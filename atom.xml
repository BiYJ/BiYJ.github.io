<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-16T01:18:32.131Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片处理</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E9%9F%B3%E8%A7%86%E9%A2%91/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS音视频/图片处理/</id>
    <published>2019-09-16T01:18:32.131Z</published>
    <updated>2019-09-16T01:18:32.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ImageMagick"><a href="#一、ImageMagick" class="headerlink" title="一、ImageMagick"></a>一、ImageMagick</h2><p>使用 <a href="http://www.imagemagick.org/" target="_blank" rel="noopener">ImageMagick</a> 对 png 图片做轻量压缩（基本没有减少体积），不损失图片质量，会改变图片文件 hash 值。方法：</p><ol><li><p>安装 ImageMagick  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install imagemagick</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>压缩工程目录下所有 png 文件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -iname &quot;*.png&quot; -exec echo &#123;&#125; \; -exec convert &#123;&#125; &#123;&#125; \;</span><br></pre></td></tr></table></figure></li></ol><p>其他用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">更改文件类型</span><br><span class="line">$ convert input.jpg output.png    // 增加有色边</span><br><span class="line"></span><br><span class="line">$ convert -bordercolor red -border 25x25 image.jpg image.gif  // 加亮或变暗图片边缘，以增强3D效果</span><br><span class="line"></span><br><span class="line">$ convert -raise 25 image.jpg image.gif  // 在图片周围增加装饰性框架。</span><br><span class="line"></span><br><span class="line">$ convert -mattecolor gray -frame 25x25 image.jpg image.gif   // 在图片边缘增加升、降斜角</span><br><span class="line"></span><br><span class="line">$ convert -mattecolor gray -frame 25x25+0+25 image.jpg image.gif</span><br><span class="line">$ convert -mattecolor gray -frame 25x25+25+0 image.jpg image.gif   // 将 gif 文件分析为一系列的单个图片</span><br><span class="line"></span><br><span class="line">$ convert animation.gif frame%02d.gif   // 创建一张空白图片</span><br><span class="line"></span><br><span class="line">$ convert -size 800x600 xc:&quot;#ddddff&quot; ltblue.ppm</span><br><span class="line">$ convert -size 800x600 null:white white.ppm</span><br><span class="line">$ convert in.png -threshold 100% black.ppm  // 与 in.png 同大小</span><br></pre></td></tr></table></figure><p>Mac：文件校验终端命令查看文件哈希值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`MD5`</span><br><span class="line">$ md5 文件路径</span><br><span class="line"></span><br><span class="line">`SHA1`</span><br><span class="line">$ shasum 文件路径 </span><br><span class="line">或者</span><br><span class="line">$ openssl dgst -sha1 文件路径</span><br><span class="line"></span><br><span class="line">`SHA256`</span><br><span class="line">$ openssl dgst -sha256 文件路径</span><br></pre></td></tr></table></figure><h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://www.jianshu.com/p/587c85229a4c" target="_blank" rel="noopener">iOS 马甲包（一）图片轻量级压缩改变 hash 值</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、ImageMagick&quot;&gt;&lt;a href=&quot;#一、ImageMagick&quot; class=&quot;headerlink&quot; title=&quot;一、ImageMagick&quot;&gt;&lt;/a&gt;一、ImageMagick&lt;/h2&gt;&lt;p&gt;使用 &lt;a href=&quot;http://www.ima
      
    
    </summary>
    
      <category term="iOS音视频" scheme="http://yoursite.com/categories/iOS%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Premultiplied Alpha</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E9%9F%B3%E8%A7%86%E9%A2%91/Premultiplied%20Alpha/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS音视频/Premultiplied Alpha/</id>
    <published>2019-09-16T01:18:32.130Z</published>
    <updated>2019-09-16T01:18:32.130Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode 的工程选项里有一项 Compress PNG Files，会对 PNG 进行 Premultiplied Alpha。游戏开发中会更加关注这个格式，省一些运行时计算。</p><p>Premultiplied Alpha 是什么呢？</p><p><a href="https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre" target="_blank" rel="noopener">Alpha Blending: To Pre or Not To Pre</a> 这篇文章其实说的很清楚。还有《Real Time Rendering》</p><h2 id="一、Alpha-Blending"><a href="#一、Alpha-Blending" class="headerlink" title="一、Alpha Blending"></a>一、Alpha Blending</h2><p>要搞清楚这个问题，先得理解 Alpha 通道的工作原理。</p><p>最常见的像素表示格式是 RGBA8888 即 （r, g, b, a），每个通道 8 位，0~255。例如红色 60% 透明度就是（255, 0, 0, 153），为了表示方便，alpha 通道一般记成正规化后的 0~1 的浮点数，也就是（255, 0, 0, 0.6）。而 Premultiplied Alpha 则是把 RGB 通道乘以透明度也就是（r <em> a, g </em> a, b * a, a），50% 透明红色就变成了（153, 0, 0, 0.6）。</p><p><a href="https://www.baidu.com/s?wd=%E9%80%8F%E6%98%8E%E9%80%9A%E9%81%93&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">透明通道</a>在渲染的时候通过 Alpha Blending 产生作用，如果一个透明度为 a<sub>s</sub> 的颜色 C<sub>s</sub> 渲染到颜色 C<sub>d</sub> 上，混合后的颜色通过以下公式计算：</p><p>C<sub>o</sub> = a<sub>s</sub>C<sub>s</sub> + (1 − a<sub>s</sub>)C<sub>d</sub></p><p>以 60% 透明的红色渲染到白色背景为例：</p><p>C<sub>o</sub> = (255, 0, 0) * 0.6 + (255, 255, 255) *(1 − 0.6) = (255, 102, 102)</p><p>也就是说，从视觉上（255, 0, 0, 0.6）渲染到白色背景上和（255, 102, 102）是同一个颜色。如果颜色以 Premultiplied Alpha 形式存储，也就是 C<sub>s</sub> 已经乘以透明度了，所以混合公式变成了：</p><p>C<sub>o</sub> = C<sub>s</sub>′ + (1 − a<sub>s</sub>)C<sub>d</sub></p><h2 id="二、为什么要-Premultiplied-Alpha？"><a href="#二、为什么要-Premultiplied-Alpha？" class="headerlink" title="二、为什么要 Premultiplied Alpha？"></a>二、为什么要 Premultiplied Alpha？</h2><p>Premultiplied Alpha 后的像素格式变得不直观，因为在画图的时候都是先从调色板中选出一个 RGB 颜色，再单独设置透明度，如果 RGB 乘以透明度就搞不清楚原色是什么了。从前面的 Alpha Blending 公式可以看出，Premultiplied Alpha 之后，混合的时候可以<font color="#cc0000">少一次乘法，这可以提高一些效率</font>，但这并不是最主要的原因。最主要的原因是：</p><p><font color="#cc0000">没有 Premultiplied Alpha 的纹理无法进行 Texture Filtering</font>（除非使用最近邻插值）。</p><p>以最常见的 filtering 方式线性插值为例，一个宽 2px 高 1px 的图片，左边的像素是红色，右边是绿色 10% 透明度，如果把这个图片缩放到 1x1 的大小，那么缩放后 1 像素的颜色就是左右两个像素线性插值的结果，也就是把两个像素各个通道加起来除以2。如果使用没有 Premultiplied Alpha 的颜色进行插值，那么结果就是：</p><p>((255, 0, 0, 1) + (0, 255, 0, 0.1)) * 0.5 = (127, 127, 0, 0.55)</p><p>如果绿色 Premultiplied Alpha，也就是（0, 255 * 0.1, 0, 0.1），和红色混合后：</p><p>((255, 0, 0, 1) + (0, 25, 0, 0.1)) * 0.5 = (127, 25, 0, 0.55)</p><p>Premultiplied Alpha 最重要的意义是<font color="#cc0000">使得带透明度图片纹理可以正常的进行线性插值</font>。这样旋转、缩放或者非整数的纹理坐标才能正常显示，否则就会像上面的例子一样，在透明像素边缘附近产生奇怪的颜色。</p><h2 id="三、纹理处理"><a href="#三、纹理处理" class="headerlink" title="三、纹理处理"></a>三、纹理处理</h2><p>我们使用的 PNG 图片纹理，一般是不会 Premultiplied Alpha 的。游戏引擎在载入 PNG 纹理后会手动处理，然后再 glTexImage2D 传给 GPU，比如 Cocos2D-x 中的 CCImage::premultipliedAlpha：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Image::premultipliedAlpha() &#123;</span><br><span class="line">    unsigned int* fourBytes = (unsigned int*)_data;</span><br><span class="line">    for (int i = 0; i &lt; _width * _height; i++) &#123;</span><br><span class="line">        unsigned char* p = _data + i * 4;</span><br><span class="line">        fourBytes[i] = CC_RGB_PREMULTIPLY_ALPHA(p[0], p[1], p[2], p[3]);</span><br><span class="line">    &#125;  </span><br><span class="line">    _hasPremultipliedAlpha = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 GPU 专用的纹理格式，比如 PVR、ETC 一般在生成纹理都是默认 Premultiplied Alpha 的，这些格式一般是 GPU 硬解码，引擎用 CPU 处理会很慢。</p><p>总之 glTexImage2D 传给 GPU 的纹理数据最好都是 Multiplied Alpha 的，要么在生成纹理时由纹理工具 Pre-multiplied，要么载入纹理后由游戏引擎或 UI 框架 Post-multiplied。</p><h2 id="四、iOS-中的-Premultiplied-Alpha"><a href="#四、iOS-中的-Premultiplied-Alpha" class="headerlink" title="四、iOS 中的 Premultiplied Alpha"></a>四、iOS 中的 Premultiplied Alpha</h2><p>Core Graphics 的 CGImage.h 对图像透明度信息有如下定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_ENUM(uint32_t, CGImageAlphaInfo)&#123;</span><br><span class="line">    // ...</span><br><span class="line">    /* For example, premultiplied RGBA */</span><br><span class="line">    kCGImageAlphaPremultipliedLast, </span><br><span class="line">    /* For example, premultiplied ARGB */ </span><br><span class="line">    kCGImageAlphaPremultipliedFirst, </span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>预乘透明度（Premultiplied Alpha<strong>）</strong>图像简单地说，即每个颜色分量都乘以 alpha 通道值作为结果值：</p><pre><code>color.rgb *= color.alpha</code></pre><p>为什么关注预乘透明度图像？微信团队因 AR 抢红包场景的 OpenGL 混色结果出错引起注意。</p><blockquote><p>Premultiplied alpha is better than conventional blending for several reasons:</p><p>It works properly when filtering alpha cutouts _(see below)_</p><p>It works properly when doing image composition _(stay tuned for my next post)_</p><p>It is a superset of both conventional and additive blending. If you set alpha to zero while RGB is non zero, you get an additive blend. This can be handy for particle systems that want to smoothly transition from additive glowing sparks to dark pieces of soot as the particles age.</p><p>It plays nice with <a href="https://link.jianshu.com?t=http://blogs.msdn.com/shawnhar/archive/2008/10/28/texture-compression.aspx" target="_blank" rel="noopener">DXT compression</a>, which only supports transparent pixels with an RGB of zero.</p><p>摘自：<a href="https://link.jianshu.com?t=https://blogs.msdn.microsoft.com/shawnhar/2009/11/06/premultiplied-alpha/" target="_blank" rel="noopener">Premultiplied alpha</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xcode 的工程选项里有一项 Compress PNG Files，会对 PNG 进行 Premultiplied Alpha。游戏开发中会更加关注这个格式，省一些运行时计算。&lt;/p&gt;
&lt;p&gt;Premultiplied Alpha 是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
      <category term="iOS音视频" scheme="http://yoursite.com/categories/iOS%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>添加垃圾代码</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E6%9E%B6%E6%9E%84/%E5%9E%83%E5%9C%BE%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS架构/垃圾代码/</id>
    <published>2019-09-16T01:18:32.129Z</published>
    <updated>2019-09-16T01:18:32.129Z</updated>
    
    <content type="html"><![CDATA[<p>方式 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># _*_ coding:utf-8 _*_</span><br><span class="line">#第一步:首先生成一个500位的数组 驼峰类型的元素 用作文件名 eg:AsdfdfGsd</span><br><span class="line">import random</span><br><span class="line">import os,sys</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">first = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line">second = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">number = &quot;345&quot;</span><br><span class="line">index = 0</span><br><span class="line">array = [\]</span><br><span class="line">for i in range(500):</span><br><span class="line">    final=(random.choice(first))</span><br><span class="line">    index = random.randint(3, 5)</span><br><span class="line">    for i in range(index):</span><br><span class="line">        final+=(random.choice(second))</span><br><span class="line">    final += (random.choice(first))</span><br><span class="line">    for i in range(index):</span><br><span class="line">        final+=(random.choice(second))</span><br><span class="line">    array.append(final)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print (array)</span><br><span class="line"></span><br><span class="line">#第二步:</span><br><span class="line">#用上边生成的数组来创建对应的.h和.m文件</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import random</span><br><span class="line">import os</span><br><span class="line">import string</span><br><span class="line">#创建.h文件</span><br><span class="line">def text_createH(fileNmae,msg,msg1,propertyNumber,methodArray,msg3):</span><br><span class="line">    full_path = sys.path[0] + &apos;/ReplaceDemo/&apos; + fileNmae + &apos;.h&apos;</span><br><span class="line">    file = open(full_path, &apos;w&apos;)</span><br><span class="line">    file.write(&apos;//\n//  &apos;+fileNmae+&apos;.h\n//  SajiaoShopping\n\n//  Created by 某 波 bo on 15/10/23.\n//  Copyright ©  2017年 阿里郎. All rights reserved.\n//\n\n&apos;)</span><br><span class="line">    file.write(msg)</span><br><span class="line">    file.write(msg1)</span><br><span class="line">    propryNameArray = []</span><br><span class="line">    for index in range(1,propertyNumber):</span><br><span class="line">        propryNameArray.append(random.choice(array))</span><br><span class="line">    propryNameArray = list(set(propryNameArray))</span><br><span class="line">    for propertyName in propryNameArray:</span><br><span class="line">        file.write(&apos;@property(nonatomic,strong)&apos;+random.choice(classArray)+&apos; * &apos;+propertyName+&apos;;\n&apos;)</span><br><span class="line">    file.write(&apos;\n\n&apos;)</span><br><span class="line">    for methodName in methodArray:</span><br><span class="line">        file.write(&apos;- (void)pushTo&apos;+methodName+&apos;VC:(NSDictionary *)info;\n&apos;)</span><br><span class="line">    file.write(msg3)</span><br><span class="line">    file.close()</span><br><span class="line">    print(&apos;Done&apos;)</span><br><span class="line">#创建.m文件</span><br><span class="line">def text_createM(fileNmae,msg,msg1,methodArray,msg3):</span><br><span class="line">    full_path = sys.path[0] + &apos;/ReplaceDemo/&apos; + fileNmae + &apos;.m&apos;</span><br><span class="line">    file = open(full_path, &apos;w&apos;)</span><br><span class="line">    file.write(&apos;//\n//  &apos;+fileNmae+&apos;.m\n//  SajiaoShopping\n\n//  Created by 某 波 bo on 15/10/23.\n//  Copyright ©  2017年 阿里郎. All rights reserved.\n//\n\n&apos;)</span><br><span class="line">    file.write(msg)</span><br><span class="line">    file.write(msg1)</span><br><span class="line">    for methodName in methodArray:</span><br><span class="line">        file.write(&apos;- (void)pushTo&apos;+methodName+&apos;VC:(NSDictionary *)info\n&#123;\n\n  NSMutableArray *array = [NSMutableArray array];\n&apos;)</span><br><span class="line">        number = random.randint(3, 10)</span><br><span class="line">        for i in range(1,number):</span><br><span class="line">            file.write(&apos;  [array addObject:@&quot;&apos;+random.choice(array)+&apos;&quot;];\n&apos;)</span><br><span class="line">        file.write(&apos;\n&#125;\n\n&apos;)</span><br><span class="line">    file.write(msg3)</span><br><span class="line">    file.close()</span><br><span class="line">    print(&apos;Done&apos;)</span><br><span class="line"></span><br><span class="line">classArray = [&apos;NSString&apos;,&apos;UILabel&apos;,&apos;NSDictionary&apos;,&apos;NSData&apos;,&apos;UIScrollView&apos;,&apos;UIView&apos;]</span><br><span class="line">array = [&apos;HwxrFvrj&apos;, &apos;QnzduQbtdd&apos;, &apos;PvcrwLtqhf&apos;, &apos;UvdhDbjn&apos;, &apos;SuntmyTxvyzg&apos;, &apos;CvlxwBipbp&apos;, &apos;GzrdyzIbimvz&apos;, &apos;CqsjqMmgsp&apos;, &apos;OxaaeuWjhasc&apos;, &apos;NjiardRvwgbi&apos;, &apos;NcculmLtpljq&apos;, &apos;ApoqQrll&apos;, &apos;GkgokDyvjb&apos;, &apos;EblldkVouplj&apos;, &apos;KfdrFvnw&apos;, &apos;SfhyhObftc&apos;, &apos;SmruByoc&apos;, &apos;YzcccvXmpmit&apos;, &apos;OmqvaHpxat&apos;, &apos;XzytsUyvyd&apos;, &apos;MjforNnnyi&apos;, &apos;ZvjhuIdogs&apos;, &apos;BzfrxzSeahxc&apos;, &apos;PycycwFjtpny&apos;, &apos;XvngtoSedljr&apos;, &apos;DktiaCbucd&apos;, &apos;AqbplNuodc&apos;, &apos;MzkvgZuala&apos;, &apos;KdwzIoej&apos;, &apos;AaynatUpqcfd&apos;, &apos;IyvwhZvtjc&apos;, &apos;UmijGmsy&apos;, &apos;AoayndXxghym&apos;]</span><br><span class="line">array = list(set(array))</span><br><span class="line"></span><br><span class="line">for name in array:</span><br><span class="line">    number = random.randint(3, 10)</span><br><span class="line">    methodArray = []</span><br><span class="line">    for i in range(1,5):</span><br><span class="line">        methodArray.append(random.choice(array))</span><br><span class="line">    methodArray = list(set(methodArray))#数组去重</span><br><span class="line">    text_createH(name+&apos;ViewController&apos;, &apos;#import &lt;UIKit/UIKit.h&gt;\n&apos;,&apos;@interface &apos;+name+ &apos;ViewController:&apos;+ &apos;UIViewController\n\n&apos;,number,methodArray,&apos;\n\n@end&apos;)</span><br><span class="line">    text_createM(name+&apos;ViewController&apos;, &apos;#import &quot;&apos;+name+&apos;ViewController.h&quot;\n\n&apos; &apos;@interface &apos;+ name+&apos;ViewController()\n\n @end\n\n&apos;,&apos;@implementation &apos;+name+&apos;ViewController\n\n- (void)viewDidLoad &#123; \n\n [super viewDidLoad];\n\n&#125;\n\n&apos;,methodArray,&apos;\n\n@end&apos;)</span><br></pre></td></tr></table></figure><p>full_path 代表垃圾文件生成路径，第一次 file.write 的是类的注释，包含工程名、类名、作者，这种方式生成的内容无意义，所以很可能过不了审核。<a href="https://blog.csdn.net/qq_34716474/article/details/83151659#OC_51" target="_blank" rel="noopener">脚本原文</a></p><p>方式 2：</p><p>使用 <a href="https://github.com/klaus01/KLGenerateSpamCode" target="_blank" rel="noopener">KLGenerateSpamCode</a> 扫描工程中的代码，生成同等数量的 Category 文件，文件中即是同等方法数量的垃圾代码。</p><p>KLGenerateSpamCode 工程 -> Edit scheme -&gt; Run -&gt; Arguments Passed On Launch 添加。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c18ebda447160533.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Trash 是放垃圾代码的文件夹，trash 是分类名。</p><p>或者用终端执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./GenerateSpamCode /Users/CJ/Desktop/ReplaceDemo/ReplaceDemo -spamCodeOut /Users/CJ/Desktop/Trash trash</span><br></pre></td></tr></table></figure><p>第一条路径是马甲包工程，第二条路径是存放垃圾代码目录路径。</p><p>两种方式都会自动在指定路径下生成 Trash 文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;方式 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>pthread_rwlock_t</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/pthread_rwlock_t/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS多线程/pthread_rwlock_t/</id>
    <published>2019-09-16T01:18:32.129Z</published>
    <updated>2019-09-16T01:18:32.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、读写锁"><a href="#一、读写锁" class="headerlink" title="一、读写锁"></a>一、读写锁</h2><p>读写锁实际是一种特殊的<font color="#cc0000">自旋锁</font>，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。</p><p><font color="#cc0000">读操作可以共享，写操作是排他的</font>，可以有多个在读（与 CPU 数相关），只能有唯一个在写，但不能同时既有读者又有写者。</p><p>如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。</p><p>具有强读者同步和强写者同步两种形式：</p><ul><li><p>强读者同步：当写者没有进行写操作，读者就可以访问；</p></li><li><p>强写者同步：当所有写者都写完之后，才能进行读操作。</p></li></ul><p>在强写者情况，读者需要最新的信息，一些事实性较高的系统可能会用到该锁，比如定票之类的。</p><h2 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h2><p><font color="#cc0000">一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁</font>。</p><p>正因为这个特性，当读写锁是写加锁状态时，在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被<font color="#cc0000">阻塞</font>。</p><p>当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁，它必须直到所有的线程释放锁。</p><p>通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，<font color="#cc0000">读写锁通常会阻塞随后的读模式锁请求</font>，这样可以<font color="#cc0000">避免读模式锁长期占用</font>，而等待的写模式锁请求长期阻塞.</p><p>读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享，以写模式锁住时意味着独占，所以读写锁又叫共享-独占锁。</p><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><ol><li><p>互斥锁与读写锁的区别</p><p> 当访问临界区资源时（访问的含义包括所有的操作：读和写），需要上互斥锁；</p><p> 当对数据（互斥锁中的临界区资源）进行读取时，需要上读取锁，当对数据进行写入时，需要上写入锁。</p></li><li><p>读写锁的优点</p><p> 对于读数据比修改数据频繁的应用，用读写锁代替互斥锁可以提高效率。因为使用互斥锁时，即使是读出数据（相当于操作临界区资源）都要上互斥锁，而采用读写锁，则可以在任一时刻允许多个读者存在，提供了更高的并发度，同时在某个写入者修改数据期间保护该数据，以免任何其它读出者或写入者的干扰。</p></li><li><p>读写锁描述：</p><p> 获取一个读写锁用于读称为共享锁，获取一个读写锁用于写称为独占锁，因此这种对于某个给定资源的共享访问也称为共享-独占上锁。</p></li></ol><h2 id="四、使用读写锁"><a href="#四、使用读写锁" class="headerlink" title="四、使用读写锁"></a>四、使用读写锁</h2><p>配置读写锁的属性之后，即可初始化读写锁。以下函数用于初始化或销毁读写锁、锁定或解除锁定读写锁或尝试锁定读写锁。</p><ol><li><p>初始化读写锁</p><p> 使用 pthread_rwlock_init(3C) 通过 attr 所引用的属性初始化 rwlock 所引用的读写锁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param  attr  如果为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同</span><br><span class="line"> *</span><br><span class="line"> * @return  如果成功，返回 0，否则将返回用于指明错误的错误号。 EINVAL : attr 或者 rwlock 指定的值无效 </span><br><span class="line"> */</span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure><p> 如果 attr 为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同。</p><p> 初始化读写锁之后，该锁可以<font color="#cc0000">使用任意次数</font>，而无需重新初始化。成功初始化之后，读写锁的状态会变为<font color="#cc0000">已初始化和未锁定</font>。如果调用 pthread_rwlock_init() 来指定已初始化的读写锁，则结果是不确定的。如果读写锁在使用之前未初始化，则结果是不确定的。</p><p> 如果缺省的读写锁属性适用，则 PTHREAD_RWLOCK_INITIALIZER 宏可初始化<font color="#cc0000">以静态方式分配的读写锁</font>，其作用与通过调用pthread_rwlock_init() 并将参数 attr 指定为 NULL 进行动态初始化等效，区别在于<font color="#cc0000">不会执行错误检查</font>。</p><p> 如果 pthread_rwlock_init() 失败，将不会初始化 rwlock，并且 rwlock 的内容是不确定的。</p></li><li><p>获取读写锁中的读锁</p><p> pthread_rwlock_rdlock(3C) 可用来向 rwlock 所引用的读写锁应用读锁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return  如果成功，返回 0。否则，将返回用于指明错误的错误号。 EINVAL : attr 或 rwlock 指定的值无效</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">int  pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure><p> 如果写入器未持有读锁，并且没有任何写入器基于该锁阻塞，则调用线程会获取读锁。如果写入器未持有读锁，但有多个写入器正在等待该锁时，<font color="#cc0000">调用线程是否能获取该锁是不确定的</font>。如果某个写入器持有读锁，则调用线程无法获取该锁。如果调用线程未获取读锁，则它将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_rdlock() 返回。如果在进行调用时，调用线程持有 rwlock 中的写锁，则结果是不确定的。</p><p> 为避免写入器资源匮乏，允许在多个实现中使<font color="#cc0000">写入器的优先级高于读取器</font>。</p><p> 一个线程可以在 rwlock 中持有多个并发的读锁，该线程可以成功调用 pthread_rwlock_rdlock() n 次。该线程必须调用 pthread_rwlock_unlock() n 次才能执行匹配的解除锁定操作。</p><p> 如果针对未初始化的读写锁调用 pthread_rwlock_rdlock()，则结果是不确定的。</p><p> 线程信号处理程序可以处理传送给等待读写锁的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行读取，就好像线程未中断一样。</p></li><li><p>读取非阻塞读写锁中的锁</p><p> pthread_rwlock_tryrdlock(3C)应用读锁的方式与 pthread_rwlock_rdlock() 类似，区别在于如果任何线程持有 rwlock 中的写锁或者写入器基于 rwlock 阻塞，则 pthread_rwlock_tryrdlock() 函数会失败。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行读取的锁，返回 0。否则，返回用于指明错误的错误号</span><br><span class="line"> *</span><br><span class="line"> *         EBUSY : 无法获取读写锁以执行读取，因为写入器持有该锁或者基于该锁已阻塞</span><br><span class="line"> */</span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure></li><li><p>写入读写锁中的锁</p><p> pthread_rwlock_wrlock(3C) 可用来向 rwlock 所引用的读写锁应用写锁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return  如果获取了用于在 rwlock 所引用的读写锁对象中执行写入的锁，返回 0。否则，返回指明错误的错误号</span><br><span class="line"> */</span><br><span class="line">int  pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</span><br></pre></td></tr></table></figure><p> 如果没有其他读取器线程或写入器线程持有读写锁 rwlock，则调用线程将获取写锁，否则，调用线程将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_wrlock() 调用返回。如果在进行调用时，调用线程持有读写锁（读锁或写锁），则结果是不确定的。</p><p> 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。</p><p> 如果针对未初始化的读写锁调用 pthread_rwlock_wrlock()，则结果是不确定的。</p><p> 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。</p></li><li><p>写入非阻塞读写锁中的锁</p><p> pthread_rwlock_trywrlock(3C)应用写锁的方式与 pthread_rwlock_wrlock() 类似，区别在于如果任何线程当前持有用于读取和写入的 rwlock，则pthread_rwlock_trywrlock() 函数会失败。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return  如果获取了用于在 rwlock 引用的读写锁对象中执行写入的锁，则返回 0，否则，返回用于指明错误的错误号</span><br><span class="line"> *          EBUSY : 无法为写入获取读写锁，因为已为读取或写入锁定该读写锁</span><br><span class="line"> */</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t  *rwlock);</span><br></pre></td></tr></table></figure><p> 如果针对未初始化的读写锁调用 pthread_rwlock_trywrlock()，则结果是不确定的。</p><p> 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。</p></li><li><p>解除锁定读写锁</p><p> pthread_rwlock_unlock(3C) 可用来释放在 rwlock 引用的读写锁对象中持有的锁。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  @return 如果成功返回 0，否则返回用于指明错误的错误号</span><br><span class="line"> */</span><br><span class="line">int pthread_rwlock_unlock (pthread_rwlock_t  *rwlock);</span><br></pre></td></tr></table></figure><p> 如果调用线程未持有读写锁 rwlock，则结果是不确定的。</p><p> 如果通过调用 pthread_rwlock_unlock() 来释放读写锁对象中的读锁，并且其他读锁当前由该锁对象持有，则该对象会保持读取锁定状态。如果 pthread_rwlock_unlock() 释放了调用线程在该读写锁对象中的最后一个读锁，则调用线程不再是该对象的属主。如果 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个读锁，则该读写锁对象将处于<font color="#cc0000">无属主、解除锁定状态</font>。</p><p> 如果通过调用 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个写锁，则该读写锁对象将处于无属主、解除锁定状态。</p><p> 如果 pthread_rwlock_unlock() 解除锁定该读写锁对象，并且多个线程正在等待获取该对象以执行写入，则通过调度策略可确定获取该对象以执行写入的线程。如果多个线程正在等待获取读写锁对象以执行读取，则通过调度策略可确定等待线程获取该对象以执行写入的顺序。<font color="#cc0000">如果多个线程基于 rwlock 中的读锁和写锁阻塞，则无法确定读取器和写入器谁先获得该锁</font>。</p><p> 如果针对未初始化的读写锁调用 pthread_rwlock_unlock()，则结果是不确定的。</p></li><li><p>销毁读写锁</p><p> pthread_rwlock_destroy(3C) 可用来销毁 rwlock 引用的读写锁对象并释放该锁使用的任何资源。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return  如果成功，返回 0。否则，返回用于指明错误的错误号。EINVAL : attr 或者 rwlock 指定的值无效 </span><br><span class="line"> */</span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</span><br><span class="line"></span><br><span class="line">pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure></li></ol><p>再次调用 pthread_rwlock_init() 重新初始化该锁之前，使用该锁所产生的影响是不确定的。实现可能会导致 pthread_rwlock_destroy() 将 rwlock 所引用的对象设置为无效值。如果在任意线程持有 rwlock 时调用 pthread_rwlock_destroy()，则结果是不确定的。尝试销毁未初始化的读写锁会产生不确定的行为。已销毁的读写锁对象可以使用 pthread_rwlock_init() 来重新初始化。销毁读写锁对象之后，如果以其他方式引用该对象，则结果是不确定的。</p><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://baike.baidu.com/item/%E8%AF%BB%E5%86%99%E9%94%81/1756708" target="_blank" rel="noopener">百度百科</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、读写锁&quot;&gt;&lt;a href=&quot;#一、读写锁&quot; class=&quot;headerlink&quot; title=&quot;一、读写锁&quot;&gt;&lt;/a&gt;一、读写锁&lt;/h2&gt;&lt;p&gt;读写锁实际是一种特殊的&lt;font color=&quot;#cc0000&quot;&gt;自旋锁&lt;/font&gt;，它把对共享资源的访问者划分成
      
    
    </summary>
    
      <category term="iOS多线程" scheme="http://yoursite.com/categories/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD实现</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS多线程/GCD实现/</id>
    <published>2019-09-16T01:18:32.128Z</published>
    <updated>2019-09-16T01:18:32.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Dispatch-Queue"><a href="#一、Dispatch-Queue" class="headerlink" title="一、Dispatch Queue"></a>一、Dispatch Queue</h2><p>不难想象 GCD 的实现需要使用以下这些工具。</p><p>①、用于管理追加的 Block 的 C 语言层实现的 <font color="#cc0000">FIFO 队列</font>；</p><p>②、Atomic 函数中实现的用于排他控制的<font color="#cc0000">轻量级信号</font>；</p><p>③、用于管理线程的 C 语言层实现的<font color="#cc0000">一些容器</font>。</p><p>但如果只用了这些内容便可实现，那么就不需要内核级的实现了。官方说明：</p><blockquote><p>通常，应用程序中编写的线程管理用的代码要在系统级实现。</p></blockquote><p>在系统（iOS 和 OS X 的核心 XNU 内核）级上的实现。因此，无论编程人员如何努力编写管理线程的代码，在性能方面都不可能超过 XNU 内核级所实现的 GCD。</p><p>使用 GCD 不必编写线程的创建、销毁等管理代码，而可以在线程中集中实现处理内容。我们应该尽量多使用 GCD 或者使用了 Cocoa 框架 GCD 的 NSOperationQueue 类等 API。</p><p>用于实现 Dispatch Queue 而使用的软件组件。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-76ca86d8be6976a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br></center><p>编程人员所使用的 GCD 的 API 全部为包含在 libdispatch 库的 C 语言函数。Dispatch Queue 通过<font color="#cc0000">结构体和链表</font>，被实现为 FIFO 队列。FIFO 队列管理通过 dispatch_async 等函数所追加的 block。</p><p>Block 并不直接加入  FIFO 队列，而是先加入 Dispatch Continuation 这一个 <font color="#cc0000">dispatch_continuation_t</font> 类型结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记录 Block 所属的 Dispatch Group 和一些其他信息，相当于一般常说的上下文。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-7320d9613aed8c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br></center><p>Dispatch Queue 可通过 <font color="#cc0000">dispatch_set_target_queue</font> 函数设定执行该 Dispatch Queue 处理的 Dispatch Queue 为目标。该目标可像串珠子一样，设定多个连接在一起的 Dispatch Queue。但是在连接串的最后必须设定为 Main Dispatch Queue 或各种优先级的 Global Dispatch Queue，或者准备用于 Serial Dispatch Queue 的各种优先级的 Global Dispatch Queue。</p><p>Global Dispatch Queue 有 8 种：</p><ul><li>Global Dispatch Queue（High Priority）</li><li>Global Dispatch Queue（Default Priority）</li><li>Global Dispatch Queue（Low Priority）</li><li>Global Dispatch Queue（Background Priority）</li><li>Global Dispatch Queue（High Overcommit Priority）</li><li>Global Dispatch Queue（Default Overcommit Priority）</li><li>Global Dispatch Queue（Low Overcommit Priority）</li><li>Global Dispatch Queue（Background Overcommit Priority）</li></ul><p>优先级带有 <font color="#cc0000">Overcommit</font> 的 Global Dispatch Queue 使用在 Serial Dispatch Queue 中。如 Overcommit 这个名称所示，不管系统状态如何，都会<font color="#cc0000">强制生成</font>线程的 Dispatch Queue。</p><p>这 8 种 Global Dispatch Queue 各使用 1 个 pthread_workqueue。GCD 初始化时，使用 <font color="#cc0000">pthread_workqueue_create_np</font> 函数生成 pthread_workqueue。</p><p>pthread_workqueue 包含在 Libc 提供的 pthreads API 中。其使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-816faa7ca4c6ff96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br></center><p>XNU 内核持有 4 种 workqueue：</p><ul><li>WORKQUEUE_HIGH_PRIOQUEUE</li><li>WORKQUEUE_DEFAULT_PRIOQUEUE</li><li>WORKQUEUE_LOW_PRIOQUEUE</li><li>WORKQUEUE_BG_PRIOQUEUE</li></ul><p>该执行优先级和 Global Dispatch Queue 的 4 种优先级相同。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-6e6083b134f2f075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"><br></center><p>当在 Global Dispatch Queue 中执行 Block 时，libdispatch 从 Global Dispatch Queue 自身的 FIFO 队列取出 Dispatch Continuation，调用 pthread_workqueue_additem_np 函数，把该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数。</p><p>pthread_workqueue_additem_np 函数使用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目。根据该通知，XNU 内核基于系统状态判断是否要生成线程。如果是 Overcommit 优先级的 Global Dispatch Queue，workqueue 则始终生成线程。</p><p>该线程虽然与 iOS 和 OS X 中通常使用的线程大致相同，但是有一部分 pthread API 不能使用。详见苹果官方文档《并行编码指南》的“与 POSIX 线程的互换性”。</p><p>另外，因为 workqueue 生成的线程在实现用于 workqueue 的线程计划表中运行，所以与一般线程的上下文切换不同。</p><p>workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数。在该回调函数中执行加入到 Dispatch Continuation 的 Block。</p><p>Block 执行结束后，进行通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备执行加入到 Global Dispatch Queue 中的下一个 Block。</p><p>总结：</p><p>①、block、block 所属的 group、其他信息加入的 dispatch_continuation_t 结构体中；</p><p>②、将 dispatch_continuation_t 加入 FIFO 队列；</p><p>③、Dispatch_Queue 通过 dispatch_set_target_queue 设置目标 Queue；</p><p>④、GCD 初始化时，pthread_workqueue_create_np 生成 pthread_workqueue;</p><p>⑤、pthread_workqueue 使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息；</p><p>⑥、当在 Global Dispatch Queue 执行 Block 时 libdispatch 从 FIFO 队列中取出 Dispatch Continuation；</p><p>⑦、调用 pthread_workqueue_additem_np 函数，将该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数；</p><p>⑧、pthread_workqueue_additem_np 内部调用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目；</p><p>⑨、XNU 内核基于系统状态判断是否要生成线程；</p><p>⑩、workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数，在该回调函数中执行加入到 Dispatch Continuation 的 Block。Block 执行结束后，通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备下一个 Block 的执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Dispatch-Queue&quot;&gt;&lt;a href=&quot;#一、Dispatch-Queue&quot; class=&quot;headerlink&quot; title=&quot;一、Dispatch Queue&quot;&gt;&lt;/a&gt;一、Dispatch Queue&lt;/h2&gt;&lt;p&gt;不难想象 GCD 的实现需要
      
    
    </summary>
    
      <category term="iOS多线程" scheme="http://yoursite.com/categories/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS多线程/GCD/</id>
    <published>2019-09-16T01:18:32.128Z</published>
    <updated>2019-09-16T01:18:32.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、GCD-简介"><a href="#一、GCD-简介" class="headerlink" title="一、GCD 简介"></a>一、GCD 简介</h2><blockquote><p><a href="http://baike.baidu.com/item/GCD" target="_blank" rel="noopener">百度百科</a></p><p>Grand Central Dispatch(GCD) 是 Apple 开发的<font color="#cc0000">一个多核编程的较新的解决方法</font>。在 Mac OSX 10.6 首次推出，也可在 iOS4 及以上版本使用。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。</p></blockquote><p>使用 GCD 的好处：</p><ul><li>GCD 可用于多核的并行运算</li><li>GCD 会<font color="#cc0000">自动利用</font>更多的 CPU 内核（比如双核、四核）</li><li>GCD 会<font color="#cc0000">自动管理</font>线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉 GCD 想要执行什么任务。</li></ul><h2 id="二、GCD-任务和队列"><a href="#二、GCD-任务和队列" class="headerlink" title="二、GCD 任务和队列"></a>二、GCD 任务和队列</h2><p>GCD 中两个核心概念：任务和队列。</p><h4 id="2-1-任务"><a href="#2-1-任务" class="headerlink" title="2.1 任务"></a>2.1 任务</h4><p>要执行的操作，也就是在线程中执行的那段代码。在 GCD 是放在 block 里。</p><p>执行任务有两种方式：同步执行（sync）和异步执行（async）。</p><p>主要区别：<font color="#cc0000">是否等待队列的任务执行结束，以及是否具备开启新线程的能力</font>。</p><ul><li><p>同步执行</p><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul></li><li><p>异步执行：</p><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul></li></ul><p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程，这跟任务所指定的队列类型有关。</p><h4 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h4><p>指执行任务的等待队列，即用来存放任务的队列。</p><p>队列是一种特殊的线性表，采用 <font color="#cc0000">FIFO</font>（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/1877784-01267bd211719167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="4"><br></center><p>在 GCD 中有两种队列：串行队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue）。两者都符合 FIFO（先进先出）的原则。</p><p>两者的主要区别是：执行顺序不同，以及开启线程数不同。</p><ul><li><p>串行队列：</p><ul><li>每次只执行一个任务，任务一个接一个执行。（只开启一个线程）</li></ul></li><li><p>并发队列：</p><ul><li>多个任务可以并发（同时）执行。（可以开启多个线程，并且同时执行任务）</li></ul></li></ul><p>注意：<font color="#cc0000">并发队列的并发功能只有在异步（dispatch_async）函数下才有效</font>。</p><p>两者具体区别如下图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/1877784-4faca27116209f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="5"><br><br><img src="https://upload-images.jianshu.io/upload_images/1877784-97f3931d1b187b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="6"><br></center><h2 id="三、GCD-的使用步骤"><a href="#三、GCD-的使用步骤" class="headerlink" title="三、GCD 的使用步骤"></a>三、GCD 的使用步骤</h2><p>GCD 的使用只有两步：</p><ol><li><p>创建一个队列（串行队列或并发队列）</p></li><li><p>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。</p></li></ol><h4 id="3-1-队列的创建方法-获取方法"><a href="#3-1-队列的创建方法-获取方法" class="headerlink" title="3.1 队列的创建方法/获取方法"></a>3.1 队列的创建方法/获取方法</h4><ul><li><p>使用 dispatch_queue_create 来创建队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   参数 1 : 表示队列的唯一标识符，用于 DEBUG，可以为空，推荐使用应用 BundleId 的逆序全程域名</span><br><span class="line">   参数 2 : 用于识别是串行队列、并发队列。DISPATCH_QUEUE_SERIAL:串行   DISPATCH_QUEUE_CONCURRENT:并发</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 串行队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">// 并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue）</p><ul><li><p>所有放在主队列中的任务，都会放到主线程中执行。</p></li><li><p>可使用 dispatch_get_main_queue() 获得主队列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 主队列</span><br><span class="line">dispatch\_queue\_t queue = dispatch\_get\_main_queue();</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>GCD 默认提供了全局并发队列（Global Dispatch Queue）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全局并发队列</span><br><span class="line"> * </span><br><span class="line"> * 参数 1 : 队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT</span><br><span class="line"> * 参数 2 : 暂时没用，传 0</span><br><span class="line"> */</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-任务的创建方法"><a href="#3-2-任务的创建方法" class="headerlink" title="3.2 任务的创建方法"></a>3.2 任务的创建方法</h4><p>GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 同步</span><br><span class="line">dispatch_sync(queue, ^&#123; </span><br><span class="line">    // do something</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 异步</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然使用 GCD 只需两步，但是既然有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么就有了四种不同的组合方式。这四种不同的组合方式是：</p><ol><li>同步执行 + 并发队列</li><li>异步执行 + 并发队列</li><li>同步执行 + 串行队列</li><li>异步执行 + 串行队列</li></ol><p>还有两种特殊队列：全局并发队列、主队列。因为主队列特殊，所以就又多了两种组合方式。这样就有 6 种不同的组合方式了。</p><ol start="5"><li>同步执行 + 主队列</li><li>异步执行 + 主队列</li></ol><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-c840e31e294a8e17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"><br></center><p>同步既然不会开辟新的线程，那同步阻塞的是当前线程还是当前队列？</p><font color="#cc0000">阻塞当前队列，造成线程死锁</font>。<br><br>#### 3.3 GCD 线程间的通信<br><br>在 iOS 开发过程中，通常把一些耗时的操作放在其他线程，然后在主线程进行 UI 刷新。而当有时候在其他线程完成了耗时操作时，需要回到主线程，就用到了线程之间的通讯。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 线程间通信</span><br><span class="line"> */</span><br><span class="line">- (void)communication</span><br><span class="line">&#123;</span><br><span class="line">    // 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    // 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 异步追加任务</span><br><span class="line">        for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            // 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2];          // 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">1---&lt;NSThread: 0x600000271940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">1---&lt;NSThread: 0x600000271940&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2---&lt;NSThread: 0x60000007bf80&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><br><br>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。<br><br>#### 3.4 GCD 的其他方法<br><br>##### 3.4.1 GCD 栅栏方法：dispatch_barrier_async<br><br>有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样就需要有一个相当于栅栏一样的方法<font color="#cc0000">将两组异步执行的操作组（包含一个或多个任务）给分割开来</font>。这就需要用到 dispatch_barrier_async 方法。<br><br>dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列。然后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。<br><br>具体如下图所示：<br><br><center><br><img src="https://upload-images.jianshu.io/upload_images/1877784-4d6d77fafd3ad007.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="8"><br></center><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    // 并行队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.dubinbin.Demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2222&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;barrier&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3333&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4444&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">2019-03-19 14:47:01.584536+0800 Demo[45246:3034531] end</span><br><span class="line">2019-03-19 14:47:01.584562+0800 Demo[45246:3034564] 2222</span><br><span class="line">2019-03-19 14:47:01.584566+0800 Demo[45246:3034562] 1111</span><br><span class="line">2019-03-19 14:47:01.584676+0800 Demo[45246:3034562] barrier</span><br><span class="line">2019-03-19 14:47:01.584755+0800 Demo[45246:3034562] 3333</span><br><span class="line">2019-03-19 14:47:01.584765+0800 Demo[45246:3034564] 4444</span><br></pre></td></tr></table></figure><br><br>dispatch_barrier_async 执行结果：在执行完栅栏前面的任务之后，才执行栅栏操作，最后再执行栅栏后边的任务。<br><br>##### 3.4.2 GCD 延时执行方法：dispatch_after<br><br>经常会遇到这样的需求：在指定时间（例如 3 秒）之后执行某个任务。可以用 GCD 的 dispatch_after 函数来实现。<br><br>注意：<font color="#cc0000">dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中</font>。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 函数是很有效的。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;Delay in Thread : %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">14:52:01.582676+0800  end</span><br><span class="line">14:52:06.583078+0800  Delay in Thread : &lt;NSThread: 0x600001026940&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><br><br>dispatch_after 执行结果：打印 end 之后大约 5.0 秒打印了 Delay in Thread。<br><br>##### 3.4.3 GCD 一次性代码：dispatch_once<br><br>在创建单例或者整个程序运行过程中只执行一次的代码时，就用到了 GCD 的 dispatch_once 函数。使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行 1 次，并且即使在多线程的环境下，dispatch_once 也可以保证线程安全。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // code to be executed once</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br><br>##### 3.4.4 GCD 快速迭代方法：dispatch_apply<br><br>通常是用 for 循环遍历，但是 GCD 提供了快速迭代的函数 dispatch_apply。<font color="#cc0000">dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束</font>。<br><br>如果是在串行队列（单线程）中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行，体现不出快速迭代的意义。<br><br>dispatch_apply 可以在多个线程中同时（异步）遍历多个数字。<br><br>注意：无论是串行队列，还是异步队列，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait 方法。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_apply(5, queue, ^(size_t index) &#123;</span><br><span class="line">        NSLog(@&quot;%zd---%@&quot;, index, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">1---&lt;NSThread: 0x6000031499c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">3---&lt;NSThread: 0x600003149a00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">0---&lt;NSThread: 0x600003126fc0&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2---&lt;NSThread: 0x6000031414c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">4---&lt;NSThread: 0x6000031414c0&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定，但是 end 一定在最后执行。<br><br>##### 3.4.5 GCD 队列组：dispatch_group<br><br>有时候会有这样的需求：分别异步执行 2 个耗时任务，然后当 2 个耗时任务都执行完毕后再回到主线程执行任务。这时候就可以用到 GCD 的队列组。<br><br><em>   调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合来实现。</em>   调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。<br><br><br><strong>dispatch_group_notify</strong><br><br>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 并执行。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.dubinbin.Demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^ &#123;</span><br><span class="line">        NSLog(@&quot;2222&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;group&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3333&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4444&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">2019-03-19 15:07:48.576680+0800 Demo[45472:3045696] end</span><br><span class="line">2019-03-19 15:07:48.576680+0800 Demo[45472:3045738] 2222</span><br><span class="line">2019-03-19 15:07:48.576687+0800 Demo[45472:3045736] 1111</span><br><span class="line">2019-03-19 15:07:48.576702+0800 Demo[45472:3045735] 4444</span><br><span class="line">2019-03-19 15:07:51.580427+0800 Demo[45472:3045737] 3333</span><br><span class="line">2019-03-19 15:07:51.580874+0800 Demo[45472:3045737] group</span><br></pre></td></tr></table></figure><br><br>dispatch_group_notify 运行结果：当所有任务都执行完成之后，才执行 dispatch_group_notify block 中的任务。<br><br>注意：barrier 和 group 的区别，<font color="#cc0000">barrier 只等待之前的任务执行完，group 需要等待加入到 group 中所有的任务执行完</font>。<br><br><strong>dispatch_group_wait</strong><br><br>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.dubinbin.Demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^ &#123;</span><br><span class="line">        NSLog(@&quot;2222&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;group&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;3333&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        NSLog(@&quot;4444&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">2019-03-19 15:14:18.051069+0800 Demo[45564:3049581] 2222</span><br><span class="line">2019-03-19 15:14:18.051069+0800 Demo[45564:3049578] 1111</span><br><span class="line">2019-03-19 15:14:18.051089+0800 Demo[45564:3049579] 3333</span><br><span class="line">2019-03-19 15:14:23.055943+0800 Demo[45564:3049580] 4444</span><br><span class="line">2019-03-19 15:14:23.056329+0800 Demo[45564:3049532] end</span><br><span class="line">2019-03-19 15:14:23.056329+0800 Demo[45564:3049580] group</span><br></pre></td></tr></table></figure><br><br>dispatch_group_wait 运行结果：dispatch_group_wait 会阻塞当前线程，当所有任务执行完成再继续向下执行。<br><br><strong>dispatch_group_enter、dispatch_group_leave</strong><br><br>dispatch_group_enter 标志着一个任务追加到 group，相当于 group 中未执行完毕任务数 +1<br><br>dispatch_group_leave 标志着一个任务离开了 group，相当于 group 中未执行完毕任务数 -1。<br><br>当 group 中未执行完毕任务数为 0 时，才会使 dispatch_group_wait 解除阻塞，并执行追加到 dispatch_group_notify 中的任务。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.dubinbin.Demo&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1111&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2222&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;group&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        NSLog(@&quot;3333&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;4444&quot;);</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;end&quot;);</span><br><span class="line"></span><br><span class="line">2019-03-19 15:45:32.294390+0800 Demo[45813:3061727] 1111</span><br><span class="line">2019-03-19 15:45:32.294399+0800 Demo[45813:3061725] 2222</span><br><span class="line">2019-03-19 15:45:32.294411+0800 Demo[45813:3061728] 4444</span><br><span class="line">2019-03-19 15:45:37.299935+0800 Demo[45813:3061726] 3333</span><br><span class="line">2019-03-19 15:45:37.300306+0800 Demo[45813:3061728] group</span><br><span class="line">2019-03-19 15:45:37.300309+0800 Demo[45813:3061668] end</span><br></pre></td></tr></table></figure><br><br>dispatch_group_enter、dispatch_group_leave 运行结果：这里的 dispatch_group_enter、dispatch_group_leave 组合等同于 dispatch_group_async。当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。<br><br>##### 3.4.6 GCD 信号量：dispatch_semaphore<br><br>GCD 中的信号量是指 Dispatch Semaphore，<font color="#cc0000">是持有计数的信号</font>。<br><br>在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为 0 时等待；计数 ≥ 1 时不等待。<br><br>Dispatch Semaphore 提供了三个函数。<br><br><em>   dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量</em>   dispatch_semaphore_signal：发送一个信号，让信号总量 +1<br><br><em>   dispatch_semaphore_wait：使总信号量 -1，当信号总量为 0 时一直等待（阻塞所在线程），否则正常执行。<br><br><br>注意：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后才能使用信号量。<br><br>Dispatch Semaphore 在实际开发中主要用于：</em>   保持线程同步，将异步执行任务转换为同步执行任务<br><br>*   保证线程安全，为线程加锁<br><br><br><strong>Dispatch Semaphore 线程同步</strong><br><br>在开发中会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于将异步执行任务转换为同步执行任务。比如 AFNetworking 中 AFURLSessionManager.m 的 tasksForKeyPath: 方法，通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath </span><br><span class="line">&#123;</span><br><span class="line">    __block NSArray * tasks = nil;</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    </span><br><span class="line">    [self.session getTasksWithCompletionHandler:^( NSArray * dataTasks, </span><br><span class="line">                                                   NSArray * uploadTasks,</span><br><span class="line">                                                   NSArray * downloadTasks) &#123;</span><br><span class="line"></span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。<br><br><strong>Dispatch Semaphore 线程安全和线程同步（为线程加锁）</strong><br><br><font color="#cc0000">线程安全</font><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><font color="#cc0000">线程同步</font><p>可以理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p><h5 id="3-4-7-dispatch-set-target-queue"><a href="#3-4-7-dispatch-set-target-queue" class="headerlink" title="3.4.7 dispatch_set_target_queue"></a>3.4.7 dispatch_set_target_queue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 参数 1 : 要执行变更的队列（不能指定主队列和全局队列）</span><br><span class="line"> * 参数 2 : 目标队列（指定全局队列）</span><br><span class="line"> */</span><br><span class="line">dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);</span><br></pre></td></tr></table></figure><p>dispatch_set_target_queue 函数有两个作用：①、变更队列的执行优先级；②、目标队列可以成为原队列的执行阶层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    // 串行队列，默认优先级</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.gcd.setTargetQueue.serialQueue&quot;, NULL);</span><br><span class="line">    // 串行队列（参照），默认优先级</span><br><span class="line">    dispatch_queue_t serialDefaultQueue = dispatch_queue_create(&quot;com.gcd.setTargetQueue.serialDefaultQueue&quot;, NULL);</span><br><span class="line">    </span><br><span class="line">    // 1. 变更前</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialDefaultQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 全局队列，后台优先级</span><br><span class="line">    dispatch_queue_t globalDefaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line">    // 2. 变更优先级</span><br><span class="line">    dispatch_set_target_queue(serialQueue, globalDefaultQueue);</span><br><span class="line">    </span><br><span class="line">    // 3. 变更后</span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialDefaultQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">-------------------- 1 -------------------- </span><br><span class="line">2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 2</span><br><span class="line">2019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 1</span><br><span class="line">2019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 2</span><br><span class="line">2019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1</span><br><span class="line"></span><br><span class="line">-------------------- 2 -------------------- </span><br><span class="line">2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 1</span><br><span class="line">2019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 2</span><br><span class="line">2019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 2</span><br><span class="line">2019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1</span><br></pre></td></tr></table></figure><p>变更优先级前，serialQueue、serialDefaultQueue 打印随机；变更后，serialDefaultQueue 必定先于 serialQueue 打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue4 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue5 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(serialQueue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue3, ^&#123;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue4, ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue5, ^&#123;</span><br><span class="line">        NSLog(@&quot;5&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">2019-03-19 23:31:27.856574+0800 Demo[41983:2736476] 1</span><br><span class="line">2019-03-19 23:31:27.856583+0800 Demo[41983:2736474] 4</span><br><span class="line">2019-03-19 23:31:27.856585+0800 Demo[41983:2736475] 2</span><br><span class="line">2019-03-19 23:31:27.856586+0800 Demo[41983:2736477] 5</span><br><span class="line">2019-03-19 23:31:27.856586+0800 Demo[41983:2736493] 3</span><br></pre></td></tr></table></figure><p>未设置目标队列前，异步执行任务不阻塞，所以打印随机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue4 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue5 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t targetSerialQueue = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.targetSerialQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    //设置执行阶层</span><br><span class="line">    dispatch_set_target_queue(serialQueue1, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue3, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue2, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue4, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue5, targetSerialQueue);</span><br><span class="line"></span><br><span class="line">    dispatch_async(serialQueue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue3, ^&#123;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue4, ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue5, ^&#123;</span><br><span class="line">        NSLog(@&quot;5&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">2019-03-19 23:34:04.912115+0800 Demo[42048:2739515] 1</span><br><span class="line">2019-03-19 23:34:04.912432+0800 Demo[42048:2739515] 2</span><br><span class="line">2019-03-19 23:34:04.912573+0800 Demo[42048:2739515] 3</span><br><span class="line">2019-03-19 23:34:04.912692+0800 Demo[42048:2739515] 4</span><br><span class="line">2019-03-19 23:34:04.912874+0800 Demo[42048:2739515] 5</span><br></pre></td></tr></table></figure><p>情况一：先设置目标队列，后添加任务，按顺序执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    dispatch_queue_t serialQueue1 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue3 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue4 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL);</span><br><span class="line">    dispatch_queue_t serialQueue5 = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(serialQueue1, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue2, ^&#123;</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue3, ^&#123;</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue4, ^&#123;</span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(serialQueue5, ^&#123;</span><br><span class="line">        NSLog(@&quot;5&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t targetSerialQueue = dispatch_queue_create(&quot;com.gcd.setTargetQueue2.targetSerialQueue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    //设置执行阶层</span><br><span class="line">    dispatch_set_target_queue(serialQueue1, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue2, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue3, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue4, targetSerialQueue);</span><br><span class="line">    dispatch_set_target_queue(serialQueue5, targetSerialQueue);</span><br><span class="line"></span><br><span class="line">2019-03-19 23:36:07.791578+0800 Demo[42077:2741664] 1</span><br><span class="line">2019-03-19 23:36:07.791620+0800 Demo[42077:2741665] 4</span><br><span class="line">2019-03-19 23:36:07.791578+0800 Demo[42077:2741663] 3</span><br><span class="line">2019-03-19 23:36:07.791578+0800 Demo[42077:2741666] 2</span><br><span class="line">2019-03-19 23:36:07.791635+0800 Demo[42077:2741693] 5</span><br></pre></td></tr></table></figure><p>情况二：先添加任务，后设置目标队列，乱序输出。</p><p>在必须将不可并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。</p><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/p/2d57c72016c6" target="_blank" rel="noopener">iOS多线程：『GCD』详尽总结</a><br><a href="http://blog.csdn.net/liuyang11908/article/details/70757534" target="_blank" rel="noopener">iOS GCD之dispatch_semaphore（信号量）</a><br><a href="https://www.jianshu.com/p/cbaeea5368b1" target="_blank" rel="noopener">iOS多线程：『pthread、NSThread』详尽总结</a><br><a href="https://www.jianshu.com/p/4b1d77054b35" target="_blank" rel="noopener">iOS多线程：『NSOperation』详尽总结</a><br><a href="https://www.jianshu.com/p/d260d18dd551" target="_blank" rel="noopener">iOS多线程：『RunLoop』详尽总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、GCD-简介&quot;&gt;&lt;a href=&quot;#一、GCD-简介&quot; class=&quot;headerlink&quot; title=&quot;一、GCD 简介&quot;&gt;&lt;/a&gt;一、GCD 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/i
      
    
    </summary>
    
      <category term="iOS多线程" scheme="http://yoursite.com/categories/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>GCD深入</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD%E6%B7%B1%E5%85%A5/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS多线程/GCD深入/</id>
    <published>2019-09-16T01:18:32.128Z</published>
    <updated>2019-09-16T01:18:32.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、知识储备"><a href="#一、知识储备" class="headerlink" title="一、知识储备"></a>一、知识储备</h2><p>阅读 <a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a>之前，需要了解一些相关知识。</p><h4 id="1-1-DISPATCH-DECL"><a href="#1-1-DISPATCH-DECL" class="headerlink" title="1.1 DISPATCH_DECL"></a>1.1 DISPATCH_DECL</h4><p>GCD 中对变量的定义大多遵循如下格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DISPATCH_DECL(name) typedef struct name##_s *name##_t</span><br></pre></td></tr></table></figure><p>如 DISPATCH_DECL(dispatch_queue); 的展开形式是：typedef struct dispatch_queue_s *dispatch_queue_t; 这行代码定义了一个 dispatch_queue_t 类型的指针，指向一个 dispatch_queue_s 类型的结构体。</p><h4 id="1-2-TSD"><a href="#1-2-TSD" class="headerlink" title="1.2 TSD"></a>1.2 TSD</h4><p>TSD（Thread-Specific Data）表示线程私有数据。在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。在不同线程中，虽然名字相同，但是获取到的数据随线程不同而不同。通常我们可以利用 POSIX 库提供的 API 来实现 TSD：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *))</span><br></pre></td></tr></table></figure><p>此函数用来创建一个 key，在线程退出时会将 key 对应的数据传入 destr_function 函数中进行清理。我们分别使用 get/set 方法来访问/修改 key 对应的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  pthread_setspecific(pthread_key_t  key,  const   void  *pointer)</span><br><span class="line">  </span><br><span class="line">void * pthread_getspecific(pthread_key_t key)</span><br></pre></td></tr></table></figure><p>在 GCD 中定义了六个 key，根据名字大概能猜出各自的含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_key_t dispatch_queue_key;  </span><br><span class="line">pthread_key_t dispatch_sema4_key;  </span><br><span class="line">pthread_key_t dispatch_cache_key;  </span><br><span class="line">pthread_key_t dispatch_io_key;  </span><br><span class="line">pthread_key_t dispatch_apply_key;  </span><br><span class="line">pthread_key_t dispatch_bcounter_key;</span><br></pre></td></tr></table></figure><h4 id="1-3-fastpath-amp-amp-slowpath"><a href="#1-3-fastpath-amp-amp-slowpath" class="headerlink" title="1.3 fastpath &amp;&amp; slowpath"></a>1.3 fastpath &amp;&amp; slowpath</h4><p>这是定义在 internal.h 中的两个宏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span><br><span class="line">#define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span><br></pre></td></tr></table></figure><p>为了理解所谓的快路径和慢路径，需要先学习一点计算机基础知识。比如这段非常简单的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x)  </span><br><span class="line">    return 1;</span><br><span class="line">else  </span><br><span class="line">    return 39;</span><br></pre></td></tr></table></figure><p>由于<font color="#cc0000">计算机并非一次只读取一条指令，而是读取多条指令</font>，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的<font color="#cc0000">指令重读</font>。当然，最简单的优化就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!x)  </span><br><span class="line">    return 39;</span><br><span class="line">else  </span><br><span class="line">    return 1;</span><br></pre></td></tr></table></figure><p>然而对程序员来说，每次都做这样的判断非常烧脑，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long __builtin_expect (long EXP, long C)</span><br></pre></td></tr></table></figure><p>它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect(x, 0))  </span><br><span class="line">    return 1;</span><br><span class="line">else  </span><br><span class="line">    return 39;</span><br></pre></td></tr></table></figure><p>虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。</p><h2 id="二、dispatch-queue-t"><a href="#二、dispatch-queue-t" class="headerlink" title="二、dispatch_queue_t"></a>二、dispatch_queue_t</h2><p>以 dispatch_queue_create 的源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123;</span><br><span class="line">    // 省略 label 相关的操作</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t dq;</span><br><span class="line">    dq = _dispatch_alloc(DISPATCH_VTABLE(queue),</span><br><span class="line">            sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE -</span><br><span class="line">            DISPATCH_QUEUE_CACHELINE_PAD + label_len + 1);</span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    if (fastpath(!attr)) &#123;</span><br><span class="line">        return dq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;</span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        dq-&gt;do_targetq = _dispatch_get_root_queue(0, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        dispatch_debug_assert(!attr, &quot;Invalid attribute&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道创建队列时， attr 属性有三个值可选，nil、DISPATCH_QUEUE_SERIAL（实际上就是 nil）或 DISPATCH_QUEUE_CONCURRENT。</p><p>第一个 if 判断中，苹果认为串行队列或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。</p><p>第二个判断中，参数几乎只可能是 DISPATCH_QUEUE_CONCURRENT，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断几乎不会为 0，依然与 fastpath 的作用一致。</p><p><font color="#cc0000">_dispatch_get_root_queue</font> 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载（overcommit）。这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务（比如下文介绍的定时器），3 这个序列号暂时没有使用。队列 的 <font color="#cc0000">dq_width</font> 被设置为 UINT32_MAX，表示这些队列不限制并发数。作为对比，在 _dispatch_queue_init 中，并发数限制为 1，也就是串行队列的默认设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_queue_init(dispatch_queue_t dq) &#123;  </span><br><span class="line">    dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);</span><br><span class="line">    dq-&gt;dq_running = 0;</span><br><span class="line">    dq-&gt;dq_width = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这行代码：dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);，它涉及到 GCD 队列与 block 的一个重要模型，target_queue。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。借用 <a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">objc 的文章</a> 中的图片来表示：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-bf853ec94c911d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center><h2 id="二、dispatch-async"><a href="#二、dispatch-async" class="headerlink" title="二、dispatch_async"></a>二、dispatch_async</h2><p>直接上函数实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block) &#123;  </span><br><span class="line">    dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#cc0000">队列其实就是一个用来提交 block 的对象</font>，当 block 提交到队列中后，将按照 “先入先出（FIFO）” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。block 参数的类型是 dispatch_block_t，它是一个没有参数，没有返回值的 block：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^dispatch_block_t)(void);</span><br></pre></td></tr></table></figure><p>dispatch_async 的函数很简单，它将 block 复制了一份，然后调用另一个函数 dispatch_async_f：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure><p>work 参数是一个函数，在实际调用时，会把第二参数 context 作为参数传入，以 _dispatch_call_block_and_release 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_call_block_and_release(void *block) &#123;  </span><br><span class="line">    void (^b)(void) = block;</span><br><span class="line">    b();</span><br><span class="line">    Block_release(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略各种分支后的 dispatch_async_f 函数实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    if (dq-&gt;dq_width == 1) &#123;</span><br><span class="line">        return dispatch_barrier_async_f(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    if (dq-&gt;do_targetq) &#123;</span><br><span class="line">        return _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见如果是串行队列（dq_width = 1），会调用 dispatch_barrier_async_f 函数处理。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。这里的 dispatch_continuation_t 其实是对 block 的封装，然后调用 _dispatch_queue_push 这个宏将封装好的 block 放入队列中。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push  </span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br><span class="line">        └──_dispatch_queue_push_slow</span><br><span class="line">            └──_dispatch_queue_push_list_slow2</span><br><span class="line">                └──_dispatch_wakeup</span><br><span class="line">                    └──dx_probe</span><br></pre></td></tr></table></figure><p>队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法，调用栈如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global  </span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure><p>在 _dispatch_queue_wakeup_global_slow 我们见到了熟悉的老朋友 pthread 线程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) &#123;</span><br><span class="line"> </span><br><span class="line">    // 如果线程池已满，则直接调用 _dispatch_worker_thread </span><br><span class="line">    // 否则创建线程池</span><br><span class="line">    pthread_t pthr;</span><br><span class="line">    while ((r = pthread_create(&amp;pthr, NULL, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">        if (r != EAGAIN) &#123;</span><br><span class="line">            (void)dispatch_assume_zero(r);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    r = pthread_detach(pthr);</span><br><span class="line">    (void)dispatch_assume_zero(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见这里确实使用了线程池。创建线程后会执行 _dispatch_worker_thread 回调:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_worker_thread  </span><br><span class="line">└──_dispatch_worker_thread4</span><br><span class="line">    └──_dispatch_continuation_pop</span><br></pre></td></tr></table></figure><p>在 pop 函数中，我们拿到了最早加入的任务，然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_continuation_pop(dispatch_object_t dou) &#123;  </span><br><span class="line">    // ...</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    if (dg) &#123;</span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dispatch_async 的实现比较复杂，主要是因为其中的数据结构较多，分支流程控制比较复杂。但思路其实很简单，用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。如果熟悉了相关数据结构和调用流程，接下来研究 GCD 的其他 API 就比较轻松了。</p><h2 id="三、dispatch-sync"><a href="#三、dispatch-sync" class="headerlink" title="三、dispatch_sync"></a>三、dispatch_sync</h2><p>同步方法的实现相对来说和异步类似，而且更简单，调用栈如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync  </span><br><span class="line">└──dispatch_sync_f</span><br><span class="line">    └──_dispatch_sync_f2</span><br><span class="line">        └──_dispatch_sync_f_slow</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    struct dispatch_sync_slow_s &#123;</span><br><span class="line">        DISPATCH_CONTINUATION_HEADER(sync_slow);</span><br><span class="line">    &#125; dss = &#123;</span><br><span class="line">        .do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_ctxt = (void*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push(dq, (void *)&amp;dss);</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。</p><h2 id="四、dispatch-semaphore"><a href="#四、dispatch-semaphore" class="headerlink" title="四、dispatch_semaphore"></a>四、dispatch_semaphore</h2><p>关于信号量的 API 不多，主要是三个：create、wait 和 signal。信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value，一个是当前的 value，一个是记录初始 value。信号的 wait 和 signal 是互逆的两个操作。如果 value &gt; 0，前者将 value - 1，此时如果 value &lt; 0 就一直等待。初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。</p><h4 id="4-1-dispatch-semaphore-wait"><a href="#4-1-dispatch-semaphore-wait" class="headerlink" title="4.1 dispatch_semaphore_wait"></a>4.1 dispatch_semaphore_wait</h4><p>首先从源码看起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">    long value = dispatch_atomic_dec2o(dsema, dsema_value);</span><br><span class="line">    dispatch_atomic_acquire_barrier();</span><br><span class="line">    if (fastpath(value &gt;= 0)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 <font color="#cc0000">__sync_sub_and_fetch，实现减法的原子性操作</font>。因此这一行的意思是将 dsema 的值减 1，并把新的值赋给 value。如果减一后的 value ≥ 0 就立刻返回，没有任何操作，否则进入等待状态。_dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case DISPATCH_TIME_NOW:  </span><br><span class="line">    while ((orig = dsema-&gt;dsema_value) &lt; 0) &#123;</span><br><span class="line">        if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) &#123;</span><br><span class="line">            return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value + 1（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。实际上 while 判断一定会成立，因为如果 value 大于等于 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。</p><p>第二种情况是 DISPATCH_TIME_FOREVER 这个 case：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case DISPATCH_TIME_FOREVER:  </span><br><span class="line">    do &#123;</span><br><span class="line">        kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">    &#125; while (kr == KERN_ABORTED);</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure><p>进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。整个函数的框架如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">again:  </span><br><span class="line">    while ((orig = dsema-&gt;dsema_sent_ksignals)) &#123;</span><br><span class="line">        if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">                orig - 1)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (timeout) &#123;</span><br><span class="line">        default:  /* semaphore_timedwait */</span><br><span class="line">        case DISPATCH_TIME_NOW: /* KERN_OPERATION_TIMED_OUT */</span><br><span class="line">        case DISPATCH_TIME_FOREVER: /* semaphore_wait */</span><br><span class="line">    &#125;</span><br><span class="line">    goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。</p><h4 id="4-2-dispatch-semaphore-signal"><a href="#4-2-dispatch-semaphore-signal" class="headerlink" title="4.2 dispatch_semaphore_signal"></a>4.2 dispatch_semaphore_signal</h4><p>这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_semaphore_signal(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    long value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">    if (fastpath(value &gt; 0)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用原子方法让 value + 1，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：“如果唤醒了线程，返回非 0，否则返回 0”。</p><h2 id="五、dispatch-group"><a href="#五、dispatch-group" class="headerlink" title="五、dispatch_group"></a>五、dispatch_group</h2><p>有了上面的铺垫，group 是一个非常容易理解的概念，我们先看看如何创建 group：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t dispatch_group_create(void) &#123;  </span><br><span class="line">    dispatch_group_t dg = _dispatch_alloc(DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s));</span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    return dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，group 就是一个 value 为 LONG_MAX 的信号量。</p><h4 id="5-1-dispatch-group-async"><a href="#5-1-dispatch-group-async" class="headerlink" title="5.1 dispatch_group_async"></a>5.1 dispatch_group_async</h4><p>它仅仅是 dispatch_group_async_f 的封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line"></span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数和 dispatch_async_f 的实现高度一致，主要的不同在于调用了 dispatch_group_enter 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_enter(dispatch_group_t dg) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    (void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也没做什么，就是调用 wait 方法让信号量的 value 减一而已。</p><h4 id="5-2-dispatch-group-wait"><a href="#5-2-dispatch-group-wait" class="headerlink" title="5.2 dispatch_group_wait"></a>5.2 dispatch_group_wait</h4><p>这个方法用于等待 group 中所有任务执行完成，可以理解为信号量 wait 的封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeout == 0) &#123;</span><br><span class="line">        return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前 value 和原始 value 相同，表明任务已经全部完成，直接返回 0，如果 timeout 为 0 也会立刻返回，否则调用 _dispatch_group_wait_slow。这个方法的等待部分和 _dispatch_semaphore_signal_slow 几乎一致，区别在于等待结束后它不是 return，而是调用 _dispatch_group_wake 去唤醒这个 group。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">again:  </span><br><span class="line">    _dispatch_group_wake(dsema);</span><br><span class="line">    switch (timeout) &#123;/* 三种情况分类 */&#125;    </span><br><span class="line">    goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们暂时跳过 _dispatch_group_wake，后面会有详细分析。只要知道这个函数在 group 中所有事件执行完后会被调用即可。</p><h4 id="5-3-dispatch-group-notify"><a href="#5-3-dispatch-group-notify" class="headerlink" title="5.3 dispatch_group_notify"></a>5.3 dispatch_group_notify</h4><p>这个函数仅仅是封装了 dispatch_group_notify_f：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, void (*func)(void *)) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    struct dispatch_sema_notify_s *dsn, *prev;</span><br><span class="line"></span><br><span class="line">    dsn-&gt;dsn_queue = dq;</span><br><span class="line">    dsn-&gt;dsn_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dsn_func = func;</span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn);</span><br><span class="line">    if (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;dsn_next = dsn;</span><br><span class="line">    &#125; else &#123;/* ... */&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种结构的代码已经遇到多次了，它其实就是在链表的尾部续上新的元素。所以 notify 方法并没有做过多的处理，只是用链表把所有回调通知保存起来，等待调用。</p><h4 id="5-4-dispatch-group-leave"><a href="#5-4-dispatch-group-leave" class="headerlink" title="5.4 dispatch_group_leave"></a>5.4 dispatch_group_leave</h4><p>在介绍 dispatch_async 函数时，我们看到任务在被执行时，还会调用 dispatch_group_leave 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_leave(dispatch_group_t dg) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    long value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">    if (slowpath(value == dsema-&gt;dsema_orig)) &#123;</span><br><span class="line">        (void)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 group 的 value 变为初始值时，表示所有任务都已执行完，开始调用 _dispatch_group_wake 处理回调。  </p><h4 id="5-5-dispatch-group-wake"><a href="#5-5-dispatch-group-wake" class="headerlink" title="5.5 dispatch_group_wake"></a>5.5 dispatch_group_wake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_group_wake(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    struct dispatch_sema_notify_s *next, *head, *tail = NULL;</span><br><span class="line">    long rval;</span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL);</span><br><span class="line"></span><br><span class="line">    if (head) &#123;</span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = dispatch_atomic_xchg2o(dsema, dsema_group_waiters, 0);</span><br><span class="line">    if (rval) &#123;</span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);</span><br><span class="line">        do &#123;</span><br><span class="line">            kern_return_t kr = semaphore_signal(dsema-&gt;dsema_waiter_port);</span><br><span class="line">        &#125; while (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    if (head) &#123;</span><br><span class="line">        // async group notify blocks</span><br><span class="line">        do &#123;</span><br><span class="line">            dispatch_async_f(head-&gt;dsn_queue, head-&gt;dsn_ctxt, head-&gt;dsn_func);</span><br><span class="line">            next = fastpath(head-&gt;dsn_next);</span><br><span class="line">            if (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                while (!(next = fastpath(head-&gt;dsn_next))) &#123;</span><br><span class="line">                    _dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            free(head);</span><br><span class="line">        &#125; while ((head = next));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要分为两部分，首先循环调用 semaphore_signal 告知唤醒当初等待 group 的信号量，因此 dispatch_group_wait 函数得以返回。然后获取链表，依次调用 dispatch_async_f 异步执行在 notify 函数中注册的回调。</p><h2 id="六、dispatch-once"><a href="#六、dispatch-once" class="headerlink" title="六、dispatch_once"></a>六、dispatch_once</h2><p>dispatch_once 仅仅是一个包装，内部直接调用了 dispatch_once_f：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    struct _dispatch_once_waiter_s * volatile *vval = (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;;</span><br><span class="line">    struct _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">    _dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">    if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line">        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        while (tail != tmp) &#123;</span><br><span class="line">            while (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                _dispatch_hardware_pause();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            tmp = *vval;</span><br><span class="line">            if (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_atomic_store_barrier();</span><br><span class="line">            if (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较长，我们考虑三个场景：</p><ol><li><p>第一次调用：此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。</p><p> 首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。</p></li><li><p>同一线程第二次调用：由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。</p><p> 由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。</p></li><li><p>多个线程同时调用：由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。</p><p> 由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。</p></li></ol><h2 id="七、dispatch-barrier-async"><a href="#七、dispatch-barrier-async" class="headerlink" title="七、dispatch_barrier_async"></a>七、dispatch_barrier_async</h2><p>它调用了 dispatch_barrier_async_f 函数，实现原理也和 dispatch_async_f 类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别在于 do_vtable 被设置了两个标志位，多了一个 DISPATCH_OBJ_BARRIER_BIT 标记。这个标记在从队列中取出任务时被用到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static _dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_queue_t dq) &#123;  </span><br><span class="line">    while (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">        if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp; (long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">            if (dq-&gt;dq_running &gt; 1) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:  </span><br><span class="line">    /* 不完整的 drain，需要清理现场 */</span><br><span class="line">    return sema; // 返回空的信号量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里原来是一个循环，会拿出所有的任务，依次调用 _dispatch_continuation_redirect，最终并行处理。一旦遇到 DISPATCH_OBJ_BARRIER_BIT 这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_queue_invoke(dispatch_queue_t dq) &#123;  </span><br><span class="line">    _dispatch_thread_semaphore_t sema = _dispatch_queue_drain(dq);</span><br><span class="line">    if (sema) &#123;</span><br><span class="line">        _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">    &#125; else if (tq) &#123;</span><br><span class="line">        return _dispatch_queue_push(tq, dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 barrier 方法能等待此前所有任务执行完以后执行 _dispatch_queue_push，同时保证自己执行完以后才执行后续的操作。</p><h2 id="八、dispatch-source"><a href="#八、dispatch-source" class="headerlink" title="八、dispatch_source"></a>八、dispatch_source</h2><p>source 是一种资源，类似于生产者/消费者模式中的生产者，而队列则是消费者。当有新的资源（source）产生时，它们被放到对应的队列上被执行（消费）。dispatch_source 最常见的用途之一就是用来实现定时器，举一个小例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);  </span><br><span class="line"></span><br><span class="line">// 每 10 秒触发 timer，误差 1 秒</span><br><span class="line">dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 10*NSEC_PER_SEC, 1*NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;  </span><br><span class="line">    // 定时器触发时执行的 block</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure><p>使用 GCD Timer 的好处在于<font color="#cc0000">不依赖 runloop</font>，因此任何线程都可以使用。由于使用了 block，不会忘记避免循环引用。此外，定时器可以自由控制精度，随时修改间隔时间等。</p><h4 id="8-1-dispatch-source-create"><a href="#8-1-dispatch-source-create" class="headerlink" title="8.1 dispatch_source_create"></a>8.1 dispatch_source_create</h4><p>下面从底层源码的角度来研究这几行代码的作用。首先是 dispatch_source_create 函数，它和之前见到的 create 函数都差不多，对 dispatch_source_t 对象做了一些初始化工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t ds = NULL;  </span><br><span class="line">ds = _dispatch_alloc(DISPATCH_VTABLE(source), sizeof(struct dispatch_source_s));  </span><br><span class="line">_dispatch_queue_init((dispatch_queue_t)ds);  </span><br><span class="line">ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;  </span><br><span class="line">ds-&gt;do_targetq = &amp;_dispatch_mgr_q;  </span><br><span class="line">dispatch_set_target_queue(ds, q);  </span><br><span class="line">return ds;</span><br></pre></td></tr></table></figure><p>这里涉及到两个队列，其中 q 是用户指定的队列，表示事件触发的回调在哪个队列执行。而 _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写，也是上文提到的序列号为 2 的内部队列。</p><h4 id="8-2-dispatch-source-set-timer"><a href="#8-2-dispatch-source-set-timer" class="headerlink" title="8.2 dispatch_source_set_timer"></a>8.2 dispatch_source_set_timer</h4><p>在这个函数中，首先会有参数处理，过滤掉不符合要求的参数。随后创建了 dispatch_set_timer_params 类型的指针 params：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct dispatch_set_timer_params &#123;  </span><br><span class="line">    dispatch_source_t ds;</span><br><span class="line">    uintptr_t ident;</span><br><span class="line">    struct dispatch_timer_source_s values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 params 负责绑定定时器对象与它的参数（存储在 values 属性中），最后调用：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async_f((dispatch_queue_t)ds, params, _dispatch_source_set_timer2);</span><br></pre></td></tr></table></figure><p>这里是把 source 当做队列来使用，因此实际上是调用了 _dispatch_source_set_timer2(params) 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_source_set_timer2(void *context) &#123;  </span><br><span class="line">    // Called on the source queue</span><br><span class="line">    struct dispatch_set_timer_params *params = context;</span><br><span class="line">    dispatch_suspend(params-&gt;ds);</span><br><span class="line">    dispatch_barrier_async_f(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先暂停了队列，避免了修改的过程中定时器被触发。然后在 manager 队列上执行 _dispatch_source_set_timer3(params)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_source_set_timer3(void *context) &#123;  </span><br><span class="line">    struct dispatch_set_timer_params *params = context;</span><br><span class="line">    dispatch_source_t ds = params-&gt;ds;</span><br><span class="line">    // ...</span><br><span class="line">    _dispatch_timer_list_update(ds);</span><br><span class="line">    dispatch_resume(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_dispatch_timer_list_update 函数的作用是根据下一次触发时间将 timer 排序。接下来，当初分发到 manager 队列的 block 将要被执行，走到 _dispatch_mgr_invoke 函数，其中有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeoutp = _dispatch_get_next_timer_fire(&amp;timeout);  </span><br><span class="line">r = select(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, NULL, sel_timeoutp);</span><br></pre></td></tr></table></figure><p>可见 GCD 的定时器是由系统的 select 方法实现的。当内层的 manager 队列被唤醒后，还会进一步唤醒外层的队列（当初用户指定的那个），并在队列上执行 timer 触发时的 block。</p><h2 id="九、dispatch-resume-suspend"><a href="#九、dispatch-resume-suspend" class="headerlink" title="九、dispatch_resume/suspend"></a>九、dispatch_resume/suspend</h2><p>GCD 对象的暂停和恢复由 do_suspend_cnt 决定，暂停时通过原子操作将该属性的值加 2，对应的在恢复时通过原子操作将该属性减 2。它有两个默认值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DISPATCH_OBJECT_SUSPEND_LOCK        1u</span><br><span class="line">#define DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span><br></pre></td></tr></table></figure><p>在唤醒队列时有如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_queue_invoke(dispatch_queue_t dq) &#123;  </span><br><span class="line">    if (!dispatch_atomic_sub2o(dq, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;</span><br><span class="line">        if (dq-&gt;dq_running == 0) &#123;</span><br><span class="line">            _dispatch_wakeup(dq); // verify that the queue is idle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见能够唤醒队列的前提是 dq-&gt;do_suspend_cnt - 1 = 0，也就是要求 do_suspend_cnt 的值就是 DISPATCH_OBJECT_SUSPEND_LOCK。观察 8 个全局队列和主队列的定义就会发现，他们的 do_suspend_cnt 值确实为 DISPATCH_OBJECT_SUSPEND_LOCK，因此默认处于启动状态。而 dispatch_source 的 create 方法中，do_suspend_cnt 的初始值为 DISPATCH_OBJECT_SUSPEND_INTERVAL，因此默认处于暂停状态，需要手动开启。</p><h2 id="十、dispatch-after"><a href="#十、dispatch-after" class="headerlink" title="十、dispatch_after"></a>十、dispatch_after</h2><p>dispatch_after 其实依赖于定时器的实现，函数内部调用了 dispatch_after_f：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    uint64_t delta;</span><br><span class="line">    struct _dispatch_after_time_s *datc = NULL;</span><br><span class="line">    dispatch_source_t ds;</span><br><span class="line"></span><br><span class="line">    // 如果延迟为 0，直接调用 dispatch_async</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    if (delta == 0) &#123;</span><br><span class="line">        return dispatch_async_f(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    dispatch_assert(ds);</span><br><span class="line"></span><br><span class="line">    datc = malloc(sizeof(*datc));</span><br><span class="line">    dispatch_assert(datc);</span><br><span class="line">    datc-&gt;datc_ctxt = ctxt;</span><br><span class="line">    datc-&gt;datc_func = func;</span><br><span class="line">    datc-&gt;ds = ds;</span><br><span class="line"></span><br><span class="line">    dispatch_set_context(ds, datc);</span><br><span class="line">    dispatch_source_set_event_handler_f(ds, _dispatch_after_timer_callback);</span><br><span class="line">    dispatch_source_set_timer(ds, when, DISPATCH_TIME_FOREVER, 0);</span><br><span class="line">    dispatch_resume(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将延迟执行的 block 封装在 _dispatch_after_time_s 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。到时以后，执行 _dispatch_after_timer_callback 回调，并取出上下文中的 block：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_after_timer_callback(void *ctxt) &#123;  </span><br><span class="line">    struct _dispatch_after_time_s *datc = ctxt;</span><br><span class="line">    _dispatch_client_callout(datc-&gt;datc_ctxt, datc-&gt;datc_func);</span><br><span class="line">    // 清理工作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h2><p>本文主要整理了 GCD 中常见的 API 以及底层的实现原理。</p><ol><li><p>对于队列来说，需要理解它的数据结构，转发机制，以及底层的线程池模型。</p></li><li><p>dispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。在 wakeup 方法中，从线程池里取出工作线程（如果没有就新建），然后在工作线程中取出链表头部指向的 block 并执行。</p></li><li><p>dispatch_sync 的实现略简单一些，它不涉及线程池（因此一般都在当前线程执行），而是利用与线程绑定的信号量来实现串行。分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性（表示在运行的任务数量）为 1，所以以下判断成立：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) &#123;  </span><br><span class="line">    return _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>在 \_dispatch\_barrier\_sync\_f\_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。如果向其它队列同步提交 block，最终进入 \_dispatch\_barrier\_sync\_f\_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。</code></pre><ol start="4"><li><p>对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。在调用 signal 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。</p></li><li><p>dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。</p></li><li><p>dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。</p></li><li><p>dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。</p></li><li><p>dispatch_source 可以用来实现定时器。所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。随后找到最近触发的定时器，调用内核的 select 方法等待。等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。</p></li><li><p>GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。</p></li><li><p>dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。</p></li></ol><h2 id="十二、文章"><a href="#十二、文章" class="headerlink" title="十二、文章"></a>十二、文章</h2><p><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解 GCD</a><br><a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a><br><a href="http://stackoverflow.com/questions/7346929/why-do-we-use-builtin-expect-when-a-straightforward-way-is-to-use-if-else" target="_blank" rel="noopener">Why do we use _builtinexpect when a straightforward way is to use if-else</a><br><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/" target="_blank" rel="noopener">Posix线程编程指南(2) 线程私有数据</a><br><a href="http://www.jianshu.com/p/0c050af6c5ee" target="_blank" rel="noopener">选择 GCD 还是 NSTimer？</a><br><a href="https://yq.aliyun.com/articles/17709" target="_blank" rel="noopener">从NSTimer的失效性谈起（二）：关于GCD Timer和libdispatch</a><br><a href="http://blog.csdn.net/u012878842/article/list/4" target="_blank" rel="noopener">变态的libDispatch源码分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、知识储备&quot;&gt;&lt;a href=&quot;#一、知识储备&quot; class=&quot;headerlink&quot; title=&quot;一、知识储备&quot;&gt;&lt;/a&gt;一、知识储备&lt;/h2&gt;&lt;p&gt;阅读 &lt;a href=&quot;https://libdispatch.macosforge.org/&quot; targe
      
    
    </summary>
    
      <category term="iOS多线程" scheme="http://yoursite.com/categories/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>NSProxy</title>
    <link href="http://yoursite.com/2019/09/16/iOS/iOS%E5%8E%9F%E7%90%86/NSProxy/"/>
    <id>http://yoursite.com/2019/09/16/iOS/iOS原理/NSProxy/</id>
    <published>2019-09-16T01:18:32.127Z</published>
    <updated>2019-09-16T01:18:32.128Z</updated>
    
    <content type="html"><![CDATA[<p>NSProxy 是一个<font color="#cc0000">实现了 NSObject 协议</font>类似于 NSObject 的根类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NS_ROOT_CLASS</span><br><span class="line">@interface NSProxy &lt;NSObject&gt;&#123;</span><br><span class="line">    Class   isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>苹果的官方文档：</p><blockquote><p>Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.</p><p>NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information.</p></blockquote><p>看了这些描述我们应该能对 NSProxy 有个初步印象，<font color="#cc0000">它仅仅是个转发消息的场所</font>，至于如何转发，取决于派生类的具体实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了。甚至也可以不去创建这些对象，去做任何你想做的事情，但是必须要实现它的 forwardInvocation: 和 methodSignatureForSelector: 方法。</p><h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h2><h4 id="1-1-多继承"><a href="#1-1-多继承" class="headerlink" title="1.1 多继承"></a>1.1 多继承</h4><p>大致过程就是让它持有要实现多继承的类的对象，然后用多个接口定义不同的行为，并让 Proxy 去实现这些接口，然后在转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。注意：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用 NSObject 类来实现。</p><p>NSObject 寻找方法顺序：本类 -> 父类 -> 动态方法解析 -> 备用对象 -> 消息转发；<br> NSproxy 寻找方法顺序：本类-> 消息转发；</p><p>同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间。</p><p>首先新建两个基类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation classA</span><br><span class="line">-(void)infoA</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;classA 卖水&quot;);   </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation classB</span><br><span class="line">-(void)infoB</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;classB 卖饭&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>代理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong, readonly) NSMutableArray * targetArray;</span><br><span class="line"></span><br><span class="line">-(void)target:(id)target;</span><br><span class="line">-(void)handleTargets:(NSArray *)targets;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>NSProxy 必须以子类的形式出现。</p><p>因为考虑到很可能还有其他的卖衣服的、卖鞋子的需要 ClassProxy 来代理，这边做了一个数组来存放需要代理的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassProxy()</span><br><span class="line">@property (nonatomic, strong) NSMutableArray * targetArray; // 多个 targets 皆可代理</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * methodDic;</span><br><span class="line">@property (nonatomic, strong) id target;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后 target 和相对应的 method name 做了一个字典来存储，方便获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(void)registMethodWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int countOfMethods = 0;</span><br><span class="line">    Method *method_list = class_copyMethodList([target class], &amp;countOfMethods);</span><br><span class="line">    for (int i = 0; i&lt;countOfMethods; i++) &#123;</span><br><span class="line">        Method method = method_list[i];</span><br><span class="line">        //得到方法的符号</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        //得到方法的符号字符串</span><br><span class="line">        const char *sel_name = sel_getName(sel);</span><br><span class="line">        //得到方法的名字</span><br><span class="line">        NSString * method_name = [NSString stringWithUTF8String:sel_name];</span><br><span class="line">        self.methodDic[method_name] = target;</span><br><span class="line">    &#125;</span><br><span class="line">    free(method_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是最主要的两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    id target = self.methodDic[methodName];</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        [invocation invokeWithTarget:target];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *Method;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    id target = self.methodDic[methodName];</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        Method =  [target methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        Method = [super methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    return Method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>methodSignatureForSelector: 得到对应的方法签名，通过 forwardInvocation: 转发。</p><p>调用和打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self classInheritance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多继承</span><br><span class="line"> */</span><br><span class="line">-(void)classInheritance</span><br><span class="line">&#123;</span><br><span class="line">    classA * A = [[classA alloc]init];</span><br><span class="line">    classB * B = [[classB alloc]init];</span><br><span class="line">    ClassProxy * proxy = [ClassProxy alloc];</span><br><span class="line"></span><br><span class="line">    [proxy handleTargets:@[A, B]];</span><br><span class="line">    [proxy performSelector:@selector(infoA)];</span><br><span class="line">    [proxy performSelector:@selector(infoB)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2018-12-27 18:02:34.445 NSProxyStudy[18975:4587631] classA 卖水</span><br><span class="line">2018-12-27 18:02:34.446 NSProxyStudy[18975:4587631] classB 卖饭</span><br></pre></td></tr></table></figure><p>以上就是利用 NSProxy 实现多继承。</p><h4 id="1-2-避免循环应用"><a href="#1-2-避免循环应用" class="headerlink" title="1.2 避免循环应用"></a>1.2 避免循环应用</h4><p>举一个比较常见的例子 NSTimer。</p><p>由于苹果在 iOS10 以上给出了 timer 的 block 方式，已经可以解决循环引用的问题。所以这里只是说明利用 NSProxy 如何解决循环引用，实际情况可直接使用系统的方法。</p><p>首先因为 NSTimer 创建的时候需要传入一个 target，并且持有它，而 target 本身也会持有 timer 所以会造成循环引用。所以我们将 target 用 NSProxy 的子类代替。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:1</span><br><span class="line">                                         target:[WeakProxy proxyWithTarget:self]</span><br><span class="line">                                       selector:@selector(invoked:)</span><br><span class="line">                                       userInfo:nil</span><br><span class="line">                                        repeats:YES];</span><br><span class="line">    [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)invoked:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 WeakProxy 中我们设定 target 为弱引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@interface WeakProxy ()</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WeakProxy</span><br><span class="line">+(instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    return [[self alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(instancetype)initWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    self.target = target; </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line">    if ([self.target respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:self.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后同样利用上述两个方法进行消息转发即可。</p><h4 id="1-3-AOP"><a href="#1-3-AOP" class="headerlink" title="1.3 AOP"></a>1.3 AOP</h4><p>要重点介绍的功能就是 AOP（Aspect Oriented Programming），它是可以<font color="#cc0000">通过预编译方式和运行时动态代理实现在不修改源代码的情况下给程序动态添加功能的一种技术</font>。</p><p>iOS 中面向切片编程一般有两种方式 ，一种是直接基于 runtime 的 method-Swizzling 机制来实现方法替换从而达到 hook 的目的，另一种就是基于 NSProxy。</p><p>OC 的动态语言的核心部分应该就是 objc_msgSend 方法的调用了。该函数的声明大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 参数 1：接受消息的 target</span><br><span class="line"> * 参数 2：要执行的 selector</span><br><span class="line"> * 参数 3：要调用的方法</span><br><span class="line"> * 可变参数：若干个要传给 selector 的参数 </span><br><span class="line"> */</span><br><span class="line">id objc_msgSend(id self, SEL _cmd, ...)</span><br></pre></td></tr></table></figure><p>只要我们能够 Hook 到对某个对象的 objc_msgSend 的调用，并且可以修改其参数甚至于修改成任意其他 selector 的 IMP，我们就实现了 AOP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface MyProxy : NSProxy &#123;</span><br><span class="line">     id _innerObject;  // 在内部持有要 hook 的对象</span><br><span class="line">&#125;</span><br><span class="line">+(instancetype)proxyWithObj:(id)object;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog : NSObject</span><br><span class="line">-(NSString *)barking:(NSInteger)months;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实现部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyProxy</span><br><span class="line"></span><br><span class="line">+(instancetype)proxyWithObj:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    MyProxy * proxy = [MyProxy alloc];</span><br><span class="line">    // 持有要 hook 的对象</span><br><span class="line">    proxy-&gt;_innerObject = object;</span><br><span class="line">    // 注意返回的值是 Proxy 对象</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    // 这里可以返回任何 NSMethodSignature 对象，也可以完全自己构造一个</span><br><span class="line">    return [_innerObject methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    if([_innerObject respondsToSelector:invocation.selector])&#123;</span><br><span class="line">        NSString *selectorName = NSStringFromSelector(invocation.selector);</span><br><span class="line">        NSLog(@&quot;Before calling %@&quot;,selectorName);</span><br><span class="line">        [invocation retainArguments];</span><br><span class="line">        NSMethodSignature *sig = [invocation methodSignature];</span><br><span class="line">        // 获取参数个数，注意在本例里这里的值是 3，因为 objc_msgSend 隐含了 self、selector 参数</span><br><span class="line">        NSUInteger cnt = [sig numberOfArguments];</span><br><span class="line">        // 本例只是简单的将参数和返回值打印出来</span><br><span class="line">        for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 参数类型</span><br><span class="line">            const char * type = [sig getArgumentTypeAtIndex:i];</span><br><span class="line">            if(strcmp(type, &quot;@&quot;) == 0)&#123;</span><br><span class="line">                NSObject *obj;</span><br><span class="line">                [invocation getArgument:&amp;obj atIndex:i];</span><br><span class="line">                // 这里输出的是：&quot;parameter (0)&apos;class is MyProxy&quot;，也证明了这是 objc_msgSend 的第一个参数</span><br><span class="line">                NSLog(@&quot;parameter (%d)&apos;class is %@&quot;, i, [obj class]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(strcmp(type, &quot;:&quot;) == 0)&#123;</span><br><span class="line">                SEL sel;</span><br><span class="line">                [invocation getArgument:&amp;sel atIndex:i];</span><br><span class="line">                // 这里输出的是:&quot;parameter (1) is barking:&quot;，也就是 objc_msgSend 的第二个参数</span><br><span class="line">                NSLog(@&quot;parameter (%d) is %@&quot;, i, NSStringFromSelector(sel));</span><br><span class="line">            &#125;</span><br><span class="line">            else if(strcmp(type, &quot;q&quot;) == 0)&#123;</span><br><span class="line">                int arg = 0;</span><br><span class="line">                [invocation getArgument:&amp;arg atIndex:i];</span><br><span class="line">                // 这里输出的是:&quot;parameter (2) is int value is 4&quot;，稍后会看到我们在调用 barking 的时候传递的参数就是 4</span><br><span class="line">                NSLog(@&quot;parameter (%d) is int value is %d&quot;, i, arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 消息转发</span><br><span class="line">        [invocation invokeWithTarget:_innerObject];</span><br><span class="line">        const char *retType = [sig methodReturnType];</span><br><span class="line">        if(strcmp(retType, &quot;@&quot;) == 0)&#123;</span><br><span class="line">            NSObject *ret;</span><br><span class="line">            [invocation getReturnValue:&amp;ret];</span><br><span class="line">            //这里输出的是:&quot;return value is wang wang!&quot;</span><br><span class="line">            NSLog(@&quot;return value is %@&quot;, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;After calling %@&quot;, selectorName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">-(NSString *)barking:(NSInteger)months</span><br><span class="line">&#123;</span><br><span class="line">    return months &gt; 3 ? @&quot;wang wang!&quot; : @&quot;eng eng!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>函数的调用如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog * dog = [MyProxy proxyWithObj:[Dog alloc]];</span><br><span class="line">[dog barking:4];</span><br></pre></td></tr></table></figure><p>上面的代码中，可以任意更改参数、调用的方法，甚至转发给其他类型的对象，这确实达到了 Hook 对象的目的，也就是可以实现 AOP 的功能了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^proxyBlock)(id target,SEL selector);</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface AOPProxy : NSProxy</span><br><span class="line">+(instancetype)proxyWithTarget:(id)target;</span><br><span class="line">-(void)inspectSelector:(SEL)selector preSelTask:(proxyBlock)preTask endSelTask:(proxyBlock)endTask;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AOPProxy ()</span><br><span class="line">@property (nonatomic, strong) id target;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * preSelTaskDic;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * endSelTaskDic;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)inspect&#123;</span><br><span class="line">    NSMutableArray * targtArray = [AOPProxy proxyWithTarget:[NSMutableArray arrayWithCapacity:1]];</span><br><span class="line">    [(AOPProxy *)targtArray inspectSelector:@selector(addObject:) preSelTask:^(id target, SEL selector) &#123;</span><br><span class="line">        [target addObject:@&quot;-------&quot;];</span><br><span class="line">        NSLog(@&quot;%@ 我加进来之前&quot;, target);</span><br><span class="line">    &#125; endSelTask:^(id target, SEL selector) &#123;</span><br><span class="line">        [target addObject:@&quot;-------&quot;];</span><br><span class="line">        NSLog(@&quot;%@ 我加进来之后&quot;, target);</span><br><span class="line">    &#125;];</span><br><span class="line">    [targtArray addObject:@&quot;我是一个元素&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">( &quot;-------&quot; ) 我加进来之前</span><br><span class="line">( &quot;-------&quot;, </span><br><span class="line">  &quot;\U6211\U662f\U4e00\U4e2a\U5143\U7d20&quot;, </span><br><span class="line">  &quot;-------&quot; ) </span><br><span class="line">我加进来之后</span><br></pre></td></tr></table></figure><h3 id="1-4-实现延迟初始化（Lazy-Initialization）"><a href="#1-4-实现延迟初始化（Lazy-Initialization）" class="headerlink" title="1.4 实现延迟初始化（Lazy Initialization）"></a>1.4 实现延迟初始化（Lazy Initialization）</h3><p>使用场景：</p><ol><li><p>在 [SomeClass lazy] 之后调用 doSomthing，首先进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用 init 初始化对象，然后将消息转发给代理对象 _object；</p></li><li><p>在 [SomeClass lazy] 之后调用 initWithXXX:，首先进入 forwardingTargetForSelector 返回 nil，然后进入 methodSignatureForSelector: 和 forwardInvocation: 保存自定义初始化方法的调用，最后调用 doSomthing，进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用自定义初始化方法，然后将消息转发给代理对象 _object。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SomeClass *object = [SomeClass lazy];</span><br><span class="line"></span><br><span class="line">// other thing ...</span><br><span class="line"></span><br><span class="line">[object doSomething];  // 在这里 object 才会调用初始化方法，然后调用 doSomething</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NSProxy 是一个&lt;font color=&quot;#cc0000&quot;&gt;实现了 NSObject 协议&lt;/font&gt;类似于 NSObject 的根类。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>组件化方案</title>
    <link href="http://yoursite.com/2019/09/10/iOS/iOS%E6%9E%B6%E6%9E%84/%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/09/10/iOS/iOS架构/组件化方案/</id>
    <published>2019-09-10T09:56:58.453Z</published>
    <updated>2019-09-10T09:56:58.453Z</updated>
    
    <content type="html"><![CDATA[<p>大致讨论组件化的三种方案：url-block、protocol-class（和 url-controller 类似)、target-action，以及应用这三种组件化方案的时机、步骤、利弊等。</p><h2 id="一、为什么需要组件化"><a href="#一、为什么需要组件化" class="headerlink" title="一、为什么需要组件化"></a>一、为什么需要组件化</h2><p>随着公司业务的不断发展，项目的功能越来越复杂，各个业务代码耦合越来越多，代码量急剧增加，传统的 MVC 或者 MVVM 架构已经无法高效的管理工程代码，因此需要用一种技术来更好地管理工程，而组件化是一种能够解决代码耦合的技术。项目经过组件化的拆分，不仅可以解决代码耦合的问题，还可以增强代码的复用性，工程的易管理性等。</p><h2 id="二、什么时候做组件开发"><a href="#二、什么时候做组件开发" class="headerlink" title="二、什么时候做组件开发"></a>二、什么时候做组件开发</h2><ul><li><p>项目管理：项目的业务线超过 2 条以上，需要独立拆分。随着业务的拆分，对应的业务组件也就很自然的独立出来。</p></li><li><p>人员管理：过多人对同一块代码的进行修改，产生 bug 的可能性上升，所以需要重新分配人员和其维护的功能。</p></li><li><p>测试维度：随着项目的业务量增大，很难做单元测试。每个小功能修改，都需要对 App 进行测试，严重增加测试工作量。</p></li></ul><p>当 App 业务之间交叉耦合，bug 率难以下降，测试每天做大量重复工作。开发人员之间修改相互影响时，你需要考虑进行组件化。</p><p>组件化是项目架构层面的技术，不是所有项目都适合组件化，<font color="#cc0000">组件化一般针对的是大中型的项目，并且是多人开发</font>。如果，项目比较小，开发人员比较少，确实不太适合组件化，因为这时的组件化可能带来的不是便捷，而是增加了开发的工作量。另外，组件化过程也要考虑团队的情况，总之，根据目前项目的情况作出最合适的技术选型。</p><h2 id="三、组件化的过程"><a href="#三、组件化的过程" class="headerlink" title="三、组件化的过程"></a>三、组件化的过程</h2><h4 id="3-1-url-block"><a href="#3-1-url-block" class="headerlink" title="3.1 url-block"></a>3.1 url-block</h4><p>这是蘑菇街中使用的一种页面间调用的方式，通过<font color="#cc0000">在启动时注册组件</font>提供的服务，把调用组件使用的 url 和组件提供的服务 block 对应起来，保存到内存中。在使用组件的服务时，通过 url 找到对应的 block，然后获取服务。</p><p>url-block 的架构图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-bc2ca655eba6843c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"><br></center><p>注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[MGJRouter registerURLPattern:@&quot;mgj://detail?id=:id&quot; </span><br><span class="line">                    toHandler:^(NSDictionary * routerParameters) &#123;</span><br><span class="line">    NSNumber *id = routerParameters[@&quot;id&quot;];</span><br><span class="line">    // create view controller with id. push view controller</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[MGJRouter openURL:@&quot;mgj://detail?id=404&quot;]</span><br></pre></td></tr></table></figure><p>蘑菇街为了统一 iOS 和 Android 的平台差异性，专门用后台来管理 url，然后针对不同的平台生成不同类型的文件。</p><p>使用 url-block 的方案的确可以组件间解耦，但是还是存在其它明显的问题，比如：</p><ol><li>需要在内存中维护 url-block 的表，组件多了可能会有内存问题；</li><li>url 的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如 UIImage、NSData 等类型；</li><li>没有区分本地调用和远程调用的情况，尤其是远程调用会因为 url 参数受限，导致一些功能受限；</li><li>组件本身依赖了中间件，且分散注册使的耦合较多</li></ol><h4 id="3-2-protocol-class"><a href="#3-2-protocol-class" class="headerlink" title="3.2 protocol-class"></a>3.2 protocol-class</h4><p>针对方案 1 的问题，蘑菇街又提出了另一种组件化的方案，就是通过 protocol 定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把 protocol 和 class 做一个映射，同时在内存中保存一张映射表，使用的时就通过 protocol 找到对应的 class 来获取需要的服务。</p><p>protocol-class 的架构图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-161dc9fbcedaca0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"><br></center><p>注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ModuleManager registerClass:ClassA forProtocol:ProtocolA]</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ModuleManager classForProtocol:ProtocolA]</span><br></pre></td></tr></table></figure><p>蘑菇街的这种方案确实解决了方案 1 中无法传递非常规参数的问题，使得组件间的调用更为方便，但是它依然没有解决组件依赖中间件、内存中维护映射表、组件的分散调用的问题。设计思想和方案 1 类似，都是通过给组件加了一层 wrapper，然后给使用者调用。</p><h4 id="3-3-url-controller"><a href="#3-3-url-controller" class="headerlink" title="3.3 url-controller"></a>3.3 url-controller</h4><p>这是 <a href="https://github.com/Lede-Inc/LDBusMediator.git" target="_blank" rel="noopener">LDBusMediator</a> 的组件化方案。它是通过组件实现公共协议的接口，来对外提供服务。</p><p>具体就是通过单例来维护 url-controller 的映射关系表，根据调用者的 url，以及提供的参数（字典类型，所以参数类型不受约束）来返回对应的 controller 来提供服务；同时，为了增强组件提供服务的多样性，又通过服务协议定义了其它的服务。整体来看，LDBusMediator 解决了蘑菇街的这两种组件化方案的不足，比如：通过注册封装件 connector 而不是 block 来降低了内存占用；通过字典传递参数，解决了 url 参数的限制性。但是，由于使用了 connector 来提供服务而不是组件本身，把 connector 作为组件的一部分，依然有组件依赖中间件的问题。</p><p>LDBusMediator 的架构图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/1843940-509413f03657649d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"><br></center><h4 id="3-4-target-action"><a href="#3-4-target-action" class="headerlink" title="3.4 target-action"></a>3.4 target-action</h4><p>target-action 的方案是通过给组件包装一层 wrapper 来给外界提供服务，然后调用者通过依赖中间件来使用服务；其中，中间件是通过 runtime 来调用组件的服务，是真正意义上的解耦，也是该方案最核心的地方。具体实施过程是给组件封装一层 target 对象来对外提供服务，不会对原来组件造成入侵；然后，通过实现中间件的 category 来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。</p><p>target-action 的架构图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-cab5dd96a2de7eb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"><br></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)CTMediator_viewControllerForDetail</span><br><span class="line">&#123;</span><br><span class="line">    return [self performTarget:kCTMediatorTargetA </span><br><span class="line">                        action:kCTMediatorActionNativFetchDetailViewController </span><br><span class="line">                        params:@&#123; @&quot;key&quot; : @&quot;value&quot; &#125;</span><br><span class="line">             shouldCacheTarget:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是 target-action 方案有个问题就是在中间件的 category 里有 hardcode，casa 的解释是在组件间调用时，最好是去 model 化，所以不可避免的引入了 hardcode，并且所有的 hardcode 只存在于分类中。</p><p>针对这个问题，有人提议把所有的 model 做成组件化下沉，然后让所有的组件都可以自由的访问 model。这种方案虽然解决了组件间传递 model 的依赖问题，但是为了解决这个问题，直接把整个 model 层组件化后暴露给所有组件，容易造成数据泄露，付出的代价有点大。</p><p>针对这个问题，经过和网友讨论，一致觉得组件间调用时用字典传递数据，组件内调用时用 model 传递数据，这样既减少组件间数据对 model 的耦合，又方便了组件内使用 model 传递数据的便捷性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)CTMediator_viewControllerForDetail:(NSDictionary *)dict</span><br><span class="line">&#123;</span><br><span class="line">    return [self performTarget:kCTMediatorTargetA                         </span><br><span class="line">                        action:kCTMediatorActionNativFetchDetailViewController</span><br><span class="line">                        params:dict</span><br><span class="line">             shouldCacheTarget:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hardCode</p><ol><li><p>官方解释：将可变变量用一个固定值来代替的方法。用这种方法编译后，如果以后需要更改此变量就非常困难了。</p></li><li><p>hard code 是指“硬编码”，即将数据直接写在代码中。也就是，在程序中直接给变量赋值。指的是在软件实现上，把输出或输入的相关参数（例如：路径、输出的形式、格式）直接硬编码在源代码中，而非在运行时期由外界指定的设置、资源、数据、或者格式做出适当回应。</p></li><li><p>hard code 的双重性：</p><p> a. 直接将数据填写在源代码中，数据发生变化时，并不利于数据的修改，会造成程序的质量降低；</p><p> b. 保护一些数据，直接赋值，避免其发生变化。</p></li></ol><h2 id="四、组件化实施的方式"><a href="#四、组件化实施的方式" class="headerlink" title="四、组件化实施的方式"></a>四、组件化实施的方式</h2><p>组件化可以利用 git 的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的 podspec 上传到私有仓库，在需要用到组件时，直接从仓库里面取。</p><ol><li><p>壳工程</p><ul><li>main</li><li>AppDelegate</li><li>工程配置</li><li>Debug 页面</li></ul></li><li><p>封装公共库和基础 UI 库</p><p> 在具体的项目开发过程中，我们常会用到三方库和自己封装的 UI 库，我们可以把这些库封装成组件，然后在项目里用 pod 进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。</p></li><li><p>独立业务模块化</p><p> 在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。</p></li><li><p>服务接口最小化</p><p> 在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。</p><p> 公共组件：</p><ul><li>埋点组件</li><li>Common 组件（聚合工具类）</li><li>启动组件</li><li>性能监控组件</li><li>定位组件</li><li>图片处理组件</li><li>UIKit 封装和扩展组件</li><li><p>业务生命周期及通信组件</p><p>网络组件：</p></li><li><p>基于 AFNetworking 进行封装，提供 JSON 转 Model、缓存功能</p></li><li><p>DNS 加速组件</p><p>持久化组件</p></li><li><p>基于 FMDB 进行封装组件</p></li></ul></li></ol><pre><code>第三方业务组件*   分享组件*   推送组件基础业务组件*   User 组件，保存用户信息，登陆，登出状态</code></pre><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.cnblogs.com/fishbay/p/7216084.html" target="_blank" rel="noopener">iOS 组件化方案的几种实现</a><br><a href="https://my.oschina.net/u/2448717/blog/2222711" target="_blank" rel="noopener">iOS 的组件化开发</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大致讨论组件化的三种方案：url-block、protocol-class（和 url-controller 类似)、target-action，以及应用这三种组件化方案的时机、步骤、利弊等。&lt;/p&gt;
&lt;h2 id=&quot;一、为什么需要组件化&quot;&gt;&lt;a href=&quot;#一、为什么需
      
    
    </summary>
    
      <category term="iOS架构" scheme="http://yoursite.com/categories/iOS%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 编译过程原理(1)</title>
    <link href="http://yoursite.com/2019/09/10/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86(1)/"/>
    <id>http://yoursite.com/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/</id>
    <published>2019-09-10T09:56:58.452Z</published>
    <updated>2019-09-10T09:56:58.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>一般可以将编程语言分为两种，<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">编译语言</a>和<a href="https://en.wikipedia.org/wiki/Interpreted_language" target="_blank" rel="noopener">直译式语言</a>。</p><p>像 C++、Objective-C 都是编译语言。编译语言在执行的时候，必须<font color="#cc0000">先通过编译器生成机器码</font>，机器码可以直接在 CPU 上执行，所以执行效率较高。</p><p>像 JavaScript、Python 都是直译式语言。直译式语言不需要经过编译的过程，而是<font color="#cc0000">在执行的时候通过一个中间的解释器将代码解释为 CPU 可以执行的代码</font>。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。</p><p>iOS 开发目前的常用语言：Objective-C 和 Swift。二者都是编译语言，换句话说都是需要编译才能执行的。它们的编译都是依赖于 Clang(swift) + LLVM。本文只关注 Objective-C，原理上大同小异。</p><p>充分理解了编译的过程，会对你的开发大有帮助。本文的最后，会以以下几个例子，来讲解如何合理利用 XCode 和编译</p><ul><li>__attribute__</li><li>Clang 警告处理</li><li>预处理</li><li>插入编译期脚本</li><li>提高项目编译速度</li></ul><h2 id="二、iOS-编译"><a href="#二、iOS-编译" class="headerlink" title="二、iOS 编译"></a>二、iOS 编译</h2><p>Objective-C 采用 Clang 作为前端，而 Swift 则采用 swift() 作为前端，都是 LLVM（Low level vritual machine）作为编译器后端。所以简单的编译过程如图：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-3a4fe4a482e93bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br></center><p>其中，swift 的编译命令可以在这里找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift</span><br></pre></td></tr></table></figure><p>可以通过 Clang，来<font color="#cc0000">查看一个文件的编译具体过程</font>，新建 Demo.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">  </span><br><span class="line">int main()&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,@&quot;Hello Leo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~ $ cd /Users/dubin/Desktop/Demo/Demo</span><br><span class="line">Demo $ </span><br><span class="line">Demo $ clang -ccc-print-phases -framework Foundation Demo.m -o Demo </span><br><span class="line">0: input, &quot;Foundation&quot;, object</span><br><span class="line">1: input, &quot;Demo.m&quot;, objective-c</span><br><span class="line">2: preprocessor, &#123;1&#125;, objective-c-cpp-output  // 预处理</span><br><span class="line">3: compiler, &#123;2&#125;, ir                          // 编译生成 IR（中间代码）</span><br><span class="line">4: backend, &#123;3&#125;, assembler                    // 汇编器生成汇编代码</span><br><span class="line">5: assembler, &#123;4&#125;, object                     // 生成机器码</span><br><span class="line">6: linker, &#123;0, 5&#125;, image                      // 链接</span><br><span class="line">7: bind-arch, &quot;x86_64&quot;, &#123;6&#125;, image            // 生成 Image，也就是最后的可执行文件</span><br></pre></td></tr></table></figure><p>在终端运行这个程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo $ gcc -framework Foundation Demo.m -o Demo</span><br><span class="line">$ ./Demo</span><br><span class="line">2019-03-27 13:55:30.426 Demo[14155:5478670] Hello Leo</span><br></pre></td></tr></table></figure><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9a33d4c189414790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br></center><p>另一种终端运行 OC 程序的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo $ cc -c Demo.m</span><br><span class="line">Demo $ cc Demo.o -framework Foundation</span><br><span class="line">ld: warning: text-based stub file /System/Library/Frameworks//Foundation.framework/Foundation.tbd and library file /System/Library/Frameworks//Foundation.framework/Foundation are out of sync. Falling back to library file for linking.</span><br><span class="line">ld: warning: text-based stub file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation.tbd and library file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation are out of sync. Falling back to library file for linking.</span><br><span class="line">Demo $ ./a.out</span><br><span class="line">2019-03-27 14:01:52.933 a.out[14413:5483194] Hello Leo</span><br></pre></td></tr></table></figure><p>cc -c tst.m    编译：生成 tst.o文件</p><p>cc -c man.m        编译： 生成 man.o 文件</p><p>cc tst.o man.o -framework Foundation  链接、合并：生成 a.out 可执行文件</p><p>./a.out 运行</p><p>当然 OC 程序还可以混编 C 程序，格式为：cc -c x.m x.c，或者直接将编译和链接合在一起：cc x.m x.c</p><ol><li><p>编译器前端</p><p> 编译器前端的任务是：语法分析、语义分析、生成中间代码（intermediate representation）。在这个过程中<font color="#cc0000">会进行类型检查，如果发现错误或者警告会标注出来在哪一行</font>。</p> <center><br> <img src="https://upload-images.jianshu.io/upload_images/5294842-eba0d4d3a3fbec8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"><br> </center></li><li><p>编译器后端</p><p> 编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS 的编译过程，后端的处理如下</p><p> ①、LVVM 优化器会进行 BitCode 的生成，链接期优化等等。</p><p> <img src="https://upload-images.jianshu.io/upload_images/5294842-7fc3096f9cf495e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p><p> ②、LLVM 机器码生成器会针对不同的架构，比如 arm64 等生成不同的机器码。</p><p> <img src="https://upload-images.jianshu.io/upload_images/5294842-2037b2a6480b4d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p></li></ol><h2 id="三、执行一次-XCode-build-的流程"><a href="#三、执行一次-XCode-build-的流程" class="headerlink" title="三、执行一次 XCode build 的流程"></a>三、执行一次 XCode build 的流程</h2><p>当你在 XCode 中，选择 build 的时候（快捷键 command+B），会执行如下过程</p><ul><li>编译信息写入辅助文件，创建编译后的文件架构（name.app）</li><li>处理文件打包信息，例如在 debug 环境下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entitlements:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;application-identifier&quot; = &quot;app的bundleid&quot;;</span><br><span class="line">    &quot;aps-environment&quot; = development;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行 CocoaPod 编译前脚本。例如对于使用 CocoaPod 的工程会执行 <font color="#cc0000">CheckPods Manifest.lock</font></li><li>编译各个 .m 文件，使用 <font color="#cc0000">CompileC</font> 和 <font color="#cc0000">clang</font> 命令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</span><br><span class="line">export LANG=en_US.US-ASCII</span><br><span class="line">export PATH=&quot;...&quot;</span><br><span class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework  -iquote 所需要的Framework  ... -c ClassName.c -o ClassName.o</span><br></pre></td></tr></table></figure><p>通过这个编译的命令，我们可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang是实际的编译命令</span><br><span class="line">-x objective-c 指定了编译的语言</span><br><span class="line">-arch x86_64制定了编译的架构，类似还有arm7等</span><br><span class="line">-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。</span><br><span class="line">-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项</span><br><span class="line">-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span><br><span class="line">-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本</span><br><span class="line">-I 把编译信息写入指定的辅助文件</span><br><span class="line">-F 链接所需要的Framework</span><br><span class="line">-c ClassName.c 编译文件</span><br><span class="line">-o ClassName.o 编译产物</span><br></pre></td></tr></table></figure><ul><li>链接需要的 Framework，例如 Foundation.framework、AFNetworking.framework、AliPay.framework</li><li>编译 xib 文件</li><li>拷贝 xib，图片等资源文件到结果目录</li><li>编译 ImageAssets</li><li>处理 info.plist</li><li>执行 CocoaPod 脚本</li><li>拷贝 Swift 标准库</li><li>创建 .app 文件和对其签名</li></ul><h2 id="四、ipa-包的内容"><a href="#四、ipa-包的内容" class="headerlink" title="四、ipa 包的内容"></a>四、ipa 包的内容</h2><p>例如，通过 iTunes Store 下载微信，获得 ipa 安装包，然后实际看看其安装包的内容。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-475c1b17e4bc6ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"><br></center><ul><li>右键 ipa，重命名为 .zip</li><li>双击 zip 文件，解压缩后会得到一个文件夹。所以，<font color="#cc0000">ipa 包就是一个普通的压缩包</font>。</li></ul><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-a17d16dddf291011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"><br></center><ul><li>右键图中的 [WeChat[，选择显示包内容，然后就能够看到实际的 ipa 包内容了。</li></ul><h2 id="五、二进制文件的内容"><a href="#五、二进制文件的内容" class="headerlink" title="五、二进制文件的内容"></a>五、二进制文件的内容</h2><p>通过 XCode 的 Link Map File，我们可以窥探二进制文件中布局。在 XCode -&gt; Build Settings -&gt; 搜索 map -&gt; 开启Write Link Map File。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-ad796aa51811238f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"><br></center><p>开启后，再编译，我们可以在对应的 Debug/Release 目录下看到对应的 link map 的 text 文件。</p><p>默认的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Developer/Xcode/DerivedData/&lt;TARGET-NAME&gt;-对应ID/Build/Intermediates/&lt;TARGET-NAME&gt;.build/Debug-iphoneos/&lt;TARGET-NAME&gt;.build/</span><br></pre></td></tr></table></figure><p>例如 TargetName是 Demo 的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build</span><br></pre></td></tr></table></figure><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9879ec4e25c96df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"><br></center><p>这个映射文件的主要包含以下部分：</p><ol><li><p>Object files</p><p> 这个部分包括的内容：</p><ul><li>.o 文文件，也就是上文提到的 .m 文件编译后的结果。</li><li>.a 文件</li><li><p>需要 link 的 framework</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Arch: x86_64</span><br><span class="line"># Object files:</span><br><span class="line">[  0] linker synthesized</span><br><span class="line">[  1] dtrace</span><br><span class="line">[  2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o</span><br><span class="line">[  3] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/ViewController.o</span><br><span class="line">[  4] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/Person.o</span><br><span class="line">[  5] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyOperation.o</span><br><span class="line">[  6] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/main.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[130] /Applications/Xcode10.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//CoreGraphics.framework/CoreGraphics.tbd</span><br></pre></td></tr></table></figure><p>这个区域的存储内容比较简单：前面是文件的编号，后面是文件的路径。文件的编号在后续会用到。</p></li></ul></li><li><p>Sections</p><p> 这个区域<font color="#cc0000">提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小</font>。这个区域完整的描述了可执行文件中的全部内容。其中，段分为两种：</p><ul><li>__TEXT 代码段</li><li><p>__DATA 数据段</p><p>从 Sections 区域可以看到，代码段的 __text 节的地址是 0x100001000，大小是 0x000A5FF9，而二者相加的下一个位置正好是 __stubs 的位置 0x1000A6FFA。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Sections: </span><br><span class="line"># 位置           大小            段       节 </span><br><span class="line"># Address       Size            Segment Section</span><br><span class="line">0x1000010000x000A5FF9__TEXT__text             // 代码</span><br><span class="line">0x1000A6FFA0x000003D8__TEXT__stubs</span><br><span class="line">0x1000A73D40x00000678__TEXT__stub_helper</span><br><span class="line">0x1000A7A4C0x0000794A__TEXT__objc_methname    // OC 方法名</span><br><span class="line">0x1000AF3960x000079F4__TEXT__cstring          // 字符串</span><br><span class="line">0x1000B6D8A0x0000092C__TEXT__objc_classname   // OC 类名</span><br><span class="line">0x1000B76B60x00002293__TEXT__objc_methtype    // OC 方法类型</span><br><span class="line">0x1000B99500x000000E8__TEXT__const            // 常量</span><br><span class="line">0x1000B9A380x000043DC__TEXT__gcc_except_tab</span><br><span class="line">0x1000BDE140x0000004A__TEXT__ustring</span><br><span class="line">0x1000BDE5E0x00000166__TEXT__entitlements</span><br><span class="line">0x1000BDFC40x0000037B__TEXT__dof_RACSignal</span><br><span class="line">0x1000BE33F0x000002E8__TEXT__dof_RACCompou</span><br><span class="line">0x1000BE6280x000009CC__TEXT__unwind_info</span><br><span class="line">0x1000BF0000x00000010__DATA__nl_symbol_ptr</span><br><span class="line">0x1000BF0100x000001B8__DATA__got</span><br><span class="line">0x1000BF1C80x00000520__DATA__la_symbol_ptr</span><br><span class="line">0x1000BF6E80x00005D28__DATA__const</span><br><span class="line">0x1000C54100x00002E80__DATA__cfstring</span><br><span class="line">0x1000C82900x00000268__DATA__objc_classlist   // OC 方法列表</span><br><span class="line">0x1000C84F80x000001C0__DATA__objc_catlist</span><br><span class="line">0x1000C86B80x00000098__DATA__objc_protolist   // OC 协议列表</span><br><span class="line">0x1000C87500x00000008__DATA__objc_imageinfo</span><br><span class="line">0x1000C87580x0000F0C0__DATA__objc_const       // OC 常量</span><br><span class="line">0x1000D78180x00001B28__DATA__objc_selrefs</span><br><span class="line">0x1000D93400x00000040__DATA__objc_protorefs</span><br><span class="line">0x1000D93800x00000360__DATA__objc_classrefs</span><br><span class="line">0x1000D96E00x00000170__DATA__objc_superrefs   // OC 父类引用</span><br><span class="line">0x1000D98500x00000610__DATA__objc_ivar        // OC ivar</span><br><span class="line">0x1000D9E600x00001810__DATA__objc_data</span><br><span class="line">0x1000DB6700x00000768__DATA__data</span><br><span class="line">0x1000DBDD80x0000015F__DATA__bss</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Symbols</p><p> <font color="#cc0000">Section 部分将二进制文件进行了一级划分。而 Symbols 对 Section 中的各个段进行了二级划分</font>，例如，对于 __TEXT __text 表示代码段中的代码内容。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000010000x000A5FF9__TEXT__text             // 代码</span><br></pre></td></tr></table></figure><p> 而对应的 Symbols，起始地址也是 0x1000021B0。其中，文件编号和上文的编号对应</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x1000010000x000000A0[  2] +[MyProxy proxyWithObj:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o</span><br></pre></td></tr></table></figure><p> 具体内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># 地址           大小            文件编号 方法名</span><br><span class="line"># AddressSize    File  Name</span><br><span class="line">0x1000010000x000000A0[  2] +[MyProxy proxyWithObj:]</span><br><span class="line">0x1000010A00x00000040[  2] -[MyProxy methodSignatureForSelector:]</span><br><span class="line">0x1000010E00x000003F0[  2] -[MyProxy forwardInvocation:]</span><br><span class="line">0x1000014D00x00000040[  2] -[MyProxy .cxx_destruct]</span><br><span class="line">0x1000015100x00000048[  2] -[Dog barking:]</span><br><span class="line">0x1000015600x00000060[  3] -[ViewController dealloc]</span><br><span class="line">0x1000015C00x000001C0[  3] -[ViewController drawImage:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>到这里，我们知道 OC 的方法是如何存储的，再来看看 ivar 是如何存储的。</p><p>首先找到数据栈中 __DATA __objc_ivar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000D98500x00000610__DATA__objc_ivar</span><br></pre></td></tr></table></figure><p>然后，搜索这个地址 0x1000D9850，就能找到 ivar 的存储区域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000D98500x00000008[  2] _OBJC_IVAR_$_MyProxy.__innerObj</span><br></pre></td></tr></table></figure><p>值得一提的是，对于 String，会显式的存储到数据段中，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000AF3F20x00000004[  3] literal string: http://www.baidu.com</span><br></pre></td></tr></table></figure><p>所以，若果你的加密 Key 以明文的形式写在文件里，是一件很危险的事情。</p><h2 id="六、dSYM-文件"><a href="#六、dSYM-文件" class="headerlink" title="六、dSYM 文件"></a>六、dSYM 文件</h2><p>在每次编译过后，都会生成一个 dsym 文件。<font color="#cc0000">dsym 文件中，存储了 16 进制的函数地址映射</font>。</p><p>在 App 实际执行的二进制文件中，是通过地址来调用方法的。在 App crash 的时候，第三方工具（Fabric、友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含 crash 地址的调用信息。然后通过 dSYM 文件，我们就可以由地址映射到具体的函数位置。</p><p>XCode 中选择 Window -&gt; Organizer 可以看到生成的 archier 文件。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-6d216b1dd05b7413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"><br></center><p>然后</p><ul><li>右键 -> 在 finder 中显示。</li><li>右键 -> 查看包内容。</li></ul><p>关于如何用 dsym 文件来分析崩溃位置，查看另一篇博客：<a href="http://blog.csdn.net/hello_hwc/article/details/50036323" target="_blank" rel="noopener">iOS 如何调试第三方统计到的崩溃报告</a></p><h2 id="七、应用场景"><a href="#七、应用场景" class="headerlink" title="七、应用场景"></a>七、应用场景</h2><h4 id="7-1-attribute"><a href="#7-1-attribute" class="headerlink" title="7.1 __attribute__"></a>7.1 __attribute__</h4><p>或多或少都会在第三方库或者 iOS 的头文件中，见到过 __attribute__。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((warn_unused_result)) // 如果没有使用返回值，编译的时候给出警告</span><br></pre></td></tr></table></figure><p><font color="#cc0000">__attribtue__ 是一个高级的的编译器指令</font>，它允许开发者指定更多的编译检查和一些高级的<font color="#cc0000">编译期优化</font>。</p><p>分为三种：</p><ul><li>函数属性（Function Attribute）</li><li>类型属性（Variable Attribute）</li><li>变量属性（Type Attribute）</li></ul><p>语法结构</p><pre><code>__attribute__ 语法格式为：__attribute__ ((attribute-list))</code></pre><p>放在声明分号 “;” 前面。</p><p>比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) CLASSNAME * property __deprecated;</span><br></pre></td></tr></table></figure><p>好处：</p><p>给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的 API，但是被 __deprecated 的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新 Pod 的时候，代码无法运行了。</p><p>__attribtue__ 的使用场景很多，本文只列举 iOS 开发中常用的几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 弃用 API，用作 API 更新</span><br><span class="line">#define __deprecated__attribute__((deprecated)) </span><br><span class="line"></span><br><span class="line">// 带描述信息的弃用</span><br><span class="line">#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))</span><br><span class="line"></span><br><span class="line">// 遇到 __unavailable 的变量/方法，编译器直接抛出 Error</span><br><span class="line">#define __unavailable__attribute__((unavailable))</span><br><span class="line"></span><br><span class="line">// 告诉编译器，即使这个变量/方法没被使用，也不要抛出警告</span><br><span class="line">#define __unused__attribute__((unused))</span><br><span class="line"></span><br><span class="line">// 和 __unused 相反</span><br><span class="line">#define __used__attribute__((used))</span><br><span class="line"></span><br><span class="line">// 如果不使用方法的返回值，进行警告</span><br><span class="line">#define __result_use_check __attribute__((__warn_unused_result__))</span><br><span class="line"></span><br><span class="line">// OC 方法在 Swift 中不可用</span><br><span class="line">#define __swift_unavailable(_msg)__attribute__((__availability__(swift, unavailable, message=_msg)))</span><br></pre></td></tr></table></figure><h4 id="7-2-Clang-警告处理"><a href="#7-2-Clang-警告处理" class="headerlink" title="7.2 Clang 警告处理"></a>7.2 Clang 警告处理</h4><p>你一定还见过如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span><br><span class="line">/// 代码</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure><p>这段代码的作用是</p><ol><li><font color="#cc0000">对当前编译环境进行压栈</font></li><li>忽略 -Wundeclared-selector（未声明的）Selector 警告</li><li>编译代码</li><li>对编译环境进行出栈</li></ol><p>通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p><p>在另一篇文章：<a href="http://blog.csdn.net/Hello_Hwc/article/details/46425503" target="_blank" rel="noopener">iOS 合理利用 Clang 警告来提高代码质量</a>，详细的介绍了 XCode 的警告相关内容。</p><h4 id="7-3-预处理"><a href="#7-3-预处理" class="headerlink" title="7.3 预处理"></a>7.3 预处理</h4><p>所谓预处理，就是在编译之前的处理。<font color="#cc0000">预处理能够让你定义编译器变量，实现条件编译</font>。</p><p>比如，这样的代码很常见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">//...</span><br><span class="line">#else</span><br><span class="line">//...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>我们同样也可以定义其他预处理变量，在 XCode -&gt; 选中 Target -&gt; build settings 中，搜索 preprocessor。可以分别为 Debug 和 Release 两种模式设置预处理宏。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-f44b0523ec2d7d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"><br></center><p>比如加上：TESTMODE = 1，表示在这个宏中的代码运行在测试服务器。</p><p>然后，配合多个 Target（右键 Target，选择 Duplicate），单独一个 Target 负责测试服务器。这样就不用每次切换测试服务器都要修改代码了。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9e591436b1f5e436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"><br></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef TESTMODE</span><br><span class="line">// 测试服务器相关的代码</span><br><span class="line">#else</span><br><span class="line">// 生产服务器相关代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h4 id="7-4-插入脚本"><a href="#7-4-插入脚本" class="headerlink" title="7.4 插入脚本"></a>7.4 插入脚本</h4><p>通常，如果你使用 CocoaPod 来管理三方库，那么你的 Build Phase 是这样子的：</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-cbf92c80a034e8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13"><br></center><p>其中：[CP] 开头的就是 CocoaPod 插入的脚本。</p><ul><li>Check Pods Manifest.lock，用来检查 cocoapod 管理的三方库是否需要更新</li><li>Embed Pods Framework，运行脚本来链接三方库的静态/动态库</li><li>Copy Pods Resources，运行脚本来拷贝三方库的资源文件</li></ul><p>而这些配置信息都存储在这个文件（.xcodeproj）里。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-204e1892f65add4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14"><br></center><p>到这里，CocoaPod 的原理也就大致搞清楚了，<font color="#cc0000">通过修改 xcodeproject，然后配置编译期脚本</font>，来保证三方库能够正确的编译连接。</p><p>同样，我们也可以插入自己的脚本来做一些额外的事情。比如，每次进行 archive 的时候，我们都必须手动调整 target 的 build 版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buildNumber=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)</span><br><span class="line">buildNumber=$(($buildNumber + 1))</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;</span><br></pre></td></tr></table></figure><p>这段脚本其实很简单，读取当前 plist 的 build 版本号，然后对其 +1，重新写入。</p><p>使用起来也很简单：</p><ul><li>Xcode -&gt; 选中 Target -&gt; 选中 build phase</li><li>选择添加 Run Script Phase</li></ul><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-7390774f5a869394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"><br></center><ul><li>然后把这段脚本拷贝进去，并且勾选 Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为 Auto Increase build number</li></ul><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1bbe50512c4a785c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16"><br></center><ul><li>然后，拖动这个脚本的到 Link Binary With Libraries 下面。</li></ul><h4 id="7-5-脚本编译打包"><a href="#7-5-脚本编译打包" class="headerlink" title="7.5 脚本编译打包"></a>7.5 脚本编译打包</h4><p>脚本化编译打包对于 CI（持续集成）来说，十分有用。iOS 开发中，编译打包必备的两个命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编译成.app</span><br><span class="line">xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">// 打包</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</span><br><span class="line"></span><br><span class="line">// 通过 info 命令，可以查看到详细的文档</span><br><span class="line">info xcodebuild</span><br></pre></td></tr></table></figure><p>在本文最后的附录中，提供一个自动打包的脚本。</p><h4 id="7-6-提高项目编译速度"><a href="#7-6-提高项目编译速度" class="headerlink" title="7.6 提高项目编译速度"></a>7.6 提高项目编译速度</h4><p>通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了 XCode 的编译过程后，我们可以从以下角度来优化编译速度。</p><ol><li><p>查看编译时间</p><p> 我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。</p><p> 对于 XCode 8，关闭 XCode，终端输入以下指令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</span><br></pre></td></tr></table></figure></li></ol><pre><code>然后，重启 XCode，再编译，你会在这里看到编译时间。&lt;center&gt;![17](https://upload-images.jianshu.io/upload_images/5294842-699c09578e290bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;/center&gt;</code></pre><ol start="2"><li><p>代码层面的优化</p><ul><li><p>forward declaration</p><p>所谓 forward declaration，就是 @class CLASSNAME，而不是 #import CLASSNAME.h。这样，编译器能大大<font color="#cc0000">提高 #import 的替换速度</font>。</p></li><li><p>对常用的工具类进行打包（Framework/.a）</p><p>打包成 Framework 或者静态库，这样编译的时候这部分代码就<font color="#cc0000">不需要重新编译</font>了。</p></li><li><p>常用头文件放到预编译文件里</p><p>pch 文件是预编译文件，这里的内容在执行 XCode build 之前就已经被预编译，并且引入到了每一个 .m 文件里。</p></li></ul></li><li><p>编译器选项优化</p><ul><li><p>Debug 模式下，不生成 dsym 文件</p><p>上文提到了，dysm 文件里存储了调试信息，在 Debug 模式下，我们可以借助 XCode 和 LLDB 进行调试。所以，不需要生成额外的 dsym 文件来降低编译速度。</p></li><li><p>Debug 开启 Build Active Architecture Only</p><p>在 XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为 YES。这样做，可以只编译当前的版本，比如 arm7/arm64 等等，记得只开启 Debug 模式。这个选项在高版本的 XCode 中自动开启了。</p></li><li><p>Debug 模式下，关闭编译器优化</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-69b06dd791e83926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18"><br></center></li></ul></li></ol><h2 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h2><p>自动编译打包脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">export LC_ALL=zh_CN.GB2312;</span><br><span class="line">export LANG=zh_CN.GB2312</span><br><span class="line">buildConfig=&quot;Release&quot; //这里是build模式</span><br><span class="line">projectName=[find . -name *.xcodeproj | awk -F &quot;[/.]&quot; &apos;&#123;print $(NF-1)&#125;&apos;[</span><br><span class="line">projectDir=[pwd[</span><br><span class="line">wwwIPADir=~/Desktop/$projectName-IPA</span><br><span class="line">isWorkSpace=true</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">if [ -d &quot;$wwwIPADir&quot; ]; then</span><br><span class="line">echo $wwwIPADir</span><br><span class="line">echo &quot;文件目录存在&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;文件目录不存在&quot;</span><br><span class="line">mkdir -pv $wwwIPADir</span><br><span class="line">echo &quot;创建$&#123;wwwIPADir&#125;目录成功&quot;</span><br><span class="line">fi</span><br><span class="line">cd $projectDir</span><br><span class="line">rm -rf ./build</span><br><span class="line">buildAppToDir=$projectDir/build</span><br><span class="line">infoPlist=&quot;$projectName/Info.plist&quot;</span><br><span class="line">bundleVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlist`</span><br><span class="line">bundleIdentifier=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlist`</span><br><span class="line">bundleBuildVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist`</span><br><span class="line"></span><br><span class="line">if $isWorkSpace ; then  #是否用CocoaPod</span><br><span class="line">echo  &quot;开始编译workspace....&quot;</span><br><span class="line">xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">else</span><br><span class="line">echo  &quot;开始编译target....&quot;</span><br><span class="line">xcodebuild  -target  $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if test $? -eq 0</span><br><span class="line">then</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ipaName=[echo $projectName | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;[ #将项目名转小写</span><br><span class="line">findFolderName=[find . -name &quot;$buildConfig-*&quot; -type d |xargs basename[ #查找目录</span><br><span class="line">appDir=$buildAppToDir/$findFolderName/  #app所在路径</span><br><span class="line">echo &quot;开始打包$projectName.app成$projectName.ipa.....&quot;</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$appDir/$ipaName.ipa&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;打包$ipaName.ipa成功.&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;打包$ipaName.ipa失败.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">path=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipa</span><br><span class="line">cp -f -p $appDir/$ipaName.ipa $path   #拷贝ipa文件</span><br><span class="line">echo &quot;复制$ipaName.ipa到$&#123;wwwIPADir&#125;成功&quot;</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~结束编译，处理成功~~~~~~~~~~~~~~~~~~~&quot;</span><br></pre></td></tr></table></figure><h2 id="九、文章"><a href="#九、文章" class="headerlink" title="九、文章"></a>九、文章</h2><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/53557308" target="_blank" rel="noopener">iOS编译过程的原理和应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;一般可以将编程语言分为两种，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B7%A8
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>if-else、switch、while、for</title>
    <link href="http://yoursite.com/2019/09/10/C/if-else%E3%80%81switch%E3%80%81while%E3%80%81for/"/>
    <id>http://yoursite.com/2019/09/10/C/if-else、switch、while、for/</id>
    <published>2019-09-10T09:56:58.451Z</published>
    <updated>2019-09-10T09:56:58.452Z</updated>
    
    <content type="html"><![CDATA[<p>文章主要会涉及如下几个问题：</p><ol><li>if-else 和 switch-case 两者相比谁的效率会高些？在日常开发中该如何抉择？</li><li>如何基于赫夫曼树结构减少 if-else 分支判断次数？</li><li>如何巧妙的应用 do…while(0) 改善代码结构？</li><li>哨兵是什么东西？如何利用哨兵提高有序数组查找效率？</li><li>如何降低 for 循环嵌套的时间复杂度？</li><li>如何利用策略模式替换繁琐的 if-else 分支？</li></ol><h2 id="一、if-else-和-switch-case-效率问题"><a href="#一、if-else-和-switch-case-效率问题" class="headerlink" title="一、if-else 和 switch-case 效率问题"></a>一、if-else 和 switch-case 效率问题</h2><p>switch-case 与 if-else 的根本区别：</p><blockquote><p>switch 会生成一个<font color="#cc0000">跳转表</font>来指示实际的 case 分支的地址，而这个跳转表的索引号与 switch 变量的值是相等的。</p></blockquote><p>所以 switch-case 不用像 if-else 那样遍历条件分支直到命中条件，只需访问对应索引号的表项从而到达定位分支。</p><p>具体地说，switch-case 会生成一份大小（表项数）为最大 case 常量 +1 的跳转表，程序首先判断 switch 变量是否大于最大 case 常量，若大于，则跳到 default 分支处理；否则取得索引号为 switch 变量大小的跳表项的地址（即跳表的起始地址+表项大小 * 索引号），程序接着跳到此地址执行，到此完成了分支的跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    unsigned int i, j;</span><br><span class="line">    i = 3;</span><br><span class="line"></span><br><span class="line">    switch (i) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            j = 0;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case 1:</span><br><span class="line">            j = 1;</span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case 2:</span><br><span class="line">            j = 2;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case 3:</span><br><span class="line">            j = 3;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">            j = 4;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            j = 10;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 gcc 编译器，生成汇编代码（不开编译器优化）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">_main:                                  ## @main</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">.loc1 12 0                  ## /Users/cykj/Desktop/Demo/Demo/MyC.c:12:0</span><br><span class="line">.cfi_startproc</span><br><span class="line">## %bb.0:</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset %rbp, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">Ltmp0:</span><br><span class="line">.loc1 14 7 prologue_end     ## /Users/cykj/Desktop/Demo/Demo/MyC.c:14:7</span><br><span class="line">movl$3, -8(%rbp)</span><br><span class="line">.loc1 16 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:13</span><br><span class="line">movl-8(%rbp), %eax</span><br><span class="line">movl%eax, %ecx</span><br><span class="line">movq%rcx, %rdx</span><br><span class="line">subq$4, %rdx</span><br><span class="line">.loc1 16 5 is_stmt 0        ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:5</span><br><span class="line">movq%rcx, -24(%rbp)         ## 8-byte Spill</span><br><span class="line">movq%rdx, -32(%rbp)         ## 8-byte Spill</span><br><span class="line">jaLBB0_6</span><br><span class="line">## %bb.8:</span><br><span class="line">.loc1 0 5                   ## /Users/cykj/Desktop/Demo/Demo/MyC.c:0:5</span><br><span class="line">leaqLJTI0_0(%rip), %rax</span><br><span class="line">movq-24(%rbp), %rcx         ## 8-byte Reload</span><br><span class="line">movslq(%rax,%rcx,4), %rdx</span><br><span class="line">addq%rax, %rdx</span><br><span class="line">jmpq*%rdx</span><br><span class="line">LBB0_1:</span><br><span class="line">Ltmp1:</span><br><span class="line">.loc1 18 15 is_stmt 1       ## /Users/cykj/Desktop/Demo/Demo/MyC.c:18:15</span><br><span class="line">movl$0, -12(%rbp)</span><br><span class="line">.loc1 19 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:19:13</span><br><span class="line">jmpLBB0_7</span><br><span class="line">LBB0_2:</span><br><span class="line">.loc1 22 15                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:22:15</span><br><span class="line">movl$1, -12(%rbp)</span><br><span class="line">.loc1 23 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:23:13</span><br><span class="line">jmpLBB0_7</span><br><span class="line">LBB0_3:</span><br><span class="line">.loc1 26 15                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:26:15</span><br><span class="line">movl$2, -12(%rbp)</span><br><span class="line">.loc1 27 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:27:13</span><br><span class="line">jmpLBB0_7</span><br><span class="line">LBB0_4:</span><br><span class="line">.loc1 30 15                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:30:15</span><br><span class="line">movl$3, -12(%rbp)</span><br><span class="line">.loc1 31 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:31:13</span><br><span class="line">jmpLBB0_7</span><br><span class="line">LBB0_5:</span><br><span class="line">.loc1 34 15                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:34:15</span><br><span class="line">movl$4, -12(%rbp)</span><br><span class="line">.loc1 35 13                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:35:13</span><br><span class="line">jmpLBB0_7</span><br><span class="line">LBB0_6:</span><br><span class="line">.loc1 38 15                 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:38:15</span><br><span class="line">movl$10, -12(%rbp)</span><br><span class="line">Ltmp2:</span><br><span class="line">LBB0_7:</span><br><span class="line">.loc1 42 1                  ## /Users/cykj/Desktop/Demo/Demo/MyC.c:42:1</span><br><span class="line">movl-4(%rbp), %eax</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">Ltmp3:</span><br><span class="line">Lfunc_end0:</span><br><span class="line">.cfi_endproc</span><br><span class="line">.p2align2, 0x90</span><br><span class="line">.data_region jt32</span><br><span class="line">L0_0_set_1 = LBB0_1-LJTI0_0</span><br><span class="line">L0_0_set_2 = LBB0_2-LJTI0_0</span><br><span class="line">L0_0_set_3 = LBB0_3-LJTI0_0</span><br><span class="line">L0_0_set_4 = LBB0_4-LJTI0_0</span><br><span class="line">L0_0_set_5 = LBB0_5-LJTI0_0</span><br><span class="line">LJTI0_0:</span><br><span class="line">.longL0_0_set_1</span><br><span class="line">.longL0_0_set_2</span><br><span class="line">.longL0_0_set_3</span><br><span class="line">.longL0_0_set_4</span><br><span class="line">.longL0_0_set_5</span><br><span class="line">.end_data_region</span><br><span class="line">                                        ## -- End function</span><br></pre></td></tr></table></figure><p>由此看来，switch 有点以空间换时间的意思，而事实上也的确如此。</p><ol><li><p>当分支较多时，当时用 switch 的效率是很高的。因为 switch 是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是 if-else 是遍历所有的可能值，直到找到符合条件的分支。</p><p> 但不总是那么好，因为每次计算会有一个二次查表过程。 具体需要看应用场景，举个例子：对于网络层的协议分析，99% 可能都是 IP 协议，因此基本上会在第一个 if 时就命中，只有一次计算。</p><p> 总结：对于分支较多或分布相对均匀的情况，使用 switch 可以提高效率；对于分支较少或分布不均匀的情况，使用 if-else 更好。</p></li><li><p>由上面的汇编代码可知道，switch-case 占用较多的代码空间，因为它要生成跳转表，特别是当 case 常量分布范围很大但实际有效值又比较少的情况，switch-case 的空间利用率将变得很低。</p></li><li><p>switch-case 只能处理 case 为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用 switch-case 来处理的。所以 if-else 能应用于更多的场合，比较灵活。</p></li></ol><p>文章：<a href="https://blog.csdn.net/kehui123/article/details/5298337" target="_blank" rel="noopener">switch 与 if-else 的效率问题</a></p><h2 id="二、用-do-while-0-改善代码结构"><a href="#二、用-do-while-0-改善代码结构" class="headerlink" title="二、用 do-while(0) 改善代码结构"></a>二、用 do-while(0) 改善代码结构</h2><p>先看一段代码，要重点注意代码中的注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)handleString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    if (![str isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if(str.length &lt;= 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行</span><br><span class="line">    code1...code1</span><br><span class="line">     </span><br><span class="line">    // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果)，无论判断是否通过都要执行</span><br><span class="line">    code2...code2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试问，怎样做才能巧妙的满足上述注释代码的需求，因为上述代码中存在 return nil，一旦执行到此处，逻辑一和逻辑二处的伪代码都不会再执行。为了满足上述要求，我们可以巧妙的利用 break 退出临时构造的代码块，但不退出整个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)handleString:(NSString *)str &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if (![str isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str.length &lt;= 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行</span><br><span class="line">        code1...code2</span><br><span class="line">    &#125; while (0);    </span><br><span class="line">    </span><br><span class="line">    // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果),无论判断是否通过都要执行</span><br><span class="line">    code2...code2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、有序数组查找操作中的哨兵"><a href="#三、有序数组查找操作中的哨兵" class="headerlink" title="三、有序数组查找操作中的哨兵"></a>三、有序数组查找操作中的哨兵</h2><p>正常的查找处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr = @[@1, @2, @3, @4, @5];</span><br><span class="line">for (NSInteger i = 0; i &lt; arr.count; i++) &#123;</span><br><span class="line">    if ([arr[i] integerValue] == 2) &#123;</span><br><span class="line">        NSLog(@&quot;for 找到了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用哨兵进行查找处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)search:(NSNumber *)key array:(NSMutableArray *)arr</span><br><span class="line">&#123;</span><br><span class="line">    if (arr.count &lt;= 0) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSNumber * firstObj = (NSNumber *)arr[0];</span><br><span class="line">    if ([firstObj integerValue] == [key integerValue]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSInteger i = arr.count - 1;</span><br><span class="line">    NSLock * lock = [[NSLock alloc] init];</span><br><span class="line">    [lock lock];</span><br><span class="line">    arr[0] = key;</span><br><span class="line">    // 同上面 for 循环相比，i &lt; arr.count 的判断，在处理大批量数据时候，对性能提升比较大</span><br><span class="line">    while ([arr[i] integerValue] != [key integerValue]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[0] = firstObj;</span><br><span class="line">    [lock unlock];</span><br><span class="line"></span><br><span class="line">    return (i != 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上述两段代码，同样是在有序数组中查找目标为 2 的元素，第一段代码是常规迭代处理，第二段代码是将要查找的元素设置为哨兵。同第一段代码相比第二种方式<font color="#cc0000">少了 i &lt; arr.count 的判断</font>，在小批量有序数组查询中对效率的提升并无明显影响，但是在处理大批量数据时候，对性能提升还是比较明显的。</p><h2 id="四、多层-for-嵌套处理"><a href="#四、多层-for-嵌套处理" class="headerlink" title="四、多层 for 嵌套处理"></a>四、多层 for 嵌套处理</h2><p>实际开发中应尽量避免使用双层 for 循环，客户端数据量比较小可能实际开发中并不是很注意这些。但是后端开发过程中，数据量比较大, 为了提升性能，有些公司后端开发中可能会直接规定避免使用多层 for 循环嵌套的形式。<font color="#cc0000">一般第二层或更深层的 for 循环可以使用字典替换</font>。双层 for 循环嵌套的时间复杂度是 n 的二次方。但如果内部 for 循环用字典代替时间复杂度为 O(2n)（实际是 O(n)）。如：两个数组中有且只有一个相同元素，寻找该元素。其中一个数组就可以先用字典做保存，遍历第一个数组的时候，同字典中的数据做比较即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSArray *arr1 = @[@1, @2, @3, @4, @5];</span><br><span class="line">NSArray *arr2 = @[@5, @6, @7, @8];</span><br><span class="line">NSMutableDictionary * dict = [NSMutableDictionary dictionary];</span><br><span class="line">for (NSInteger i = 0; i &lt; arr2.count; i++) &#123;</span><br><span class="line">    [dict setObject:arr2[i] forKey:[NSString stringWithFormat:@&quot;%ld&quot;, i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (NSInteger i= 0 ; i &lt; arr1.count; i++) &#123;</span><br><span class="line">    NSNumber * number = [dict objectForKey:[NSString stringWithFormat:@&quot;%ld&quot;, i]];</span><br><span class="line">    if ([arr1[i] integerValue] == [number integerValue]) &#123;</span><br><span class="line">        NSLog(@&quot;相同的数据为:%@&quot;, number);</span><br><span class="line">        break;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、用策略模式替换-if-else"><a href="#五、用策略模式替换-if-else" class="headerlink" title="五、用策略模式替换 if-else"></a>五、用策略模式替换 if-else</h2><p><a href="https://www.jianshu.com/p/98fa80eebc52" target="_blank" rel="noopener">https://www.jianshu.com/p/98fa80eebc52</a></p><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://www.jianshu.com/p/ceed2daebc47" target="_blank" rel="noopener">用if else,switch,while,for颠覆你的编程认知</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章主要会涉及如下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;if-else 和 switch-case 两者相比谁的效率会高些？在日常开发中该如何抉择？&lt;/li&gt;
&lt;li&gt;如何基于赫夫曼树结构减少 if-else 分支判断次数？&lt;/li&gt;
&lt;li&gt;如何巧妙的应用 do…whil
      
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>FOUNDATION_EXTERN</title>
    <link href="http://yoursite.com/2019/09/09/iOS/iOS%E5%8E%9F%E7%90%86/FOUNDATION_EXTERN/"/>
    <id>http://yoursite.com/2019/09/09/iOS/iOS原理/FOUNDATION_EXTERN/</id>
    <published>2019-09-09T08:18:19.678Z</published>
    <updated>2019-09-09T08:19:39.649Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXTERN extern &quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXTERN extern</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>由以上定义可以看出 FOUNDATION_EXTERN 是可以兼容 C++ 的 extern 的宏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXTERN NSString * Extern_S = @&quot;sss&quot;;</span><br><span class="line"></span><br><span class="line">#define Define_S @&quot;sss&quot;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">NSString * s = @&quot;tt&quot;;</span><br><span class="line">    </span><br><span class="line">CFTimeInterval begin = CACurrentMediaTime();</span><br><span class="line">    </span><br><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">if ([s isEqualToString:Define_S]) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%f&quot;, CACurrentMediaTime() - begin);</span><br><span class="line">    </span><br><span class="line">begin = CACurrentMediaTime();</span><br><span class="line">    </span><br><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">if ([s isEqualToString:Extern_S]) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%f&quot;, CACurrentMediaTime() - begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-09-09 16:06:04.849874+0800 Demo[86518:3255355] 0.000148</span><br><span class="line">2019-09-09 16:06:04.850170+0800 Demo[86518:3255355] 0.000137</span><br></pre></td></tr></table></figure><p>extern 比宏在字符串上的比较速度要快一些，因为 extern 直接比较指针地址，而宏是比较字符串是否相等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>NSPredicate</title>
    <link href="http://yoursite.com/2019/08/31/iOS/iOS%E5%8E%9F%E7%90%86/NSPredicate/"/>
    <id>http://yoursite.com/2019/08/31/iOS/iOS原理/NSPredicate/</id>
    <published>2019-08-31T05:34:34.645Z</published>
    <updated>2019-09-03T09:55:42.400Z</updated>
    
    <content type="html"><![CDATA[<p>官方的解释:</p><blockquote><p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p></blockquote><p>NSPredicate 类是用来定义逻辑条件，用来有约束的获取内存中的对象或过滤搜索。</p><p>简而言之：只选取符合条件的对象。</p><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><p>使用谓词（NSPredicate）都需要为谓词定义<font color="#cc0000"><code>谓词表达式</code></font>，而这个表达式必须是一个返回 BOOL 的值。</p><p>谓词表达式由表达式、运算符和值构成。</p><h4 id="1-1-比较运算符"><a href="#1-1-比较运算符" class="headerlink" title="1.1 比较运算符"></a>1.1 比较运算符</h4><ol><li><p>=、==：判断两个表达式是否相等，在谓词中 = 和 == 是相同的意思，而没有赋值的概念。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString * string = @&quot;1234&quot;;</span><br><span class="line">NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF = &apos;1234&apos;&quot;];</span><br><span class="line"></span><br><span class="line">// 验证对象是否符合条件。底层调用了 [xx compare:] 方法</span><br><span class="line">if ([predicate evaluateWithObject:string]) &#123;</span><br><span class="line">    NSLog(@&quot;Evaluate Success!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    NSLog(@&quot;Evaluate Fail!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-31 11:53:35.305452+0800 Predicate[7069:1165684] Evaluate Success!</span><br></pre></td></tr></table></figure><p> 当传入数组对象时，报错：<font color="#cc0000">*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSArrayI compare:]: unrecognized selector sent to instance 0x600000234c00’</font>。可以发现底层调用了 compare: 方法。</p></li><li><p>>=、=>：判断左边表达式的值是否大于或等于右边表达式的值</p></li><li>\&lt;=、=\&lt;：判断左边表达式的值是否小于或等于右边表达式的值</li><li>>：判断左边表达式的值是否大于右边表达式的值</li><li>\&lt;：判断左边表达式的值是否小于右边表达式的值</li><li>!=、\&lt;>：判断两个表达式是否不相等</li></ol><h4 id="1-2-逻辑运算符"><a href="#1-2-逻辑运算符" class="headerlink" title="1.2 逻辑运算符"></a>1.2 逻辑运算符</h4><ol><li>AND、&amp;&amp;：逻辑与。两个表达式的值都为 YES 时，结果才为 YES。</li><li>OR、||：逻辑或。要求其中一个表达式为 YES 时，结果就是 YES。</li><li>NOT、!：逻辑非。对原有的表达式取反</li></ol><h4 id="1-3-关系运算符"><a href="#1-3-关系运算符" class="headerlink" title="1.3 关系运算符"></a>1.3 关系运算符</h4><ol><li><p>ANY、SOME：集合中任意一个元素满足条件，就返回 YES。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">NSArray * arr = @[ person1, person2, ... ];  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-31 13:33:03.764130+0800 Predicate[8478:1206451] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;The left hand side for an ALL or ANY operator must be either an NSArray or an NSSet.&apos;</span><br></pre></td></tr></table></figure></li></ol><pre><code>根据报错信息得知，谓词表达式中 ANY 的操作的主体需要是 NSArray 或者 NSSet。上面 filteredArrayUsingPredicate: 方法传入的是 Person 对象，所以报错，因此 ANY 操作的数据结构要是 @[ @[] ] 双层数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">NSArray * arr = @[ @[ person1, person2, ... ] ];  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>ALL：集合中所有元素都满足条件，才返回 YES。</li><li>NONE：集合中没有任何元素满足条件就返回 YES，等同于 not any。如: NONE person.age &lt; 18，表示 person 集合中所有元素的 age &gt;= 18 时，才返回 YES。</li><li><p>IN：等价于 SQL 语句中的 IN 运算符，只有当左边表达式或值出现在右边的集合中才会返回 YES</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predicateString = @&quot;self.name IN &#123;&apos;Tom&apos;,&apos;Jay&apos;&#125; || self.age IN&#123;25,30&#125;&quot;;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:predicateString];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@ = %@&quot;, predicateString, [self.persons filteredArrayUsingPredicate:predicate]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-4-范围运算符"><a href="#1-4-范围运算符" class="headerlink" title="1.4 范围运算符"></a>1.4 范围运算符</h4><ol><li><p>BETWEEN：BETWEEN 表达式必须满足表达式 <font color="#cc0000">BETWEEN {下限，上限}</font> 的格式，要求该表达式必须大于或等于下限，并小于或等于上限</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSNumber * number = @(1234);</span><br><span class="line">   predicate = [NSPredicate predicateWithFormat:@&quot;SELF BETWEEN &#123;1000, 2000&#125;&quot;];</span><br><span class="line">   </span><br><span class="line">   if ([predicate evaluateWithObject:number]) &#123;</span><br><span class="line">       NSLog(@&quot;Success!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">       NSLog(@&quot;Fail!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   2019-08-31 13:06:59.443083+0800 Predicate[8050:1192540] Success!</span><br></pre></td></tr></table></figure></li><li><p>IN</p></li></ol><h4 id="1-5-字符串比较运算符"><a href="#1-5-字符串比较运算符" class="headerlink" title="1.5 字符串比较运算符"></a>1.5 字符串比较运算符</h4><ol><li>BEGINSWITH：检查某个字符串是否以指定的字符串开头</li><li>ENDSWITH：检查某个字符串是否以指定的字符串结尾</li><li>CONTAINS：检查某个字符串是否包含指定的字符串</li><li>LIKE：检查某个字符串是否匹配指定的字符串模板。其之后可以跟 ? 代表一个字符和 * 代表任意多个字符。比如 “name LIKE ‘*ac*‘“，这表示 name 的值中包含 ac 则返回 YES；”name LIKE ‘?ac*’”，表示 name 的第 2、3 个字符为 ac 时返回 YES。</li><li>MATCHES：检查某个字符串是否匹配指定的正则表达式。虽然<font color="#cc0000">正则表达式的执行效率是最低的</font>，但其功能是最强大的，也是我们最常用的。</li></ol><p>注意：字符串比较都是区分大小写和重音符号的。如：café 和 cafe 是不一样的，Cafe 和 cafe 也是不一样的。如果希望字符串比较运算不区分大小写和重音符号，请在这些运算符后使用 <font color="#cc0000">[c]、[d]</font> 选项。其中 [c] 是不区分大小写，[d] 是不区分重音符号，其写在字符串比较运算符之后，比如：name LIKE[cd] ‘cafe’，那么不论 name 是cafe、Cafe 还是 café 上面的表达式都会返回 YES。</p><h4 id="1-6-直接量"><a href="#1-6-直接量" class="headerlink" title="1.6 直接量"></a>1.6 直接量</h4><p>在谓词表达式中可以使用如下直接量</p><ol><li>FALSE、NO：代表逻辑假</li><li>TRUE、YES：代表逻辑真</li><li>NULL、NIL：代表空值</li><li>SELF：代表正在被判断的对象自身，不区分大小写，self 也可以。</li><li>“string” 或 ‘string’：代表字符串</li><li>数组：和 c 中的写法相同，如：{‘one’, ‘two’, ‘three’}。</li><li>数值：包括整数、小数和科学计数法表示的形式</li><li>十六进制数：0x开头的数字</li><li>八进制：0o开头的数字</li><li>二进制：0b开头的数字</li></ol><h4 id="1-7-数组操作"><a href="#1-7-数组操作" class="headerlink" title="1.7 数组操作"></a>1.7 数组操作</h4><ol><li>array[index]：指定数组中特定索引处的元素。</li><li>array[first]：指定第一个元素</li><li>array[last]：指定最后一个元素</li><li>array[size]：指定数组大小</li></ol><h4 id="1-8-保留字"><a href="#1-8-保留字" class="headerlink" title="1.8 保留字"></a>1.8 保留字</h4><p>下列单词都是保留字（不区分大小写）</p><p>AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSEPREDICATE</p><blockquote><p>虽然大小写都可以，但是更推荐使用大写来表示这些保留字</p></blockquote><h2 id="二、谓词的用法"><a href="#二、谓词的用法" class="headerlink" title="二、谓词的用法"></a>二、谓词的用法</h2><h4 id="2-1-数据校验"><a href="#2-1-数据校验" class="headerlink" title="2.1 数据校验"></a>2.1 数据校验</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// MATCHES（正则表达式）</span><br><span class="line">NSString * phoneRegex = @&quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;;</span><br><span class="line">NSString * phoneNumber = @&quot;15180168516&quot;;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, phoneRegex];</span><br><span class="line">    </span><br><span class="line">if ([predicate evaluateWithObject:phoneNumber]) &#123;</span><br><span class="line">    NSLog(@&quot;%@ 是电话号码!&quot;, phoneNumber);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    NSLog(@&quot;%@ 不是电话号码!&quot;, phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evaluateWithObject: 方法返回的是一个 BOOL 值，如果符合条件就返回 YES，不符合就返回 NO。常见的有判断手机号码、邮编等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 检测字符串中是否有特殊字符</span><br><span class="line">- (BOOL)checkSpecialCharacter:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    NSString *regex = @&quot;[`~!@#$^&amp;*()=|&#123;&#125;&apos;:;&apos;,\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“&apos;。，、？]+&quot;;</span><br><span class="line">    NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];</span><br><span class="line">    return [pred evaluateWithObject:string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-过滤集合"><a href="#2-2-过滤集合" class="headerlink" title="2.2 过滤集合"></a>2.2 过滤集合</h4><p>谓词本身就代表了一个逻辑条件，计算谓词之后返回的结果永远为 BOOL 类型的值。而谓词最常用的功能就是对集合进行过滤。当程序使用谓词对集合元素进行过滤时，程序会自动遍历其元素，并根据集合元素来计算谓词的值，当这个集合中的元素计算谓词并返回 YES 时，这个元素才会被保留下来。请注意程序会自动遍历其元素，它会将自动遍历过之后返回为YES的值重新组合成一个集合返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  NSArray</span><br><span class="line"> * @return  使用指定的谓词过滤 NSArray 集合，返回符合条件的元素组成的新集合</span><br><span class="line"> */</span><br><span class="line">- (NSArray&lt;ObjectType&gt; *)filteredArrayUsingPredicate:(NSPredicate *)predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  使用指定的谓词过滤 NSMutableArray，剔除集合中不符合条件的元素</span><br><span class="line"> */</span><br><span class="line">- (void)filterUsingPredicate:(NSPredicate *)predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  NSSet</span><br><span class="line"> */</span><br><span class="line">- (NSSet&lt;ObjectType&gt; *)filteredSetUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  NSMutableSet</span><br><span class="line"> */</span><br><span class="line">- (void)filterUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);</span><br></pre></td></tr></table></figure><p>使用谓词过滤不可变集合和可变集合的区别是：过滤不可变集合时，会返回符合条件的集合元素<font color="#cc0000">组成</font>的新集合；过滤可变集合时，没有返回值，会直接<font color="#cc0000">剔除</font>不符合条件的集合元素。</p><h4 id="2-3-在谓词中使用占位符参数"><a href="#2-3-在谓词中使用占位符参数" class="headerlink" title="2.3 在谓词中使用占位符参数"></a>2.3 在谓词中使用占位符参数</h4><p>上面所有的例子中谓词总是固定的，然而我们在现实中处理变量时决定了谓词应该是可变的。</p><p>首先如果我们想在谓词表达式中使用变量，那么我们需要了解下列两种占位符：</p><blockquote><p>%K：用于动态传入属性名<br>%@：用于动态设置属性值</p></blockquote><p>相当于变量名与变量值。</p><p>除此之外，还可以在谓词表达式中使用动态改变的属性值，就像环境变量一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate * predicate1 = [NSPredicate predicateWithFormat:@&quot;%K CONTAINS %@&quot;, key, value];</span><br><span class="line">NSArray * filterArray = [array filteredArrayUsingPredicate:predicate];</span><br><span class="line"></span><br><span class="line">// 包含 $VALUE 字符串</span><br><span class="line">NSPredicate * predicateTemp = [NSPredicate predicateWithFormat:@&quot;%K &gt; $VALUE&quot;, @&quot;age&quot;];</span><br><span class="line">// 指定 $VALUE 的值为 25</span><br><span class="line">NSPredicate * predicate2 = [predicateTemp predicateWithSubstitutionVariables:@&#123; @&quot;VALUE&quot; : @25&#125; ];</span><br><span class="line">filterArray = [array filteredArrayUsingPredicate:predicate2];</span><br></pre></td></tr></table></figure><h2 id="三、文章"><a href="#三、文章" class="headerlink" title="三、文章"></a>三、文章</h2><p><a href="https://www.jianshu.com/u/c2f0de304708" target="_blank" rel="noopener">sunny_zl</a> &amp; <a href="https://www.jianshu.com/p/88be28860cde" target="_blank" rel="noopener">iOS中的谓词（NSPredicate）使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or fo
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>静态、动态 pod</title>
    <link href="http://yoursite.com/2019/08/30/iOS/iOS%E5%8E%9F%E7%90%86/%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%20Pod/"/>
    <id>http://yoursite.com/2019/08/30/iOS/iOS原理/静态、动态 Pod/</id>
    <published>2019-08-30T07:20:43.836Z</published>
    <updated>2019-09-03T09:52:56.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、静态和动态"><a href="#一、静态和动态" class="headerlink" title="一、静态和动态"></a>一、静态和动态</h2><p>在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。</p><p>当在 podfile 中指定 use_frameworks! 时，子模块和第三方类库将被打包成 <code>.framework</code> 动态库，模块之间的代码不能直接引用，需要添加依赖；</p><center><br><img src="http://dzliving.com/DynamicModule2.png" alt><br></center><p>反之（默认情况）将打包成 <code>.a</code> 静态库。</p><center><br><img src="http://dzliving.com/StaticModule3.png" alt><br></center><p>动态库和静态库的区别：</p><ul><li>资源加载方式</li><li>包的大小 </li><li>编译速度</li></ul><h4 id="1-1-资源加载方式"><a href="#1-1-资源加载方式" class="headerlink" title="1.1 资源加载方式"></a>1.1 资源加载方式</h4><ol><li><p>s.dependency ‘xx’</p><p> 静态方式中各模块的 podspec 文件不用设置依赖，就可以直接 #import 其他模块的类头文件。</p> <center><br>￼    <img src="http://dzliving.com/StaticModule1.png" alt><br> </center><p> 而动态方式则会报错。</p> <center><br> <img src="http://dzliving.com/DynamicModule1.png" alt><br> </center></li></ol><ol start="2"><li><p>s.resources</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.resources = [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt&#125;&apos;, &apos;Resource/**/*&apos;]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">图片等资源是都放入 mainbundle，直接用 imageNamed: 访问，不用增加很多获取 bundle 的代码。</span><br></pre></td></tr></table></figure><p> s.resource = ‘xx/xxx.bundle’</p><p> s.resource_bundles = { ‘xxx’ =&gt; [‘/Classes/<strong>/*.{xib,storyboard,Bundle,png,gif,jpg,jpeg,txt}’, ‘Resource/</strong>/*’] }</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这两种写法，资源都在模块自己的 bundle 里面，文件名为 xxx.bundle，工程中需要通过 ``bundleForClass`` 等获取资源路径。</span><br><span class="line"></span><br><span class="line">#### 1.2 包的大小</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/StaticModule2.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">在图中，上面的是使用 use\_frameworks! 的动态包， 下面的是默认（或使用 use\_modular\_headers!）的静态包，几次验证，都是&lt;font color=#cc0000&gt;动态的更小&lt;/font&gt;。</span><br><span class="line"></span><br><span class="line">#### 1.3 编译速度</span><br><span class="line"></span><br><span class="line">这个未验证。</span><br><span class="line"></span><br><span class="line">#### 1.4 工程实例</span><br><span class="line"></span><br><span class="line">在项目开发中的场景是一个第三方类库 bongSDK.framework 引入了 Realm.framework 和 RealmSwift.framework，RealmSwift.framework 是通过 swift 语言写的，它的内部调用 Realm。</span><br><span class="line"></span><br><span class="line">最初静态方式的 pod 遇到了难以理解的报错，因为知识的欠缺和时间的紧迫，放弃了静态这条路，使用 use\_frameworks! 动态 pod 的方式。</span><br><span class="line"></span><br><span class="line">动态方式在 pod install 阶段没有报错，但子模块需要添加依赖，更困难的是图片、xib、storyboard 等资源需要获取到模块的 bundle 才能加载，导致工程大面积的图片加载错误，页面跳转崩溃。因此不得不增加很多获取 bundle 路径的代码，修改的位置几百上千处。</span><br><span class="line"></span><br><span class="line">```oc</span><br><span class="line">+ (NSBundle *)bundleWithClassName:(Class)cls moduleName:(NSString*)module</span><br><span class="line">&#123;</span><br><span class="line">    if (module == nil) &#123;</span><br><span class="line">        return [NSBundle mainBundle];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSBundle * bundle = [NSBundle bundleForClass:cls];</span><br><span class="line">    NSURL * bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;];</span><br><span class="line">    </span><br><span class="line">    if (bundleURL == nil) &#123;</span><br><span class="line"></span><br><span class="line">        __block UINavigationController* nav;</span><br><span class="line">        [[UIApplication sharedApplication].windows enumerateObjectsUsingBlock:^(__kindof UIWindow * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            UIViewController * windowVC = obj.rootViewController;</span><br><span class="line">            if ([windowVC isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">                nav = (UINavigationController *)windowVC;</span><br><span class="line">                *stop = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        if (nav != nil) &#123;</span><br><span class="line">            Class callerCls = [nav.viewControllers.firstObject class];</span><br><span class="line">            bundle = [NSBundle bundleForClass:callerCls];</span><br><span class="line">            bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bundleURL == nil) &#123;</span><br><span class="line">            return [NSBundle mainBundle];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>图片加载则更加困难，因为很多图片是在 xib 中写的，通过断点发现，系统并没有调用 <code>imageNamed:</code> 方法，导致使用 runtime 替换方法实现图片位置修改的方式失败，通过查找资料，发现 xib 中的 UIButton、UIImageView 会调用 <code>- initWithCoder:</code> 方法，底层会调用 UINibDecoder 类的 <code>decodeObjectForKey</code>。</p><p>runtime 替换 decodeObjectForKey 方法后，打印输出发现，UIButton、UIImageView 控件加载的图片名称在 <font color="#cc0000"><code>UIResourceName</code></font> 字段。由此就有了如下的处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    _imageViewImageArray = [NSMutableArray arrayWithCapacity:2];</span><br><span class="line"></span><br><span class="line">    propKey = [CYKJXUtil stringByReversed:@&quot;emaNecruoseRIU&quot;];</span><br><span class="line">    btnKey = [CYKJXUtil stringByReversed:@&quot;tnetnoClufetatSnottuBIU&quot;];</span><br><span class="line"></span><br><span class="line">    // hook UINibDecoder      - decodeObjectForKey:</span><br><span class="line">    NSString* clsName = [NSString stringWithFormat:@&quot;redoce%@biNIU&quot;, @&quot;D&quot;];</span><br><span class="line">    clsName = [CYKJXUtil stringByReversed:clsName];</span><br><span class="line"></span><br><span class="line">    [HookTool exchangeInstanceMethod:NSClassFromString(clsName)</span><br><span class="line">                         originalSEL:@selector(decodeObjectForKey:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_decodeObjectForKey:)];</span><br><span class="line"></span><br><span class="line">    // hook UIImageView        - initWithCoder:</span><br><span class="line">    [HookTool exchangeInstanceMethod:UIImageView.class</span><br><span class="line">                         originalSEL:@selector(initWithCoder:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_imageView_initWithCoder:)];</span><br><span class="line"></span><br><span class="line">    // hook UIButton        - initWithCoder:</span><br><span class="line">    [HookTool exchangeInstanceMethod:UIButton.class</span><br><span class="line">                         originalSEL:@selector(initWithCoder:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_button_initWithCoder:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)swizzle_decodeObjectForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function;</span><br><span class="line">    id value = functionPoint(self, _cmd, key);</span><br><span class="line">    </span><br><span class="line">    // 保存图片名称</span><br><span class="line">    if ([key isEqualToString:propKey]) &#123;</span><br><span class="line">        [_imageViewImageArray addObject:value];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 保存 button 状态数据</span><br><span class="line">    if ([key isEqualToString:btnKey]) &#123;</span><br><span class="line">        if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            _buttonImageDictionary = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UIImageView</span><br><span class="line"></span><br><span class="line">- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。</span><br><span class="line">    // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。</span><br><span class="line">    [_imageViewImageArray removeAllObjects];</span><br><span class="line"></span><br><span class="line">    UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder];</span><br><span class="line"></span><br><span class="line">    // 设置 image</span><br><span class="line">    if (_imageViewImageArray.count &gt; 0) &#123;</span><br><span class="line">        UIImage * normalImage = [HookTool imageAfterSearch:_imageViewImageArray[0]];</span><br><span class="line">        if (normalImage) &#123;</span><br><span class="line">            instance.image = normalImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置 highlightedImage</span><br><span class="line">    if (_imageViewImageArray.count &gt; 1) &#123;</span><br><span class="line">        UIImage * highlightedImage = [HookTool imageAfterSearch:_imageViewImageArray[1]];</span><br><span class="line">        if (highlightedImage) &#123;</span><br><span class="line">            instance.highlightedImage = highlightedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UIButton</span><br><span class="line"></span><br><span class="line">- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。</span><br><span class="line">    // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。</span><br><span class="line">    [_imageViewImageArray removeAllObjects];</span><br><span class="line">    _buttonImageDictionary = nil;</span><br><span class="line">    </span><br><span class="line">    UIButton * instance = (UIButton *)[self swizzle_button_initWithCoder:aDecoder];</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_buttonImageDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key,</span><br><span class="line">                                                                    id  _Nonnull obj,</span><br><span class="line">                                                                    BOOL * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            if (_imageViewImageArray.count == 0) &#123;</span><br><span class="line">                *stop = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                switch ([key integerValue]) &#123;</span><br><span class="line">                    case ButtonImageOrder_Normal:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateNormal];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Highlighted:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateHighlighted];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Selected:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateSelected];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Disabled:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateDisabled];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的代码：<a href="https://github.com/BiYJ/ImageTool" target="_blank" rel="noopener">ImageTool</a></p><p>如上可见，这种动态方式对于编码并不友好，资源必须要特定的 bundle，一旦资源路径出错，轻则图片未加载，重则程序崩溃。</p><p>所以需要研究下如果使用静态方式 pod 子模块代码。</p><p>首先将 use_frameworks! 删除，重新执行 pod install，等 Pod installation complete! 之后，运行工程，报错，一个一个的解决。</p><ol><li><p>dyld: Library not loaded: @rpath/Realm.framework/Realm</p><p> 现在不用 pod 导入 realm，而是将 realm.framework 拖入 basicModule 工程。这里找了<a href="https://static.realm.io/downloads/objc/realm-objc-3.13.1.zip?_ga=2.256310156.625208557.1551076206-43540051.1551076206" target="_blank" rel="noopener">官方最新的</a> realm.framework，它分为静态版和动态版，添加到工程的 <code>Embedded Binaries</code>，编译时报错 <code>Unknown type name namespace</code>。</p><p> 不管通过修改 .h 为 .hpp，还是修改 build settings -&gt; Compile Sources As -&gt; Objectoive-C++ 都没有效果，无计可施之时想到了，可以将 use_frameworks! 时 cocoapods 生成 的 Realm.framework 拷贝一份，拖入工程死马等活马医。</p><p> 编译运行，这个问题解决了~</p></li><li><p>Argument list too long: recursive header expansion failed</p><p> Search Paths -&gt; Header Search Paths，去掉 <code>$(PODS_ROOT)/**</code>，去掉不必要的 <code>recursive</code> search。</p></li></ol><p>其余的就是解决一些资源加载问题，资源重名问题，动态库的引用问题 #import “” 改为 #import &lt;&gt;。</p><center><br><img src="http://dzliving.com/DuplicateFile.png" alt><br></center>    <h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://juejin.im/post/5bea871ef265da612e282f54" target="_blank" rel="noopener">关于Argument list too long的问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、静态和动态&quot;&gt;&lt;a href=&quot;#一、静态和动态&quot; class=&quot;headerlink&quot; title=&quot;一、静态和动态&quot;&gt;&lt;/a&gt;一、静态和动态&lt;/h2&gt;&lt;p&gt;在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编程思想</title>
    <link href="http://yoursite.com/2019/08/17/iOS/iOS%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2019/08/17/iOS/iOS原理/编程思想/</id>
    <published>2019-08-17T15:41:19.406Z</published>
    <updated>2019-09-03T09:52:51.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链式编程"><a href="#一、链式编程" class="headerlink" title="一、链式编程"></a>一、链式编程</h2><blockquote><p>链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[self one] two];</span><br></pre></td></tr></table></figure><p>在 Objective-C 中，没有传递参数的方法可以写成<font color="#cc0000">点语法</font>的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.one.two;</span><br></pre></td></tr></table></figure><p>上面的写法会产生警告：<code>Property access result unused - getters should not be used for side effects</code>。这是因为 two 方法被当成 <font color="#cc0000"><code>getter</code></font> 方法，getter 方法会有返回值，self.one.two 没有使用该返回值。</p><blockquote><p>Objective-C : 点语法 + 事务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.one.two(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void(^)(NSString *))two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    return ^ (NSString * s) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, s);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-17 19:45:34.079059+0800 Demo[858:23949] 1</span><br><span class="line">2019-08-17 19:45:34.079188+0800 Demo[858:23949] 2</span><br><span class="line">2019-08-17 19:45:34.079271+0800 Demo[858:23949] 3</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>经典使用链式编程思想的开源代码：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a></p><h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><p>在数学中 y = f(x), y = f(f(x)) 都是函数，x 既可以是一个简单的参数，也可以是一个表达式。</p><p>在 OC 中，将 block 作为参数传递可实现<font color="#cc0000">灵活的</font>函数封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two:(void (^)(NSString *))block</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    block(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.one two:^(NSString * s) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, s);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>函数式编程（Functional Programming）相对于要理解「函数」，我们更需要理解的其实是「状态」。</p><h4 id="2-1-状态"><a href="#2-1-状态" class="headerlink" title="2.1 状态"></a>2.1 状态</h4><p>说到状态，很容易会联想到变量、局部变量、全局变量、property、model，这些都可以成为状态，但变量和状态又不是一回事，要真正理解状态，得先理解下面一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>简单的一行代码，分析起来却有不少门道。</p><ul><li>「i」就是变量，一个变量可以看做是一个实体，真实存在于内存空间的实体。</li><li>int 是它的类型信息，是对于它的一种约束。</li><li>0 是它被赋予的一个值。</li></ul><p>变量是我们要分析的目标。它的类型信息、值信息虽然会约束变量的行为，但不是我们关注的重点，真正让变量变得危险的是中间的等号，= 是个赋值操作，意味着改变 i 的值，原本处于<font color="#cc0000">静态的</font> i，由于一个 = 发生了变化，它的值可以变为 1，或者 10000，或者其他任何值，我们可以说这个变量有了状态。</p><p>状态也是个相对的概念，变量都有其生命周期，一旦变量被回收，其所包含的状态也随之消失，所以状态所带来的影响是受限于变量的生命周期的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)<span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是函数 do 方法内部的临时变量，分配在内存的栈上。在 do 函数内部这个空间范畴来说，i 是有状态的，i 被赋予了值 0。一旦 return，i 的生命周期也随之结束，其所对应的状态也消失了。所以一旦出了do，i 又变得没有状态了。代码虽然执行了 return i，但返回的其实是 i 所代表的值，i 将自己的值交出来之后，就完成了自己的使命。</p><p>所以 do 函数的使用者是感受不到 i 的存在的，do 的调用方可以认为 do 是无状态（stateless）的，<font color="#cc0000">无状态意味着静止，静止的事物都是安全的</font>，飞驰而过的火车和静止的石块，当然是后者感觉更安全。</p><p>我们编写代码的时候会经常谈论状态，函数的状态、类的状态、App 的状态，归根结底，我们所讨论的是：<font color="#cc0000">在某个空间范畴内会发生变化的变量</font>。</p><p>函数式编程当中的函数 f(x) 强调无状态，其实是强调<font color="#cc0000">将状态锁定在函数的内部</font>。一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，前面说过变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量。下面两个函数，一个入参是传值，一个入参是传变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)do:(int)value  // 传值</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)do:(NSMutableArray *)arr  // 传变量</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个没状态，对调用方来说是安全的，对整个app来说也是安全的，既避免了依赖外部的状态，也不会修改外部的状态，即：不会产生 side effect，没有副作用。</p><p>第二个 do 函数，不但是传入了变量，还是可以变化的变量，是真正意义上的外部状态。很有可能在你遍历这个 arr 的时候，外部某个同时执行的线程正在尝试改变这个 arr 里的元素。</p><p>所以让我来总结函数式编程当中的函数，可以一句话归结为：<font color="#cc0000">隔绝一切外部状态，传入值，输出值</font>。</p><p>再看看函数式编程当中的纯函数（Pure Function）的定义:</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a>, a <a href="https://en.wikipedia.org/wiki/Function_(computer_science" target="_blank" rel="noopener">function</a>) may be considered a pure function if both of the following statements about the function hold:</p><ol><li><p>The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or bet`ween different executions of the program, nor can it depend on any external input from <a href="https://en.wikipedia.org/wiki/Input/output" target="_blank" rel="noopener">I/O</a> devices (usually—see below).</p></li><li><p>Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below).</p></li></ol></blockquote><p>纯函数即为函数式编程所强调的函数，上述两点可翻译为：</p><p>①、不依赖外部状态<br>②、不改变外部状态</p><p>所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解：<font color="#cc0000">时间和空间</font>。</p><h4 id="2-2-时间"><a href="#2-2-时间" class="headerlink" title="2.2 时间"></a>2.2 时间</h4><p>变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。</p><p>时间的武器是赋值，赋予变量新的值，在不可预知的未来埋下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setUserName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">//before assignment</span><br><span class="line">_userName = name;</span><br><span class="line">//after assignment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了赋值操作，时间就找到了空隙，可以对代码的执行产生影响。或许是现在，或许是明天，或许是在  appDidFinishLaunch，或许是在 didReceiveMemoryWarning。</p><p><font color="#cc0000">变量会随着时间变化</font>。有状态的函数也会随着时间的流动产生不同的输出，Pure Function 却是对时间免疫的，纯函数没有状态，无论怎样去执行一个纯函数，它所输出的结果永远不会变。</p><h4 id="2-3-空间"><a href="#2-3-空间" class="headerlink" title="2.3 空间"></a>2.3 空间</h4><p>如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。(线程安全问题)</p><p>Pure Function 同样是对空间免疫的。</p><p>多线程的 bug 调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。</p><h4 id="2-4-离不开的状态"><a href="#2-4-离不开的状态" class="headerlink" title="2.4 离不开的状态"></a>2.4 离不开的状态</h4><p>函数式编程通过 Pure Function，使得我们的代码经得起时间和空间的考验。</p><p>我们可以把一个 App 的代码按照函数式编程的方式，拆分成一个个合格的 pure function，再通过某种方式串联起来，要方便的串联函数，需要能像使用变量一样方便的使用函数。</p><p>一个 Pure Function 可以是 stateless 的，但 App 可以变成 stateless 吗？显然不能。</p><p>离开了变量和状态，我们很难完整的描述业务。用户购物车里的商品总是会发生变化，今天或明天，我们总是需要在一个地方接收这种变化，保存这种变化，继而反应这种变化。所以，大多数时候，我们离不开状态，但我们能做的是，<font color="#cc0000">将一定会变化的状态，锁定在尽可能小的时间和空间跨度之内</font>，通过改变代码的组织方式或架构，将必须改变的难以管教的状态，囚禁在特定的模块代码之中，让不可控变得尽量可控。</p><p>其实，即使不严格遵从函数式编程，我们同样可以写出带有 Functional Programming 精髓的代码，一切的一切，都是对于状态（state）的理解。</p><p>NSMutableArray 的 copy 也是颇具函数式编程精髓的。</p><h4 id="2-5-一等公民"><a href="#2-5-一等公民" class="headerlink" title="2.5 一等公民"></a>2.5 一等公民</h4><p>当我们把函数改造成 pure function 之后，会产生一些奇妙的化学连锁反应，这些反应甚至会改变我们的编程习惯。</p><p>一旦我们有了绝对安全的纯函数，我们当然希望能尽最大可能的去发挥它的价值，增加它出现和被使用的场景。为了加大纯函数的使用率，我们需要在语言层面做一些改造或者增强，以提高纯函数传递性。怎么增强呢？答案是将函数变为一等公民。</p><p>何谓公民？有身份证才叫公民，有身份证还能自由迁徙的就叫一等公民。</p><p>当我们的变量可以指向函数时，这个变量就有了函数的身份。当我们把这个变量当做函数的参数传入，或者函数的返回值传出的时候，这个变量就有了自由迁徙的能力。</p><p>一个函数 A，可以接收另一个函数 B 作为参数，然后再返回第三个函数 C 作为返回值。类似下面的一段swift代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">(funcB: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; input <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> funcB(input)</span><br><span class="line">&#125; <span class="comment">//funcC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 funcA 的定义里，funcB 是作为参数传入，funcC（匿名的）是作为返回值返回。funcB 和 funcC 在这个语境里就称之为 first class function。而 funcA 作为 funcB 和 funcC 的管理者，有个更高端的称谓：high order function。</p><p>有了 first class function 和 high order function，我们还会收获另一个成果：语言的表达力更灵活，更简洁，更强大了。举个例子，我们写一段代码来实现一个功能：参加 party 前选一件衣服。用传统的方式来写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseColor</span><span class="params">(gender: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dressup</span><span class="params">(dressColor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//imperative</span></span><br><span class="line"><span class="keyword">let</span> dressColor = chooseColor(gender: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> dress = dressup(dressColor: dressColor)</span><br><span class="line">user.dress = dress</span><br></pre></td></tr></table></figure><p>先定义函数，再分三步依次调用 chooseColor, dressup，然后赋值。</p><p>如果用 first class function 和 high order function 的方式来写就是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoParty</span><span class="params">(dressup: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>, chooseColor: @escaping (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; gender <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> dressColor = chooseColor(gender)</span><br><span class="line"><span class="keyword">return</span> dressup(dressColor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declarative</span></span><br><span class="line"><span class="keyword">let</span> prepare = gotoParty(dressup: &#123; color <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, chooseColor: &#123; gender <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">user.dress = prepare(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>gotoParty 函数糅合了 dressup 和 chooseColor，gotoParty 成了一个 high order function，当我们读 gotoParty 的代码的时候，这单一一个函数就将我们的目的和结果都表明了。</p><p>这就是 high order function 的神奇之处，原先啰啰嗦嗦的几句话变成一句话就说清楚了，它更接近我们自然语言的表达方式，比如 gotoParty 可以这样阅读：我要挑选一件颜色适合的衣服去参加 party，这样的代码是不是语意更简洁更美呢？</p><p>注意，<font color="#cc0000">functional programming 并不会减少我们的代码量，它改变的只是我们书写代码的方式</font>。</p><p>这种更为强大的表达力我们也有个行话来称呼它：declarative programming。而我们传统的代码表达方式（OOP当中所使用的方式）则叫做：imperative programming。</p><p>imperative programming 更强调实现的步骤，而 declarative programming 则重在表达我们想要的结果。这句话理解起来可能有些抽象，实在理解不了也没啥关系，只要记住declarative programming 能更简洁精炼的表达我们想要的结果即可。</p><p>以上都是我们将function变为一等公民所产生的结果，这一改变还有更多的妙用，比如lazy evaluation。</p><p>上述代码中的dressup和chooseColor虽然都是function，但是他们在传入gotoParty的时候并不会立马执行（evaluation），而是等gotoParty被执行的时候再一起执行。这也很大程度上增强了我们的表达能力，dressup和chooseColor都具备了lazy evaluation的属性，可以被拼装，被delay，最后在某一时刻才被执行。</p><p>所以，functional programming改变了我们使用函数的方式，之前使用 OOP，我们对于怎么处理变量（定义变量，修改值，传递值，等）轻车熟路，到了函数式编程的世界，我们要学会如何同函数打交道了，要能像使用变量一样灵活自如的使用函数，这在刚开始的时候确实需要一段适应期。</p><h2 id="三、响应式编程"><a href="#三、响应式编程" class="headerlink" title="三、响应式编程"></a>三、响应式编程</h2><p>在网上流传一个非常经典的解释｀响应式编程的概念｀</p><blockquote><p>在程序开发中： a ＝ b ＋ c<br>赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化。<br>响应式编程的目标就是：如果 b 或者 c 的数值发生变化，a 的数值会同时发生变化。</p></blockquote><ol><li><p>什么是响应式编程？</p><p> 响应式编程是一种编程范例，它处理异步数据流和特定的变更传播，按照特定顺序对执行环境（上下文）进行修改。</p></li><li><p>使用响应式编程有哪些好处？</p><p> 提高系统性能：使用响应式编程能提高处理大量数据的反应速度。提升用户体验：使用响应式编程能提升系统的响应能力。简化修改和维护：代码更容易理解。</p></li><li><p>所有都应该是响应式的么？</p><p>响应式编程可以作为应用的一部分集成到应用中，没必要将已经证明有效的编程模式全部推倒。如果只是简单的网站，肯定没有必要应用响应式编程；如果需要引入推荐系统，引入响应式编程处理来大数据、高负载就是个好办法。</p></li><li><p>什么时候使用响应式编程？</p><p>响应式编程是高负载、多用户应用的优雅的解决方案，像社交应用、游戏、音视频应用；此外，应用有以下模块也适合应用：需要大量交互的服务端代码、代理服务器/负载均衡器、人工智能/机器学习、实时数据流处理。</p></li></ol><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p>suiling &amp; <a href="http://www.cocoachina.com/articles/18325" target="_blank" rel="noopener">简单点，理解iOS与函数式编程</a><br><a href="https://www.jianshu.com/u/456d7ff700c2" target="_blank" rel="noopener">阳仔dynamics</a> &amp; <a href="https://www.jianshu.com/p/ca10c143ff0d" target="_blank" rel="noopener">ReactiveCocoa学习笔记（三）：响应式和函数响应式编程</a><br><a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="noopener">Why Reactive(Cocoa)?</a><br><a href="https://www.jianshu.com/u/18eb197607ff" target="_blank" rel="noopener">吴启辉</a> &amp; <a href="https://www.jianshu.com/p/a3598fb73eda" target="_blank" rel="noopener">关于响应式编程的十个问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、链式编程&quot;&gt;&lt;a href=&quot;#一、链式编程&quot; class=&quot;headerlink&quot; title=&quot;一、链式编程&quot;&gt;&lt;/a&gt;一、链式编程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。&lt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>dyld</title>
    <link href="http://yoursite.com/2019/08/07/iOS/iOS%E5%8E%9F%E7%90%86/dyld/"/>
    <id>http://yoursite.com/2019/08/07/iOS/iOS原理/dyld/</id>
    <published>2019-08-07T08:13:26.814Z</published>
    <updated>2019-09-03T09:56:44.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。</p><blockquote><p>dyld 全称 the dynamic link editor，即动态链接器，其本质是 Mach-O 文件，是专门用来加载动态库的库。</p></blockquote><p>源码下载地址：<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/dyld/</a></p><p>dyld 会将 App 依赖的动态库和 App 文件加载到内存以后执行，动态库不是可执行文件，无法独自执行。当点击 App 的时候，系统在内核态完成一些必要配置，从 App 的 MachO 文件解析出 dyld 的地址，这里会记录在 MachO 的 LC_LOAD_DYLINKER 命令中，内容参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          cmd LC_LOAD_DYLINKER</span><br><span class="line">      cmdsize 28</span><br><span class="line">         name /usr/lib/dyld (offset 12)</span><br><span class="line">Load command 8</span><br><span class="line">     cmd LC_UUID</span><br><span class="line"> cmdsize 24</span><br><span class="line">    uuid DF0F9B2D-A4D7-37D0-BC6B-DB0297766CE8</span><br><span class="line">Load command 9</span><br><span class="line">      cmd LC_VERSION_MIN_IPHONEOS</span><br></pre></td></tr></table></figure><p>dyld 位于 <code>/usr/lib/dyld</code>，可以从越狱机或者 mac 电脑中找到。以 mac 为例，终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/lib</span><br><span class="line">$ file dyld</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/dyld_path.png" alt><br></center><p>dyld 是 <font color="#cc0000">Mach-O 类型的通用二进制文件</font>，支持 x86_64 和 i386 两种架构。iPhone 真机对应的 dyld 支持的为 arm 系列架构。</p><h2 id="二、otool"><a href="#二、otool" class="headerlink" title="二、otool"></a>二、otool</h2><blockquote><p>otool 是专门用来查看 Mach-O 类型文件的工具</p></blockquote><p>Mac OS X 下二进制可执行文件的动态链接库是 <code>dylib</code> 文件。</p><blockquote><p>dylib 也就是 bsd 风格的动态库。基本可以认为等价于 windows 的 dll 和 linux 的so。mac 基于 bsd，所以也使用的是 dylib。</p></blockquote><p>Linux 下用 ldd 查看，苹果系统用 otool。</p><h4 id="2-1-查看-otool-地址"><a href="#2-1-查看-otool-地址" class="headerlink" title="2.1 查看 otool 地址"></a>2.1 查看 otool 地址</h4><p>电脑已安装 Xcode。终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ otool</span><br><span class="line">Usage: /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&apos;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&apos;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&apos;s disassembler</span><br><span class="line">-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure><p>由上可知 otool 的地址：<font color="#cc0000"><code>/Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</code></font></p><p>进入地址发现 otool 文件是一个替身（软连接）。</p><p>查看 otool 指向的软连接地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/</span><br><span class="line">$</span><br><span class="line">$ ls -l</span><br><span class="line">total 223352</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     33920 10 20  2018 ar</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     28000 10 20  2018 as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     18176 10 20  2018 asa</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    212208 10 20  2018 bison</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    150048 10 20  2018 bitcode_strip</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 c++ -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23152 10 20  2018 c89</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23248 10 20  2018 c99</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 cc -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  78705232 10 20  2018 clang</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 clang++ -&gt; clang</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120064 10 20  2018 cmpdylib</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145872 10 20  2018 codesign_allocate</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        17 11 22  2018 codesign_allocate-p -&gt; codesign_allocate</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   4937600 10 20  2018 coremlcompiler</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3344  9 26  2018 cpp</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     27712 10 20  2018 ctags</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145824 10 20  2018 ctf_insert</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        13 11 22  2018 dsymutil -&gt; llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1006032 10 20  2018 dwarfdump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    219088 10 20  2018 dyldinfo</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex++</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         8 11 22  2018 gcov -&gt; llvm-cov</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 gm4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     90960 10 20  2018 gperf</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     65520 10 20  2018 indent</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    136784 10 20  2018 install_name_tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2480704 10 20  2018 ld</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       230  9 26  2018 lex</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    154592 10 20  2018 libtool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     66000 10 20  2018 lipo</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   3320816 10 20  2018 llvm-cov</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  29723968 10 20  2018 llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  10591472 10 20  2018 llvm-nm</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  11899296 10 20  2018 llvm-objdump</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     32672 10 20  2018 llvm-otool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1272096 10 20  2018 llvm-profdata</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2873440 10 20  2018 llvm-size</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3567  9 26  2018 lorder</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 m4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24800 10 20  2018 metal</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-ar</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-link</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-opt</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metallib</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      7604  9 26  2018 mig</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 nm -&gt; llvm-nm</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132896 10 20  2018 nm-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    162720 10 20  2018 nmedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        12 11 22  2018 objdump -&gt; llvm-objdump</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        10 11 22  2018 otool -&gt; llvm-otool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    648720 10 20  2018 otool-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132784 10 20  2018 pagestuff</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 ranlib -&gt; libtool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59344 10 20  2018 rebase</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    204960 10 20  2018 redo_prebinding</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     73664 10 20  2018 rpcgen</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     48864 10 20  2018 segedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         9 11 22  2018 size -&gt; llvm-size</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120080 10 20  2018 size-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120400 10 20  2018 strings</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    189568 10 20  2018 strip</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  87671328 10 20  2018 swift</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swift-autolink-extract -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031520 10 20  2018 swift-build</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    384480 10 20  2018 swift-build-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    461136 10 20  2018 swift-demangle</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031552 10 20  2018 swift-package</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031472 10 20  2018 swift-run</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     53024 10 20  2018 swift-stdlib-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031504 10 20  2018 swift-test</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swiftc -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  12042320 10 20  2018 tapi</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     32592 10 20  2018 unifdef</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      2946  9 26  2018 unifdefall</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59776 10 20  2018 unwinddump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       135  9 26  2018 yacc</span><br></pre></td></tr></table></figure><p>可以看到 otool 指向 <font color="#cc0000">llvm-otool</font>，而 llvm-otool 和 otool 在同一个目录中。</p><p>另外，还可以发现，这个文件夹下面还有很多有用的文件，如 <code>lipo</code>。</p><h4 id="2-2-otool-L"><a href="#2-2-otool-L" class="headerlink" title="2.2 otool -L"></a>2.2 otool -L</h4><blockquote><p>查看动态链接库</p></blockquote><p>终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-fpfdxjbemnwnqcfjimbqpbzpnpem/Build/Products/Debug-iphonesimulator/Demo.app/</span><br><span class="line">$</span><br><span class="line">$ otool -L Demo</span><br><span class="line">Demo:</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0)</span><br><span class="line">/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)</span><br></pre></td></tr></table></figure><p>查看动态库的依赖库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/lib/system/libdispatch.dylib</span><br><span class="line">/usr/lib/system/libdispatch.dylib:</span><br><span class="line">/usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 913.60.3)</span><br><span class="line">/usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 551.4.0)</span><br><span class="line">/usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 62.0.0)</span><br><span class="line">/usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 4570.71.8)</span><br><span class="line">/usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 161.50.1)</span><br><span class="line">/usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 301.50.1)</span><br><span class="line">/usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 140.50.6)</span><br><span class="line">/usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1244.50.9)</span><br><span class="line">/usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 67.0.0)</span><br><span class="line">/usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 35.3.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure><h4 id="2-3-otool-ov"><a href="#2-3-otool-ov" class="headerlink" title="2.3 otool -ov"></a>2.3 otool -ov</h4><blockquote><p>显示 Objective-C 类结构及其定义的方法。</p></blockquote><p>终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ otool -ov Demo</span><br><span class="line">Demo:</span><br><span class="line">Contents of (__DATA,__objc_classlist) section</span><br><span class="line">00000001000041f0 0x100005080 _OBJC_CLASS_$_HookTool</span><br><span class="line">           isa 0x1000050a8 _OBJC_METACLASS_$_HookTool</span><br><span class="line">    superclass 0x0 _OBJC_CLASS_$_NSObject</span><br><span class="line">         cache 0x0 __objc_empty_cache</span><br><span class="line">        vtable 0x0</span><br><span class="line">          data 0x100004328 (struct class_ro_t *)</span><br><span class="line">                    flags 0x80</span><br><span class="line">            instanceStart 8</span><br><span class="line">             instanceSize 8</span><br><span class="line">                 reserved 0x0</span><br><span class="line">               ivarLayout 0x0</span><br><span class="line">                     name 0x100003555 HookTool</span><br><span class="line">              baseMethods 0x1000042f0 (struct method_list_t *)</span><br><span class="line">   entsize 24</span><br><span class="line">     count 2</span><br><span class="line">      name 0x1000028b3 swizzle_decodeObjectForKey:</span><br><span class="line">     types 0x1000035c4 @24@0:8@16</span><br><span class="line">       imp 0x1000015f0 -[HookTool swizzle_decodeObjectForKey:]</span><br><span class="line">      name 0x100002914 swizzle_button_initWithCoder:</span><br><span class="line">     types 0x1000035c4 @24@0:8@16</span><br><span class="line">       imp 0x1000017c0 -[HookTool swizzle_button_initWithCoder:]</span><br><span class="line">            baseProtocols 0x0</span><br><span class="line">                    ivars 0x0</span><br><span class="line">           weakIvarLayout 0x0</span><br><span class="line">           baseProperties 0x0</span><br><span class="line">Meta Class</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-4-otool-tV-Mach-O"><a href="#2-4-otool-tV-Mach-O" class="headerlink" title="2.4 otool -tV [Mach-O]"></a>2.4 otool -tV [Mach-O]</h4><blockquote><p>查看 ARM 汇编码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ otool -tV Demo</span><br><span class="line">Demo:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">+[HookTool load]:</span><br><span class="line">0000000100001400pushq%rbp</span><br><span class="line">0000000100001401movq%rsp, %rbp</span><br><span class="line">0000000100001404subq$0x40, %rsp</span><br><span class="line">0000000100001408movl$0x2, %eax</span><br><span class="line">000000010000140dmovl%eax, %edx</span><br><span class="line">000000010000140fmovq%rdi, -0x8(%rbp)</span><br><span class="line">0000000100001413movq%rsi, -0x10(%rbp)</span><br><span class="line">0000000100001417movq0x3c1a(%rip), %rsi ## Objc class ref: _OBJC_CLASS_$_NSMutableArray</span><br><span class="line">000000010000141emovq0x3b33(%rip), %rdi ## Objc selector ref: arrayWithCapacity:</span><br><span class="line">0000000100001425movq%rdi, -0x20(%rbp)</span><br><span class="line">0000000100001429movq%rsi, %rdi</span><br><span class="line">000000010000142cmovq-0x20(%rbp), %rsi</span><br><span class="line">0000000100001430callq*0x2bf2(%rip) ## Objc message: +[NSMutableArray arrayWithCapacity:]</span><br><span class="line">0000000100001436movq%rax, %rdi</span><br><span class="line">0000000100001439callq0x10000265a ## symbol stub for: _objc_retainAutoreleasedReturnValue</span><br><span class="line">000000010000143emovq__imageViewImageArray(%rip), %rdx</span><br><span class="line">0000000100001445movq%rax, __imageViewImageArray(%rip)</span><br><span class="line">000000010000144cmovq%rdx, %rdi</span><br><span class="line">000000010000144fcallq*0x2bdb(%rip) ## literal pool symbol address: _objc_release</span><br><span class="line">0000000100001455leaq0x2cb4(%rip), %rax ## Objc cfstring ref: @&quot;emaNecruoseRIU&quot;</span><br><span class="line">000000010000145cmovq0x3bdd(%rip), %rdx ## Objc class ref: HookTool</span><br><span class="line">0000000100001463movq0x3af6(%rip), %rsi ## Objc selector ref: stringByReversed:</span><br><span class="line">000000010000146amovq%rdx, %rdi</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-5-otool-h-Mach-O"><a href="#2-5-otool-h-Mach-O" class="headerlink" title="2.5 otool -h [Mach-O]"></a>2.5 otool -h [Mach-O]</h4><blockquote><p>查看 Mach-O 头结构等</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ otool -h Demo</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> 0xfeedfacf 16777223          3  0x00           2    21       3272 0x00200085</span><br></pre></td></tr></table></figure><p>一个 Mach-O 的文件头结构为：</p><center><br><img src="http://dzliving.com/MachOHeader.png" alt><br></center><p>各字段的含义，可参看 <code>/usr/include/mach-o/loader.h</code>。</p><h4 id="2-6-otool-l-Mach-O-grep-crypt1"><a href="#2-6-otool-l-Mach-O-grep-crypt1" class="headerlink" title="2.6 otool -l [Mach-O] | grep crypt1"></a>2.6 otool -l [Mach-O] | grep crypt1</h4><blockquote><p>查看 ipa 包是否加壳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ otool -l Demo | grep crypt1</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>没有进行过加壳处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6651904</span><br><span class="line">  cryptid 0</span><br><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6553600</span><br><span class="line">  cryptid 0123456</span><br></pre></td></tr></table></figure><p>cryptid 代表是否加壳，1 - 加壳，0 - 已脱壳。</p><p>上面打印了两遍，其实代表着该可执行文件支持两种架构 armv7 和 arm64。</p><p>Mach-O 文件可以用 GUI 图形软件 <a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a> 更加直观的查看相关信息。</p><center><br><img src="http://dzliving.com/MachOView.png" alt><br></center><h2 id="三、dyld加载"><a href="#三、dyld加载" class="headerlink" title="三、dyld加载"></a>三、dyld加载</h2><blockquote><p>动态库链接、load 方法执行都是在 main 函数执行之前的。</p></blockquote><p>如图所示进行操作：</p><center><br><img src="http://dzliving.com/SymbolicBreakPoint.png" alt><br><img src="http://dzliving.com/NSObjectLoad.png" alt><br><img src="http://dzliving.com/ThreadStatck.png" alt><br></center><p>由上可知，load 的加载是从 <code>__dyld_start</code> 这个函数开始的。</p><h4 id="3-1-dyld-start"><a href="#3-1-dyld-start" class="headerlink" title="3.1 __dyld_start"></a>3.1 __dyld_start</h4><p>系统内核在加载动态库前，会加载 dyld，然后调用去执行 __dyld_start（汇编语言实现）。该函数会执行 dyldbootstrap::start()，后者会执行 _main()函数，dyld 的加载动态库的代码就是从_main()开始执行的。这里可以查看 dyldStartup.s的部分内容（以x86_x64架构做参考)，其中标出了 _dyld_start() 与 dyldbootstrap 的 start 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">.data</span><br><span class="line">.align <span class="number">3</span></span><br><span class="line">__dyld_start_static:</span><br><span class="line">.quad   __dyld_start</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">.text</span><br><span class="line">.align <span class="number">2</span>,<span class="number">0x90</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">popq%rdi# param1 = mh of app</span><br><span class="line">pushq$<span class="number">0</span># push a zero <span class="keyword">for</span> debugger end of frames marker</span><br><span class="line">movq%rsp,%rbp# pointer to base of kernel frame</span><br><span class="line">andq    $<span class="number">-16</span>,%rsp       # force SSE alignment</span><br><span class="line">subq$<span class="number">16</span>,%rsp# room <span class="keyword">for</span> local variables</span><br><span class="line"></span><br><span class="line"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">movl<span class="number">8</span>(%rbp),%esi# param2 = argc into %esi</span><br><span class="line">leaq<span class="number">16</span>(%rbp),%rdx# param3 = &amp;argv[<span class="number">0</span>] into %rdx</span><br><span class="line">movq__dyld_start_static(%rip), %r8</span><br><span class="line">leaq__dyld_start(%rip), %rcx</span><br><span class="line">subq %r8, %rcx# param4 = slide into %rcx</span><br><span class="line">leaq___dso_handle(%rip),%r8 # param5 = dyldsMachHeader</span><br><span class="line">leaq<span class="number">-8</span>(%rbp),%r9</span><br><span class="line">call__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">movq<span class="number">-8</span>(%rbp),%rdi</span><br><span class="line">cmpq$<span class="number">0</span>,%rdi</span><br><span class="line">jneLnew</span><br><span class="line"></span><br><span class="line">    # clean up <span class="built_in">stack</span> <span class="keyword">and</span> jump to <span class="string">"start"</span> in main executable</span><br><span class="line">movq%rbp,%rsp# restore the unaligned <span class="built_in">stack</span> pointer</span><br><span class="line">addq$<span class="number">8</span>,%rsp # remove the mh argument, <span class="keyword">and</span> debugger end frame marker</span><br><span class="line">movq$<span class="number">0</span>,%rbp# restore ebp back to zero</span><br><span class="line">jmp*%rax# jump to the entry point</span><br><span class="line"></span><br><span class="line"># LC_MAIN <span class="keyword">case</span>, <span class="built_in">set</span> up <span class="built_in">stack</span> <span class="keyword">for</span> call to main()</span><br></pre></td></tr></table></figure><h4 id="3-2-dyldInitialization-cpp"><a href="#3-2-dyldInitialization-cpp" class="headerlink" title="3.2 dyldInitialization.cpp"></a>3.2 dyldInitialization.cpp</h4><p>__dyld_start 内部调用 dyldbootstrap::start，位于 dyldInitialization.cpp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line"><span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line"><span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    <span class="comment">// ①、获取 dyld 对应的 slide</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">    shouldRebase = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        <span class="comment">// ②、通过 slide 对 dyld 进行 rebase</span></span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">    <span class="comment">// ③、mach 初始化</span></span><br><span class="line">mach_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="comment">// ④、栈溢出保护</span></span><br><span class="line"><span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">++apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up random value for stack canary</span></span><br><span class="line">__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line"><span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">    <span class="comment">// ⑤、获取应用的 slide（appsSlide）</span></span><br><span class="line"><span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⑥、调用 dyld 的 main 函数</span></span><br><span class="line"><span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-slide、rebase"><a href="#3-3-slide、rebase" class="headerlink" title="3.3 slide、rebase"></a>3.3 slide、rebase</h4><p>由于 apple 采用了 <a href="https://baike.baidu.com/item/aslr/5779647?fr=aladdin" target="_blank" rel="noopener">ASLR（Address space layout randomization）</a>技术，所以 Mach-O 每次加载到内存中的<font color="#cc0000">首地址是变化的</font>，此时想找到代码在内存中对应的地址需要重定位 rebase。rebase 要用到 slide 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  The kernel may have slid a Position Independent Executable</span><br><span class="line">//</span><br><span class="line">static uintptr_t slideOfMainExecutable(const struct macho_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Mach-O 文件中 load commands 数量</span><br><span class="line">const uint32_t cmd_count = mh-&gt;ncmds;</span><br><span class="line">    </span><br><span class="line">    // 偏移地址到 load commands 的首地址</span><br><span class="line">const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header));</span><br><span class="line">const struct load_command* cmd = cmds;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        // 选中 cmd = LC_SEGMENT_COMMAND</span><br><span class="line">if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</span><br><span class="line">            // 实际对应 LC_SEGMENT_COMMAND(_TEXT)</span><br><span class="line">if ( (segCmd-&gt;fileoff == 0) &amp;&amp; (segCmd-&gt;filesize != 0)) &#123;</span><br><span class="line">                </span><br><span class="line">                // Mach-O 文件首地址 - LC_SEGMENT_COMMAND(_TEXT).vmaddr</span><br><span class="line">return (uintptr_t)mh - segCmd-&gt;vmaddr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        // 偏移 command 指针</span><br><span class="line">cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/MachOTEXT.png" alt><br></center><p>应用本身的 Mach-O 及 dyld 采用的是 <code>slideOfMainExecutable</code> 的方式获取 slide。从上代码得知：side = Mach-O header 首地址 - Load Commands 中 __TEXT 段的 VM Address 的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_slide(<span class="keyword">const</span> mach_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_slide(%p)\n"</span>, mh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Mach-O 文件加载对象</span></span><br><span class="line">    <span class="keyword">const</span> MachOLoaded* mf = (MachOLoaded*)mh;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 mach 文件头没有 magic 值</span></span><br><span class="line">    <span class="keyword">if</span> ( !mf-&gt;hasMachOMagic() )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 MachOLoaded::getSlide() 方法</span></span><br><span class="line">    <span class="keyword">return</span> mf-&gt;getSlide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> imageIndex)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_vmaddr_slide(%d)\n"</span>, imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到 Mach-O 文件</span></span><br><span class="line">    <span class="keyword">const</span> mach_header* mh = gAllImages.imageLoadAddressByIndex(imageIndex);</span><br><span class="line">    <span class="keyword">if</span> ( mh != <span class="literal">nullptr</span> )</span><br><span class="line">        <span class="comment">// 调用上面的方法</span></span><br><span class="line">        <span class="keyword">return</span> dyld3::_dyld_get_image_slide(mh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> MachOLoaded::getSlide() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 诊断对象。</span></span><br><span class="line">    Diagnostics diag;</span><br><span class="line">    __block <span class="keyword">intptr_t</span> slide = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环 load command</span></span><br><span class="line">    forEachLoadCommand(diag, ^(<span class="keyword">const</span> load_command* cmd, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 64 位</span></span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_64 ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command_64* seg = (segment_command_64*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT_64(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT_64(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 32 位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command* seg = (segment_command*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    diag.assertNoError();   <span class="comment">// any malformations in the file should have been caught by earlier validate() call</span></span><br><span class="line">    <span class="keyword">return</span> slide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态库加载采用的是 <code>\_dyld\_get\_image\_vmaddr\_slide</code> 的方式获取 slide。</p><p>简单验证一下，以应用 Mach-O 为例：</p><ol><li><p>Load Commands __TEXT 段 VM Address 值。</p><p> <center><br> <img src="http://dzliving.com/MachOVMAddress.png" alt><br> </center></p><p> VM Address 的地址为 4294967296（10进制）。</p></li><li><p>在 Demo 项目中 ViewController.m <code>viewDidLoad</code> 方法设置断点，触发后，在 lldb 执行 <code>image list</code></p> <center><br> <img src="http://dzliving.com/ImageList.png" alt><br> </center><p> 应用 Mach-O 的地址为 0x00000001004f8000（16进制）。</p></li><li><p>计算 viewDidLoad 在应用 Mach-O 文件中的地址，<code>symbol address = stack address - slide</code>。</p> <center><br> <img src="http://dzliving.com/LLVMAddress.png" alt><br> </center><p> ①、用 Mach-O 的 VM Address 减去对应虚拟地址，得到的 5210112（10进制）为 slide 值；<br> ②、获取 viewDidLoad 函数在当前<font color="#cc0000">内存</font>中的地址；<br> ③、用 viewDidLoad 内存地址减去 slide 得到它在 Mach-O 中对应的虚拟地址；<br> ④、将 10 进制转化为 16 进制。</p><p> 计算得到地址：0x00000001000022c0</p></li><li><p>在 Mach-O 文件中查看。</p> <center><br> <img src="http://dzliving.com/ViewDidLoadAddress.png" alt><br> </center><p> 可以看到，通过计算得出的值 0x100001750 与 Mach-O 中看到的值一致。</p></li></ol><p>当然，也可以通过命令行直接获取 slide 的值。</p><h4 id="3-4-dyld-main"><a href="#3-4-dyld-main" class="headerlink" title="3.4 dyld::_main"></a>3.4 dyld::_main</h4><p>对 ASLR 有了基本认知后，接着看看位于 <code>dyld.cpp</code> 中的 _main 干了什么。</p><h5 id="3-4-1-设置运行环境"><a href="#3-4-1-设置运行环境" class="headerlink" title="3.4.1 设置运行环境"></a>3.4.1 设置运行环境</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (<span class="keyword">uint64_t</span>)mainExecutableMH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">"executable_cdhash"</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序 hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace dyld's load</span></span><br><span class="line"><span class="comment">// 告知 kernel，dyld 已加载</span></span><br><span class="line">notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">"dyld_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace the main executable's load</span></span><br><span class="line"><span class="comment">// 告知 kernel，主程序 Mach-O 已加载</span></span><br><span class="line">notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, <span class="string">"executable_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 赋值参数。</span></span><br><span class="line"><span class="comment">// mach_header 类型结构体，表示当前 App 的 Mach-O头部信息。有了头部信息，加载器就可以从头开始，遍历整个 Mach-O 文件的信息。</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// long 类型数据，表示 ASLR 位移长度</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// if this is host dyld, check to see if iOS simulator is being run</span></span><br><span class="line"><span class="comment">// 获取 dyld 路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rootPath = _simple_getenv(envp, <span class="string">"DYLD_ROOT_PATH"</span>);</span><br><span class="line"><span class="keyword">if</span> ( (rootPath != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line"><span class="comment">// look to see if simulator has its own dyld</span></span><br><span class="line"><span class="keyword">char</span> simDyldPath[PATH_MAX]; </span><br><span class="line">strlcpy(simDyldPath, rootPath, PATH_MAX);</span><br><span class="line">strlcat(simDyldPath, <span class="string">"/usr/lib/dyld_sim"</span>, PATH_MAX);</span><br><span class="line"><span class="comment">// 打开 dyld_sim 路径</span></span><br><span class="line"><span class="keyword">int</span> fd = my_open(simDyldPath, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">if</span> ( fd != <span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="comment">// 如果是模拟器，并且正确加载`dyld_sim`，则直接返回主程序地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result);</span><br><span class="line"><span class="keyword">if</span> ( errMessage != <span class="literal">NULL</span> )</span><br><span class="line">halt(errMessage);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">CRSetCrashLogMessage(<span class="string">"dyld: launch started"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个全局链接上下文，包括一些回调函数、参数与标志设置信息，其中的 context 结构体实例、回调函数都是 dyld 自己的实现</span></span><br><span class="line">setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用 Mach-O 文件的绝对路径</span></span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">'/'</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( getcwd(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">"/"</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 设置进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式。根据当前进程是否受限，再次配置链接上下文以及其他环境参数</span></span><br><span class="line">configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次检测/设置上下文环境</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">    <span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123;</span><br><span class="line">pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line"><span class="comment">// set again because envp and apple may have changed or moved</span></span><br><span class="line">setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">checkEnvironmentVariables(envp);</span><br><span class="line">defaultUninitializedFallbackPaths(envp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="keyword">if</span> (  ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac)</span><br><span class="line">  &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) &#123;</span><br><span class="line">gLinkContext.rootPaths = parseColonList(<span class="string">"/System/iOSSupport"</span>, <span class="literal">NULL</span>);</span><br><span class="line">gLinkContext.marzipan = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths )</span><br><span class="line">sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths;</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths )</span><br><span class="line">sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS，则打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">printOptions(argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV，则打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">printEnvironmentVariables(envp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取主程序架构信息</span></span><br><span class="line">getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从源码可以看到，在模拟器运行程序时，通过 <code>dyld_sim</code> 来进行后续加载工作的，与正常真机加载流程略有不同。</p><p>模拟器：</p><center><br><img src="http://dzliving.com/DyldMainSim.png" alt><br></center><p>真机：</p><center><br><img src="http://dzliving.com/DyldMainPhone.png" alt><br></center><p>具体实现在 <code>useSimulatorDyld</code> 这个函数中，本文不做进一步解析。</p><p>这里还有一个知识点，环境变量 <font color="#cc0000"><code>DYLD_PRINT_OPTS</code></font> 与 <font color="#cc0000"><code>DYLD_PRINT_ENV</code></font>。在 processDyldEnvironmentVariable 方法中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_IMAGE_SUFFIX"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">gLinkContext.imageSuffix = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_INSERT_LIBRARIES"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">sEnv.DYLD_INSERT_LIBRARIES = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 secheme 添加这两个环境变量，对应的字段会被设置为 true，并不需要设置 value。</p><center><br><img src="http://dzliving.com/DyldPrintSetting.png" alt><br><img src="http://dzliving.com/DyldPrintLog.png" alt><br></center><p>但是并非每个环境变量都不需要配置 value，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processDyldEnvironmentVariable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">const</span> <span class="keyword">char</span>* mainExecutableDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FRAMEWORK_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_FRAMEWORK_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_LIBRARY_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_LIBRARY_PATH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="3-4-2-加载共享缓存"><a href="#3-4-2-加载共享缓存" class="headerlink" title="3.4.2 加载共享缓存"></a>3.4.2 加载共享缓存</h5><p>dyld3 与 dyld 不同点在 _main 方法中可以看出。在 dyld 的 _main 方法中，完成第一步以后会初始化主 App，然后加载共享缓存。到了 dyld3，调整了顺序：加载缓存的步骤可以划分为 mapSharedCache 和 checkVersionedPaths，先执行 mapSharedCache，然后加载主 App，最后checkVersionedPaths。（苹果在 2017 年发布的 dyld3，<a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">视频链接</a>）</p><p>对于共享缓存的理解：dyld 加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被 dyld 映射到内存中，之后，当任何 Mach-O 映像加载时，dyld 首先会检查该 Mach-O 映像及所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// load shared cache</span></span><br><span class="line"><span class="comment">// 检查共享缓存是否可用</span></span><br><span class="line">checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed</span></span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line"><span class="comment">// &lt;/HACK&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 非 Dont Use</span></span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line"><span class="comment">// 映射共享缓存到共享区</span></span><br><span class="line">mapSharedCache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存是否兼容（DyldSharedCache * loadAddress 为空 || 版本相同 -》YES）</span></span><br><span class="line"><span class="keyword">bool</span> cacheCompatible = (sSharedCacheLoadInfo.loadAddress == <span class="literal">nullptr</span>) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置了 DYLD_USE_CLOSURES || 在白名单</span></span><br><span class="line"><span class="keyword">if</span> ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line"><span class="comment">// 不使用closure，因为共享缓存格式版本与 dyld 不匹配</span></span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: not using closure because shared cache format version does not match dyld's\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could not use closure info, launch old way</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// install gdb notifier</span></span><br><span class="line">stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);</span><br><span class="line">stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);</span><br><span class="line"><span class="comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span></span><br><span class="line">sImageRoots.reserve(<span class="number">16</span>);</span><br><span class="line">sAddImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sRemoveImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sAddLoadImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sImageFilesNeedingTermination.reserve(<span class="number">16</span>);</span><br><span class="line">sImageFilesNeedingDOFUnregistration.reserve(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WAIT_FOR_SYSTEM_ORDER_HANDSHAKE</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process</span></span><br><span class="line">WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="comment">// 添加 dyld 的 UUID 到共享缓存 UUID 列表中</span></span><br><span class="line">addDyldImageToUUIDList();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检测共享缓存是否可用；</li><li>如果可用，映射共享缓存到共享区；</li><li>添加 dyld 的 UUID 到缓存列表。</li></ul><p>其中，检测共享缓存是否可用的函数 <font color="#cc0000"><code>checkSharedRegionDisable</code></font> 中有两句注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSharedRegionDisable</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// if main executable has segments that overlap the shared region, then disable using the shared region</span></span><br><span class="line"><span class="comment">// 如果主程序 Mach-O 有 segments 与共享区重叠，那么共享区不可用。并且，iOS 不开启共享区无法运行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测两者是否重叠</span></span><br><span class="line"><span class="keyword">if</span> ( mainExecutableMH-&gt;intersectsRange(SHARED_REGION_BASE, SHARED_REGION_SIZE) ) &#123;</span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.verboseMapping )</span><br><span class="line">dyld::warn(<span class="string">"disabling shared region because main executable overlaps\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line"><span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPath ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/15280847&gt; use private or no shared region for suid processes</span></span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// iOS cannot run without shared region</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体检测代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MachOLoaded::intersectsRange(<span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> length) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> slide = getSlide();</span><br><span class="line">    forEachSegment(^(<span class="keyword">const</span> SegmentInfo&amp; info, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ①、主程序 segment 中的虚拟地址 + 虚拟地址大小 + 偏移量 &gt;= 共享区起始地址</span></span><br><span class="line"><span class="comment">            ②、主程序 segment 中的虚拟地址 + 偏移量 &lt; 共享区终止地址</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            ① 和 ② 同时 YES，那么认为主程序 Mach-O 有 segments 与共享区重叠，此时共享区不可用，从而动态库缓存不可用</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">            疑问：地址是从高到低分配？</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ( (info.vmAddr+info.vmSize+slide &gt;= start) &amp;&amp; (info.vmAddr+slide &lt; start+length) )</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段检测代码在满足重叠条件后，并没有设置 stop = true 停止 <font color="#cc0000"><code>forEachLoadCommand</code></font> 中的循环，这里值得深究和讨论。</p><p>加载共享缓存最核心的步骤在 <font color="#cc0000"><code>mapSharedCache</code></font> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dyld3::SharedCacheOptions opts;</span><br><span class="line">opts.cacheDirOverride= sSharedCacheOverrideDir;</span><br><span class="line">opts.forcePrivate= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__ &amp;&amp; !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">opts.useHaswell= sHaswell;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">opts.useHaswell= <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">opts.verbose= gLinkContext.verboseMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 dyld 缓存</span></span><br><span class="line">loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update global state</span></span><br><span class="line"><span class="comment">// 更新进程的全局状态信息</span></span><br><span class="line"><span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">gLinkContext.dyldCache = sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SharedCacheRuntime.cpp 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="comment">// 模拟器只支持 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">    <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="comment">// 只加载 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="keyword">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 已加载过的</span></span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未加载过的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载缓存分三种情况：</p><p>①、仅加载到当前进程。通过 <code>mapCachePrivate()</code> 加载并返回错误信息；<br>②、已经加载过的。通过 <code>reuseExistingCache()</code> 加载并返回错误信息，同时返回是否加载过 BOOL 值；<br>③、未加载过的。通过 <code>mapCacheSystemWide()</code> 加载缓存并映射，返回错误信息。</p><p>options.forcePrivate 的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld.cpp</span></span><br><span class="line">opts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion)</span><br><span class="line"></span><br><span class="line">gLinkContext.sharedRegionMode= ImageLoader::kUseSharedRegion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageLoader.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">enum</span> SharedRegionMode &#123; kUseSharedRegion, kUsePrivateSharedRegion, kDontUseSharedRegion, kSharedRegionIsSharedCache &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gLinkContext.sharedRegionMode 在 setContext() 方法中设置默认值，默认值为 kUseSharedRegion，也就是之前检测共享区是否可用的标识值。</p><h5 id="3-4-3-实例化主程序"><a href="#3-4-3-实例化主程序" class="headerlink" title="3.4.3 实例化主程序"></a>3.4.3 实例化主程序</h5><p>系统会对已经映射到进程空间的主程序（在 XNU 解析 MachO 阶段就完成了映射操作）创建一个ImageLoaderMachO，再将其加入到 master list 中（sAllImages）。如果加载的 MachO 的硬件架构与本设备相符，就执行 imageLoader 的创建和添加操作。其中主要实现是ImageLoaderMachO::instantiateMainExecutable方法，该方法将主 App 的 MachHeader、ASLR，文件路径和前面提到的链接上下文作为参数，做 imageLoader 的实例化操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">// 实例化主程序</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line"><span class="comment">// 代码签名</span></span><br><span class="line">gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// check main executable is not too new for this OS</span></span><br><span class="line"><span class="comment">// 检测主程序是否支持当前设备版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查是否是模拟器二进制文件</span></span><br><span class="line"><span class="keyword">if</span> ( ! isSimulatorBinary((<span class="keyword">uint8_t</span>*)mainExecutableMH, sExecPath) ) &#123;</span><br><span class="line">throwf(<span class="string">"program was built for a platform that is not supported by this runtime"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint32_t</span> mainMinOS = sMainExecutable-&gt;minOSVersion();</span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld is always built for the current OS, so we can get the current OS version</span></span><br><span class="line"><span class="comment">// from the load command in dyld itself.</span></span><br><span class="line"><span class="comment">// 获取 dyld 中存储的当前 OS 版本</span></span><br><span class="line"><span class="keyword">uint32_t</span> dyldMinOS = ImageLoaderMachO::minOSVersion((<span class="keyword">const</span> mach_header*)&amp;__dso_handle);</span><br><span class="line"><span class="comment">// 应用 mach-O 文件的版本超过了当前模拟器设备的版本，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> ( mainMinOS &gt; dyldMinOS ) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WATCH</span></span><br><span class="line">throwf(<span class="string">"app was built for watchOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> TARGET_OS_TV</span></span><br><span class="line">throwf(<span class="string">"app was built for tvOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">throwf(<span class="string">"app was built for iOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries</span></span><br><span class="line"><span class="keyword">uint32_t</span> mainSDK = sMainExecutable-&gt;sdkVersion();</span><br><span class="line">gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// simulators, iOS, tvOS, and watchOS are always strict</span></span><br><span class="line">gLinkContext.strictMachORequired = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">sAllImages.reserve((sAllCacheImagesProxy != <span class="literal">NULL</span>) ? <span class="number">16</span> : INITIAL_IMAGE_COUNT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">sAllImages.reserve(INITIAL_IMAGE_COUNT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line">checkVersionedPaths(); <span class="comment">// 设置加载的动态库版本。这里的动态库还没有包括经 DYLD_INSERT_LIBRARIES 插入的库。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="comment">// dyld 加载的 image_infos 并不包含 dyld 本身，它被放到 dyld_all_image_infos 的 dyldPath 字段中去了。而对于模拟器，dyld 加载的 image_infos 是包含 dyld_sim 的。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 dyld 路径并与 gProcessInfo-&gt;dyldPath 对比</span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = proc_regionfilename(getpid(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">'\0'</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="comment">// 如果不同将获取到的路径复制给 gProcessInfo-&gt;dyldPath</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#cc0000"><code>dyld_all_image_infos</code></font> 是个结构体，同样分为 32 位和 64 位两个版本，分别对应 dyld_all_image_infos_32 与 dyld_all_image_infos_64，由于获取 dyld_all_image_infos 需要用到一些未开源信息，这里为了方便，从侧面验证一下这条注释信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); ++i) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%s"</span>, _dyld_get_image_name(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟器：</p><center><br><img src="http://dzliving.com/DyldSimAllImageInfo.png" alt><br></center><p>真机：</p><center><br><img src="http://dzliving.com/DyldPhoneAllImageInfo.png" alt><br></center><p>可以看到：模拟器打印的 image 没有 dyld，第 0 个 image 是 dyld_sim，第一个 image 才是主程序；真机打印出的加载 image 中也没有 dyld，第 0 个 image 是主程序。</p><p>回到最核心的 <font color="#cc0000"><code>instantiateFromLoadedImage</code></font> 实例化主程序函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="comment">// kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化成 ImageLoader 加载到内存中交给 dyld 管理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">// CPU 架构是否匹配</span></span><br><span class="line"><span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line"><span class="comment">// 实例化 ImageLoader 对象。参数：macho header、ASLR、执行路径、链接上下文</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="comment">// 分配主程序image的内存，更新。</span></span><br><span class="line">addImage(image);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化ImageLoader 对象，加载到内存，返回交给 dyld 管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line"><span class="comment">//sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line"><span class="keyword">bool</span> compressed;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line"><span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line"><span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sniffLoadCommands 函数会对主程序 Mach-O进 行一系列的校验：对代码签名，MachO加密，动态库数量，段的数量相关信息的 loadCommand 做解析，提取出 command 数据。</span></span><br><span class="line"><span class="comment">/*      case LC_DYLD_INFO:</span></span><br><span class="line"><span class="comment"> case LC_DYLD_INFO_ONLY:</span></span><br><span class="line"><span class="comment"> *compressed = true;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line"><span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line"><span class="comment">// 已解密</span></span><br><span class="line"><span class="keyword">if</span> ( compressed ) </span><br><span class="line"><span class="comment">// Compressed</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line"><span class="comment">// Classic</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sniffLoadCommands 的校验并不包括对主程序 Mach-O 的解密操作，解密操作是由 xnu 完成的。</p><p>ImageLoaderMachOCompressed::instantiateMainExecutable、ImageLoaderMachOClassic::instantiateMainExecutable 两者内部的逻辑相同，只是返回类型一个是 ImageLoaderMachOCompressed 一个是 ImageLoaderMachOClassic。</p><p>以 ImageLoaderMachOCompressed 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 image</span></span><br><span class="line">ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set slide for PIE programs</span></span><br><span class="line"><span class="comment">// 设置 image 偏移量</span></span><br><span class="line">image-&gt;setSlide(slide);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for PIE record end of program, to know where to start loading dylibs</span></span><br><span class="line"><span class="keyword">if</span> ( slide != <span class="number">0</span> )</span><br><span class="line"><span class="comment">// 设置动态库起始地址</span></span><br><span class="line">fgNextPIEDylibAddress = (<span class="keyword">uintptr_t</span>)image-&gt;getEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用段覆盖检测</span></span><br><span class="line">image-&gt;disableCoverageCheck();</span><br><span class="line"><span class="comment">// 结束 image 上下文</span></span><br><span class="line">image-&gt;instantiateFinish(context);</span><br><span class="line"><span class="comment">// 设置 image 加载状态为 dyld_image_state_mapped</span></span><br><span class="line">image-&gt;setMapped(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.verboseMapping ) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: Main executable mapped %s\n"</span>, path);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = image-&gt;segName(i);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(name, <span class="string">"__PAGEZERO"</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(name, <span class="string">"__UNIXSTACK"</span>) == <span class="number">0</span>)  )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::setMapped(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">fState = dyld_image_state_mapped;</span><br><span class="line">context.notifySingle(dyld_image_state_mapped, <span class="keyword">this</span>, <span class="literal">NULL</span>);  <span class="comment">// note: can throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instantiateFinish() 在内部解析 loadCmds、设置动态库连接信息、设置符号表相关信息等。setMapped() 内部调用 notifySingle 进行处理。</p><h5 id="3-4-4-加载插入的动态库"><a href="#3-4-4-加载插入的动态库" class="headerlink" title="3.4.4 加载插入的动态库"></a>3.4.4 加载插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 插入动态库</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库个数</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置了 <font color="#cc0000"><code>DYLD_INSERT_LIBRARIES</code></font> 环境变量，通过loadInsertedDylib() 方法插入配置的动态库。对于越狱插件而言，其实就是通过添加 DYLD_INSERT_LIBRARIES 这个环境变量达到加载插件的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInsertedDylib</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> cacheIndex;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LoadContext context;</span><br><span class="line">context.useSearchPaths= <span class="literal">false</span>;</span><br><span class="line">context.useFallbackPaths= <span class="literal">false</span>;</span><br><span class="line">context.useLdLibraryPath= <span class="literal">false</span>;</span><br><span class="line">context.implicitRPath= <span class="literal">false</span>;</span><br><span class="line">context.matchByInstallName= <span class="literal">false</span>;</span><br><span class="line">context.dontLoad= <span class="literal">false</span>;</span><br><span class="line">context.mustBeBundle= <span class="literal">false</span>;</span><br><span class="line">context.mustBeDylib= <span class="literal">true</span>;</span><br><span class="line">context.canBePIE= <span class="literal">false</span>;</span><br><span class="line">context.enforceIOSMac= <span class="literal">true</span>;</span><br><span class="line">context.origin= <span class="literal">NULL</span>;<span class="comment">// can't use @loader_path with DYLD_INSERT_LIBRARIES</span></span><br><span class="line">context.rpath= <span class="literal">NULL</span>;</span><br><span class="line">image = load(path, context, cacheIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.allowInsertFailures )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: warning: could not load inserted library '%s' into hardened process because %s\n"</span>, path, msg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s' because %s\n"</span>, path, msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) &#123;</span><br><span class="line">halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s'\n"</span>, path));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部构建 context 后调用 load() 函数生成 image。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  做路径展开，搜索查找，排重，以及缓存查找工作。其中路径的展开和搜索分几个阶段（phase）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找 image</span></span><br><span class="line">ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line"><span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// 继续查找</span></span><br><span class="line">CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</span></span><br><span class="line"><span class="comment">// 在共享缓存中查找</span></span><br><span class="line"><span class="keyword">if</span> ( image == <span class="literal">NULL</span>)</span><br><span class="line">image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::iterator it = exceptions.begin(); it != exceptions.end(); ++it) &#123;</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span>*)(*it));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if loaded image is not from cache, but original path is in cache</span></span><br><span class="line"><span class="comment">// set gSharedCacheOverridden flag to disable some ObjC optimizations</span></span><br><span class="line"><span class="keyword">if</span> ( !gSharedCacheOverridden &amp;&amp; !image-&gt;inSharedCache() &amp;&amp; image-&gt;isDylib() &amp;&amp; cacheablePath(path) &amp;&amp; inSharedCache(path) ) &#123;</span><br><span class="line">gSharedCacheOverridden = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load 方法不仅被 loadInsertedDylib 调用，也会被 dlopen 等运行时加载动态库的方法使用。</p><p>内部有一整套 loadPhase0~loadPhase6 的流程来查找及加载 image。如果在共享缓存中找到则直接调用 instantiateFromCache 实例化 image，否则通过 loadPhase5open 打开文件并调用loadPhase6，内部通过 instantiateFromFile 实例化 image，最后再调用 checkandAddImage 将image 加载进内存。</p><p> 这些 phase 的搜索路径对应各个环境变量：DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p><p> ImageLoaderMachO 的 <code>instantiateFromFile</code>、<code>instantiateFromCache</code> 是 loader 将 MachO 文件解析映射到内存的核心方法，两个都会进入 Compressed 和 Classic 的分叉步骤。以 Compressed 下的 instantiateFromFile 来分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image by mapping in a mach-o file</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateFromFile(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* fileData, <span class="keyword">size_t</span> lenFileData,</span><br><span class="line"><span class="keyword">uint64_t</span> offsetInFat, <span class="keyword">uint64_t</span> lenInFat, <span class="keyword">const</span> struct stat&amp; info, </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, </span><br><span class="line"><span class="keyword">const</span> struct linkedit_data_command* codeSigCmd, </span><br><span class="line"><span class="keyword">const</span> struct encryption_info_command* encryptCmd, </span><br><span class="line"><span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart((macho_header*)fileData, path, segCount, libCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// record info about file  </span></span><br><span class="line">image-&gt;setFileInfo(info.st_dev, info.st_ino, info.st_mtime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if this image is code signed, let kernel validate signature before mapping any pages from image</span></span><br><span class="line"><span class="comment">// ①、交给内核去验证动态库的代码签名</span></span><br><span class="line">image-&gt;loadCodeSignature(codeSigCmd, fd, offsetInFat, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that first data we read with pread actually matches with code signature</span></span><br><span class="line"><span class="comment">// ②、映射到内存的 first page, （4k大小）与代码签名是否match。在这里会执行沙盒，签名认证</span></span><br><span class="line">image-&gt;validateFirstPages(codeSigCmd, fd, fileData, lenFileData, offsetInFat, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap segments</span></span><br><span class="line">image-&gt;mapSegments(fd, offsetInFat, lenInFat, info.st_size, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if framework is FairPlay encrypted, register with kernel</span></span><br><span class="line"><span class="comment">// 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据cryptid是否为1做了解密操作。</span></span><br><span class="line">image-&gt;registerEncryption(encryptCmd, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// probe to see if code signed correctly</span></span><br><span class="line">image-&gt;crashIfInvalidCodeSignature();</span><br><span class="line"></span><br><span class="line"><span class="comment">// finish construction</span></span><br><span class="line">image-&gt;instantiateFinish(context);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中几个需要留意的步骤：</p><ul><li>交给内核去验证动态库的代码签名 loadCodeSignature。</li><li>映射到内存的 first page（4k 大小）与代码签名是否 match。在这里会执行沙盒，签名认证，对于在线上运行时加载动态库的需求，可以重点研究<a href="https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg" target="_blank" rel="noopener">这里</a>。</li><li>根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息 registerEncryption。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了<a href="http://newosxbook.com/src.jl?tree=xnu-3789.70.16&amp;file=bsd/kern/kern_mman.c#mremap_encrypted" target="_blank" rel="noopener">内核代码</a>，应该是根据 cryptid 是否为 1 做了解密操作。</li><li>如果走到 Phase6, 会调 xmap 函数将动态库从本地 mmap 到用户态内存空间。</li></ul><p>根据上面的分析，<font color="#cc0000">主程序 imageLoader 在全局 image 表的首位</font>，后面的是插入的动态库的 imageLoader，每个动态库对应一个 loader。</p><h5 id="3-4-5-链接主程序"><a href="#3-4-5-链接主程序" class="headerlink" title="3.4.5 链接主程序"></a>3.4.5 链接主程序</h5><p>链接所有动态库，进行符号修正绑定工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        // link main executable</span><br><span class="line">        gLinkContext.linkingMainExecutable = true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">        if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">            // previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">            // work around that by rebasing by inverse amount</span><br><span class="line">            sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">                // 链接主程序</span><br><span class="line">        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">        sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">        if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">            gLinkContext.bindFlat = true;</span><br><span class="line">            gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主程序的链接是通过 <code>link</code> 这个函数完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</span><br><span class="line">&#123;</span><br><span class="line">// add to list of known images.  This did not happen at creation time for bundles</span><br><span class="line">// 添加到已知镜像列表中。这在创建 bundles 时没有处理。</span><br><span class="line">if ( image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked() )</span><br><span class="line">addImage(image);</span><br><span class="line"></span><br><span class="line">// we detect root images as those not linked in yet</span><br><span class="line">// 在根镜像中检测是否尚未链接</span><br><span class="line">if ( !image-&gt;isLinked() )</span><br><span class="line">addRootImage(image);</span><br><span class="line"></span><br><span class="line">// process images</span><br><span class="line">try &#123;</span><br><span class="line">const char* path = image-&gt;getPath();</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">if ( image == sAllCacheImagesProxy )</span><br><span class="line">path = sAllCacheImagesProxy-&gt;getIndexedPath(cacheIndex);</span><br><span class="line">#endif</span><br><span class="line">// 调用 ImageLoader::link() 链接</span><br><span class="line">image-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path);</span><br><span class="line">&#125;</span><br><span class="line">catch (const char* msg) &#123;</span><br><span class="line">// 标记 image 为未使用，处理</span><br><span class="line">garbageCollectImages();</span><br><span class="line">throw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span><br><span class="line"></span><br><span class="line">// clear error strings</span><br><span class="line">(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">// 起始时间。用于记录时间间隔</span><br><span class="line">uint64_t t0 = mach_absolute_time();</span><br><span class="line">// ①、递归加载主程序依赖的库，完成之后发送一个状态为 dyld_image_state_dependents_mapped的通知。</span><br><span class="line">this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">// we only do the loading step for preflights  只做预检的装载步骤</span><br><span class="line">if ( preflightOnly )</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">uint64_t t1 = mach_absolute_time();</span><br><span class="line">// 清空 image 层级关系</span><br><span class="line">context.clearAllDepths();</span><br><span class="line">// 递归更新 image 层级关系</span><br><span class="line">this-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">__block uint64_t t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);</span><br><span class="line">t2 = mach_absolute_time();</span><br><span class="line">// ②、递归修正自己和依赖库的基地址，因为 ASLR 的原因，需要根据随机 slide 修正基地址。</span><br><span class="line">this-&gt;recursiveRebase(context);</span><br><span class="line">context.notifyBatch(dyld_image_state_rebased, false);</span><br><span class="line"></span><br><span class="line">t3 = mach_absolute_time();</span><br><span class="line">if ( !context.linkingMainExecutable )</span><br><span class="line">// ③、递归绑定 noLazy 的符号表，lazy的符号会在运行时动态绑定（首次被调用才去绑定）</span><br><span class="line">this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = mach_absolute_time();</span><br><span class="line">if ( !context.linkingMainExecutable )</span><br><span class="line">// ④、绑定弱符号表，比如未初始化的全局变量就是弱符号。</span><br><span class="line">this-&gt;weakBind(context);</span><br><span class="line">t5 = mach_absolute_time();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    if ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, false);</span><br><span class="line">uint64_t t6 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line">// ⑤、递归获取/注册程序的 DOF 节区，dtrace 会用其动态跟踪。</span><br><span class="line">this-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">// 注册</span><br><span class="line">context.registerDOFs(dofs);</span><br><span class="line">uint64_t t7 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">// interpose any dynamically loaded images</span><br><span class="line">if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123;</span><br><span class="line">dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);</span><br><span class="line">// 递归应用插入的动态库</span><br><span class="line">this-&gt;recursiveApplyInterposing(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// clear error strings</span><br><span class="line">(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">// 计算出各种时间间隔</span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line">// done with initial dylib loads</span><br><span class="line">fgNextPIEDylibAddress = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部加载动态库、rebase、绑定符号表、注册dofs信息等，同时还计算各步骤的耗时。如果想获取这些耗时，只需要在环境变量中添加 <font color="#cc0000"><code>DYLD_PRINT_STATISTICS</code></font> 就可以了，这个环境变量不需要 value。</p><p>在步骤 ① 里，递归加载主 App 在打包阶段就确定好的动态库的操作，会使用前面提到的 setContext 里的链接上下文，调用它的 loadLibrary 方法；然后优先去加载依赖的动态库。loadLibary 的实现在设置链接上下文的时候就已经赋值确定，即 libraryLocator，在这个方法里会用到上面提到的 load 方法。</p><p>在步骤 ③ 里，会有符号绑定的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief   recursiveBind 完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，对于 DYLD_BIND_AT_LAUNCH 等特殊情况下的 non-lazy 符号才执行立即绑定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::recursiveBind(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> neverUnload)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Normally just non-lazy pointers are bound immediately.</span></span><br><span class="line"><span class="comment">// The exceptions are:</span></span><br><span class="line"><span class="comment">//   1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately</span></span><br><span class="line"><span class="comment">//   2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately</span></span><br><span class="line"><span class="keyword">if</span> ( fState &lt; dyld_image_state_bound ) &#123;</span><br><span class="line"><span class="comment">// break cycles</span></span><br><span class="line">fState = dyld_image_state_bound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// bind lower level libraries first</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">ImageLoader* dependentImage = libImage(i);</span><br><span class="line"><span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> )</span><br><span class="line">dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bind this image</span></span><br><span class="line"><span class="comment">// 绑定。this 表示递归调用时，recursiveBind 方法的调用者</span></span><br><span class="line"><span class="keyword">this</span>-&gt;doBind(context, forceLazysBound);</span><br><span class="line"><span class="comment">// mark if lazys are also bound</span></span><br><span class="line"><span class="keyword">if</span> ( forceLazysBound || <span class="keyword">this</span>-&gt;usablePrebinding(context) )</span><br><span class="line">fAllLazyPointersBound = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// mark as never-unload if requested</span></span><br><span class="line"><span class="keyword">if</span> ( neverUnload )</span><br><span class="line"><span class="keyword">this</span>-&gt;setNeverUnload();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">context.notifySingle(dyld_image_state_bound, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="comment">// restore state</span></span><br><span class="line">fState = dyld_image_state_rebased;</span><br><span class="line">            CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的核心是 ImageLoaderMach 的 doBind，读取 image 的动态链接信息的 bind_off 与 bind_size 来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用 <font color="#cc0000">bindAt</font> 函数；调用 resolve 解析完符号表后，调用 bindLocation 完成最终的绑定操作，需要绑定的符号信息有三种：</p><ul><li>BIND_TYPE_POINTER：需要绑定的是一个指针。直接将计算好的新值屿值即可。</li><li>BIND_TYPE_TEXT_ABSOLUTE32：一个32位的值。取计算的值的低32位赋值过去。</li><li>BIND_TYPE_TEXT_PCREL32：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。</li></ul><p>对延迟绑定的实现感兴趣的可以在Xcode中调试查看，或者参考<a href="https://leylfl.github.io/2018/05/28/dyld%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">这个</a>。</p><h5 id="3-4-6-链接插入的动态库"><a href="#3-4-6-链接插入的动态库" class="headerlink" title="3.4.6 链接插入的动态库"></a>3.4.6 链接插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="comment">// 链接其他被插入的动态库</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// 循环处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 链接</span></span><br><span class="line">link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 递归修改 image 的 fNeverUnload 属性</span></span><br><span class="line">image-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="comment">// 只有插入可插入的库。在绑定所有插入的库后注册插入信息，以便链接工作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="comment">// 即使没有 DYLD_INSERT_LIBRARIES，dyld 也应该支持插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;inSharedCache() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES  <span class="comment">// !TARGET_IPHONE_SIMULATOR，非模拟器</span></span></span><br><span class="line"><span class="keyword">if</span> ( (sAllCacheImagesProxy != <span class="literal">NULL</span>) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line"><span class="comment">// Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span></span><br><span class="line"><span class="comment">// 加速键表不能与隐式插入一起使用，因此在禁用加速键表的情况下重新启动</span></span><br><span class="line">ImageLoader::clearInterposingTuples();</span><br><span class="line"><span class="comment">// unmap all loaded dylibs (but not main executable)</span></span><br><span class="line"><span class="comment">// 取消映射所有加载的 dylib 文件，除了主程序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image == sMainExecutable )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ( image == sAllCacheImagesProxy )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;setCanUnload();</span><br><span class="line">ImageLoader::deleteImage(image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span></span><br><span class="line">sAllImages.clear();</span><br><span class="line">sImageRoots.clear();</span><br><span class="line">sImageFilesNeedingTermination.clear();</span><br><span class="line">sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">sAddImageCallbacks.clear();</span><br><span class="line">sRemoveImageCallbacks.clear();</span><br><span class="line">sAddLoadImageCallbacks.clear();</span><br><span class="line">sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line">sAllCacheImagesProxy = <span class="literal">NULL</span>;  <span class="comment">// 下次不再进入</span></span><br><span class="line">sMappedRangesStart = <span class="literal">NULL</span>;</span><br><span class="line">mainExcutableAlreadyRebased = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">resetAllImages();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转回上面的步骤，重新执行，加载所有的镜像</span></span><br><span class="line"><span class="keyword">goto</span> reloadAllImages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line"><span class="comment">// 是调用 ImageLoader::applyInterposing()，不是 ClosureWriter.cpp。内部递归，最终是执行 doInterpose() 方法</span></span><br><span class="line">sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入信息存入 dyld 缓存</span></span><br><span class="line">ImageLoader::applyInterposingToDyldCache(gLinkContext);</span><br><span class="line"><span class="comment">// 修改主程序插入标识</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the main executable now that interposing has been registered</span></span><br><span class="line"><span class="comment">// 从主程序开始调用，递归执行绑定、通知（插入信息已经注册）</span></span><br><span class="line"><span class="keyword">uint64_t</span> bindMainExecutableStartTime = mach_absolute_time();</span><br><span class="line"><span class="comment">// 内部执行 doBind()、notifySingle()</span></span><br><span class="line">sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> bindMainExecutableEndTime = mach_absolute_time();</span><br><span class="line"><span class="comment">// 绑定和通知处理时间</span></span><br><span class="line">ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime;</span><br><span class="line">gLinkContext.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 绑定插入的动态库</span></span><br><span class="line">image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里参与链接的动态库根据第 4 步中加载的插入的动态库，从 sAllImages 的第二个 imageLoader 开始，取出 image，重复 <code>link</code> 操作进行连接。registerInterposing 内部会加载 loadCmds 并查找 __interpose 及 __DATA 段，读取段信息保存到 fgInterposingTuples 中，然后调用 applyInterposing，内部调用 recursiveApplyInterposing，通过这个函数调用到 doInterpose。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoaderMachOCompressed::doInterpose(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( context.verboseInterposing )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: interposing %lu tuples onto image: %s\n"</span>, fgInterposingTuples.size(), <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// update prebound symbols。更新预绑定的符号</span></span><br><span class="line">eachBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line"><span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line"><span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">ExtraBindData *extraBindData,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line"><span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">   addend, libraryOrdinal, extraBindData,</span><br><span class="line">   msg, last, runResolver);</span><br><span class="line">&#125;);</span><br><span class="line">eachLazyBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line"><span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line"><span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">ExtraBindData *extraBindData,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line"><span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">   addend, libraryOrdinal, extraBindData,</span><br><span class="line">   msg, last, runResolver);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interposeAt 通过 interposedAddress 在上文提到的 fgInterposingTuples 中找到需要替换的符号地址进行替换。</p><h5 id="3-4-7-弱符号绑定"><a href="#3-4-7-弱符号绑定" class="headerlink" title="3.4.7 弱符号绑定"></a>3.4.7 弱符号绑定</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">        <span class="comment">// 弱符号绑定</span></span><br><span class="line">        sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::weakBind(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind start:\n"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"><span class="comment">// get set of ImageLoaders that participate in coalecsing</span></span><br><span class="line">ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing];</span><br><span class="line"><span class="keyword">unsigned</span> imageIndexes[fgImagesRequiringCoalescing];</span><br><span class="line"><span class="comment">// 合并所有动态库的弱符号到列表中</span></span><br><span class="line"><span class="keyword">int</span> count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// count how many have not already had weakbinding done</span></span><br><span class="line"><span class="keyword">int</span> countNotYetWeakBound = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countOfImagesWithWeakDefinitionsNotInSharedCache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;weakSymbolsBound(imageIndexes[i]) )</span><br><span class="line"><span class="comment">// 获取未进行绑定的弱符号的个数</span></span><br><span class="line">++countNotYetWeakBound;</span><br><span class="line"><span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;inSharedCache() )</span><br><span class="line"><span class="comment">// 获取在共享缓存中已绑定的弱符号个数</span></span><br><span class="line">++countOfImagesWithWeakDefinitionsNotInSharedCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't need to do any coalescing if only one image has overrides, or all have already been done</span></span><br><span class="line"><span class="keyword">if</span> ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; <span class="number">0</span>) &amp;&amp; (countNotYetWeakBound &gt; <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="comment">// make symbol iterators for each</span></span><br><span class="line">ImageLoader::CoalIterator iterators[count];</span><br><span class="line">ImageLoader::CoalIterator* sortedIts[count];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="comment">// 对需要绑定的弱符号排序</span></span><br><span class="line">imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i, imageIndexes[i]);</span><br><span class="line">sortedIts[i] = &amp;iterators[i];</span><br><span class="line"><span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind load order %d/%d for %s\n"</span>, i, count, imagesNeedingCoalescing[i]-&gt;getIndexedPath(imageIndexes[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walk all symbols keeping iterators in sync by </span></span><br><span class="line"><span class="comment">// only ever incrementing the iterator with the lowest symbol </span></span><br><span class="line"><span class="keyword">int</span> doneCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( doneCount != count ) &#123;</span><br><span class="line"><span class="comment">//for(int i=0; i &lt; count; ++i)</span></span><br><span class="line"><span class="comment">//dyld::log("sym[%d]=%s ", sortedIts[i]-&gt;loadOrder, sortedIts[i]-&gt;symbolName);</span></span><br><span class="line"><span class="comment">//dyld::log("\n");</span></span><br><span class="line"><span class="comment">// increment iterator with lowest symbol</span></span><br><span class="line"><span class="comment">// 计算弱符号偏移量及大小，绑定弱符号</span></span><br><span class="line"><span class="keyword">if</span> ( sortedIts[<span class="number">0</span>]-&gt;image-&gt;incrementCoalIterator(*sortedIts[<span class="number">0</span>]) )</span><br><span class="line">++doneCount; </span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程：合并所有动态库的弱符号到列表中 -&gt; 对需要绑定的弱符号排序 -&gt; 计算弱符号偏移量及大小，绑定弱符号</p><h5 id="3-4-8-初始化主程序"><a href="#3-4-8-初始化主程序" class="headerlink" title="3.4.8 初始化主程序"></a>3.4.8 初始化主程序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">CRSetCrashLogMessage(<span class="string">"dyld: launch, running initializers"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line"><span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line"><span class="keyword">if</span> ( ! gRunInitializersOldWay )</span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="comment">// 通知任何监视进程，此进程将要进入main（）。</span></span><br><span class="line"><span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">notifyMonitoringDyldMain();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// record that we've reached this step。开始初始化标识</span></span><br><span class="line">gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line"><span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line"><span class="comment">// 初始化动态库</span></span><br><span class="line">sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line"><span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dump info if requested</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先初始化动态库，然后初始化主程序。上文提到的 DYLD_PRINT_STATISTICS 环境变量在这里也出现了，除此之外还有个 detail 版的环境变量 <font color="#cc0000">DYLD_PRINT_STATISTICS_DETAILS</font>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::runInitializers(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程</span></span><br><span class="line"><span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">ImageLoader::UninitedUpwards up;</span><br><span class="line">up.count = <span class="number">1</span>;</span><br><span class="line">up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 在进程中初始化</span></span><br><span class="line">processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line"><span class="comment">// 初始化耗时</span></span><br><span class="line">fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/14412057&gt; upward dylib initializers can be run too soon</span></span><br><span class="line"><span class="comment">// To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs</span></span><br><span class="line"><span class="comment">// have their initialization postponed until after the recursion through downward dylibs</span></span><br><span class="line"><span class="comment">// has completed.</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::processInitializers(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span><br><span class="line"> InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">ups.count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line"><span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line"><span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态库和主程序的初始化是调用 runInitializers，内部通过 processInitializers 调用 recursiveInitialization 递归初始化当前 image 所依赖的库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::recursiveInitialization(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span><br><span class="line">  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 递归锁</span></span><br><span class="line"><span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line"><span class="comment">// break cycles</span></span><br><span class="line"><span class="comment">// 退出递归循环</span></span><br><span class="line">fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// initialize lower level libraries first</span></span><br><span class="line"><span class="comment">// 先初始化低级别的库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">ImageLoader* dependentImage = libImage(i);</span><br><span class="line"><span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line"><span class="comment">// 不要试图初始化级别高于我的</span></span><br><span class="line"><span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">uninitUps.images[uninitUps.count] = dependentImage;</span><br><span class="line">uninitUps.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record termination order. 记录终止命令</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">fState = dyld_image_state_dependents_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="comment">// 真正初始化镜像</span></span><br><span class="line"><span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">fState = dyld_image_state_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line">context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="comment">// this image is not initialized</span></span><br><span class="line">fState = oldState;</span><br><span class="line">recursiveSpinUnLock();</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意内部有个调用 context.notifySingle(dyld_image_state_initialized, this, NULL)，其实每次 image 状态改变都会调用 notifySingle 这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log("notifySingle(state=%d, image=%s)\n", state, image-&gt;getPath());</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</span><br><span class="line"><span class="keyword">if</span> ( handlers != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">dyld_image_info info;</span><br><span class="line">info.imageLoadAddress= image-&gt;machHeader();</span><br><span class="line">info.imageFilePath= image-&gt;getRealPath();</span><br><span class="line">info.imageFileModDate= image-&gt;lastModified();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* result = (*it)(state, <span class="number">1</span>, &amp;info);</span><br><span class="line"><span class="keyword">if</span> ( (result != <span class="literal">NULL</span>) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</span><br><span class="line"><span class="comment">//fprintf(stderr, "  image rejected by handler=%p\n", *it);</span></span><br><span class="line"><span class="comment">// make copy of thrown string so that later catch clauses can free it</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = strdup(result);</span><br><span class="line"><span class="keyword">throw</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( state == dyld_image_state_mapped ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</span></span><br><span class="line"><span class="keyword">if</span> ( !image-&gt;inSharedCache() ) &#123;</span><br><span class="line">dyld_uuid_info info;</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;getUUID(info.imageUUID) ) &#123;</span><br><span class="line">info.imageLoadAddress = image-&gt;machHeader();</span><br><span class="line">addNonSharedCacheImageUUID(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">dyld3::<span class="function">ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line"><span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line"><span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// mach message csdlc about dynamically unloaded images</span></span><br><span class="line"><span class="keyword">if</span> ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</span><br><span class="line">notifyKernel(*image, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">loadAddress</span>[] = &#123;</span> image-&gt;machHeader() &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* loadPath[] = &#123; image-&gt;getPath() &#125;;</span><br><span class="line">notifyMonitoringDyld(<span class="literal">true</span>, <span class="number">1</span>, loadAddress, loadPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 state == dyld_image_state_mapped 时，将 image 对应的 UUID 存起来，当state == dyld_image_state_dependents_initialized 并且有 sNotifyObjCInit 回调时调用sNotifyObjCInit函数。</p><p>搜索回调函数赋值入口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// record functions to call</span></span><br><span class="line">    sNotifyObjCMapped   = mapped;</span><br><span class="line">    sNotifyObjCInit     = init;</span><br><span class="line">    sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">    dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是通过 _dyld_objc_notify_register 这个函数注册回调的。</p><p>[NSObject load] 的堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2</span><br><span class="line">  * frame #0: 0x000000010944f3b1 libobjc.A.dylib`+[NSObject load]</span><br><span class="line">    frame #1: 0x000000010943d317 libobjc.A.dylib`call_load_methods + 691</span><br><span class="line">    frame #2: 0x000000010943e814 libobjc.A.dylib`load_images + 77</span><br><span class="line">    frame #3: 0x0000000108b73b97 dyld_sim`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 260</span><br><span class="line">    frame #4: 0x000000010b779bf3 libdyld.dylib`_dyld_objc_notify_register + 113</span><br><span class="line">    frame #5: 0x000000010944ca12 libobjc.A.dylib`_objc_init + 115</span><br><span class="line">    frame #6: 0x000000010b7015c0 libdispatch.dylib`_os_object_init + 13</span><br><span class="line">    frame #7: 0x000000010b70f4e5 libdispatch.dylib`libdispatch_init + 300</span><br><span class="line">    frame #8: 0x0000000109e05a78 libSystem.B.dylib`libSystem_initializer + 164</span><br><span class="line">    frame #9: 0x0000000108b82b96 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 506</span><br><span class="line">    frame #10: 0x0000000108b82d9c dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40</span><br><span class="line">    frame #11: 0x0000000108b7e3fc dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 324</span><br><span class="line">    frame #12: 0x0000000108b7e392 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 218</span><br><span class="line">    frame #13: 0x0000000108b7d5d3 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 133</span><br><span class="line">    frame #14: 0x0000000108b7d665 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 73</span><br><span class="line">    frame #15: 0x0000000108b71333 dyld_sim`dyld::initializeMainExecutable() + 129</span><br><span class="line">    frame #16: 0x0000000108b75434 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4384</span><br><span class="line">    frame #17: 0x0000000108b70630 dyld_sim`start_sim + 136</span><br><span class="line">    frame #18: 0x00000001155c1234 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2238</span><br><span class="line">    frame #19: 0x00000001155bf0ce dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 522</span><br><span class="line">    frame #20: 0x00000001155ba503 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1167</span><br><span class="line">    frame #21: 0x00000001155ba036 dyld`_dyld_start + 54</span><br></pre></td></tr></table></figure><p>可以看到，_dyld_objc_notify_register 是在初始化 libobjc.A.dylib 这个动态库时调用的，然后 _objc_init 内部调用了 load_images，进而调用 call_load_methods，从而调用各个类中的load方法，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F" target="_blank" rel="noopener">Objc源码</a>。</p><p>notifySingle 调用完毕后，开始真正初始化工作 <font color="#cc0000"><code>doInitialization</code></font>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ImageLoaderMachO::doInitialization(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">    doImageInit(context);</span><br><span class="line">    doModInitFunctions(context);</span><br><span class="line">    </span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doImageInit 执行 <code>LC_ROUTINES_COMMAND</code> segment 中保存的函数，doModInitFunctions执行 __DATA,__mod_init_func section 中保存的函数。这个 section 中保存的是 C++ 的构造函数及带有 attribute((constructor)) 的 C 函数，简单验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.mm</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">    Test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test()&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test test;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) void testConstructor() &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    testConstructor();</span><br><span class="line"></span><br><span class="line">    Test * t = new Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-19 13:26:33.587051+0800 Demo[7105:314102] testConstructor</span><br><span class="line">2019-08-19 13:26:33.587109+0800 Demo[7105:314102] Test</span><br></pre></td></tr></table></figure><p>通过 MachOView 可以看到：</p><p>显然，__mod_init_func 中的函数在类对应的 load 方法之后调用。</p><ol><li>对于 dumpdcrypted 这一类注入方法实现功能的插件，他们添加的静态方法会在 doModInitFunctions方法中被解析出来，位置在 MachO 文件的 __DATA 段的 __mod_init_func section。C++ 的全局对象也会出现在这个section中。</li><li>在递归初始化 (recursiveInitialization）中，如果当前执行的是主程序 image，doInitialization 完毕后会执行 notifySingle 方法去通知观察者。在 doInitialization 方法前会发送 state 为 dyld_image_state_dependents_initialized 的通知，由这个通知，会调用 libobjc 的 load_images，最后去依次调用各个 OC 类的 load 方法以及分类的 load 方法。</li><li><p>Objective-C 的入口方法是 _objc_init，dyld 唤起它的执行路径是从 runInitializers -&gt; recursiveInitialization -&gt; doInitialization -&gt; doModInitFunctions -&gt;.. _objc_init。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;       </span><br><span class="line"><span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">_dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                         <span class="number">1</span><span class="comment">/*batch*/</span>, &amp;map_2_images);</span><br><span class="line">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>_objc_init 会在 dyld 中注册两个通知，对应的回调会分别执行将 OC 类加载到内存和调用 load 方法的操作。后面的就是 OC 类加载的经典方法 map_2_images 了。</p></li><li><p>从 recursiveInitialization 的以下代码片段可以看出 load 是在全局实例或者方法调用前被触发的。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"><span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">fState = dyld_image_state_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line">context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-4-9-查找主程序入口函数指针并返回"><a href="#3-4-9-查找主程序入口函数指针并返回" class="headerlink" title="3.4.9 查找主程序入口函数指针并返回"></a>3.4.9 查找主程序入口函数指针并返回</h5><p>调用getEntryFromLC_MAIN 获取主程序 main 函数的地址，如果未找到则调用getEntryFromLC_UNIXTHREAD 获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_MAIN() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="keyword">char</span>*)fMachOData);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"LC_MAIN entryoff is out of range"</span>;</span><br><span class="line">&#125;</span><br><span class="line">cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( cmd-&gt;cmd == LC_UNIXTHREAD ) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">i386_thread_state_t</span>* registers = (<span class="keyword">i386_thread_state_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;eip + fSlide);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">x86_thread_state64_t</span>* registers = (<span class="keyword">x86_thread_state64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;rip + fSlide);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __arm64__ &amp;&amp; !__arm64e__</span></span><br><span class="line"><span class="comment">// temp support until &lt;rdar://39514191&gt; is fixed</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span>* regs64 = (<span class="keyword">uint64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(regs64[<span class="number">32</span>] + fSlide); <span class="comment">// arm_thread_state64_t.__pc</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"no valid entry point"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，入口是在 load_command 的 LC_MAIN 或者 LC_UNIXTHREAD 中 LC_MAIN。</p><h2 id="四、dyld-闭包"><a href="#四、dyld-闭包" class="headerlink" title="四、dyld 闭包"></a>四、dyld 闭包</h2><p>在第 2 步和第 3 步之间有一个查找闭包并以其结果作为程序入口返回的代码，这里是 <a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">WWDC 2017</a> 推出的 dyld3 中提出的一种优化 App 启动速度的技术。大致步骤如下：</p><ol><li>如果满足条件：开启闭包（DYLD_USE_CLOSURES 环境变量为 1），App 的路径在白名单中（目前只有系统 Ap p享有使用闭包的特权），共享缓存加载地址不为空，则往下执行。</li><li>去内存中查找闭包数据，这里的方法是 findClosure。如果内存中不存在，再去 <code>/private/var/staged_system_apps</code> 路径下去查找硬盘数据，找到就返回结果。</li><li>如果没有闭包数据，就会调用 socket 通信走 RPC 去获取闭包数据，执行方法为 callClosureDaemon，感兴趣可以研究下。</li><li>如果闭包数据不为空，就会走核心方法：launchWithClosure，基于闭包去启动 App，并且返回该方法中获取的程序入口地址给外界。这个方法重复了上面的各个步骤。具体实现和内部的数据结构有待分析。</li></ol><h2 id="五、共享缓存机制"><a href="#五、共享缓存机制" class="headerlink" title="五、共享缓存机制"></a>五、共享缓存机制</h2><p>在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个一个加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到 <font color="#cc0000"><code>/System/Library/Caches/com.apple.dyld/</code></font> 目录下，按不同的架构保存分别保存着，原作者的 iPhone6 里面就有 dyld_shared_cache_armv7s 和 dyld_shared_cache_armv64 两个文件，如下图所示。</p><p>想要分析某个系统库，就需要从 dyld_shared_cache 里先将的原始二进制文件提取出来，这里从易到难提供 3 种方法：</p><h4 id="5-1-dyld-cache-extract-提取"><a href="#5-1-dyld-cache-extract-提取" class="headerlink" title="5.1 dyld_cache_extract 提取"></a>5.1 dyld_cache_extract 提取</h4><p><a href="https://github.com/macmade/dyld_cache_extract" target="_blank" rel="noopener">dyld_cache_extract</a> 是一个可视化的工具，使用极其简单，把 dyld_shared_cache 载入即可解析出来，如下图所示。</p><h4 id="5-2-jtool-提取"><a href="#5-2-jtool-提取" class="headerlink" title="5.2 jtool 提取"></a>5.2 jtool 提取</h4><p>以提取 CFNetwork 为例，使用如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jtool -extract CFNetwork ./dyld_shared_cache_arm64</span><br></pre></td></tr></table></figure><h4 id="5-3-dsc-extractor-提取"><a href="#5-3-dsc-extractor-提取" class="headerlink" title="5.3 dsc_extractor 提取"></a>5.3 dsc_extractor 提取</h4><p>在 dyld 源代码的 launch-cache 文件夹里面找到 dsc_extractor.cpp，将 653 行的“#if 0”修改为“#if 1”，然后用如下命令编译生成 dsc_extractor，并使用它提取所有缓存文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ dsc_extractor.cpp dsc_iterator.cpp  -o dsc_extractor</span><br><span class="line">$ ./dsc_extractor ./dyld_shared_cache_arm64 ./</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>每个 MachO 都会由一个 imageLoader 来处理加载和依赖管理的操作，这里是由 dyld 来安排。主程序 app 的 image 的加载是由内核来完成的。其他的动态库的加载细节可以参考上面提到的 link 方法实现，当一个 image 加载完毕，dyld 会发送 dyld_image_state_bound 通知；著名的 hook 工具 fishhook 的实现原理也是借助监听这个通知，在回调里完成 hook 操作的。</p><h2 id="七、文章"><a href="#七、文章" class="headerlink" title="七、文章"></a>七、文章</h2><p><a href="https://www.jianshu.com/u/02a488e1e71e" target="_blank" rel="noopener">01_Jack</a> &amp; <a href="https://www.jianshu.com/p/82e6fdaa0e41" target="_blank" rel="noopener">dyld源码解读</a><br><a href="https://me.csdn.net/lovechris00" target="_blank" rel="noopener">伊织__</a> &amp; <a href="https://blog.csdn.net/lovechris00/article/details/81561627#otool_0" target="_blank" rel="noopener">Mac - otool</a><br><a href="https://www.jianshu.com/u/3b5a95e93778" target="_blank" rel="noopener">RemisKrlet</a> &amp; <a href="https://www.jianshu.com/p/72e34948dac0" target="_blank" rel="noopener">App启动过程 - dyld加载动态库</a><br><a href="https://www.dllhook.com/post/238.html" target="_blank" rel="noopener">dyld详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>终端</title>
    <link href="http://yoursite.com/2019/08/06/%E5%B7%A5%E5%85%B7/%E7%BB%88%E7%AB%AF/"/>
    <id>http://yoursite.com/2019/08/06/工具/终端/</id>
    <published>2019-08-06T05:54:23.090Z</published>
    <updated>2019-08-31T07:24:51.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、github-clone-提速"><a href="#1、github-clone-提速" class="headerlink" title="1、github clone 提速"></a>1、github clone 提速</h2><h4 id="1-1-修改-hosts-文件"><a href="#1-1-修改-hosts-文件" class="headerlink" title="1.1 修改 hosts 文件"></a>1.1 修改 hosts 文件</h4><ol><li><p>在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress.com</a> 网站中中分别查询 <code>https://www.github.com</code> 和 <code>github.global.ssl.fastly.net</code> 域名的 IP 地址。</p> <center><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubIPSearch.png" alt><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubIP.png" alt><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubSSLIP.png" alt><br> </center></li><li><p>打开的 hosts 文件</p></li></ol><p>【Windows】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\host</span><br></pre></td></tr></table></figure><p>【Mac】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><center><br><img src="http://pugqga7mf.bkt.clouddn.com/ViHosts.png" alt><br><img src="http://pugqga7mf.bkt.clouddn.com/EditHosts.png" alt><br></center><p><a href="https://www.jianshu.com/p/8577c9401fe1" target="_blank" rel="noopener">更多阅读</a></p><blockquote><p>重启 Finder 进程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ $ killall Finder</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、github-clone-提速&quot;&gt;&lt;a href=&quot;#1、github-clone-提速&quot; class=&quot;headerlink&quot; title=&quot;1、github clone 提速&quot;&gt;&lt;/a&gt;1、github clone 提速&lt;/h2&gt;&lt;h4 id=&quot;1-1-修
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode</title>
    <link href="http://yoursite.com/2019/08/06/%E5%B7%A5%E5%85%B7/Xcode/"/>
    <id>http://yoursite.com/2019/08/06/工具/Xcode/</id>
    <published>2019-08-06T05:35:43.506Z</published>
    <updated>2019-09-30T07:55:57.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、整行上下移动"><a href="#一、整行上下移动" class="headerlink" title="一、整行上下移动"></a>一、整行上下移动</h2><p>Xcode 自带的配置文件路径：/Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Versions/A/Resources/IDETextKeyBindingSet.plist，用文本编辑 IDETextKeyBindingSet.plist，并添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;GDI Commands&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">       &lt;key&gt;GDI Duplicate Current Line&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, copy:, moveToEndOfLine:,insertNewline:, paste:, deleteBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Delete Current Line&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveToEndOfLine:, deleteToBeginningOfLine:,deleteBackward:,moveDown:,moveToEndOfLine:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Move Current Line Up&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, cut:, moveUp:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Move Current Line Down&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, cut:, moveDown:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Insert Line Above&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveUp:, moveToEndOfLine:, insertNewline:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Insert Line Below&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveToEndOfLine:, insertNewline:&lt;/string&gt;</span><br><span class="line">   &lt;/dict&gt;</span><br></pre></td></tr></table></figure><font color="#cc0000">注意</font>：Xcode.app 需要换成实际的应用名，如 Xcode10.1.app。<br><br>详细文章：<a href="https://www.cnblogs.com/goodboy-heyang/p/4732365.html" target="_blank" rel="noopener">xcode 设置快捷键 整行上下移动</a><br><br>## 二、Other linker flags<br><br>Other linker flags 用来填写 XCode 的<font color="#cc0000">链接器参数</font>。<br><br>从 C 代码到可执行文件经历的步骤是：<br><br>&gt; 源代码 -&gt; 预处理器 -&gt; 编译器 -&gt; 汇编器 -&gt; 机器码 -&gt; 链接器 -> 可执行文件<br><br>在最后一步需要<font color="#cc0000">把 .o 文件和 C 语言运行库链接起来</font>，这时候需要用到 <font color="#cc0000">ld</font> 命令。<br><br>源文件经过一系列处理以后，会生成对应的 <font color="#cc0000">.obj</font> 文件，然后一个项目必然会有许多 .obj 文件，并且这些文件之间会有各种各样的联系，例如函数调用。<font color="#cc0000">链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件</font>。<br><br>Other linker flags 设置的值<font color="#cc0000">实际上就是 ld 命令执行时后面所加的参数</font>。<br><br>&gt; The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category.<br>&gt;<br>&gt; 运行时的异常是由于标准 XNIX 静态库、链接器与 OC 语言的动态的特性之间的问题，OC 语言并不是对每一个函数或者方法建立链接器符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不知道将核心类与分类之间的代码实现联系起来，这就导致最终的应用程序中的可执行文件缺失了分类中的代码，这样函数调用就失败了。<br><br>常用参数：<br><br>- －ObjC<br><br>    链接器就会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中。<br><br>    这样编译之后的 app 会变大，因为加载了很多不必要的文件而导致可执行文件变大。但是如果静态库中有类和 category 的话只有加入这个 flag 才行。但是 Objc 也不是万能的，当静态库中只有分类而没有类的时候，Objc 就失效了，这就需要使用 -all_load 或者 -force_load 了。<br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyStaticLib</span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;sssss&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyStaticLib (Cate)</span><br><span class="line">/**</span><br><span class="line"> * 重写方法</span><br><span class="line"> */</span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;哈哈哈&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><br><br><br>    静态库中分类重写了方法，导入工程中，设置 -Objc 参数将打印：哈哈哈；不设置将打印：sssss。<br><br>- －all_load<br><br>    会让链接器把所有找到的目标文件都加载到可执行文件中，即使没有 objc 代码。但是这个参数也有一个弊端，假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到 <font color="#cc0000">ld: duplicate symbol</font> 错误，因为不同的库文件里面可能会有相同的目标文件，有两种方法解决：1、用命令行进行拆包；2、使用 -force_load 参数。<br><br>- -force_load<br><br>    适用于 Xcode3.2+ 版本，它允许 finer 得到文档加载的控制，所做的事情跟 -all_load 其实是一样的，但是每一个 -force_load 操作必须跟着一个文档路径，文档中的每一个对象文件将会被加载，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。<br><br>- -lstdc++<br><br>    OC 和 C++ 混编时，在 Compile 阶段一切顺利，Clang 会根据后缀（.m .cpp）选择编译器进行编译，产物都是 Object File（.o 文件）。如果一个文件调用另一个文件的方法，编译出的 Object File 中会出现 undefined symbol 去代表这个方法。在链接阶段，Linker 通过把依赖的文件也加到最终的 executable 中 resolve undefined symbol。<br><br>    Linker 没有主动的去 link stdc++ 库，解决方案 1：在 Other Linker Flags 中新增标志 -lstdc++；解决方案2：在 Linked Framework and Libraries 中添加 libstdc++.tbd。<br><br>- 总结：<br><br>    建议 -ObjC 与 -force_load 搭配使用比较好。<br><br>    包含静态库时需要在 Target 的 Other linker flags 里面加上值：-objC、-all_load、-force_load<br><br>    对于 64 位机器和 iPhone O S应用，解决方法是使用 -all_load 或者 -force_load。<br><br>- 文章：<br><br>    <a href="https://blog.csdn.net/bobo553443/article/details/78633340" target="_blank" rel="noopener">Xcode 中 other linker flags 的作用</a><br>    <a href="https://blog.csdn.net/fly1183989782/article/details/80558831" target="_blank" rel="noopener">当我们在设置 Other Linker Flags -lstdc++时，我们到底在设置什么？</a><br><br><br>## 三、Archive<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1b5c4ce68e064e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>1. iOS App Store<br><br>    保存到本地，准备上传 App Store 或者在越狱的 iOS 设备上使用，利用的是 Distribution 描述文件，关联 production 证书；<br><br>2. Ad Hoc<br><br>    保存到本地，准备在开发者账户下添加了 UDID 的设备上使用，利用的是 Distribution 描述文件，关联 production 证书；<br><br>    &gt; 官方解释：Ad Hoc 模式的包和将来发布到 App Store 的包在各种功能测试上是一样的，只要 Ad Hoc 模式下测试（推送、内购等）没有问题，发布到 App Store 也是没有问题的。<br><br>3. Enterprise<br><br>    主要针对企业级账户下准备本地服务器分发的 app。利用的是 Distribution 描述文件，关联 production 证书；<br><br>4. Development<br><br>    保存到本地，给添加了 UDID 的设备使用，开发者模式打包 ipa，通过 development 描述文件，关联 development 证书。<br><br>    <center><br>    <img src="https://upload-images.jianshu.io/upload_images/5294842-1c407b5f2ac4059c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>    <img src="https://upload-images.jianshu.io/upload_images/5294842-5981e6b0bcac4065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>    </center><br><br>5. Rebuild from Bitcode*<em><br><br>    如果工程 Bitcode 为 NO，则不会有此选项。<br><br>6. Strip Swift symbols<br><br>    去除 swift 符号，勾选后会让 ipa 包内存小一些，对包进行了一个压缩。如果项目中未包含 swift 代码，则没有此选项。<br><br>7. Include manifest for over-the-air installation<br><br>    勾选后用户可以在 safari 中下载应用，而不必移步 App Store。<br><br>8. Upload your app’s symbols to receive symbolicated reports from Apple<br><br>    上传应用程序的符号以接收来自苹果的符号化报告。<br><br>    <center><br>    <img src="https://upload-images.jianshu.io/upload_images/5294842-988e01e7cc35ade7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>    </center><br><br>9. 学习文章<br><br>    <a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="noopener">Understanding and Analyzing Application Crash Reports</a><br><br><br>## 四、armv7、armv7s、arm64<br><br>#### 4.1 前言<br><br>ARM 处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于 ARM，在嵌入式系统中应用广泛。<br><br>armv6｜armv7｜armv7s｜arm64 都是 ARM 处理器的指令集，这些指令集都是<font color="#cc0000">向下兼容</font>的，例如 armv7 指令集兼容 armv6，只是使用 armv6 的时候无法发挥出其性能，无法使用 armv7 的新特性，从而会导致程序执行效率没那么高。<br><br>#### 4.2 介绍</em>   armv7｜armv7s｜arm64 都是 ARM 处理器的指令集<br><em>   i386｜x86_64 是 Mac 处理器的指令集<br><br>|:————-:|:————-:|:—–:|<br>|arm64|iPhone6s | iphone6s plus | iPhone6 | iPhone6 plus | iPhone5S | iPad Air | iPad mini2 | 真机 64 位 |<br>|armv7s|iPhone5 | iPhone5C | iPad4|真机 32 位|<br>|armv7|iPhone4|iPhone4S|iPad|iPad2|iPad3|iPad mini|iPod Touch 3G|iPod Touch4|真机 32 位|<br>|i386|针对 intel 通用微处理器 32 位处理器|模拟器 32 位|<br>|x86_64|是针对 x86 架构的 64 位处理器|模拟器 64 位|<br><br>模拟器并不运行 arm 代码，软件会被编译成 x86 可以运行的指令。所以生成静态库时都是会先生成两个 .a，一个是 i386 的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个 .a 合并成一个。<br><br>#### 4.3 Xcode 的指令集选项<br><br>1. Architectures<br><br>    &gt; Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures.<br><br>    指定工程被编译成可支持哪些指令集类型。支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是 ipa 包会变大。<br><br>2. Valid Architectures<br><br>    &gt; Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.<br><br>    限制可能被支持的指令集的范围，也就是 Xcode 编译出来的二进制包类型最终从这些类型产生。而编译出哪种指令集的包，将由Architectures 与 Valid Architectures 的交集来确定。<br><br>    ①、Valid Architectures 支持 arm 指令集版本设置为：armv7/armv7s/arm64，对应的 Architectures 支持 arm 指令集版本为：armv7s，这时 Xcode 只会生成一个 armv7s 指令集的二进制包。<br><br>    ②、将 Architectures 支持 arm 指令集设置为：armv7/armv7s，对应的 Valid Architectures 的支持的指令集设置为：armv7s/arm64，那么此时，XCode 生成二进制包所支持的指令集只有 armv7s。<br><br>3. Build Active Architecture Only<br><br>    指定是否只对当前连接设备所支持的指令集编译。<br><br>    debug 时设置成 YES 是为了编译速度更快，它只编译当前的 architecture 版本；而 release 时设置为 NO 会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如设置为 YES，用 iphone4 编译出来的是 armv7 版本的，iphone5 也可以运行，但是 armv6 的设备就不能运行。  所以，一般 debug 的时候可以选择设置为 YES，release 的时候要改为 NO，以适应不同设备。<br><br>    <center><br>    <img src="http://dzliving.com/iOSArchitecture.png" alt><br>    </center><br><br>如果你对 ipa 安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</em>   $(ARCHS_STANDARD)<br>    默认值，以各版本实际的值为准。XCode5 中值为 armv7 armv7s，在 XCode5.1 时，强制加入了对 arm64 的编译，于是该值为 armv7,armv7s,arm64。当前 Xcode10.1 默认为 Standard architectures(armv7,arm64)。<br><em>   $(ARCHS_STANDARD_32_BIT)<br>    Xcode5 和 5.1 都为 armv7,armv7s，旧一点的版本中应该对应的就只有 armv7。<font color="#cc0000">（待验证）</font></em>   $(ARCHS_STANDARD_INCLUDING_64_BIT)<br>    XCode5 和 5.1 都为 armv7,armv7s,arm64<br><br>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有 32 位、64 位两份代码，在iPhone5s（64 位）下，会首选运行 64 位代码包。包含两种架构的代码包，只有运行在 iOS6、iOS7 系统上。<br><br>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有 32 位代码， iPhone5s 可以兼容 32 位代码，但是这会降低 iPhone5s 的性能。<br><br>开启 arm64 支持后，不能开发 iOS 5.1.1 之前的版本，要强制将 deployment target 设置为 5.1.1 或之后。Xcode4.5 中移除了对 arm6 的支持。<br><br>#### 4.4 查看 .a/framework 库支持的指令集<br><br>通过 lipo 命令查看 .a 库所支持的指令集。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -info AFNetworking</span><br><span class="line">$ lipo -info AFNetworking.framework/AFNetworking</span><br><span class="line">Non-fat file: AFNetworking.framework/AFNetworking is architecture: x86_64</span><br><span class="line">$ lipo -info *.a</span><br><span class="line">Architectures in the fat file: libPods-AFNetworking.a are: armv7 armv7s</span><br><span class="line">Architectures in the fat file: libPods.a are: armv7 armv7s</span><br><span class="line">$ lipo -info libBloodTester.a</span><br><span class="line">Architectures in the fat file: libBloodTester.a are: armv7 i386 x86_64 arm64</span><br></pre></td></tr></table></figure><br><br>#### 4.5 CocoaPods与Architecture<br><br>出现问题 <font color="#cc0000">ld: library not found for -lAFNetworking</font>，需要将 pods 的 Architectures 设置成与工程 targets 里的相同。<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-ac1144fb7f36f684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>#### 4.6 如何选择支持的指令集？<br><br>如果你的软件对安装包大小非常敏感，你可以减少安装包中的指令集数据包，而且这能达到立竿见影的效果。<br><br>很久前 xcode 支持的指令集是 armv7/armv7s，后来改成只支持 armv7 后，比原来小了 10MB 左右。目前 AppStore 上的一些知名应用，比如百度地图、腾讯地图通过反汇编工具查看后，也都只支持 armv7 指令集。<font color="#cc0000">（待验证）</font><p>根据向下兼容原则，armv7 指令集的应用是可以正常在支持 armv7s/arm64 指令集的机器上运行的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、整行上下移动&quot;&gt;&lt;a href=&quot;#一、整行上下移动&quot; class=&quot;headerlink&quot; title=&quot;一、整行上下移动&quot;&gt;&lt;/a&gt;一、整行上下移动&lt;/h2&gt;&lt;p&gt;Xcode 自带的配置文件路径：/Applications/Xcode.app/Conten
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计策略</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/08/06/算法/算法设计策略/</id>
    <published>2019-08-05T16:07:52.660Z</published>
    <updated>2019-08-05T16:07:52.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h2><h4 id="1-1-基本思想"><a href="#1-1-基本思想" class="headerlink" title="1.1 基本思想"></a>1.1 基本思想</h4><blockquote><p>将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，<font color="#cc0000">分而治之</font>。</p></blockquote><p>能用分治法的基本特征：</p><p>①、问题缩小到一定规模容易解决</p><p>②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想）</p><p>③、分解而成的小问题在解决之后要可以合并</p><p>④、子问题是相互独立的，即子问题之间没有公共的子问题</p><font color="#cc0000">第 ③ 条是能分治的关键</font>。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。<br><br>如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。<br><br>分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。<br><br>根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。<br><br>#### 1.2 分治步骤<br><br>①、分解成很多子问题<br><br>②、解决这些子问题<br><br>③、将解决的子问题合并从而解决整个大问题<br><br>化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。<br><br>它的一般的算法设计模式如下：<br><br>Divide-and-Conquer(P)<br><br>1.   if |P|≤n0<br>2.   then return(ADHOC(P))<br>3.   将 P 分解为较小的子问题 P1, P2, …, Pk<br>4.   for i←1 to k<br>5.   do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi<br>6.   T ← MERGE(y1,y2,…,yk) △ 合并子问题<br>7.   return(T)<br><br><br>#### 1.3 分类<br><br>根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形：<br><br>1.   原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可；<br>2.   原始问题的解需要由各个子问题的解再经过综合处理得到。<br><br>#### 1.4 效果<br><br>适当运用分治策略往往可以<font color="#cc0000">较快地缩小问题求解的范围</font>，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。<br><br>分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好<font color="#cc0000">符合递归的特性</font>。<br><br>因此，计算机算法中的分治策略往往与递归联系在一起。<br><br>#### 1.5 算法的典型应用<br><br>    ①、MAXMIN问题<br><br>    ②、二分搜索<br><br>    ③、归并排序<br><br>    ④、寻找第 K 小的元素<br><br>    ⑤、大整数的乘法<br><br>    ⑥、Strassen 矩阵乘法<br><br>    ⑦、快速排序<br><br>    ⑧、二叉树遍历<br><br>    ⑨、棋盘覆盖<br><br>    ⑩、线性时间选择<br><br>最接近点对问题<br><br>循环赛日程表<br><br>汉诺塔。。。<br><br>#### 1.6 依据分治法设计程序时的思维过程<br><br>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。<br><br>①、一定是先找到最小问题规模时的求解方法；<br>②、然后考虑随着问题规模增大时的求解方法；<br>③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。<br><br><br>文章：<a href="https://blog.csdn.net/effective_coder/article/details/8697789" target="_blank" rel="noopener">分治算法详解</a><br><br><br>## 二、减治<br><br>#### 2.1 基本思想<br><br>减治技术利用了一种关系：<font color="#cc0000">一个问题给定实例的解和同样问题较小实例的解之间的关系</font>。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡）<br><br>有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫<font color="#cc0000">增量法</font>。<br><br>一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。<br><br>#### 2.2 分类<br><br>减治法有 3 种主要的变种：<br><br>1.   减去一个常量<br>2.   减去一个常数因子<br>3.   减去的规模是可变的<br><br>#### 2.3 减去一个常量<br><br>每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。<br><br>函数 f(n) = a<sup>n</sup> 可以用一递归定义来计算<br><br>f(n) = f(n-1) * a   <font color="#067500">如果 n &gt; 1</font><p>f(n) = a          <font color="#067500">如果 n = 1</font></p><p>虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！</p><h4 id="2-4-减去常量因子"><a href="#2-4-减去常量因子" class="headerlink" title="2.4 减去常量因子"></a>2.4 减去常量因子</h4><p>每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。</p><p>计算 a<sup>n</sup> 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 a<sup>n/2</sup> 的值；它们之间有着明显的关系： a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>。</p><p>a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>                       n 是正偶数</p><p>a<sup>n</sup> = (a<sup>(n-1)/2</sup>)<sup>2</sup> * a     n 是大于 1 的奇数，先提出一个 a 来再减半</p><p>a<sup>n</sup> = a               n = 1</p><p>上式递归根据所做的乘法次数来度量效率，该算法属于 <font color="#cc0000">O(log n)</font>;</p><p>因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。</p><h4 id="2-5-减可变规模"><a href="#2-5-减可变规模" class="headerlink" title="2.5 减可变规模"></a>2.5 减可变规模</h4><p>每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法</p><h4 id="2-6-算法思想的典型应用"><a href="#2-6-算法思想的典型应用" class="headerlink" title="2.6 算法思想的典型应用"></a>2.6 算法思想的典型应用</h4><p>减去一个常量：</p><pre><code>①、插入排序③、深度优先查找④、广度优先查找⑤、拓扑排序（源删除法对无环有向图进行拓扑排序）⑥、生成排列⑦、生成子集</code></pre><p>减去常量因子：</p><pre><code>①、折半查找②、假币问题③、俄式乘法④、约瑟夫斯问题</code></pre><p>减可变规模</p><pre><code>①、插值查找、二叉查找树②、欧几里得算法，随着不断求余，n 越来越小</code></pre><h2 id="三、分治减治区别"><a href="#三、分治减治区别" class="headerlink" title="三、分治减治区别"></a>三、分治减治区别</h2><p>分治法：求解多个子问题（每个子问题都需要求解），<font color="#cc0000">合并</font>子问题的解。</p><p>减治法：求解一个子问题（子问题只需要求解一次），<font color="#cc0000">扩展</font>子问题的解。</p><p>求 a<sup>n</sup>。</p><p>分治法：a<sup>(n/2)</sup> * a<sup>(n/2)</sup> 则左右两个 a<sup>(n/2)</sup> 均需要求解，所以时间复杂度为 O(n)。<br>减治法：(a<sup>(n/2)</sup>)<sup>2</sup> 则只需要求 a<sup>(n/2)</sup> 再平方即可，所以时间复杂度为 O(lgn)。</p><p>也就是说<strong>分治法</strong>是分解的部分需要进行分开的单独计算（需要计算两遍），而<strong>减治法</strong>则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量<strong>。</strong></p><h2 id="四、变治"><a href="#四、变治" class="headerlink" title="四、变治"></a>四、变治</h2><p>基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据<font color="#cc0000">对问题实例的变换方式</font>，变治思想有 3 种主要类型：</p><ul><li>变换为同样问题的一个更简单或者更方便的实例：<strong>实例化简</strong>；</li><li>变换为同样实例的不同表现：<strong>改变表现</strong>；</li><li>变换为另一个问题的实例， 这种问题的算法是已知的：<strong>问题化简</strong>。</li></ul><p>基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。</p><h4 id="4-1-实例化简"><a href="#4-1-实例化简" class="headerlink" title="4.1 实例化简"></a>4.1 实例化简</h4><pre><code>①、检验数组中元素的唯一性（预排序）②、模式计算（预排序）③、AVL 树</code></pre><h4 id="4-2-改变表现"><a href="#4-2-改变表现" class="headerlink" title="4.2 改变表现"></a>4.2 改变表现</h4><pre><code>①、2-3 树、2-3-4 树（二叉排序树）②、堆和堆排序（利用最大/小堆总是找到最大/小值）③、霍纳法则（多项式的计算）④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组）</code></pre><h4 id="4-3-问题化简"><a href="#4-3-问题化简" class="headerlink" title="4.3 问题化简"></a>4.3 问题化简</h4><pre><code>①、背包问题（线性规划）</code></pre><h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往<font color="#cc0000">不是相互独立的</font>。这种情况下若用分治法会对一些子问题进行<font color="#cc0000">多次求解</font>，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。</p><p>动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质：</p><ol><li><p>最优子结构性质</p><p> 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。</p><p> 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。</p></li><li><p>子问题重叠性质</p><p> 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。</p></li></ol><p>用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法：</p><p>①、自底向上递归法</p><p>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>②、自顶向下递归法（即备忘录法）</p><p>利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。</p><p>当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。</p><p>文章：<a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="noopener">动态规划：从新手到专家</a></p><h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单<font color="#cc0000">更直接效率更高</font>的算法：贪心法。</p><p>贪心法总是做出在<font color="#cc0000">当前</font>看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。</p><p>贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质：</p><ol><li><p>贪心选择性质</p><p> 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。</p><p> 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。</p></li><li><p>最优子结构性质</p><p> 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。</p></li></ol><p>贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。</p><h2 id="七、回溯"><a href="#七、回溯" class="headerlink" title="七、回溯"></a>七、回溯</h2><p>回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。</p><p>回溯法通常的解题步骤如下：</p><p>①、定义问题的解空间。</p><p>②、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。</p><p>③、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。</p><p>用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h)</p><p>用回溯法解题时，常会遇到以下两类典型的解空间树：</p><p>(1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><p>回溯法中的剪枝函数通常分为两类：</p><p>(1)、用约束函数在指定节点处剪去不满足约束的子树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、用限界函数在指定节点处剪去得不到最优解的子树，例如<a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><h2 id="八、分支限界"><a href="#八、分支限界" class="headerlink" title="八、分支限界"></a>八、分支限界</h2><p>回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。</p><p>分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。</p><h2 id="九、学习文章"><a href="#九、学习文章" class="headerlink" title="九、学习文章"></a>九、学习文章</h2><p><a href="https://www.cnblogs.com/laifeiyao/" target="_blank" rel="noopener">姚来飞的博客</a> &amp; <a href="https://www.cnblogs.com/laifeiyao/p/3476258.html" target="_blank" rel="noopener">常见的算法设计策略</a></p><p><a href="https://www.cnblogs.com/lsgxeva/p/7800564.html" target="_blank" rel="noopener">算法设计之五大常用算法设计方法总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、分治&quot;&gt;&lt;a href=&quot;#一、分治&quot; class=&quot;headerlink&quot; title=&quot;一、分治&quot;&gt;&lt;/a&gt;一、分治&lt;/h2&gt;&lt;h4 id=&quot;1-1-基本思想&quot;&gt;&lt;a href=&quot;#1-1-基本思想&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>重构 AppDelegate</title>
    <link href="http://yoursite.com/2019/08/06/iOS/iOS%E4%BC%98%E5%8C%96/%E9%87%8D%E6%9E%84AppDelegate/"/>
    <id>http://yoursite.com/2019/08/06/iOS/iOS优化/重构AppDelegate/</id>
    <published>2019-08-05T16:07:52.660Z</published>
    <updated>2019-08-05T16:07:52.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Massive-AppDelegate"><a href="#一、Massive-AppDelegate" class="headerlink" title="一、Massive AppDelegate"></a>一、Massive AppDelegate</h2><blockquote><p>AppDelegate 是应用程序的根对象，<font color="#cc0000">它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互</font>，通常被认为是每个 iOS 项目的核心。</p></blockquote><p>随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。</p><p>在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的<font color="#cc0000">简洁和清晰</font>对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。</p><p>AppDelegate 常见的业务代码如下：</p><ul><li>日志埋点统计数据分析</li><li>初始化数据存储系统</li><li>配置 UIAppearance</li><li>管理 App Badge 数字</li><li>管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分</li><li>管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换</li><li>管理 UserDefaults：设置首先启动标志，保存和加载数据</li><li>管理后台任务</li><li>管理设备方向</li><li>更新位置信息</li><li>初始化第三方库（如分享、日志、第三方登陆、支付）</li></ul><p>这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。</p><p>看看以下可能的解决方案，每个 Recipe（方案）<font color="#cc0000">遵循单一职责、易于扩展、易于测试原则</font>。</p><h2 id="二、命令模式-Command-Design-Pattern"><a href="#二、命令模式-Command-Design-Pattern" class="headerlink" title="二、命令模式 Command Design Pattern"></a>二、命令模式 Command Design Pattern</h2><blockquote><p>命令模式是一种数据驱动的设计模式，属于行为型模式。</p></blockquote><p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。</p><p>可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 命令协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Command</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)execute;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeThirdPartiesCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化主视图</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeRootViewControllerCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWindow</span> * keyWindow;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化视图全局配置</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeAppearanceCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// ...</span></span><br></pre></td></tr></table></figure><p>然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StartupCommandsBuilder</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组，元素为遵守 Command 协议的对象</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;Command&gt;&gt; *)build</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @[ [InitializeAppearanceCommand new], </span><br><span class="line">              [InitializeRootViewControllerCommand new], </span><br><span class="line">              [InitializeThirdPartiesCommand new] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;    </span><br><span class="line">    [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(<span class="keyword">id</span>&lt;Command&gt; _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [obj execute];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="三、组合设计模式-Composite-Design-Pattern"><a href="#三、组合设计模式-Composite-Design-Pattern" class="headerlink" title="三、组合设计模式 Composite Design Pattern"></a>三、组合设计模式 Composite Design Pattern</h2><blockquote><p>组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。</p></blockquote><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于<font color="#cc0000">结构型模式</font>，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。</p><p>这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 组装类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CompositeAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CompositeAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里要实现单例</span></span><br><span class="line">    <span class="keyword">return</span> [[CompositeAppDelegate alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现执行具体职责的叶子类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 叶子类。推送消息处理</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushNotificationAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 叶子类。初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PushNotificationAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"PushNotificationAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ThirdPartiesConfiguratorAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="四、中介者模式-Mediator-Design-Pattern"><a href="#四、中介者模式-Mediator-Design-Pattern" class="headerlink" title="四、中介者模式 Mediator Design Pattern"></a>四、中介者模式 Mediator Design Pattern</h2><blockquote><p>中介者模式是用来降低多个对象和类之间的通信复杂性。</p></blockquote><p>这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于<font color="#cc0000">行为型模式</font>。</p><p>如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。</p><p>让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">APPLifeCycleMediator</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">APPLifeCycleMediator</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; * _listeners;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithListeners:(<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; *)listeners</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        _listeners = listeners;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppWillEnterForeground)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillEnterForegroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidEnterBackgroud)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidFinishLaunching)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义好静态类方法，初始化所有监听者</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> APPLifeCycleMediator * mediator;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">1</span>] onAppWillEnterForeground];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">0</span>] onAppDidEnterBackgroud];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>定义 AppLifecycleListener 协议，以及协议的的实现者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 监听协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AppLifeCycleListener</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VideoListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SocketListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VideoListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"停止视频播放"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SocketListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开启长链接"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>加入到 AppDelegate 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [APPLifeCycleMediator makeDefaultMediator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。</p><p>通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。</p><p>这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247484070&amp;idx=1&amp;sn=8f784d2931c90bbc10c1d07bb634f01d&amp;chksm=a6f95840918ed156b8333751242eab54caacc5502af2e177018f0fc9df8f8955cee36e92eaf8&amp;mpshare=1&amp;scene=23&amp;srcid=1201w1cWjo0tBpIGir7EcNQD#rd" target="_blank" rel="noopener">最佳实践：重构AppDelegate</a></p><p><a href="https://www.vadimbulavin.com/refactoring-massive-app-delegate/" target="_blank" rel="noopener">Refactoring Massive App Delegate</a></p><p><a href="https://github.com/GesanTung/iOSTips" target="_blank" rel="noopener">iOSTips</a></p><p>OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》</p><p> Swift 设计模式：《<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247483977&amp;idx=1&amp;sn=5994f8456884df158e7263be8179b79f&amp;chksm=a6f958af918ed1b92625986d22a19e7ddaf85367386b9edf19b93e8ce836f83e0c5556997d13&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Design_Patterns_by_Tutorials_v0.9.1</a>》</p><p>重构：《重构改善既有代码的设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Massive-AppDelegate&quot;&gt;&lt;a href=&quot;#一、Massive-AppDelegate&quot; class=&quot;headerlink&quot; title=&quot;一、Massive AppDelegate&quot;&gt;&lt;/a&gt;一、Massive AppDelegate&lt;/
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
</feed>
