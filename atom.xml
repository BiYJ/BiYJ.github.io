<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T06:31:14.236Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Push</title>
    <link href="http://yoursite.com/2019/05/22/iOS%20Push/"/>
    <id>http://yoursite.com/2019/05/22/iOS Push/</id>
    <published>2019-05-22T06:31:14.236Z</published>
    <updated>2019-05-22T06:31:14.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。</p><h2 id="2、push流程"><a href="#2、push流程" class="headerlink" title="2、push流程"></a>2、push流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-80bb8c98fe99de60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt></p><p>Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。</p><p>上图可以分为三个阶段：<br>①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。<br>②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。<br>③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b049ae989bfc6221.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="APNs流程图"></p><p>从上图可以看到：</p><p>①、在程序上注册远程通知，这是通知的前提（程序员的工作）；<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"> &#123; </span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotificationTypes:<span class="built_in">UIRemoteNotificationTypeAlert</span> | <span class="built_in">UIRemoteNotificationTypeBadge</span> | <span class="built_in">UIRemoteNotificationTypeSound</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；<br>③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    <span class="comment">//注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做）</span></span><br><span class="line">    self.deviceToken = [[[[devToken description]</span><br><span class="line"><span class="symbol">                          stringByReplacingOccurrencesOfString:</span>@<span class="string">"&lt;"</span>withString:@<span class="string">""</span>]</span><br><span class="line"><span class="symbol">                         stringByReplacingOccurrencesOfString:</span>@<span class="string">"&gt;"</span> withString:@<span class="string">""</span>]</span><br><span class="line"><span class="symbol">                        stringByReplacingOccurrencesOfString:</span> @<span class="string">" "</span> withString: @<span class="string">""</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送</span></span><br><span class="line">    [JPUSHService registerDeviceToken:devToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>④、将这个 token 值发送到公司的服务器上去，存储下来。<br>⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。</p><h2 id="3、APNs的限制"><a href="#3、APNs的限制" class="headerlink" title="3、APNs的限制"></a>3、APNs的限制</h2><p>APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： </p><p><strong>可靠性</strong>。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 </p><p><strong>Payload Size</strong>。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 </p><p><strong>成功率并不高</strong>。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 </p><p>理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。</p><h2 id="4、不仅仅是Local-Push"><a href="#4、不仅仅是Local-Push" class="headerlink" title="4、不仅仅是Local Push"></a>4、不仅仅是Local Push</h2><p>很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。</p><p>Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。</p><h2 id="5、叫醒你的App"><a href="#5、叫醒你的App" class="headerlink" title="5、叫醒你的App"></a>5、叫醒你的App</h2><p>开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。</p><p>唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。</p><h2 id="6、前台消息通道"><a href="#6、前台消息通道" class="headerlink" title="6、前台消息通道"></a>6、前台消息通道</h2><p>大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 10 Support</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">jpushNotificationCenter</span><span class="selector-pseudo">:(UNUserNotificationCenter</span> *)<span class="selector-tag">center</span> <span class="selector-tag">didReceiveNotificationResponse</span><span class="selector-pseudo">:(UNNotificationResponse</span> *)<span class="selector-tag">response</span> <span class="selector-tag">withCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)())<span class="selector-tag">completionHandler</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">didReceiveRemoteNotification</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">userInfo</span> <span class="selector-tag">fetchCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UIBackgroundFetchResult result))<span class="selector-tag">completionHandler</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。</p><h2 id="7、PushKit"><a href="#7、PushKit" class="headerlink" title="7、PushKit"></a>7、PushKit</h2><p>APNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。</p><p>之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。</p><p>当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。</p><p>微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。</p><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。</p><h2 id="9、学习文章"><a href="#9、学习文章" class="headerlink" title="9、学习文章"></a>9、学习文章</h2><p><a href="http://mrpeak.cn/" target="_blank" rel="noopener">MrPeak杂货铺</a> &amp; <a href="http://mrpeak.cn/ios/2016/01/06/push" target="_blank" rel="noopener">iOS Push的门道</a><br><a href="http://hayageek.com/ios-silent-push-notifications" target="_blank" rel="noopener">Silent Push实现</a><br><a href="https://zeropush.com/guide/guide-to-pushkit-and-voip" target="_blank" rel="noopener">PushKit实现</a><br><a href="https://blog.csdn.net/zhugq_1988/article/details/37656107" target="_blank" rel="noopener">APNS推送服务证书制作 图文详解教程</a><br><a href="https://blog.csdn.net/zm53373581/article/details/49735329?locationNum=2&amp;fps=1" target="_blank" rel="noopener">APNS远程推送证书的申请和制作——详细解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 时间</title>
    <link href="http://yoursite.com/2019/05/21/iOS%20%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2019/05/21/iOS 时间/</id>
    <published>2019-05-21T08:15:20.020Z</published>
    <updated>2019-05-21T10:58:38.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、时间的形式"><a href="#1、时间的形式" class="headerlink" title="1、时间的形式"></a>1、时间的形式</h2><p>在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。</p><h3 id="1-1、GMT"><a href="#1-1、GMT" class="headerlink" title="1.1、GMT"></a>1.1、GMT</h3><p>人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。</p><p>前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。</p><h3 id="1-2、UTC"><a href="#1-2、UTC" class="headerlink" title="1.2、UTC"></a>1.2、UTC</h3><p>太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。</p><p>我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。</p><p>接下来看下iOS里，五花八门的记录时间的方式。</p><h2 id="2、NSDate"><a href="#2、NSDate" class="headerlink" title="2、NSDate"></a>2、NSDate</h2><p>NSDate是我们平时使用较多的一个类，先看下它的定义：</p><blockquote><p>NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001).</p></blockquote><p>NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。</p><p>这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。</p><p>理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="keyword">date</span> = [NSDate <span class="keyword">date</span>];</span><br><span class="line">NSLog(@"current <span class="keyword">date</span> interval: %f<span class="string">", [date timeIntervalSinceReferenceDate]);</span></span><br></pre></td></tr></table></figure></p><p>timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。</p><p>又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="keyword">date</span> = [NSDate <span class="keyword">date</span>];</span><br><span class="line">NSLog(@"current <span class="keyword">date</span>: %@<span class="string">", date);</span></span><br></pre></td></tr></table></figure></p><p>current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。</p><p>NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。</p><p>另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。</p><h2 id="3、CFAbsoluteTimeGetCurrent"><a href="#3、CFAbsoluteTimeGetCurrent" class="headerlink" title="3、CFAbsoluteTimeGetCurrent()"></a>3、CFAbsoluteTimeGetCurrent()</h2><p>官方定义如下：</p><blockquote><p>Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock.</p></blockquote><p>从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。</p><p>同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。</p><h2 id="4、gettimeofday"><a href="#4、gettimeofday" class="headerlink" title="4、gettimeofday"></a>4、gettimeofday</h2><p>这个API也能返回一个描述当前时间的值，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">gettimeofday(&amp;now, &amp;tz);</span><br><span class="line">NSLog(@<span class="string">"gettimeofday: %ld"</span>, now.tv_sec);</span><br></pre></td></tr></table></figure></p><p>使用gettimeofday获得的值是Unix time。Unix time又是什么呢？</p><p>Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。</p><p>Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -r <span class="number">1481266031</span></span><br></pre></td></tr></table></figure></p><p>实际上NSDate也有一个API能返回Unix time：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="built_in">date</span> = [NSDate <span class="built_in">date</span>];</span><br><span class="line">NSLog(@<span class="string">"timeIntervalSince1970: %f"</span>, [<span class="built_in">date</span> timeIntervalSince1970]);</span><br></pre></td></tr></table></figure></p><p>gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。</p><h2 id="5、mach-absolute-time"><a href="#5、mach-absolute-time" class="headerlink" title="5、mach_absolute_time()"></a>5、mach_absolute_time()</h2><p>mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。</p><p>前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。</p><p>不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。</p><p>mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。</p><h2 id="6、CACurrentMediaTime"><a href="#6、CACurrentMediaTime" class="headerlink" title="6、CACurrentMediaTime()"></a>6、CACurrentMediaTime()</h2><p>CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current CoreAnimation absolute time. This is the result of</span></span><br><span class="line"><span class="comment"> * calling mach_absolute_time () and converting the units to seconds. */</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> <span class="built_in">CACurrentMediaTime</span> (<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure></p><p>CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> mediaTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CACurrentMediaTime: %f"</span>, mediaTime);</span><br></pre></td></tr></table></figure></p><p>返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> systemUptime = [[<span class="built_in">NSProcessInfo</span> processInfo] systemUptime];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"systemUptime: %f"</span>, systemUptime);</span><br></pre></td></tr></table></figure></p><p>CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。</p><h2 id="7、sysctl"><a href="#7、sysctl" class="headerlink" title="7、sysctl"></a>7、sysctl</h2><p>iOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">long</span>)bootTime</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIB_SIZE 2</span></span><br><span class="line">    <span class="keyword">int</span> mib[MIB_SIZE];</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  <span class="title">boottime</span>;</span></span><br><span class="line">    </span><br><span class="line">    mib[<span class="number">0</span>] = CTL_KERN;</span><br><span class="line">    mib[<span class="number">1</span>] = KERN_BOOTTIME;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(boottime);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> boottime.tv_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回的值是上次设备重启的Unix time。</p><p>这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。</p><p>有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。</p><h2 id="8、场景一，时间测量"><a href="#8、场景一，时间测量" class="headerlink" title="8、场景一，时间测量"></a>8、场景一，时间测量</h2><p>我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。</p><p>在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。</p><p>客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。</p><p>上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">double</span> avgCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i ++) &#123;</span><br><span class="line">    <span class="built_in">NSDate</span>* begin = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a meaningless log"</span>);</span><br><span class="line">    avgCost += -[begin timeIntervalSinceNow];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"benchmark with NSDate: %f"</span>, avgCost/testCount);</span><br><span class="line"></span><br><span class="line">avgCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i ++) &#123;</span><br><span class="line">    <span class="keyword">double</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a meaningless log"</span>);</span><br><span class="line">    <span class="keyword">double</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    avgCost += (endTime - startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"benchmark with CACurrentMediaTime: %f"</span>, avgCost/testCount);</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">benchmark</span> <span class="keyword">with</span> NSDate: <span class="number">0.000046</span></span><br><span class="line"><span class="built_in">benchmark</span> <span class="keyword">with</span> CACurrentMediaTime: <span class="number">0.000037</span></span><br></pre></td></tr></table></figure></p><p>可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK   NSDate *startTime = [NSDate date]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOCK   NSLog(@<span class="meta-string">"Time Cost: %f"</span>, -[startTime timeIntervalSinceNow])</span></span><br></pre></td></tr></table></figure></p><h2 id="9、场景二：客户端和服务器之间的时间同步"><a href="#9、场景二：客户端和服务器之间的时间同步" class="headerlink" title="9、场景二：客户端和服务器之间的时间同步"></a>9、场景二：客户端和服务器之间的时间同步</h2><p>这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。</p><p>比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？</p><p>上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。</p><p>首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">uint64_t</span> realLocalTime = <span class="number">0</span>;</span><br><span class="line"><span class="attribute">if</span> (serverTime != <span class="number">0</span> &amp;&amp; <span class="literal">last</span>SyncLocalTime != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="attribute">realLocalTime</span> = serverTime + (curLocalTime - <span class="literal">last</span>SyncLocalTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">else</span> &#123;</span><br><span class="line">    <span class="attribute">realLocalTime</span> = [[NSDate date] timeIntervalSince1970]*<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。</p><p>关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get system uptime since last boot</span></span><br><span class="line">- (NSTimeInterval)uptime</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">boottime</span>;</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>] = &#123;CTL_KERN, KERN_BOOTTIME&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(boottime);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    gettimeofday(&amp;now, &amp;tz);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> uptime = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;boottime, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span> &amp;&amp; boottime.tv_sec != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uptime = now.tv_sec - boottime.tv_sec;</span><br><span class="line">        uptime += (<span class="keyword">double</span>)(now.tv_usec - boottime.tv_usec) / <span class="number">1000000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uptime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。</p><p>多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。</p><h2 id="10、学习文章"><a href="#10、学习文章" class="headerlink" title="10、学习文章"></a>10、学习文章</h2><p><a href="http://mrpeak.cn/blog/ios-time/" target="_blank" rel="noopener">MrPeak杂货铺</a><br><a href="http://www.cocoachina.com/ios/20180911/24870.html" target="_blank" rel="noopener">iOS倒计时的探究与选择</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、时间的形式&quot;&gt;&lt;a href=&quot;#1、时间的形式&quot; class=&quot;headerlink&quot; title=&quot;1、时间的形式&quot;&gt;&lt;/a&gt;1、时间的形式&lt;/h2&gt;&lt;p&gt;在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+pages建站</title>
    <link href="http://yoursite.com/2019/05/14/hexo+pages%E5%BB%BA%E7%AB%99/"/>
    <id>http://yoursite.com/2019/05/14/hexo+pages建站/</id>
    <published>2019-05-14T07:42:50.947Z</published>
    <updated>2019-05-22T03:54:40.187Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a></p><p><a href="https://blog.csdn.net/Greenovia/article/details/60576985" target="_blank" rel="noopener">解决用Hexo和GitHub搭建博客时hexo d命令报错问题</a></p><p><a href="https://blog.csdn.net/weixin_36401046/article/details/52940313" target="_blank" rel="noopener">hexo d后 ERROR Deployer not found: git</a></p><p><a href="https://www.cnblogs.com/ldq2016/p/7418206.html" target="_blank" rel="noopener">git-ssh 配置和使用</a></p><p><a href="https://www.jianshu.com/p/c08f4e8127a5" target="_blank" rel="noopener">给博客添加文章目录</a></p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p><a href="https://www.jianshu.com/p/0558c041e56d" target="_blank" rel="noopener">Hexo博客多台电脑设备同步管理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_37781304/article/details/82729029&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo史上最全搭建教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
  </entry>
  
</feed>
