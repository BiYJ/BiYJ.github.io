<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-11T11:56:08.758Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 页面流畅技巧</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%95%85%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/05/23/iOS 页面流畅技巧/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-11T11:56:08.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、屏幕显示图像原理"><a href="#一、屏幕显示图像原理" class="headerlink" title="一、屏幕显示图像原理"></a>一、屏幕显示图像原理</h2><p>首先明确两个概念：水平同步信号、垂直同步信号。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-920b300dcddfb38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。</p><p>CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1cc88c02ec5e957b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="二、卡顿产生的原因"><a href="#二、卡顿产生的原因" class="headerlink" title="二、卡顿产生的原因"></a>二、卡顿产生的原因</h2><p><font color="#cc0000">如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃</font>，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。</p><h2 id="三、CPU-资源消耗的原因和解决方案"><a href="#三、CPU-资源消耗的原因和解决方案" class="headerlink" title="三、CPU 资源消耗的原因和解决方案"></a>三、CPU 资源消耗的原因和解决方案</h2><h4 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h4><p>对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以：</p><p>①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适；</p><p>②、如果对象不涉及 UI 操作，尽量放到后台线程去创建；</p><p>③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用；</p><p>④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去；</p><p>⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p><h4 id="3-2-对象调整"><a href="#3-2-对象调整" class="headerlink" title="3.2 对象调整"></a>3.2 对象调整</h4><p>对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer：</p><p>①、CALayer 内部没有属性，当调用属性方法时，它内部是<font colro="#cc0000">通过运行时</font> resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源；</p><p>②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改；</p><p>③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><h4 id="3-3-对象销毁"><a href="#3-3-对象销毁" class="headerlink" title="3.3 对象销毁"></a>3.3 对象销毁</h4><p>当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * tmp = <span class="keyword">self</span>.arr_data;</span><br><span class="line"><span class="keyword">self</span>.arr_data = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-4-对象布局"><a href="#3-4-对象布局" class="headerlink" title="3.4 对象布局"></a>3.4 对象布局</h4><p>在后台线程提前计算好视图布局、并对视图的布局进行缓存。</p><p>不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。</p><h4 id="3-5-Autolayout"><a href="#3-5-Autolayout" class="headerlink" title="3.5 Autolayout"></a>3.5 Autolayout</h4><p>这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但<font color="#cc0000">对于复杂视图来说常会产生严重的性能问题</font>。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。</p><h4 id="3-6-文本计算"><a href="#3-6-文本计算" class="headerlink" title="3.6 文本计算"></a>3.6 文本计算</h4><p>如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。</p><h4 id="3-7-文本渲染"><a href="#3-7-文本渲染" class="headerlink" title="3.7 文本渲染"></a>3.7 文本渲染</h4><p>屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。</p><p>显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，<font color="#cc0000">用 TextKit 或最底层的 CoreText 对文本异步绘制</font>，尽管麻烦但优势强大：</p><p>①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；</p><p>②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。</p><h4 id="3-8-图片解码"><a href="#3-8-图片解码" class="headerlink" title="3.8 图片解码"></a>3.8 图片解码</h4><p>用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。</p><p>该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是<font color="#cc0000">在后台线程先把图片绘制到 CGBitmapContext 中</font>，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><h4 id="3-9-图像的绘制"><a href="#3-9-图像的绘制" class="headerlink" title="3.9 图像的绘制"></a>3.9 图像的绘制</h4><p>是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、GPU-资源消耗原因和解决方案"><a href="#四、GPU-资源消耗原因和解决方案" class="headerlink" title="四、GPU 资源消耗原因和解决方案"></a>四、GPU 资源消耗原因和解决方案</h2><p>GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。</p><h4 id="4-1-纹理的渲染"><a href="#4-1-纹理的渲染" class="headerlink" title="4.1 纹理的渲染"></a>4.1 纹理的渲染</h4><p>所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。</p><p>当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。</p><p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。</p><h4 id="4-2-视图的混合（Composing）"><a href="#4-2-视图的混合（Composing）" class="headerlink" title="4.2 视图的混合（Composing）"></a>4.2 视图的混合（Composing）</h4><p>当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。</p><p>所以应当<font color="#cc0000">尽量减少视图数量和层次</font>，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。</p><p>也可以把多个视图预先渲染为一张图片来显示。</p><h4 id="4-3-图形的生成"><a href="#4-3-图形的生成" class="headerlink" title="4.3 图形的生成"></a>4.3 图形的生成</h4><p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。</p><p>当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。</p><p>对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。</p><p>最彻底的做法：<font color="#cc0000">把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性</font>。</p><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.jianshu.com/u/93bd6c9bc835" target="_blank" rel="noopener">幸运的芳1990</a> &amp; <a href="https://www.jianshu.com/p/bade6ce45b8b" target="_blank" rel="noopener">浅谈iOS页面流畅技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、屏幕显示图像原理&quot;&gt;&lt;a href=&quot;#一、屏幕显示图像原理&quot; class=&quot;headerlink&quot; title=&quot;一、屏幕显示图像原理&quot;&gt;&lt;/a&gt;一、屏幕显示图像原理&lt;/h2&gt;&lt;p&gt;首先明确两个概念：水平同步信号、垂直同步信号。&lt;/p&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 响应链</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>http://yoursite.com/2019/05/23/iOS 响应链/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T03:41:49.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、UIResponder"><a href="#一、UIResponder" class="headerlink" title="一、UIResponder"></a>一、UIResponder</h2><blockquote><p>app 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。</p></blockquote><p>UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。</p><p>响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。</p><p>有时候可能会通过 UIResponder 来查找控件的父视图。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过遍历 UIView 上的响应链来查找当前顶部 vc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)firstVC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> * next = <span class="keyword">self</span>; next; next = next.superview) &#123;</span><br><span class="line">        <span class="built_in">UIResponder</span> * nextResponder = [next nextResponder];</span><br><span class="line">        <span class="keyword">if</span> ([nextResponder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)nextResponder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过遍历 button 上的响应链来查找 cell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (MyCell *)buttonTaped:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIResponder</span> * responder = button.nextResponder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([responder isKindOfClass:[MyCell <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            MyCell * cell = (MyCell *)responder;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responder = responder.nextResponder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、事件的第一响应者"><a href="#二、事件的第一响应者" class="headerlink" title="二、事件的第一响应者"></a>二、事件的第一响应者</h2><p>事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。</p><ul><li><p>Touch event 第一响应者是触摸事件产生的 view</p></li><li><p>Press event 第一响应者是焦点响应者。</p></li><li><p>Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象</p></li></ul><p>⚠️注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。</p><p>控件直接与它相关的 target 对象使用 action 消息通信。</p><p>当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。</p><p>如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。</p><h2 id="三、事件的分发和传递"><a href="#三、事件的分发和传递" class="headerlink" title="三、事件的分发和传递"></a>三、事件的分发和传递</h2><ol><li>当iOS程序中发生触摸事件后，系统会<font color="#cc0000">将事件加入到 UIApplication 管理的一个任务队列</font>中；</li><li>UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。</li><li>UIWindow 将事件向下分发，即 UIView。</li><li>UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。</li><li>遍历子控件，重复以上两步。</li><li>如果没有找到，那么自己就是事件处理者。</li><li>如果自己不能处理，那么不做任何处理。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ec30446fe33b1976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其中 UIView <font color="#cc0000">不接受事件处理</font>的情况主要有以下三种</p><ol><li>alpha &lt; 0.01</li><li>userInteractionEnabled = NO</li><li>hidden ＝ YES</li></ol><p>这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果<font color="#cc0000">父视图不接受事件处理，那么子视图也不能接收事件</font>。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。</p><h2 id="四、hitTest-withEvent"><a href="#四、hitTest-withEvent" class="headerlink" title="四、hitTest:withEvent:"></a>四、hitTest:withEvent:</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return 本次点击事件需要的最佳 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><p>UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。</p><p>⚠️注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。</p><p>当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-bff8ab2f91a231b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。</p><blockquote><p>如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢?</p></blockquote><p>事件传递给窗口或控件的后，就调用 <font color="#cc0000">hitTest:withEvent:</font> 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到<font color="#cc0000">找到最合适的 view 或者废弃事件</font>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ①、判断当前控件能否接收事件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ②、判断触摸点在不在当前控件内</span></span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ②、倒序遍历自己的子控件</span></span><br><span class="line">   <span class="built_in">NSInteger</span> count = <span class="keyword">self</span>.subviews.count;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">UIView</span> * childView = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">       <span class="comment">// 把当前控件上的坐标系转换成子控件上的坐标系</span></span><br><span class="line">       <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line"></span><br><span class="line">       <span class="built_in">UIView</span> * fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (fitView) &#123; </span><br><span class="line">           <span class="keyword">return</span> fitView;  <span class="comment">// 找到了最合适的 view</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 循环结束，表示没有比自己更合适的 view</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。</p></li><li><p><font color="#cc0000">从后往前遍历</font>子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f9515b7b8aab8425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。</p><p>如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。</p><p>如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。</p><p>如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。</p><p>如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。</p><h2 id="四、pointInside-withEvent"><a href="#四、pointInside-withEvent" class="headerlink" title="四、pointInside:withEvent:"></a>四、pointInside:withEvent:</h2><p>1、判断触摸点是否在视图内。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  判断一个点是否落在范围内</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><p>如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢?</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-df8b1e917c015d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>扩大响应范围。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and decrease its size by `(2*dx, 2*dy)'. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">       CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bounds = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-10</span>, <span class="number">-10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不规则的点击区域</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  改变图片的点击范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 控件范围宽度 +40，高度 +40</span></span><br><span class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-20</span>, <span class="number">-20</span>);</span><br><span class="line">    <span class="built_in">UIBezierPath</span> * path1 = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">-20</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">120</span>)];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> * path2 = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.frame.size.width - <span class="number">20</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">120</span>)];</span><br><span class="line">    <span class="keyword">if</span> (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; <span class="built_in">CGRectContainsPoint</span>(bounds, point))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;  <span class="comment">// 如果在 path 区域内返回 YES</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：</p><ol><li><p>在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。</p></li><li><p>不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。</p></li><li>在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。</li></ol><h2 id="五、响应者链"><a href="#五、响应者链" class="headerlink" title="五、响应者链"></a>五、响应者链</h2><p>响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。</p><p>在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。</p><p>1、改变响应链</p><p>可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。</p><ul><li><p>UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。</p></li><li><p>UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。</p><p>-UIWindow 下一个响应者为 UIApplication 对象。</p></li><li><p>UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。</p></li></ul><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc" target="_blank" rel="noopener">Using Responders and the Responder Chain to Handle Events</a></p><p><a href="http://www.cocoachina.com/ios/20160113/14896.html" target="_blank" rel="noopener">iOS开发 - 事件传递响应链</a></p><p><a href="https://www.jianshu.com/p/4155c9ffe1a8" target="_blank" rel="noopener">iOS响应链（Responder Chain）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、UIResponder&quot;&gt;&lt;a href=&quot;#一、UIResponder&quot; class=&quot;headerlink&quot; title=&quot;一、UIResponder&quot;&gt;&lt;/a&gt;一、UIResponder&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;app 使用响应者对象接收
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>isa 和 Class</title>
    <link href="http://yoursite.com/2019/05/23/isa%20%E5%92%8C%20Class/"/>
    <id>http://yoursite.com/2019/05/23/isa 和 Class/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T05:56:46.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Runtime-简介"><a href="#一、Runtime-简介" class="headerlink" title="一、Runtime 简介"></a>一、Runtime 简介</h2><p>Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，<font color="#cc0000">在编译阶段只是确定了要向接收者发送这条消息</font>，而接受者将要如何响应和处理这条消息，那就要由运行时来决定了。</p><p>C 语言中，函数的调用在编译期就会决定调用哪个函数。而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。</p><p>Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。</p><p>Objc 在三种层面上与 Runtime 系统进行交互：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b4ed02142f8f97fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p>1、通过 Objective-C 源代码</p><p>一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。</p><p>2、通过 Foundation 框架的 NSObject 类定义的方法</p><p>在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。</p><p>在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回对象的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (Class)<span class="keyword">class</span> OBJC_SWIFT_UNAVAILABLE(<span class="string">"use 'anObject.dynamicType' instead"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否是某个类的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象能否响应指定的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否实现了指定协议类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>在 NSObject 的类中还定义了一个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定方法实现的地址 IMP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (IMP)methodForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>3、通过对 Runtime 库函数的直接调用</p><p>关于库函数可以在 <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">Objective-C Runtime Reference</a> 中查看 Runtime 函数的详细文档。</p><p>关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。</p><p>具体设置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-4a2ea408888ae8cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt></p><p>如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。</p><h2 id="二、NSObject-起源"><a href="#二、NSObject-起源" class="headerlink" title="二、NSObject 起源"></a>二、NSObject 起源</h2><p>与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自<a href="https://link.jianshu.com?t=http://opensource.apple.com//source/objc4/" target="_blank" rel="noopener">objc4-680</a></p><p>NSObject 的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Objc2.0 之前，objc_class 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;  <span class="comment">// 指向成员变量列表的指针</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;  <span class="comment">// 指向方法列表指针的指针</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。</p><p>动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。</p><p>关于 Category，推荐 2 篇文章可以仔细研读：<a href="https://link.jianshu.com?t=http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>、<a href="https://link.jianshu.com?t=https://bestswifter.com/jie-he-category-gong-zuo-yuan-li-fen-xi-oc2-0-zhong-de-runtime/" target="_blank" rel="noopener">结合 Category 工作原理分析 OC2.0 中的 runtime</a></p><p>然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 <a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/objc-private.h.auto.html" target="_blank" rel="noopener">objc_private</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Object</span> </span>&#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1194012-06a854913380136c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/956/format/webp" alt></p><p>把源码的定义转化成类图，就是上图的样子。</p><p>从上述源码中，我们可以看到，<font color="#cc0000">Objective-C 对象都是 C 语言结构体实现的</font>，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。</p><p>objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。</p><p>objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论：</p><blockquote><p><font color="#cc0000">Objective-C 中类也是一个对象</font>。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。</p></blockquote><p>object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。</p><h4 id="2-1-isa"><a href="#2-1-isa" class="headerlink" title="2.1 isa"></a>2.1 isa</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line"><span class="meta"># if __arm64__</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;  <span class="comment">// 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化  </span></span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否有设置过关联对象，如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否有被弱引用指向过，如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中</span></span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>; <span class="comment">// 里面存储的值是引用计数 - 1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># elif __x86_64__</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;  </span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># else</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012581760/article/details/81230721" target="_blank" rel="noopener">isa 详解</a></p><p>在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 <font color="#cc0000">64</font> 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。</p><p>当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。</p><p>但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 <a href="https://link.jianshu.com?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p><p>在引入元类之后，类对象和对象查找方法的机制就完全统一了。</p><blockquote><p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</p><p>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p></blockquote><p>meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。</p><p>对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-d7b097e86f9e488d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt></p><p>实线是 super_class 指针，虚线是 isa 指针。</p><ol><li><p>Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。</p></li><li><p>每个 Class 都有一个 isa 指针指向唯一的 Meta class</p></li><li><p>Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。</p></li><li><p>每个 Meta class 的 isa 指针都指向 Root class（meta）。</p></li></ol><p>我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 <a href="https://link.jianshu.com?t=http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">iOS 程序 main 函数之前发生了什么</a></p><h6 id="2-1-1-isa-t-结构体的具体实现"><a href="#2-1-1-isa-t-结构体的具体实现" class="headerlink" title="2.1.1 isa_t 结构体的具体实现"></a>2.1.1 isa_t 结构体的具体实现</h6><p>接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="keyword">void</span> initIsa(Class cls <span class="comment">/*indexed=false*/</span>);</span><br><span class="line">    <span class="keyword">void</span> initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor);</span><br><span class="line">private:</span><br><span class="line">    <span class="keyword">void</span> initIsa(Class newCls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor);</span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 <a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/objc-object.h.auto.html" target="_blank" rel="noopener">objc_object</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># if __arm64__</span></span><br><span class="line"><span class="meta">#   define ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       define RC_ONE   (1ULL<span class="meta-string">&lt;&lt;45)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_HALF  (1ULL&lt;&lt;18)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"># elif __x86_64__</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MASK        0x00007ffffffffff8ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    struct &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t indexed           : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_assoc         : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_cxx_dtor      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t magic             : 6;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t weakly_referenced : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t deallocating      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_sidetable_rc  : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t extra_rc          : 8;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_ONE   (1ULL&lt;&lt;56)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_HALF  (1ULL&lt;&lt;7)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1194012-2f2760cc2bc4034e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-78ff71b4e40f616f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/829/format/webp" alt="6"></p><p>参数的说明：</p><ul><li>index</li></ul><blockquote><p>代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。</p></blockquote><p>在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p><p>在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。</p><font color="#cc0000">Tagged Pointer 的存在主要是为了节省内存</font>。我们知道，<font color="#cc0000">对象的指针大小一般是与机器字长有关</font>，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。<br><br>假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1f205ac1ee6d1db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-c1a948684d801b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>关于 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer 技术</a>详细的，可以看上面链接那个文章。<br><br><em> has_assoc<br><br>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</em> has_cxx_dtor<br><br>表示该对象是否有 C++ 或者 Objc 的析构器<br><br><em> shiftcls<br><br>类的指针。arm64 架构中有 33 位可以存储类指针。<br><br>源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br><br>将当前地址右移三位的主要原因是用于<font color="#cc0000">将 Class 指针中无用的后三位清除减小内存的消耗</font>，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md#shiftcls" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a>这篇文章里面的 shiftcls 分析。</em> magic<br><br>判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。<br><br><em> weakly_referenced<br><br>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</em> deallocating<br><br>对象是否正在释放内存<br><br><em> has_sidetable_rc<br><br>判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。</em> extra_rc<br><br>存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。<br><br>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>关于 x86_64 的架构，具体可以看<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a>文章里面的详细分析。<br><br><br>#### 2.2 cache_t 的具体实现<br><br>继续看源码<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;      <span class="comment">// 分配用来缓存 bucket 的总数</span></span><br><span class="line">    mask_t _occupied;  <span class="comment">// 表明实际占用的缓存 bucket 的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32_t;</span><br><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  uintptr_t;</span><br><span class="line"><span class="keyword">typedef</span> uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-3ab871ca22e8e5a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt><br><br>根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。<br><br>bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。<br><br>cache_t 中的 bucket_t <em>_buckets 其实就是一个散列表，用来存储 Method 的链表。<br><br>Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，<font color="#cc0000">因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%</font>。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。<br><br>#### 2.3 class_data_bits_t 的具体实现<br><br>源码实现：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-dfecb7c37d335fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits; <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><br><br>它为我们提供了便捷方法用于返回其中的 class_rw_t </em> 指针：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t *data() &#123;</span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly<br><br>在编译期，类的结构中的 class_data_bits_t <em>data 指向的是一个 class_ro_t </em> 指针：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-2dad1ac70ec7dac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>在运行时调用 realizeClass方法，会做以下 3 件事情：<br><br>1.  从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针<br><br>2.  初始化一个 class_rw_t 结构体<br><br>3.  设置结构体 ro 的值以及 flag<br><br><br>最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;   <span class="comment">// 方法名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">// Type Encoding 类型编码</span></span><br><span class="line">    IMP imp;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;<span class="keyword">const</span> method_t&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> method_t&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> operator() (<span class="keyword">const</span> method_t&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> method_t&amp; rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 <a href="https://link.jianshu.com?t=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a>。<br><br>IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。<br><br>整个运行时过程描述如下：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-06da58b9bbe05c6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>更加详细的分析，请看<a href="https://link.jianshu.com?t=https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a> 的这篇文章<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a><br><br>到此，总结 objc_class 1.0 和 2.0 的差别。<br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-8b2987b38e6e5d2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-cd2c3afd17d40e9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><br>## 三、测试题<br><br>1. [self class] 与 [super class]<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br><br>self 和 super 的区别：<br><br>    self 是类的一个<font color="#cc0000">隐藏参数</font>，每个方法的实现的第一个参数即为 self。<br><br>　 super 并不是隐藏参数，它实际上只是一个“<font color="#cc0000">编译器标示符</font>”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。<br><br>在调用 [super class] 的时候，runtime 会去调用 <font color="#cc0000">objc_msgSendSuper</font> 方法，而不是 objc_msgSend。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_msgSendSuper(<span class="keyword">void</span> <span class="comment">/* struct objc_super *super, SEL op, ... */</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。<br><br>objc_msgSendSuper 的工作原理应该是这样的：<br><br>&gt; 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。<br><br>那么 objc_msgSendSuper 最后就转变成<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里是从父类开始 msgSend，而不是从本类开始。</span></span><br><span class="line">objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(<span class="keyword">class</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies an instance of a class.  这是类的一个实例</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是实例调用，所以是减号方法</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。<br><br><br>2. isKindOfClass 与 isMemberOfClass<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span>@<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">         <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>先来分析一下源码这两个函数的对象实现<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) &#123;</span><br><span class="line">        uintptr_t slot = ((uintptr_t)<span class="keyword">this</span> &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;</span><br><span class="line">        <span class="keyword">return</span> objc_tag_classes[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>首先题目中 NSObject 和 Sark 分别调用了 class 方法。<br><br>+ (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去<font color="#cc0000">调用当前类的 obj-&gt;getIsa()</font>，最后在 <font color="#cc0000">ISA()</font> 方法中获得 meta class 的指针。<br><br>接着在 isKindOfClass 中有一个<font color="#cc0000">循环</font>，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。<br><br>[NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。<br><br>同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。<br><br>如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。<br><br>&gt; isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。<br><br>第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。<br><br><br>3. Class 与内存地址<br><br>下面的代码会？Compile Error / Runtime Crash / NSLog…?<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name's %@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br><br>这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？<br><br>首先需要谈谈隐藏参数 self 和 _cmd 的问题。<br><br>当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。<br><br>难点一：能不能调用 speak 方法？<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>]; </span><br><span class="line"><span class="keyword">void</span> *obj = &amp;cls;</span><br></pre></td></tr></table></figure><br><br>答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。<br><br>难点二：如果能调用 speak，会输出什么呢？<br><br>很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。<br><br>正确的答案会输出<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is &lt;ViewController: <span class="number">0x7ff6d9f31c50</span>&gt;</span><br></pre></td></tr></table></figure><br><br>内存地址每次运行都不同，但是前面一定是 ViewController。why？<br><br>我们把代码改变一下，打印更多的信息出来。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController = %@ , 地址 = %p"</span>, <span class="keyword">self</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark class = %@ 地址 = %p"</span>, cls, &amp;cls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@ 地址 = %p"</span>, obj, &amp;obj);</span><br><span class="line">    </span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    </span><br><span class="line">    Sark *sark = [[Sark alloc]init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark instance = %@ 地址 = %p"</span>,sark, &amp;sark);</span><br><span class="line">    </span><br><span class="line">    [sark speak];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我们把对象的指针地址都打印出来。输出结果：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewController = &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt; , 地址 = <span class="number">0x7fff543f5aa8</span></span><br><span class="line">Sark <span class="keyword">class</span> = Sark 地址 = <span class="number">0x7fff543f5a88</span></span><br><span class="line">Void *obj = &lt;Sark: <span class="number">0x7fff543f5a88</span>&gt; 地址 = <span class="number">0x7fff543f5a80</span></span><br><span class="line"></span><br><span class="line">my name is &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt;</span><br><span class="line"></span><br><span class="line">Sark instance = &lt;Sark: <span class="number">0x7fb570d20b10</span>&gt; 地址 = <span class="number">0x7fff543f5a78</span></span><br><span class="line">my name is (null)</span><br></pre></td></tr></table></figure><br><br><img src="//upload-images.jianshu.io/upload_images/1194012-c794987c90515f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSendSuper2(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><br><br>objc_msgSendSuper2 方法入参是一个 objc_super <em>super。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><br><br>所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-75370b4b3f3e6c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。<br><br>在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1de5156e2caa715e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。<br><br>至此，Objc 中的对象到底是什么呢？<br><br>实质：<font color="#cc0000">Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject<strong>，</strong>而对象的实例变量 void </font></em>ivar = &amp;obj + offset(N)<p>加深一下对上面这句话的理解，下面这段代码会输出什么？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController = %@ , 地址 = %p"</span>, <span class="keyword">self</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *myName = <span class="string">@"halfrost"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark class = %@ 地址 = %p"</span>, cls, &amp;cls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@ 地址 = %p"</span>, obj,&amp;obj);</span><br><span class="line">    </span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    </span><br><span class="line">    Sark *sark = [[Sark alloc]init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark instance = %@ 地址 = %p"</span>,sark,&amp;sark);</span><br><span class="line">    </span><br><span class="line">    [sark speak];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewController = &lt;ViewController: <span class="number">0x7fff44404ab0</span>&gt; ,  地址  = <span class="number">0x7fff56a48a78</span></span><br><span class="line">Sark <span class="keyword">class</span> = Sark  地址  = <span class="number">0x7fff56a48a50</span></span><br><span class="line">Void *obj = &lt;Sark: <span class="number">0x7fff56a48a50</span>&gt;  地址 = <span class="number">0x7fff56a48a48</span></span><br><span class="line"></span><br><span class="line">my name is halfrost</span><br><span class="line"></span><br><span class="line">Sark instance = &lt;Sark: <span class="number">0x6080000233e0</span>&gt;  地址 = <span class="number">0x7fff56a48a40</span></span><br><span class="line">my name is (null)</span><br></pre></td></tr></table></figure><p>由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。</p><p>原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-86a075b8fd3adf92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5294842-428635ce01f15146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-cccbecc99506dbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。</p><p>LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：</p><blockquote><p>x/</p><p>n、f、u 是可选的参数。</p><p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</p><p>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。</p><p>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。</p><p>u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1194012-3111309aaef61c73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。</p><p>这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。</p><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="noopener">一缕殇流化隐半边冰霜</a> &amp; <a href="https://www.jianshu.com/p/9d649ce6d0b8" target="_blank" rel="noopener">神经病院Objective-C Runtime入院第一天–isa和Class</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Runtime-简介&quot;&gt;&lt;a href=&quot;#一、Runtime-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Runtime 简介&quot;&gt;&lt;/a&gt;一、Runtime 简介&lt;/h2&gt;&lt;p&gt;Runtime 又叫运行时，是一套底层的 C 语言 API，
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Runtime</title>
    <link href="http://yoursite.com/2019/05/23/Runtime/"/>
    <id>http://yoursite.com/2019/05/23/Runtime/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T08:00:41.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。<font color="#cc0000">函数标识与函数实现之间的关联可以动态修改</font>。</p><p><font color="#cc000">OC 把一些决定工作从编译链接推迟到运行时</font>，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。</p><p>Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事：</p><ol><li><p>封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。</p></li><li><p>传递消息，找出方法的最终执行代码。</p><p> ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）；  </p><p> ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发）</p></li></ol><blockquote><p>动态加载：<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="noopener">NSBundle</a>类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[receiver message];  </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)</span></span><br><span class="line">[receiver message:(<span class="keyword">id</span>)arg...]; </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...)</span></span><br></pre></td></tr></table></figure><p>Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。</p><p>当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p><p>Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。</p><h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><p>Objc 与 Runtime 相关：</p><p>①、通过 Objective-C 源代码<br>②、通过 Foundation 框架的 NSObject 类定义的方法<br>③、通过对 Runtime 库函数的直接调用</p><h4 id="2-1-Objective-C-源代码"><a href="#2-1-Objective-C-源代码" class="headerlink" title="2.1 Objective-C 源代码"></a>2.1 Objective-C 源代码</h4><p>多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。</p><h4 id="2-2-通过-Foundation-框架的-NSObject-类定义的方法"><a href="#2-2-通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="2.2 通过 Foundation 框架的 NSObject 类定义的方法"></a>2.2 通过 Foundation 框架的 NSObject 类定义的方法</h4><p>Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类）</p><p>NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。</p><p>一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如：</p><ul><li>-class 方法返回对象的类；</li><li>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中</li><li>-respondsToSelector: 检查对象能否响应指定的消息；</li><li>-conformsToProtocol: 检查对象是否实现了指定协议类的方法；</li><li>-methodForSelector: 返回指定方法实现的地址。</li></ul><h4 id="2-3-通过对-Runtime-库函数的直接调用"><a href="#2-3-通过对-Runtime-库函数的直接调用" class="headerlink" title="2.3 通过对 Runtime 库函数的直接调用"></a>2.3 通过对 Runtime 库函数的直接调用</h4><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。</p><p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。</p><h2 id="三、Runtime-相关的头文件"><a href="#三、Runtime-相关的头文件" class="headerlink" title="三、Runtime 相关的头文件"></a>三、Runtime 相关的头文件</h2><p>ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List.h</span><br><span class="line"><span class="built_in">NSObjCRuntime</span>.h</span><br><span class="line"><span class="built_in">NSObject</span>.h</span><br><span class="line">Object.h</span><br><span class="line">Protocol.h</span><br><span class="line">a.txt</span><br><span class="line">hashtable.h</span><br><span class="line">hashtable2.h</span><br><span class="line">message.h</span><br><span class="line">module.map</span><br><span class="line">objc-api.h</span><br><span class="line">objc-auto.h</span><br><span class="line">objc-<span class="keyword">class</span>.h</span><br><span class="line">objc-exception.h</span><br><span class="line">objc-load.h</span><br><span class="line">objc-runtime.h</span><br><span class="line">objc-sync.h</span><br><span class="line">objc.h</span><br><span class="line">runtime.h</span><br></pre></td></tr></table></figure><p>都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括：</p><h4 id="3-1-操作对象的类型的定义"><a href="#3-1-操作对象的类型的定义" class="headerlink" title="3.1 操作对象的类型的定义"></a>3.1 操作对象的类型的定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.  一个类型，代表着类定义中的一个方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an instance variable.  代表实例(对象)的变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents a category.  代表一个分类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C declared property.  代表OC声明的属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls = obj.class;</span><br><span class="line"><span class="comment">// NSLog(@"%s", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLE</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(cls);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br></pre></td></tr></table></figure><h4 id="3-2-函数的定义"><a href="#3-2-函数的定义" class="headerlink" title="3.2 函数的定义"></a>3.2 函数的定义</h4><blockquote><p>操作对象的方法一般以 object_ 开头<br>操作类的方法一般以 class_ 开头<br>操作类或对象的方法的方法一般以 method_ 开头<br>操作成员变量的方法一般以 ivar_ 开头<br>操作属性的方法一般以 property_ 开头<br>操作协议的方法一般以 protocol_ 开头</p><p>以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。</p></blockquote><p>根据以上的函数的前缀可以大致了解到层级关系。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 runtime 对当前的应用中加载的类进行打印</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Class * clsList = objc_copyClassList(&amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(clsList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、术语及其数据结构"><a href="#四、术语及其数据结构" class="headerlink" title="四、术语及其数据结构"></a>四、术语及其数据结构</h2><h4 id="4-1-SEL"><a href="#4-1-SEL" class="headerlink" title="4.1 SEL"></a>4.1 SEL</h4><p>它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，<font color="#cc0000">本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度</font>。它的数据结构是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;  <span class="comment">// An opaque type that represents a method selector.</span></span><br></pre></td></tr></table></figure><p>可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。</p><blockquote><p>注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p></blockquote><h4 id="4-2-id"><a href="#4-2-id" class="headerlink" title="4.2 id"></a>4.2 id</h4><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">struct</span> objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure><p>objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。</p><blockquote><p>注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。</p><p>Direct access to Objective-C’s isa is deprecated in favor of object_getClass()</p></blockquote><p><a href="http://lizhaoloveit.com/2014/05/11/KVO/" target="_blank" rel="noopener">KVO</a> 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。</p><h4 id="4-3-Class"><a href="#4-3-Class" class="headerlink" title="4.3 Class"></a>4.3 Class</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure><p>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">/*  父类  */</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;   </span><br><span class="line">    <span class="comment">/*  类名  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类的版本信息，默认为 0 */</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类信息，供运行时期使用的一些位标识。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;</span></span><br><span class="line"><span class="comment">         CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量大小（包括从父类继承下来的实例变量）*/</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员变量地址列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法地址列表，与 info 的一些标志位有关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists   OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 缓存最近使用的方法地址，用于提升效率 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 存储该类声明遵守的协议的列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;  </span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p><p>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解 Objective-C: Category</a>。</p><p>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p><p>值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。</p><blockquote><p>实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）；</p><p>类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。</p></blockquote><p>为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p><p>开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p><p>当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span>.class alloc];    <span class="comment">// [NSObject alloc]</span></span><br></pre></td></tr></table></figure><p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f45adc9fd1faea0b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Meta Class"></p><p>实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。</p><p>最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。</p><h4 id="4-4-Method"><a href="#4-4-Method" class="headerlink" title="4.4 Method"></a>4.4 Method</h4><p>代表类中某个方法的类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name            OBJC2_UNAVAILABLE;   <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable method_types       OBJC2_UNAVAILABLE;   <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp             OBJC2_UNAVAILABLE;   <span class="comment">// 方法实现</span></span><br><span class="line">&#125;   </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">*   method\_name 类型为 SEL</span><br><span class="line">*   method\_types 是个 <span class="keyword">char</span> 指针，存储方法的参数类型和返回值类型</span><br><span class="line">*   method\_imp 指向了方法的实现，本质是一个函数指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 4.5 Ivar</span></span><br><span class="line"></span><br><span class="line">表示成员变量的类型。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                           OBJC2_UNAVAILABLE;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                 OBJC2_UNAVAILABLE;  <span class="comment">// 占用空间</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-IMP"><a href="#4-6-IMP" class="headerlink" title="4.6 IMP"></a>4.6 IMP</h4><p>objc.h 中定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br></pre></td></tr></table></figure><p>它就是一个<font color="#cc0000">由编译器生成的函数指针，指向方法实现的首地址</font>。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p><p>如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p><p>你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p><h4 id="4-7-Cache"><a href="#4-7-Cache" class="headerlink" title="4.7 Cache"></a>4.7 Cache</h4><p>runtime.h 中定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">/* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实际占用cache buckets的总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Method _Nullable buckets[<span class="number">1</span>]                              OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。</p><p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p><h4 id="4-8-Property"><a href="#4-8-Property" class="headerlink" title="4.8 Property"></a>4.8 Property</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;  <span class="comment">// 这个更常用</span></span><br></pre></td></tr></table></figure><p>可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">protocol_copyPropertyList(Protocol * _Nonnull proto,</span><br><span class="line">                          <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。</p></blockquote><p>property_getName() 用来查找属性的名称，返回 c 字符串。<br>property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。<br>class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e2cb59d1344df2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象结构图"></p><h2 id="五、消息"><a href="#五、消息" class="headerlink" title="五、消息"></a>五、消息</h2><p>体会官方文档中的 messages aren’t bound to method implementations until Runtime。<font color="#cc0000">消息直到运行时才会与方法实现进行绑定</font>。</p><p>这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2d3464848b8f4fc2?imageMogr2/auto-orient/strip" alt="消息发送"></p><p>①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数；</p><p>②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</p><p>③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。</p><p>④、如果 cache 找不到就找类的方法列表中是否有对应的方法。</p><p>⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。</p><p>⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。</p><p>在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。</p><h4 id="5-1-方法中的隐藏参数"><a href="#5-1-方法中的隐藏参数" class="headerlink" title="5.1 方法中的隐藏参数"></a>5.1 方法中的隐藏参数</h4><blockquote><p>我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？</p></blockquote><p>其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。</p><p>当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p><ul><li>self 当前方法的对象指针，接受消息的对象</li><li>_cmd 当前方法的 SEL 指针，方法选择器</li></ul><p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p><p>这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p><p>这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体指明了消息应该被传递给特定的父类。</p><p>receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">25.082134</span>+<span class="number">0800</span> Demo[<span class="number">22838</span>:<span class="number">128408</span>] ViewController   <span class="comment">// 当前类</span></span><br></pre></td></tr></table></figure><h4 id="5-2-获取方法地址"><a href="#5-2-获取方法地址" class="headerlink" title="5.2 获取方法地址"></a>5.2 获取方法地址</h4><p>NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          [<span class="keyword">self</span> fail:<span class="literal">YES</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fail:(<span class="built_in">BOOL</span>)value</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">06</span>:<span class="number">22.683838</span>+<span class="number">0800</span> Demo[<span class="number">36187</span>:<span class="number">211037</span>] <span class="number">4.104993</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>) = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(fail:)];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">setter</span>(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fail:), <span class="literal">YES</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">05</span>:<span class="number">48.480498</span>+<span class="number">0800</span> Demo[<span class="number">36095</span>:<span class="number">209893</span>] <span class="number">3.751424</span></span><br></pre></td></tr></table></figure><p>虽然是更高效的调用方法，但这种做法很少用，除非是<font color="#cc0000">需要持续大量重复调用某个方法</font>的情况，才会选择使用，<font color="#cc0000">以免消息发送泛滥</font>。</p><blockquote><p>注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</p></blockquote><h2 id="六、动态方法解析"><a href="#六、动态方法解析" class="headerlink" title="六、动态方法解析"></a>六、动态方法解析</h2><p>如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure><p>这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p><p>Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p><blockquote><p>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。</p></blockquote><h2 id="七、消息转发"><a href="#七、消息转发" class="headerlink" title="七、消息转发"></a>七、消息转发</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f7a92a32f8cc7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p><p>①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步；</p><p>②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步；</p><p>③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步；</p><p>④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。</p><h4 id="7-1-重定向"><a href="#7-1-重定向" class="headerlink" title="7.1 重定向"></a>7.1 重定向</h4><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(xxx:))&#123;</span><br><span class="line">          <span class="keyword">return</span> otherObj;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。</p><h4 id="7-2-转发"><a href="#7-2-转发" class="headerlink" title="7.2 转发"></a>7.2 转发</h4><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [otherObj methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param  anInvocation  封装了原始的消息和消息的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 判断 otherObj 对象是否实现了方法</span></span><br><span class="line">     <span class="keyword">if</span> ([otherObj respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:otherObj];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p><blockquote><p>参数 anInvocation 是从哪来的？</p><p>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</p></blockquote><p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p><p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p><blockquote><p>forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。</p></blockquote><h4 id="7-3-转发和多继承"><a href="#7-3-转发和多继承" class="headerlink" title="7.3 转发和多继承"></a>7.3 转发和多继承</h4><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-70cda98ab8c42661?imageMogr2/auto-orient/strip" alt></p><p>在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p><h4 id="7-4-转发与继承"><a href="#7-4-转发与继承" class="headerlink" title="7.4 转发与继承"></a>7.4 转发与继承</h4><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p><p>如果判断上图中的 Warrior 对象是否能响应 negotiate 消息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。</p><p>如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* Here, test whether the aSelector message can     *</span></span><br><span class="line"><span class="comment">           * be forwarded to another object and whether that  *</span></span><br><span class="line"><span class="comment">           * object can respond to it. Return YES if it can.  */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。</p><p>如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。</p><h2 id="八、应用场景"><a href="#八、应用场景" class="headerlink" title="八、应用场景"></a>八、应用场景</h2><h4 id="8-1-获取属性-成员变量列表"><a href="#8-1-获取属性-成员变量列表" class="headerlink" title="8.1 获取属性/成员变量列表"></a>8.1 获取属性/成员变量列表</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的定义了一个成员变量和两个属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">         <span class="built_in">CGFloat</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"Person"</span>);   <span class="comment">// Class cls = Person.class;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取成员变量数组</span></span><br><span class="line">    Ivar * ivarList = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取成员变量名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivarList[i]); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivarName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性数组</span></span><br><span class="line">    objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ptyName = property_getName(ptyList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ptyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905326</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905486</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905616</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905745</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905877</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] age</span><br></pre></td></tr></table></figure><p>从这里就可以看出 @property 做了三件事：</p><p>①、生成一个带下划线的成员变量<br>②、生成这个成员变量的 set 方法<br>③、生成这个成员变量的 get 方法</p><p>因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> * name;  <span class="comment">// 只读属性</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"job"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.690815</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691025</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691159</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691308</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] age</span><br></pre></td></tr></table></figure><p>当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。</p><blockquote><p>一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好?</p></blockquote><p>大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。</p><blockquote><p>在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？</p></blockquote><p>首先要了解 setValue:forKeyPath: 方法的底层实现：</p><p>①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]<br>②、查找有没有成员变量 _XX，如果有 _XX = value；<br>③、查找有没有成员变量 XX，如果有 XX = value；<br>④、如果都没有找到，直接报错。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSUnknownKeyException', </span><br><span class="line">reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: </span><br><span class="line"><span class="keyword">this</span> <span class="keyword">class</span> is not key value coding-compliant <span class="keyword">for</span> the key name.<span class="string">'</span></span><br></pre></td></tr></table></figure><p>首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。</p><p>另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc；</p><p>使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。</p><p>要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> * timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> * thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AModel * a;  <span class="comment">// 自定义对象</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     objc_property_t * propertyList = class_copyPropertyList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_getAttributes(propertyList[i]));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839596</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSTimer"</span>,W,N,V_timer</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839692</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSThread"</span>,&amp;,N,V_thread</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839771</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"AModel"</span>,R,N,V_a</span><br></pre></td></tr></table></figure><p>通过 property_getAttributes() 方法获取属性的参数。</p><h4 id="8-2-KVC字典转模型"><a href="#8-2-KVC字典转模型" class="headerlink" title="8.2 KVC字典转模型"></a>8.2 KVC字典转模型</h4><p>获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。</p><p>为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程：</p><p>①、遍历字典里面的所有 key，取出 key；<br>②、取出 key 的 value，即 dict[key]；<br>③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。</p><p>因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。</p><p>因此使用逐一为属性赋值的方法进行 KVC：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">     Class cls = Person.class;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     Person * person = [[Person alloc] init];</span><br><span class="line">     <span class="built_in">NSDictionary</span> * dict = @&#123;  <span class="string">@"name"</span> : <span class="string">@"Tom"</span>, <span class="string">@"age"</span> : @<span class="number">19</span>, <span class="string">@"height"</span>: @<span class="number">175</span> &#125;;</span><br><span class="line">    </span><br><span class="line">     Ivar * ivars = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * clsName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:clsName];</span><br><span class="line">          <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];  <span class="comment">// 去掉'_'</span></span><br><span class="line">          [person setValue:dict[key] forKey:key];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">42</span>:<span class="number">16.964474</span>+<span class="number">0800</span> Demo[<span class="number">6425</span>:<span class="number">1574210</span>] height:<span class="number">175.0000</span>，name:Tom，age:<span class="number">19</span>，time:(null)</span><br></pre></td></tr></table></figure><p>使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。</p><p>但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。</p><blockquote><p>setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。</p></blockquote><p>解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。</p><p>runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">     <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">     <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * coding = ivar_getTypeEncoding(ivars[i]); <span class="comment">// 获取类型</span></span><br><span class="line">     <span class="built_in">NSString</span> * strCode = [<span class="built_in">NSString</span> stringWithUTF8String:coding];</span><br><span class="line">     <span class="keyword">id</span> value = dict[key];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ([strCode isEqualToString:<span class="string">@"f"</span>]) &#123;  <span class="comment">// 判断类型是否是 float</span></span><br><span class="line">          value = @(<span class="number">0.0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     [person setValue:value forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>method_getTypeEncoding() 函数可以获取到方法类型编码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     Method m = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(<span class="keyword">do</span>:at:on:));</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, method_getTypeEncoding(m));</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)<span class="keyword">do</span>:(<span class="built_in">NSString</span> *)something at:(<span class="keyword">char</span>)place on:(<span class="keyword">int</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">42</span>:<span class="number">30.891829</span>+<span class="number">0800</span> Demo[<span class="number">38588</span>:<span class="number">270099</span>] B32@<span class="number">0</span>:<span class="number">8</span>@<span class="number">16</span>c24i28</span><br></pre></td></tr></table></figure><p>property_getAttributes() 函数可以获取到属性的参数。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="noopener">Declared Properties</a></p><h4 id="8-3-NSCoding-归档和解档"><a href="#8-3-NSCoding-归档和解档" class="headerlink" title="8.3 NSCoding 归档和解档"></a>8.3 NSCoding 归档和解档</h4><p>获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">          <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];  <span class="comment">// 取出 key 对应的 value</span></span><br><span class="line">          [aCoder encodeObject:value forKey:key];   <span class="comment">// 编码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">               <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">               <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];  <span class="comment">// 解码</span></span><br><span class="line">               [<span class="keyword">self</span> setValue:value forKey:key];  <span class="comment">// 设置 key 对应的 value</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-交换方法实现"><a href="#8-4-交换方法实现" class="headerlink" title="8.4 交换方法实现"></a>8.4 交换方法实现</h4><p>交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">          Method orginalMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">          Method swizzleMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(my_imageNamed:));</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//方法交换</span></span><br><span class="line">          method_exchangeImplementations(orginalMethod, swizzleMethod);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)my_imageNamed:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> my_imageNamed:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。<br>②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。</p><p>任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。</p><h4 id="8-5-类-对象的关联对象"><a href="#8-5-类-对象的关联对象" class="headerlink" title="8.5 类/对象的关联对象"></a>8.5 类/对象的关联对象</h4><p>关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参数 1 : 关联到对象</span></span><br><span class="line"><span class="comment">   参数 2 : 关联的 key，可以是任意类型</span></span><br><span class="line"><span class="comment">   参数 3 : 被关联的对象</span></span><br><span class="line"><span class="comment">   参数 4 : 关联引用的规则</span></span><br><span class="line"><span class="comment">           enum &#123;</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_ASSIGN = 0,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY_NONATOMIC = 3,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN = 01401,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY = 01403</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> value = objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br></pre></td></tr></table></figure><h4 id="8-6-动态添加方法，拦截未实现的方法"><a href="#8-6-动态添加方法，拦截未实现的方法" class="headerlink" title="8.6 动态添加方法，拦截未实现的方法"></a>8.6 动态添加方法，拦截未实现的方法</h4><p>每个类都有继承自 NSObject 的两个类方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure><p>一个适用于类方法，一个适用于对象方法。</p><p>在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmd</span></span><br><span class="line"><span class="keyword">void</span> method(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"doSomething"</span>]) &#123;       </span><br><span class="line">     </span><br><span class="line">          <span class="comment">/* 参数 4 : const char *types 方法的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             如果想要再增加参数，就可以从实现的第三个参数算起：</span></span><br><span class="line"><span class="comment">                 class_addMethod(self, sel, method, "v@:@"); // 多一个对象类型参数增加了 @</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 void method(id self, SEL _cmd, NSString * name) &#123;  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             返回值：YES if the method was found and added to the receiver, otherwise NO.</span></span><br><span class="line"><span class="comment">          */</span> </span><br><span class="line">          class_addMethod(<span class="keyword">self</span>, sel, method, <span class="string">"v@:"</span>);  <span class="comment">// 为 sel 指定实现为 method</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-7-动态创建一个类"><a href="#8-7-动态创建一个类" class="headerlink" title="8.7 动态创建一个类"></a>8.7 动态创建一个类</h4><p>动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> sayFunction(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> param) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld岁的%@在%@说%@"</span>, [object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_age"</span>)) integerValue], object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>)), object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"schoolName"</span>)), param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 Student 类。参数 1 : 父类   参数 2 : 类名   参数 3 : 通常为 0</span></span><br><span class="line">    Class StudentClass = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">"Student"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型</span></span><br><span class="line">    <span class="comment">// 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用</span></span><br><span class="line">    <span class="keyword">if</span> (class_addIvar(StudentClass, <span class="string">"schoolName"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="string">"@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加成员变量成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 NSString * _name 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_name"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">    <span class="comment">// 添加 int _age 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_age"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为 Student 类添加方法 "v@:" 这种写法见参数类型连接</span></span><br><span class="line">    SEL sel = sel_registerName(<span class="string">"sayFunction:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(StudentClass, sel, (IMP)sayFunction, <span class="string">"v@:@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加方法成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册这个类到 runtime 系统中就可以使用了</span></span><br><span class="line">    objc_registerClassPair(StudentClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用创建的类</span></span><br><span class="line">    <span class="keyword">id</span> student = [[StudentClass alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给刚刚添加的变量赋值</span></span><br><span class="line">    <span class="comment">// object_setInstanceVariable(student, "schoolName", (void *)&amp;str);在ARC下不允许使用</span></span><br><span class="line">    [student setValue:<span class="string">@"清华大学"</span> forKey:<span class="string">@"schoolName"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KVC 动态改变实例变量</span></span><br><span class="line">    [student setValue:<span class="string">@"Tom"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从类中获取成员变量Ivar</span></span><br><span class="line">    Ivar ageIvar = class_getInstanceVariable(StudentClass, <span class="string">"_age"</span>);</span><br><span class="line">    <span class="comment">// 为peopleInstance的成员变量赋值</span></span><br><span class="line">    object_setIvar(StudentClass, ageIvar, @<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息</span></span><br><span class="line">    objc_msgSend(student, <span class="string">"sayFunction:"</span>, <span class="string">@"你好~"</span>); </span><br><span class="line">    <span class="comment">// [student performSelector:sel withObject:@"你好~"]; // 动态调用未显式在类中声明的方法</span></span><br><span class="line">    </span><br><span class="line">    student = <span class="literal">nil</span>;</span><br><span class="line">    StudentClass = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    objc_disposeClassPair(StudentClass);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d8496fe34a524c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt></p><h2 id="九、健壮的实例变量-Non-Fragile-ivars"><a href="#九、健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="九、健壮的实例变量(Non Fragile ivars)"></a>九、健壮的实例变量(Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。</p><p>当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b75736c89991ff2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ddfa1eb170bae83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a4a0f676708f0a30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="健壮的实例变量自动偏移"></p><p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p><p>需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。</p><h2 id="十、文章"><a href="#十、文章" class="headerlink" title="十、文章"></a>十、文章</h2><p><a href="http://home.cnblogs.com/u/Mike-zh/" target="_blank" rel="noopener">Mike_zh</a> &amp; <a href="https://www.cnblogs.com/Mike-zh/p/4557014.html" target="_blank" rel="noopener">iOS-Runtime知识点整理</a></p><p><a href="https://www.ianisme.com/" target="_blank" rel="noopener">ian</a> &amp; <a href="https://www.ianisme.com/ios/2019.html" target="_blank" rel="noopener">Objective-C Runtime 1小时入门教程</a></p><p><a href="https://www.cnblogs.com/ioshe/p/5489086.html" target="_blank" rel="noopener">iOS开发-Runtime 详解</a></p><p><a href="https://www.jianshu.com/p/26c41f48267d" target="_blank" rel="noopener">iOS RunTime 之数据结构</a></p><p><a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">iOS 模块分解—「Runtime面试、工作」</a></p><p><a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Runtime 源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>消息转发</title>
    <link href="http://yoursite.com/2019/05/23/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/05/23/消息转发/</id>
    <published>2019-05-23T10:19:03.940Z</published>
    <updated>2019-07-12T15:44:59.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unrecognized selector sent to instance，导致应用 crash 的情况。</p><p>针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。</p><p>消息转发的整个过程主要涉及的 3 个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span>*)anInvocation;</span><br></pre></td></tr></table></figure><p>其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。</p><h2 id="二、消息转发过程"><a href="#二、消息转发过程" class="headerlink" title="二、消息转发过程"></a>二、消息转发过程</h2><p>首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-21f16eb1cfa08e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下边分析消息转发的过程，以 [MyObjet Length] 为例：</p><p>①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。</p><p>②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。</p><p>③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。</p><h2 id="三、结合-MyObject-中的代码对消息转发流程进一步分析"><a href="#三、结合-MyObject-中的代码对消息转发流程进一步分析" class="headerlink" title="三、结合 MyObject 中的代码对消息转发流程进一步分析"></a>三、结合 MyObject 中的代码对消息转发流程进一步分析</h2><p>①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel </span><br><span class="line">&#123;    </span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ ,<span class="built_in">NSStringFromSelector</span>(sel).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(length)) &#123;</span><br><span class="line">         <span class="built_in">BOOL</span> success = class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)(length), <span class="string">"q@:"</span>); </span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (success) &#123;</span><br><span class="line">             <span class="keyword">return</span> success;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 “q@:” 分别代表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q : 返回值 <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">@ : 调用方法的的实例为对象类型</span><br><span class="line">: : 表示方法</span><br></pre></td></tr></table></figure><p>下图表示了编码类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a5925ae21f498603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * respondClasses;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(aSelector).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> forwardTarget = [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (forwardTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> forwardTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class someClass = [<span class="keyword">self</span> myResponedClassForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (someClass) &#123;</span><br><span class="line">        forwardTarget = [someClass new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forwardTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。</p><p>③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。</p><blockquote><p> -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。</p><p>摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.</p><p>这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。</p></blockquote><p>相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n\n\n\n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(anInvocation.selector).UTF8String);</span><br><span class="line"></span><br><span class="line">    anInvocation.target = <span class="literal">nil</span>;</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        Class responededClass = [<span class="keyword">self</span> myResponedClassForSelector:selector];</span><br><span class="line">        <span class="keyword">if</span> (responededClass) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                signature = [responededClass instanceMethodSignatureForSelector:selector];</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">@finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">NSMethodSignature</span>: <span class="number">0x6000030a17c0</span>&gt;</span><br><span class="line">    number of arguments = <span class="number">2</span></span><br><span class="line">    frame size = <span class="number">224</span></span><br><span class="line">    is special <span class="keyword">struct</span> <span class="keyword">return</span>? <span class="literal">NO</span></span><br><span class="line">    <span class="keyword">return</span> value: -------- -------- -------- --------</span><br><span class="line">        type encoding (f) <span class="string">'f'</span></span><br><span class="line">        flags &#123;isFloat&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">16</span>, offset adjust = <span class="number">0</span>, size = <span class="number">16</span>, size adjust = <span class="number">-12</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">4</span>&#125;</span><br><span class="line">    argument <span class="number">0</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (@) <span class="string">'@'</span></span><br><span class="line">        flags &#123;isObject&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">0</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">    argument <span class="number">1</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (:) <span class="string">':'</span></span><br><span class="line">        flags &#123;&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">8</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span>。</span><br><span class="line"></span><br><span class="line">仍然以`myObject`调用`length`方法为例。 \- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> \*)anInvocation中的 anInvocation 的信息如下：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x6000025b8140</span>&gt;</span><br><span class="line"><span class="keyword">return</span> value: &#123;Q&#125; <span class="number">0</span></span><br><span class="line">target: &#123;@&#125; <span class="number">0x60000322c360</span></span><br><span class="line">selector: &#123;:&#125; length</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">return</span> value 指返回值，<span class="string">"Q"</span> 表示返回值类型为 <span class="keyword">long</span> <span class="keyword">long</span> 类型；</span><br><span class="line">&gt; target 指的是消息的接收者，<span class="string">"@"</span>标识对象类型；</span><br><span class="line">&gt; selector 指的是方法，<span class="string">":"</span>表示是方法，后边的 length 为方法名。</span><br></pre></td></tr></table></figure><p>更多内容可见下图 NSInvocation 的 types：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> _NSObjCValueType &#123;</span><br><span class="line">    <span class="built_in">NSObjCNoType</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSObjCVoidType</span> = <span class="string">'v'</span>,</span><br><span class="line">    <span class="built_in">NSObjCCharType</span> = <span class="string">'c'</span>,</span><br><span class="line">    <span class="built_in">NSObjCShortType</span> = <span class="string">'s'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLongType</span> = <span class="string">'l'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLonglongType</span> = <span class="string">'q'</span>,</span><br><span class="line">    <span class="built_in">NSObjCFloatType</span> = <span class="string">'f'</span>,</span><br><span class="line">    <span class="built_in">NSObjCDoubleType</span> = <span class="string">'d'</span>,</span><br><span class="line">    <span class="built_in">NSObjCBoolType</span> = <span class="string">'B'</span>,</span><br><span class="line">    <span class="built_in">NSObjCSelectorType</span> = <span class="string">':'</span>,</span><br><span class="line">    <span class="built_in">NSObjCObjectType</span> = <span class="string">'@'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStructType</span> = <span class="string">'&#123;'</span>,</span><br><span class="line">    <span class="built_in">NSObjCPointerType</span> = <span class="string">'^'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStringType</span> = <span class="string">'*'</span>,</span><br><span class="line">    <span class="built_in">NSObjCArrayType</span> = <span class="string">'['</span>,</span><br><span class="line">    <span class="built_in">NSObjCUnionType</span> = <span class="string">'('</span>,</span><br><span class="line">    <span class="built_in">NSObjCBitfield</span> = <span class="string">'b'</span></span><br><span class="line">&#125; API_DEPRECATED(<span class="string">"Not supported"</span>, macos(<span class="number">10.0</span>,<span class="number">10.5</span>), ios(<span class="number">2.0</span>,<span class="number">2.0</span>), watchos(<span class="number">2.0</span>,<span class="number">2.0</span>), tvos(<span class="number">9.0</span>,<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><h2 id="四、尚存疑点"><a href="#四、尚存疑点" class="headerlink" title="四、尚存疑点"></a>四、尚存疑点</h2><p>细心的读者可能会发现在首次消息转发的时候流程并不是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>而是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:_forwardStackInvocation: </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>查看了开源源码 <a href="https://opensource.apple.com/source/objc4/objc4-750.1/runtime/NSObject.mm.auto.html" target="_blank" rel="noopener">NSObject.mm</a> 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Replaced by CF (returns an NSMethodSignature)</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot;</span><br><span class="line">                &quot;not available without CoreFoundation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];</span><br><span class="line">&#125;</span><br><span class="line">// Replaced by CF (throws an NSException)</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、NSNull-QiNullSafe-m"><a href="#五、NSNull-QiNullSafe-m" class="headerlink" title="五、NSNull+QiNullSafe.m"></a>五、NSNull+QiNullSafe.m</h2><p>根据 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a> 仿写的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FQiShare%2FQiSafeType%2Fblob%2Fmaster%2FQiSafeType%2FNullSafe%2FNSNull%252BQiNullSafe.m" target="_blank" rel="noopener">NSNull+QiNullSafe.m</a>。</p><p>NSNull+QiNullSafe.m 能够避免的问题有：</p><blockquote><p>NSNull *null = [NSNull null];</p><p>[null performSelector:@selector(addObject:) withObject:@”aaa”];<br>[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];<br>[null performSelector:@selector(valueForKey:) withObject:@”aaa”];<br>[null performSelector:@selector(length) withObject:nil];<br>[null performSelector:@selector(integerValue) withObject:nil];<br>[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];<br>[null performSelector:@selector(bytes) withObject:nil];</p></blockquote><h2 id="六、NullSafe-是怎么处理-null-问题"><a href="#六、NullSafe-是怎么处理-null-问题" class="headerlink" title="六、NullSafe 是怎么处理 null 问题"></a>六、NullSafe 是怎么处理 null 问题</h2><p>其实 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>  处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。</p><p>不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。</p><p>注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。</p><h2 id="七、单元测试"><a href="#七、单元测试" class="headerlink" title="七、单元测试"></a>七、单元测试</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testStringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * string = [null stringValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertNil</span>(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testFloatValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> f = [null floatValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertEqualWithAccuracy</span>(f, <span class="number">0.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNull</span> * null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    [null performSelector:<span class="keyword">@selector</span>(addObject:) withObject:<span class="string">@"aaa"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、文章"><a href="#八、文章" class="headerlink" title="八、文章"></a>八、文章</h2><p><a href="https://juejin.im/post/5c6e773be51d451b25716d0e" target="_blank" rel="noopener">iOS 消息转发</a></p><p><a href="http://www.olinone.com/?p=643" target="_blank" rel="noopener">Protocol 协议分发器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unr
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>图片加载和处理</title>
    <link href="http://yoursite.com/2019/05/23/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/23/图片加载和处理/</id>
    <published>2019-05-23T10:19:03.939Z</published>
    <updated>2019-07-11T11:48:36.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、图片显示"><a href="#一、图片显示" class="headerlink" title="一、图片显示"></a>一、图片显示</h2><p>图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-08b5bf1385f387ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。<font color="#cc0000">UIImage 持有的数据是未解码的压缩数据</font>，能节省较多的内存和加快存储。</p><p>当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。</p><p>解码是一个<font color="#cc0000">计算量较大且需要 CPU 来执行的任务</font>；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 <em> 高 </em> 每个像素点的大小 = width <em> height </em> 4bytes。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-819f47a678632a85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>图像解码操作会造成什么问题？</p><p>以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于<font color="#cc0000">在主线程同时进行 IO 操作、解码操作</font>等，会造成<font color="#cc0000">内存迅速增长和 CPU 负载瞬间提升</font>。</p><p>并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2746a469e302ca58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1-1-优化一：降采样"><a href="#1-1-优化一：降采样" class="headerlink" title="1.1 优化一：降采样"></a>1.1 优化一：降采样</h4><p>在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用<font color="#cc0000">加载缩略图的方式减少图片的占用内存</font>。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-362199218d9322bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。</p><p>思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)downsampleImageAt:(<span class="built_in">NSURL</span> *)imageURL to:(<span class="built_in">CGSize</span>)pointSize scale:(<span class="built_in">CGFloat</span>)scale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> imageSourceOptions = <span class="built_in">CFDictionaryCreate</span> ( <span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                                              (<span class="keyword">void</span> *)@[ (<span class="built_in">NSString</span> *)kCGImageSourceShouldCache ],</span><br><span class="line">                                                              (<span class="keyword">void</span> *)@[ @(<span class="literal">YES</span>) ],</span><br><span class="line">                                                              <span class="number">1</span>,</span><br><span class="line">                                                              &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">                                                              &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)imageURL, imageSourceOptions);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> downsampleOptions = (__bridge <span class="built_in">CFDictionaryRef</span>)@&#123; (<span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailFromImageAlways : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceShouldCacheImmediately : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailWithTransform : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:downsampledImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。</p><h4 id="1-2-优化二：异步处理"><a href="#1-2-优化二：异步处理" class="headerlink" title="1.2 优化二：异步处理"></a>1.2 优化二：异步处理</h4><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fb940b0c9a90d4b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以<font color="#cc0000">在 Prefetching 时把降采样放到子线程进行处理</font>，因为降采样过程就包括解码操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/1049769-adc5d8f6870f9d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/890/format/webp" alt></p><p>Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。</p><p>需要特别注意，此处不能是并发队列，否则会造成<font color="#cc0000">线程爆炸</font>，原因见总结部分。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建串行队列</span></span><br><span class="line">    _serialQueue = dispatch_queue_create(<span class="string">"DecodeQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  获取单元格的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView prefetchItemsAt:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> * indexPath <span class="keyword">in</span> indexPaths) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;</span><br><span class="line">            <span class="built_in">UIImage</span> * downsampledImage = [<span class="keyword">self</span> downsample];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> updateAt:indexPath with:downsampledImage];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  @brief  降采样。自行实现。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)downsample</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  更新单元格的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)updateAt:(<span class="built_in">NSIndexPath</span> *)indexPath with:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-优化三：使用-Image-Asset-Catalogs"><a href="#1-3-优化三：使用-Image-Asset-Catalogs" class="headerlink" title="1.3 优化三：使用 Image Asset Catalogs"></a>1.3 优化三：使用 Image Asset Catalogs</h4><p>苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。</p><p><a href="https://developer.apple.com/videos/play/wwdc2018/227/" target="_blank" rel="noopener">WWDC Session</a>。</p><h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><p>应用上述的优化策略，已经能对图片加载有比较好的优化。</p><p>WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。</p><h2 id="三、WWDC学习"><a href="#三、WWDC学习" class="headerlink" title="三、WWDC学习"></a>三、WWDC学习</h2><p>原作者的经验：<a href="https://www.jianshu.com/u/815d10a4bdce" target="_blank" rel="noopener">落影loyinglin</a></p><p>先主观假设两个前提：</p><p>①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚；</p><p>②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。</p><p>所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，<font color="#cc0000">看我们的 iOS 知识体系是否存在缺陷</font>；另外，WWDC 介绍的很多知识点同样<font color="#cc0000">免验证</font>的加入自己的知识体系。</p><p>以上文提到的线程爆炸为例，看看这种方式的好处。</p><p>原文如下：</p><blockquote><p>Thread Explosion（线程爆炸）</p><p>More images to decode than available CPUs（解码图像数量大于 CPU 数量）<br>GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）<br>Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像）</p></blockquote><p>从这个案例我们学习到<font color="#cc0000">如何避免图像解码的线程爆炸</font>，我们分析苹果工程师的逻辑，然后扩散思维：</p><blockquote><p>原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间</p></blockquote><p>延伸出来的问题：</p><blockquote><p>GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？…</p></blockquote><p>举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来：</p><p>①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别；</p><p>②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。</p><p>接下来的表现是操作系统相关的知识：</p><p>①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程；</p><p>②、cpu 的时间是分为多个时间片，每个线程轮询执行；</p><p>③、线程切换执行有代价，但比进程切换小得多；</p><p>④、每个 cpu 核心在同一时刻只能执行一个线程。</p><p>至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现：</p><p>主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。</p><p>结合此案例，我们能回答相关问题：</p><p>①、现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？</p><p>②、GCD 的串行队列和并发队列的应用场景有何不同？</p><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/p/7d8a82115060" target="_blank" rel="noopener">iOS性能优化–图片加载和处理</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">WWDC2018-Image and Graphics Best Practices</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、图片显示&quot;&gt;&lt;a href=&quot;#一、图片显示&quot; class=&quot;headerlink&quot; title=&quot;一、图片显示&quot;&gt;&lt;/a&gt;一、图片显示&lt;/h2&gt;&lt;p&gt;图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>NSDateFormatter性能</title>
    <link href="http://yoursite.com/2019/05/23/NSDateFormatter%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2019/05/23/NSDateFormatter性能/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-11T11:18:11.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、探究"><a href="#一、探究" class="headerlink" title="一、探究"></a>一、探究</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span> * dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * current = [dateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br></pre></td></tr></table></figure><p>关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:       %8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter once: %8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)----------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">08</span>:<span class="number">42.184</span> Demo[<span class="number">95118</span>:<span class="number">1359994</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">48.73</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">08</span>:<span class="number">42.188</span> Demo[<span class="number">95118</span>:<span class="number">1359994</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">3.57</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.871</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">61.18</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.875</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">3.85</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.123</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">79.80</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.129</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">6.08</span> ms</span><br></pre></td></tr></table></figure><p>上面可以看出两者之间消耗时间差距很大。<font color="#cc0000">创建单例很有必要</font>。</p><p>那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    a += (end - begin);</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    b += (end - begin);</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    c += (end - begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:alloc          %8.2f ms"</span>, a * <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:setFormat      %8.2f ms"</span>, b * <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:stringFromDate %8.2f ms"</span>, c * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">-------------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)-------------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">7.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.28</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">55.98</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.198</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">7.69</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.199</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.25</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.199</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">60.97</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">6.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.20</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">49.06</span> ms</span><br></pre></td></tr></table></figure><p>从上面可以看出，实际<font color="#cc0000">最耗时的方法是 stringFromDate:/dateFromString:</font>。再往下细究。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------Xcode <span class="number">10.0</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)-------------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.218</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">1.43</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.218</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.03</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.02</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.02</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.221</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.221</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br></pre></td></tr></table></figure><p>从上面可以看出，只有<font =#cc0000>首次调用 stringFromDate:/dateFromString: 方法才会很耗时</font>。再往下细究。</p><p>还有人说应该针对 format 格式创建对应的单例对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的对象不同的 format 格式</span></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter1  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter2  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter3  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter4  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter1 setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter1 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter2 setDateFormat:<span class="string">@"MM-dd-yyyy"</span>];</span><br><span class="line">        [formatter2 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter3 setDateFormat:<span class="string">@"MM-dd"</span>];</span><br><span class="line">        [formatter3 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter4 setDateFormat:<span class="string">@"MM-yyyy"</span>];</span><br><span class="line">        [formatter4 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"NSDateFormatter: different format  %8.2f ms\n"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个对象不同的 format 格式</span></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-dd-yyyy"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-yyyy"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"NSDateFormatter:                   %8.2f ms\n"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)---------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDateFormatter</span>: different format     <span class="number">23.26</span> ms</span><br><span class="line"><span class="built_in">NSDateFormatter</span>:                      <span class="number">16.25</span> ms</span><br></pre></td></tr></table></figure><p>如果不计 NSDateFormatter 对象的初始化时间，那么打印输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span>:different format     <span class="number">23.81</span> ms</span><br><span class="line"><span class="built_in">NSDateFormatter</span>:                     <span class="number">23.02</span> ms</span><br></pre></td></tr></table></figure><p>两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。</p><h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://www.jianshu.com/p/b000518c3eb8" target="_blank" rel="noopener">NSDateFormatter 性能测试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、探究&quot;&gt;&lt;a href=&quot;#一、探究&quot; class=&quot;headerlink&quot; title=&quot;一、探究&quot;&gt;&lt;/a&gt;一、探究&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>.pch</title>
    <link href="http://yoursite.com/2019/05/23/pch/"/>
    <id>http://yoursite.com/2019/05/23/pch/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T07:26:36.262Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的<font color="#cc0000">预编译头文件</font>，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之后则需要手动创建。</p><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>①、定义全局性宏；</p><p>②、引用全局性头文件；</p><p>③、根据运行环境，自动打开或者关闭日志输出功能。</p><h2 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h2><p>①、PCH 文件的内容能被项目中的其他所有文件<font color="#cc0000">共享和访问</font>，其它地方可直接使用，不用再手动重复定义或引用；</p><p>②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而<font color="#cc0000">提高编译速度</font>。</p><h2 id="三、缺点"><a href="#三、缺点" class="headerlink" title="三、缺点"></a>三、缺点</h2><p>①、把类中使用的框架等放到 PCH 中，<font color="#cc0000">依赖关系不明确</font>，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。</p><p>②、大量的<font color="#cc0000">共用性不高</font>的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长；</p><h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><p>①、PCH 的目的是：提高编译速度，而不是少敲几行 #import；</p><p>②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用；</p><p>③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。</p><p>④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。</p><p>⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。</p><p>⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。</p><p>⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。</p><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.jianshu.com/p/001980b7a0c4" target="_blank" rel="noopener">PCH 文件的优缺点</a></p><p><a href="https://www.jianshu.com/p/2b449a4ae20f" target="_blank" rel="noopener">PCH文件的新建和其缺点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的&lt;font color=&quot;#cc0000&quot;&gt;预编译头文件&lt;/font&gt;，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 内置图片瘦身</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%86%85%E7%BD%AE%E5%9B%BE%E7%89%87%E7%98%A6%E8%BA%AB/"/>
    <id>http://yoursite.com/2019/05/23/iOS 内置图片瘦身/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-12T01:20:52.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、iOS-内置资源的集中方式"><a href="#一、iOS-内置资源的集中方式" class="headerlink" title="一、iOS 内置资源的集中方式"></a>一、iOS 内置资源的集中方式</h2><h4 id="1-1-将图片存放在-bundle"><a href="#1-1-将图片存放在-bundle" class="headerlink" title="1.1 将图片存放在 bundle"></a>1.1 将图片存放在 bundle</h4><p>这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到<font color="#cc0000">隔离资源</font>的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。</p><p>这种方式有比较明显的缺点：</p><p>①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。</p><p>②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。</p><p>在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。</p><p>下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-66c00dd63d65a971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt> <img src="https://upload-images.jianshu.io/upload_images/5294842-b85758fdfe19f422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-94a016df24024865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt> <img src="https://upload-images.jianshu.io/upload_images/5294842-da19d42d7f21cb5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。</p><h4 id="1-2-使用-ttf-字体文件替代图标"><a href="#1-2-使用-ttf-字体文件替代图标" class="headerlink" title="1.2 使用 .ttf 字体文件替代图标"></a>1.2 使用 .ttf 字体文件替代图标</h4><p>使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。</p><p>使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。</p><p>字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILabel</span> * iconLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">iconLabel.font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"icomoon"</span> size:<span class="number">50</span>];</span><br><span class="line">iconLabel.text = [<span class="built_in">NSString</span> stringWithUTF8String:<span class="string">"\ue902"</span>];</span><br></pre></td></tr></table></figure><p>由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。</p><p>优点：</p><p>①、可以降低应用图片内置资源的体积。</p><p>②、可以随意缩放和修改颜色。</p><p>缺点：</p><p>①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。</p><p>②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。</p><p>任何一种需要大刀阔斧改革的优化都是一种不明智的行为。</p><h4 id="1-3-图片存在-Assets-xcassets"><a href="#1-3-图片存在-Assets-xcassets" class="headerlink" title="1.3 图片存在 Assets.xcassets"></a>1.3 图片存在 Assets.xcassets</h4><p>使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。</p><h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><p>项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。</p><p>为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。</p><p>与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。<font color="#cc0000">.framework 中可以存放资源，但 .a 不可以</font>，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。</p><p>优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。</p><p>先要抛出两个问题：</p><p>&emsp;①、cocoapods 是否支持使用 Assets.xcassets。</p><p>&emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。</p><p>为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d91c042de77985a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.source_files ：源文件路径。</span><br><span class="line"></span><br><span class="line">s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。</span><br><span class="line"></span><br><span class="line">s.resources ：资源文件路径及文件类型。</span><br><span class="line"></span><br><span class="line">s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。</span><br></pre></td></tr></table></figure><p>实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。</p><p>如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。</p><p>查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-7ad0badccde39e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-26d283bdb3e0ab53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。</p><p>既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案：</p><p>①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。</p><p>②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。</p><p>③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。</p><p>④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。</p><p>只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1d1c0b0a5829ddce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-25e5c59026031224.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。</p><p>为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e90e00f3d0c80b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b33cce60e4a67ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a3bfbde2e9e119c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_decodeObjectForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    <span class="keyword">id</span> (*functionPoint)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)) function;</span><br><span class="line">    <span class="keyword">id</span> value = functionPoint(<span class="keyword">self</span>, _cmd, key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b2355951a7c86b6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6d040ecd395f34fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e65336fc35468c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_decodeObjectForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    <span class="keyword">id</span> (*functionPoint)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)) function;</span><br><span class="line">    <span class="keyword">id</span> value = functionPoint(<span class="keyword">self</span>, _cmd, key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span>* propKey = <span class="string">@"emaNecruoseRIU"</span>;</span><br><span class="line">    <span class="comment">// 反转字符串</span></span><br><span class="line">    propKey = [XUtil stringByReversed:propKey];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:propKey]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (normal_imageName) &#123;</span><br><span class="line">            select_imageName = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            normal_imageName = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook UIImageView 的 initWithCoder:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_imageView_initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。</span></span><br><span class="line">    <span class="comment">// tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。</span></span><br><span class="line">    normal_imageName = <span class="literal">nil</span>;</span><br><span class="line">    select_imageName = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImageView</span> * instance = (<span class="built_in">UIImageView</span> *)[<span class="keyword">self</span> swizzle_imageView_initWithCoder:aDecoder];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] &amp;&amp; normal_imageName.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIImage</span> * normalImage = [HookTool imageAfterSearch:normal_imageName];</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (normalImage) &#123;</span><br><span class="line">            instance.image = normalImage;</span><br><span class="line">        &#125;</span><br><span class="line">        normal_imageName = <span class="literal">nil</span>;</span><br><span class="line">        select_imageName = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。</p><p>但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对<font color="#cc0000">增加了项目维护的难度</font>。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。</p><p>hook method_exchangeImplementations 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-53182782221fe7cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>检测方法（字典写入时不要忘了加锁）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fe1b0b6cdef8e479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><font color="#cc0000">这种方式不能区分 image 和 backgroundImage、normal 和 Selected</font>。目前根据观察顺序应该是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIResourceName</span> ： normal - image(前景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： normal - backgroundImage(背景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： selected - image(前景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： selected - backgroundImage(背景图)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、iOS-内置资源的集中方式&quot;&gt;&lt;a href=&quot;#一、iOS-内置资源的集中方式&quot; class=&quot;headerlink&quot; title=&quot;一、iOS 内置资源的集中方式&quot;&gt;&lt;/a&gt;一、iOS 内置资源的集中方式&lt;/h2&gt;&lt;h4 id=&quot;1-1-将图片存放在-bu
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 单例</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/05/23/iOS 单例/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T08:28:00.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、单例介绍"><a href="#一、单例介绍" class="headerlink" title="一、单例介绍"></a>一、单例介绍</h2><p>单例：该类在程序运行期间有且仅有一个实例。</p><h4 id="1-1-单例的主要优点"><a href="#1-1-单例的主要优点" class="headerlink" title="1.1 单例的主要优点"></a>1.1 单例的主要优点</h4><p>①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例；</p><p>②、因为类控制了实例化过程，所以类可以灵活更改实例化过程；</p><p>③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。</p><h4 id="1-2-单例的主要缺点"><a href="#1-2-单例的主要缺点" class="headerlink" title="1.2 单例的主要缺点"></a>1.2 单例的主要缺点</h4><p>①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放；</p><p>②、单例不能继承。</p><h2 id="二、单例的实现"><a href="#二、单例的实现" class="headerlink" title="二、单例的实现"></a>二、单例的实现</h2><p>单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。</p><p>主要是做到以下几点：</p><p>防止调用 [[A alloc] init] 引起的错误<br>防止调用 new 引起的错误<br>防止调用 copy 引起的错误<br>防止调用 mutableCopy 引起的错误</p><h4 id="2-1-实现方式一"><a href="#2-1-实现方式一" class="headerlink" title="2.1 实现方式一"></a>2.1 实现方式一</h4><blockquote><p>把所有可能出现的初始化方法做了相应的处理来其保证安全性</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 不能再使用 alloc 方法</span></span><br><span class="line">        <span class="comment">// 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法</span></span><br><span class="line">        _sharedSingleton = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-实现方式二"><a href="#2-2-实现方式二" class="headerlink" title="2.2 实现方式二"></a>2.2 实现方式二</h4><blockquote><p>不做处理的情况下禁止外部调用</p></blockquote><p>一些成熟的第三方代码的单例中也有使用该方法的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.h 文件</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span> <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopy <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">.m 文件</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          _sharedSingleton = [[<span class="keyword">self</span> alloc] init];  <span class="comment">// 要使用 self 来调用</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。</p><h2 id="三、单例的滥用"><a href="#三、单例的滥用" class="headerlink" title="三、单例的滥用"></a>三、单例的滥用</h2><h4 id="3-1-全局状态"><a href="#3-1-全局状态" class="headerlink" title="3.1 全局状态"></a>3.1 全局状态</h4><p>大多数的开发者都认同使用<font color="#cc0000">全局可变的状态</font>是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SPMath</span></span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSInteger</span> _a;</span><br><span class="line">     <span class="built_in">NSInteger</span> _b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)add</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题：</p><ol><li><p>add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。</p></li><li><p>当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。</p></li></ol><p>把下面的代码和上面的例子做对比:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSUInteger</span>)addOf:(<span class="built_in">NSUInteger</span>)a plus:(<span class="built_in">NSUInteger</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为<font color="#cc0000">类方法</font>，这样就显式的告诉了代码的阅读者：这个方法<font color="#cc0000">不会修改任何实例的状态</font>。</p><p>那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“<a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">单例就是披着羊皮的全局状态</a>” 。</p><p>一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Singleton</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)a </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([[Singleton sharedInstance] name]) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     [[Singleton sharedInstance] setName:<span class="string">""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的<font color="#cc0000">共享状态</font>来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致<font color="#cc0000">隐式的在两个看起来完全不相关的模块之间建立了耦合</font>。</p><p>来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。</p><p>想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">URLCache</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSCache</span> *)sharedURLCache;</span><br><span class="line">- (<span class="keyword">void</span>)storeCachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。</p><p>几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？</p><p>原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。</p><p><font color="#cc0000">持久化状态是单元测试的敌人</font>，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。</p><h4 id="3-2-对象的生命周期"><a href="#3-2-对象的生命周期" class="headerlink" title="3.2 对象的生命周期"></a>3.2 对象的生命周期</h4><p>另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。</p><p>假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThumbnailCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache;</span><br><span class="line">- (<span class="keyword">void</span>)cacheProfileImage:(<span class="built_in">NSData</span> *)imageData forUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="built_in">NSData</span> *)cachedProfileImageForUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。</p><p>当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。</p><p>问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThumbnailCache * sharedThumbnailCache;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!sharedThumbnailCache) &#123;</span><br><span class="line">           sharedThumbnailCache = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sharedThumbnailCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cleanUp</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// The SPThumbnailCache will clean up persistent states when deallocated</span></span><br><span class="line">     sharedThumbnailCache = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个明显的对单例模式的滥用，但是它可以工作，对吧。</p><p>当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。</p><p>由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。</p><p>分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。</p><p>举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持<a href="https://www.dropbox.com/business/two-dropboxes" target="_blank" rel="noopener">多个用户账号</a>登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。</p><p>这里我们得到的教训是：<font color="#cc0000">单例应该只用来保存全局的状态，并且不能和任何作用域绑定</font>。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。</p><h2 id="四、避免使用单例"><a href="#四、避免使用单例" class="headerlink" title="四、避免使用单例"></a>四、避免使用单例</h2><p>既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？</p><p>重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ThumbnailCache * thumbnailCache;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">          _thumbnailCache = [[ThumbnailCache alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。</p><p>现在假设我们有一个 VC 来展现好友列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FriendListVC</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUser:(User *)user; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是<a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">依赖注入</a>，并且它有很多优点：</p><p>①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。</p><p>②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。</p><p>为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。</p><ol><li>假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-5a3d085872ee313f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。</p><p>当用户登出后，清理 rootViewController 并且退出到登录页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d7ce97acfc9e7890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。</p><ol start="2"><li>使用依赖注入的对象图：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-42f2c8e7764a543b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了<a href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank" rel="noopener">简化</a> applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a00b35bf8a96f6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个对象图看起来和使用单例时很像。这有什么区别？</p><p>关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b011ee68eba70df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f0268e3703574ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。</p><p>这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。</p><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://blog.csdn.net/zhengang007/article/details/70336612" target="_blank" rel="noopener">避免滥用单例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、单例介绍&quot;&gt;&lt;a href=&quot;#一、单例介绍&quot; class=&quot;headerlink&quot; title=&quot;一、单例介绍&quot;&gt;&lt;/a&gt;一、单例介绍&lt;/h2&gt;&lt;p&gt;单例：该类在程序运行期间有且仅有一个实例。&lt;/p&gt;
&lt;h4 id=&quot;1-1-单例的主要优点&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>依赖注入</title>
    <link href="http://yoursite.com/2019/05/23/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/05/23/依赖注入/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T08:02:59.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。</p><p>初始化方法注入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2;</span><br></pre></td></tr></table></figure><p>属性注入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency1 * dependency1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency2 * dependency2;</span><br></pre></td></tr></table></figure><p>一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。</p><h2 id="二、为什么使用依赖注入"><a href="#二、为什么使用依赖注入" class="headerlink" title="二、为什么使用依赖注入"></a>二、为什么使用依赖注入</h2><p>依赖注入的几个重要之处：</p><p>①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量；</p><p>②、使用构成。 即一直坚持的<font color="#cc0000">多构成少继承原则</font>。它能提高代码的可重用性；</p><p>③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。</p><p>④、明确的所有者。</p><p>⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。</p><h2 id="三、使用依赖注入"><a href="#三、使用依赖注入" class="headerlink" title="三、使用依赖注入"></a>三、使用依赖注入</h2><h4 id="3-1-注入类的类型"><a href="#3-1-注入类的类型" class="headerlink" title="3.1 注入类的类型"></a>3.1 注入类的类型</h4><p>首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。</p><p>简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。</p><p>复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。</p><p>分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。</p><h4 id="3-2-在初始化时依赖分配"><a href="#3-2-在初始化时依赖分配" class="headerlink" title="3.2 在初始化时依赖分配"></a>3.2 在初始化时依赖分配</h4><p>原始代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line">         ...</span><br><span class="line">         _engine = [[RCEngine alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用依赖注入改版后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">         _engine = engine;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-3-延迟初始化依赖"><a href="#3-3-延迟初始化依赖" class="headerlink" title="3.3 延迟初始化依赖"></a>3.3 延迟初始化依赖</h4><p>通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;</span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init];</span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。</p><p>工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。</p><p>下面，通过一个工厂，使用依赖注入创建一个灭火器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RCFireExtinguisher *(^RCFireExtinguisherFactory)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RCFireExtinguisherFactory fireExtinguisherFactory;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          _engine = engine;  </span><br><span class="line">          _fireExtinguisherFactory = [extFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;     </span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = <span class="keyword">self</span>.fireExtinguisherFactory();     </span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;      </span><br><span class="line"> </span><br><span class="line">          _engine = engine;   </span><br><span class="line">          _transmission    = transmission;   </span><br><span class="line">          _leftFrontWheel  = wheelFactory();   </span><br><span class="line">          _leftRearWheel   = wheelFactory();   </span><br><span class="line">          _rightFrontWheel = wheelFactory();  </span><br><span class="line">          _rightRearWheel  = wheelFactory();   <span class="comment">// 保留轮子工厂，之后还需要一个备胎。   </span></span><br><span class="line">          _wheelFactory    = [wheelFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="四、避免多余的配置"><a href="#四、避免多余的配置" class="headerlink" title="四、避免多余的配置"></a>四、避免多余的配置</h2><p>如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。</p><p>在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。</p><p>为了配置我们的对象，将从 4 个点来收集我们的依赖：</p><p>①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中；</p><p>②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值；</p><p>③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。</p><p>④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。</p><p>下面是关于赛车的简单初便利构造器</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency</span><br><span class="line">&#123;</span><br><span class="line">     RCEngine * engine = [[RCEngine alloc] init];   </span><br><span class="line">     RCTransmission * transmission = [[RCTransmission alloc] init];   </span><br><span class="line"></span><br><span class="line">     RCWheel *(^wheelFactory)() = ^&#123;      </span><br><span class="line">          <span class="keyword">return</span> [[RCWheel alloc] init];   </span><br><span class="line">     &#125;;   </span><br><span class="line">     <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithEngine:engine</span><br><span class="line">                            transmission:transmission </span><br><span class="line">                       pitRadioFrequency:frequency</span><br><span class="line">                            wheelFactory:wheelFactory];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。</p><h2 id="五、系统单例"><a href="#五、系统单例" class="headerlink" title="五、系统单例"></a>五、系统单例</h2><p>在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。</p><p>这里建议<font color="#cc0000">避免在你的代码中创建全局的单例</font>，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。</p><h2 id="六、不可修改的构造函数"><a href="#六、不可修改的构造函数" class="headerlink" title="六、不可修改的构造函数"></a>六、不可修改的构造函数</h2><p>有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个我们不能直接调用初始化方法的例子。</span></span><br><span class="line">RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];</span><br><span class="line"><span class="comment">// 我们仍然可以使用属性来配置我们的赛车路径</span></span><br><span class="line">raceTrack.width = <span class="number">10</span>;</span><br><span class="line">raceTrack.numberOfHairpinTurns = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。</p><h2 id="七、类注册"><a href="#七、类注册" class="headerlink" title="七、类注册"></a>七、类注册</h2><p>“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * raceCarClasses = @[ [RCFastRaceCar <span class="keyword">class</span>], [RCSlowRaceCar <span class="keyword">class</span>] ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class raceCarClass <span class="keyword">in</span> raceCarClasses) &#123;   </span><br><span class="line">     <span class="comment">// 所有赛车必须有相同的初始化方法 (在这个例子中是 "init" 方法).</span></span><br><span class="line">     <span class="comment">// 这里意味着我们不能自定义不同的子类</span></span><br><span class="line">     [raceCars addObject:[[raceCarClass alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的替换方法是：使用工厂 block 来代替</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> RCRaceCar *(^RCRaceCarFactory)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * raceCarFactories = @[ ^&#123; <span class="keyword">return</span> [[RCFastRaceCar alloc] initWithTopSpeed:<span class="number">200</span>]; &#125;, </span><br><span class="line">                                ^&#123; <span class="keyword">return</span> [[RCSlowRaceCar alloc] initWithLeatherPlushiness:<span class="number">11</span>]; &#125; ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *  raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RCRaceCarFactory raceCarFactory <span class="keyword">in</span> raceCarFactories) &#123;</span><br><span class="line">    <span class="comment">// 现在这样，我们就不用关心到底是那个初始化方法被调用了</span></span><br><span class="line">    [raceCars addObject:raceCarFactory()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、Storyboards"><a href="#八、Storyboards" class="headerlink" title="八、Storyboards"></a>八、Storyboards</h2><p>Storyboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。</p><p>解决方法是<font color="#cc0000">避免使用 storyboard</font>。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。</p><h2 id="九、公有和私有"><a href="#九、公有和私有" class="headerlink" title="九、公有和私有"></a>九、公有和私有</h2><p>依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In public ObjectA.h.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(ObjectB *)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectB</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也一样：需要暴露 ObjectC.h</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectC:(ObjectC *)objectC;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectC</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(<span class="keyword">id</span> &lt;ObjectB&gt;)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个协议只暴露 ObjectA 需要原始的 ObjectB。</span></span><br><span class="line"><span class="comment">// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectB</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodNeededByObjectA;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="十、一次高效的依赖注入"><a href="#十、一次高效的依赖注入" class="headerlink" title="十、一次高效的依赖注入"></a>十、一次高效的依赖注入</h2><h4 id="10-1-问题场景"><a href="#10-1-问题场景" class="headerlink" title="10.1 问题场景"></a>10.1 问题场景</h4><p>如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ee8e7de4eb46f0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里依赖路径有两条：</p><p>①、主项目依赖第三方 pods。</p><p>②、组件依赖第三方 pods，主项目再依赖组件。</p><p><font color="#cc0000">单向的依赖关系</font>决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，<font color="#cc0000">组件却没有办法主动和主项目通讯</font>。</p><p>可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。</p><h4 id="10-2-依赖注入"><a href="#10-2-依赖注入" class="headerlink" title="10.2 依赖注入"></a>10.2 依赖注入</h4><p>依赖注入有另外一个名字，叫做“控制反转”。</p><p>像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。</p><p>所以依赖注入有两个比较重要的点：</p><p>①、要实现这种反转控制的功能。</p><p>②、要解耦。</p><blockquote><p>不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。</p><p>出自这篇文章：<a href="https://laravel-china.org/topics/2104/understanding-dependency-injection-and-inversion-of-control" target="_blank" rel="noopener">理解依赖注入与控制反转</a></p></blockquote><h4 id="10-3-iOS-依赖注入调查"><a href="#10-3-iOS-依赖注入调查" class="headerlink" title="10.3 iOS 依赖注入调查"></a>10.3 iOS 依赖注入调查</h4><p>iOS 平台实现依赖注入功能的开源项目有两个大头：<a href="https://github.com/atomicobject/objection" target="_blank" rel="noopener">objection</a>、<a href="https://github.com/appsquickly/typhoon" target="_blank" rel="noopener">typhoon</a>。</p><p>详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。</p><p>还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。</p><p>那有没有其他没那么方案呢？<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener">libextobjc</a></p><p>libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点：</p><p>①、充分使用了 OC 动态语言的特性，不侵入项目</p><p>②、高度自动化</p><p>③、框架十分轻量（只有一个 .h 和 .m 文件）</p><p>④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。</p><h4 id="10-4-EXTConcreteProtocol-实现原理"><a href="#10-4-EXTConcreteProtocol-实现原理" class="headerlink" title="10.4 EXTConcreteProtocol 实现原理"></a>10.4 EXTConcreteProtocol 实现原理</h4><p>有两个比较重要的概念需要提前明白才能继续往下讲。</p><p>①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。</p><p>②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d6694cba798f0df6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。</p><h6 id="10-4-1-EXTConcreteProtocol-的使用"><a href="#10-4-1-EXTConcreteProtocol-的使用" class="headerlink" title="10.4.1 EXTConcreteProtocol 的使用"></a>10.4.1 EXTConcreteProtocol 的使用</h6><p>比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectProtocol</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello;</span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">@concreteprotocol(ObjectProtocol)</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">ObjectProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们接下来就可以对 Person 调用注入的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     Person * p = [Person new];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [p age]);</span><br><span class="line">     [p.class sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">18</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h6 id="10-4-2-源码解析"><a href="#10-4-2-源码解析" class="headerlink" title="10.4.2 源码解析"></a>10.4.2 源码解析</h6><p>先来看一下头文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define concreteprotocol(NAME) \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a class used to contain all the methods used in this protocol</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">     <span class="comment">// 定义一个容器类</span></span><br><span class="line">    interface NAME <span class="meta">## _ProtocolMethodContainer : NSObject <span class="meta-string">&lt; NAME &gt;</span> &#123;&#125; \</span></span><br><span class="line">    <span class="keyword">@end</span> \</span><br><span class="line">    \</span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">NAME</span> ## <span class="title">_ProtocolMethodContainer</span> \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when this class is loaded into the runtime, add the concrete protocol</span></span><br><span class="line"><span class="comment">     * into the list we have of them</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// load 方法添加混合协议</span></span><br><span class="line">    + (<span class="keyword">void</span>)load &#123; \</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * passes the actual protocol as the first parameter, then this class as</span></span><br><span class="line"><span class="comment">         * the second</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        <span class="keyword">if</span> (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), <span class="keyword">self</span>)) \</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not load concrete protocol %s\n"</span>, metamacro_stringify(NAME)); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * using the "constructor" function attribute, we can ensure that this</span></span><br><span class="line"><span class="comment">     * function is executed only AFTER all the Objective-C runtime setup (i.e.,</span></span><br><span class="line"><span class="comment">     * after all +load methods have been executed)</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// 在 load 之后，main 之前执行方法注入</span></span><br><span class="line">    __attribute__((constructor)) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> ext_ <span class="meta">## NAME ## _inject (void) &#123; \</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * use this injection point to mark this concrete protocol as ready for</span></span><br><span class="line"><span class="comment">         * loading</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** implementation details follow ***/</span></span><br><span class="line"><span class="comment">// load 方法添加混合协议</span></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);</span><br><span class="line"><span class="comment">// load 之后，main 之前执行方法注入</span></span><br><span class="line"><span class="keyword">void</span> ext_loadConcreteProtocol (Protocol *protocol);</span><br></pre></td></tr></table></figure><p>可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。</p><p>然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contains the information needed to reference a full special protocol</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the actual protocol declaration (@protocol block)  用户定义的协议.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the injection block associated with this protocol</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this block is RETAINED and must eventually be released by transferring it</span></span><br><span class="line">    <span class="comment">// back to ARC</span></span><br><span class="line">    <span class="comment">// 在 __attribute__((constructor)) 时往指定类里注入方法的 block.</span></span><br><span class="line">    <span class="keyword">void</span> *injectionBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// whether this protocol is ready to be injected to its conforming classes</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this does NOT refer to a special protocol having been injected already</span></span><br><span class="line">    <span class="comment">// 对应的协议是否已经准备好注入.</span></span><br><span class="line">    <span class="built_in">BOOL</span> ready;</span><br><span class="line">&#125; EXTSpecialProtocol;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123;</span><br><span class="line">        ext_injectConcreteProtocol(protocol, containerClass, destinationClass);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_loadSpecialProtocol (Protocol *protocol, <span class="keyword">void</span> (^injectionBehavior)(Class destinationClass)) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(injectionBehavior != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work    加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if we've hit the hard maximum for number of special protocols, we can't</span></span><br><span class="line">        <span class="comment">// continue</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount == SIZE_MAX) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the array has no more space, we will need to allocate additional</span></span><br><span class="line">        <span class="comment">// entries</span></span><br><span class="line">        <span class="comment">// specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols.</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount &gt;= specialProtocolCapacity) &#123;</span><br><span class="line">            size_t newCapacity;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocolCapacity == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// if there are no entries, make space for just one</span></span><br><span class="line">                newCapacity = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// otherwise, double the current capacity</span></span><br><span class="line">                newCapacity = specialProtocolCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if the new capacity is less than the current capacity, that's</span></span><br><span class="line">                <span class="comment">// unsigned integer overflow</span></span><br><span class="line">                <span class="keyword">if</span> (newCapacity &lt; specialProtocolCapacity) &#123;</span><br><span class="line">                    <span class="comment">// set it to the maximum possible instead</span></span><br><span class="line">                    newCapacity = SIZE_MAX;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// if the new capacity is still not greater than the current</span></span><br><span class="line">                    <span class="comment">// (for instance, if it was already SIZE_MAX), we can't continue</span></span><br><span class="line">                    <span class="keyword">if</span> (newCapacity &lt;= specialProtocolCapacity) &#123;</span><br><span class="line">                        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we have a new capacity, so resize the list of all special protocols</span></span><br><span class="line">            <span class="comment">// to add the new entries</span></span><br><span class="line">            <span class="keyword">void</span> * restrict ptr = realloc(specialProtocols, <span class="keyword">sizeof</span>(*specialProtocols) * newCapacity);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">                <span class="comment">// the allocation failed, abort</span></span><br><span class="line">                pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            specialProtocols = ptr;</span><br><span class="line">            specialProtocolCapacity = newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// at this point, there absolutely must be at least one empty entry in the</span></span><br><span class="line">        <span class="comment">// array</span></span><br><span class="line">        assert(specialProtocolCount &lt; specialProtocolCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// disable warning about "leaking" this block, which is released in</span></span><br><span class="line">        <span class="comment">// ext_injectSpecialProtocols()</span></span><br><span class="line">        <span class="meta">#ifndef __clang_analyzer__</span></span><br><span class="line">        ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// construct a new EXTSpecialProtocol structure and add it to the first</span></span><br><span class="line">        <span class="comment">// empty space in the array</span></span><br><span class="line">        <span class="comment">// 将协议保存为一个 EXTSpecialProtocol 结构体。</span></span><br><span class="line">        specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123;</span><br><span class="line">            .protocol = protocol,</span><br><span class="line">            .injectionBlock = (__bridge_retained <span class="keyword">void</span> *)copiedBlock,</span><br><span class="line">            .ready = <span class="literal">NO</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">        ++specialProtocolCount;</span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。</p><p>ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class <span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="comment">// get the full list of instance methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的实例方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> imethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the full list of class methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的类方法方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> cmethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// get the metaclass of this class (the object on which class</span></span><br><span class="line">    <span class="comment">// methods are implemented)  拿到要注入方法的类的元类.</span></span><br><span class="line">    Class metaclass = object_getClass(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all instance methods in the concrete protocol   注入实例方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; imethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = imethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if such an instance method already exists</span></span><br><span class="line">        <span class="comment">// (on this class or on a superclass)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(<span class="keyword">class</span>, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this instance method to the class in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(<span class="keyword">class</span>, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all class methods in the concrete protocol   注入类方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; cmethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = cmethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +initialize is a special case that should never be copied</span></span><br><span class="line">        <span class="comment">// into a class, as it performs initialization for the concrete</span></span><br><span class="line">        <span class="comment">// protocol</span></span><br><span class="line">        <span class="comment">// +initialize 不能被注入.</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">@selector</span>(initialize)) &#123;</span><br><span class="line">            <span class="comment">// so just continue looking through the rest of the methods</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if a class method already exists (on this</span></span><br><span class="line">        <span class="comment">// class or on a superclass)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// since 'class' is considered to be an instance of 'metaclass',</span></span><br><span class="line">        <span class="comment">// this is actually checking for class methods (despite the</span></span><br><span class="line">        <span class="comment">// function name)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(metaclass, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this class method to the metaclass in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(metaclass, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the instance method list  管理内存</span></span><br><span class="line">    free(imethodList); imethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the class method list</span></span><br><span class="line">    free(cmethodList); cmethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use [containerClass class] and discard the result to call +initialize</span></span><br><span class="line">    <span class="comment">// on containerClass if it hasn't been called yet</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this is to allow the concrete protocol to perform custom initialization</span></span><br><span class="line">    <span class="comment">// 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行.</span></span><br><span class="line">    (<span class="keyword">void</span>)[containerClass <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ext_specialProtocolReadyForInjection (Protocol *protocol) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work   加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through all the special protocols in our list, trying to find the</span></span><br><span class="line">        <span class="comment">// one associated with 'protocol'</span></span><br><span class="line">        <span class="comment">// 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocols[i].protocol == protocol) &#123;</span><br><span class="line">                <span class="comment">// found the matching special protocol, check to see if it's</span></span><br><span class="line">                <span class="comment">// already ready</span></span><br><span class="line">                <span class="keyword">if</span> (!specialProtocols[i].ready) &#123;</span><br><span class="line">                    <span class="comment">// if it's not, mark it as being ready now</span></span><br><span class="line">                    specialProtocols[i].ready = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// since this special protocol was in our array, and it was not</span></span><br><span class="line">                    <span class="comment">// loaded, the total number of protocols loaded must be less</span></span><br><span class="line">                    <span class="comment">// than the total count at this point in time</span></span><br><span class="line">                    assert(specialProtocolsReady &lt; specialProtocolCount);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ... and then increment the total number of special protocols</span></span><br><span class="line">                    <span class="comment">// loaded – if it now matches the total count of special</span></span><br><span class="line">                    <span class="comment">// protocols, begin the injection process</span></span><br><span class="line">                    <span class="keyword">if</span> (++specialProtocolsReady == specialProtocolCount)</span><br><span class="line">                        <span class="comment">// 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入.</span></span><br><span class="line">                        ext_injectSpecialProtocols();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是准备工作，接下来开始进入核心方法进行注入。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function actually performs the hard work of special protocol injection.</span></span><br><span class="line"><span class="comment"> * It obtains a full list of all classes registered with the Objective-C</span></span><br><span class="line"><span class="comment"> * runtime, finds those conforming to special protocols, and then runs the</span></span><br><span class="line"><span class="comment"> * injection blocks as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectSpecialProtocols (<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don't lock specialProtocolsLock in this function, as it is called only</span></span><br><span class="line"><span class="comment">     * from public functions which already perform the synchronization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This will sort special protocols in the order they should be loaded. If</span></span><br><span class="line"><span class="comment">     * a special protocol conforms to another special protocol, the former</span></span><br><span class="line"><span class="comment">     * will be prioritized above the latter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对协议进行排序.</span></span><br><span class="line">    <span class="comment">// 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的  load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现.</span></span><br><span class="line">    <span class="comment">// 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面.</span></span><br><span class="line">    qsort_b(specialProtocols, specialProtocolCount, <span class="keyword">sizeof</span>(EXTSpecialProtocol), ^(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)&#123;</span><br><span class="line">        <span class="comment">// if the pointers are equal, it must be the same protocol</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoA = a;</span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoB = b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A higher return value here means a higher priority</span></span><br><span class="line">        <span class="keyword">int</span> (^protocolInjectionPriority)(<span class="keyword">const</span> EXTSpecialProtocol *) = ^(<span class="keyword">const</span> EXTSpecialProtocol *specialProtocol)&#123;</span><br><span class="line">            <span class="keyword">int</span> runningTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">                <span class="comment">// the pointer passed into this block is guaranteed to point</span></span><br><span class="line">                <span class="comment">// into the 'specialProtocols' array, so we can compare the</span></span><br><span class="line">                <span class="comment">// pointers directly for identity</span></span><br><span class="line">                <span class="keyword">if</span> (specialProtocol == specialProtocols + i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol))</span><br><span class="line">                    runningTotal++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> runningTotal;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will return:</span></span><br><span class="line"><span class="comment">         * 0 if the protocols are equal in priority (such that load order does not matter)</span></span><br><span class="line"><span class="comment">         * &lt; 0 if A is more important than B</span></span><br><span class="line"><span class="comment">         * &gt; 0 if B is more important than A</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取项目中所有的类</span></span><br><span class="line">    <span class="keyword">unsigned</span> classCount = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!classCount) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: No classes registered with the runtime\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Class *allClasses = (Class *)malloc(<span class="keyword">sizeof</span>(Class) * (classCount + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!allClasses) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: Could not allocate space for %u classes\n"</span>, classCount);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use this instead of ext_copyClassList() to avoid sending +initialize to</span></span><br><span class="line"><span class="comment">// classes that we don't plan to inject into (this avoids some SenTestingKit</span></span><br><span class="line"><span class="comment">// timing issues)</span></span><br><span class="line">classCount = objc_getClassList(allClasses, classCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set up an autorelease pool in case any Cocoa classes get used during</span></span><br><span class="line"><span class="comment">     * the injection process or +initialize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// loop through the special protocols, and apply each one to all the</span></span><br><span class="line">        <span class="comment">// classes in turn</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in</span></span><br><span class="line">        <span class="comment">// the order in which they appear in specialProtocols. Consider classes</span></span><br><span class="line">        <span class="comment">// X and Y that implement protocols A and B, respectively. B needs to get</span></span><br><span class="line">        <span class="comment">// its implementation into Y before A gets into X.</span></span><br><span class="line">        <span class="comment">// 遍历所有的要注入的协议结构体.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            Protocol *protocol = specialProtocols[i].protocol;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// transfer ownership of the injection block to ARC and remove it</span></span><br><span class="line">            <span class="comment">// from the structure</span></span><br><span class="line">            <span class="comment">// 使用 __bridge_transfer 把对象的内存管理交给 ARC.</span></span><br><span class="line">            ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer <span class="keyword">id</span>)specialProtocols[i].injectionBlock;</span><br><span class="line">            specialProtocols[i].injectionBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop through all classes   遍历所有的类</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> classIndex = <span class="number">0</span>;classIndex &lt; classCount;++classIndex) &#123;</span><br><span class="line">                Class <span class="keyword">class</span> = allClasses[classIndex];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// if this class doesn't conform to the protocol, continue to the</span></span><br><span class="line">                <span class="comment">// next class immediately</span></span><br><span class="line">                <span class="comment">// 如果这个类遵守了要注入的协议，那么就执行注入</span></span><br><span class="line">                <span class="comment">// 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法.</span></span><br><span class="line">                <span class="keyword">if</span> (!class_conformsToProtocol(<span class="keyword">class</span>, protocol))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                injectionBlock(<span class="keyword">class</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理内存.</span></span><br><span class="line">    <span class="comment">// free the allocated class list</span></span><br><span class="line">    free(allClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that everything's injected, the special protocol list can also be</span></span><br><span class="line">    <span class="comment">// destroyed</span></span><br><span class="line">    free(specialProtocols); specialProtocols = <span class="literal">NULL</span>;</span><br><span class="line">    specialProtocolCount = <span class="number">0</span>;</span><br><span class="line">    specialProtocolCapacity = <span class="number">0</span>;</span><br><span class="line">    specialProtocolsReady = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 </p><h6 id="10-4-3-问题在哪？"><a href="#10-4-3-问题在哪？" class="headerlink" title="10.4.3 问题在哪？"></a>10.4.3 问题在哪？</h6><p>接下来讨论 EXTConcreteProtocol 的缺点。</p><p>如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。</p><p>这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。</p><p>这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。</p><h4 id="10-5-解决方案"><a href="#10-5-解决方案" class="headerlink" title="10.5 解决方案"></a>10.5 解决方案</h4><p>从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。</p><p>那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。</p><p>但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。</p><p>如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f80ece7045a2e25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。</p><p>②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。</p><p>③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。</p><p>④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。</p><p><a href="https://github.com/newyjp/BLMethodInjecting" target="_blank" rel="noopener">https://github.com/newyjp/BLMethodInjecting</a></p><h2 id="十一、结语"><a href="#十一、结语" class="headerlink" title="十一、结语"></a>十一、结语</h2><p>依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。</p><h2 id="十二、文章"><a href="#十二、文章" class="headerlink" title="十二、文章"></a>十二、文章</h2><p><a href="https://blog.csdn.net/linshaolie/article/details/47037941" target="_blank" rel="noopener">依赖注入——让iOS代码更简洁</a></p><p><a href="https://blog.csdn.net/Px01Ih8/article/details/84207382" target="_blank" rel="noopener">[iOS]一次高效的依赖注入</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。&lt;/
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>利用预渲染加速iOS设备的图像显示</title>
    <link href="http://yoursite.com/2019/05/23/%E5%88%A9%E7%94%A8%E9%A2%84%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9FiOS%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/05/23/利用预渲染加速iOS设备的图像显示/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-07-11T11:04:07.666Z</updated>
    
    <content type="html"><![CDATA[<p>使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。</p><p>于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。</p><p>接着下面举个例子程序来验证：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> * image;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ImageView.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;mach/mach_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGRect</span> imageRect = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ImageView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">self</span>.image) &#123;</span><br><span class="line">          <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     [superawakeFromNib];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">CGRectContainsRect</span>(rect, imageRect)) &#123;</span><br><span class="line"> </span><br><span class="line">          uint64_t start = getTickCount();</span><br><span class="line"></span><br><span class="line">          [<span class="keyword">self</span>.image drawInRect:imageRect];</span><br><span class="line"></span><br><span class="line">          uint64_t drawTime = getTickCount() - start;</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%llu"</span>, drawTime);  <span class="comment">// 打印时间间隔    </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。</span></span><br><span class="line">uint64_t getTickCount(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">static</span> mach_timebase_info_data_t sTimebaseInfo;</span><br><span class="line"></span><br><span class="line">     uint64_t machTime = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Convert to nanoseconds - if this is the first time we've run, get the timebase.</span></span><br><span class="line">    <span class="keyword">if</span> (sTimebaseInfo.denom == <span class="number">0</span>) &#123;</span><br><span class="line">         (<span class="keyword">void</span>)mach_timebase_info(&amp;sTimebaseInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom;  <span class="comment">// 纳秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> millis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>测试用一张 1838 * 890 的图</p><p>2018-07-05 11:05:25.950978+0800 Demo[5831:113872] <font color="#cc0000">31802012</font></p><p>接下来就是见证奇迹的时刻了，把这段代码加入程序：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGSize</span> imageSize = &#123;<span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">self</span>.image) &#123;</span><br><span class="line">          <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 由于JPEG图像是不透明的，所以第二个参数就设为YES</span></span><br><span class="line">          <span class="comment">// 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了</span></span><br><span class="line">          <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageSize, <span class="literal">YES</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="comment">// 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作</span></span><br><span class="line">          [image drawInRect:imageRect];</span><br><span class="line">          <span class="keyword">self</span>.image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">          <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。</p><p>时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] <font color="#cc0000">127939</font>，缩短了很多。</p><p>还能更快吗？让我们来试试 Core Graphics。</p><p>先定义一个全局的 CGImageRef 变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CGImageRef</span> imageRef;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib</span><br><span class="line">&#123;</span><br><span class="line">    imageRef = <span class="keyword">self</span>.image.CGImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">     CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">     CGContextDrawImage(context, imageRect, imageRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] <font color="#cc0000">27425265</font>，而且图像还上下颠倒了⋯</p><p>这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br></pre></td></tr></table></figure><p>这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] <font color="#cc0000">34242146</font>，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。&lt;/p&gt;
&lt;p&gt;于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Pe
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>UITableView优化</title>
    <link href="http://yoursite.com/2019/05/23/UITableView%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/23/UITableView优化/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-07-11T10:58:20.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Cell-复用"><a href="#一、Cell-复用" class="headerlink" title="一、Cell 复用"></a>一、Cell 复用</h2><p>在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 </p><p><font color="#008200">解决方案</font>：创建一个<font color="#cc0000">静态变量</font> reuseID，防止重复创建（提高性能），使用系统的缓存池功能。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * CELL_RUID = <span class="string">@"CELL"</span>;  <span class="comment">// 调用次数太多，static 保证只创建一次 reuseID，提高性能</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存池中取已经创建的 cell</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID</span><br><span class="line">                                                             forIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;  <span class="comment">// Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.</span></span><br><span class="line">- (__kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier forIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0); <span class="comment">// newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered</span></span><br></pre></td></tr></table></figure><p><font color="#cc0000">复用 Cell 时 不会调用 awakeFromNib</font>。</p><ul><li>获取方法的区别</li></ul><p>dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard'</span><br></pre></td></tr></table></figure><p>dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to obtain a cell from its dataSource</span><br></pre></td></tr></table></figure><p>判断 nil 后可以自己创建 cell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot;];</span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么需要 forIndexPath:</li></ul><p>因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。</p><p>我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。</p><p>注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。</p><h2 id="二、定义一种（尽量少）类型的-Cell-及善用-hidden-隐藏（显示）subviews"><a href="#二、定义一种（尽量少）类型的-Cell-及善用-hidden-隐藏（显示）subviews" class="headerlink" title="二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews"></a>二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews</h2><p>分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的<font color="#cc0000">数量不会很多</font>，完全可以接受的。</p><p>好处：</p><p>①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（<font color="#cc0000">多个 Cell 不是更容易维护？</font>）</p><p>②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。</p><p>既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。</p><p>尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。</p><h2 id="三、提前计算并缓存-Cell-的高度"><a href="#三、提前计算并缓存-Cell-的高度" class="headerlink" title="三、提前计算并缓存 Cell 的高度"></a>三、提前计算并缓存 Cell 的高度</h2><h4 id="3-1-固定高度的-cell"><a href="#3-1-固定高度的-cell" class="headerlink" title="3.1 固定高度的 cell"></a>3.1 固定高度的 cell</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="number">88</span>;</span><br></pre></td></tr></table></figure><p>直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。</p><h4 id="3-2-动态高度的-cell"><a href="#3-2-动态高度的-cell" class="headerlink" title="3.2 动态高度的 cell"></a>3.2 动态高度的 cell</h4><p>实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。</p><p>tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。</p><p><font color="#008200">解决方案</font>：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;  <span class="comment">// Cell 高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  计算高度</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">- (<span class="keyword">void</span>)calculateCellHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。</p><p>还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。</p><h2 id="四、异步绘制（自定义-Cell-绘制）"><a href="#四、异步绘制（自定义-Cell-绘制）" class="headerlink" title="四、异步绘制（自定义 Cell 绘制）"></a>四、异步绘制（自定义 Cell 绘制）</h2><p>遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。<a href="http://www.cocoachina.com/ios/20150602/11968.html" target="_blank" rel="noopener">详细整理：UITableView 优化技巧</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  cell 添加 draw 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)draw</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异步绘制</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  @brief  重写 drawRect: 方法 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。</p><h2 id="五、滑动时，按需加载"><a href="#五、滑动时，按需加载" class="headerlink" title="五、滑动时，按需加载"></a>五、滑动时，按需加载</h2><p>自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (needLoadArr.count &gt; <span class="number">0</span> &amp;&amp; [needLoadArr indexOfObject:indexPath] == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">         [cell clear];  <span class="comment">// 清掉内容</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> * ip  = [<span class="keyword">self</span>.tableView indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> * cip = [[<span class="keyword">self</span>.tableView indexPathsForVisibleRows] firstObject];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -8 &lt; 当前位置 - 目标位置 &lt; 8</span></span><br><span class="line">    <span class="keyword">if</span> (labs(cip.row - ip.row) &gt; skipCount) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标区域的 cell 的 indexPaths</span></span><br><span class="line">        <span class="built_in">NSArray</span> * temp = [<span class="keyword">self</span>.tableView indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.tableView.frame.size.width, <span class="keyword">self</span>.tableView.frame.size.height)];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableArray</span> * arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> * indexPath = [temp lastObject];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (indexPath.row + <span class="number">33</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p><h2 id="六、缓存-View"><a href="#六、缓存-View" class="headerlink" title="六、缓存 View"></a>六、缓存 View</h2><p>当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。</p><h2 id="七、尽量显示“大小刚好合适的”图片资源"><a href="#七、尽量显示“大小刚好合适的”图片资源" class="headerlink" title="七、尽量显示“大小刚好合适的”图片资源"></a>七、尽量显示“大小刚好合适的”图片资源</h2><p>避免大量的图片缩放、颜色渐变等。</p><h2 id="八、避免同步的从网络、文件获取数据"><a href="#八、避免同步的从网络、文件获取数据" class="headerlink" title="八、避免同步的从网络、文件获取数据"></a>八、避免同步的从网络、文件获取数据</h2><p>Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。</p><h2 id="九、渲染"><a href="#九、渲染" class="headerlink" title="九、渲染"></a>九、渲染</h2><p>1、减少 subviews 的个数和层级</p><pre><code>子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。</code></pre><p>2、少用 subviews 的透明图层</p><pre><code>渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。</code></pre><p>3、背景色不要使用 clearColor</p><p>4、避免 CALayer 特效（shadowPath）</p><pre><code>给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：</code></pre><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor   = color.CGColor;</span><br><span class="line">view.layer.shadowOffset  = offset;</span><br><span class="line">view.layer.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">view.layer.shadowRadius  = radius;</span><br></pre></td></tr></table></figure><p>5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>UITableView 的优化主要从四个方面入手：</p><p>1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法；</p><p>2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage；</p><p>3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；</p><p>4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。</p><p>大概需要关注的：</p><p>1、cell 复用</p><p>2、cell 高度的计算</p><p>3、渲染（混合问题）</p><p>4、减少视图的数目（重写 drawRect:）</p><p>5、减少多余的绘制操作</p><p>6、不要给 cell 动态添加 subView</p><p>7、异步化 UI，不要阻塞主线程</p><p>8、滑动时按需加载对应的内容</p><h2 id="十一、资料"><a href="#十一、资料" class="headerlink" title="十一、资料"></a>十一、资料</h2><p>图片加载优化官方 Demo：<a href="https://developer.apple.com/library/archive/samplecode/LazyTableImages/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009394-Intro-DontLinkElementID_2" target="_blank" rel="noopener">LazyTableImages</a></p><p>文章：<a href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">提升 UITableView 性能-复杂页面的优化</a></p><p>代码：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Cell-复用&quot;&gt;&lt;a href=&quot;#一、Cell-复用&quot; class=&quot;headerlink&quot; title=&quot;一、Cell 复用&quot;&gt;&lt;/a&gt;一、Cell 复用&lt;/h2&gt;&lt;p&gt;在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 &lt;
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>图片设置圆角性能问题</title>
    <link href="http://yoursite.com/2019/05/23/%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/23/图片设置圆角性能问题/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-07-11T11:13:02.854Z</updated>
    
    <content type="html"><![CDATA[<p>通常设置圆角方式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageView.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line">imageView.layer.cornerRadius = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。</p><p>注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。</p><h2 id="一、设置圆角的方法"><a href="#一、设置圆角的方法" class="headerlink" title="一、设置圆角的方法"></a>一、设置圆角的方法</h2><p>①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。</p><p>②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageView.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line">imageView.layer.cornerRadius = <span class="number">50</span>;</span><br><span class="line">imageView.layer.shouldRasterize = <span class="literal">YES</span>;  <span class="comment">// 设置光栅化</span></span><br><span class="line">imageView.layer.rasterizationScale = [<span class="built_in">UIScreen</span> mainScreen].scale;  <span class="comment">// UIImageView 不加这句会产生一点模糊</span></span><br></pre></td></tr></table></figure><p><font color="#cc0000">设置光栅化可以使离屏渲染的结果缓存到内存中存为位图</font>，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。</p><p>但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p><p>③、直接覆盖一张中间为圆形透明的图片（推荐使用）</p><p>这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。</p><p>这种圆片覆盖的方法一般只用在<font color="#cc0000">底色为纯色</font>的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色）</p><p>④、UIImage drawInRect 绘制圆角</p><p>这种方式 GPU 损耗低内存占用大。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CornerImageView</span> ()</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">NSBlockOperation</span> * _operation;  <span class="comment">// 任务 </span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> * _queue;  </span><br><span class="line">    <span class="built_in">UIImage</span> * _cornerImage;  <span class="comment">// 圆角化的图片</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CornerImageView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        _queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写设置方法。如果是 UIButton 可以换成 setImage:forState:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setImage:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> roundedImage:image];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)roundedImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    [_queue cancelAllOperations];</span><br><span class="line"></span><br><span class="line">    [_operation cancel];</span><br><span class="line">    _operation = <span class="literal">nil</span>;</span><br><span class="line">    _operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">false</span>, [<span class="built_in">UIScreen</span> mainScreen].scale);</span><br><span class="line">        <span class="comment">// Add a clip before drawing anything, in the shape of an rounded rect</span></span><br><span class="line">        [[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds</span><br><span class="line">                                    cornerRadius:<span class="keyword">self</span>.bounds.size.height / <span class="number">2</span>] addClip];</span><br><span class="line">        [image drawInRect:<span class="keyword">self</span>.bounds];</span><br><span class="line">        </span><br><span class="line">        _cornerImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Lets forget about that we were drawing</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!_operation) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [<span class="keyword">super</span> setImage:_cornerImage];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [_queue addOperation:_operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。</p><p>问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？</p><p>⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImage</span> (<span class="title">corner</span>)</span></span><br><span class="line">+ (<span class="keyword">id</span>)createRoundedRectImage:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">corner</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRoundedRectToPath(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGRect</span> rect, <span class="keyword">float</span> ovalWidth, <span class="keyword">float</span> ovalHeight)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> fw, fh;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ovalWidth == <span class="number">0</span> || ovalHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGContextAddRect</span>(context, rect);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextSaveGState</span>(context);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="built_in">CGRectGetMinX</span>(rect), <span class="built_in">CGRectGetMinY</span>(rect));</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, ovalWidth, ovalHeight);</span><br><span class="line">    fw = <span class="built_in">CGRectGetWidth</span>(rect) / ovalWidth;</span><br><span class="line">    fh = <span class="built_in">CGRectGetHeight</span>(rect) / ovalHeight;  <span class="comment">// 使的圆角半径为 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, fw, fh/<span class="number">2</span>);  <span class="comment">// Start at lower right corner</span></span><br><span class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, fw, fh, fw/<span class="number">2</span>, fh, <span class="number">1</span>);  <span class="comment">// Top right corner</span></span><br><span class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">0</span>, fh, <span class="number">0</span>, fh/<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// Top left corner</span></span><br><span class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, <span class="number">0</span>, <span class="number">0</span>, fw/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// Lower left corner</span></span><br><span class="line">    <span class="built_in">CGContextAddArcToPoint</span>(context, fw, <span class="number">0</span>, fw, fh/<span class="number">2</span>, <span class="number">1</span>); <span class="comment">// Back to lower right</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextClosePath</span>(context);</span><br><span class="line">    <span class="built_in">CGContextRestoreGState</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)createRoundedRectImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> wh = MIN(MAX(image.size.width, image.size.height), <span class="number">160</span>);</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(wh, wh);</span><br><span class="line">    <span class="built_in">CGfloat</span> radius = wh / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>( <span class="literal">NULL</span>, </span><br><span class="line">                                                  wh, </span><br><span class="line">                                                  wh, </span><br><span class="line">                                                  <span class="number">8</span>, </span><br><span class="line">                                                  <span class="number">4</span> * wh, </span><br><span class="line">                                                  <span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), </span><br><span class="line">                                                  kCGImageAlphaPremultipliedFirst );</span><br><span class="line">    <span class="comment">// 绘制圆角    </span></span><br><span class="line">    <span class="built_in">CGContextBeginPath</span>(context);</span><br><span class="line">    </span><br><span class="line">    addRoundedRectToPath(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, wh, wh), radius, radius);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextClosePath</span>(context);</span><br><span class="line">    <span class="built_in">CGContextClip</span>(context);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, w, h), img.CGImage);</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageMasked = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    image = [<span class="built_in">UIImage</span> imageWithCGImage:imageMasked];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageMasked);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 '(x1，y1)' 的直线相切，与 '(x1，y1)' 到 '(x2, y2)' 的直线相切。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="keyword">void</span> <span class="built_in">CGContextAddArcToPoint</span>(<span class="built_in">CGContextRef</span> cg_nullable c,</span><br><span class="line">    <span class="built_in">CGFloat</span> x1, <span class="built_in">CGFloat</span> y1, <span class="built_in">CGFloat</span> x2, <span class="built_in">CGFloat</span> y2, <span class="built_in">CGFloat</span> radius)</span><br><span class="line">    <span class="built_in">CG_AVAILABLE_STARTING</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><h2 id="二、使用-Instruments-的-Core-Animation-查看性能"><a href="#二、使用-Instruments-的-Core-Animation-查看性能" class="headerlink" title="二、使用 Instruments 的 Core Animation 查看性能"></a>二、使用 Instruments 的 Core Animation 查看性能</h2><ul><li>Color Offscreen-Rendered Yellow</li></ul><pre><code>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</code></pre><ul><li><p>Color Hits Green and Misses Red</p><p>如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p></li></ul><p>用 Instruments 测试得：</p><p>①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。</p><p>②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。</p><p>③、添加圆形透明图片，无任何高亮，说明没离屏渲染。</p><p>④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大）</p><p>⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法)</p><h2 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h2><p>①、有提到还有一种 mask 方法。 </p><p>这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考<a href="https://link.jianshu.com/?t=http://www.cocoachina.com/ios/20150803/12873.html" target="_blank" rel="noopener">小心别让圆角成了你列表的帧数杀手</a>。</p><p>②、第四种比第一种更卡。</p><p>第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。</p><p> 可以用 Instruments的 GPU Driver 进行测试：</p><ul><li><p>Renderer Utilization 如果这个值 &gt; 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。</p></li><li><p>Tiler Utilization     如果这个值 &gt; 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9f4398579f83477e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。</p><p>第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。</p><p><font color="#cc0000">帧率越接近 60 滑动越顺畅</font>。</p><p>发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。</p><p>如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。</p><p>而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。</p><p>所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。</p><h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><ul><li><p><a href="https://link.jianshu.com/?t=http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=447105405&amp;idx=1&amp;sn=054dc54289a98e8a39f2b9386f4f620e&amp;scene=0#wechat_redirect" target="_blank" rel="noopener">内存恶鬼drawRect - 谈画图功能的内存优化</a></p></li><li><p>github 绘制圆角源码参考 <a href="https://link.jianshu.com/?t=https://github.com/NZN/NZCircularImageView" target="_blank" rel="noopener">NZCircularImageView</a>、<a href="https://github.com/panghaijiao/HJCornerRadius" target="_blank" rel="noopener">HJCornerRadius</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常设置圆角方式&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>0-1 背包</title>
    <link href="http://yoursite.com/2019/05/23/01-%E8%83%8C%E5%8C%85/"/>
    <id>http://yoursite.com/2019/05/23/01-背包/</id>
    <published>2019-05-23T10:19:03.934Z</published>
    <updated>2019-07-11T05:01:57.543Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p><img src="https://upload-images.jianshu.io/upload_images/5294842-171c0d1ec913da7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>01 背包问题是用来介绍动态规划算法最经典的例子。</p><h2 id="一、解释-1"><a href="#一、解释-1" class="headerlink" title="一、解释 1"></a>一、解释 1</h2><p><strong>①、状态方程</strong></p><font color="#cc0000">f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] }  ( j &gt;= Wi )</font><p>f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。</p><p>决策：为了背包中物品总价值最大化，<strong>第 i 件物品应该放入背包中吗</strong> ？</p><p><strong>②、实例</strong></p><p>假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f2981baf260f8184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。</p><p>首先要明确<font color="#cc0000">这张表是至底向上，从左到右生成的</font>。</p><p>用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。</p><p>对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。</p><p>同理 c2 = 0，b2 = 3，a2 = 6。</p><p><strong>对于承重为 8 的背包，a8 = 15 是怎么得出的呢？</strong></p><p>根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。</p><p>f[i-1, j]        表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。</p><p>f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。</p><p>Pi 指的是 a 物品的价值，即 6。</p><p>由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。</p><p><strong>③、代码</strong></p><p>物品信息类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface PackageItem : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@property (nonatomic, assign) NSInteger weight;</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation PackageItem</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.name = name;</span><br><span class="line">        self.weight = weight;</span><br><span class="line">        self.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>非递归代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    NSArray * nameArr   = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ];</span><br><span class="line">    NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ];</span><br><span class="line">    NSArray * valueArr  = @[ @(6), @(3), @(5), @(4), @(6) ];</span><br><span class="line">    NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH];</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; nameArr.count; i++) &#123;</span><br><span class="line">        PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i]</span><br><span class="line">                                                        weight:[weightArr[i] integerValue]</span><br><span class="line">                                                         value:[valueArr[i] integerValue]];</span><br><span class="line">        bagItems[i] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self packageAlgorithm:bagItems bagSize:10];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *  @brief   01 背包算法</span><br><span class="line">  */</span><br><span class="line">- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize</span><br><span class="line">&#123;</span><br><span class="line">    if (bagSize == 0 || bagItems.count == 0)  return;</span><br><span class="line">    </span><br><span class="line">    NSInteger bagMatrix[bagSize][bagItems.count];  // 是否选中数组</span><br><span class="line">    PackageItem * item;</span><br><span class="line">    NSInteger i = 0; // 背包容量，列数</span><br><span class="line">    NSInteger j = 0; // 物品数量，行数</span><br><span class="line">    </span><br><span class="line">    // 初始化数组</span><br><span class="line">    for (; i &lt;= bagSize; i++) &#123;</span><br><span class="line">        for (j = 0; j &lt; bagItems.count; j++)</span><br><span class="line">            bagMatrix[i][j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 打印二维数组内容</span><br><span class="line">    for (j = 0; j &lt; bagItems.count; j++) &#123;</span><br><span class="line">        for (i = 0; i &lt;= bagSize; i++)</span><br><span class="line">            printf(&quot;%ld    &quot;, (long)bagMatrix[i][j]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt;= bagSize; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取</span><br><span class="line">        for (j = bagItems.count - 1; j &gt; -1; j--) &#123;</span><br><span class="line">            </span><br><span class="line">            item = bagItems[j];</span><br><span class="line">            </span><br><span class="line">            // 装不下</span><br><span class="line">            if (item.weight &gt; i) &#123;</span><br><span class="line"></span><br><span class="line">                // 价值总和为 0</span><br><span class="line">                if (j == bagItems.count - 1) &#123;</span><br><span class="line">                    bagMatrix[i][j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // 价值总和为之前项的和</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1</span><br><span class="line">                    bagMatrix[i][j] = bagMatrix[i][j+1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 能装下</span><br><span class="line">            else &#123;</span><br><span class="line"></span><br><span class="line">                // 是第一个物品，保存起来</span><br><span class="line">                if (j == bagItems.count - 1) &#123;</span><br><span class="line">                    bagMatrix[i][j] = item.value;</span><br><span class="line">                &#125;</span><br><span class="line">                // 非第一个物品，求最大值</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1</span><br><span class="line">                    bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 打印二维数组内容</span><br><span class="line">    for (j = 0; j &lt; bagItems.count; j++) &#123;</span><br><span class="line">        for (i = 0; i &lt;= bagSize; i++)</span><br><span class="line">            printf(&quot;%ld    &quot;, (long)bagMatrix[i][j]);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger curSize = bagSize; // 当前能装的空间</span><br><span class="line">    NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count];</span><br><span class="line">    </span><br><span class="line">    // 以 a、b、c、d、e 的顺序获取</span><br><span class="line">    for (j = 0; j &lt; bagItems.count; j++) &#123;</span><br><span class="line">        </span><br><span class="line">        item = bagItems[j];</span><br><span class="line">        </span><br><span class="line">        // 剩下能装的空间为 0</span><br><span class="line">        if (curSize == 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据变换公式从上至下获得物品</span><br><span class="line">        if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123;</span><br><span class="line">            [answer addObject:item.name];</span><br><span class="line">            curSize -= item.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">0    0    0    0    0    0    0    0    0    0    0    </span><br><span class="line">0    0    0    0    0    0    0    0    0    0    0    </span><br><span class="line">0    0    0    0    0    0    0    0    0    0    0    </span><br><span class="line">0    0    0    0    0    0    0    0    0    0    0    </span><br><span class="line">0    0    0    0    0    0    0    0    0    0    0    </span><br><span class="line"></span><br><span class="line">0    0    6    6    9    9    12    12    15    15    15    </span><br><span class="line">0    0    3    3    6    6    9     9     9     10    11    </span><br><span class="line">0    0    0    0    6    6    6     6     6     10    11    </span><br><span class="line">0    0    0    0    6    6    6     6     6     10    10    </span><br><span class="line">0    0    0    0    6    6    6     6     6     6     6</span><br><span class="line">  </span><br><span class="line">2019-01-25 22:12:03.795695+0800 Demo[1750:32295] (</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    e</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="二、解释-2"><a href="#二、解释-2" class="headerlink" title="二、解释 2"></a>二、解释 2</h2><p><strong>①、状态方程</strong></p><font color="#cc0000">max.F(n,C,x).   x∈0,1</font><p>展开公式：</p><font color="#cc0000">F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn   x1∗w1 + x2∗w2 + … + xn∗wn ≤ C  xi∈0,1</font><p>x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。</p><p>我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够<font color="#cc0000">自动组合 x 的取值使得 F(n,c,x) 达到最大</font>。</p><p>再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。</p><p>如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。</p><p>B(n, C) = B(n−1, C);   没有多余的空间去放置最后一个物品  </p><p><font color="#cc0000">B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn };</font>   如果有多余的空间去放置，则考虑是否要放置</p><p>B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。</p><p><strong>②、实例</strong></p><p>w = {1, 2}</p><p>v = {1, 2}</p><p>C = 2</p><p>解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。</p><p>拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2</p><p>不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。</p><p>然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 </p><p>B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2</p><p><strong>③、递归代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    NSArray * nameArr   = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ];</span><br><span class="line">    NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ];</span><br><span class="line">    NSArray * valueArr  = @[ @(6), @(3), @(5), @(4), @(6) ];</span><br><span class="line">    selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count];</span><br><span class="line">    NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count];</span><br><span class="line"></span><br><span class="line">    for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123;</span><br><span class="line">        PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i]</span><br><span class="line">                                                        weight:[weightArr[i] integerValue]</span><br><span class="line">                                                         value:[valueArr[i] integerValue]];</span><br><span class="line">        bagItems[i] = item;  // a、b、c、d、e</span><br><span class="line">        selectedArray[i] = @(0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%ld&quot;, (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]);</span><br><span class="line">    </span><br><span class="line">    [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123;</span><br><span class="line">        if (obj.integerValue) &#123;</span><br><span class="line">            NSLog(@&quot;%@   &quot;, nameArr[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *  @brief   01 背包算法。递归方式</span><br><span class="line">  */</span><br><span class="line">- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize</span><br><span class="line">&#123;</span><br><span class="line">    if (bagItems.count == 0 || bagSize == 0 || bagNo == 0)  return 0;</span><br><span class="line">    </span><br><span class="line">    PackageItem * item = bagItems[bagNo - 1];</span><br><span class="line">    </span><br><span class="line">    // 装不下</span><br><span class="line">    if (bagSize &lt; item.weight) &#123;</span><br><span class="line">        // 在剩余的物品中查找</span><br><span class="line">        return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize];</span><br><span class="line">        NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value;</span><br><span class="line">        </span><br><span class="line">        if (more &lt; less) &#123;</span><br><span class="line">            selectedArray[bagNo - 1] = @(1); // 拿</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            selectedArray[bagNo - 1] = @(0); // 不拿</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return MAX(more, less);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 15</span><br><span class="line">2019-01-26 00:11:13.897903+0800 Demo[3618:88346] a</span><br><span class="line">2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b</span><br><span class="line">2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e</span><br></pre></td></tr></table></figure><h2 id="三、DP-优于递归的好处"><a href="#三、DP-优于递归的好处" class="headerlink" title="三、DP 优于递归的好处"></a>三、DP 优于递归的好处</h2><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。</p><h2 id="四、学习文章"><a href="#四、学习文章" class="headerlink" title="四、学习文章"></a>四、学习文章</h2><p><a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener">动态规划之 01 背包问题（最易理解的讲解）</a><br><a href="https://blog.csdn.net/u014296502/article/details/80015722" target="_blank" rel="noopener">一文彻底搞懂01背包算法</a><br><a href="https://blog.csdn.net/jushang0235/article/details/78841915" target="_blank" rel="noopener">DP——01背包问题使用迭代和动态规划</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5294842-171c0d1ec913da7d.png?image
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>Category</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20Category/"/>
    <id>http://yoursite.com/2019/05/23/iOS Category/</id>
    <published>2019-05-23T10:19:03.931Z</published>
    <updated>2019-07-13T08:40:56.958Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分类可以拓展类的属性、方法、协议等信息</p></blockquote><h2 id="一、底层结构"><a href="#一、底层结构" class="headerlink" title="一、底层结构"></a>一、底层结构</h2><p>在 objc-4 的源码中，搜索 category_t 可以看到:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;</span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="keyword">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。</p><p>在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： </p><h4 id="objc-os-mm"><a href="#objc-os-mm" class="headerlink" title="objc-os.mm"></a>objc-os.mm</h4><ul><li>_objc_init()</li><li>map_images()</li><li>map_images_nolock()</li></ul><h4 id="objc-runtime-new-mm"><a href="#objc-runtime-new-mm" class="headerlink" title="objc-runtime-new.mm"></a>objc-runtime-new.mm</h4><ul><li>_read_images()</li><li>remethodizeClass()</li><li>attachCategories()</li><li>attachLists()</li><li>realloc、memmove、memcpy</li></ul><p>最终可以找到这个方法 attachCategories</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line">    <span class="comment">// 判断是否元类</span></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="comment">/* 方法数组 @[ @[method_t, method_t], @[method_t .....] ]  */</span></span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="comment">/* 属性数组 @[ @[property_t, property_t], @[property_t .....] ]  */</span></span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="comment">/* 协议数组 @[ @[peotocol_t, peotocol_t], @[peotocol_t .....] ]  */</span></span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[I];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有分类的对象方法，附加到类对象列表中</span></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有分类的属性，附加到类属性列表中</span></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有分类的协议，附加到类协议列表中</span></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, <span class="literal">NO</span>, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。  </p><h2 id="二、Category和Class-Extension-的区别"><a href="#二、Category和Class-Extension-的区别" class="headerlink" title="二、Category和Class Extension 的区别"></a>二、Category和Class Extension 的区别</h2><p>Class Extension:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> sex;</span><br><span class="line">- (<span class="keyword">void</span>)isBig;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>将属性、方法等封装在 .m 文件里面，类似 private 的应用。 </p><p>区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。  </p><h2 id="三、-Load-和-initialize-方法的区别"><a href="#三、-Load-和-initialize-方法的区别" class="headerlink" title="三、+ Load 和 +initialize 方法的区别"></a>三、+ Load 和 +initialize 方法的区别</h2><p>Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 </p><p>initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次）  </p><h2 id="四、objc-msgSend-方法实现"><a href="#四、objc-msgSend-方法实现" class="headerlink" title="四、objc_msgSend() 方法实现"></a>四、objc_msgSend() 方法实现</h2><p>在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * id objc_msgSend(id self, SEL _cmd, ...);</span></span><br><span class="line"><span class="comment"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * objc_msgLookup ABI:</span></span><br><span class="line"><span class="comment"> * IMP returned in x17</span></span><br><span class="line"><span class="comment"> * x16 reserved for our use but not used</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">    .align <span class="number">3</span></span><br><span class="line">    .globl _objc_debug_taggedpointer_classes</span><br><span class="line">_objc_debug_taggedpointer_classes:</span><br><span class="line">    .fill <span class="number">16</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line">    .globl _objc_debug_taggedpointer_ext_classes</span><br><span class="line">_objc_debug_taggedpointer_ext_classes:</span><br><span class="line">    .fill <span class="number">256</span>, <span class="number">8</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    ENTRY _objc_msgSend</span><br><span class="line">    UNWIND _objc_msgSend, NoFrame</span><br><span class="line">    MESSENGER_START</span><br><span class="line"></span><br><span class="line">    cmp x0, <span class="meta">#0          // nil check and tagged pointer check</span></span><br><span class="line">    b.le    LNilOrTagged        <span class="comment">//  (MSB tagged pointer looks negative)</span></span><br><span class="line">    ldr x13, [x0]       <span class="comment">// x13 = isa</span></span><br><span class="line">    and x16, x13, <span class="meta">#ISA_MASK // x16 = class</span></span><br></pre></td></tr></table></figure><p>但是可以大概猜出它的实现思路:</p><ol><li>由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断；</li><li>通过 isa 寻找类/元类对象，寻找方法调用；</li><li>如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。</li></ol><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.jianshu.com/u/edda0ce4a193" target="_blank" rel="noopener">宁夏灼雪__</a> &amp; <a href="https://www.jianshu.com/p/1589bc808921" target="_blank" rel="noopener">iOS底层day4 - 探索Category的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;分类可以拓展类的属性、方法、协议等信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、底层结构&quot;&gt;&lt;a href=&quot;#一、底层结构&quot; class=&quot;headerlink&quot; title=&quot;一、底层结构&quot;&gt;&lt;/a&gt;一、底层结构&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>重构 AppDelegate</title>
    <link href="http://yoursite.com/2019/05/23/%E9%87%8D%E6%9E%84AppDelegate/"/>
    <id>http://yoursite.com/2019/05/23/重构AppDelegate/</id>
    <published>2019-05-23T10:19:03.931Z</published>
    <updated>2019-07-11T09:56:41.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Massive-AppDelegate"><a href="#一、Massive-AppDelegate" class="headerlink" title="一、Massive AppDelegate"></a>一、Massive AppDelegate</h2><blockquote><p>AppDelegate 是应用程序的根对象，<font color="#cc0000">它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互</font>，通常被认为是每个 iOS 项目的核心。</p></blockquote><p>随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。</p><p>在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的<font color="#cc0000">简洁和清晰</font>对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。</p><p>AppDelegate 常见的业务代码如下：</p><ul><li>日志埋点统计数据分析</li><li>初始化数据存储系统</li><li>配置 UIAppearance</li><li>管理 App Badge 数字</li><li>管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分</li><li>管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换</li><li>管理 UserDefaults：设置首先启动标志，保存和加载数据</li><li>管理后台任务</li><li>管理设备方向</li><li>更新位置信息</li><li>初始化第三方库（如分享、日志、第三方登陆、支付）</li></ul><p>这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。</p><p>看看以下可能的解决方案，每个 Recipe（方案）<font color="#cc0000">遵循单一职责、易于扩展、易于测试原则</font>。</p><h2 id="二、命令模式-Command-Design-Pattern"><a href="#二、命令模式-Command-Design-Pattern" class="headerlink" title="二、命令模式 Command Design Pattern"></a>二、命令模式 Command Design Pattern</h2><blockquote><p>命令模式是一种数据驱动的设计模式，属于行为型模式。</p></blockquote><p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。</p><p>可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 命令协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Command</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)execute;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeThirdPartiesCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化主视图</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeRootViewControllerCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWindow</span> * keyWindow;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化视图全局配置</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeAppearanceCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// ...</span></span><br></pre></td></tr></table></figure><p>然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StartupCommandsBuilder</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组，元素为遵守 Command 协议的对象</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;Command&gt;&gt; *)build</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @[ [InitializeAppearanceCommand new], </span><br><span class="line">              [InitializeRootViewControllerCommand new], </span><br><span class="line">              [InitializeThirdPartiesCommand new] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;    </span><br><span class="line">    [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(<span class="keyword">id</span>&lt;Command&gt; _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [obj execute];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="三、组合设计模式-Composite-Design-Pattern"><a href="#三、组合设计模式-Composite-Design-Pattern" class="headerlink" title="三、组合设计模式 Composite Design Pattern"></a>三、组合设计模式 Composite Design Pattern</h2><blockquote><p>组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。</p></blockquote><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于<font color="#cc0000">结构型模式</font>，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。</p><p>这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 组装类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CompositeAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CompositeAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里要实现单例</span></span><br><span class="line">    <span class="keyword">return</span> [[CompositeAppDelegate alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现执行具体职责的叶子类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 叶子类。推送消息处理</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushNotificationAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 叶子类。初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PushNotificationAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"PushNotificationAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ThirdPartiesConfiguratorAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="四、中介者模式-Mediator-Design-Pattern"><a href="#四、中介者模式-Mediator-Design-Pattern" class="headerlink" title="四、中介者模式 Mediator Design Pattern"></a>四、中介者模式 Mediator Design Pattern</h2><blockquote><p>中介者模式是用来降低多个对象和类之间的通信复杂性。</p></blockquote><p>这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于<font color="#cc0000">行为型模式</font>。</p><p>如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。</p><p>让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">APPLifeCycleMediator</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">APPLifeCycleMediator</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; * _listeners;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithListeners:(<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; *)listeners</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        _listeners = listeners;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppWillEnterForeground)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillEnterForegroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidEnterBackgroud)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidFinishLaunching)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义好静态类方法，初始化所有监听者</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> APPLifeCycleMediator * mediator;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">1</span>] onAppWillEnterForeground];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">0</span>] onAppDidEnterBackgroud];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>定义 AppLifecycleListener 协议，以及协议的的实现者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 监听协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AppLifeCycleListener</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VideoListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SocketListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VideoListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"停止视频播放"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SocketListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开启长链接"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>加入到 AppDelegate 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [APPLifeCycleMediator makeDefaultMediator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。</p><p>通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。</p><p>这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247484070&amp;idx=1&amp;sn=8f784d2931c90bbc10c1d07bb634f01d&amp;chksm=a6f95840918ed156b8333751242eab54caacc5502af2e177018f0fc9df8f8955cee36e92eaf8&amp;mpshare=1&amp;scene=23&amp;srcid=1201w1cWjo0tBpIGir7EcNQD#rd" target="_blank" rel="noopener">最佳实践：重构AppDelegate</a></p><p><a href="https://www.vadimbulavin.com/refactoring-massive-app-delegate/" target="_blank" rel="noopener">Refactoring Massive App Delegate</a></p><p><a href="https://github.com/GesanTung/iOSTips" target="_blank" rel="noopener">iOSTips</a></p><p>OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》</p><p> Swift 设计模式：《<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247483977&amp;idx=1&amp;sn=5994f8456884df158e7263be8179b79f&amp;chksm=a6f958af918ed1b92625986d22a19e7ddaf85367386b9edf19b93e8ce836f83e0c5556997d13&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Design_Patterns_by_Tutorials_v0.9.1</a>》</p><p>重构：《重构改善既有代码的设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Massive-AppDelegate&quot;&gt;&lt;a href=&quot;#一、Massive-AppDelegate&quot; class=&quot;headerlink&quot; title=&quot;一、Massive AppDelegate&quot;&gt;&lt;/a&gt;一、Massive AppDelegate&lt;/
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
</feed>
