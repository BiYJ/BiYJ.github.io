<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T10:52:52.721Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/05/22/深拷贝和浅拷贝/</id>
    <published>2019-05-22T10:52:52.721Z</published>
    <updated>2019-05-22T10:52:52.721Z</updated>
    
    <content type="html"><![CDATA[<p>深拷贝和浅拷贝的<font color="#cc0000">本质区别是地址是否相同</font>。</p><ul><li>浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址；</li><li>深拷贝是真正的复制了一份，复制的对象指向了新的地址。</li></ul><h2 id="一、非容器类对象"><a href="#一、非容器类对象" class="headerlink" title="一、非容器类对象"></a>一、非容器类对象</h2><p>对象的 copy 是浅拷贝，mutableCopy 是深拷贝。</p><p>1、不可变</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = @<span class="string">"AAA"</span><span class="comment">;</span></span><br><span class="line">NSString * <span class="built_in">s2</span> = [<span class="built_in">s1</span> copy]<span class="comment">;</span></span><br><span class="line">NSString * <span class="built_in">s3</span> = [<span class="built_in">s1</span> mutableCopy]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s1</span>, <span class="built_in">s1</span>.class)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s2</span>, <span class="built_in">s2</span>.class)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s3</span>, <span class="built_in">s3</span>.class)<span class="comment">;</span></span><br><span class="line"><span class="number">0x1083a40e8</span>   __NSCFConstantString</span><br><span class="line"><span class="number">0x1083a40e8</span>   __NSCFConstantString</span><br><span class="line"><span class="number">0x60400044f840</span>   __NSCFString</span><br></pre></td></tr></table></figure><p>结论：</p><p>①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝；</p><p>②、浅拷贝返回不可变对象，深拷贝返回可变对象。</p><p>2、可变</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> * ms1 = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSMutableString</span> * ms2 = [ms1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSString</span> * ms3 = [ms1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms1, ms1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms2, ms2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms3, ms3.class);</span><br><span class="line"><span class="number">0x6040004500b0</span>   __NSCFString</span><br><span class="line"><span class="number">0xa000000000000311</span>   <span class="built_in">NSTaggedPointerString</span></span><br><span class="line"><span class="number">0x60400044fc60</span>   __NSCFString</span><br></pre></td></tr></table></figure><p>结论：</p><p>①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝；</p><p>②、copy 和 mutableCopy 返回对象都为可变对象。</p><h2 id="二、容器对象"><a href="#二、容器对象" class="headerlink" title="二、容器对象"></a>二、容器对象</h2><p>1、不可变</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSMutableString</span> * ms = [<span class="symbol">NSMutableString</span> stringWithString:@<span class="string">"1"</span>];</span><br><span class="line"><span class="symbol">NSArray</span> * arr1 = [<span class="symbol">NSArray</span> arrayWithObjects:ms, @<span class="string">"2"</span>, nil];</span><br><span class="line"><span class="symbol">NSArray</span> * arr2 = [arr1 copy];</span><br><span class="line"><span class="symbol">NSArray</span> * arr3 = [arr1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr1, arr1.class, arr1[<span class="number">0</span>], [arr1[<span class="number">0</span>] class], arr1[<span class="number">1</span>], [arr1[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr2, arr2.class, arr2[<span class="number">0</span>], [arr2[<span class="number">0</span>] class], arr2[<span class="number">1</span>], [arr2[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr3, arr3.class, arr3[<span class="number">0</span>], [arr3[<span class="number">0</span>] class], arr3[<span class="number">1</span>], [arr3[<span class="number">1</span>] class]);</span><br><span class="line">    </span><br><span class="line"><span class="number">0x600000037620</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x600000037620</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x60000025a940</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br></pre></td></tr></table></figure><p>结论：</p><p>①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝；</p><p>②、浅拷贝返回不可变对象，深拷贝返回可变对象。</p><p>③、容器内的元素始终都是浅拷贝。</p><p>2、可变</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSMutableString</span> * ms = [<span class="symbol">NSMutableString</span> stringWithString:@<span class="string">"1"</span>];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr1 = [<span class="symbol">NSMutableArray</span> arrayWithObjects:ms, @<span class="string">"2"</span>, nil];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr2 = [mArr1 copy];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr3 = [mArr1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr1, mArr1.class, mArr1[<span class="number">0</span>], [mArr1[<span class="number">0</span>] class], mArr1[<span class="number">1</span>], [mArr1[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr2, mArr2.class, mArr2[<span class="number">0</span>], [mArr2[<span class="number">0</span>] class], mArr2[<span class="number">1</span>], [mArr2[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr3, mArr3.class, mArr3[<span class="number">0</span>], [mArr3[<span class="number">0</span>] class], mArr3[<span class="number">1</span>], [mArr3[<span class="number">1</span>] class]);</span><br><span class="line"><span class="number">0x60000025aeb0</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x600000037640</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x60000025ae80</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br></pre></td></tr></table></figure><p>结论：</p><p>①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；<br>②、copy 返回不可变对象，mutableCopy 返回可变对象；<br>③、容器内的元素始终是浅拷贝。</p><h2 id="三、自定义类对象的深浅拷贝"><a href="#三、自定义类对象的深浅拷贝" class="headerlink" title="三、自定义类对象的深浅拷贝"></a>三、自定义类对象的深浅拷贝</h2><p>自定义的类需要遵循 <nscopying> 才支持 copy，遵循 <nsmutablecopying> 支持 mutableCopy。</nsmutablecopying></nscopying></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  [Person allocWithZone:zone];   <span class="comment">// return self;</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span>  [Person allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">Person * p1 = [[Person alloc] init];</span><br><span class="line">Person * p2 = [p1 <span class="keyword">copy</span>];</span><br><span class="line">Person * p3 = [p1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p1, p1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p2, p2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p3, p3.class);</span><br><span class="line"><span class="number">0x600000011e30</span>   Person</span><br><span class="line"><span class="number">0x600000011f70</span>   Person</span><br><span class="line"><span class="number">0x600000011f90</span>   Person</span><br></pre></td></tr></table></figure><h2 id="四、实现容器对象的完全拷贝"><a href="#四、实现容器对象的完全拷贝" class="headerlink" title="四、实现容器对象的完全拷贝"></a>四、实现容器对象的完全拷贝</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> * ms = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> * arr = [<span class="built_in">NSArray</span> arrayWithObjects:ms, <span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">NSMutableArray</span> * mArr = [[<span class="built_in">NSMutableArray</span> alloc] initWithArray:arr copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, mArr[<span class="number">0</span>], mArr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">NSData</span> * data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:mArr];</span><br><span class="line"><span class="built_in">NSMutableArray</span> * newMutableArr = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, newMutableArr[<span class="number">0</span>], newMutableArr[<span class="number">1</span>]);</span><br><span class="line"><span class="number">0x6040004434b0</span>  <span class="number">0x109c93100</span></span><br><span class="line"><span class="number">0xa000000000000311</span>  <span class="number">0x109c93100</span></span><br><span class="line"><span class="number">0xa000000000000311</span>  <span class="number">0xa000000000000321</span></span><br></pre></td></tr></table></figure><p>由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。</p><blockquote><p>自定义类对象需要遵循 <nscoding> 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。</nscoding></p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.xxx = [aDecoder decodeObjectForKey:<span class="string">@"key"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.xxx forKey:<span class="string">@"key"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://www.jianshu.com/p/33f175d97b86" target="_blank" rel="noopener">深刻理解iOS中的“深拷贝”和“浅拷贝”</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深拷贝和浅拷贝的&lt;font color=&quot;#cc0000&quot;&gt;本质区别是地址是否相同&lt;/font&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址；&lt;/li&gt;
&lt;li&gt;深拷贝是真正的复制了一份，复制的对象指向了新的地址。&lt;/li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="http://yoursite.com/2019/05/22/String/"/>
    <id>http://yoursite.com/2019/05/22/String/</id>
    <published>2019-05-22T10:48:05.651Z</published>
    <updated>2019-05-22T10:48:05.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串常量"><a href="#一、字符串常量" class="headerlink" title="一、字符串常量"></a>一、字符串常量</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * string1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSString</span> * string2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * temp = <span class="string">@"AAAA"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.s1 = temp;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"temp -&gt; %p"</span>, temp);</span><br><span class="line">    <span class="keyword">self</span>.s2 = <span class="keyword">self</span>.s1;</span><br><span class="line">    <span class="keyword">self</span>.s1 = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"s1 = %@，s2 = %@"</span>, <span class="keyword">self</span>.s1, <span class="keyword">self</span>.s2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"s1 -&gt; %p，s2 -&gt; %p"</span>, <span class="keyword">self</span>.s1, <span class="keyword">self</span>.s2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount = %@"</span>, [temp valueForKey:<span class="string">@"retainCount"</span>]);</span><br><span class="line">&#125;</span><br><span class="line">temp -&gt; <span class="number">0x108551118</span></span><br><span class="line">s1 = (null)，s2 = AAAA</span><br><span class="line">s1 -&gt; <span class="number">0x0</span>，s2 -&gt; <span class="number">0x108551118</span></span><br><span class="line">retainCount = <span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure><p><strong>解释 1</strong></p><p>temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。</p><p>即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。</p><p>另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString ** <span class="built_in">s2</span> = <span class="built_in">s1</span><span class="comment">;  // 需要关闭 arc 才能使用二级指针</span></span><br></pre></td></tr></table></figure><p>这样 s1 = nil 后 s2 也是 nil 了。</p><p><strong>解释 2</strong></p><p>@”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。</p><p>self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。</p><p>字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。</p><p>致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * temp1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"AAAAAAA"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp2 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"AAAAAAA"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp3 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"BBBBBBBBBBBB"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp4 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"BBBBBBBBBBBB"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p   %p"</span>, temp1, temp2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p   %p"</span>, temp3, temp4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0xa414141414141417</span>   <span class="number">0xa414141414141417</span></span><br><span class="line"><span class="number">0x60000022a3a0</span>   <span class="number">0x60000022a260</span></span><br></pre></td></tr></table></figure><p>通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区：</p><p>如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；<br>如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。</p><h2 id="二、Copy-和-strong"><a href="#二、Copy-和-strong" class="headerlink" title="二、Copy 和 strong"></a>二、Copy 和 strong</h2><pre><code>@interface ViewController ()@property (nonatomic, strong) NSString * sString;@property (nonatomic, copy) NSString * cString;@end@implementation ViewController- (void)viewDidLoad{    [super viewDidLoad];    NSMutableString * mString = [NSMutableString string];    [mString appendFormat:@&quot;AA&quot;];    self.sString = mString;    self.cString = mString;    NSLog(@&quot;mString -&gt; %p, sString -&gt; %p, cString -&gt; %p&quot;, mString, _sString, _cString);   // mString -&gt; 0x600002565b30, sString -&gt; 0x600002565b30, cString -&gt; 0xcac34ab7cb397e8b    NSLog(@&quot;%@&quot;, self.sString);  // AA    NSLog(@&quot;%@&quot;, self.cString);  // AA    [mString appendFormat:@&quot;BB&quot;];    NSLog(@&quot;%@&quot;, self.sString);  // AABB    NSLog(@&quot;%@&quot;, self.cString);  // AA}@end</code></pre><p>结果分析:</p><p>使用 strong 修饰 NSString 类型属性，指针指向可变字符串对象的地址，当可变字符串内容发生变化时，self.sStrong 相对应的也发生变化；<br>使用 copy 修饰，会将可变字符串重新拷贝一份，重新开辟内存空间，修改 mutableString 的值不会对 self.cString 造成影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、字符串常量&quot;&gt;&lt;a href=&quot;#一、字符串常量&quot; class=&quot;headerlink&quot; title=&quot;一、字符串常量&quot;&gt;&lt;/a&gt;一、字符串常量&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>atomic</title>
    <link href="http://yoursite.com/2019/05/22/atomic/"/>
    <id>http://yoursite.com/2019/05/22/atomic/</id>
    <published>2019-05-22T09:54:44.720Z</published>
    <updated>2019-05-22T10:10:23.458Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="http://blog.csdn.net/kangguang/article/details/79194563" target="_blank" rel="noopener">http://blog.csdn.net/kangguang/article/details/79194563</a></p><p>atomic 在 set 方法里加了锁，防止了多线程一直去写这个 property，造成难以预计的数值。</p><p>当属性使用 atomic 修饰时，它的读和写是原子性的：当线程 A 进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当 A 线程的写操作结束后，B 线程进行写操作，然后当 A 线程需要读操作时，获得了在 B 线程中修改的值。如果有 C 线程在 A 线程读操作之前 release了该属性，可能导致程序崩溃。</p><p>导致崩溃并不是线程安全问题。所谓线程安全是保证同一时间只有一个线程对该内存进行访问。只要我们使用 getter、setter 方法来访问，上面的表述中的每一个步骤都只有一条线程在访问该内存，哪个线程会获得锁完全取决于代码顺序，这个崩溃就是程序员自身的问题了。如果绕开 getter、setter 方法访问这个属性，才会造成线程不安全，比如使用 KVC。</p><h2 id="一、atomic-是绝对安全的"><a href="#一、atomic-是绝对安全的" class="headerlink" title="一、atomic 是绝对安全的"></a>一、atomic 是绝对安全的</h2><p>在 64 位的操作系统下，所有类型的指针(包括 void *)都是占用 8 个字节的。超过 4 个字节的基本类型数据都会有线程并发的问题。</p><p>那所有的指针类型都会有这个问题。</p><p>以 Objective-C 的 NSArray * 为例子，如果一个多线程操作这个数据，会有两个层级的并发问题：</p><p>①、指针本身</p><p>②、指针所指向的内存</p><p>指针本身也是占用内存的，并且一定是 8 个字节。第二部分，指针所指向的内存，有可能非常大，有可能也就 1 个字节。</p><p>所以考虑 NSArray * array 这个数据在进行多线程操作的时候，必须分成两部分来描述，一个是 &amp;array 这个指针本身，另一个则是它所指向的内存 array。想象现在有两块内存，一块是 8 字节，一块 n 字节，8 字节里面放的值，就是 n 字节内存的首地址。</p><p>如果用 atomic 修饰之后，会有什么影响？</p><p>从内存的角度来解释这个过程。atomic 其实修饰的是这个指针 &amp;array，与指针指向的第二部分 n 字节数据没有任何关系，被atomic 修饰之后，你不可能随意去多线程操作这个 8 字节，但是对 8 字节里面所指向的 n 字节没有任何限制！</p><p>atomic 已经完美的履行了它的指责，你不可能对这个 8 字节进行无序的多线程操作，这就够了呀！有问题的是程序员，程序员并未对 n 字节做任何的限制。</p><h2 id="二、NSMutableArray-本身是线程不安全的"><a href="#二、NSMutableArray-本身是线程不安全的" class="headerlink" title="二、NSMutableArray 本身是线程不安全的"></a>二、NSMutableArray 本身是线程不安全的</h2><p>简单来说，线程安全就是多个线程访问同一段代码，程序不会异常、不 Crash。而编写线程安全的代码主要依靠线程同步。</p><p>1、不使用 atomic 修饰属性。原因有二：</p><p>①、atomic 的内存管理语义是原子性的，仅保证了属性的 setter 和 getter 方法是原子性的、线程安全的，但是属性的其他方法，如数组添加/移除元素等并不是原子操作，所以不能保证属性是线程安全的。</p><p>②、atomic 虽然保证了 getter、setter 方法线程安全，但是付出的代价很大，执行效率要比 nonatomic 慢很多倍(有说法是慢 10-20 倍)。</p><p>总之：使用 nonatomic 修饰 NSMutableArray 对象就可以了，而使用锁、dispatch_queue 来保证 NSMutableArray 对象的线程安全。</p><p>2、打造线程安全的 NSMutableArray</p><p>在<strong>《</strong>Effective Objective-C 2.0..<strong>》</strong>书中<strong>第 </strong>41<strong> 条：</strong>多用派发队列，少用同步锁中指出：使用“串行同步队列”(serial synchronization queue)，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD 的栅栏块(barrier)来不仅实现数据同步线程安全，还比串行同步队列方式更高效。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-5fb527a419acf5a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="automic"></p><p>GCD 的栅栏块作用示意图</p><p><strong>说明</strong>：栅栏块单独执行，不能与其他块并行。直到当前所有并发块都执行完毕，才会单独执行这个栅栏块</p><p>线程安全实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QSThreadSafeMutableArray</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * MDataArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> MSyncQueue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QSThreadSafeMutableArray</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initCommon</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// %p 以 16 进制的形式输出内存地址，附加前缀 0x</span></span><br><span class="line">        <span class="built_in">NSString</span> * uuid = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.jzp.array_%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 注意：_MSyncQueue 是并行队列</span></span><br><span class="line">        _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initCommon]) &#123;</span><br><span class="line">        _MDataArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">id</span> obj;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            obj = _MDataArray[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)objectEnumerator</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSEnumerator</span> * enu;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>( _MSyncQueue, ^&#123;</span><br><span class="line">        enu = [_MDataArray objectEnumerator];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> enu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertObject:(<span class="keyword">id</span>)anObject atIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray insertObject:anObject atIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span>(anObject)&#123;</span><br><span class="line">            [_MDataArray addObject:anObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray removeObjectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeLastObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        [_MDataArray removeLastObject];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replaceObjectAtIndex:(<span class="built_in">NSUInteger</span>)index withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray replaceObjectAtIndex:index withObject:anObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSUInteger</span> index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; [_MDataArray count]; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([_MDataArray objectAtIndex:i] == anObject) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_MSyncQueue) &#123;</span><br><span class="line">        _MSyncQueue = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>说明 ①：使用 dispatch queue 实现线程同步；将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，又不会阻塞执行异步派发的线程；使用同步队列及栅栏块，可以令同步行为更加高效。</p><p>说明 ②：NSMutableDictionary 本身也是线程不安全的，实现线程安全的 NSMutableDictionary 原理同线程安全的NSMutableArray。(代码见 <a href="https://github.com/buaa0300/QSKitDemo/tree/master/QSUseCollectionDemo" target="_blank" rel="noopener">QSUseCollectionDemo</a>)</p><p>3、线程安全的 NSMutableArray 使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testQsMutableArray</span><br><span class="line">&#123;</span><br><span class="line">    _MSafeArray = [[QSThreadSafeMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSString</span> * str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"数组%d"</span>, (<span class="keyword">int</span>)i+<span class="number">1</span>];</span><br><span class="line">            [_MSafeArray addObject:str];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSEnumerator</span> * enu = [_MSafeArray objectEnumerator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> * object <span class="keyword">in</span> enu) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、atomic-与-nonatomic-的区别"><a href="#三、atomic-与-nonatomic-的区别" class="headerlink" title="三、atomic 与 nonatomic 的区别"></a>三、atomic 与 nonatomic 的区别</h2><p>在默认情况下，由编译器生成的属性的 set、get 方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不需要同步锁。</p><p>尽管没有指明 atomic 的特质（如果某属性不具备 nonatomic 特质，那它就是”原子的”(atomic)），仍然可以在属性特质中写明这一点，编译器是不会报错的。</p><p>一般 iOS 程序中，所有属性都声明为 nonatomic。这样做的原因是：</p><p>①、在 iOS 中使用同步锁的开销比较大， 会带来性能问题。</p><p>②、一般情况下并不要求属性必须是”原子的”，因为这并不能保证线程安全。若要实现线程安全的操作，还需采用更为深层的锁的机制。</p><p>一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic 也还是会读取到不同的属性值。</p><p>因此，iOS 程序一般都会使用 nonatomic 属性。但在 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p><p>nonatomic 的实现：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setImage:(UIImage *)<span class="built_in">image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_image</span> != <span class="built_in">image</span>) &#123;</span><br><span class="line">        [<span class="variable">_image</span> release];</span><br><span class="line">        <span class="variable">_image</span> = [<span class="built_in">image</span> retain];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)<span class="built_in">image</span></span><br><span class="line">&#123;</span><br><span class="line">    return <span class="variable">_image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic 的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁</span></span><br><span class="line">        <span class="keyword">if</span> (_image != image) &#123;</span><br><span class="line">            [_image release];</span><br><span class="line">            _image = [image <span class="keyword">retain</span>];</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@synchronized 的介绍：</p><blockquote><p>The @synchronized directive is a convenient way to create mutex locks on the fly in Objective-C code. The @synchronized directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example:</p><p>- (void)myMethod:(id)anObj<br>{</p><p>@synchronized(anObj) {</p><p>// Everything between the braces is protected by the @synchronized directive.</p><p>}</p><p>}</p><p>The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the anObj parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section.</p><p>As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes.</p><p>For more information about the @synchronized directive, see The Objective-C Programming Language.</p></blockquote><p>更准确的说应该是读写安全，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章：&lt;a href=&quot;http://blog.csdn.net/kangguang/article/details/79194563&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/kangguang/arti
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>malloc</title>
    <link href="http://yoursite.com/2019/05/22/malloc/"/>
    <id>http://yoursite.com/2019/05/22/malloc/</id>
    <published>2019-05-22T09:54:44.720Z</published>
    <updated>2019-05-22T09:54:44.720Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="noopener">iOS内存管理和malloc源码解读</a></p><p>在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。</p><p>与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？</p><p>和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。</p><p>如上所述，iOS 在外存没有交换区，没有内存页换出的过程。</p><h2 id="一、malloc-基本原理"><a href="#一、malloc-基本原理" class="headerlink" title="一、malloc 基本原理"></a>一、malloc 基本原理</h2><p>在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。</p><ul><li>创建新对象    [NSObject alloc];</li><li>释放对象       [Object release];</li></ul><p>而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。</p><p>从苹果公开的 malloc 源码上来看，它的原理大致如下：</p><ul><li>malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。</li><li>malloc 在首次调用时，初始化 default zone。在 64 位环境下，会初始化 default zone 为 nano zone，同时初始化一个 scalable zone 作为 helper zone。nano zone 负责 nano 大小的分配，scalable zone 则负责 tiny、small 和 large内存的分配。</li><li>每次 malloc 时，根据传入的 size 参数，优先交给 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5294842-58b5a941da813178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。</p><h2 id="二、nano-malloc"><a href="#二、nano-malloc" class="headerlink" title="二、nano malloc"></a>二、nano malloc</h2><p>在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。</p><p>nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为Magazine、Band 和 Slot 几个级别。</p><ul><li>Magazine 范围对应于 CPU，CPU0 对应 Mag0，CPU1 对应 Mag1，依次类推</li><li>Band 范围为 2M，连续内存分配当内存不够时以 Band 为单位向内核请求</li><li>Slot 则对应于每个 Band 中 128K 大小的范围，每个 Band 都分为 16 个 Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配</li></ul><p>分配过程：</p><ul><li>确定当前 cpu 对应的 mag 和通过 size 参数计算出来的 slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。</li><li>初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。</li><li>如当前 Band 中当前 Slot 耗尽则向系统申请新的 Band(每个 Band 固定大小 2M，容纳了 16 个 128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是 16 个)的二维数组形式，放在 nanozone_t 的 meta_data 字段中。</li></ul><p>当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。</p><p>其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。</p><p>下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b41dd6a71ee927ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data上挂着的空闲链表上内存区块回收来完成。</p><h2 id="三、scalable-zone-上内存分配简要分析"><a href="#三、scalable-zone-上内存分配简要分析" class="headerlink" title="三、scalable zone 上内存分配简要分析"></a>三、scalable zone 上内存分配简要分析</h2><p>对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。</p><p>在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。</p><p>tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为-1 的 magazine 作为后备之用。</p><p>下面是一个简图。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-10c246c2019af0d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>分配时(以 tiny 的情况为例)：</p><ol><li>确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。</li><li>优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。</li><li>如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。</li><li>如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。这里需要注意的是，在一般情况下 free list 分为 64 个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63 为所有更大的内存区块挂载的地方。</li><li>上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。</li><li>如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。</li><li>如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。</li><li>要是再不行就没招了，系统也给不到内存，就报错返回。</li></ol><p>free 时：</p><ol><li>检查指针指向地址是否有问题。</li><li>如果 last free 指针上没有挂载内存区块，则放到 last free 上就 OK 了。</li><li>如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上(在挂载的 free list 前，会先根据 region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。</li><li>合并后所在的 region 如果空闲字节超过一定条件，则将把此 region 放到后备的 magazine 中(-1)。</li><li>如果整个 region 都是空的，则直接还给系统内核，一了百了。</li></ol><p>而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://yq.aliyun.com/articles/3065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS内存管理和malloc源码解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在内存管理方面，iOS 和其它操作系统总体上来说是大同
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 证书</title>
    <link href="http://yoursite.com/2019/05/22/iOS%20%E8%AF%81%E4%B9%A6/"/>
    <id>http://yoursite.com/2019/05/22/iOS 证书/</id>
    <published>2019-05-22T08:51:44.499Z</published>
    <updated>2019-05-22T08:52:07.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><blockquote><ol><li>什么是 App ID？Explicit/Wildcard App ID 有何区别？什么是 App Group ID？</li><li>什么是证书（Certificate）？如何申请？有啥用？</li><li>什么是Key Pair（公钥/私钥）？有啥用？与证书有何关联？</li><li>什么是签名（Signature）？如何签名（CodeSign）？怎样校验（Verify）？</li><li>什么是（Team）Provisioning Profiles？有啥用？</li><li>Xcode如何配置才能使用iOS真机进行开发调试？</li><li>多台机器如何共享开发者账号或证书？</li><li>遇到证书配置问题怎么办？</li><li>Xcode 7免证书调试真机调试</li></ol></blockquote><h2 id="二、App-ID（bundle-identifier）"><a href="#二、App-ID（bundle-identifier）" class="headerlink" title="二、App ID（bundle identifier）"></a>二、App ID（bundle identifier）</h2><blockquote><p>App ID 即 Product ID，用于标识一个或者一组 App。</p></blockquote><ol><li>App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。</li><li>App ID字符串通常以<strong>反域名</strong>（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。</li><li>App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类：<ul><li>Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。</li><li>Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“*”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.*”可以表示Bundle Identifier以“com.apple.”开头的所有应用程序。</li></ul></li><li>用户可在Developer MemberCenter网站上注册或删除已注册的App IDs。 </li><li>App ID <strong>被配置到</strong>【Target-&gt;Info-&gt;Bundle Identifier】下；对于 Wildcard App ID，只要 bundle identifier 包含其作为 Prefix/Seed 即可。</li></ol><h2 id="三、设备（Device）"><a href="#三、设备（Device）" class="headerlink" title="三、设备（Device）"></a>三、设备（Device）</h2><blockquote><p>Device 就是运行 iOS 系统用于开发调试 App 的设备。每台Apple设备使用 <strong>UDID</strong> 来唯一标识。</p></blockquote><p>iOS设备连接Mac后，可通过 iTunes-&gt;Summary 或者 Xcode-&gt;Window-&gt;Devices 获取 iPhone 的 UDID。</p><p>Apple Member Center 网站个人账号下的 <strong>Devices</strong> 中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册 <strong>100</strong> 个设备。</p><blockquote><ul><li>Apps signed by you or your team run only on designated development devices.</li><li>Apps run only on the test devices you specify.</li></ul></blockquote><p>用户可在网站上注册或启用/禁用（Enable/Disable）已注册的 Device。本文的 Devices 是指<strong>连接到</strong> Xcode 被授权用于开发测试的 iOS 设备（iPhone/iPad）。</p><h2 id="四、开发证书（Certificates）"><a href="#四、开发证书（Certificates）" class="headerlink" title="四、开发证书（Certificates）"></a>四、开发证书（Certificates）</h2><h3 id="4-1-证书"><a href="#4-1-证书" class="headerlink" title="4.1 证书"></a>4.1 证书</h3><blockquote><p><strong>证书</strong>是由公证处或认证机关开具的证明资格或权力的<em>证件</em>，它是表明（或帮助断定）事理的一个<em>凭证</em>。证件或凭证的尾部通常会烙印<em>公章</em>。</p></blockquote><p>每个中国人一生可能需要 70 多个证件，含 15 种身份证明。</p><h3 id="4-2-数字证书"><a href="#4-2-数字证书" class="headerlink" title="4.2 数字证书"></a>4.2 数字证书</h3><blockquote><p><strong>数字证书</strong>就是互联网通讯中<strong>标志</strong>通讯各方<strong>身份信息</strong>的一串数字，提供了一种在 Internet 上验证通信<strong>实体身份</strong>的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。</p></blockquote><p>它是由一个由权威机构——<strong>CA机构</strong>，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。</p><ul><li>数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。</li><li>数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。 </li></ul><p>数字证书中的公开密钥（公钥）相当于公章。</p><p>某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的<strong>起始点</strong>。安装根证书意味着对这个CA认证中心的信任。</p><p>为了防止 <a href="http://bbs.3dmgame.com/thread-2356754-1-1.html" target="_blank" rel="noopener">GFW</a> 进行中间人攻击(MitM)，例如篡改 github 证书，导致无法访问 github 网站等问题，可选择不信任根证书。</p><ul><li>在【钥匙串】中输入 ROOT 进行搜索，可以找到很多根证书，在【简介】|【使用此证书时】下拉选择【永不信任】。<br><img src="https://upload-images.jianshu.io/upload_images/5294842-cc3bd54be1a42708.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt></li></ul><h3 id="4-3-iOS（开发）证书"><a href="#4-3-iOS（开发）证书" class="headerlink" title="4.3 iOS（开发）证书"></a>4.3 iOS（开发）证书</h3><blockquote><p>iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的<strong>数字证书</strong>。对于想安装到真机或发布到AppStore的应用程序（App），只有经过<strong>签名验证</strong>（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。</p></blockquote><p>iOS证书分为两类：Development 和 Production（Distribution）。</p><ul><li>Development 证书用来开发和调试应用程序：A <strong>development certificate</strong> identifies you, as a team member, in a development provisioning profile that allows apps signed by you to <strong>launch</strong> on devices. </li><li>Production 主要用来分发应用程序（根据证书种类有不同作用）：A <strong>distribution certificate</strong> identifies your team or organization in a distribution provisioning profile and allows you to <strong>submit</strong> your app to the store. Only a team agent or an admin can create a distribution certificate.</li></ul><p>普通个人开发账号最多可注册 iOS Development/Distribution 证书各 <font color="#CC0000">2</font> 个，用户可在网站上删除（Revoke）已注册的Certificate。</p><p>下文主要针对 iOS App 开发调试过程中的开发证书（Certificate for Development）。</p><h3 id="4-4-iOS（开发）证书的根证书"><a href="#4-4-iOS（开发）证书的根证书" class="headerlink" title="4.4 iOS（开发）证书的根证书"></a>4.4 iOS（开发）证书的根证书</h3><p>那么，iOS 开发证书是谁颁发的呢？或者说我们是从哪个 CA 申请到用于 Xcode 开发调试 App 的证书呢？</p><p>iOS 以及 Mac OS X 系统（在安装 Xcode 时）将自动安装 <a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer" target="_blank" rel="noopener"><strong><em>AppleWWDRCA.cer</em></strong></a> 这个中间证书（<strong>Intermediate Certificates</strong>），它实际上就是 iOS（开发）证书的证书，即<strong>根证书</strong>（Apple Root Certificate）。</p><p>AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer 之于 iOS（开发）证书则好比户籍证之于身份证。 </p><p>如果 Mac Keychain Access 证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-afd0c07e271ca6a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h3 id="4-5-申请证书（CSR：Certificate-Signing-Request）"><a href="#4-5-申请证书（CSR：Certificate-Signing-Request）" class="headerlink" title="4.5 申请证书（CSR：Certificate Signing Request）"></a>4.5 申请证书（CSR：Certificate Signing Request）</h3><p>可以在缺少证书时通过 Xcode Fix Issue 自动请求证书，这里通过 Keychain <strong>证书助理</strong>从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d54209d02611c0ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>keychain 将生成一个包含开发者身份信息的 <strong>CSR</strong>（Certificate Signing Request）文件；同时，Keychain Access|Keys 中将新增一对 Public/Private <strong>Key Pair</strong>（This signing identity consists of a public-private key pair that Apple issues）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b90d8cb700a6e7a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>private key</strong>始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）对外发布的 App；<br><strong>public key</strong>一般随证书（Provisioning Profile）散布出去，对 App 签名进行校验认证。用户必须保护好本地 Keychain 中的 private key，以防伪冒。</p><blockquote><ul><li>Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an <strong>entirely new</strong> identity to sign code. </li><li>Worse, if someone else has your private key, that person may be able to <strong>impersonate</strong> you.</li></ul></blockquote><p>在 Apple 开发网站上传该 CSR 文件来添加证书（Upload CSR file to generate your certificate）：</p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-2bd8ca660b5d1310?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>Apple 证书颁发机构 WWDRCA<a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer" target="_blank" rel="noopener"><em>(Apple Worldwide Developer Relations Certification Authority)</em></a> 将使用private key 对 CSR 中的 public key 和一些身份信息进行加密签名生成<strong>数字证书</strong>（ios_development.cer）并记录在案（Apple Member Center）。</p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-4ad2b020cd19ac82?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>从 Apple Member Center 网站下载证书到 Mac 上双击即可安装（当然也可在 Xcode 中添加开发账号自动同步证书和【生成】配置文件）。证书安装成功后，在 KeychainAccess|Keys 中展开创建 CSR 时生成的 Key Pair 中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在 Keychain Access|Certificates 中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6e0ad6902588873f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1dae71c0b8c55b48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Certificate <strong>被配置到</strong>【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Identity】下，下拉选择 Identities from Profile。</p><h2 id="五、供应配置文件（Provisioning-Profiles）"><a href="#五、供应配置文件（Provisioning-Profiles）" class="headerlink" title="五、供应配置文件（Provisioning Profiles）"></a>五、供应配置文件（<a href="https://help.apple.com/xcode/mac/current/#/dev3a05256b8" target="_blank" rel="noopener">Provisioning Profiles</a>）</h2><h3 id="5-1-Provisioning-Profile的概念"><a href="#5-1-Provisioning-Profile的概念" class="headerlink" title="5.1 Provisioning Profile的概念"></a>5.1 Provisioning Profile的概念</h3><blockquote><p>Provisioning Profile文件包含了上述的所有内容：<strong>证书、App ID 和设备</strong>。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/5294842-9522993cb7553738?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"> </p><p>一个 Provisioning Profile 对应一个 Explicit App ID 或 Wildcard App ID（一组相同Prefix/Seed的App IDs）。</p><p>在网站上手动创建一个Provisioning Profile时，需要依次指定 App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的 Provisioning Profiles。</p><p>Provisioning Profile 决定 Xcode 用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product），将在应用程序打包时嵌入到 .ipa 包里。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备也通过它来认证安装的程序。</p><p>如果要打包或者在真机上运行一个APP，一般要经历以下三步：</p><ul><li>首先，需要指明它的 App ID，并且验证 Bundle ID 是否与其一致；</li><li>其次，需要证书对应的私钥来进行签名，用于标识这个 APP 是合法、安全、完整的；</li><li>然后，如果是真机调试，需要确认这台设备是否授权运行该 APP。</li></ul><p>Provisioning Profile 把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。</p><p>Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited），App ID 为 Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。</p><p>Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录 <a href="http://blog.csdn.net/iamfreedom2011/article/details/22160853" target="_blank" rel="noopener">~/Library/MobileDevice/Provisioning Profiles</a> 下。</p><h3 id="5-2-Provisioning-Profile的构成"><a href="#5-2-Provisioning-Profile的构成" class="headerlink" title="5.2 Provisioning Profile的构成"></a>5.2 Provisioning Profile的构成</h3><p>以下为典型供应配置文件 *.mobileprovision 的 <strong>构成简析</strong>：</p><blockquote><p>（1）<strong>Name</strong>：该mobileprovision的文件名。<br>（2）<strong>UUID</strong>：该mobileprovision文件的真实文件名。<br>（3）<strong>TeamName</strong>：Apple ID账号名。<br>（4）<strong>TeamIdentifier</strong>：Team Identity。<br>（5）<strong>AppIDName</strong>：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。<br>（6）<strong>ApplicationIdentifierPrefix</strong>：完整 App ID 的前缀（TeamIdentifier.*）。<br>（7）<strong>DeveloperCertificates</strong>：包含了可以为使用该配置文件应用签名的所有证书<data><array>。</array></data></p><p>证书是基于 Base64 编码，符合 PEM（PrivacyEnhanced Mail, RFC 1848）格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。</p><p>从 DeveloperCertificates 提取<data></data>之间的内容到文件cert.cer（cert.perm）：</p><p>  —–BEGIN CERTIFICATE—–</p><p>  将<data></data>之间的内容拷贝至此</p><p> —–END CERTIFICATE—–</p><p> Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥 KeyPair 配对）应吻合；Windows 下没有足够信息（WWDRCA.cer），无法验证该证书。</p><p>如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。</p><p>（8）<strong>Entitlements</strong>键<key>对应的<dict>：</dict></key></p><p> <strong>keychain-access-groups</strong>：$(AppIdentifierPrefix)，参见<strong>Code Signing Entitlements</strong>(*.entitlements)。</p><p>每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的 <strong><a href="http://blog.k-res.net/archives/1081.html" title="View all posts in keychain" target="_blank" rel="noopener">keychain</a></strong>，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。</p><p><strong>application-identifier</strong>：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。</p><p><strong>com.apple.security.application-groups</strong>：App Group ID（group. com.apple），参见<strong>Code Signing Entitlements</strong>(*.entitlements)。</p><p><strong>com.apple.developer.team-identifier</strong>：同Team Identifier。</p><p>（9）<strong><em>ProvisionedDevices</em></strong>：该mobileprovision授权的开发设备的UDID <array>。</array></p><p>Provisioning Profile <strong>被配置到</strong>【XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。</p></blockquote><h2 id="六、开发组供应配置文件（Team-Provisioning-Profiles）"><a href="#六、开发组供应配置文件（Team-Provisioning-Profiles）" class="headerlink" title="六、开发组供应配置文件（Team Provisioning Profiles）"></a>六、开发组供应配置文件（<a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppStoreDistributionTutorial/CreatingYourTeamProvisioningProfile/CreatingYourTeamProvisioningProfile.html" target="_blank" rel="noopener">Team Provisioning Profiles</a>）</h2><h3 id="6-1-Team-Provisioning-Profile的概念"><a href="#6-1-Team-Provisioning-Profile的概念" class="headerlink" title="6.1 Team Provisioning Profile的概念"></a>6.1 Team Provisioning Profile的概念</h3><p>每个Apple开发者账号都对应一个唯一的 <strong>Team ID，</strong> Xcode3.2.3 预发布版本中加入了Team Provisioning Profile这项新功能。</p><p>在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑<strong>自动生成</strong>iOS Team Provisioning Profile（Managed by Xcode）。</p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-a8e475a9e1877520?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(*)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。</p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-5d741b0c08fce2e6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><h3 id="6-2-Team-Provisioning-Profile生成-更新时机"><a href="#6-2-Team-Provisioning-Profile生成-更新时机" class="headerlink" title="6.2 Team Provisioning Profile生成/更新时机"></a>6.2 Team Provisioning Profile生成/更新时机</h3><blockquote><ul><li>Add an Apple ID account to Xcode</li><li>Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode</li><li>Assign Your App to a Team in Xcode project settings of General|Identity</li><li>Register new device on the apple development website or Xcode detected new device connected</li></ul></blockquote><p>利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。</p><p>Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也<strong>被配置到</strong>【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。</p><h2 id="七、App-Group（ID）"><a href="#七、App-Group（ID）" class="headerlink" title="七、App Group（ID）"></a>七、App Group（ID）</h2><h3 id="7-1-App-Group的概念"><a href="#7-1-App-Group的概念" class="headerlink" title="7.1 App Group的概念"></a>7.1 App Group的概念</h3><p>WWDC14除了发布了OS X v10.10和 Swift 外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（<a href="http://blog.csdn.net/phunxm/article/details/42715145" target="_blank" rel="noopener">App Extension</a>）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。</p><p>扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。</p><p>App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。</p><h3 id="7-2-App-Group的配置"><a href="#7-2-App-Group的配置" class="headerlink" title="7.2 App Group的配置"></a>7.2 App Group的配置</h3><p>Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范：</p><blockquote><ol><li>置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard）</li><li>Extension App ID以Containing App ID为Prefix/Seed</li></ol></blockquote><p>假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.<strong>extImportRecording</strong>”。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c8af62d28f5c77bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。 </p><p>App Group会<strong>被配置到</strong>【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。</p><h2 id="八、证书与签名（Certificate-amp-Signature）"><a href="#八、证书与签名（Certificate-amp-Signature）" class="headerlink" title="八、证书与签名（Certificate&amp; Signature）"></a>八、<a href="https://developer.apple.com/library/mac/documentation/Security/Conceptual/CodeSigningGuide/CodeSigningGuide.pdf" target="_blank" rel="noopener">证书与签名</a>（Certificate&amp; Signature）</h2><h3 id="8-1-Code-Signing-Identity"><a href="#8-1-Code-Signing-Identity" class="headerlink" title="8.1 Code Signing Identity"></a>8.1 Code Signing Identity</h3><p><img src="http://upload-images.jianshu.io/upload_images/5294842-13c2383966ff52da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-4208d56528145197?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。</p><p>Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性：</p><blockquote><ul><li>若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信；</li><li>再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。</li></ul></blockquote><h3 id="8-2-Code-Signing"><a href="#8-2-Code-Signing" class="headerlink" title="8.2 Code Signing"></a>8.2 Code Signing</h3><p>每个证书（其实是公钥）对应Key Pair中的<strong>私钥</strong>会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字<strong>签名</strong>（CodeSign）——使用哈希算法生成内容<strong>摘要</strong>（digest）。</p><p>Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。</p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-9bd7403097d7dde3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><h3 id="8-3-Verify-Code-Signature-with-Certificate"><a href="#8-3-Verify-Code-Signature-with-Certificate" class="headerlink" title="8.3 Verify Code Signature with Certificate"></a>8.3 Verify Code Signature with Certificate</h3><p>上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。</p><p>第一步，App在Mac／iOS真机上启动时，需要对配置的bundle ID、entitlements和certificate与Provisioning Profile进行匹配校验： </p><p><img src="http://upload-images.jianshu.io/upload_images/5294842-88c55e5e668d61f1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>第二步，iOS/Mac真机上的ios_development.cer被AppleWWDRCA.cer中的 public key解密校验合法后，获取每个开发证书中可信任的公钥对App的可靠性和完整性进行校验。</p><p>iOS/Mac设备（系统）使用App Provisioning Profile <strong>（Code Signing Identity）</strong> 中的开发证书来判断App的合法性：</p><blockquote><ul><li>若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信；</li><li>再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。</li></ul></blockquote><p><strong>小结：</strong></p><blockquote><ul><li>基于Provisioning Profile校验了CodeSign的一致性；</li><li>基于Certificate校验App的可靠性和完整性；</li><li>启动时，真机的device ID（UUID）必须在Provisioning Profile的<strong><em>ProvisionedDevices</em></strong>授权之列。</li></ul></blockquote><h2 id="九、在多台机器上共享开发账户-证书"><a href="#九、在多台机器上共享开发账户-证书" class="headerlink" title="九、在多台机器上共享开发账户/证书"></a>九、在多台机器上共享开发账户/证书</h2><h3 id="9-1-Xcode导出开发者账号-developerprofile-或PKCS12文件-p12"><a href="#9-1-Xcode导出开发者账号-developerprofile-或PKCS12文件-p12" class="headerlink" title="9.1 Xcode导出开发者账号(*.developerprofile)或PKCS12文件(*.p12)"></a>9.1 Xcode导出开发者账号(*.developerprofile)或<a href="http://certhelp.ksoftware.net/support/solutions/articles/17251-what-is-a-p12-file-or-a-pkcs12-file-" target="_blank" rel="noopener">PKCS12文件(*.p12)</a></h3><p>进入Xcode Preferences|Accounts：</p><ul><li>选中Apple IDs列表中对应Account的的Email，点击+-之后的☸|Export Accounts，可导出包含account/code signing identity/provisioning profiles信息的*.<strong>developerprofile</strong>（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。</li></ul><p>选中右下列表中某行Account Name条目|ViewDetails，可以查看Signing Identities和Provisioning Profiles。 </p><ul><li>选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权export key “privateKey” from keychain，将导出<strong><strong>Certificates.<a href="http://appfurnace.com/2015/01/how-do-i-make-a-p12-file/" target="_blank" rel="noopener">p12</a></strong></strong>。<em>**</em></li></ul><p>点击左下角的刷新按钮可从Member Center同步该账号下所有的Provisioning Profile到本地。</p><p>选中右击列表中某个Provisioning Profile可以【Show in Finder】到[~/Library/MobileDevice/Provisioning\ Profiles]目录，其中Provisioning Profile的真实名称为$(UUID).mobileprovision，名如”2488109f-ff65-442e-9774-fd50bd6bc827.mobileprovision”，其中<key>Name</key>中为Xcode中看到的描述性别名。 </p><h3 id="9-2-Keychain-Access导出PKCS12文件-p12"><a href="#9-2-Keychain-Access导出PKCS12文件-p12" class="headerlink" title="9.2 Keychain Access导出PKCS12文件(*.p12)"></a>9.2 Keychain Access导出<a href="http://blog.csdn.net/kmyhy/article/details/6431609" target="_blank" rel="noopener">PKCS12</a>文件(*.<a href="http://help.adobe.com/zh_CN/as3/iphone/WS144092a96ffef7cc-371badff126abc17b1f-7fff.html" target="_blank" rel="noopener">p12</a>)</h3><p>在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出Certificates.<a href="https://www.youtube.com/watch?v=1X10zCzhukI" target="_blank" rel="noopener">p12</a>——PKCS12 file holds the private key and certificate。 </p><p>其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书。有了共享证书之后，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件，方可在iOS真机设备上开发调试。</p><h2 id="十、证书配置常见错误"><a href="#十、证书配置常见错误" class="headerlink" title="十、证书配置常见错误"></a>十、<a href="https://developer.apple.com/library/ios/technotes/tn2318/_index.html" target="_blank" rel="noopener">证书配置常见错误</a></h2><blockquote><p>no such provisioning profile was found</p></blockquote><p>Xcode Target -&gt; Genera -&gt; Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.”</p><p>Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioning profile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！</p><blockquote><p>No identities from profile</p></blockquote><p>Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioning profile之后，Code Signing Identity中下拉提示<a href="http://stackoverflow.com/questions/21675371/no-identities-from-profile-happened-after-i-upgraded-to-xcode-5" target="_blank" rel="noopener">No identities from profile “…”</a>or No identities from keychain.</p><p>Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（<a href="http://stackoverflow.com/questions/18746703/no-identities-are-available-for-signing-xcode-5" target="_blank" rel="noopener">No identities are available</a>）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（<em>.developerprofile）或共享证书(</em>.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。</p><blockquote><p>Code Signing Entitlements file do not match profile</p></blockquote><p>“<a href="https://developer.apple.com/library/ios/qa/qa1710/_index.html" target="_blank" rel="noopener">Invalid application-identifier Entitlement</a>“ or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).”</p><p><strong>（1）</strong> 检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。<br><strong>（2）</strong> 也可以将Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。</p><blockquote><p>Xcode配置反应有时候不那么及时</p></blockquote><p>可刷新、重置相关配置项开关（若有）或重启Xcode试试。</p><h2 id="十一、Xcode7-免证书真机调试"><a href="#十一、Xcode7-免证书真机调试" class="headerlink" title="十一、Xcode7 免证书真机调试"></a>十一、<a href="http://altair21.org/156.html" target="_blank" rel="noopener">Xcode7 免证书真机调试</a></h2><p>在 Xcode 7 中，苹果改变了自己在许可权限上的策略：</p><blockquote><ol><li>此前 Xcode 只开放给注册开发者下载，现在 Xcode 7 改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。</li><li>此前开发者需每年支付99美元的费用成为注册开发者才能在 iPhone/iPad 真机上运行调试APP，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。——<a href="http://www.tuicool.com/articles/JvENzq3" target="_blank" rel="noopener">Developers would be able to test apps on devices without</a><a href="http://www.tuicool.com/articles/JvENzq3" target="_blank" rel="noopener"> a paid Apple developer account in Xcode 7</a>.</li></ol></blockquote><p>所谓“免证书”真机调试，并不是真的不需要证书，Xcode真机调试原有的证书配置体系仍在——All iOS, tvOS, and watchOS apps <strong>must be</strong> code signed and provisioned to launch on a device. 所以，上文啰嗦几千字还是有点用的。</p><p>自 Xcode7 开始，原来基于付费开发者账号及自助生成证书及配置文件的繁琐过程被苹果简化，Xcode将针对任何普通账号<strong>自动</strong>为联调真机生成所需相关的证书及配置文件。当你打算向 App Store 提交发布应用，才需要付费。</p><p>第一步：进入 Xcode Preferences|Accounts，添加自己的 Apple ID 账号。</p><p>第二步：Build Settings|Code Signing 下的 Provisioning Profile 选择 <strong>Automatic</strong>，Code Signing Identity 选择 Automatic 下的<strong>iOS Developer</strong>。</p><p>第三步：General 配置 Bundle identifier，Team 下拉选择苹果Member Center自动为你的账号生成的Personal Team ID。</p><p>自己的账号在调试公司或其他第三方APP代码时，若填写 Bundle identifier 为他人账号注册的 APP ID（例如苹果相机应用 com.apple.camera），会报错：</p><blockquote><p>No provisioning profiles with a valid signing identity (i.e. certificate and private key pair) matching the bundle identifier “com.apple.camera” were found.</p></blockquote><p>即使编译通过了，可能运行时APP自身与服务器校验也可能会报签名错误，肿么办？？？</p><blockquote><p>Her skill：此时，可以在他人原有App ID基础上添加后缀（例如com.apple.camera.<strong><em>extension</em></strong>），配置成应用的衍生插件（相当于置于同一 <a href="http://blog.csdn.net/phunxm/article/details/42715145" target="_blank" rel="noopener">App Group</a> 下）就可以快乐的玩耍了。</p><p>如果启动APP时，Xcode报错“<a href="http://www.jianshu.com/p/3b2be6454462" target="_blank" rel="noopener">process launch failed: Security</a>”或iPhone报错【<a href="http://bbs.itheima.com/thread-237009-1-1.html" target="_blank" rel="noopener">不受信任的开发者</a>】，此时需要到iPhone通用配置中的描述文件（最新系统中可能叫设备管理）中，在描述文件（开发商应用）中选择对应的描述文件（你的Apple ID）点击 <strong>信任 </strong>或 <strong>验证 </strong>即可。</p></blockquote><h2 id="十二、推送证书"><a href="#十二、推送证书" class="headerlink" title="十二、推送证书"></a>十二、推送证书</h2><p><a href="https://blog.csdn.net/zm53373581/article/details/49735329?locationNum=2&amp;fps=1" target="_blank" rel="noopener">APNS远程推送证书的申请和制作——详细解析</a><br><a href="https://blog.csdn.net/zhugq_1988/article/details/37656107" target="_blank" rel="noopener">APNS推送服务证书制作 图文详解教程</a></p><h2 id="十三、学习文章"><a href="#十三、学习文章" class="headerlink" title="十三、学习文章"></a>十三、学习文章</h2><p>《<a href="https://blog.csdn.net/zhaobingxu24/article/details/50679912" target="_blank" rel="noopener">iOS开发各种证书问题</a>》<br>《<a href="http://blog.sina.com.cn/s/blog_68e753f70100r3w5.html" target="_blank" rel="noopener">iPhone真机调试应用程序</a>》<br>《<a href="http://my.oschina.net/joanfen/blog/167730" target="_blank" rel="noopener">iOS Developer：真机测试</a>》<br>《<a href="http://www.cnblogs.com/wengzilin/p/3441116.html" target="_blank" rel="noopener">Xcode5 &amp; iOS 7 及以下版本免证书真机调试记录</a>》<br>《<a href="http://damiansheldon.github.io/blog/ios-development-certificates.html/" target="_blank" rel="noopener">iOS Development–Certificates, Provisioning Profiles</a>》<br>《<a href="http://www.cnblogs.com/cywin888/p/3263027.html" target="_blank" rel="noopener">关于Certificate、Provisioning Profile、App ID的介绍及其关系</a>》<br>《<a href="http://blog.csdn.net/phunxm/article/details/16344837" target="_blank" rel="noopener">数字签名和数字证书</a>》《<a href="http://blog.csdn.net/jerryvon/article/details/16843065" target="_blank" rel="noopener">iOS keyChain 研究</a>》<br>《<a href="http://blog.csdn.net/ryantang03/article/details/17037895" target="_blank" rel="noopener">苹果开发者账号那些事儿</a>》<br>《<a href="http://lamb-mei.com/7/ios-provisioning-profiles/" target="_blank" rel="noopener">iOS关于Provisioning Profiles這些事</a>》<br>《<a href="http://foggry.com/blog/2014/10/16/ios-code-signing-xue-xi-bi-ji/" target="_blank" rel="noopener">iOS Code Signing 学习笔记</a>》<br>《<a href="http://www.objccn.io/issue-17-2/" target="_blank" rel="noopener">代码签名探析</a>/<a href="http://www.objc.io/issue-17/inside-code-signing.html" target="_blank" rel="noopener">Inside Code Signing</a>》<br>《<a href="http://www.cnblogs.com/andyque/archive/2011/08/30/2159086.html" target="_blank" rel="noopener">iOS Code Signing: 解惑</a>/<a href="http://www.raywenderlich.com/2915/ios-code-signing-under-the-hood" target="_blank" rel="noopener">iOS Code Signing: Under The Hood</a>》<br>《<a href="http://www.cnblogs.com/yesun/archive/2013/08/16/3261839.html" target="_blank" rel="noopener">iOS行货自动打包</a>》<br>《<a href="http://blog.csdn.net/sing_sing/article/details/7576027" target="_blank" rel="noopener">解决Xcode无法生成Archive的问题</a>》<br>《<a href="http://blog.csdn.net/why_ios/article/details/7798030" target="_blank" rel="noopener">iOS程序完成后如何生成ipa进行真机测试</a>》<br>《<a href="http://blog.csdn.net/xiaoxuan415315/article/details/8217134" target="_blank" rel="noopener">发布iOS应用程序(Application Loader)</a>》<br>《<a href="http://blogs.zmit.cn/1023.html" target="_blank" rel="noopener">iOS发布遇到的一些问题</a>》<br>《<a href="http://zengwu3915.blog.163.com/blog/static/27834897201362831449893/" target="_blank" rel="noopener">Xcode打包ipa包</a>》<br>《<a href="http://blog.csdn.net/why_ios/article/details/7798030" target="_blank" rel="noopener">iOS程序生成ipa进行真机测试</a>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么是 App ID？Explicit/Wildcard App ID 有何区别？什么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS Push</title>
    <link href="http://yoursite.com/2019/05/22/iOS%20Push/"/>
    <id>http://yoursite.com/2019/05/22/iOS Push/</id>
    <published>2019-05-22T06:31:14.236Z</published>
    <updated>2019-05-22T06:31:14.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。</p><h2 id="2、push流程"><a href="#2、push流程" class="headerlink" title="2、push流程"></a>2、push流程</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-80bb8c98fe99de60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt></p><p>Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。</p><p>上图可以分为三个阶段：<br>①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。<br>②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。<br>③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b049ae989bfc6221.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="APNs流程图"></p><p>从上图可以看到：</p><p>①、在程序上注册远程通知，这是通知的前提（程序员的工作）；<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"> &#123; </span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotificationTypes:<span class="built_in">UIRemoteNotificationTypeAlert</span> | <span class="built_in">UIRemoteNotificationTypeBadge</span> | <span class="built_in">UIRemoteNotificationTypeSound</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；<br>③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    <span class="comment">//注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做）</span></span><br><span class="line">    self.deviceToken = [[[[devToken description]</span><br><span class="line"><span class="symbol">                          stringByReplacingOccurrencesOfString:</span>@<span class="string">"&lt;"</span>withString:@<span class="string">""</span>]</span><br><span class="line"><span class="symbol">                         stringByReplacingOccurrencesOfString:</span>@<span class="string">"&gt;"</span> withString:@<span class="string">""</span>]</span><br><span class="line"><span class="symbol">                        stringByReplacingOccurrencesOfString:</span> @<span class="string">" "</span> withString: @<span class="string">""</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送</span></span><br><span class="line">    [JPUSHService registerDeviceToken:devToken];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>④、将这个 token 值发送到公司的服务器上去，存储下来。<br>⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。</p><h2 id="3、APNs的限制"><a href="#3、APNs的限制" class="headerlink" title="3、APNs的限制"></a>3、APNs的限制</h2><p>APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： </p><p><strong>可靠性</strong>。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 </p><p><strong>Payload Size</strong>。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 </p><p><strong>成功率并不高</strong>。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 </p><p>理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。</p><h2 id="4、不仅仅是Local-Push"><a href="#4、不仅仅是Local-Push" class="headerlink" title="4、不仅仅是Local Push"></a>4、不仅仅是Local Push</h2><p>很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。</p><p>Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。</p><h2 id="5、叫醒你的App"><a href="#5、叫醒你的App" class="headerlink" title="5、叫醒你的App"></a>5、叫醒你的App</h2><p>开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。</p><p>唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。</p><h2 id="6、前台消息通道"><a href="#6、前台消息通道" class="headerlink" title="6、前台消息通道"></a>6、前台消息通道</h2><p>大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iOS 10 Support</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">jpushNotificationCenter</span><span class="selector-pseudo">:(UNUserNotificationCenter</span> *)<span class="selector-tag">center</span> <span class="selector-tag">didReceiveNotificationResponse</span><span class="selector-pseudo">:(UNNotificationResponse</span> *)<span class="selector-tag">response</span> <span class="selector-tag">withCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)())<span class="selector-tag">completionHandler</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">didReceiveRemoteNotification</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">userInfo</span> <span class="selector-tag">fetchCompletionHandler</span><span class="selector-pseudo">:(void</span> (^)(UIBackgroundFetchResult result))<span class="selector-tag">completionHandler</span> </span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。</p><h2 id="7、PushKit"><a href="#7、PushKit" class="headerlink" title="7、PushKit"></a>7、PushKit</h2><p>APNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。</p><p>之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。</p><p>当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。</p><p>微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。</p><h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。</p><h2 id="9、学习文章"><a href="#9、学习文章" class="headerlink" title="9、学习文章"></a>9、学习文章</h2><p><a href="http://mrpeak.cn/" target="_blank" rel="noopener">MrPeak杂货铺</a> &amp; <a href="http://mrpeak.cn/ios/2016/01/06/push" target="_blank" rel="noopener">iOS Push的门道</a><br><a href="http://hayageek.com/ios-silent-push-notifications" target="_blank" rel="noopener">Silent Push实现</a><br><a href="https://zeropush.com/guide/guide-to-pushkit-and-voip" target="_blank" rel="noopener">PushKit实现</a><br><a href="https://blog.csdn.net/zhugq_1988/article/details/37656107" target="_blank" rel="noopener">APNS推送服务证书制作 图文详解教程</a><br><a href="https://blog.csdn.net/zm53373581/article/details/49735329?locationNum=2&amp;fps=1" target="_blank" rel="noopener">APNS远程推送证书的申请和制作——详细解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt;早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 时间</title>
    <link href="http://yoursite.com/2019/05/21/iOS%20%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2019/05/21/iOS 时间/</id>
    <published>2019-05-21T08:15:20.020Z</published>
    <updated>2019-05-21T10:58:38.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、时间的形式"><a href="#1、时间的形式" class="headerlink" title="1、时间的形式"></a>1、时间的形式</h2><p>在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。</p><h3 id="1-1、GMT"><a href="#1-1、GMT" class="headerlink" title="1.1、GMT"></a>1.1、GMT</h3><p>人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。</p><p>前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。</p><h3 id="1-2、UTC"><a href="#1-2、UTC" class="headerlink" title="1.2、UTC"></a>1.2、UTC</h3><p>太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。</p><p>我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。</p><p>接下来看下iOS里，五花八门的记录时间的方式。</p><h2 id="2、NSDate"><a href="#2、NSDate" class="headerlink" title="2、NSDate"></a>2、NSDate</h2><p>NSDate是我们平时使用较多的一个类，先看下它的定义：</p><blockquote><p>NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001).</p></blockquote><p>NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。</p><p>这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。</p><p>理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="keyword">date</span> = [NSDate <span class="keyword">date</span>];</span><br><span class="line">NSLog(@"current <span class="keyword">date</span> interval: %f<span class="string">", [date timeIntervalSinceReferenceDate]);</span></span><br></pre></td></tr></table></figure></p><p>timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。</p><p>又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="keyword">date</span> = [NSDate <span class="keyword">date</span>];</span><br><span class="line">NSLog(@"current <span class="keyword">date</span>: %@<span class="string">", date);</span></span><br></pre></td></tr></table></figure></p><p>current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。</p><p>NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。</p><p>另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。</p><h2 id="3、CFAbsoluteTimeGetCurrent"><a href="#3、CFAbsoluteTimeGetCurrent" class="headerlink" title="3、CFAbsoluteTimeGetCurrent()"></a>3、CFAbsoluteTimeGetCurrent()</h2><p>官方定义如下：</p><blockquote><p>Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock.</p></blockquote><p>从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。</p><p>同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。</p><h2 id="4、gettimeofday"><a href="#4、gettimeofday" class="headerlink" title="4、gettimeofday"></a>4、gettimeofday</h2><p>这个API也能返回一个描述当前时间的值，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">gettimeofday(&amp;now, &amp;tz);</span><br><span class="line">NSLog(@<span class="string">"gettimeofday: %ld"</span>, now.tv_sec);</span><br></pre></td></tr></table></figure></p><p>使用gettimeofday获得的值是Unix time。Unix time又是什么呢？</p><p>Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。</p><p>Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> -r <span class="number">1481266031</span></span><br></pre></td></tr></table></figure></p><p>实际上NSDate也有一个API能返回Unix time：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="built_in">date</span> = [NSDate <span class="built_in">date</span>];</span><br><span class="line">NSLog(@<span class="string">"timeIntervalSince1970: %f"</span>, [<span class="built_in">date</span> timeIntervalSince1970]);</span><br></pre></td></tr></table></figure></p><p>gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。</p><h2 id="5、mach-absolute-time"><a href="#5、mach-absolute-time" class="headerlink" title="5、mach_absolute_time()"></a>5、mach_absolute_time()</h2><p>mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。</p><p>前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。</p><p>不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。</p><p>mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。</p><h2 id="6、CACurrentMediaTime"><a href="#6、CACurrentMediaTime" class="headerlink" title="6、CACurrentMediaTime()"></a>6、CACurrentMediaTime()</h2><p>CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the current CoreAnimation absolute time. This is the result of</span></span><br><span class="line"><span class="comment"> * calling mach_absolute_time () and converting the units to seconds. */</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> <span class="built_in">CACurrentMediaTime</span> (<span class="keyword">void</span>)</span><br></pre></td></tr></table></figure></p><p>CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> mediaTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CACurrentMediaTime: %f"</span>, mediaTime);</span><br></pre></td></tr></table></figure></p><p>返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimeInterval</span> systemUptime = [[<span class="built_in">NSProcessInfo</span> processInfo] systemUptime];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"systemUptime: %f"</span>, systemUptime);</span><br></pre></td></tr></table></figure></p><p>CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。</p><h2 id="7、sysctl"><a href="#7、sysctl" class="headerlink" title="7、sysctl"></a>7、sysctl</h2><p>iOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">long</span>)bootTime</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIB_SIZE 2</span></span><br><span class="line">    <span class="keyword">int</span> mib[MIB_SIZE];</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  <span class="title">boottime</span>;</span></span><br><span class="line">    </span><br><span class="line">    mib[<span class="number">0</span>] = CTL_KERN;</span><br><span class="line">    mib[<span class="number">1</span>] = KERN_BOOTTIME;</span><br><span class="line">    size = <span class="keyword">sizeof</span>(boottime);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> boottime.tv_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回的值是上次设备重启的Unix time。</p><p>这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。</p><p>有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。</p><h2 id="8、场景一，时间测量"><a href="#8、场景一，时间测量" class="headerlink" title="8、场景一，时间测量"></a>8、场景一，时间测量</h2><p>我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。</p><p>在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。</p><p>客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。</p><p>上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> testCount = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">double</span> avgCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i ++) &#123;</span><br><span class="line">    <span class="built_in">NSDate</span>* begin = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a meaningless log"</span>);</span><br><span class="line">    avgCost += -[begin timeIntervalSinceNow];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"benchmark with NSDate: %f"</span>, avgCost/testCount);</span><br><span class="line"></span><br><span class="line">avgCost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testCount; i ++) &#123;</span><br><span class="line">    <span class="keyword">double</span> startTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a meaningless log"</span>);</span><br><span class="line">    <span class="keyword">double</span> endTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    avgCost += (endTime - startTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"benchmark with CACurrentMediaTime: %f"</span>, avgCost/testCount);</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">benchmark</span> <span class="keyword">with</span> NSDate: <span class="number">0.000046</span></span><br><span class="line"><span class="built_in">benchmark</span> <span class="keyword">with</span> CACurrentMediaTime: <span class="number">0.000037</span></span><br></pre></td></tr></table></figure></p><p>可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK   NSDate *startTime = [NSDate date]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOCK   NSLog(@<span class="meta-string">"Time Cost: %f"</span>, -[startTime timeIntervalSinceNow])</span></span><br></pre></td></tr></table></figure></p><h2 id="9、场景二：客户端和服务器之间的时间同步"><a href="#9、场景二：客户端和服务器之间的时间同步" class="headerlink" title="9、场景二：客户端和服务器之间的时间同步"></a>9、场景二：客户端和服务器之间的时间同步</h2><p>这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。</p><p>比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？</p><p>上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。</p><p>首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">uint64_t</span> realLocalTime = <span class="number">0</span>;</span><br><span class="line"><span class="attribute">if</span> (serverTime != <span class="number">0</span> &amp;&amp; <span class="literal">last</span>SyncLocalTime != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="attribute">realLocalTime</span> = serverTime + (curLocalTime - <span class="literal">last</span>SyncLocalTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">else</span> &#123;</span><br><span class="line">    <span class="attribute">realLocalTime</span> = [[NSDate date] timeIntervalSince1970]*<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。</p><p>关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get system uptime since last boot</span></span><br><span class="line">- (NSTimeInterval)uptime</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">boottime</span>;</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>] = &#123;CTL_KERN, KERN_BOOTTIME&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(boottime);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    gettimeofday(&amp;now, &amp;tz);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> uptime = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;boottime, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span> &amp;&amp; boottime.tv_sec != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uptime = now.tv_sec - boottime.tv_sec;</span><br><span class="line">        uptime += (<span class="keyword">double</span>)(now.tv_usec - boottime.tv_usec) / <span class="number">1000000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uptime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。</p><p>多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。</p><h2 id="10、学习文章"><a href="#10、学习文章" class="headerlink" title="10、学习文章"></a>10、学习文章</h2><p><a href="http://mrpeak.cn/blog/ios-time/" target="_blank" rel="noopener">MrPeak杂货铺</a><br><a href="http://www.cocoachina.com/ios/20180911/24870.html" target="_blank" rel="noopener">iOS倒计时的探究与选择</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、时间的形式&quot;&gt;&lt;a href=&quot;#1、时间的形式&quot; class=&quot;headerlink&quot; title=&quot;1、时间的形式&quot;&gt;&lt;/a&gt;1、时间的形式&lt;/h2&gt;&lt;p&gt;在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo+pages建站</title>
    <link href="http://yoursite.com/2019/05/14/hexo+pages%E5%BB%BA%E7%AB%99/"/>
    <id>http://yoursite.com/2019/05/14/hexo+pages建站/</id>
    <published>2019-05-14T07:42:50.947Z</published>
    <updated>2019-05-22T03:54:40.187Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">hexo史上最全搭建教程</a></p><p><a href="https://blog.csdn.net/Greenovia/article/details/60576985" target="_blank" rel="noopener">解决用Hexo和GitHub搭建博客时hexo d命令报错问题</a></p><p><a href="https://blog.csdn.net/weixin_36401046/article/details/52940313" target="_blank" rel="noopener">hexo d后 ERROR Deployer not found: git</a></p><p><a href="https://www.cnblogs.com/ldq2016/p/7418206.html" target="_blank" rel="noopener">git-ssh 配置和使用</a></p><p><a href="https://www.jianshu.com/p/c08f4e8127a5" target="_blank" rel="noopener">给博客添加文章目录</a></p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p><a href="https://www.jianshu.com/p/0558c041e56d" target="_blank" rel="noopener">Hexo博客多台电脑设备同步管理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_37781304/article/details/82729029&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hexo史上最全搭建教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
  </entry>
  
</feed>
