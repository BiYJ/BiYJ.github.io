<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-06T14:29:26.452Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS UmbrellaFramework</title>
    <link href="http://yoursite.com/2019/11/06/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20UmbrellaFramework/"/>
    <id>http://yoursite.com/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/</id>
    <published>2019-11-06T13:44:48.817Z</published>
    <updated>2019-11-06T14:29:26.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、umbrella-framework"><a href="#一、umbrella-framework" class="headerlink" title="一、umbrella framework"></a>一、umbrella framework</h2><blockquote><p>将几个已经封装好的 framework 封装成一个，封装的这种 framework 就是 umbrella framework。</p></blockquote><p>Apple 的官方文档中明确提到了不建议自己去创建 umbrellaframework。首先先引入 Apple 的 Guidelins for Creating Frameworks 的一段：</p><blockquote><p>Don’t Create Umbrella Frameworks</p><p>While it is possible to create umbrella frameworks using Xcode, doing so is unnecessary for most developers and is not recommended. Apple uses umbrella frameworks to mask some of the interdependencies between libraries in the operating system. In nearly all cases, you should be able to include your code in a single, standard framework bundle. Alternatively, if your code was sufficiently modular, you could create multiple frameworks, but in that case, the dependencies between modules would be minimal or nonexistent and should not warrant the creation of an umbrella for them</p></blockquote><p>分三个部分逐步创建并使用 UmbrellaFramework：</p><ol><li>SubFramework：创建一个基础 framework</li><li>UmbrellaFramework：framework 里封装 framework</li><li>UmbrellaFrameworkDemo：使用 demo</li></ol><h2 id="二、创建一个基础的-framework"><a href="#二、创建一个基础的-framework" class="headerlink" title="二、创建一个基础的 framework"></a>二、创建一个基础的 framework</h2><p><a href="https://www.jianshu.com/p/eb1bdd226ea9" target="_blank" rel="noopener">UmbrellaFramework（一）创建基础framework</a></p><ol><li><p>创建一个 framework 工程：Subframework；</p> <center><br> <img src="http://dzliving.com/iOSUmbrellaFramework_1.png" alt><br> </center></li><li><p>添加 SubSayHello 类，添加 sayHello 方法；</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">SubSayHello </span>: NSObject</span><br><span class="line">- (void)sayHello;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> SubSayHello</span><br><span class="line"></span><br><span class="line">- (void)sayHello</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">NSLog</span>(@<span class="string">"say Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在 SubFramework.h 头文件中导入 SubSayHello.h</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Subframework/SubSayHello.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>将 SubSayHello.h 添加到 Target -&gt; Build Phases -&gt; Headers -&gt; Public，可手动拖拽；</p></li><li><p>Build Settings -&gt; Mach-O Type 选择 Static Library 静态库</p></li><li><p>生成通用 framework</p><ul><li><p>方式一：分别在模拟器和真机下编译工程，生成两个 framework，用命令行合并成一个通用的。</p><p>  <img src="http://dzliving.com/iOSUmbrellaFramework_0.png" alt></p>  <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -create <span class="string">[真机 Framework 二进制文件路径]</span> <span class="string">[模拟器 Framework 二进制文件路径]</span> -output <span class="string">[结果路径]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    &gt; $ lipo -create /Users/cykj/Library/Developer/Xcode/DerivedData/Subframework-hkwchwbjmtuhoseinwkzbtcjxpbj/Build/Products/Debug-iphoneos/Subframework.framework/Subframework /Users/cykj/Library/Developer/Xcode/DerivedData/Subframework-hkwchwbjmtuhoseinwkzbtcjxpbj/Build/Products/Debug-iphonesimulator/Subframework.framework/Subframework -output /Users/cykj/Desktop/Subframework    注意：如果执行命令报错，可以将结果地址改为 `/Users/cykj/Desktop/Subframework.xx`，生成后再将后缀名去掉。 * 方式二：脚本生成    * 为 SubFramework 工程添加 Target -&gt; Aggregate        ![](http://dzliving.com/iOSUmbrellaFramework_2.png)    * 在新添加的 Target 中添加脚本        ![](http://dzliving.com/iOSUmbrellaFramework_3.png)    * 脚本内容        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sets the target folders and the final framework product.</span></span><br><span class="line">FRAMEWORK_NAME=LibraryName</span><br><span class="line">FRAMEWORK_VERSION=1.0</span><br><span class="line">FRAMEWORK_CONFIG=Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install dir will be the final output to the framework.</span></span><br><span class="line"><span class="comment"># The following line create it in the root folder of the current project.</span></span><br><span class="line">INSTALL_PATH=<span class="variable">$&#123;PROJECT_DIR&#125;</span>/Products/</span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;INSTALL_PATH&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.framework</span><br><span class="line"></span><br><span class="line"><span class="comment"># Working dir will be deleted after the framework creation.</span></span><br><span class="line">WORK_DIR=build</span><br><span class="line">DEVICE_DIR=<span class="variable">$&#123;WORK_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_CONFIG&#125;</span>-iphoneos/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.framework</span><br><span class="line">SIMULATOR_DIR=<span class="variable">$&#123;WORK_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_CONFIG&#125;</span>-iphonesimulator/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.framework</span><br><span class="line"></span><br><span class="line">xcodebuild -configuration <span class="string">"<span class="variable">$&#123;FRAMEWORK_CONFIG&#125;</span>"</span> -target <span class="string">"<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> -sdk iphoneos</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Build simulator"</span></span><br><span class="line">xcodebuild -configuration <span class="string">"<span class="variable">$&#123;FRAMEWORK_CONFIG&#125;</span>"</span> -target <span class="string">"<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates install directory if it not exits.</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates headers directory if it not exits.</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/Headers"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/Headers"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove all files in the headers diectory.</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/Headers"</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">rm <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/Headers/<span class="variable">$&#123;file&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove binary library file.</span></span><br><span class="line">rm -f <span class="variable">$&#123;INSTALL_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copies the headers files to the final product folder.</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/Headers"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/Headers"</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">cp <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/Headers/<span class="variable">$&#123;file&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/Headers/<span class="variable">$&#123;file&#125;</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy nibs to bundle,then copy bundle to final folder</span></span><br><span class="line">BUNDLE_DIR=<span class="variable">$&#123;DEVICE_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.bundle</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;BUNDLE_DIR&#125;</span>"</span> ];<span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> ls <span class="variable">$&#123;DEVICE_DIR&#125;</span>/*.nib &gt;/dev/null 2&gt;&amp;1;<span class="keyword">then</span></span><br><span class="line">rm -rf <span class="variable">$&#123;BUNDLE_DIR&#125;</span>/*.nib</span><br><span class="line">cp -rf <span class="variable">$&#123;DEVICE_DIR&#125;</span>/*.nib <span class="variable">$&#123;BUNDLE_DIR&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.bundle"</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;BUNDLE_DIR&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>.bundle"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Merge with simulator"</span></span><br><span class="line"><span class="comment"># Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>/<span class="variable">$&#123;FRAMEWORK_NAME&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">open <span class="string">"<span class="variable">$&#123;INSTALL_PATH&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rm -r "$&#123;WORK_DIR&#125;"</span></span><br></pre></td></tr></table></figure></code></pre><ol start="7"><li><p>查看 framework 支持的架构</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lipo -<span class="builtin-name">info</span> [framework 二进制文件路径]</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、framework-里封装-framework"><a href="#三、framework-里封装-framework" class="headerlink" title="三、framework 里封装 framework"></a>三、framework 里封装 framework</h2><p><a href="https://www.jianshu.com/p/50d69681d7ca" target="_blank" rel="noopener">UmbrellaFramework（二）framework里封装framework</a></p><ol><li><p>创建 Cocoa Touch Framework 工程 UmbrellaFramework</p></li><li><p>导入 SubFramework</p><p> <img src="http://dzliving.com/iOSUmbrellaFramework_4.png" alt></p></li><li><p>选择 Target -&gt; Build Phases -&gt; 点击左上角+号 -&gt; New Copy Files Phase 添加 Copy Files，将 SubFramework 添加到 Copy Files，选择 Destination 为 Frameworks。</p><p> <img src="http://dzliving.com/iOSUmbrellaFramework_5.png" alt></p></li><li><p>添加 UmbrellaSayHello 类，添加 sayHello 方法，并在 sayHello 方法中调用 SubFramework 的 sayHello 方法。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UmbrellaSayHello</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)sayHello;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Subframework/SubSayHello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UmbrellaSayHello</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    SubSayHello * ssh = [[SubSayHello alloc] init];</span><br><span class="line">    [ssh test];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>UmbrellaFramework.h 头文件中导入将 UmbrellaSayHello.h</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UmbrellaFramework/UmbrellaSayHello.h&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>将 UmbrellaSayHello.h 添加到 UmbrellaFramework 的公共 headers 中</p></li><li><p>Architectures 添加 armv7s</p></li><li><p>连接选项 Mach-O Type 不用改，选择默认选项 Dynamic Library，这意味着外层的 UmbrellaFramework 是一个动态库。</p></li><li><p>生成真机和模拟器都能用的 framework。见第二章。</p></li></ol><h2 id="四、使用-UmbrellaFramework"><a href="#四、使用-UmbrellaFramework" class="headerlink" title="四、使用 UmbrellaFramework"></a>四、使用 UmbrellaFramework</h2><p><a href="https://www.jianshu.com/p/895621ecfc32" target="_blank" rel="noopener">UmbrellaFramework（三）使用demo</a></p><ol><li><p>创建工程 UmbrellaFrameworkDemo</p></li><li><p>嵌入UmbrellaFramework，选择工程 -&gt; General -&gt; Embedded binaries，添加UmbrellaFramework。UmbrellaFramework 将会同时添加到 Linked Frameworks and Libraries.</p><p> <img src="http://dzliving.com/iOSUmbrellaFramework_6.png" alt></p></li><li><p>工程中使用</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import &lt;UmbrellaFramework/UmbrellaFramework.h&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">super viewDidLoad</span>];</span><br><span class="line">    </span><br><span class="line">    UmbrellaSayHello * ush = [[UmbrellaSayHello alloc] init];</span><br><span class="line">    [<span class="meta">ush sayHello</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、umbrella-framework&quot;&gt;&lt;a href=&quot;#一、umbrella-framework&quot; class=&quot;headerlink&quot; title=&quot;一、umbrella framework&quot;&gt;&lt;/a&gt;一、umbrella framework&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS umbrella header</title>
    <link href="http://yoursite.com/2019/11/06/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20UmbrellaHeader/"/>
    <id>http://yoursite.com/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/</id>
    <published>2019-11-06T12:49:53.868Z</published>
    <updated>2019-11-06T14:58:37.061Z</updated>
    
    <content type="html"><![CDATA[<blockquote><font color="#FF9900">Lexical or Preprocessor Issue - Umbrella header for module ‘xxx’ does not include header ‘xxx.h’</font></blockquote><p>framework 的文件明明被主工程引用了，但是在编译的时候依旧抛出上面的警告。</p><h2 id="一、什么是-umbrella-header"><a href="#一、什么是-umbrella-header" class="headerlink" title="一、什么是 umbrella header?"></a>一、什么是 umbrella header?</h2><p>参考官方文档<a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1" target="_blank" rel="noopener">《Introduction to Framework Programming Guide》</a>，可以了解到 Framework 区分Standard Framework 和 Umbrella Framework。但是并没有找到官方文档有对 Umberlla framework 给出明确的定义。在官方文档<a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC" target="_blank" rel="noopener">《Anatomy of Framework Bundles》</a>章节中， 找到三段比较合理说明 Umbrella Framework 的话：</p><blockquote><p>Umbrella frameworks add minor refinements to the standard framework structure， such as the ability to encompass other frameworks</p></blockquote><blockquote><p>The structure of an umbrella framework is similar to that of a standard framework， and applications do not distinguish between umbrella frameworks and standard frameworks when linking to them. However， two factors distinguish umbrella frameworks from other frameworks. The first is the manner in which they include header files. The second is the fact that they encapsulate subframeworks.</p></blockquote><blockquote><p>Physically， umbrella frameworks have a similar structure to standard frameworks. One significant difference is the addition of a Frameworks directory to contain the subframeworks that make up the umbrella framework.</p></blockquote><p>字面上的意思应该是在标准的 Framework 做了一些改良的工作，使其可以嵌套包含 Framework。在物理结构上，Umbrella Framework 只在包含头文件的方式以及是否包含子 Framework 和普通的 Framework 存在区别。</p><p>那么引用头文件的地方又有什么区别呢? 还是参考官方文档引用:</p><blockquote><p>For most frameworks， you can include header files other than the master header file. You can include any specific header file you want as long as it is available in the framework’s Headers directory. However， if you are including an umbrella framework， you must include the master header file. Umbrella frameworks do not allow you to include the headers of their constituent subframeworks directly. See Restrictions on Subframework Linking for more information.</p></blockquote><p>简单翻译一下: 普通的 Framework 可以通过引用对应的 heaedr 文件而不是 <font color="#cc0000">Master Header File</font> 去引用需要使用的类，只需要对应的 header 头文件在 Headers 文件夹下暴露，并没有强制要求引用 Master Header File。Umbrella Framework 要求必须要引用 Master Header File，并且头文件中不能直接引用子 Framework 的东西。</p><p>上述描述已经说了 Umbrella Framework 一定要引用 Master Header File，而 <font color="#cc0000">Umbrella Framework 的 Master Header File 就是 Umbrella header 文件</font>。</p><p>官方说明中只有强制规定一定要引用 Umbrella Header 文件，但是却没有说能不能单独引用 Umbrella Framework 的其他头文件呢? 我们可以自己试验一下:</p><ol><li>在 Umbrella Framework 新建一个 testObject 类，分别产生了 testObject.h 和 testObject.m 文件。</li><li>打开 Framework 配置文件，在 Build Phases的Headers 里的 Public 目录下，将 testObject.h 文件添加进去。</li><li>Build Framework 看是否报错。</li><li>在主工程中调用初始化 testObject 对象，看编译是否报错。</li></ol><p>执行结果:</p><ul><li>步骤3: 没有编译报错， 但是报出了 <font color="#ff9900">Lexical or Preprocessor Issue - Umbrella header for module ‘STDemoUI’ does not include header ‘testObject.h’</font>的警告。</li><li>步骤4: 执行正常。</li></ul><p>总结一下:</p><ol><li>Standard Framework 不能包含 Sub Framework；Umbrella Framework 可以包含子 Framework;</li><li>Standard Framework 可以直接引用需要使用的头，也可以通过引用 Master Header file 来引用需要使用的类；Umbrella Framework 需要通过引用 Master Header File(Umbrella Header) 来引用需要使用的类;</li></ol><h2 id="二、规范的写法"><a href="#二、规范的写法" class="headerlink" title="二、规范的写法"></a>二、规范的写法</h2><p>Umbrella Framework 默认会创建一个同名 .h 文件做为 Umbrella Header 文件。规范的写法当然是遵从默认的模式，将所有需要暴露的头文件都写在 Umbrella Header 文件中。</p><p>例如: STDemoUI.framework 工程包含了 STClassOne、STClassTwo 和 STClassThree 三个类。</p><p>STDemoUI 会生成一个默认的伞头文件（直译 Umbrella Header）STDemoUI.h。假设该 framework 的三个类均需要在外部调用使用，则 STDemoUI.h 需要将三个类的引用均写入伞头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STDemoUI.h</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;STDemoUI/STClassOne.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;STDemoUI/STClassTwo.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;STDemoUI/STClassThree.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>在需要调用的主工程中， 仅仅只要将 Umbrella Header 引用即可调用所有在 Umbrella Header 中包含的类了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主工程需要应用的类中包含Umbrella Header</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;STDemoUI/STDemoUI.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="三、重命名-umbrella-header"><a href="#三、重命名-umbrella-header" class="headerlink" title="三、重命名 umbrella header"></a>三、重命名 umbrella header</h2><p>如果大家都遵从默认的 Umbrella Framework 的写法，在同名头文件中写需要暴露的引用头文件，那么就不需要考虑怎么重命名 Umbrella header 了。</p><p>很多时候，理想和现实是有差距的，程序员写代码多数是在二次接手进行开发的。假设公司的前辈已经将 Framework 的同名文件用作了一个逻辑类， 给同名文件创建了 .m 文件， 并已经书写了逻辑并应用了各个工程里面去了。那么显然迁移头文件功能代码是不可能的，因为很多依赖该 Framework 的业务部门都需要针对库进行代码优化。</p><p>在这种不能将同名文件作为 Umbrella header 的情况下，我们又不想通过 Public 强制暴露头文件的情况下（不写在 Umbrella Header 中会有警告）。我们就需要对 Umbrella Header 进行指定了。</p><ol><li><p>指定 Umbrella Header 入口在哪里呢?</p><ul><li>在工程全局搜索 umbrella 关键字 - <font color="#cc0000">Failed</font></li><li>在Build Settings里搜索umbrella关键字 - <font color="#cc0000">Failed</font></li><li><p>在打包好的 STDemoUI.framework 中搜索 umbrella 关键字 - <font color="#65AC47">Success</font></p><p>双击点开 STDemo.framework，内容如下：</p><p><img src="http://dzliving.com/iOSUmbrellaHeader_1.png" alt></p><p>初略看名称可以推测出每个文件以及文件夹所承担的作用:</p></li><li><p>_CodeSignature：保存签名相关文件</p></li><li>Headers：framework 暴露的所有头文件</li><li>Info.plist：描述了该 framework 所包含的项目配置信息</li><li>UmbrellaFramework：编译后的核心库文件</li><li>Modules：模块相关文件夹， 目测只包含了 module.modulemap 文件</li><li><p>Frameworks：包含的子 framework</p><p>我们在 module.modulemap 文件中找到了 umbrella 关键字。文件内容如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">framework <span class="keyword">module</span> STDemoUI &#123;</span><br><span class="line">  umbrella header <span class="string">"STDemoUI.h"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> *</span><br><span class="line">  <span class="keyword">module</span> * &#123; <span class="keyword">export</span> * &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 Framework 的 umbrella header 是在这个位置被指定的，但是这个已经是编译好的工程， 我们总不能每次编译好了再进到包里面修改下。既然我们已经找到 umbrella header 是在 module 中去指定，那么我们就用 module 作为关键字再去 Build Settings 里重新搜索下。</p><p>这回在 Kernel Module 和 Packaging 中均找到了 Module 关键字，在 Packaging 标签中，有一项 Module Map File 属性，看名字应该是用来指定 modulemap 文件的。</p><p><img src="http://dzliving.com/iOSUmbrellaHeader_0.png" alt></p></li></ul></li><li><p>指定 Modulemap 文件</p><ol><li>创建一个新的 .h 文件，如：STHeader.h。将所有需要暴露的头文件均写入 STHeader.h</li><li>创建一个新的 modulemap 文件，如：stdemoalt.modulemap</li><li><p>在新的 modulemap 中指定 umbrella header</p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">framework <span class="keyword">module</span> STDemoUI &#123;</span><br><span class="line">    umbrella header <span class="string">"STHeader.h"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">    <span class="keyword">module</span> * &#123; <span class="keyword">export</span> * &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 framework 的 Build Settings 中的 Module Map File 指定新建的 modulemap 文件。</p></li><li><p>CMD+B 编译，打开 framework 包中的 Module 文件夹，看是否包含了新指定的 modulemap。</p></li></ol></li></ol><p>抛出两个疑问:</p><ol><li>Module 是什么?</li><li>如果 Defines Module 指定为 NO， 那会发生什么事情呢?</li></ol><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本文简单的梳理了官方文章关于 Umbrella Framework 和 Umbrella Header 的介绍说明，产生警告的原因是没有引用 umbrella header 或者暴露头没有写在 umbrella header 中。在 umbrella header 被已使用的前提下，本文提供了一种通过重命名 Umbrella Header 文件的方式来消除警告的解决方案。</p><p>虽然引用警告可以被消除，但是建议大家还是采用规范的做法：尽量不要在同名头文件中写业务逻辑代码， 用同名文件作为 Umbrella 库的 Master Header File。</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.jianshu.com/p/894a36643758" target="_blank" rel="noopener">iOS - Umbrella Header在framework中的应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;font color=&quot;#FF9900&quot;&gt;Lexical or Preprocessor Issue - Umbrella header for module ‘xxx’ does not include header ‘xxx.h’&lt;/font&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 图片</title>
    <link href="http://yoursite.com/2019/11/06/iOS/iOS%E5%AA%92%E4%BD%93/iOS%20%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/11/06/iOS/iOS媒体/iOS 图片/</id>
    <published>2019-11-06T07:50:47.319Z</published>
    <updated>2019-11-06T11:49:10.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、图片加载的工作流"><a href="#一、图片加载的工作流" class="headerlink" title="一、图片加载的工作流"></a>一、图片加载的工作流</h2><p>概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下：</p><ol><li>假设我们使用 <code>+imageWithContentsOfFile:</code> 方法从磁盘中加载一张图片，此时的图片并没有解压缩；</li><li>然后将生成的 UIImage 赋值给 UIImageView；</li><li>接着一个隐式的 <code>CATransaction</code> 捕获到了 UIImageView 图层树的变化；</li><li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<ul><li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li><li>将文件数据从磁盘读到内存中；</li><li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li><li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li></ul></li></ol><p>由上面的步骤可知，图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p><h2 id="二、为什么需要解压缩"><a href="#二、为什么需要解压缩" class="headerlink" title="二、为什么需要解压缩"></a>二、为什么需要解压缩</h2><p>既然图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3" target="_blank" rel="noopener">位图</a>：</p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.</p></blockquote><p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。</p><p>下面是一张 PNG 图片，像素为 30 × 30，文件大小为 843B：</p><center><br><img src="http://dzliving.com/ImageDecode_0.png" alt><br></center><p>使用<a href="https://developer.apple.com/library/content/qa/qa1509/_index.html" target="_blank" rel="noopener">下面的代码</a>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"check_green"</span>];</span><br><span class="line"><span class="built_in">CFDataRef</span> rawData = <span class="built_in">CGDataProviderCopyData</span>(<span class="built_in">CGImageGetDataProvider</span>(image.CGImage));</span><br></pre></td></tr></table></figure><p>就可以获取到这个图片的原始像素数据，大小为 3600B ：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">01020102</span> <span class="number">032</span>c023c <span class="number">0567048</span>c <span class="number">078</span>d06bf <span class="number">08</span>a006d9 <span class="number">09</span>b307f3 <span class="number">09</span>b307f3 <span class="number">08</span>a006d9 <span class="number">078</span>d06bf</span><br><span class="line"><span class="number">0567048</span>c <span class="number">032</span>c023c <span class="number">01020102</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">01060108</span> <span class="number">05570476</span> <span class="number">09</span>ab07e9 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>ab07e9 <span class="number">05570476</span> <span class="number">01060108</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">033</span>d0353 <span class="number">08</span>a607e2 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line">...</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">08</span>a607e2 <span class="number">033</span>d0353 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">01060108</span> <span class="number">05570476</span> <span class="number">09</span>ab07e9 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>ab07e9 <span class="number">05570476</span> <span class="number">01060108</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01020102</span> <span class="number">032</span>c023c <span class="number">0567048</span>c</span><br><span class="line"><span class="number">078</span>d06bf <span class="number">08</span>a006d9 <span class="number">09</span>b307f3 <span class="number">09</span>b307f3 <span class="number">08</span>a006d9 <span class="number">078</span>d06bf <span class="number">0567048</span>c <span class="number">032</span>c023c <span class="number">01020102</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>也就是说，这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p><blockquote><p>解压缩后的图片大小(3600) = 图片的像素宽(30) <em> 图片的像素高(30) </em> 每个像素所占的字节数(4)</p></blockquote><p>至于这个公式是怎么得来的，后面会有详细的说明。</p><p>至此，我们已经知道了什么是位图，并且直观地看到了它的原始像素数据，那么它与我们经常提到的图片的二进制数据有什么联系吗？是同一个东西吗？事实上，这二者是完全独立的两个东西，它们之间没有必然的联系。为了加深理解，我把这个图片拖进 Sublime Text 2 中，得到了这个图片的二进制数据，大小与原始文件大小一致，为 843B：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8950</span> <span class="number">4e47</span> <span class="number">0</span>d0a <span class="number">1</span>a0a <span class="number">0000</span> <span class="number">000</span>d <span class="number">4948</span> <span class="number">4452</span> <span class="number">0000</span> <span class="number">001</span>e <span class="number">0000</span> <span class="number">001</span>e <span class="number">0806</span> <span class="number">0000</span> <span class="number">003</span>b <span class="number">30</span>ae a200</span><br><span class="line"><span class="number">0000</span> <span class="number">0173</span> <span class="number">5247</span> <span class="number">4200</span> aece <span class="number">1</span>ce9 <span class="number">0000</span> <span class="number">0305</span> <span class="number">4944</span> <span class="number">4154</span> <span class="number">480</span>d c557 <span class="number">4</span>d68 <span class="number">1341</span> <span class="number">149</span>e <span class="number">3709</span> da4d</span><br><span class="line"><span class="number">09</span>c6 <span class="number">8</span>a56 <span class="number">2385</span> <span class="number">9e14</span> f458 <span class="number">4</span>fa2 d092 f4a6 <span class="number">28</span>d8 <span class="number">2222</span> de04 <span class="number">3</span>d09 a1d0 <span class="number">7</span>a50 <span class="number">0954</span> <span class="number">8</span>bad <span class="number">2</span>d05</span><br><span class="line"><span class="number">4</span>fde <span class="number">3</span>c89 <span class="number">482</span>b <span class="number">2</span>ad6 <span class="number">8334</span> d183 e049 ef9e <span class="number">4</span>a41 <span class="number">48</span>b0 <span class="number">42</span>eb a549 <span class="number">6893</span> <span class="number">1</span>ddf <span class="number">9</span>bcd b4d9 d9d9</span><br><span class="line"><span class="number">4</span>dd8 a43a b0d9 <span class="number">9</span>d79 <span class="number">3</span>fdf bc79 <span class="number">3</span>ff3 <span class="number">02</span>ac <span class="number">8591</span> <span class="number">1559</span> <span class="number">3e97</span> <span class="number">9</span>b3e <span class="number">5</span>b05 fb32 <span class="number">6330</span> c098 <span class="number">48</span>a2</span><br><span class="line"><span class="number">183</span>d <span class="number">340</span>a b886 <span class="number">8</span>ff8 <span class="number">1e15</span> fced <span class="number">587</span>a e26b <span class="number">16</span>b2 b643 f2ff <span class="number">057</span>f <span class="number">1263</span> fd9f fbbb <span class="number">7</span>ed7 <span class="number">7</span>edd</span><br><span class="line"><span class="number">1142</span> <span class="number">8</span>c09 <span class="number">268</span>e <span class="number">04</span>f1 <span class="number">2</span>a1a <span class="number">3058</span> <span class="number">0380</span> b9c3 <span class="number">91</span>de a7ab <span class="number">43</span>ab <span class="number">15</span>b5 aebf <span class="number">7</span>d81 ad65 eb0a <span class="number">5</span>a31</span><br><span class="line"><span class="number">8</span>f4f <span class="number">9</span>f2e d4da <span class="number">1</span>c7e e249 <span class="number">64</span>ca c3e5 d726 <span class="number">7</span>eae <span class="number">2</span>fa2 <span class="number">7510</span> cb75 <span class="number">3</span>d62 cc5e <span class="number">0</span>c0f <span class="number">4</span>a5a <span class="number">69</span>c3</span><br><span class="line">...</span><br><span class="line"><span class="number">36</span>ac b11e <span class="number">7006</span> f71b <span class="number">5386</span> a2b7 <span class="number">1e48</span> ad82 a26a <span class="number">2880</span> <span class="number">95</span>db <span class="number">3</span>f8b f525 b880 e0ed <span class="number">7221</span> <span class="number">75</span>f1</span><br><span class="line">fa02 <span class="number">2</span>cd4 <span class="number">1</span>af7 <span class="number">1</span>d0e <span class="number">546</span>a <span class="number">98e5</span> d4ae <span class="number">342</span>a <span class="number">337</span>e <span class="number">6</span>b96 <span class="number">134</span>f <span class="number">1</span>ba0 <span class="number">0</span>c0b c83b a0f2 <span class="number">3593</span> <span class="number">7</span>b5c</span><br><span class="line"><span class="number">6</span>ca9 b541 cb4f <span class="number">254</span>e df58 d958 <span class="number">8955</span> a0fc <span class="number">2638</span> <span class="number">658</span>c <span class="number">2660</span> f986 b5f1 f4dd <span class="number">63</span>f2 <span class="number">5</span>aec ce59</span><br><span class="line">e3b6 b0a7 cdac ee55 <span class="number">145</span>c c7dc <span class="number">8</span>f60 f53f e0a6 b436 e3c0 <span class="number">27</span>b0 <span class="number">8</span>ecf <span class="number">5054</span> <span class="number">336</span>a ccd0 e1d8</span><br><span class="line"><span class="number">2335</span> <span class="number">1</span>f78 <span class="number">323</span>d <span class="number">6141</span> <span class="number">09</span>c3 c1aa <span class="number">5</span>f8b <span class="number">4e37</span> <span class="number">0899</span> e6b0 ed72 <span class="number">4046</span> <span class="number">759</span>e d262 <span class="number">5247</span> <span class="number">9</span>d01 <span class="number">1689</span></span><br><span class="line">a976 <span class="number">55</span>fb c993 <span class="number">6</span>ed5 <span class="number">7</span>d10 <span class="number">8</span>ff4 b162 fe6f cd1e ee4a d4bb c18e <span class="number">594</span>e <span class="number">96</span>ea <span class="number">1</span>da6 c762 <span class="number">6539</span></span><br><span class="line">bdff <span class="number">7943</span> afc0 c91f bdd1 a327 <span class="number">28</span>fc <span class="number">29</span>f7 d47a b337 f192 <span class="number">0</span>cc9 <span class="number">36</span>fa <span class="number">5497</span> <span class="number">73</span>f9 <span class="number">5827</span> aa39</span><br><span class="line"><span class="number">1599</span> <span class="number">4</span>eff <span class="number">69</span>fb <span class="number">0</span>b0d <span class="number">1</span>f7a <span class="number">96</span>cd <span class="number">3</span>eb0 <span class="number">7800</span> <span class="number">0000</span> <span class="number">0049</span> <span class="number">454</span>e <span class="number">44</span>ae <span class="number">4260</span> <span class="number">82</span></span><br></pre></td></tr></table></figure><p>事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">return</span> <span class="built_in">image</span> as PNG. May <span class="built_in">return</span> nil <span class="keyword">if</span> <span class="built_in">image</span> has no CGImageRef <span class="keyword">or</span> invalid bitmap format</span><br><span class="line">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull <span class="built_in">image</span>);</span><br><span class="line"></span><br><span class="line">// <span class="built_in">return</span> <span class="built_in">image</span> as JPEG. May <span class="built_in">return</span> nil <span class="keyword">if</span> <span class="built_in">image</span> has no CGImageRef <span class="keyword">or</span> invalid bitmap format. compression <span class="built_in">is</span> <span class="number">0</span>(most)..<span class="number">1</span>(least)</span><br><span class="line">UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull <span class="built_in">image</span>, CGFloat compressionQuality);</span><br></pre></td></tr></table></figure><p>因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p><h2 id="三、强制解压缩的原理"><a href="#三、强制解压缩的原理" class="headerlink" title="三、强制解压缩的原理"></a>三、强制解压缩的原理</h2><p>既然图片的解压缩不可避免，而我们也不想让它在主线程执行，影响应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。</p><p>当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。</p><p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是  <code>CGBitmapContextCreate</code>：</p><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/* Create a bitmap context. The context draws into a bitmap which <span class="keyword">is</span> `width'</span><br><span class="line">   pixels wide <span class="keyword">and</span> `height' pixels high. The number <span class="keyword">of</span> components <span class="keyword">for</span> each</span><br><span class="line">   pixel <span class="keyword">is</span> specified <span class="keyword">by</span> `space', which may also specify a destination color</span><br><span class="line">   profile. The number <span class="keyword">of</span> bits <span class="keyword">for</span> each component <span class="keyword">of</span> a pixel <span class="keyword">is</span> specified <span class="keyword">by</span></span><br><span class="line">   `bitsPerComponent'. The number <span class="keyword">of</span> bytes <span class="keyword">per</span> pixel <span class="keyword">is</span> equal to</span><br><span class="line">   `(bitsPerComponent * number <span class="keyword">of</span> components + 7)/8'. Each row <span class="keyword">of</span> the bitmap</span><br><span class="line">   consists <span class="keyword">of</span> `bytesPerRow' bytes, which must <span class="keyword">be</span> at least `width * bytes</span><br><span class="line">   <span class="keyword">per</span> pixel' bytes; <span class="keyword">in</span> addition, `bytesPerRow' must <span class="keyword">be</span> an integer multiple</span><br><span class="line">   <span class="keyword">of</span> the number <span class="keyword">of</span> bytes <span class="keyword">per</span> pixel. `data', if non-NULL, points to a block</span><br><span class="line">   <span class="keyword">of</span> memory at least `bytesPerRow * height' bytes. If `data' <span class="keyword">is</span> NULL, the</span><br><span class="line">   data <span class="keyword">for</span> context <span class="keyword">is</span> allocated automatically <span class="keyword">and</span> freed when the context <span class="keyword">is</span></span><br><span class="line">   deallocated. `bitmapInfo' specifies whether the bitmap should contain an</span><br><span class="line">   alpha channel <span class="keyword">and</span> how it's to <span class="keyword">be</span> generated, along with whether the</span><br><span class="line">   components are floating-point <span class="keyword">or</span> integer. </span><br><span class="line"> */</span><br><span class="line">CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</span><br><span class="line"></span><br><span class="line">#### 3.1 Pixel Format</span><br><span class="line"></span><br><span class="line">位图其实就是一个像素数组，而[像素格式](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG)则是用来描述每个像素的组成格式，它包括以下信息：</span><br><span class="line"></span><br><span class="line">* Bits <span class="keyword">per</span> component：一个像素中每个独立的颜色分量使用的 bit 数；</span><br><span class="line">* Bits <span class="keyword">per</span> pixel：一个像素使用的总 bit 数；</span><br><span class="line">* Bytes <span class="keyword">per</span> row：位图中的每一行使用的字节数。</span><br><span class="line"></span><br><span class="line">有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/Supported Pixel Formats.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant，我们在后面会详细介绍。</span><br><span class="line"></span><br><span class="line">#### 3.2 Color <span class="keyword">and</span> Color Spaces</span><br><span class="line"></span><br><span class="line">什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 (0, 0, 1)。而&lt;font color=#cc0000&gt;颜色空间则是用来说明如何解析这些值的&lt;/font&gt;，离开了颜色空间，它们将变得毫无意义。比如,下面的值都表示蓝色：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/blue_color.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 (0, 0, 1) 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/color_profiles.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.3 Color Spaces <span class="keyword">and</span> Bitmap Layout</span><br><span class="line"></span><br><span class="line">像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供[位图的布局信息](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB) CGBitmapInfo：</span><br></pre></td></tr></table></figure><p>typedef CF_OPTIONS(uint32_t, CGBitmapInfo) {<br>    kCGBitmapAlphaInfoMask = 0x1F,</p><pre><code>kCGBitmapFloatInfoMask = 0xF00,kCGBitmapFloatComponents = (1 &lt;&lt; 8),kCGBitmapByteOrderMask     = kCGImageByteOrderMask,kCGBitmapByteOrderDefault  = (0 &lt;&lt; 12),kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big</code></pre><p>} CG_AVAILABLE_STARTING(<strong>MAC_10_0, </strong>IPHONE_2_0);<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它主要提供了三个方面的布局信息：</span><br><span class="line"></span><br><span class="line"><span class="comment">* alpha 的信息；</span></span><br><span class="line"><span class="comment">* 颜色分量是否为浮点数；</span></span><br><span class="line"><span class="comment">* 像素格式的字节顺序。</span></span><br><span class="line"></span><br><span class="line">其中，<span class="keyword">alpha</span> 的信息由枚举值 CGImageAlphaInfo 来表示：</span><br></pre></td></tr></table></figure></p><p>typedef CF_ENUM(uint32_t, CGImageAlphaInfo) {<br>    kCGImageAlphaNone,               /<em> For example, RGB. </em>/<br>    kCGImageAlphaPremultipliedLast,  /<em> For example, premultiplied RGBA </em>/<br>    kCGImageAlphaPremultipliedFirst, /<em> For example, premultiplied ARGB </em>/<br>    kCGImageAlphaLast,               /<em> For example, non-premultiplied RGBA </em>/<br>    kCGImageAlphaFirst,              /<em> For example, non-premultiplied ARGB </em>/<br>    kCGImageAlphaNoneSkipLast,       /<em> For example, RBGX. </em>/<br>    kCGImageAlphaNoneSkipFirst,      /<em> For example, XRGB. </em>/<br>    kCGImageAlphaOnly                /<em> No color data, alpha data only </em>/<br>};<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>是否包含 alpha；</span><br><span class="line"><span class="bullet">* </span>如果包含 alpha，那么 alpha 信息所处的位置，在像素的[<span class="string">最低有效位</span>](<span class="link">https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D</span>)，比如 RGBA，还是[<span class="string">最高有效位</span>](<span class="link">https://zh.wikipedia.org/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D</span>)，比如 ARGB；</span><br><span class="line"><span class="bullet">* </span>如果包含 alpha，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。</span><br><span class="line"></span><br><span class="line">那么我们在解压缩图片的时候应该使用哪个值呢？根据 [<span class="string">Which CGImageAlphaInfo should we use</span>](<span class="link">http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use</span>) 和官方文档中对 <span class="code">`UIGraphicsBeginImageContextWithOptions`</span> 函数的讨论：</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; You use this function to configure the drawing environment for rendering into a bitmap. The format for the bitmap is a ARGB 32-bit integer pixel format using host-byte order. If the opaque parameter is YES, the alpha channel is ignored and the bitmap is treated as fully opaque (kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host). Otherwise, each pixel uses a premultipled ARGB format (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host).</span></span><br><span class="line"></span><br><span class="line">我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host，而这个值具体是什么，后面再讨论。</span><br><span class="line"></span><br><span class="line">至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</span><br><span class="line"></span><br><span class="line">接下来，我们来简单地了解下像素格式的[<span class="string">字节顺序</span>](<span class="link">https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH</span>)，它是由枚举值 CGImageByteOrderInfo 来表示的：</span><br></pre></td></tr></table></figure></p><p>typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) {<br>    kCGImageByteOrderMask     = 0x7000,<br>    kCGImageByteOrder16Little = (1 &lt;&lt; 12),<br>    kCGImageByteOrder32Little = (2 &lt;&lt; 12),<br>    kCGImageByteOrder16Big    = (3 &lt;&lt; 12),<br>    kCGImageByteOrder32Big    = (4 &lt;&lt; 12)<br>} CG_AVAILABLE_STARTING(<strong>MAC_10_12, </strong>IPHONE_10_0);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它主要提供了两个方面的字节顺序信息：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">小端模式</span>](<span class="link">https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F</span>)还是[<span class="string">大端模式</span>](<span class="link">https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F</span>)；</span><br><span class="line"><span class="bullet">* </span>数据以 16 位还是 32 位为单位。</span><br><span class="line"></span><br><span class="line">对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 [<span class="string">Hardcoding</span>](<span class="link">https://en.wikipedia.org/wiki/Hard_coding</span>)：</span><br></pre></td></tr></table></figure></p><p>#ifdef <strong>BIG_ENDIAN</strong></p><pre><code>#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big</code></pre><p>#else /<em> Little endian. </em>/</p><pre><code>#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little</code></pre><p>#endif<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</span><br><span class="line"></span><br><span class="line">下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/colorformatrgba32.gif)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</span><br><span class="line"></span><br><span class="line">好了，了解完这些相关知识后，我们再回过头来看看 CGBitmapContextCreate 函数中每个参数所代表的具体含义：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</span><br><span class="line"><span class="bullet">* </span>width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</span><br><span class="line"><span class="bullet">* </span>bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 [<span class="string">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</span>](<span class="link">http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters</span>) 和 [<span class="string">Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?</span>](<span class="link">http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</span><br><span class="line"><span class="bullet">* </span>bitmapInfo ：就是我们前面提到的位图的布局信息。</span><br><span class="line">到这里，你已经掌握了强制解压缩图片需要用到的最核心的函数，点个赞。</span><br><span class="line"></span><br><span class="line"><span class="section">## 四、开源库的实现</span></span><br><span class="line"></span><br><span class="line">接下来，我们来看看在三个比较流行的开源库 [<span class="string">YYKit</span>](<span class="link">https://github.com/ibireme/YYKit</span>)、[<span class="string">SDWebImage</span>](<span class="link">https://github.com/rs/SDWebImage</span>) 和 [<span class="string">FLAnimatedImage</span>](<span class="link">https://github.com/Flipboard/FLAnimatedImage</span>) 中，对图片的强制解压缩是如何实现的。</span><br><span class="line"></span><br><span class="line">首先，我们来看看 YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 [<span class="string">YYImageCoder</span>](<span class="link">https://github.com/ibireme/YYKit/blob/master/YYKit/Image/YYImageCoder.m</span>) 类中，核心代码如下：</span><br></pre></td></tr></table></figure></p><p>CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) {<br>    …</p><pre><code>if (decodeForDisplay) { // decode with redraw (may lose some precision)    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;    BOOL hasAlpha = NO;    if (alphaInfo == kCGImageAlphaPremultipliedLast ||        alphaInfo == kCGImageAlphaPremultipliedFirst ||        alphaInfo == kCGImageAlphaLast ||        alphaInfo == kCGImageAlphaFirst) {        hasAlpha = YES;    }    // BGRA8888 (premultiplied) or BGRX8888    // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]    CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;    bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);    if (!context) return NULL;    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode    CGImageRef newImage = CGBitmapContextCreateImage(context);    CFRelease(context);    return newImage;} else {    ...}</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它接受一个原始的位图参数 imageRef，最终返回一个新的解压缩后的位图 newImage，中间主要经过了以下三个步骤：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>使用 CGBitmapContextCreate 函数创建一个位图上下文；</span><br><span class="line"><span class="bullet">2. </span>使用 CGContextDrawImage 函数将原始位图绘制到上下文中；</span><br><span class="line"><span class="bullet">3. </span>使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。</span><br><span class="line"></span><br><span class="line">事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别，如下表所示：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/CGBitmapContextCreate.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">在上表中，用浅绿色背景标记的参数即为我们在前面的分析中所推荐的参数，用这些参数解压缩后的图片渲染的速度会更快。因此，从理论上说 YYKit 中的解压缩算法是三者之中最优的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 五、性能对比</span></span><br><span class="line"></span><br><span class="line">[<span class="string">测试源码 GitHub 地址</span>](<span class="link">https://github.com/leichunfeng/Image-Decompression-Benchmark</span>)。</span><br><span class="line"></span><br><span class="line">采用的测试样例分别为 5 张 PNG 图片和 5 张 JPEG 图片，像素依次为 128x96、256x192 、512x384、1024x768 和 2048x1536，它们其实都长一个样：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/128x96.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">首先，我们来了解下测试的原理，我们可以将从磁盘加载一张图片到最终渲染到屏幕上的过程划分为三个阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>初始化阶段：从磁盘初始化图片，生成一个未解压缩的 UIImage 对象；</span><br><span class="line"><span class="bullet">* </span>解压缩阶段：分别使用 YYKit、SDWebImage 和 FLAnimatedImage 对第 1 步中得到的 UIImage 对象进行解压缩，得到一个新的解压缩后的 UIImage 对象；</span><br><span class="line"><span class="bullet">* </span>绘制阶段：将第 2 步中得到的 UIImage 对象绘制到屏幕上。</span><br><span class="line"></span><br><span class="line">这里我们以绘制阶段的耗时为依据来评测解压缩的性能，解压缩的算法越优秀，那么得到的图片就越符合系统渲染时的需求，绘制的时间也就越短。为了让测试的结果更准确，我们对每张图片都解压缩 10 次，然后取平均值。说明，本次使用的测试设备是 iPhone 5s 。</span><br><span class="line"></span><br><span class="line">首先，我们来看看解压缩 PNG 图片的测试结果：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress<span class="emphasis">_png_</span>compare.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">相应的柱状图如下：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress_png.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">从上图可以看出，就我们采用的测试样例来说，解压缩 PNG 图片的性能 SDWebImage 最好，FLAnimatedImage 次之，YYKit 最差。这与我们前面的理论结果有一定的差距，可能是测试样例太少，也可能这就是真实结果。另外，需要说明的是，我们这里使用的 PNG 图片都是不带 alpha 值，因为 SDWebImage 不支持解压缩带 alpha 值的 PNG 图片。</span><br><span class="line"></span><br><span class="line">接着，我们再来看看解压缩 JPEG 图片的测试结果：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress<span class="emphasis">_jpeg_</span>compare.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">相应的柱状图如下：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress_jpeg.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">解压缩 JPEG 图片的性能最好，SDWebImage 和 FLAnimatedImage 并列第二。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 六、总结</span></span><br><span class="line"></span><br><span class="line">要理解 iOS 中图片的解压缩并不难，重点是要理解位图的概念。而图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程。了解这些知识，将有助于我们更好地处理图片，管理好它们所占用的内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 七、其他</span></span><br><span class="line"></span><br><span class="line">[<span class="string">飘金</span>](<span class="link">https://www.jianshu.com/u/da7864faa1be</span>) - [<span class="string">iOS 图片解码</span>](<span class="link">https://www.jianshu.com/p/e9843d5b70a2</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.1 图片的存储消耗</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>磁盘空间或者通过网络传输所消耗的空间</span><br><span class="line"><span class="bullet">2. </span>解压缩空间，通常是长 <span class="bullet">* 宽 *</span> 高 * 4字节（RGBA）</span><br><span class="line"><span class="bullet">3. </span>当显示在一个 view 中时，view 本身也需要空间来存储 layer</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.2 图片加载时间</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>从磁盘上 alloc/initUIImage 的时间</span><br><span class="line"><span class="bullet">2. </span>解压缩的时间</span><br><span class="line"><span class="bullet">3. </span>将解压缩后的比特转换成 CGContext 的时间，通常需要改变尺寸、混合、抗锯齿工作。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.3 小 Tips</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>如何把 GIF 动图保存到相册？</span><br></pre></td></tr></table></figure></p><pre><code>[ALAssetsLibrary writeImageDataToSavedPhotosAlbum:metadata:completionBlock];// 图像会被强制转码为 PNG 格式UIImageWriteToSavedPhotosAlbum();```</code></pre><ol start="2"><li><p>将 UIImage 保存到磁盘，用什么方式最好？</p><p> 保存 UIImage 有三种方式：</p><ul><li>直接用 NSKeyedArchiver 把 UIImage 序列化保存；</li><li>用 UIImagePNGRepresentation() 先把图片转为 PNG 保存；</li><li><p>用 UIImageJPEGRepresentation() 把图片压缩成 JPEG 保存。</p><p>实际上，NSKeyedArchiver 是调用了 UIImagePNGRepresentation 进行序列化的，用它来保存图片是消耗最大的。苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。所以如果图片不包含透明像素时，<code>UIImageJPEGRepresentation(0.9)</code> 是最佳的图片保存方式，其次是 UIImagePNGRepresentation()。</p></li></ul></li><li><p>UIImage 缓存是怎么回事？</p><p> 通过 <code>imageNamed:</code> 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存。</p><p> 在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在<font color="#cc0000">(待验证)</font>。</p></li><li><p>用 imageWithData: 能不能避免缓存呢？</p><p> 不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 <code>CGImageSourceCreateWithData()</code> 方法。该方法有个参数叫 <code>ShouldCache</code>，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed: 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p></li><li><p>怎么能避免缓存?</p><ol><li>手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。</li><li>把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。</li></ol></li><li><p>我能直接取到图片解码后的数据，而不是通过画布取到吗？</p><ol><li>CGImageSourceCreateWithData(data) 创建 ImageSource。</li><li>CGImageSourceCreateImageAtIndex(source) 创建一个未解码的 CGImage。</li><li>CGImageGetDataProvider(image) 获取这个图片的数据源。</li><li><p>CGDataProviderCopyData(provider) 从数据源获取直接解码的数据。</p><p>ImageIO 解码发生在最后一步，这样获得的数据是没有经过颜色类型转换的原生数据（比如灰度图像）。</p></li></ol></li><li><p>如何判断一个文件的图片类型？</p><p> 通过读取文件或数据的头几个字节然后和对应图片格式标准进行比对。</p></li><li><p>怎样像浏览器那样边下载边显示图片？</p><ul><li><p>baseline 逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。</p><p>  <img src="http://dzliving.com/UIImage_1.gif" alt></p></li><li><p>interlaced 隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。</p><p>  <img src="http://dzliving.com/UIImage_2.gif" alt></p></li><li><p>progressive 渐进式。JPEG 在保存时可以选择这种方式。</p><p>  <img src="http://dzliving.com/UIImage_3.gif" alt></p><p>在下载图片时，首先用 CGImageSourceCreateIncremental(NULL) 创建一个空的图片源，随后在获得新数据时调用 CGImageSourceUpdateData(data, false) 来更新图片源，最后在用 CGImageSourceCreateImageAtIndex() 创建图片来显示。</p><p>可以用 <a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="noopener">PINRemoteImage</a> 或者 <a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage</a> 来实现这个效果。</p></li></ul></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="http://blog.leichunfeng.com/" target="_blank" rel="noopener">雷纯锋的技术博客</a> - <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina" target="_blank" rel="noopener">谈谈 iOS 中图片的解压缩</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、图片加载的工作流&quot;&gt;&lt;a href=&quot;#一、图片加载的工作流&quot; class=&quot;headerlink&quot; title=&quot;一、图片加载的工作流&quot;&gt;&lt;/a&gt;一、图片加载的工作流&lt;/h2&gt;&lt;p&gt;概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下：&lt;
      
    
    </summary>
    
      <category term="iOS媒体" scheme="http://yoursite.com/categories/iOS%E5%AA%92%E4%BD%93/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 优化实例</title>
    <link href="http://yoursite.com/2019/11/05/iOS/iOS%E4%BC%98%E5%8C%96/iOS%20%E4%BC%98%E5%8C%96%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/11/05/iOS/iOS优化/iOS 优化实例/</id>
    <published>2019-11-05T13:43:13.701Z</published>
    <updated>2019-11-06T08:14:27.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口请求优化"><a href="#一、接口请求优化" class="headerlink" title="一、接口请求优化"></a>一、接口请求优化</h2><p>在工程项目中，多个一级界面包含状态，如：服务入口的动态配置，未读消息数量，图片文字等，因此产品设计要每次切换 tab 时都请求数据，及时的更新页面状态。在实际开发中，频繁的调用接口，频繁的刷新界面显然是影响用户体验的，所以需要进行优化，优化的思路有以下几点：</p><ol><li>使用 loading + 默认灰色矩形视图；</li><li><p>每隔 15s 以上才请求一次，防止频繁触发请求</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CFTimeInterval</span> lastTi;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">[<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFTimeInterval</span> nowTi = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.lastTi &lt;= <span class="number">0</span> || nowTi - <span class="keyword">self</span>.lastTi &gt; <span class="number">15</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span> makeRequestAction];</span><br><span class="line"><span class="keyword">self</span>.lastTi = nowTi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)makeRequestAction</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 接口请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>CACurrentMediaTime() 在退到后台、手动修改设备时间后没有影响。</code></pre><ol start="3"><li><p>对数据进行判断，数据没有更新不需要刷新界面。这里要注意，存储的是不是字符串，而是字符串的 hash 值，因为长度比较小。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> compareHash;  <span class="comment">// 判断列表数据是否更新</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSUInteger</span> hash = [data.mainTools componentsJoinedByString:<span class="string">@""</span>].hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.compareHash == hash) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.compareHash = hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新界面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里的策略还是存在点问题：</p><ol><li>不能处理好未读标识。比如当进入子界面详情时，这里需要更新未读状态，但因为 15s 的限制，而不能及时刷新；</li></ol><h2 id="二、界面优化"><a href="#二、界面优化" class="headerlink" title="二、界面优化"></a>二、界面优化</h2><ol><li><p>使用 Debug -&gt; View Debugging -&gt; Rendering 中的界面渲染选项，进行界面优化</p> <center><br> <img src="http://dzliving.com/iOSDebugRender.png" alt><br> </center></li><li><p>cell 滚动停止时加载</p></li></ol><h2 id="三、资源加载优化"><a href="#三、资源加载优化" class="headerlink" title="三、资源加载优化"></a>三、资源加载优化</h2><ol><li><p>图片加载</p><blockquote><p>imageNamed:</p></blockquote><p> 利用它可以方便加载资源图片。用 imageNamed 的方式加载时，会把图像数据根据它的名字缓存在系统内存中，以提高 imageNamed 方法获得相同图片的 image 对象的性能。即使生成的对象被  autoReleasePool 释放了，这份缓存也不释放。而且没有明确的释放方法。如果图像比较大，或者图像比较多，用这种方式会消耗很大的内存。</p><p> 优点：加载图片速度快；<br> 缺点：耗内存大，适用于小图片并且会被频繁读取的图片。</p><blockquote><p>imageWithContentsOfFile:</p></blockquote><p> 加载的图片是不会缓存的。得到的对象时 autoRelease 的，当 autoReleasePool 释放时才释放。</p><p> 优点：图片数据不缓存，节省内存；<br> 缺点：加载图片速度相对慢，每次读取图片都要从路径下寻找并解析图片数据。适用于会用到的图片数据不大，且不经常用到的。</p><p> imageNamed: 加载会缓存在内存中，对于常用的图片可以放在 asset 里，不常用的图片放在 bundle 的路径下通过 imageWithContentsOfFile: 获取图片资源。</p></li></ol><pre><code>&gt; initWithContentsOfFile:一般用在封面等图比较大的地方。适用于大图片，且不经常要用的图片。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">4</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">self.loadImageView.image = [UIImage imageNamed:@<span class="string">"icon"</span>];</span><br><span class="line">//self.loadImageView.image = [UIImage imageWithContentsOfFile:<span class="string">[[NSBundle mainBundle] pathForResource:@"icon" ofType:@"png"]]</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>* imageNamed:    &lt;center&gt;    ![](http://dzliving.com/iOSimageNamed_0.png)    ![](http://dzliving.com/iOSimageNamed_1.png)    &lt;/center&gt;* imageWithContentsOfFile:    &lt;center&gt;    ![](http://dzliving.com/iOSimageFile_0.png)    ![](http://dzliving.com/iOSimageFile_1.png)    &lt;/center&gt;在有缓存的情况下，即使运行 100000 次，也不会等待很久，而 imageWithContentsOfFile: 会等待很久，且内存持续增长。</code></pre><ol start="2"><li><p>UITableView 中使用 imageNamed: 加载图片，频繁上下滑动时 CPU 耗时不断增长。</p><p> 原本期望 imageNamed: 创建了缓存的，不应该持续耗费 cpu 时间，结果却耗费了 6-700ms，多处合起来有几秒。</p><p> 优化思路是自己使用 NSDictionary 或 NSCache 存储 images，使用时根据 key 来获取。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSString</span> * kAPlaceholderImageKey;</span><br><span class="line">FOUNDATION_EXTERN <span class="built_in">NSString</span> * kBPlaceholderImageKey;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageForKey:(<span class="built_in">NSString</span> *)placeholderImageKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件</span></span><br><span class="line"><span class="built_in">NSString</span> * kAPlaceholderImageKey = <span class="string">@"APlaceholderImageKey"</span>;</span><br><span class="line"><span class="built_in">NSString</span> * kBPlaceholderImageKey = <span class="string">@"BPlaceholderImageKey"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)imageForKey:(<span class="built_in">NSString</span> *)placeholderImageKey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.imageCache objectForKey:placeholderImageKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief 缓存 cell 中需要重复使用的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSCache</span> *)imageCache</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_imageCache == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _imageCache = [[<span class="built_in">NSCache</span> alloc] init];</span><br><span class="line">        [_imageCache setObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"1"</span>] forKey:kAPlaceholderImageKey];</span><br><span class="line">        [_imageCache setObject:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"2"</span>] forKey:kBPlaceholderImageKey];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、接口请求优化&quot;&gt;&lt;a href=&quot;#一、接口请求优化&quot; class=&quot;headerlink&quot; title=&quot;一、接口请求优化&quot;&gt;&lt;/a&gt;一、接口请求优化&lt;/h2&gt;&lt;p&gt;在工程项目中，多个一级界面包含状态，如：服务入口的动态配置，未读消息数量，图片文字等，因此产
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 操作系统架构</title>
    <link href="http://yoursite.com/2019/11/05/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2019/11/05/iOS/iOS原理/iOS 操作系统架构/</id>
    <published>2019-11-05T07:11:27.306Z</published>
    <updated>2019-11-05T07:18:01.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、iOS-系统架构层次"><a href="#一、iOS-系统架构层次" class="headerlink" title="一、iOS 系统架构层次"></a>一、iOS 系统架构层次</h2><center><br><img src="http://dzliving.com/iOSStructure_0.jpg" alt><br></center><p>在 iOS 中，<font color="#cc0000">框架是一个目录</font>，包含了共享资源库，用于访问该资源库中储存的代码的头文件，以及图像、声音文件等其他资源。共享资源库定义应用程序可以调用的函数和方法。</p><p>iOS 为应用程序开发提供了许多可使用的框架，并构成 iOS 操作系统的层次架构，分为四层：</p><ol><li><p>Cocoa Touch 可触摸层</p><p> 这一层为我们的应用程序开发提供了各种有用的框架，并且大部分与用户界面有关，本质上来说它<font color="#cc0000">负责用户在 iOS 设备上的触摸交互操作</font>。</p><blockquote><p>包括：Address Book UI Framework、Event Kit UI Framework、Game Kit Framework、iAd Framework、Map Kit Framework、Message UI Framework、UIKit Framework 等等，这一层基本都是<font color="#cc0000">基于 Objective-C</font> 的接口。</p></blockquote></li><li><p>Media 媒体层</p><p> 通过它我们可以在应用程序中<font color="#cc0000">使用各种媒体文件</font>，进行音频与视频的录制，图形的绘制，以及制作基础的动画效果。</p><blockquote><p>包含 Core Graphics、Core Animation、OpenGL ES、Core Text、Image I/O、Assets Library Framework、Media Player Framework、AV Foundation、OpenAL、Core Audio Frameworks、Core Media 等等</p></blockquote></li><li><p>Core Services 核心服务层</p><p> 可以通过它来访问 iOS 的一些服务。</p><blockquote><p>包含 Address Book Framework、CFNetwork Framework、Core Data Framework、Core Foundation Framework、Core Location Framework、Core Media Framework、Core Telephony Framework、Event Kit Framework、Foundation Framework、Mobile Core Services Framework、Quick Look Framework、Store Kit Framework、System Configuration Framework、Block Objects、Grand Central Dispatch 、In App Purchase、Location Services、SQLite、XML Support 等一些框架，也基本都是<font color="#cc0000">基于 c 语言</font>的接口。</p></blockquote></li><li><p>Core OS 是位于 iOS 系统架构最下面的一层是核心操作系统层</p><p> 它包括内存管理、文件系统、电源管理以及一些其他的操作系统任务。它可以直接和硬件设备进行交互。作为app开发者不需要与这一层打交道。</p><blockquote><p>包含 Accelerate Framework、External Accessory Framework、Security Framework、System 等几个框架，基本都是<font color="#cc0000">基于 c 语言</font>的接口。</p></blockquote></li></ol><p>低层次框架提供 iOS 的基本服务和技术；高层次框架建立在低层次框架之上，用来提供更加复杂的服务和技术，较高级的框架向较低级的结构提供面向对象的抽象。</p><p>在开发应用时应尽可能使用较高级的框架。如果要开发的功能在高层框架中没有提供，也可以使用较低层框架和技术。</p><p>Foundation 和 UIKit 框架是应用编程用到的两个主要的框架，能够满足大多数应用程序的开发需求。</p><p>UIKit 框架提供的类，用于创建基于触摸的用户界面。所有 iOS 应用程序都是基于 UIKit，没有这个框架，就无法交付应用程序。UIKit 提供应用程序的基础架构，用于在屏幕上绘图、处理事件，以及创建通用用户界面及其中元素。UIKit 还通过管理屏幕上显示的内容，来组织应用程序。</p><p>Foundation 框架为所有应用程序提供基本的系统服务。应用程序以及 UIKit 和其他框架，都是建立在Foundation 框架的基础结构之上。Foundation 框架提供许多基本的对象类和数据类型，使其成为应用程序开发的基础。它还制定了一些约定（如用于取消分配等任务），使代码更加一致，可复用性更好。</p><h2 id="二、Cocoa-Touch-Layer"><a href="#二、Cocoa-Touch-Layer" class="headerlink" title="二、Cocoa Touch Layer"></a>二、Cocoa Touch Layer</h2><center><br><img src="http://dzliving.com/iOSStructure_2.png" alt><br></center><p>Cocoa Touch 层包含如下框架：</p><h4 id="2-1-Address-Book-UI-Framework"><a href="#2-1-Address-Book-UI-Framework" class="headerlink" title="2.1 Address Book UI Framework"></a>2.1 Address Book UI Framework</h4><p>地址本 UI 框架。</p><p>该框架提供一个面向对象的编程接口。用来显示标准的系统接口，来创建新的联系人和编辑和选择已存在的联系人。</p><h4 id="2-2-Event-Kit-UI-Framework"><a href="#2-2-Event-Kit-UI-Framework" class="headerlink" title="2.2 Event Kit UI Framework"></a>2.2 Event Kit UI Framework</h4><p>月历事件 UI 框架。</p><p>该框架提供一个视图控制器来呈现标准的系统接口，来观察和编辑月历相关的事件。EventKit UI Framework 基于 Event Kit framework 框架。</p><h4 id="2-3-Game-Kit-Framework"><a href="#2-3-Game-Kit-Framework" class="headerlink" title="2.3 Game Kit Framework"></a>2.3 Game Kit Framework</h4><p>游戏工具框架。</p><p>该框架实现对游戏中心的支持，让用户能够在线共享他们的游戏相关的信息。</p><h4 id="2-4-iAd-Framework"><a href="#2-4-iAd-Framework" class="headerlink" title="2.4 iAd Framework"></a>2.4 iAd Framework</h4><p>iAD 框架。</p><p>该框架用来在应用中提供广告条。当你想要显示广告时，广告条与用户 UI 上的标准的视图进行合并。这些视图与苹果的 iAd 服务一起工作，自动处理、加载和呈现富媒体广告以及应答在那些广告条上的点击等所有相关的工作。</p><h4 id="2-5-Map-Kit-Framewor"><a href="#2-5-Map-Kit-Framewor" class="headerlink" title="2.5 Map Kit Framewor"></a>2.5 Map Kit Framewor</h4><p>地图工具框架。</p><p>MapKit 提供与应用的 UI 组合的一个可滚动的地图。</p><p>除了显示一个地图，你能使用该框架接口来定制地图的内容和外观，也能使用注解来标记感兴趣的点，也能使用定制的内容来与地图内容叠置。例如，你可以在地图上来画一条公交路线，或者使用注解来高亮显示附近的商店和餐馆。</p><p>除了显示地图，MapKit 框架还能与地图应用以及苹果的地图服务器集成来为用户指引方向。</p><p>地图应用能够给任意支持方向的应用提供方向的代理。如提供特定类型方向的应用，例如一个显示地铁路线的应用，能登记请求接收地图应用提供的方向。</p><p>应用也能向苹果的服务器请求步行或驾驶方向，并与他们定制的方向的路径信息混合来为用户提供完整的点到点体验。</p><h4 id="2-6-Message-UI-Framework"><a href="#2-6-Message-UI-Framework" class="headerlink" title="2.6 Message UI Framework"></a>2.6 Message UI Framework</h4><p>消息 UI 框架。</p><p>该框架用来在应用中提供编辑邮件和 sms 消息的支持。</p><p>编辑支持包括一个呈现到你的应用的视图控制器接口，并能设置这个视图控制器的一些区域，如接收人、主题、邮件主体和邮件想包括的任意附件。</p><p>在呈现视图控制器后，也能为用户提供一个在发送邮件之前可以编辑邮件的选项。</p><h4 id="2-7-UIKit-Framework"><a href="#2-7-UIKit-Framework" class="headerlink" title="2.7 UIKit Framework"></a>2.7 UIKit Framework</h4><p>该框架提供实现图形和事件驱动的应用的至关重要的基础。包括：</p><ol><li>基本的应用管理和基础设施，包括应用的主循环；</li><li>用户接口管理，包括对 storyboards 和 nib 文件的支持；</li><li>一个用来封装用户 UI 内容的视图控制器模式；</li><li>标准系统视图和控制对象；</li><li>提供处理触摸和运动事件的支持；</li><li>支持包括与 iCloud 集成功能的文档模式；</li><li>图形和窗口支持，包括支持外部显示器；</li><li>多任务支持；</li><li>打印支持；</li><li>定制标准 UIKit 控制的外观；</li><li>支持文本和 web 内容；</li><li>剪切、复制、粘贴的支持；</li><li>支持动画 UI；</li><li>通过 url 语义和框架接口与系统提供的其它应用集成的能力；</li><li>对有障碍用户的可存取性的支持；</li><li>支持 ApplePush Notification 服务；</li><li>本地通知调度和提交；</li><li>pdf 创建；</li><li>支持定制像系统键盘行为一样的用户输入视图；</li><li>支持创建与系统键盘交互的定制的文本视图；</li><li>支持通过 email，Twitter，Facebook和其它服务共享内容。</li></ol><p>也支持一些设备特定功能的集成：</p><ol><li>内建的摄像机；</li><li>用户的图片库；</li><li>设备名和模式信息；</li><li>电池状态信息；</li><li>接近传感器信息；</li><li>来自附件耳机的远程控制信息</li></ol><h2 id="三、MediaLayer"><a href="#三、MediaLayer" class="headerlink" title="三、MediaLayer"></a>三、MediaLayer</h2><center><br><img src="http://dzliving.com/iOSStructure_3.png" alt><br></center><p>媒体层包含在应用中实现多媒体体验的图形、声音、视频技术和框架。使用这层的技术可以使你容易的建立更加好看和好听的应用。</p><h4 id="3-1-图形技术"><a href="#3-1-图形技术" class="headerlink" title="3.1 图形技术"></a>3.1 图形技术</h4><p>高质量的图形是所有应用的重要的组成部分。iOS 提供了许多帮助你定制艺术和图形屏幕的技术。iOS 图形技术为其提供了广泛的支持，并可以与 UIKit 视图架构无缝工作。</p><p>你能使用标准的视图来快速提交高质量的接口，或者使用本层的图形技术创建你自己的定制视图来提交一个更加丰富的图形体验。</p><ol><li><p>UIKit graphics</p><ul><li>UIKit 定义的绘制图像和 Bézier 路径，以及动画视图内容的高级别技术。</li><li>UIKit 视图提供快速和有效的方式来呈现图像和文本内容。</li><li>UIKIT 视图也能通过显示和使用 UIKitdynamics 技术进行动画，并为用户提供反馈，促进用户交互。</li></ul></li><li><p>CoreGraphics 框架</p><p> CoreGraphics 也称作 Quartz，是对定制的 2D 向量和图像呈现提供支持的本地绘制引擎。</p><p> 该框架提供的引擎虽然没有 OpenGLES 引擎速度快，但该框架能够很好地适合于呈现定制的 2D 图形和动态图像。</p></li><li><p>CoreAnimation 框架</p><p> CoreAnimation 也是 Quartz 核心框架的一部分，是优化应用动画体验的基础技术。</p><p> UIKit 视图基于 Core Animation 提供视图级别的动画支持。当你想对动画行为有更多控制时也能直接使用 CoreAnimation。</p></li><li><p>Core Image</p><p> CoreImage 提供非破坏的方式操作视频和静态图像。</p></li><li><p>OpenGL ES 及 GLKit</p><ul><li>OpenGLES 使用硬件加速接口来处理先进的 2D 和 3D 呈现。OpenGLES 通常由游戏开发者或想实现沉浸式图像体验的开发者使用。</li><li>OpenGLES 框架提供对呈现过程的全部控制，以及提供创建平滑动画所需要的帧速。</li><li>GLKit 是一组 Objective-C 类，以便能够使用面向对象接口来提供 OpenGL ES 的强大能力。</li></ul></li><li><p>Text Kit 和 CoreText</p><ul><li>Text Kit 是 UIKit 框架的家族，用来执行最好的排面和文本管理。如果你的应用实现先进的文本操作，Text Kit 提供与应用视图的无缝集成。</li><li>CoreText 是处理先进排面和布局的低级别的 C 语言框架。</li></ul></li><li><p>Image I/O</p><p> ImageI/O 提供读写大多数图像格式的接口。</p></li><li><p>Assets Library</p><p> AssetsLibrary 框架让你存取用户的图片、视频和媒体。你想在应用中集成用户自己的内容时可以使用该框架。</p></li></ol><h4 id="3-2-声音技术"><a href="#3-2-声音技术" class="headerlink" title="3.2 声音技术"></a>3.2 声音技术</h4><p>声音技术工作于底层硬件之上，为用户提供更加丰富的声音体验。这些体验包括播放和记录高质量的声音、处理MIDI内容以及使用设备内建的声音 等能力</p><ol><li><p>Media Player framework</p><p> 该框架是一个高级别的框架， 用来为用户提供对 iTunes 库存取的容易方式，也提供对播放轨迹和播放列表的支持。</p><p> 当你想快速在应用中集成声音以及不需要控制播放行为时可以使用该框架。</p></li><li><p>AV Foundation</p><p> AVFoundation 是管理声音以及视频播放和记录的面向对象接口。在记录声音和想对声音播放过程有更好的控制时可以使用该框架。</p></li><li><p>OpenAL</p><p> OpenAL 是一个提供位置音效的跨平台的工业标准技术和接口。游戏开发者经常使用该技术来提供高质量的声音。</p></li><li><p>Core Audio</p><p> Core Audio 是一组简单和智能的接口来记录和播放声音以及 MIDI 内容。在需要对声音有更好控制时使用该框架。</p></li></ol><h4 id="3-3-视频技术"><a href="#3-3-视频技术" class="headerlink" title="3.3 视频技术"></a>3.3 视频技术</h4><p>视频技术提供管理应用中的静态视频内容或者播放来自 Internet 的视频流的支持。对于带有适当的记录硬件的设备，该框架还能够记录视频以及与应用进行集成。</p><ol><li><p>UIImagePickerController</p><p> UIImagePickerController 是一个选择用户媒体文件的 UIKit 视图控制器。</p></li><li><p>Media Player</p><p> MediaPlayer 框架提供一组呈现视频内容的简单易用的接口，该框架支持全屏和小窗口视频播放，也为用户提供可选的播放控制。</p></li><li><p>AVFoundation</p><p> AVFoundation 提供先进的视频播放和记录能力。</p><p> 在需要对视频呈现和记录有更多的控制时使用该框架，例如在实时应用中分层显示实时视频和应用提供的其它内容。</p></li><li><p>CoreMedia</p><p> CoreMedia 框架为操作媒体定义低级别的数据类型和接口。当你需要对视频内容有无比的控制时可以使用该框架。</p></li></ol><h4 id="3-4-AirPlay-技术"><a href="#3-4-AirPlay-技术" class="headerlink" title="3.4 AirPlay 技术"></a>3.4 AirPlay 技术</h4><p>AirPlay 让应用串流声音和视频内容到 Apple TV 或者串流声音内容到第三方扬声器和接收器。</p><p>AirPlay 内建于许多框架，包括 UIKit、Media Player、AVFoundation、Core Audio。因此在大多数情况你不需要为了支持它做任何事。</p><p>在使用那些框架时，当播放内容时自动获得 AirPlay 支持。当用户选择使用 AirPlay 播放内容时系统自动进行路由。</p><table><thead><tr><th style="text-align:left">框架</th><th style="text-align:left">服务内容</th></tr></thead><tbody><tr><td style="text-align:left">Assets Library</td><td style="text-align:left">AssetsLibrary.framework 提供对用户设备上图片应用管理的图片和视频的存取。<br><br>使用该框架来存取用户保存的图片相册或导入到设备的任意相册中的图片，你也能保存新的图片和视频到用户的图片相册。</td></tr><tr><td style="text-align:left">AV Foundation</td><td style="text-align:left">AVFoundation.framework 提供一组播放、记录和管理声音和视频内容的Objective-C 类。<br><br>当你想在应用的 UI 接口无缝集成媒体能力时使用该框架。你也能使用它来进行更先进的媒体处理，例如同时播放多个声音或者控制播放和记录过程的多个方面。<br><br>该框架提供的服务包括: <br>1. 声音会话管理，包括对系统声明你的应用声音能力；<br>2. 对应用媒体资源的管理；<br>3. 对编辑媒体内容的支持；<br>4. 捕捉声音和视频的能力；<br>5. 播放声音和视频的能力；<br>6. 轨迹管理；<br>7. 媒体元数据的管理；<br>8. 立体拍摄；<br>9. 声音之间的精确同步；<br>10. 提供一个确定声音文件细节内容的 Objective-C 接口，例如数据格式，采样率，通道数；<br>          11. 通过 AirPlay 串流内容。</td></tr><tr><td style="text-align:left">Core Audio</td><td style="text-align:left">Core Audio 是一个对声音处理提供本地支持的框架家族。这些框架支持声音的产生、记录、混合和回放。<br><br>你也能使用这些接口处理 MIDI 内容以及串流声音和 MIDI 内容到其它应用。<br><br>Core Audio 框架包括如下框架：<br>1. CoreAudio.framework：定义 Core Audio 框架使用的所有数据类型。<br>2. AudioToolbox.framework：提供声音文件和声音流的播放和记录服务。也提供管理声音文件，播放系统警告声音，在某些设备上触发震动的支持。<br>3. AudioUnit.framework：提供使用内建声音单元。也提供使你的应用的声音内容作为对其它应用可视的声音组件的支持。<br>4. CoreMIDI.framework：提供与 MIDI 设备通讯的标准方式，包括硬件键盘和合成器。你使用这个框架来发送和接收 MIDI 消息以及与通过 dock 连接器或网络连接到 iOS 设备的 MIDI 外设交互。<br>5. MediaToolbox.framework：提供对声音 tap 接口的存取。</td></tr><tr><td style="text-align:left">Core Graphics</td><td style="text-align:left">CoreGraphics.framework 包含Quartz 2D 绘制 api。<br><br>Quartz 是一个原先用在 OS X 的先进的、向量绘制引擎。Quartz 支持路径绘制，抗锯齿呈现，剃度、图像、颜色、坐标空间转换以及 pdf 内容创建、显示和分析等功能。<br><br>虽然这个 api 是 C-based 接口，但它使用了面向对象抽象来表现基本的绘制对象，因此使它容易存储和重用图形内容。</td></tr><tr><td style="text-align:left">Core Image</td><td style="text-align:left">CoreImage.framework 提供一组强大的内建过滤器来操作视频和静态图像。<br><br>你能在触摸弹起、纠正图片以及面部和特征检测等许多方面使用这些内建的过滤器。这些过滤器的先进特点是它们操作在非破坏方式，即原先的图像不被改变。<br><br>这些过滤器针对底层硬件进行了优化，因此它们是快速和有效的。</td></tr><tr><td style="text-align:left">Core Text</td><td style="text-align:left">CoreText.framework 提供一个对文本进行布局和字体处理的简单的、高性能的 C-based 接口。<br><br>该框架用在不使用 TextKit 但仍想获得在字处理应用中发现的先进文本处理能力。<br><br>该框架提供了一个智能的文本布局引擎，包括在其它内容周围环绕文本的能力，它也支持使用多种字体和呈现属性的先进的文本风格。</td></tr><tr><td style="text-align:left">Core Video</td><td style="text-align:left">CoreVideo.framework 为 Core Media 框架提供缓冲和缓冲池支持。多数应用从不直接使用该框架。</td></tr><tr><td style="text-align:left">Game Controller</td><td style="text-align:left">GameController.framework 让你在应用中发现和配置针对 iPhone/iPod/iPad 设备的游戏控制器。<br><br>游戏控制器可以是物理连接到 iOS 设备或者是通过蓝牙无线连接。GameController 框架当控制器可获得时通知你的应用让应用可以规定哪个控制器输入与你的应用相关。</td></tr><tr><td style="text-align:left">GLKit</td><td style="text-align:left">GLKit.framework 包含一组简化创建 OpenGLES 应用的 Objective-C based 单元类。<br><br>GLKit 支持应用开发的四个关键领域：<br>1. GLKView 和 GLKViewController 类提供一个 OpenGLES 视图和其呈现循环的标准实现。OpenGLES 视图代表应用管理底层的 framebuffer 对象。应用只需在视图上绘制。<br>2. GLKTextureLoader 类提供在你的应用中使用图像转换和加载线程，允许应用自动加载纹理图像到应用的上下文。能够异步或同步加载纹理。当异步加载纹理时，应用应提供一个完成处理块，该处理块在纹理加载进应用上下文时被调用。<br>3. GLKit 框架提供向量、矩阵和 3D 旋转以及提供 OpenGLES 1.1 上的矩阵。<br>4. GLKBaseEffect、GLKSkyboxEffect 和 GLKReflectionMapEffect 类实现给通用图形操作提供可配置的图形着色。尤其 GLKBaseEffect 类实现了 OpenGL ES 1.1 规范上的光亮和材质模式，简化了移植一个应用从 OpenGL ES 1.1 到 OpenGL ES 最后版本的努力。</td></tr><tr><td style="text-align:left">Image I/O</td><td style="text-align:left">ImageIO.framework 提供输入和输出图像数据和图像元数据的接口。<br><br>该框架利用 CoreGraphics 数据类型和功能，并支持在 iOS 上所有的可获得的标准的图像类型。你能使用这个框架存取 Exif 和 IPTC 元数据属性。</td></tr><tr><td style="text-align:left">Media Accessibility</td><td style="text-align:left">MediaAccessibility.framework 管理媒体文件中 closed-caption 内容的呈现。<br><br>该框架与新的设置配合工作可以让用户决定是否允许 closed-caption 显示。</td></tr><tr><td style="text-align:left">Media Player</td><td style="text-align:left">MediaPlayer.framework 提供应用中播放声音和视频的高级别支持。<br><br>能够使用该框架做如下工作：<br>1. 播放视频到用户屏幕或通过 AirPlay 到另外的设备屏幕。能够全屏幕播放视频或以可改变视图大小的方式播放。<br>2. 存取用户的 iTunes 音乐库。能够播放音乐轨迹和播放列表、搜索音乐、给用户提供一个媒体 picker 呈现接口。<br>3. 配置和管理电影的回放。<br>4. 在锁定屏幕和 app 切换窗口上显示 NowPlaying 信息。当内容通过 AirPlay 提交时还能显示到 AppleTV 上。<br>5. 检测视频通过 AirPlay 被串流的时间。</td></tr><tr><td style="text-align:left">OpenAL</td><td style="text-align:left">OpenAudio Library（OpenAL）接口是用来在应用中提供位置音效的跨平台的标准。<br><br>能够使用该接口在游戏和其它需要位置音效输出的程序中实现高性能、高质量的声音。<br><br>因为 OpenAL 是跨平台的标准，在 iOS 使用 OpenAL 编写的代码能够容易地移植到许多其它平台。</td></tr><tr><td style="text-align:left">OpenGL ES</td><td style="text-align:left">OpenGLES.framework 提供绘制 2D 和 3D 内容的工具，它是一个 C-based 的框架。<br><br>该框架以最接近设备硬件的方式为全屏沉浸式应用例如游戏提供细粒度的图形控制和高的帧率。<br><br>你能够与 EAGL 配合使用这个框架，为 OpenGL ES 绘制调用和 UIKit 的本地窗口对象之间提供接口。<br><br>该框架支持 OpenGLES 1.1，2.0，3.0 规范。2.0 规范增加了片段和顶点着色的支持，3.0 规范增加了更多的功能，包括多个呈现目标和变换反馈。</td></tr><tr><td style="text-align:left">Quartz Core</td><td style="text-align:left">QuartzCore.framework 包含 Core Animation 接口。<br><br>Core Animation 是一个先进的复合技术，使用它能容易创建快和有效的 view-based 的动画。<br><br>复合引擎利用底层硬件来有效的实时操作视图内容。<br><br>只需规定动画的起始点，CoreAnimation 做剩下的工作。因为 Core Animation 内嵌在UIView架构的底层，因此它总是可用的。</td></tr><tr><td style="text-align:left">Sprite Kit</td><td style="text-align:left">SpriteKit.framework 框架为 2D 和 2.5D 游戏提供硬件加速的动画系统。<br><br>SpriteKit 提供大多数游戏需要的基础，包括一个图形引擎和动画系统，声音播放支持，一个物理仿真引擎。<br><br>使用 SpriteKit 不需你自己创建这些事情，使你聚焦在内容设计和内容的高级别的交互上。<br><br>在 Sprite Kit 应用中内容组织为场景。一个场景包括纹理对象，视频，路径图形，核心图像过滤器和其它的特效。<br><br>SpriteKit 利用这些对象，确定这些对象到屏幕上的最有效的方式。<br><br>当在场景中到了动画内容的时刻，你能使用 SpriteKit 来显式规定你想执行的行动或使用物理仿真引擎来为那些对象定义物理行为（例如重力、引力或排拆力）。<br><br>除了 SpriteKit 框架，也有其它 Xcode 工具来创建颗粒发射效果和纹理图。你能使用 Xcode 工具来管理应用资源和快速地更新 Sprite Kit 场景。</td></tr></tbody></table><h2 id="四、CoreServices-Layer"><a href="#四、CoreServices-Layer" class="headerlink" title="四、CoreServices Layer"></a>四、CoreServices Layer</h2><center><br><img src="http://dzliving.com/iOSStructure_4.png" alt><br></center><p>CoreServices Layer 包含应用需要的基础的系统服务。这些服务中的核心是 CoreFoundation 和 Foundation 框架，定义了所有应用使用的基本类型。</p><p>该层也包含独立的技术来支持一些其它功能，例如位置、iCloud、社交媒体和网络。</p><h4 id="4-1-包含的高级功能"><a href="#4-1-包含的高级功能" class="headerlink" title="4.1 包含的高级功能"></a>4.1 包含的高级功能</h4><ol><li><p>Peer-to-Peer Services</p><p> 点到点服务。</p><p> Multipeer Connectivity 框架提供通过蓝牙进行 p2p 连接的能力。</p><p> 你能使用 p2p 连接来启动与附近设备的通讯会话。虽然 p2p 连接主要用在游戏中，你也能在其它类型的应用中使用这个功能。</p></li><li><p>iCloud Storage</p><p> 云存储。</p><p>iCloud 存储让应用把用户文档和数据写到一个中心位置，用户然后能从他们的计算机和 iOS 设备存取这些数据。</p><p>使用 iCloud 可以使用户文档无所不在，意味着用户能从任何设备阅读或编辑那些文档，而不需要显式的同步或文件传输。存储文档到用户的 iCloud 账户也为用户提供了一层安全。即使用户的设备丢失，那些设备上的文档如果已经保存到 iCloud 就不会丢失。</p><p>应用能以两种方式使用 iCloud 存储，每一种有不同的使用意图：</p><ul><li><p>iCloud 文档存储。</p><p>   可以使用这个功能在用户的 iCloud 账户存储用户文档和数据。</p><ul><li><p>iCloud 键值存储。</p><p> 使用这个功能在应用之间共享数据。</p></li></ul><p>大多数应用使用 iCloud 文档存储来共享来自用户账户的文档。使用 iCloud 文档存储用户关心的是文档能否能够在设备之间共享以及他们是否能够从一个给定设备查看和管理那些文档。</p><p>相对的，iCloud 键值存储是应用与应用的其它实例共享小量数据（几十k字节）的方式，应用应当用它存储非紧急的应用数据，例如设置。</p></li></ul></li><li><p>Automatic Reference Counting</p><p> 自动引用计数。</p><p> AutomaticReference Counting（ARC)是一个编译级别的功能，用它来简化 Objective-C 对象生命周期过程的管理，以此代替用户必须记住什么时候应该保持和释放对象。</p><p> ARC 评估对象的生命周期需求和自动在编译时间插入适当的方法调用。</p><p> ARC 用来代替 ios 的早期版本中存在的传统的管理内存的编程模式。</p><p> 新创建的工程自动使用 ARC。Xcode 也提供了移植工具帮助你转换遗留的工程来使用 ARC.</p></li><li><p>Block Objects</p><p> 块对象。</p><p> BlockObjects 是一个能够与你的 C 或 Objective-C 代码集成的 C 语言的构造块。一个blockobject 本质上是一个异步功能和相关的数据。</p><p> 在其它语言中有时也被称做 closure 或 lambda。</p><p> Blocks 尤其用作回调或放在你需要一种容易的组合执行代码和相关数据方式的地方。</p><p> 在 iOS，通常在下面的场景使用 Blocks：</p><ul><li>作为代理或代理方法的代替；</li><li>作为回调功能的代替；</li><li>为某个一次性操作实现其完成处理函数；</li><li>在一个集合中的所有项上执行一个任务；</li><li>与提交队列一起执行异步任务。</li></ul></li><li><p>Data Protection</p><p> 数据保护。</p><p> DataProtection 允许应用利用设备上已有的内建的加密方法来使用用户的敏感数据。</p><ul><li>当应用指定一个特定的文件被保护时，系统在磁盘上以加密格式存储该文件。</li><li>当设备锁定时，该文件的内容不能被应用和任何潜在的侵入者存取。</li><li>可是当设备由用户解锁时，一个解密key被创建允许你的应用存取那个文件。</li><li><p>用户也可以使用其它级别的数据保护机制。</p><p>实现数据保护需要你考虑如何创建和管理你想保护的数据。应用必须设计在数据的创建时间加密数据，以及当用户锁定或解锁设备时为存取条件改变做好准备。</p></li></ul></li></ol><ol start="6"><li><p>File-Sharing Support</p><p> 文件共享支持。</p><p> File-SharingSupport 使用户数据文件在 iTunes 9.1 和以后上可被其它应用获得。</p><p> 一个应用声明支持文件共享使它的 <code>/Documents</code> 目录下的内容对其它用户可获得。用户然后当需要时能够把文件从 iTunes 移进或移出应用的 Documents 目录。</p><p> 这个特征不允许应用与相同设备上的其它应用共享应用，这需要粘贴板或一个文档交互控制器对象。</p><p> 应用为了允许文件共享支持，需要做如下工作：</p><ol><li>在应用的 Info.plist 文件中增加 UIFileSharingEnabled 键，并设置其值为 YES。</li><li>在你的应用的 Documents 中放你想共享的文件；</li><li>当设备插进用户的计算机时，iTunes 在选中设备的 Apps 标签下显式一个文件共享节；</li><li><p>用户然后能够增加文件到设备的文档目录或移动文件到桌面。</p><p>支持文件共享的应用应该能够识别文件什么时候增加到其Documents目录和做出适当的应答。例如应用可以使任意新文件的内容可以从它的接口获得。也应该从不把 Documents 目录的文件列表呈现给用户来请求用户决定对那些文件做什么。</p></li></ol></li><li><p>Grand Central Dispatch</p><p> GrandCentral Dispatch（GCD)是一个 BSD 技术，应用可以用来管理其任务的执行。</p><p> GCD 与高优化的核组合成一个异步编程模式，来提供方便和更有效的对线程的替代。GCD 也为许多低级别的任务提供一个方便的选择，例如读和写文件描述符，实现定时器和监视信号和处理事件。</p></li></ol><ol start="8"><li><p>In-App Purchase</p><p> 应用内购买。</p><p> In-App Purchase 提供在应用中销售应用特定的内容和服务以及来自 iTunes 的内容的能力。</p><p> 这个功能使用 StoreKit 框架实现，并提供使用用户的 iTunes 账号来处理金融方面的事务需要的基础。</p><p> 应用处理全部用户体验和供购买的内容及可获得服务的呈现。作为可下载的内容，你能把可下载的内容放到你自己的服务器或使用苹果的服务器。</p></li></ol><ol start="9"><li><p>SQLite</p><p> SQLite 库让你在你的应用中嵌入一个轻量级的 sql 数据库，而不需要运行一个分离的远程数据库服务进程。</p><p> 从你的应用，你能创建本地数据库文件，管理数据库表和表中的数据记录。</p><p> SQLite 库为通用功能使用设计，但已经被优化来提供对数据记录更快速的存取。</p></li></ol><ol start="10"><li><p>XML Support</p><p>Foundation 框架提供一个 NSXMLParser 类用来从一个 xml 文档中引出元素。</p><p>操作 xml 内容的额外的支持由 libxml2 库提供支持。libxml2 开源库让你快速地分析或写任意的 xml 数据和转换 xml 内容到 html.</p></li></ol><table><thead><tr><th style="text-align:left">框架</th><th style="text-align:left">服务内容</th></tr></thead><tbody><tr><td style="text-align:left">Accounts Framework</td><td style="text-align:left">Accounts.framework 为确定的用户账号提供单点登录模式。<br><br>单点登录通过消除用户分离的多个账号需要的多次登录提示，来增强用户体验。它也通过为应用管理账号认证过程来简化开发模式。<br><br>该框架需要与 Social 框架配合使用。</td></tr><tr><td style="text-align:left">Address Book Framework</td><td style="text-align:left">AddressBook.framework 提供可编程存取用户的联系人数据库的方式。<br><br>如果应用使用联系人信息，你能使用该框架来存取和修改联系人信息。例如一个聊天应用可以使用该框架来引出可能的联系人列表，通过联系人列表来启动一个会话以及在特定视图显示那些联系人。<br><br>重要提示：存取用户的联系人数据需要用户的明确的许可。应用因此必须准备好用户拒绝存取的情形。应用也鼓励提供Info.plist键来描述需要存取的原因。</td></tr><tr><td style="text-align:left">Ad Support Framework</td><td style="text-align:left">AdSupport.framework 提供存取应用用于广告功能的一个标识。<br><br>该框架也提供一个指示用户是否选择广告跟踪的标志。应用在试图存取广告标识前需要度和判断这个标志。</td></tr><tr><td style="text-align:left">CFNetwork</td><td style="text-align:left">CFNetwork.framework 是高性能的使用面向对象对网络协议进行抽象的一组 C-based 接口。这些抽象提供对协议栈细节的控制，使它容易使用低级别的构造例如 BSDsockets。<br><br>你能使用该框架简化与 ftp 或 http 服务器通讯或决定 dnshosts 的任务。<br><br>使用 CFNetwork 框架，你能：<br>1. 使用 BSD sockets。<br>2. 使用 SSL 或 TLS 创建安全连接。<br>3. 决定dnshosts。<br>4. 与 HTTP 服务器、认证 HTTP 服务器、HTTPS 服务器交互。<br>5. 与 FTP 服务器交互。<br>6. 发布、解决和浏览 Bonjour 服务。<br><br>CFNetwork 物理和理论上基于 BSD sockets。</td></tr><tr><td style="text-align:left">Core Data</td><td style="text-align:left">CoreData.framework 框架是管理 MVC 应用中的数据模式的一种技术。<br><br>CoreData 框架打算在数据模式是高结构化的应用中使用。<br><br>代替编程定义<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>，在 Xcode 中能够使用图形工具来建立一个表现你的数据模式的纲要。在运行时，你的数据模式实体的实例通过 CoreData 框架被创建、管理和获得。<br><br>通过为你的应用管理其数据模式，CoreData 大大减少了必须书写的代码量。<br><br>CoreData 也提供如下功能：<br>1. 为优化性能在 SQLite 数据库中存储对象数据；<br>2. 一个管理数据表视图结果的 NSFetchedResultsController 类；<br>3. 对基本的文本编辑之外的 undo/redo 的管理；<br>4. 支持属性值的校验；<br>5. 支持传播改变确保对象之间的关系保持一致性；<br>6. 支持分组、过滤和在内存中优化数据。<br><br>如果你开始开发一个新应用或计划对已有应用进行大的更新，应该考虑使用 CoreData。</td></tr><tr><td style="text-align:left">Core Foundation</td><td style="text-align:left">CoreFoundation.framework 是一组 C-based 接口，为 iOS 应用提供基本的数据管理和服务功能。<br><br>该框架包括如下支持：<br>1. 集合数据类型（数组、集合等等）；<br>2. 应用打包 Bundles；<br>3. 字符串管理；<br>4. 日期和时间管理<br>5. 原始数据块管理<br>6. Preferences管理；<br>7. URL 和流操作；<br>8. 线程<br>9. 端口和 socket 通讯。<br><br>CoreFoundation 框架与 Foundation 框架紧密相关，为相同的基本功能提供 Objective-C 接口。<br><br>当你需要混合使用 Foundation 对象和 Core Foundation 类型时，你能利用两个框架之间存在的“toll-freebridging”。<br><br>toll-free bridging”意味着你能可交换地在两个框架的方法和功能中使用一些 CoreFoundation 和 Foundation 类型。这个支持对许多数据类型可用，包括集合和字符串数据类型。<br><br>每个框架的类和类型描述声明一个对象是否是 toll-freebridged以及在是的情况下来标识它连接到什么对象。</td></tr><tr><td style="text-align:left">Core Location</td><td style="text-align:left">CoreLocation.framework 为应用提供位置信息。该框架使用板上的 GPS、蜂窝、或者Wi-Fi来定位用户的当前经度和纬度。<br><br>你可在你的应用中集成该技术为用户提供位置信息。例如，你可实现一个基于用户的当前位置搜索附近餐馆、商店或者银行的应用。<br><br>CoreLocation 框架也提供如下能力：<br>1. 在包括磁力计的 iOS 设备上存取罗盘信息；<br>2. 基于地理位置或蓝牙 beacon 进行区域监视；<br>3. 支持使用蜂窝基站的低耗电的位置监视；<br>4. 与 MapKit 配合来增强在特定情景下的位置数据的质量，例如开车时。</td></tr><tr><td style="text-align:left">Core Media Framework</td><td style="text-align:left">CoreMedia.framework 提供由 AV Foundation 框架使用的低级别的媒体类型。<br><br>大多数应用从不需要使用该框架，但少数需要更精确控制音视频内容创建和呈现的开发者可以使用它。</td></tr><tr><td style="text-align:left">Core Motion Framework</td><td style="text-align:left">CoreMotion.framework 提供一组接口来存取设备上可获得的运动数据。<br><br>该框架支持使用一组新的 block-based 接口来存取原始和加工过的加速度计数据。对于带有陀螺仪的设备，你也能获得原始的陀螺仪数据和加工过的反应设备方向和旋转速度的数据。<br><br>你能在游戏或其它使用运动作为输入或作为增强用户体验的方式的应用中使用加速度计和陀螺仪两种数据。对于带有计步硬件的设备，你能存取它的数据来跟踪健康相关的运动。</td></tr><tr><td style="text-align:left">Core Telephony Framework</td><td style="text-align:left">CoreTelephony.framework 提供与蜂窝电话的通话相关的信息交互的接口。<br><br>可以使用该框架来获得用户的蜂窝服务提供者的信息。对于对蜂窝 call 事件感兴趣的应用例如 VoIP 应用也能在那些事件出现时被通知。</td></tr><tr><td style="text-align:left">Event Kit</td><td style="text-align:left">EventKit.framework 提供存取用户设备上的月历事件的接口。<br><br>能够使用该框架来做如下事情：<br>1. 获得用户月历上存在的事件和提示；<br>2. 增加事件到用户月历；<br>3. 为用户创建提示和使它们出现在提示应用中；<br>4. 为月历事件配置提示信号，包括设置提示信号应该什么时候触发的规则。<br><br>重要提示：存取用户的月历和提示数据需要用户的明确许可。应用因此必须准备好用户拒绝的情形，也鼓励应用在其 Info.plist 文件中提供一个描述需要存取原因的键。</td></tr><tr><td style="text-align:left">Foundation</td><td style="text-align:left">Foundation.framework 提供 Core Foundation 框架提供的许多功能的 Objective-C 封装。<br><br>该框架提供如下功能的支持：<br>1. 集合数据类型（数组、集合等等）；<br>2. 应用打包 Bundles；<br>3. 字符串管理；<br>4. 日期和时间管理<br>5. 原始数据块管理<br>6. Preferences 管理；<br>7. URL 和流操作；<br>8. 线程和运行环；<br>9. Bonjour；<br>10. 通讯端口管理；<br>11. 国际化；<br>12. 规则表达式匹配；<br>13. Cache 支持。</td></tr><tr><td style="text-align:left">JavaScriptCore</td><td style="text-align:left">JavaScriptCore.framework 为许多标准的 JavaScript 对象提供 Objective-C 语言的封装。使用该框架来执行 JavaScript 代码和分析 JSON 数据。</td></tr><tr><td style="text-align:left">Mobile Core Services</td><td style="text-align:left">MobileCoreServices.framework 定义在通用类型标识符（UTIs）中使用的低级别类型。</td></tr><tr><td style="text-align:left">Multipeer Connectivity Framework</td><td style="text-align:left">MultipeerConnectivity.framework 支持附近设备的发现，并与那些设备直接通讯（不需要Internet连接）。<br><br>使用该框架能够与附近设备通讯、容易的创建多人会话、支持可靠地传输顺序和实时数据。<br><br>该框架为发现和管理网络服务提供可编程和 UI-based 的选项。应用能在 UI 中集成 MCBrowserViewController 类来显示一个发现设备列表让用户选择。<br><br>另外也能使用 MCNearbyServiceBrowser 类来可编程的查找和管理对方设备。</td></tr><tr><td style="text-align:left">Newsstand Kit</td><td style="text-align:left">Newsstand 应用为用户提供了一个阅读杂志和报纸的中心位置。想通过 Newsstand 提供杂志和报纸内容的出版商能够使用 NewsstandKit 框架（NewsstandKit.framework）创建它们自己的 iOS 应用，让用户启动新杂志和报纸新闻的后台下载。在启动下载后，系统处理下载操作和当内容可获得时通知应用。</td></tr><tr><td style="text-align:left">Pass Kit</td><td style="text-align:left">Passbook 应用为用户提供了一个存储订货单、登机卡、入场券和商业折扣卡的位置。代替物理携带这些东西，用户现在能在 iOS 设备上存储它们，并和过去一样的方式使用。<br><br>Pass Kit 框架 (PassKit.framework)提供把这些功能集成到你的应用的 Objective-C 接口。<br><br>你能与web 接口和文件格式信息组合使用该框架来创建和管理你们公司提供的电子入场券。<br><br>电子入场券由你们公司的  web service创建并通过 email、Safari 或定制的应用提交到用户的设备。<br><br>电子入场券本身使用特殊的文件格式，在提交之前被加密签名。文件格式标识关于提供服务的相关信息以及用户知道是什么服务的信息。<br><br>电子入场券也可以包含一个对卡进行校验的条码或其它信息，以便它能被兑换或使用。</td></tr><tr><td style="text-align:left">Quick Look</td><td style="text-align:left">QuickLook.framework 提供了一个预览应用不直接支持的文件内容的接口。<br><br>该框架主要打算用于应用从网络下载文件或处理来自不知道来源的文件的工作。<br><br>在得到文件后，你能使用该框架提供的视图控制器来直接显示文件的内容。</td></tr><tr><td style="text-align:left">Safari Services</td><td style="text-align:left">SafariServices.framework 提供以可编程的方式增加 URLs 到用户的 Safari 的书签的支持。</td></tr><tr><td style="text-align:left">Social Framework</td><td style="text-align:left">Social.framework 提供一个简单的接口来存取用户的社交媒体账号。<br><br>该框架取代 Twitter 框架并增加了其它社交账号，包括 Facebook、Sina 微博以及其它。<br><br>应用能使用该框架提交状态更新和图像到用户账号。该框架与 Accounts 框架一起为用户提供单点登录并确保存取的用户账号是经过准许的。</td></tr><tr><td style="text-align:left">Store Kit</td><td style="text-align:left">StoreKit.framework 提供在 iOS 应用中购买内容和服务的支持，也被称作应用内购买。<br><br>例如，你能使用该功能来允许用户去锁另外的应用功能。或者如果你是一名游戏开发者，你能使用它来提供另外的游戏级别。<br><br>在这两种情况，StoreKit 框架处理事务的收入方面事务，包括通过用户的 iTunes 账号处理付费请求，给应用提供关于购买的信息。<br><br>Store Kit聚集在事务的金融方面，确保事务正确和安全。你的应用处理事务的其它方面，包括购买接口的呈现和适当内容的下载（去锁）。<br><br>工作的分工让你能够控制购买内容的用户体验。由你决定你想呈现给用户什么样的购买接口和什么时候那样做，你也决定你的应用最好的提交机制。</td></tr><tr><td style="text-align:left">System Configuration Framework</td><td style="text-align:left">SystemConfiguration.framework 提供可达性接口，你能用它来确定设备的网络配置，也能使用该框架确定一个 Wi-Fi 或蜂窝连接是否在用以及一个特定的主机服务器是否能够存取。</td></tr></tbody></table><h2 id="五、Core-OS-Layer"><a href="#五、Core-OS-Layer" class="headerlink" title="五、Core OS Layer"></a>五、Core OS Layer</h2><center><br><img src="http://dzliving.com/iOSStructure_5.png" alt><br></center><p>Core OS 是用 FreeBSD 和 Mach 所改写的 Darwin，是开源、符合 POSIX 标准的一个 Unix 核心。</p><p>CoreOS 层包含其它大多数技术建在其之上的低级别的功能。虽然应用不直接使用这些技术，它们被其它框架使用。在需要显而易见的处理安全或与外设通讯的情形，你也能使用该层提供的框架。</p><ol><li><p>Accelerate 加速框架</p><p> Accelerate框架 (Accelerate.framework)包含执行数字信号处理、线性代数、图像处理计算的接口。<br>使用该框架的优点是它们针对所有的ios设备上存在的硬件配置做了优化，因此你能写一次代码确保在所有设备上有效运行。</p></li></ol><ol start="2"><li><p>Core Bluetooth Framework（核心蓝牙框架）</p><p> CoreBluetooth 框架 (CoreBluetooth.framework)允许开发者与蓝牙低耗电外设（LE）交互。</p><p> 使用该框架的Objective-C接口能够完成如下工作：</p><ul><li>扫描蓝牙外设，连接和断开发现的蓝牙外设；</li><li>声明应用的服务，转换 iOS 设备成其它蓝牙设备的外设；</li><li>从 iOS 设备广播 iBeacon 信息；</li><li>保存你的蓝牙连接的状态，当应用重新启动时恢复那些连接；</li><li>蓝牙外设可获得性变化时获得通知。</li></ul></li></ol><ol start="3"><li><p>External Accessory Framework（外部附件框架）</p><p>  ExternalAccessory 框架(ExternalAccessory.framework)提供与连接到IOS设备的硬件附件通讯的支持。</p><p>  附件能通过 30-pin 连接器或使用蓝牙无线与 iOS 设备进行连接。该框架给你提供了获得关于每一个可获得的附件信息和启动通讯会话的方式。然后，你可自由的使用附件支持的命令直接操作附件。</p></li><li><p>Generic Security Services Framework（通用安全服务框架）</p><p> GenericSecurity Services 框架 (GSS.framework)给ios应用提供一组标准安全相关的服务。该框架的基本接口规定在IETF<a href="http://www.ietf.org/rfc/rfc2743.txt" target="_blank" rel="noopener">RFC2743</a> and<a href="http://tools.ietf.org/html/rfc4401" target="_blank" rel="noopener">RFC4401</a>。除了提供标准的接口，IOS还包括一些没有在标准中规定但被许多应用需要的一些管理证书需要的额外东西。</p></li></ol><ol start="5"><li><p>Security Framework（安全框架）</p><p> 除了内建的安全功能，IOS也提供了一个明确的安全框架（Security.framework)，你能用它来保证应用管理的数据的安全。<br> 该框架提供管理证书、公有和私有key和信任策略的接口。支持产生加密安全伪随机码。它也支持在keychain（保存敏感用户数据的安全仓库）中保存证书和加密 key。</p><p> 公共加密库提供对称加密、hash认证编码（HMACs）、数字签名等额外支持，数字签名功能本质上与iOS上没有的OpenSSL库兼容。</p><p> 在你创建的多个应用之间共享keychain是可能的。共享使它容易在相同的一套应用之间更平滑的协作。例如，你能使用该功能来共享用户口令或其它元素，否则可能使每个应用都需要提示用户。</p><p> 为了在应用之间共享数据，必须为每个应用的 Xcode 工程配置适当的权限。</p></li></ol><ol start="6"><li><p>System</p><p> System 级包含 kernel 环境、驱动以及操作系统级别的 unix 接口。kernel 本身负责操作系统的每一个方面：如虚拟内存管理、线程、文件系统、网络和互联通信。</p><p> 在该层的驱动也提供在可获得的硬件与系统框架之间的接口。为了安全，对 kernel 和驱动的存取被限制到一组有限的系统框架和应用。</p><p> iOS 提供一组存取许多操作系统低级别功能的接口。应用通过 LibSystem 库存取这些功能。</p><p> 该 C-based 的接口提供如下功能的支持：</p><ul><li>多任务（POSIX 线程和 GCD)</li><li>网络（BSDsockets）</li><li>文件系统存取</li><li>标准 I/O</li><li>Bonjour 和 DNS 服务</li><li>位置信息</li><li>内存分配</li><li>数学计算</li></ul></li><li><p>64-Bit Support</p><p> iOS原先是为32-bit架构的设备设计的。自iOS 7，开始支持在64-bit进行编译、链接和调试。所有的系统库和框架是支持64位的，意味着它们能在32-bit和64-bit应用中使用。</p><p> 当以 64-bit 运行时编译时，应用可能运行的更快，因为在64-bit模式可以获得额外的处理器资源。</p><p> iOS使用OS X和其它64-bitUNIX系统使用的LP64模式，意味着在这些系统移植时不会碰到太头疼的事。</p></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.jianshu.com/u/885f40edd67a" target="_blank" rel="noopener">不会游泳De鱼</a> - <a href="https://www.jianshu.com/p/23f2c46c4b89" target="_blank" rel="noopener">iOS操作系统的层次结构</a><br><a href="https://www.jianshu.com/p/b96e35864f5d" target="_blank" rel="noopener">Mac OS 和 iOS 操作系统架构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、iOS-系统架构层次&quot;&gt;&lt;a href=&quot;#一、iOS-系统架构层次&quot; class=&quot;headerlink&quot; title=&quot;一、iOS 系统架构层次&quot;&gt;&lt;/a&gt;一、iOS 系统架构层次&lt;/h2&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://dzli
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS网络层设计</title>
    <link href="http://yoursite.com/2019/11/04/iOS/iOS%E6%9E%B6%E6%9E%84/iOS%20%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/11/04/iOS/iOS架构/iOS 网络层设计/</id>
    <published>2019-11-04T07:25:26.589Z</published>
    <updated>2019-11-04T07:54:50.259Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/fe0dd50d0af1?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">谈谈 iOS 网络层设计</a><br><a href="https://www.jianshu.com/p/c033e02e5117" target="_blank" rel="noopener">集约型API调用方式和离散型API调用方式的选择？</a><br>[casa大神的网络设计方案的评论之集约型API和离散型API的理解？]（<a href="https://www.jianshu.com/p/9a96d5c795f8）" target="_blank" rel="noopener">https://www.jianshu.com/p/9a96d5c795f8）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fe0dd50d0af1?utm_campaign=maleskine&amp;amp;utm_content=note&amp;amp;utm_medium=seo_notes&amp;amp;utm_source=recom
      
    
    </summary>
    
      <category term="iOS架构" scheme="http://yoursite.com/categories/iOS%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 类簇</title>
    <link href="http://yoursite.com/2019/11/04/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20%E7%B1%BB%E7%B0%87/"/>
    <id>http://yoursite.com/2019/11/04/iOS/iOS原理/iOS 类簇/</id>
    <published>2019-11-04T06:41:42.788Z</published>
    <updated>2019-11-04T06:42:04.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、类簇"><a href="#一、类簇" class="headerlink" title="一、类簇"></a>一、类簇</h2><p>类簇是 Foundation 框架广泛使用的设计模式。<font color="#cc0000">类簇在公共抽象超类下对多个私有的具体子类进行分组</font>。以这种方式对类进行分组<font color="#cc0000">简化了面向对象框架的公共可见体系结构</font>，而不会降低其功能丰富度。类簇是基于抽象工厂设计模式的。</p><h2 id="二、抽象工厂"><a href="#二、抽象工厂" class="headerlink" title="二、抽象工厂"></a>二、抽象工厂</h2><p>抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。很多人会混淆抽象工厂模式和工厂模式。实际上，两种的差别还是比较明显的，如下表。</p><center><br><br>|抽象工厂模式|工厂模式|<br>|:—-:|:——:|<br>|通过对象组合创建抽象产品|通过类继承创建抽象产品|<br>|创建多系列产品|创建一种产品|<br>|必须修改父类的接口才能支持新的产品|子类化创建者并重载工厂方法以创建新产品|<br><br></center><p>点击<a href="https://gist.github.com/Catfish-Man/bc4a9987d4d7219043afdf8ee536beb2" target="_blank" rel="noopener">查看子类的名称</a>。</p><h2 id="三、NSArray"><a href="#三、NSArray" class="headerlink" title="三、NSArray"></a>三、NSArray</h2><p>《Effective Objective-C 2.0》中有一段话：</p><blockquote><p>In the case of NSArray, when an instance is allocated, it’s an instance of another class that’s allocated (during a call to alloc), known as a placeholder array. This placeholder array is then converted to an instance of another class, which is a concrete subclass of NSArray.</p><p>在使用了 NSArray 的 alloc 方法来获取实例时，该方法首先会分类一个属于某类的实例，此实例充当“占位数组”。该数组稍后会转为另一个类的实例，而那个类则是 NSArray 的实体子类。</p></blockquote><p>不管创建的是可变还是不可变的数组，在 alloc 之后得到的类都是 <code>__NSPlaceholderArray</code>。而当我们 init 一个不可变的空数组之后，得到的是 <code>__NSArray0</code>；如果有且只有一个元素，那就是 <code>__NSSingleObjectArrayI</code>；有多个元素的，叫做 <code>__NSArrayI</code>；init 出来一个可变数组的话，都是 <code>__NSArrayM</code>。</p><p>注意：当使用 + array.. 方法创建数组对象时，只有一个元素也是 <code>__NSArrayI</code>。</p><p>这里 __NSSingleObjectArrayI，需要说明它的用意。</p><h2 id="四、-NSSingleObjectArrayI"><a href="#四、-NSSingleObjectArrayI" class="headerlink" title="四、__NSSingleObjectArrayI"></a>四、__NSSingleObjectArrayI</h2><p>作为对比，__NSArrayI 必须要实现</p><ul><li><ul><li>count</li></ul></li><li><ul><li>objectAtIndex:</li></ul></li></ul><p>两个方法，但是我们可以非常显而易见的看出来，当数组只有一个数字的时候，是完全不需要这两个方法的。<br>再深入一点的说明一下，__NSSingleObjectArrayI 是不需要去记录字符串长度的。它会比 __NSArrayI <font color="#cc0000">少 8 个字节的长度</font>。苹果可能是为了优化性能考虑，从而在 iOS8 之后推出这个新的子类。</p><p>另外需要说明的是，实际上，__NSArrayM 本身只有 7 个方法，分别是：</p><ul><li><ul><li>count</li></ul></li><li><ul><li>objectAtIndex:</li></ul></li><li><ul><li>insertObject:atIndex:</li></ul></li><li><ul><li>removeObjectAtIndex:</li></ul></li><li><ul><li>addObject:</li></ul></li><li><ul><li>removeLastObject</li></ul></li><li><ul><li>replaceObjectAtIndex:withObject:</li></ul></li></ul><p>所有其它高等级的抽象建立在它们的基础之上。例如 <code>- removeAllObjects</code> 方法简单地往回迭代，一个个地调用 <code>- removeObjectAtIndex:</code>。</p><h2 id="五、NSDictionary"><a href="#五、NSDictionary" class="headerlink" title="五、NSDictionary"></a>五、NSDictionary</h2><p>NSDictionary 与 NSArray 类似，不管创建的是可变还是不可变的字典，在 alloc 之后得到的类都是 <code>__NSPlaceholderDictionary</code>。而 init 一个不可变的空数组之后，得到的是 <code>__NSDictionary0</code>；如果有且只有一个元素，那就是 <code>__NSSingleEntryDictionaryI</code>；有多个元素的，叫做 <code>__NSDictionaryI</code>；init 出来一个可变数组的话，都是 <code>__NSDictionaryM</code>。还有一个子类，<code>__NSFrozenDictionaryM</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> * dict = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:<span class="string">@"Tom"</span>, <span class="string">@"name"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> * copyDict = dict.copy;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"copyDict       : %@   %p   %@"</span>, copyDict, copyDict, [copyDict <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">copyMDict       : &#123;</span><br><span class="line">    name = Tom;</span><br><span class="line">&#125;   <span class="number">0x60000363cb60</span>   __NSFrozenDictionaryM</span><br></pre></td></tr></table></figure><p>这个子类没什么特殊的作用，它仍然会被视为不可变字典。也就是说，对它进行改变的操作，会导致程序崩溃。崩溃信息如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[__NSFrozenDictionaryM setObject:forKey:]: unrecognized selector sent to<span class="built_in"> instance </span>0x600000490860</span><br><span class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSFrozenDictionaryM setObject:forKey:]: unrecognized selector sent to<span class="built_in"> instance </span>0x600000490860'</span><br></pre></td></tr></table></figure><p>其实在在 NSArray 中也有个对应的 <code>__NSFrozenArrayM</code>。</p><h2 id="六、NSSet"><a href="#六、NSSet" class="headerlink" title="六、NSSet"></a>六、NSSet</h2><p>NSSet 的子类不过是 NSDictionary 换了个名字而已，不做细讲。</p><p>这里说明一下，<code>__NSSingleObjectSetI</code> 不需要打扰实际的哈希表，因为只有一个对象需要担心。类似的方法 containsObject: 不需要遍历任何东西或查找任何东西，它可以简单地将参数与 set/array/dictionary 表示的单个对象进行比较。</p><h2 id="七、NSString"><a href="#七、NSString" class="headerlink" title="七、NSString"></a>七、NSString</h2><p>当测试创建 NSString 对象的时候，通过创建 NSString 不同的对象，并利用 object_getClassName 方法打印对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str1 = <span class="string">@"1234567890"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str1: %@"</span>, [str1 <span class="keyword">class</span>]);  <span class="comment">// str1: __NSCFConstantString</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> * str2 = <span class="string">@"123456789"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str2: %@"</span>, [str2 <span class="keyword">class</span>]);  <span class="comment">//str2: __NSCFConstantString</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> * str3 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"123456789"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str3: %@"</span>, [str3 <span class="keyword">class</span>]);  <span class="comment">// str3: NSTaggedPointerString</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> * str4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"1234567890"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"str4: %@"</span>, [str4 <span class="keyword">class</span>]);  <span class="comment">// str4: __NSCFString</span></span><br></pre></td></tr></table></figure><p>这里出现了三个子类：</p><ul><li>__NSCFConstantString</li><li>__NSCFString</li><li>NSTaggedPointerString</li></ul><ol><li><p>__NSCFConstantString</p><p> 它是一个字符串常量。它的引用计数非常大，是 4294967295。它的意思是：这个属性，怎么都不会被释放。相同的对象，内存地址是相同的，可以直接使用 == 方法（但是，这个对象的指针的地址依然不同，还是两个不同的对象）。它在编译时就决定的，不能在运行时创建。</p><p> 更详细的可以查看<a href="https://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="noopener">这篇博客</a>。</p></li><li><p>__NSCFString</p><p> 这个就是可变的 NSString 所属的子类。</p></li><li><p>NSTaggedPointerString</p><p> 要从 iPhone5s 开始说起，iPhone5s 开始采用了 64 位处理器。在 32 位时代，一个指针大小是 32 位（4字节），而在 64 位时代翻倍，一个指针的大小变成了 64 位（8字节）。这样子，在处理某些小一点，短一点的 NSString、NSNumber、NSDate 对象的时候，会显得过于浪费效率。这个时候，苹果推出了 Tagged Pointer 技术。</p><p> 苹果将一个对象的指针拆分成了两部分，一部分直接保存数据，另一部分作为特殊标记（tag），表示这个是一个特别的指针。这样呢，就会将节省很多的时间，因为它不再需要正常创建对象的申请和创建空间，处理引用计数，以及直接读取（在 objc_msgSend 当中，Tagged Pointer 会被识别出来，直接从指针中读取）。</p><p> 苹果之前说过：</p><blockquote><p>使用 Tagged Pointer 技术之后，在内存上读取的速度快了 3 倍，创建时的速度比以前快了 106 倍。</p></blockquote><p> 当然，这么做其实也是会有问题的，因为它并不是一个真正的对象，当你想要想其他普通的对象一样获取指针的时候，编译器直接就会报错（因为它也是在编译时创建的，而且压根没有 isa 指针）。</p><p> 编译器会告诉你正确的方法：改为使用 <code>object_getClass()</code>。</p></li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>类簇的优点：</p><ol><li>可以将抽象基类背后的复杂细节隐藏起来</li><li>程序员不会需要记住各种创建对象的具体类实现，简化了开发成本，提高了开发效率</li><li>便于进行封装和组件化</li><li>减少了 if-else 这样缺乏扩展性的代码</li><li>增加新功能支持不影响其他代码</li></ol><p>类簇的缺点：</p><ol><li>已有的类簇非常不好扩展</li></ol><p>我们了解类簇的好处：</p><ul><li>出现 bug 时，可以通过崩溃报告中的类簇关键字，快速定位 bug 位置。</li><li><p>在实现一些固定且并不需要经常修改的事物时，可以高效的选择类簇去实现。</p><p>  举个例子：针对不同版本，不同机型往往需要不同的设置，这时可以选择使用类簇；</p></li><li><p>app 的设置页面这种并不需要经常修改的页面，可以使用类簇去创建大量重复的布局代码。</p></li></ul><h2 id="九、文章"><a href="#九、文章" class="headerlink" title="九、文章"></a>九、文章</h2><p><a href="https://www.jianshu.com/u/471ab65a3123" target="_blank" rel="noopener">伯陽</a> - <a href="https://www.jianshu.com/p/68956f300fc2" target="_blank" rel="noopener">iOS中类簇的使用</a><br><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-31-tagged-pointer-strings.html" target="_blank" rel="noopener">Friday Q&amp;A 2015-07-31: Tagged Pointer Strings</a><br><a href="https://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/" target="_blank" rel="noopener">NSString特性分析学习</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、类簇&quot;&gt;&lt;a href=&quot;#一、类簇&quot; class=&quot;headerlink&quot; title=&quot;一、类簇&quot;&gt;&lt;/a&gt;一、类簇&lt;/h2&gt;&lt;p&gt;类簇是 Foundation 框架广泛使用的设计模式。&lt;font color=&quot;#cc0000&quot;&gt;类簇在公共抽象超类下对多个
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS OCR</title>
    <link href="http://yoursite.com/2019/11/04/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20OCR/"/>
    <id>http://yoursite.com/2019/11/04/iOS/iOS原理/iOS OCR/</id>
    <published>2019-11-04T05:31:51.742Z</published>
    <updated>2019-11-04T05:32:44.518Z</updated>
    
    <content type="html"><![CDATA[<p>身份证识别，又称 OCR 技术。OCR 技术是光学字符识别的缩写，是通过扫描等光学输入方式将各种票据、报刊、书籍、文稿及其它印刷品的<font color="#cc000">文字转化为图像信息，再利用文字识别技术将图像信息转化为可以使用的计算机输入技术</font>。</p><h2 id="实现原理及步骤"><a href="#实现原理及步骤" class="headerlink" title="实现原理及步骤"></a>实现原理及步骤</h2><ol><li><p>灰度化处理</p><p> 将指定图片每个像素点的 RGB 三个分量通过一定的算法计算出该像素点的灰度值，使图像只含亮度而不含色彩信息。</p></li><li><p>二值化</p><p> 将经过灰度化处理的图片转换为只包含黑色和白色两种颜色的图像，他们之间没有其他灰度的变化。在二值图中用 255 便是白色，0 表示黑色</p></li><li><p>腐蚀</p><p> 将得到的二值图中的黑色块进行放大。即连接图片中相邻黑色像素点的元素。通过腐蚀可以把身份证上的身份证号码连接在一起形成一个矩形区域。</p></li><li><p>轮廊检测</p><p> 图片经过腐蚀操作后相邻点会连接在一起形成一个大的区域，这个时候通过轮廊检测就可以把每个大的区域找出来，这样就可以定位到身份证上面号码的区域。</p></li><li><p>图像文字识别</p><p> 将图像信息转化为可以使用的计算机输入技术。</p></li></ol><h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><ol><li>OpenCV</li></ol><p>OpenCV 是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是它给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、身份证识别、去红眼、追踪移动物体等等的图像相关的功能</p><ol start="2"><li>TesseractOCRiOS</li></ol><p>Tesseract 是目前可用的最准确的开源 OCR 引擎，可以读取各种格式的图片并将他们转换成各种语言文本。而 TesseractOCRiOS 则是针对 iOS 平台封装的 Tesseract 引擎库。</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.jianshu.com/u/ec0c8a889343" target="_blank" rel="noopener">LYSNote</a> - <a href="https://www.jianshu.com/p/cc2efe73de10" target="_blank" rel="noopener">iOS OCR(身份证号码识别)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;身份证识别，又称 OCR 技术。OCR 技术是光学字符识别的缩写，是通过扫描等光学输入方式将各种票据、报刊、书籍、文稿及其它印刷品的&lt;font color=&quot;#cc000&quot;&gt;文字转化为图像信息，再利用文字识别技术将图像信息转化为可以使用的计算机输入技术&lt;/font&gt;。&lt;/p
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS IM</title>
    <link href="http://yoursite.com/2019/11/04/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20IM/"/>
    <id>http://yoursite.com/2019/11/04/iOS/iOS原理/iOS IM/</id>
    <published>2019-11-04T02:17:57.382Z</published>
    <updated>2019-11-04T02:17:57.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发送图片、语音等"><a href="#发送图片、语音等" class="headerlink" title="发送图片、语音等"></a>发送图片、语音等</h2><p><a href="http://www.52im.net/thread-175-1-1.html" target="_blank" rel="noopener">有人知道语音留言聊天等大文件或大数据量的主流实现方式吗？</a></p><blockquote><p>A：移动网络因为网络不稳定的客观因素存在，不适合实时发送较大的2进制文件（像电脑上的实时文件发送的那种），因为这涉及3方：客户端A、服务端、客户端B，任何两方的通讯因网络的不稳定而导致的重传等，都是个很不好处理的事情。</p><p>现在多数情况下都是通过http先上传到中转文件服务器，成功后再通知接收方，这种情况下，因上传的过程只限于客户端A和服务端，只涉及两方，网络的不稳定，也只影响了发送者（而不涉及接收者，因为对方还不知道你正在发送文件呢），所以无论是从可靠性、复杂性，还是用户体验的处理上，这种方式都要简单的多。而这么多年的移动应用也证明，这种云中转暂存的方式是比较适合于当前的移动网络和移动应用体验的。</p><p>Q：如果使用中转服务器，就有一个问题，， 就是收到音频信息后是直接显示那条音频消息，还是下载完再显示音频，如果直接显示音频，那用户点击的时候可能没有下载完成，点击没有声音。如果 下载完音频再显示消息的话，那么在下载过程中可能收到普通消息，普通消息不需要下载直接显示，这时候音频下载完成后显示在普通消息的后面的话顺序就乱了，显示在普通消息之前的话会有界面跳动的情况，用户体验不太好，这个问题怎么解决。</p><p>A：应该是发送方把语音文件上传到服务器成功后，同时发一条语音消息（只是一个包含了音频下载地址信息，可能是个文件名或url）发给接收方，接收方只在点击时才下载。</p><p>这就完全不存在你说的会乱序的问题。而且你仔细体验一下微信或其它主流im，都是这么玩的。你如果做过技术研究，就可以知道，微信最长 60 秒的语音留言大约 50KB 左右，你自已实现的话也差不多可以到90KB，而通常情况下没有人会说这么长的话，通常都是15秒左右，10 几 20kb 的文件大小，上传或下载都是非常轻松和快速的事情，所以，实际情况下的实用性，不需要怀疑。你可以去体验下 <a href="http://www.52im.net/forum-90-1.html" target="_blank" rel="noopener">RainbowChat</a>，即使是在很差的网络，比如在地铁行驶时使用，也同样体验很好。</p><p>A2：发送图片、录音、录像的思路是：先通过 http 上传图片，录音，录像到服务端，然后要求服务端返回图片录音录像的地址到客户端，然后客户端发送 json，发送图片地址录音录像的地址给 IM，IM 通过推送给另外的客户端，客户端收到以后，通过解析 json，然后通过 http 下载视频图片、语音，图片的话要进行缩放，录音的华，要有特定的图标标示，录像的话，下载以后截取第一帧的图片，不过建议这样，在展示图片的时候，缩放，在展示录像录音的时候，直接用图标替代展示的录像录音，然后通过用户点击图标通过http下载录音视频得到这种效果，此类功能需要一个ftp服务器，进行处理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;发送图片、语音等&quot;&gt;&lt;a href=&quot;#发送图片、语音等&quot; class=&quot;headerlink&quot; title=&quot;发送图片、语音等&quot;&gt;&lt;/a&gt;发送图片、语音等&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.52im.net/thread-175-1-1.ht
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 推送</title>
    <link href="http://yoursite.com/2019/10/30/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2019/10/30/iOS/iOS原理/iOS 推送/</id>
    <published>2019-10-30T12:57:54.251Z</published>
    <updated>2019-11-06T12:24:10.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、推送原理"><a href="#一、推送原理" class="headerlink" title="一、推送原理"></a>一、推送原理</h2><p>当用户打开应用程序的通知中心之后，苹果远程推送服务器就能把消息推送到装有该应用的设备上，具有强制性、实时性的特点，并且用户无需打开应用都能收到推送的消息。</p><h4 id="1-1-名词介绍"><a href="#1-1-名词介绍" class="headerlink" title="1.1 名词介绍"></a>1.1 名词介绍</h4><ul><li>Provider：消息提供者，一般是我们的后台服务器或者第三方推送服务器后台</li><li>APNs(Apple Push Notification service)：苹果推送通知服务。</li><li>APNs Server(Apple Push Notification service Server)：苹果推送通知服务的服务器。</li><li>notification：需要推送给 iOS 客户端(iPhone或者是iPad)上的消息</li><li>Client App：客户端 App,一般是安装在iPhone或者是iPad上的应用程序(App)</li><li>deviceToken：是由 APNs 根据设备和App来生成的唯一的一串数据。deviceToken 在以下三种情况下会发生改变：<ul><li>同一个设备上重新安装同一款应用</li><li>同一个应用安装在不同的设备上</li><li>设备重新安装了系统，同一个应用对应的 deviceToken 也会改变</li></ul></li></ul><h4 id="1-2-推送原理"><a href="#1-2-推送原理" class="headerlink" title="1.2 推送原理"></a>1.2 推送原理</h4><center><br><img src="http://dzliving.com/Notificaiton_3.jpg" alt><br><img src="http://dzliving.com/Notification_20.png" alt><br></center><p>从图中可以很清楚的看出来推送的原理主要分为以下几步：</p><center><br><img src="http://dzliving.com/Notification_1.png" alt><br></center><ol><li>由 App 向 iOS 设备发送一个注册通知，用户需要同意系统发送推送；</li><li>iOS 向 APNs 远程推送服务器发送 App 的 Bundle Id 和设备的 UDID；</li><li>APNs 根据设备的 UDID 和 App 的 Bundle Id 生成 deviceToken 再发回给 App；</li><li><p>App 再将 deviceToken 发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。</p> <center><br> <img src="http://dzliving.com/Notification_0.png" alt><br><br> <img src="http://dzliving.com/Notification_2.png" alt><br> </center></li><li><p>当自己的服务器想发送推送时，在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给 APNs。</p></li><li>APNs 根据 deviceToken 发送给对应的用户。</li></ol><p>详细流程：</p><ol><li><p>在今日头条 App 的 AppDelegate 的 <code>didFinishLaunchingWithOptions</code> 方法中注册远程推送通知，此时只要 iOS 设备正常联网能够访问到外网，iOS 设备默认就会和 APNs 服务器<font color="#cc0000">维持一个基于 TCP 的长连接</font>，就会把 iOS 设备的 UDID(Unique Device Identifier:唯一设备标识码，用来标识唯一一台苹果设备)和 App 的 Bundle Identifier 通过长连接发送给 APNs 服务器，然后苹果通过这两个的值根据一定的加密算法得出 deviceToken，并将 deviceToken 返回给 iOS 设备。(注：<font color="#cc0000">APNs服务器会留有 UDID+Bundle Identifier+deviceToken 的映射表</font>)</p></li><li><p>实现 UIApplicationDelegate 代理中的有关于注册远程通知的相关方法，包括注册成功、注册失败、对接收到通知的处理等。</p></li><li><p>如果注册成功，实现注册成功的代理方法，就能够接收到 deviceToken，并将 deviceToken 发送给 App 服务器，App 服务器将此 deviceToken 存储在数据库中(一般如果是及时通讯类应用那么还会与用户的账号进行映射)。</p></li><li><p>如果注册失败，那么实现注册失败的协议方法，处理失败后的事情。</p></li><li><p>app 服务器接收到 deviceToken 之后，就可以根据这些 deviceToken 向 APNs 发送推送消息。</p></li><li><p>APNs 接收到 deviceToken 和消息之后，根据 deviceToken 查找映射表找到对应的 UDID 和 Bundle Identifier，根据 UDID 找到唯一一台苹果设备，再在找到的苹果设备上根据 Bundle Identifier 找到唯一的应用，然后推送消息。</p></li><li><p>当设备接收到消息的时候，如果 App 在前台，那么不会在设备上方弹出横幅（如果使用了音效，还会触发音效的播放），直接调用我们实现的 UIApplicationDelegate 中的接收消息的方法；如果 App 在后台或者未运行时就会在设备的上方弹出横幅（如果使用了音效，还会触发音效的播放），点击横幅才会触发调用我们实现的 UIApplicationDelegate 中的接收消息的方法，这个时候你直接点击应用图标进来是不会调用的。</p></li></ol><h2 id="二、信息包"><a href="#二、信息包" class="headerlink" title="二、信息包"></a>二、信息包</h2><p>信息包结构图：</p><center><br><img src="http://dzliving.com/Notification_4.png" alt><br></center><p>上图显示的这个消息体就是我们的应用服务器（Provider）发送给 APNs 服务器的消息结构，APNs 验证这个结构正确并提取其中的信息后，再将消息推送到指定的 iOS 设备。</p><p>这个结构体包括五个部分</p><ol><li>第一部分是命令标示符</li><li>第二部分是 devicetoken 的长度</li><li>第三部分是 devicetoken 字符串</li><li>第四部分是推送消息体（Payload）的长度</li><li>最后一部分也就是真正的消息内容了，里面包含了推送消息的基本信息，比如消息内容，应用 Icon 右上角显示多少数字以及推送消息到达时所播放的声音等</li></ol><p>Payload（消息体）的结构:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“aps”:&#123;</span><br><span class="line">“alert”:“CSDN给您发送了新消息”,</span><br><span class="line">“badge”:<span class="number">1</span>,</span><br><span class="line">“sound”:“default”</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是个 JSON 结构体，alert 标签的内容就是会显示在用户手机上的推送信息，badge 显示的数量（注意是整型）是会在应用 Icon 右上角显示的数量，提示有多少条未读消息等，sound 就是当推送信息送达是手机播放的声音，传 defalut 就标明使用系统默认声音。</p><h2 id="三、证书"><a href="#三、证书" class="headerlink" title="三、证书"></a>三、证书</h2><ul><li><p>应用的调试证书、描述文件</p><p>  <a href="https://www.jianshu.com/p/c8e86f62687a" target="_blank" rel="noopener">iOS- 最全的真机测试教程</a></p></li><li><p>应用的发布证书、描述文件</p><p>  <a href="https://www.jianshu.com/p/cea762105f7c" target="_blank" rel="noopener">iOS-最全的App上架教程</a></p></li><li><p>推送的调试证书和发布证书</p><p>  <a href="https://www.jianshu.com/p/9e98af89cecc" target="_blank" rel="noopener"></a></p></li></ul><h2 id="四、后台接收通知"><a href="#四、后台接收通知" class="headerlink" title="四、后台接收通知"></a>四、后台接收通知</h2><center><br><img src="http://dzliving.com/Notification_6.png" alt><br></center><p>开启推送。</p><center><br><img src="http://dzliving.com/Notification_5.png?imageView2/0/w/400" alt><br></center><p>当推送信息中包含 <code>content-available</code> 字段，并且等于 1</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"_j_business"</span> = 1;</span><br><span class="line">    <span class="string">"_j_msgid"</span> = 29273432613945685;</span><br><span class="line">    <span class="string">"_j_uid"</span> = 31254343846;</span><br><span class="line">    aps =     &#123;</span><br><span class="line">        alert = 11111;</span><br><span class="line">        badge = 1;</span><br><span class="line">        <span class="string">"content-available"</span> = 1;</span><br><span class="line">        sound = default;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app 即使在后台也能在 appDelegate 中触发代理回调</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>application:<span class="params">(UIApplication *)</span>application </span><br><span class="line">didReceiveRemoteNotification:<span class="params">(NSDictionary *)</span>userInfo</span><br><span class="line">fetchCompletionHandler: <span class="params">(void (^)</span><span class="params">(UIBackgroundFetchResult)</span>)completionHandler </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、Notification-Extension"><a href="#五、Notification-Extension" class="headerlink" title="五、Notification Extension"></a>五、Notification Extension</h2><p><a href="https://www.jianshu.com/p/78ef7bc04655" target="_blank" rel="noopener">iOS10推送通知进阶(Notification Extension）</a></p><center><br><img src="http://dzliving.com/Notification_7.png" alt><br></center><ol><li>UNNotificationContentExtension（通知内容扩展）给通知创建一个自定义的用户界面；</li><li>UNNotificationServiceExtension（通知服务扩展）是在收到通知后，展示通知前，做一些事情的。比如：增加附件，网络请求等。</li></ol><h4 id="5-1-UNNotificationServiceExtension-通知服务扩展"><a href="#5-1-UNNotificationServiceExtension-通知服务扩展" class="headerlink" title="5.1 UNNotificationServiceExtension - 通知服务扩展"></a>5.1 UNNotificationServiceExtension - 通知服务扩展</h4><p>如果经常使用 iMessage 的朋友们，就会经常收到一些信息，附带了一些照片或者视频，所以推送中能附带这些多媒体是非常重要的。如果推送中包含了这些多媒体信息，可以使用户不用打开 app，不用下载就可以快速浏览到内容。众所周知，推送通知中带了 push payload，即使去年苹果已经把 payload 的 size 提升到了 <font color="#cc0000">4k bites</font>，但是这么小的容量也无法使用户能发送一张高清的图片，甚至把这张图的缩略图包含在推送通知里面，也不一定放的下去。在 iOS X 中，我们可以使用新特性来解决这个问题。我们可以通过新的 service extensions 来解决这个问题。</p><p>iOS10 给通知添加附件有两种情况：本地通知和远程通知。</p><ol><li><p>本地推送通知</p><p> 只需给 content.attachments 设置 UNNotificationAttachment 附件对象</p></li><li><p>远程推送通知</p><p> 需要实现 UNNotificationServiceExtension（通知服务扩展），在回调方法中处理 推送内容时设置 request.content.attachments（请求内容的附件）属性，之后调用 contentHandler 方法即可。</p></li></ol><p>UNNotificationServiceExtension 提供在远程推送将要被 push 出来前，处理推送显示内容的机会。此时可以对通知的 <code>request.content</code> 进行内容添加，如添加附件、userInfo 等。下图显示了Notification Service Extension 的流程：</p><center><br><img src="http://dzliving.com/Notification_8.jpg" alt><br></center><p>处理的细节如下：</p><ol><li><p>为了能在 service extension 里面的 <code>attachment</code>，必须给 <code>apns</code> 增加 <code>&quot;mutable-content&quot;:1</code> 字段，使你的推送通知是动态可变的。</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="attr">"aps"</span>:&#123;</span><br><span class="line">         <span class="attr">"alert"</span>:<span class="string">"Testing.. (34)"</span>,</span><br><span class="line">         <span class="attr">"badge"</span>:<span class="number">1</span>,</span><br><span class="line">         <span class="attr">"sound"</span>:<span class="string">"default"</span>,</span><br><span class="line">         <span class="attr">"mutable-content"</span>:<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给项目新建一个 Notification Service Extension 的扩展。自动生成下列文件。</p> <center><br> <img src="http://dzliving.com/Notification_10.png" alt><br> </center></li><li><p>在 -didReceiveNotificationRequest:withContentHandler: 方法中处理request.content，用来给通知的内容做修改。如下面代码示例了收到通知后，给通知增加图片附件：</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="keyword">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.title = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ [modified]"</span>, <span class="keyword">self</span>.bestAttemptContent.title];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 下载</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img1.gtimg.com/sports/pics/hv1/194/44/2136/138904814.jpg"</span>];</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *config = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    <span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:config];</span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithURL:url completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//2. 保存数据</span></span><br><span class="line">            <span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject</span><br><span class="line">                              stringByAppendingPathComponent:<span class="string">@"download/image.jpg"</span>];</span><br><span class="line">            <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">            <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</span><br><span class="line">            [<span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1</span>) writeToFile:path options:<span class="built_in">NSAtomicWrite</span> error:&amp;err];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3. 添加附件</span></span><br><span class="line">            UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:<span class="string">@"remote-atta1"</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:path] options:<span class="literal">nil</span> error:&amp;err];</span><br><span class="line">            <span class="keyword">if</span> (attachment) &#123;</span><br><span class="line">                <span class="keyword">self</span>.bestAttemptContent.attachments = @[attachment];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4. 返回新的通知内容</span></span><br><span class="line">        <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>使用 UNNotificationServiceExtension，你有 <font color="#cc0000">30</font> 秒的时间处理这个通知，可以同步下载图像和视频到本地，然后包装为一个 UNNotificationAttachment 扔给通知，这样就能展示用服务器获取的图像或者视频了。</p><p>注意：如果数据处理失败、超时，extension 会报一个崩溃信息，但是通知会用默认的形式展示出来，app不会崩溃。</p><p>附件通知所带的附件格式大小都是有限的，并不能做所有事情，视频的前几帧作为一个通知的附件是个不错的选择。</p><p>UNNotificationAttachment：attachment 支持</p><ol><li>音频 5M（kUTTypeWaveformAudio/kUTTypeMP3/kUTTypeMPEG4Audio/kUTTypeAudioInterchangeFileFormat）</li><li>图片10M（kUTTypeJPEG/kUTTypeGIF/kUTTypePNG）</li><li>视频50M（kUTTypeMPEG/kUTTypeMPEG2Video/kUTTypeMPEG4/kUTTypeAVIMovie）</li></ol><h4 id="5-2-UNNotificationContentExtension-通知内容扩展"><a href="#5-2-UNNotificationContentExtension-通知内容扩展" class="headerlink" title="5.2 UNNotificationContentExtension - 通知内容扩展"></a>5.2 UNNotificationContentExtension - 通知内容扩展</h4><p>要想创建一个自定义的用户界面，需要用到 Notification Content Extension（通知内容扩展）。</p><p>Notification Content Extension（通知内容扩展）允许开发者加入自定义的界面，在这个界面里面，你可以绘制任何你想要的东西。但是有一个最重要的限制就是，<font color="#cc0000">这个自定义的界面没有交互</font>。它们不能接受点击事件，用户并不能点击它们。但是推送通知还是可以继续与用户进行交互，因为用户可以使用 notificaiton 的 actions。</p><p>注意：extension 也可以处理这些 actions。</p><ol><li><p>推送界面的组成</p> <center><br> <img src="http://dzliving.com/Notification_9.png" alt><br> </center><ul><li>header 的 UI 是系统提供的一套标准的 UI。这套 UI 会提供给所有的推送通知。</li><li>header 下面的 custom content 是自定义的内容，就是 Notification Content Extension。在这里，就可以显示任何你想绘制的内容了。你可以展示任何额外的有用的信息给用户。</li><li>default content 是系统的界面。这也就是 iOS 9 之前的推送的样子。</li><li>notification action 用户可以触发一些操作。并且这些操作还会相应的反映到上面的自定义的推送界面 content extension 中。</li></ul></li><li><p>创建 Notification Content Extension</p><p> 创建一个新的 Notification Content 的 target。Xcode 自动生成一个新的模板以及下列文件。</p> <center><br> <img src="http://dzliving.com/Notification_11.png" alt><br> </center><p> 然后打开这里的 ViewController。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NotificationViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotifications/UserNotifications.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UserNotificationsUI/UserNotificationsUI.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NotificationViewController</span> () &lt;<span class="title">UNNotificationContentExtension</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *label;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NotificationViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any required interface initialization here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveNotification:(UNNotification *)notification &#123;</span><br><span class="line">    <span class="keyword">self</span>.label.text = notification.request.content.body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>发现这里的 ViewController 就是一个普通的 UIViewController, 但是它实现了 UNNotificationContentExtension 协议。UNNotificationContentExtension 协议有一个 required方法 didReceiveNotification:。当收到指定 categroy 的推送时，didReceiveNotification: 方法会随着 ViewController 的生命周期方法，一起被调用，这样就能接受 notification object，更新UI。</code></pre><h4 id="5-3-配置category"><a href="#5-3-配置category" class="headerlink" title="5.3 配置category"></a>5.3 配置category</h4><p>接下来就是要让推送到达后，系统怎样找到自定义的 UI。这时候就需要配置 extension 的 info.plist 文件。</p><center><br><img src="http://dzliving.com/Notification_12.png" alt><br></center><p>这里和我们给 notification actions 注册 category 一样，给这个通知扩展指定相应的 category。在 UNNotificationExtensionCategory 字段里写入相应的 category id。值得提到的一点是，这里对应的 category 是可以为一个数组的，里面可以为多个 category，这样做的目的是多个 category 共用同一套 UI。</p><center><br><img src="http://dzliving.com/Notification_13.png" alt><br></center><p>上图中 category id 为 myNotificationCategory1 和 myNotificationCategory2 的通知就共用了一套 UI。</p><p>设置了 category 后，只要在通知里面增加 category 字段，值是上面在 extension 的 plist 里面配置的 category id，收到的通知就会通过自定义的样式显示。</p><p>远程通知在 apns 里面增加 category 字段。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"aps"</span>:&#123;</span><br><span class="line">        <span class="attr">"alert"</span>:<span class="string">"Testing.. (34)"</span>,</span><br><span class="line">        <span class="attr">"badge"</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">"sound"</span>:<span class="string">"default"</span>,</span><br><span class="line">        <span class="attr">"category"</span>:<span class="string">"myNotificationCategory1"</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-自定义UI"><a href="#5-4-自定义UI" class="headerlink" title="5.4 自定义UI"></a>5.4 自定义UI</h4><p>然后开始写自定义UI。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveNotification:(UNNotification *)notification </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.label.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ [modified]"</span>, notification.request.content.title];</span><br><span class="line">    <span class="keyword">self</span>.subLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ [modified]"</span>, notification.request.content.body];</span><br><span class="line">    <span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"hong.png"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在 ViewController 中增加一些 Label 和 ImageView，收到通知的时候，提取想要的内容，或者添加额外的内容，设置到我们自定义的 View 上。</p><p><img src="https://upload-images.jianshu.io/upload_images/1124181-cd4dbbd7380741f1.png" alt></p><h4 id="5-5-优化"><a href="#5-5-优化" class="headerlink" title="5.5 优化"></a>5.5 优化</h4><ol><li><p>发现是自定义界面的大小很不美观</p><p> 这时候可以通过设置 ViewController 的 preferredContentSize大小，控制自定义视图的大小。也可以通过约束，控制自定义视图的大小。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.preferredContentSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.view.frame), <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>视图恢复成正确的尺寸前，先展示有一大片空白的样子，然后变成正确的样子。当通知展示出来之后，它的大小并不是正常的我们想要的尺寸。iOS 系统会去做一个动画来 Resize 它的大小。这样体验很差。</p> <center><br> <img src="http://dzliving.com/Notification_14.gif" alt><br> </center><p> 会出现上面这张图的原因是，在推送送达的那一刻，iOS 系统需要知道我们推送界面的最终大小。但是我们自定义的extension在系统打算展示推送通知的那一刻，并还没有启动。所以这个时候，在我们代码都还没有跑起来之前，我们需要告诉iOS系统，我们的View最终要展示的大小。</p><p> 为了解决这个问题，我们需要在 extension 的 info.plist 里设置一个 content size ratio。增加字段 UNNotificationExtensionInitialContentSizeRatio。</p> <center><br> <img src="http://dzliving.com/Notification_15.png" alt><br> </center><p> 这个属性定义了宽和高的比例。当然设置了这个比例以后，也并不是万能的。因为你并不知道你会接受到多长的content。当你仅仅只设置比例，还是不能完整的展示所有的内容。有些时候如果我们可以知道最终的尺寸，那么我们固定尺寸会更好。</p></li><li><p>这时候我们发现我们自定义的界面显示的内容(custom content)和系统默认的内容(default content)重复了。</p><p> 可以在 extension 的 info.plist 里设置，把系统默认的样式隐藏。增加字段UNNotificationExtensionDefaultContentHidden。</p> <center><br> <img src="http://dzliving.com/Notification_16.png" alt><br> </center><p> 将系统内容隐藏后效果如下：</p> <center><br> <img src="http://dzliving.com/Notification_17.png" alt><br> </center></li></ol><h4 id="5-6-自定义操作"><a href="#5-6-自定义操作" class="headerlink" title="5.6 自定义操作"></a>5.6 自定义操作</h4><p>iOS8 开始引入的 action 的工作原理：</p><p>默认系统的 Action 的处理是：当用户点击的按钮，就把 action 传递给 app，与此同时，推送通知会立即消失。这种做法很方便。</p><p>但是有的情况是，希望用户点击 action 按钮后，效果及时响应在我们自定义的 UI 上。这个时候，用户点击完按钮，我们把这个 action 直接传递给 extension，而不是传递给 app。当 actions 传递给 extension 时，它可以延迟推送通知的消失时间。在这段延迟的时间之内，我们就可以处理用户点击按钮的事件了，并且更新 UI，一切都处理完成之后，我们再去让推送通知消失掉。</p><p>这里我们可以运用 UNNotificationContentExtension 协议的第二个方法，这方法是 Optional</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">didReceiveNotificationResponse:</span>(UNNotificationResponse *)response <span class="string">completionHandler:</span>(<span class="keyword">void</span> (^)(UNNotificationContentExtensionResponseOption option))completion</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([response.actionIdentifier <span class="string">isEqualToString:</span>@<span class="string">"action-like"</span>]) &#123;</span><br><span class="line">        self.label.text = @<span class="string">"点赞成功~"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier <span class="string">isEqualToString:</span>@<span class="string">"action-collect"</span>])&#123;</span><br><span class="line">        self.label.text = @<span class="string">"收藏成功~"</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier <span class="string">isEqualToString:</span>@<span class="string">"action-comment"</span>])&#123;</span><br><span class="line">        self.label.text = [(UNTextInputNotificationResponse *)response userText];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里如果点击的action类型为UNNotificationActionOptionForeground，</span></span><br><span class="line">    <span class="comment">//则即使completion设置成Dismiss的，通知也不能消失</span></span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.5</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        completion(UNNotificationContentExtensionResponseOptionDismiss);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里判断所有的 action，更新界面，并延迟 1.5 秒后让通知消失。真实情况可能是，点击“赞”按钮后，发送请求给服务器，根据服务器返回结果，展示不同的UI效果在通知界面上，然后消失。如果是评论，则将评论内容更新到界面上。</p><p>如果还想把这个 action 传递给 app，最后消失的参数应该这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completion(<span class="name">UNNotificationContentExtensionResponseOptionDismissAndForwardAction</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>但是我实际运行遇见这种情况，如果点击的 action 类型为 UNNotificationActionOptionForeground，则即使 completion 设置成 Dismiss 的，通知也不能消失，也没有启动 app。</p><h4 id="5-7-自定义输入型操作"><a href="#5-7-自定义输入型操作" class="headerlink" title="5.7 自定义输入型操作"></a>5.7 自定义输入型操作</h4><p>action 有 2 种类型：</p><ol><li>UNNotificationAction 普通按钮样式</li><li>UNTextInputNotificationAction 输入框样式</li></ol><p>UNTextInputNotificationAction 的样式如下：</p><center><br><img src="http://dzliving.com/Notification_18.png" alt><br></center><p>系统的输入样式的 action，只有在点击发送按钮时，才能接受到 action 的响应回调。（比如上面的didReceiveNotificationResponse:completionHandler: 方法）。但有的时候系统的样式或者功能不能满足需求，这时候可以自定义键盘上面的 inputAccessoryView。</p><p>首先，重写ViewController的下面两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)inputAccessoryView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.customInputView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 inputAccessoryView，以绘制自定义的输入样式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(<span class="keyword">void</span> (^)(UNNotificationContentExtensionResponseOption option))completion</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([response.actionIdentifier isEqualToString:<span class="string">@"action-comment"</span>])&#123;</span><br><span class="line">        <span class="keyword">self</span>.label.text = [(UNTextInputNotificationResponse *)response userText];</span><br><span class="line">        [<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">        [<span class="keyword">self</span>.textField becomeFirstResponder];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.completion = completion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了点击评论按钮，ViewController 成为第一响应者，使自定义的输入样式显示出来。然后，让textField成为第一响应者，使键盘弹出。</p><p>这里将操作的completion保存，以便在需要的时候调用。比如，可以在点击键盘右下的send按钮时，调用completion，使通知消失。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">BOOL)textFieldShouldReturn:(UITextField </span>*)textField</span><br><span class="line">&#123;</span><br><span class="line">    [textField resignFirstResponder]<span class="comment">;</span></span><br><span class="line">    self.label<span class="meta">.text</span> = textField<span class="meta">.text</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, </span>(int64_t)(<span class="number">1</span>.<span class="number">5</span> * NSEC_PER_SEC)), <span class="keyword">dispatch_get_main_queue(), </span>^&#123;</span><br><span class="line">        self.completion(UNNotificationContentExtensionResponseOptionDismiss)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">    return YES<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><center><br><img src="http://dzliving.com/Notification_19.png" alt><br></center><h4 id="5-8-结合使用两个扩展"><a href="#5-8-结合使用两个扩展" class="headerlink" title="5.8 结合使用两个扩展"></a>5.8 结合使用两个扩展</h4><p>可以在 content extension 里面绘制界面时，通过 notification.request.content.attachments 获取附件放到自定义控件里面。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">didReceiveNotification:(UNNotification </span>*)notification &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    UNNotificationAttachment * attachment = notification.request.content.attachments.firstObject<span class="comment">;</span></span><br><span class="line">    if (attachment) &#123;</span><br><span class="line">        if ([attachment.URL startAccessingSecurityScopedResource]) &#123;</span><br><span class="line">            self.imageView.image = [UIImage imageWithContentsOfFile:attachment.URL.path]<span class="comment">;</span></span><br><span class="line">            <span class="keyword">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, </span>(int64_t)(<span class="number">0</span>.<span class="number">5</span> * NSEC_PER_SEC)), <span class="keyword">dispatch_get_main_queue(), </span>^&#123;</span><br><span class="line">                [attachment.URL stopAccessingSecurityScopedResource]<span class="comment">;</span></span><br><span class="line">            &#125;)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以提取 content 的 attachments。前文提到过，attachment 是由系统管理的，系统会把它们单独的管理，这意味着它们存储在我们 sandbox 之外。所以这里我们要使用 attachment 之前，我们需要告诉 iOS 系统，我们需要使用它，并且在使用完毕之后告诉系统我们使用完毕了。对应上述代码就是 <code>-startAccessingSecurityScopedResource和-stopAccessingSecurityScopedResource</code> 的操作。当我们获取到了 attachment 的使用权之后，我们就可以使用那个文件获取我们想要的信息了。</p><h4 id="5-9-关于调试"><a href="#5-9-关于调试" class="headerlink" title="5.9 关于调试"></a>5.9 关于调试</h4><p>很多人在开发 iOS extension 时遇到了调试的问题，可以看这里的<a href="https://github.com/liuyanhongwl/ios_common/blob/master/files/App-Extension-Tips.md" target="_blank" rel="noopener">解决方法</a>，如果还不能有效解决您的问题，欢迎评论留言。</p><p><a href="https://github.com/liuyanhongwl/UserNotification" target="_blank" rel="noopener">Demo</a><br><a href="http://www.cocoachina.com/articles/16833" target="_blank" rel="noopener">【WWDC2016 Session】iOS 10 推送Notification新特性</a><br><a href="https://www.jianshu.com/p/601426a247e6" target="_blank" rel="noopener">iOS- 实现APP前台、后台、甚至杀死进程下收到通知后进行语音播报（金额）。</a></p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p>官方文档：<a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1" target="_blank" rel="noopener">Local and Remote Notification Programming Guide</a><br><a href="https%3A%2F%2Fmy.oschina.net%2Fu%2F2340880%2Fblog%2F405491">iOS中使用本地通知为你的APP添加提示用户功能</a><br><a href="https://www.jianshu.com/p/9e98af89cecc" target="_blank" rel="noopener">iOS远程推送之(一)：APNs原理和基本配置</a><br><a href="https://www.jianshu.com/p/59878fd8053c" target="_blank" rel="noopener">iOS远程推送之(二)：角标applicationIconNumber设置</a><br><a href="https://www.jianshu.com/p/d7372b166a0b" target="_blank" rel="noopener">iOS远程推送之(三)：点击通知横幅启动应用</a><br><a href="https://www.jianshu.com/p/032bfc949917" target="_blank" rel="noopener">iOS 远程消息推送 APNS推送原理和一步一步开发详解篇</a><br><a href="https%3A%2F%2Fgithub.com%2Fshaojiankui%2FSmartPush">SmartPush</a><br><a href="https://blog.csdn.net/weixin_36162680/article/details/83863718" target="_blank" rel="noopener">iOS远程推送原理及实现过程</a><br><a href="https://www.jianshu.com/p/4ffb56716a5c" target="_blank" rel="noopener">iOS 推送通知及通知扩展</a><br><a href="https://www.jianshu.com/p/bb89d636f989" target="_blank" rel="noopener">iOS10 推送通知 UserNotifications</a><br><a href="https://www.jianshu.com/p/e9c313df746f" target="_blank" rel="noopener">iOS 推送全解析，你不可不知的所有 Tips！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、推送原理&quot;&gt;&lt;a href=&quot;#一、推送原理&quot; class=&quot;headerlink&quot; title=&quot;一、推送原理&quot;&gt;&lt;/a&gt;一、推送原理&lt;/h2&gt;&lt;p&gt;当用户打开应用程序的通知中心之后，苹果远程推送服务器就能把消息推送到装有该应用的设备上，具有强制性、实时性的
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 性能优化点</title>
    <link href="http://yoursite.com/2019/10/30/iOS/iOS%E4%BC%98%E5%8C%96/iOS%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%82%B9/"/>
    <id>http://yoursite.com/2019/10/30/iOS/iOS优化/iOS 性能优化点/</id>
    <published>2019-10-30T08:00:18.240Z</published>
    <updated>2019-11-06T06:32:48.665Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>用 ARC 管理内存</p></li><li><p>在正确的地方使用 reuseIdentifier</p></li><li><p>尽量把 views 设置为完全不透明</p><p> 如果你有透明的 Views 你应该设置它们的 opaque(不透明)属性为 YES。例如一个黑色半透明的可以设置为一个灰色不透明的 View 替代。原因是这会使系统用一个最优的方式渲染这些 views。这个简单的属性在 IB 或者代码里都可以设定。</p><p> Apple的文档对于为图片设置透明属性的描述是：</p><blockquote><p>(opaque)这个属性给渲染系统提供了一个如何处理这个 view 的提示。如果设为YES， 渲染系统就认为这个 view 是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能；如果设置为 NO，渲染系统正常地和其它内容组成这个 View。默认值是 YES。</p></blockquote><p> 在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个 view 嵌在 scroll view 里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响 app 的性能。</p><p> 换种说法，大家可能更好理解：</p><p> 只要一个视图的不透明度小于 1，就会导致 blending。blending 操作在 iOS 的图形处理器（GPU）中完成的，blending 主要指的是混合像素颜色的计算。举个例子，我们把两个图层叠加在一起,如果第一个图层的有透明效果，则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。</p><blockquote><p>为什么 Blending 会导致性能的损失？</p></blockquote><p> 原因是很直观的，如果一个图层是完全不透明的，则系统直接显示该图层的颜色即可。而如果图层是带透明效果的，则会引入更多的计算，因为需要把下面的图层也包括进来，进行混合后颜色的计算。</p></li><li><p>避免过于庞大的 xib</p><p> iOS5 中加入的 Storyboards(分镜)正在快速取代 XIB。然而 XIB 在一些场景中仍然很有用。比如你的 app 需要适应 iOS5 之前的设备，或者你有一个自定义的可重用的 view,你就不可避免地要用到他们。</p><p> 如果你不得不 xib 的话，使他们尽量简单。尝试为每个 Controller 配置一个单独的 xib，尽可能把一个 View Controller 的 view 层次结构分散到单独的 xib 中去。</p><p> 需要注意的是，当你加载一个 xib 的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的 view，你这就是在浪费宝贵的内存资源了。Storyboards 就是另一码事儿了，storyboard 仅在需要时实例化一个 view controller。</p><p> 当你加载一个引用了图片或者声音资源的 nib 时，nib 加载代码会把图片和声音文件写进内存。在 OS X 中，图片和声音资源被缓存在 named cache 中以便将来用到时获取。在 iOS 中，仅图片资源会被存进 named caches。取决于你所在的平台，使用 NSImage 或 UIImage 的 imageNamed: 方法来获取图片资源。</p></li><li><p>不要阻塞主线程</p><p> 永远不要使主线程承担过多。因为 UIKit 在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的 block 了主线程，你的 app 会失去反应。</p><p> 大部分阻碍主进程的情形是你的 app 在做一些牵涉到读写外部资源的 I/O 操作，比如存储或者网络。或者使用像 AFNetworking 这样的框架来异步地做这些操作。</p><p> 如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues.</p><p> 你可以使用 NSURLConnection 异步地做网络操作:</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request queue:(<span class="built_in">NSOperationQueue</span> *)queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>在 Image Views 中调整图片大小</p><p> 如果要在 UIImageView 中显示一个来自 bundle 的图片，你应保证图片的大小和 UIImageView 的大小相同。在运行中缩放图片是很耗费资源的，特别是 UIImageView 嵌套在 UIScrollView 中的情况下。</p><p> 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用 background thread，缩放一次，然后在 UIImageView 中使用缩放后的图片。</p></li><li><p>选择正确的 Collection</p><p> 学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理 collections 时这句话尤其正确。</p><p> Apple 有一个 Collections Programming Topics 的文档详尽介绍了可用的 classes 间的差别和你该在哪些场景中使用它们。这对于任何使用 collections 的人来说是一个必读的文档。</p><ul><li>Arrays：有序的一组值。使用 index 来 lookup 很快，使用 value lookup 很慢，插入/删除很慢。</li><li>Dictionaries：存储键值对。用键来查找比较快。</li><li>Sets：无序的一组值。用值来查找很快，插入/删除很快。</li></ul></li><li><p>打开 gzip 压缩</p><p> 大量 app 依赖于远端资源和第三方 API，你可能会开发一个需要从远端下载 XML、JSON、HTML 或者其它格式的 app。</p><p> 问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在 edge 网络，下一分钟可能就切换到了 3G。不论什么场景，你肯定不想让你的用户等太长时间。</p><p> 减小文档的一个方式就是在服务端和你的 app 中打开 gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS 已经在 NSURLConnection 中默认支持了 gzip 压缩，当然 AFNetworking 这些基于它的框架亦然。像 Google App Engine 这些云服务提供者也已经支持了压缩输出。</p></li><li><p>重用和延迟加载(lazy load) Views</p><p> 更多的 view 意味着更多的渲染，也就是更多的 CPU 和内存消耗，对于那种嵌套了很多 view 在UIScrollView 里边的 app 更是如此。</p><p> 这里我们用到的技巧就是模仿 UITableView 和 UICollectionView 的操作：不要一次创建所有的 subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。</p><p> 这样的话你就只需要在滚动发生时创建你的 views，避免了不划算的内存分配。</p><p> 创建 views 的能效问题也适用于你 app 的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个 view 的场景。有两种实现方法：</p><ul><li>创建并隐藏这个 view 当这个 screen 加载的时候，当需要时显示它；</li><li><p>当需要时才创建并展示。</p><p>每个方案都有其优缺点。</p><p>用第一种方案的话因为你需要一开始就创建一个 view 并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的 app 操作更敏感因为当用户点击按钮的时候它只需要改变一下这个 view 的可见性。</p><p>第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。</p></li></ul></li><li><p>Cache</p><p>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</p><p>我们能缓存些什么呢？一些选项是：远端服务器的响应、图片，甚至计算结果，比如 UITableView 的行高。</p><p>NSURLConnection 默认会缓存资源在内存或者存储中根据它所加载的 HTTP Headers。你甚至可以手动创建一个 NSURLRequest 然后使它只加载缓存的值。</p><p>下面是一个可用的代码段，你可以用它去为一个基本不会改变的图片创建一个 NSURLRequest 并缓存它：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableURLRequest</span> *)imageRequestWithURL:(<span class="built_in">NSURL</span> *)url </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSMutableURLRequest</span> * request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"> </span><br><span class="line">  request.cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>;<span class="comment">// this will make sure the request always returns the cached image</span></span><br><span class="line">  request.HTTPShouldHandleCookies = <span class="literal">NO</span>;</span><br><span class="line">  request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">  [request addValue:<span class="string">@"image/*"</span> forHTTPHeaderField:<span class="string">@"Accept"</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> request;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>注意你可以通过 NSURLConnection 获取一个 URL request，AFNetworking 也一样的。这样你就不必为采用这条 tip 而改变所有的 Networking 代码了。如果你需要缓存其它不是 HTTP Request 的东西，你可以用 NSCache。NSCache 和 NSDictionary 类似，不同的是系统回收内存的时候它会自动删掉它的内容。</code></pre><ol start="11"><li><p>权衡渲染方法</p><p>在 iOS 中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，uozhe 可以用CALayer， CoreGraphics甚至OpenGL来画它们。</p><p>当然每个不同的解决方法都有不同的复杂程度和相应的性能。有一篇 Apple UIKit team中的一员Andy Matuschak推荐过的很棒的关于graphic性能的帖子很值得一读。</p><p>简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积 – 这就是使用可变大小的图片更好的地方了: 你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。<br>然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。<br>总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。</p></li><li><p>处理内存警告</p><p>一旦系统内存过低，iOS 会通知所有运行中 app。在官方文档中是这样记述:</p><blockquote><p>如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references.</p></blockquote><p>幸运的是，UIKit 提供了几种收集低内存警告的方法:</p><ul><li>在app delegate中使用applicationDidReceiveMemoryWarning: 的方法</li><li>在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning</li><li>注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知</li></ul><p>一旦收到这类通知，你就需要释放任何不必要的内存使用。</p><p>例如，UIViewController 的默认行为是移除一些不可见的 view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。</p><p>这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。</p><p>然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。</p></li><li><p>重用大开销对象</p><p>一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。</p><p>想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</p><p>注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。</p><p>下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> * formatter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.formatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)formatter </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(! _formatter) &#123;</span><br><span class="line">        _formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        _formatter.dateFormat = <span class="string">@"EEE MMM dd HH:mm:ss Z yyyy"</span>;<span class="comment">// twitter date format</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _formatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>还需要注意的是，其实设置一个 NSDateFormatter 的速度差不多是和创建新的一样慢的！所以如果你的 app 需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。</code></pre><ol start="14"><li><p>使用 Sprite Sheets</p><p>你是一个游戏开发者吗，那么Sprite sheets一定是一个你的最好的朋友了。Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。</p><p>我们有两个很好的关于Sprite的教程：</p><ol><li>How To Use Animations and Sprite Sheets in Cocos2D</li><li>How to Create and Optimize Sprite Sheets in Cocos2D with Texture Packer and Pixel Formats</li></ol><p>第二个教程涵盖了可能在很大程度上影响你游戏性能的pixel格式的细节。</p><p>如果你对于spirte sheet还不是很熟悉，可以看下这两个(youtube)视频SpriteSheets – The Movie, Part 1 和Part 2。视频的作者是创建Sprite sheet很流行的工具之一Texture Packer的作者Andreas Löw。</p><p>除了使用Sprite sheets，其它写在这里的建议当然也可以用于游戏开发中。比如你需要很多的Sprite sheets，像敌人，导弹之类的动作类必备元素，你可以重用这些sprites而不用每次都要重新创建。</p></li><li><p>避免反复处理数据</p><p>许多应用需要从服务器加载功能所需的常为 JSON 或者 XML 格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。</p><p>比如你需要数据来展示一个 table view，最好直接从服务器取 array 结构的数据以避免额外的中间数据结构改变。</p><p>类似的，如果需要从特定 key 中取数据，那么就使用键值对的 dictionary。</p></li><li><p>选择正确的数据格式</p><p>从 app 和网络服务间传输数据有很多方案，最常见的就是 JSON 和 XML。你需要选择对你的 app 来说最合适的一个。</p><p>解析 JSON 会比 XML 更快一些，JSON 也通常更小更便于传输。从 iOS5 起有了官方内建的 JSON deserialization 就更加方便使用了。</p><p>但是 XML 也有 XML 的好处，比如使用 SAX 来解析 XML 就像解析本地文件一样，你不需像解析 json 一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</p></li><li><p>正确设定背景图片</p><p>在 View 里放背景图片就像很多其它 iOS 编程一样有很多方法:</p><ul><li>使用UIColor的 colorWithPatternImage 来设置背景色；</li><li>在 view 中添加 一个UIImageView 作为一个子 View。</li></ul><p>如果你使用全画幅的背景图，你就必须使用 UIImageView，因为 UIColor 的colorWithPatternImage 是用来创建小的重复的图片作为背景的。这种情形下使用 UIImageView 可以节约不少的内存：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You could also achieve the same result in Interface Builder</span></span><br><span class="line"><span class="built_in">UIImageView</span> *backgroundView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:backgroundView];</span><br></pre></td></tr></table></figure></li></ol><pre><code>如果你用小图平铺来创建背景，你就需要用 UIColor 的 colorWithPatternImage 来做了，它会更快地渲染也不会花费很多内存：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background"</span>]];</span><br></pre></td></tr></table></figure></code></pre><ol start="18"><li><p>减少使用Web特性</p><p>UIWebView 很有用，用它来展示网页内容或者创建 UIKit 很难做到的动画效果是很简单的一件事。</p><p>但是你可能有注意到 UIWebView 并不像驱动 Safari 的那么快。这是由于以 JIT compilation  为特色的 Webkit 的 Nitro Engine 的限制。</p><p>所以想要更高的性能你就要调整下你的 HTML 了。第一件要做的事就是尽可能移除不必要的 javascript，避免使用过大的框架。能只用原生 js 就更好了。</p><p>另外，尽可能异步加载例如用户行为统计 script 这种不影响页面表达的 javascript。</p><p>最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用 Sprite sheet 提高加载速度和节约内存。</p><p>更多相关信息可以看下 WWDC 2012 session #601 – Optimizing Web Content in UIWebViews and Websites on iOS</p></li><li><p>设定 Shadow Path</p><p>如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Somewhere later ...</span></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">view.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">-1.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">view.layer.shadowRadius = <span class="number">5.0</span>f;</span><br><span class="line">view.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure></li></ol><pre><code>看起来很简单，对吧。可是，坏消息是使用这个方法也有它的问题… Core Animation 不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用 shadowPath 的话就避免了这个问题：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.layer.<span class="keyword">shadowPath </span>= [[UIBezierPath <span class="keyword">bezierPathWithRect:view.bounds] </span>CGPath]<span class="comment">;</span></span><br></pre></td></tr></table></figure>使用 shadow path 的话 iOS 就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算 path 的话可能在某些 View 中比较困难，且每当 view 的 frame 变化的时候你都需要去 update shadow path.</code></pre><ol start="20"><li><p>优化 Table View</p><p>Table view 需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。</p><p>为了保证 table view 平滑滚动，确保你采取了以下的措施:</p><ul><li>正确使用 reuseIdentifier 来重用 cells</li><li>尽量使所有的 view opaque = YES，包括 cell 自身</li><li>避免渐变，图片缩放，后台渲染</li><li>缓存行高</li><li>如果 cell 内显示的内容来自 web，使用异步加载，缓存请求结果</li><li>使用 shadowPath 来画阴影</li><li>减少 subviews 的数量</li><li>尽量不使用 cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果</li><li>使用正确的数据结构来存储数据</li><li>尽量使用 rowHeight，sectionFooterHeight 和 sectionHeaderHeight 来设定固定的高，不要请求 delegate</li></ul></li><li><p>选择正确的数据存储选项</p><p>当做本地数据存储时你会怎么做？</p><p>你有很多选择，比如：</p><ul><li>使用 NSUerDefaults</li><li>使用 XML，JSON 或者 plist</li><li>使用 NSCoding 存档</li><li>使用类似 SQLite 的本地 SQL 数据库</li><li>使用 Core Data</li></ul><p>NSUserDefaults 的问题是什么？虽然它很 nice 也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</p><p>XML 这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用 SAX 又是一个很麻烦的事情。</p><p>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</p><p>当存储大块数据时，以上的方法都不适用. 在这种应用场景下，使用 SQLite 或者 Core Data 比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</p><p>在性能层面来讲，SQLite 和 Core Data 是很相似的。他们的不同在于具体使用方法。Core Data 代表一个对象的 graph model，但 SQLite 就是一个 DBMS。Apple 在一般情况下建议使用 Core Data，但是如果你有理由不使用它，那么就去使用更加底层的 SQLite 吧。</p></li><li><p>加速启动时间</p><p>快速打开 app 是很重要的，特别是用户第一次打开它时。</p><p>你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。</p><p>还是那句话，避免过于庞大的 xib，因为他们是在主线程上加载的。所以尽量使用没有这个问题的 Storyboards 吧！</p><p>注意，用 Xcode debug 时 watchdog 并不运行，一定要把设备从 Xcode 断开来测试启动速度</p></li><li><p>使用 Autorelease Pool</p><p>NSAutoreleasePool 负责释放 block 中的 autoreleased objects。一般情况下它会自动被 UIKit 调用。但是有些状况下你也需要手动去创建它。</p><p>假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被 release 的时候。这是因为只有当 UIKit 用光了 autorelease pool 的时候 memory 才会被释放。</p><p>好消息是你可以在你自己的 @autoreleasepool 里创建临时的对象来避免这个行为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="built_in">NSError</span> * error;</span><br><span class="line"><span class="built_in">NSString</span> * fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                     encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">    <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这段代码在每次遍历后释放所有 autorelease 对象。</code></pre><ol start="24"><li><p>选择是否缓存图片</p><p>常见的从 bundle 中加载图片的方式有两种，一个是用 imageNamed，二是用 imageWithContentsOfFile，第一种比较常见一点。</p><p>既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？</p><p>imageNamed 的优点是当加载时会缓存图片。imageNamed 的文档中这么说:</p><blockquote><p>这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。</p></blockquote><p>相反的，imageWithContentsOfFile 仅加载图片。</p><p>下面的代码说明了这两种方法的用法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImage"</span>];<span class="comment">// caching</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithContentsOfFile:<span class="string">@"myImage"</span>];<span class="comment">// no caching</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>那么我们应该如何选择呢？如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用 imageWithContentsOfFile 足矣，这样不会浪费内存来缓存它。然而，在图片反复重用的情况下 imageNamed 是一个好得多的选择。</code></pre><ol start="25"><li><p>避免日期格式转换</p><p>如果你要用 NSDateFormatter 来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用 NSDateFormatters 都是一个好的实践。</p><p>然而，如果你需要更多速度，那么直接用 C 是一个好的方案。Sam Soffes 有一个不错的帖子(<a href="http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析" target="_blank" rel="noopener">http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析</a> ISO-8601 日期字符串的代码，简单重写一下就可以拿来用了。</p><p>嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！</p><p>如果你可以控制你所处理的日期格式，尽量选择 Unix 时间戳。你可以方便地从时间戳转换到 NSDate:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDate</span> *)dateFromUnixTimestamp:(<span class="built_in">NSTimeInterval</span>)timestamp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会比用 C 来解析日期字符串还快！</p><p>需要注意的是，许多 web API 会以微秒的形式返回时间戳，因为这种格式在 javascript 中更方便使用。记住用 dateFromUnixTimestamp 之前除以 1000 就好了。</p></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="http://www.jianshu.com/p/9c450e512020" target="_blank" rel="noopener">iOS最全性能优化(上)</a><br><a href="http://www.jianshu.com/p/ad90e90dce4f" target="_blank" rel="noopener">iOS最全性能优化(中)</a><br><a href="http://www.jianshu.com/p/25e2f1ae51d2" target="_blank" rel="noopener">iOS最全性能优化(下)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;用 ARC 管理内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在正确的地方使用 reuseIdentifier&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量把 views 设置为完全不透明&lt;/p&gt;
&lt;p&gt; 如果你有透明的 Views 你应该设置它们的 opaque(不
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS图片加载速度极限优化</title>
    <link href="http://yoursite.com/2019/10/30/iOS/iOS%E4%BC%98%E5%8C%96/iOS%20%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%9E%81%E9%99%90%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/10/30/iOS/iOS优化/iOS 图片加载速度极限优化/</id>
    <published>2019-10-30T07:24:40.728Z</published>
    <updated>2019-10-30T07:24:40.728Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a> 是 Path 团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。</p><h2 id="一、优化点"><a href="#一、优化点" class="headerlink" title="一、优化点"></a>一、优化点</h2><p>iOS 从磁盘加载一张图片，使用 UIImageVIew 显示在屏幕上，需要经过以下步骤：</p><ol><li>从磁盘拷贝数据到内核缓冲区</li><li>从内核缓冲区复制数据到用户空间</li><li>生成 UIImageView，把图像数据赋值给 UIImageView</li><li>如果图像数据为未解码的 PNG/JPG，解码为位图数据</li><li>CATransaction 捕获到 UIImageView layer 树的变化</li><li>主线程 Runloop 提交 CATransaction，开始进行图像渲染<ul><li>如果数据没有字节对齐，Core Animation 会再拷贝一份数据，进行字节对齐。</li><li>GPU 处理位图数据，进行渲染。</li></ul></li></ol><p>FastImageCache 分别优化了 2、4、6(1) 三个步骤：</p><ol><li>使用 mmap 内存映射，省去了上述第 2 步数据从内核空间拷贝到用户空间的操作。</li><li>缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第 4 步解码的操作。</li><li>生成字节对齐的数据，防止上述第 6(1) 步 CoreAnimation 在渲染时再拷贝一份数据。</li></ol><p>接下来具体介绍这三个优化点以及它的实现。</p><h2 id="二、内存映射"><a href="#二、内存映射" class="headerlink" title="二、内存映射"></a>二、内存映射</h2><p>平常我们读取磁盘上的一个文件，上层 API 调用到最后会使用系统方法 read() 读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p><p>FastImageCache 采用了另一种读写文件的方法，就是用 mmap 把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。</p><h2 id="三、解码图像"><a href="#三、解码图像" class="headerlink" title="三、解码图像"></a>三、解码图像</h2><p>一般我们使用的图像是 JPG/PNG，这些图像数据不是位图，而是是经过编码压缩后的数据，使用它渲染到屏幕之前需要进行解码转成位图数据，这个解码操作是比较耗时的，并且没有 GPU 硬解码，只能通过 CPU，iOS 默认会在主线程对图像进行解码。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage 的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。</p><p>FastImageCache 也是在子线程解码图像，不同的是它会缓存解码后的图像到磁盘。因为解码后的图像体积很大，FastImageCache 对这些图像数据做了系列缓存管理，详见下文实现部分。另外缓存的图像体积大也是使用内存映射读取文件的原因，小文件使用内存映射无优势，内存拷贝的量少，拷贝后占用用户内存也不高，文件越大内存映射优势越大。</p><h2 id="四、字节对齐"><a href="#四、字节对齐" class="headerlink" title="四、字节对齐"></a>四、字节对齐</h2><p>Core Animation 在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，官方文档没有对这次拷贝行为作说明，模拟器和 Instrument 里有高亮显示“copied images”的功能，但似乎它有 bug，即使某张图片没有被高亮显示出渲染时被 copy，从调用堆栈上也还是能看到调用了 CA::Render::copy_image 方法：</p><center><br><img src="http://dzliving.com/Instrument_2.png" alt><br></center><p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前 CoreAnimation 要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel 是图像像素数据，data 是内存里其他数据)</p><center><br><img src="http://dzliving.com/Instrument_3.png" alt><br></center><p>块的大小应该是跟 CPU cache line 有关，ARMv7 是 32byte，A9 是 64byte，在 A9 下 CoreAnimation 应该是按 64byte 作为一块数据去读取和渲染，让图像数据对齐 64byte 就可以避免 CoreAnimation 再拷贝一份数据进行修补。FastImageCache 做的字节对齐就是这个事情。</p><h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><p>FastImageCache 把同个类型和尺寸的图像都放在一个文件里，根据文件偏移取单张图片，类似 web 的 css 雪碧图，这里称为 ImageTable。这样做主要是为了方便统一管理图片缓存，控制缓存的大小，整个 FastImageCache 就是在管理一个个 ImageTable 的数据。整体实现的数据结构如图：</p><center><br><img src="http://dzliving.com/FastImageCache_0.png" alt><br></center><p>一些补充和说明：</p><h4 id="5-1-ImageTable"><a href="#5-1-ImageTable" class="headerlink" title="5.1 ImageTable"></a>5.1 ImageTable</h4><p>一个 ImageFormat 对应一个 ImageTable，ImageFormat 指定了 ImageTable 里图像渲染格式/大小等信息，ImageTable 里的图像数据都由 ImageFormat 规定了统一的尺寸，每张图像大小都是一样的。</p><p>一个 ImageTable 一个实体文件，并有另一个文件保存这个 ImageTable 的 meta 信息。</p><p>图像使用 entityUUID作为唯一标示符，由用户定义，通常是图像url的hash值。ImageTable Meta的indexMap记录了entityUUID-&gt;entryIndex的映射，通过indexMap就可以用图像的entityUUID找到缓存数据在ImageTable对应的位置。</p><h4 id="5-2-ImageTableEntry"><a href="#5-2-ImageTableEntry" class="headerlink" title="5.2 ImageTableEntry"></a>5.2 ImageTableEntry</h4><p>ImageTable的实体数据是ImageTableEntry，每个entry有两部分数据，一部分是对齐后的图像数据，另一部分是meta信息，meta保存这张图像的UUID和原图UUID，用于校验图像数据的正确性。</p><p>Entry数据是按内存分页大小对齐的，数据大小是内存分页大小的整数倍，这样可以保证虚拟内存缺页加载时使用最少的内存页加载一张图像。</p><p>图像数据做了字节对齐处理，CoreAnimation使用时无需再处理拷贝。具体做法是CGBitmapContextCreate创建位图画布时bytesPerRow参数传64倍数。</p><h4 id="5-3-Chunk"><a href="#5-3-Chunk" class="headerlink" title="5.3 Chunk"></a>5.3 Chunk</h4><p>ImageTable和实体数据Entry间多了层Chunk，Chunk是逻辑上的数据划分，N个Entry作为一个Chunk，内存映射mmap操作是以chunk为单位的，每一个chunk执行一次mmap把这个chunk的内容映射到虚拟内存。为什么要多一层chunk呢，按我的理解，这样做是为了灵活控制mmap的大小和调用次数，若对整个ImageTable执行mmap，载入虚拟内存的文件过大，若对每个Entry做mmap，调用次数会太多。</p><h4 id="5-4-缓存管理"><a href="#5-4-缓存管理" class="headerlink" title="5.4 缓存管理"></a>5.4 缓存管理</h4><p>用户可以定义整个ImageTable里最大缓存的图像数量，在有新图像需要缓存时，如果缓存没有超过限制，会以chunk为单位扩展文件大小，顺序写下去。如果已超过最大缓存限制，会把最少使用的缓存替换掉，实现方法是每次使用图像都会把UUID插入到MRUEntries数组的开头，MRUEntries按最近使用顺序排列了图像UUID，数组里最后一个图像就是最少使用的。被替换掉的图片下次需要再使用时，再走一次取原图—解压—存储的流程。</p><h2 id="六、使用"><a href="#六、使用" class="headerlink" title="六、使用"></a>六、使用</h2><p>FastImageCache 适合用于 tableView 里缓存每个 cell 上同样规格的图像，优点是能极大加快第一次从磁盘加载这些图像的速度。但它有两个明显的缺点：</p><ol><li><font color="#cc0000">占空间大</font>。因为缓存了解码后的位图到磁盘，位图是很大的，宽高 100*100 的图像在 2x 的高清屏设备下就需要 200*200*4byte/pixel = 156KB，这也是为什么 FastImageCache 要大费周章限制缓存大小。</li><li>接口不友好，需预定义好缓存的图像尺寸。FastImageCache 无法像 SDWebImage 那样无缝接入UIImageView，使用它需要配置 ImageTable，定义好尺寸，手动提供的原图，每种实体图像要定义一个 FICEntity 模型，使逻辑变复杂。</li></ol><p>FastImageCache 已经属于极限优化，做图像加载/渲染优化时应该优先考虑一些低代价高回报的优化点，例如 CALayer 代替 UIImageVIew，减少 GPU 计算（去透明/像素对齐），图像子线程解码，避免 Offscreen-Render 等。在其他优化都做到位，图像的渲染还是有性能问题的前提下才考虑使用 FastImageCache 进一步提升首次加载的性能，不过字节对齐的优化倒是可以脱离 FastImageCache 直接运用在项目上，只需要在解码图像时 bitmap 画布的 bytesPerRow 设为 64 的倍数即可。</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="http://www.cocoachina.com/articles/11128" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/path/FastImageCache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FastImageCache&lt;/a&gt; 是 Path 团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>macro</title>
    <link href="http://yoursite.com/2019/10/30/IT/macro/"/>
    <id>http://yoursite.com/2019/10/30/IT/macro/</id>
    <published>2019-10-30T06:09:24.820Z</published>
    <updated>2019-10-30T09:35:28.695Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/4a1531bac39f" target="_blank" rel="noopener">Hello, 宏定义魔法世界</a></p><h2 id="宏定义和全局变量的区别"><a href="#宏定义和全局变量的区别" class="headerlink" title="宏定义和全局变量的区别"></a>宏定义和全局变量的区别</h2><ol><li>宏会在预处理阶段被替换，而全局变量是在运行时；</li><li>宏定义不分配内存，全局变量定义需要分配内存；</li><li>宏不区分数据类型，它本质上是一段字符，在预处理的时候被替换到引用的位置，而全局变量区分数据类型；</li><li>宏定义之后值是不能改变的，全局变量的值是可以改变的；</li><li>宏定义只有在定义所在文件，或引用所在文件的其它文件中使用。 而全局变量可以在工程所有文件中使用，只需在使用前加一个声明。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/4a1531bac39f&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hello, 宏定义魔法世界&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;宏定义和全局变量的区别&quot;&gt;&lt;a href=&quot;#宏定义
      
    
    </summary>
    
      <category term="IT" scheme="http://yoursite.com/categories/IT/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS hash</title>
    <link href="http://yoursite.com/2019/10/30/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20hash/"/>
    <id>http://yoursite.com/2019/10/30/iOS/iOS原理/iOS hash/</id>
    <published>2019-10-30T05:57:45.930Z</published>
    <updated>2019-10-30T05:57:45.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、iOS-hash"><a href="#一、iOS-hash" class="headerlink" title="一、iOS hash"></a>一、iOS hash</h2><p>下图列出 Hash 在 iOS 中的应用分析整理</p><center><br><img src="http://dzliving.com/Hash_3.png" alt><br></center><p>知乎上的一句话：</p><blockquote><p>算法、数据结构、通信协议、文件系统、驱动等，虽然自己不写那些东西，但是了解其原理对于排错、优化自己的代码有很大帮助，就好比虽然你不设计制造汽车，但如果你了解发动机、变速器、安全气囊等几项原理，对于你驾车如何省油、延长使用寿命、保证自身安全有很大好处，学而不思则罔、思而不学则殆，开发人员就是个随波而进的行业，无论何时何地，保持学习的深度和广度对于自身发展是很重要的，谁都不想 60 岁退休了还停留在增删查改的层面。</p></blockquote><h4 id="1-1-关联对象的实现原理"><a href="#1-1-关联对象的实现原理" class="headerlink" title="1.1 关联对象的实现原理"></a>1.1 关联对象的实现原理</h4><p>关联对象采用的是 HashMap 嵌套 HashMap 的结构存储数据的，简单来说就是根据对象从第一个 HashMap 中取出存储对象所有关联对象的第二个 HashMap，然后根据属性名从第二个 HashMap 中取出属性对应的值和策略。</p><p>设计关联对象的初衷：通过传入对象 + 属性名字，就可以找到属性值。方案设计实现好后，查找一个对象的关联对象的基本步骤：</p><ol><li>已知条件一：对象，因此引出第一个 HashMap（AssociationsHashMap），用一个能唯一代表对象的值作为 key，用存储对象的所有关联对象的结构（名字：值+策略）作为 value</li><li>已知条件二：属性名字，因此引出第二个 HashMap（ObjectAssociationMap），用属性名字作为key，用属性名字对应的结构体（值+策略）作为 value。</li></ol><p>参考资料：</p><p><a href="https://juejin.im/post/5af86b276fb9a07aa34a59e6" target="_blank" rel="noopener">iOS底层原理总结 - 关联对象实现原理</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fdraveness.me%2Fao" target="_blank" rel="noopener">关联对象 AssociatedObject 完全解析</a></p><h4 id="1-2-weak-的实现原理"><a href="#1-2-weak-的实现原理" class="headerlink" title="1.2 weak 的实现原理"></a>1.2 weak 的实现原理</h4><p>weak 采用的是一个全局的 HashMap 嵌套数组的结构存储数据的，销毁对象（weak 指针指向的对象）的时候，根据对象从 HashMap 中找到存放所有指向该对象的 weak 指针的数组，然后将数组中的所有元素都置为 nil。</p><p>weak 的最大特点就是在对象销毁时，自动置 nil，减少访问野指针的风险，这也是设计 weak 的初衷。方案设计实现好后，weak 指针置 nil 的基本步骤：</p><ol><li>对象 dealloc 的时候，从全局的 HashMap 中，根据一个唯一代表对象的值作为 key，找到存储所有指向该对象的 weak 指针的数组；</li><li>将数组中的所有元素都置为 nil。</li></ol><p>参考资料：</p><p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cocoachina.com%2Fios%2F20170328%2F18962.html" target="_blank" rel="noopener">iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）</a><br><a href="https://juejin.im/post/5a3081316fb9a0450a67537e" target="_blank" rel="noopener">weak实现原理</a></p><h4 id="1-3-KVO-实现使用的基本数据结构"><a href="#1-3-KVO-实现使用的基本数据结构" class="headerlink" title="1.3 KVO 实现使用的基本数据结构"></a>1.3 KVO 实现使用的基本数据结构</h4><p>一个对象可以被 n 个对象观察，一对象的 n 个属性又可以分别被 n 个对象观察。</p><p>详细参考： <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd6e4ba25acd2" target="_blank" rel="noopener">GNUstep KVC/KVO探索（二）：KVO的内部实现</a></p><h4 id="1-4-iOS-App-签名的原理"><a href="#1-4-iOS-App-签名的原理" class="headerlink" title="1.4 iOS App 签名的原理"></a>1.4 iOS App 签名的原理</h4><p>一致性哈希算法 + 非对称加解密算法。</p><p>详细参考：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwereadteam.github.io%2F2017%2F03%2F13%2FSignature%2F" target="_blank" rel="noopener">iOS App 签名的原理</a></p><h4 id="1-5-对象的引用计数存储的位置"><a href="#1-5-对象的引用计数存储的位置" class="headerlink" title="1.5 对象的引用计数存储的位置"></a>1.5 对象的引用计数存储的位置</h4><p>具体参考 ：<a href="https://juejin.im/post/5b4c59a55188251ac9767872#comment" target="_blank" rel="noopener">苹果iOS系统源码思考：对象的引用计数存储在哪里？–从runtime源码得到的启示</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 对象支持TaggedPointer &#123;</span><br><span class="line"><span class="keyword">return</span> 直接将对象的指针值作为引用计数返回</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> 设备是<span class="number">64</span>位环境 &amp;&amp; Objective-C2.0 &#123;</span><br><span class="line"><span class="keyword">return</span> 对象isa指针的一部分空间(bits_extra_rc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hash表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-Runloop-与线程的存储关系"><a href="#1-6-Runloop-与线程的存储关系" class="headerlink" title="1.6 Runloop 与线程的存储关系"></a>1.6 Runloop 与线程的存储关系</h4><p>线程和 RunLoop 之间是一一（子线程可以没有）对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p><h4 id="1-7-NSDictionary的原理"><a href="#1-7-NSDictionary的原理" class="headerlink" title="1.7 NSDictionary的原理"></a>1.7 NSDictionary的原理</h4><p>参考文章：<a href="https://juejin.im/post/5c510617f265da613f2fdac4" target="_blank" rel="noopener">笔记-集合NSSet、字典NSDictionary的底层实现原理</a></p><h2 id="二、哈希表"><a href="#二、哈希表" class="headerlink" title="二、哈希表"></a>二、哈希表</h2><h4 id="2-1-哈希表定义"><a href="#2-1-哈希表定义" class="headerlink" title="2.1 哈希表定义"></a>2.1 哈希表定义</h4><p>哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。</p><p>哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。根据下标 index 从数组中取 value。关键是如何获取 index，这就需要一个固定的函数（哈希函数），将 key 转换成 index。不论哈希函数设计的如何完美，都可能出现不同的 key 经过 hash 处理后得到相同的 hash 值，这时候就需要处理哈希冲突。</p><h4 id="2-2-哈希表优缺点"><a href="#2-2-哈希表优缺点" class="headerlink" title="2.2 哈希表优缺点"></a>2.2 哈希表优缺点</h4><p>优点</p><ul><li>哈希表可以提供快速的操作。</li></ul><p>缺点</p><ul><li>哈希表通常是基于数组的，数组创建后难于扩展。</li><li>没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。</li></ul><p>综上，如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。</p><h4 id="2-3-哈希查找步骤"><a href="#2-3-哈希查找步骤" class="headerlink" title="2.3 哈希查找步骤"></a>2.3 哈希查找步骤</h4><ol><li>使用哈希函数将被查找的键映射（转换）为数组的索引，理想情况下（hash 函数设计合理）不同的键映射的数组下标也不同，所有的查找时间复杂度为 O(1)。但是实际情况下不是这样的，所以哈希查找的第二步就是处理哈希冲突。</li><li>处理哈希碰撞冲突。处理方法有很多，比如拉链法、线性探测法。</li></ol><h4 id="2-4-哈希表存储过程："><a href="#2-4-哈希表存储过程：" class="headerlink" title="2.4 哈希表存储过程："></a>2.4 哈希表存储过程：</h4><ol><li>使用 hash 函数根据 key 得到哈希值 h</li><li>如果箱子的个数为 n，那么值应该存放在底(h%n)个箱子中。h%n 的值范围为 [0, n-1]。</li><li>如果该箱子非空（已经存放了一个值）即不同的 key 得到了相同的h产生了哈希冲突，此时需要使用拉链法或者开放定址线性探测法解决冲突。</li></ol><h4 id="2-5-常用哈希函数"><a href="#2-5-常用哈希函数" class="headerlink" title="2.5 常用哈希函数"></a>2.5 常用哈希函数</h4><p>哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存 0~M 数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为 key 更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。</p><p>在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。</p><ol><li>直接寻址法</li><li>数字分析法</li><li>平方取中法</li><li>折叠法</li><li>随机数法</li><li>除留余数法</li></ol><p>要想设计一个优秀的哈希算法并不容易，根据经验，总结了需要满足的几点要求：</p><ol><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ol><h4 id="2-6-负载因子"><a href="#2-6-负载因子" class="headerlink" title="2.6 负载因子"></a>2.6 负载因子</h4><blockquote><p>负载因子 = 总键值对数/数组的个数</p></blockquote><p>负载因子是哈希表的一个重要属性，用来衡量哈希表的空/满程度，一定程度也可以提现查询的效率。负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。所以当负载因子大于某个常数（一般是<font color="#cc0000">0.75</font>）时，哈希表将自动扩容。哈希表扩容时，一般会创建<font color="#cc0000">两倍</font>于原来的数组长度。因此即使 key 的哈希值没有变化，对数组个数取余的结果会随着数组个数的扩容发生变化，因此键值对的位置都有可能发生变化，这个过程也成为重哈希（rehash）。</p><h4 id="2-7-哈希表扩容"><a href="#2-7-哈希表扩容" class="headerlink" title="2.7 哈希表扩容"></a>2.7 哈希表扩容</h4><ul><li>在数组比较多的时候，需要重新哈希并移动数据，性能影响较大。</li><li>虽然能够使负载因子降低，但并不总是能有效提高哈希表的查询性能。比如哈希函数设计的不合理，导致所有的 key 计算出的哈希值都相同，那么即使扩容他们的位置还是在同一条链表上，变成了线性表，性能极低，查询的时候时间复杂度就变成了 O(n)。</li></ul><h4 id="2-8-哈希冲突的解决方法"><a href="#2-8-哈希冲突的解决方法" class="headerlink" title="2.8 哈希冲突的解决方法"></a>2.8 哈希冲突的解决方法</h4><ol><li><p>拉链法</p><p> 简单来说就是数组 + 链表。将键通过 hash 函数映射为大小为 M 的数组的下标索引，数组的每一个元素指向一个链表，链表中的每一个结点存储着 hash 出来的索引值为结点下标的键值对。</p><p> Java 8 解决哈希冲突采用的就是拉链法。在处理哈希函数设计不合理导致链表很长时（<font color="#cc0000">链表长度超过 8 切换为红黑树，小于 6 重新退化为链表</font>）。将链表切换为红黑树能够保证插入和查找的效率，缺点是当哈希表比较大时，哈希表扩容会导致瞬时效率降低。</p><p> Redis 解决哈希冲突采用的也是拉链法。通过增量式扩容解决了 Java 8 中的瞬时扩容导致的瞬时效率降低的缺点，同时拉链法的实现方式（新插入的键值对放在链表头部）带来了两个好处：</p><ul><li>头插法可以节省插入耗时。如果插到尾部，则需要时间复杂度为 O(n) 的操作找到链表尾部，或者需要额外的内存地址来保存尾部链表的位置。</li><li>头插法可以节省查找耗时。对于一个数据系统来说，最新插入的数据往往可能频繁的被查询。</li></ul></li></ol><ol start="2"><li><p>开放定址线性探测法</p><p> 使用两个大小为 N 的数组（一个存放 keys，另一个存放 values）。使用数组中的空位解决碰撞，当碰撞发生时（即一个键的 hash 值对应数组的下标被两外一个键占用）直接将下标索引加一（index += 1），这样会出现三种结果：</p><ul><li>未命中（数组下标中的值为空，没有占用）。keys[index] = key，values[index] = value。</li><li>命中（数组下标中的值不为空，占用）。keys[index] == key，values[index] == value。</li><li>命中（数组下标中的值不为空，占用）。keys[index] != key，继续 index += 1，直到遇到结果 1 或 2 停止。</li></ul></li><li><p>拉链法的优点</p><p> 与开放定址线性探测发相比，拉链法有如下几个优点：</p><ul><li>拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</li><li>由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</li><li>开放定址线性探测法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</li><li>在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放定址线性探测发构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放定址线性探测发中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放定址线性探测发处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</li></ul></li><li><p>拉链法的缺点</p><ul><li>指针需要额外的空间，故当结点规模较小时，开放定址线性探测发较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址线性探测发中的冲突，从而提高平均查找速度。</li></ul></li><li><p>开放定址线性探测法缺点</p><ul><li>容易产生堆积问题；</li><li>不适于大规模的数据存储；</li><li>散列函数的设计对冲突会有很大的影响；</li><li>插入时可能会出现多次冲突的现象，删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂；</li><li>结点规模很大时会浪费很多空间；</li></ul></li></ol><h4 id="2-9-Hash-表的平均查找长度"><a href="#2-9-Hash-表的平均查找长度" class="headerlink" title="2.9 Hash 表的平均查找长度"></a>2.9 Hash 表的平均查找长度</h4><p>Hash 表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。</p><p>查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数；</p><p>查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，再除以表长即为查找不成功时的平均查找长度。</p><p>例子：</p><blockquote><p>给定一组数据{32，14，23，01，42，20，45，27，55，24，10，53}，假设散列表的长度为 13（最接近 n 的质数），散列函数为 H(k) = k。分别画出用 线性探测法 和 拉链法 解决冲突时构造的哈希表，并求出在等概率下情况，这两种方法查找成功和查找不成功的平均查找长度。</p></blockquote><ol><li><p>拉链法</p> <center><br> <img src="http://dzliving.com/Hash_4.png" alt><br> </center><p> 查找成功时的平均查找长度：ASL = (1*6 + 2*4 + 3*1 + 4*1)/12 = 7/4</p><p> 查找不成功时的平均查找长度：ASL = (4 + 2 + 2 + 1 + 2 + 1)/13</p></li><li><p>线性探测法</p><p> 查找成功时查找次数 = 插入元素时的比较次数，查找成功的平均查找长度：ASL = (1 + 2 + 1 + 4 + 3 + 1 + 1 + 1 + 3 + 9 + 1 + 1 + 3)/12 = 2.5</p><p> 查找不成功时的查找次数 = 第 n 个位置不成功时的比较次数为，第 n 个位置到第 1 个没有数据位置的距离：如第 0 个位置取值为 1，第 1个位置取值为 2。查找不成功时的平均查找长度：ASL = （ 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12/13 = 91/13</p></li></ol><h4 id="2-10-NSDictionary"><a href="#2-10-NSDictionary" class="headerlink" title="2.10 NSDictionary"></a>2.10 NSDictionary</h4><ol><li><p>版本一</p><blockquote><p>是使用 NSMapTable 实现的，采用拉链法解决哈希冲突。</p></blockquote> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="built_in">NSMapTable</span>        *table;</span><br><span class="line">   <span class="built_in">NSInteger</span>          i;</span><br><span class="line">   <span class="keyword">struct</span> _NSMapNode *j;</span><br><span class="line">&#125; <span class="built_in">NSMapEnumerator</span>;</span><br></pre></td></tr></table></figure></li></ol><pre><code>上述结构体描述了遍历一个 NSMapTable 时的一个指针对象，其中包含 table 对象自身的指针，计数值，和节点指针。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="built_in">NSUInteger</span> (*hash)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">   <span class="built_in">BOOL</span> (*isEqual)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">   <span class="keyword">void</span> (*<span class="keyword">retain</span>)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">   <span class="keyword">void</span> (*release)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">void</span> *);</span><br><span class="line">   <span class="built_in">NSString</span>  *(*describe)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">void</span> *notAKeyMarker;</span><br><span class="line">&#125; <span class="built_in">NSMapTableKeyCallBacks</span>;</span><br></pre></td></tr></table></figure>上述结构体中存放的是几个函数指针，用于计算 key 的 hash 值，判断 key 是否相等，retain，release 操作。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="keyword">void</span>       (*<span class="keyword">retain</span>)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">   <span class="keyword">void</span>       (*release)(<span class="built_in">NSMapTable</span> *table,<span class="keyword">void</span> *);</span><br><span class="line">   <span class="built_in">NSString</span>  *(*describe)(<span class="built_in">NSMapTable</span> *table, <span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">&#125; <span class="built_in">NSMapTableValueCallBacks</span>;</span><br></pre></td></tr></table></figure>上述存放的三个函数指针，定义在对 NSMapTable 插入一对 key、value 时，对 value 对象的操作。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMapTable</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">   <span class="built_in">NSMapTableKeyCallBacks</span>   *keyCallBacks;</span><br><span class="line">   <span class="built_in">NSMapTableValueCallBacks</span> *valueCallBacks;</span><br><span class="line">   <span class="built_in">NSUInteger</span>             count;</span><br><span class="line">   <span class="built_in">NSUInteger</span>             nBuckets;</span><br><span class="line">   <span class="keyword">struct</span> _NSMapNode  **buckets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从上面的结构真的能看出 NSMapTable 是一个 哈希表 + 链表 的数据结构吗？在 NSMapTbale 中插入或者删除一个对象的寻找时间 = O(1) + O(m) ，m 为最坏时可能为 n。O(1)：对 key 进行 hash 得到 bucket 的位置O(m)：不同的 key 得到相同的 hash 值的 value 存放到链表中，遍历链表的时间上面的结论和对应的解释似乎很合理？看看下面的分析再说也不迟！</code></pre><ol start="2"><li><p>版本二</p><blockquote><p>是对 _CFDictionary 的封装，解决哈希冲突使用的是开放定址线性探测法</p></blockquote> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct __CFDictionary &#123;</span><br><span class="line">    CFRuntimeBase _base<span class="comment">;</span></span><br><span class="line">    CFIndex _<span class="built_in">count</span><span class="comment">;</span></span><br><span class="line">    CFIndex _capacity<span class="comment">;</span></span><br><span class="line">    CFIndex _bucketsNum<span class="comment">;</span></span><br><span class="line">    uintptr_t _marker<span class="comment">;</span></span><br><span class="line">    void *_<span class="built_in">context</span><span class="comment">;</span></span><br><span class="line">    CFIndex _deletes<span class="comment">;</span></span><br><span class="line">    CFOptionFlags _xflags<span class="comment">;</span></span><br><span class="line">    const void **_keys<span class="comment">;</span></span><br><span class="line">    const void **_values<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p> 从上面的数据结构可以看出 NSDictionary 内部使用了两个指针数组分别保存 keys 和 values。采用的是连续方式存储键值对。拉链法会将 key 和 value 包装成一个结果存储（链表结点），而 Dictionary 的结构拥有 keys 和 values 两个数组（开放寻址线性探测法解决哈希冲突的用的就是两个数组），说明两个数据是被分开存储的，不像是拉链法。</p><p> NSDictionary 使用开放定址线性探测法解决哈希冲突的原理：</p><p> 可以看到，NSDictionary 设置的 key 和 value，key 值会根据特定的 hash 函数算出建立的空桶数组，keys 和 values 同样多，然后存储数据的时候，根据 hash 函数算出来的值，找到对应的 index 下标，如果下标已有数据，开放定址法后移动插入，如果空桶数组到达数据阀值，这个时候就会把空桶数组扩容，然后重新哈希插入。</p><p> 这样把一些不连续的 key-value 值插入到了能建立起关系的 hash 表中，当我们查找的时候，key 根据哈希算法算出来索引，然后根据索引，直接 index 访问 hash 表 keys 和 hash 表 values，这样查询速度就可以和连续线性存储的数据一样接近 O(1) 了，只是占用空间有点大，性能就很强悍。</p><p> 如果删除的时候，也会根据 _maker 标记逻辑上的删除，除非 NSDictionary（NSDictionary 本体的hash 值就是 count）内存被移除。</p><p> NSDictionary 之所以采用这种设计：</p><ol><li>出于查询性能的考虑；</li><li>NSDictionary 在使用过程中总是会很快的被释放，不会长期占用内存;</li></ol></li></ol><h4 id="2-11-Apple方案选择"><a href="#2-11-Apple方案选择" class="headerlink" title="2.11 Apple方案选择"></a>2.11 Apple方案选择</h4><p>解决哈希冲突的拉链法和开放定址线性探测法，Apple 都是用了。具体使用哪一种是根据存储数据的生命周期和特性决定的。</p><ul><li><p>@synchronized 使用的是拉链法。拉链法多用于存储的数据是通用类型，能够被反复利用，就像@synchronized 存储的是锁是一种无关业务的实现结构，程序运行时多个对象使用同一个锁的概率相当高，有效的节省了内存。</p></li><li><p>weak 对象 associatedObject 采用的是开放定址线性探测法。开放定址线性探测法用于存储的数据是临时的，用完尽快释放，就像 associatedObject，weak。</p></li></ul><h4 id="2-12-NSDictionary-的存储过程"><a href="#2-12-NSDictionary-的存储过程" class="headerlink" title="2.12 NSDictionary 的存储过程"></a>2.12 NSDictionary 的存储过程</h4><p><a href="https://juejin.im/post/5bf4269df265da6134380660" target="_blank" rel="noopener">iOS笔记：进一步认识 ==、isEqual、hash</a></p><ol><li>通过方法 <code>- (void)setObject:(id)anObject forKey:(id)aKey;</code> 可以看出key必须遵循 NSCopy 协议，也就是说 NSDictionary 的 key 是 copy 一份新的，而 value 是浅拷贝的（如果想深拷贝可以使用 NSMapTable）。</li><li>key 还必须要继承 NSObject，并且重写 <code>-(NSUInteger)hash;</code> 和 <code>-(BOOL)isEqual:(id)object;</code> 两个方法。第一个函数用于计算 hash 值，第二个函数用来判断当哈希值相同的时候 value 是否相同（解决哈希冲突）。</li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fyangecnu%2Fp%2FIntroduce-Hashtable.html" target="_blank" rel="noopener">浅谈算法和数据结构: 十一 哈希表</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2FDeft_MKJing%2Farticle%2Fdetails%2F82732833" target="_blank" rel="noopener">NSDictionary和NSMutableArray底层原理（哈希表和环形缓冲区）</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fbestswifter.com%2Fdictionary-implemation%2F" target="_blank" rel="noopener">Swift中字典的实现原理</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fbestswifter.com%2Fhashtable%2F" target="_blank" rel="noopener">深入理解哈希表</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fhuyangjie.com%2F2017%2F04%2F20%2F%25E8%25A7%25A3%25E8%25AF%25BBObjective-C%25E7%259A%2584NSDictionary%2F" target="_blank" rel="noopener">解读Objective-C的NSDictionary</a><br><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cocoachina.com%2Fios%2F20180723%2F24267.html" target="_blank" rel="noopener">iOS重做轮子，写一个NSDictionary（一）</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2Fu011080472%2Farticle%2Fdetails%2F51177412" target="_blank" rel="noopener">哈希表——线性探测法、链地址法、查找成功、查找不成功的平均长度</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F5d933fc6df3b" target="_blank" rel="noopener">哈希表、哈希算法、一致性哈希表</a><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fef3f77c8b320" target="_blank" rel="noopener">细说@synchronized和dispatch_once</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、iOS-hash&quot;&gt;&lt;a href=&quot;#一、iOS-hash&quot; class=&quot;headerlink&quot; title=&quot;一、iOS hash&quot;&gt;&lt;/a&gt;一、iOS hash&lt;/h2&gt;&lt;p&gt;下图列出 Hash 在 iOS 中的应用分析整理&lt;/p&gt;
&lt;center&gt;&lt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>isEqual</title>
    <link href="http://yoursite.com/2019/10/30/iOS/iOS%E5%8E%9F%E7%90%86/hash%E3%80%81isEqual/"/>
    <id>http://yoursite.com/2019/10/30/iOS/iOS原理/hash、isEqual/</id>
    <published>2019-10-30T03:13:20.133Z</published>
    <updated>2019-10-30T03:45:32.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何重写-hash-方法"><a href="#如何重写-hash-方法" class="headerlink" title="如何重写 hash 方法"></a>如何重写 hash 方法</h2><p>一个合理的 hash 方法要尽量让 hash 表中的元素均匀分布，来保证较高的查询性能。</p><p>如果两个对象可以被视为同一个对象，那么他们的 hash 值要一样。</p><p>mattt 在文章 <a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a> 中给出了一个普遍的算法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)<span class="built_in">hash</span> </span><br><span class="line">&#123;</span><br><span class="line">// 假设对象有三个属性，那么对这三个属性分别算出 <span class="built_in">hash</span> 值，然后进行异或运算</span><br><span class="line">    <span class="built_in">return</span> [self.property1 <span class="built_in">hash</span>] ^ [self.property2 <span class="built_in">hash</span>] ^ [self.property3 <span class="built_in">hash</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instagram 在开源 IGListKit 的同时，鼓励这么写 hash 方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">NSUInteger subhashes[] = &#123;[self.property1 hash], [self.property2 hash], [self.property3 hash]&#125;;</span><br><span class="line"></span><br><span class="line">NSUInteger result = subhashes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt; <span class="number">3</span>; ++ii) &#123;</span><br><span class="line">unsigned <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">base</span> = (((unsigned <span class="keyword">long</span> <span class="keyword">long</span>)result) &lt;&lt; <span class="number">32</span> | subhashes[ii]);</span><br><span class="line"><span class="keyword">base</span> = (~<span class="keyword">base</span>) + (<span class="keyword">base</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">base</span> *=  <span class="number">21</span>;</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">11</span>);</span><br><span class="line"><span class="keyword">base</span> += (<span class="keyword">base</span> &lt;&lt; <span class="number">6</span>);</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">22</span>);</span><br><span class="line">result = <span class="keyword">base</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> * birthday;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (![object isKindOfClass:[Person <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(Person *)object];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">BOOL</span>)isEqualToPerson:(Person *)person &#123;</span><br><span class="line">    <span class="keyword">if</span> (!person) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">BOOL</span> haveEqualNames = (!<span class="keyword">self</span>.name &amp;&amp; !person.name) || [<span class="keyword">self</span>.name isEqualToString:person.name];</span><br><span class="line">    <span class="built_in">BOOL</span> haveEqualBirthdays = (!<span class="keyword">self</span>.birthday &amp;&amp; !person.birthday) || [<span class="keyword">self</span>.birthday isEqualToDate:person.birthday];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> haveEqualNames &amp;&amp; haveEqualBirthdays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>== 运算符判断是否是同一对象, 因为同一对象必然完全相同</li><li>判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险</li><li>通过封装的 isEqualToPerson: 方法, 提高代码复用性</li><li>判断 person 是否是 nil，做参数有效性检查</li><li>对各个属性分别使用默认判等方法进行判断</li><li>返回所有属性判等的与结果</li></ol><h2 id="重写-isEqual"><a href="#重写-isEqual" class="headerlink" title="重写 isEqual"></a>重写 isEqual</h2><blockquote><p>如何写一个合理高效的判等方法？</p></blockquote><ol><li>首先对内存地址进行判断，地址相等 return YES;</li><li>进行判空处理，self == nil || object == nil ，return NO;</li><li>类型判断，![object isKindOfClass:[self class]] , return NO;</li><li>对对象的其他属性进行判断</li></ol><p>根据这四个步骤，我们可以发现，我们都是先判断时间开销最少的属性。所以对于第 4 个步骤，如果对象有很多属性，我们也要依照这个原则来！</p><p>比如 [self.array isEqual:other.array] &amp;&amp; self.intVal == other.intVal 这种写法是不合理的，因为 array 的判等会去遍历元素，时间开销大。如果 intVal 不相等的话就可以直接 return NO了，没必要进行数组的判等。应该这么写：self.intVal == other.intVal &amp;&amp; [self.array isEqual:other.array]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)isEqual:(<span class="type">PersonModel</span> *)<span class="class"><span class="keyword">object</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self == <span class="class"><span class="keyword">object</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (self == nil || <span class="class"><span class="keyword">object</span> <span class="title">==</span> <span class="title">nil</span> <span class="title">||</span> <span class="title">!</span>[object isKindOfClass:[self class]]) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    (_property1 == <span class="class"><span class="keyword">object</span><span class="title">-&gt;_property1</span> <span class="title">?</span> <span class="title">YES</span> </span>: [_property1 isEqual:<span class="class"><span class="keyword">object</span><span class="title">-&gt;_property1</span>]) <span class="title">&amp;&amp;</span></span></span><br><span class="line"><span class="class">    (<span class="params">_property2 == object-&gt;_property2 ? <span class="type">YES</span> : [_property2 isEqual:object-&gt;_property2]</span>) <span class="title">&amp;&amp;</span></span></span><br><span class="line"><span class="class">    (<span class="params">_property3 == object-&gt;_property3 ? <span class="type">YES</span> : [_property3 isEqual:object-&gt;_property3]</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash-与判等的关系"><a href="#hash-与判等的关系" class="headerlink" title="hash 与判等的关系"></a>hash 与判等的关系</h2><p>hash 方法主要是用于在 Hash Table 查询成员用的, 那么与 isEqual() 有什么关系呢?</p><p>为了优化判等的效率，基于 hash 的 NSSet 和 NSDictionary 在判断成员是否相等时，会这样做：</p><ol><li>集成成员的 hash 值是否和目标 hash 值相等, 如果相同进入下一步，如果不等，直接判断不相等；</li><li>hash 值相同的情况下，再进行对象判等，作为判等的结果</li></ol><p>简单地说就是</p><blockquote><p>hash值是对象判等的必要非充分条件</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何重写-hash-方法&quot;&gt;&lt;a href=&quot;#如何重写-hash-方法&quot; class=&quot;headerlink&quot; title=&quot;如何重写 hash 方法&quot;&gt;&lt;/a&gt;如何重写 hash 方法&lt;/h2&gt;&lt;p&gt;一个合理的 hash 方法要尽量让 hash 表中的元素均匀
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash</title>
    <link href="http://yoursite.com/2019/10/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Hash/"/>
    <id>http://yoursite.com/2019/10/30/数据结构/Hash/</id>
    <published>2019-10-30T02:00:51.603Z</published>
    <updated>2019-10-30T03:09:33.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是-Hash-表"><a href="#一、什么是-Hash-表" class="headerlink" title="一、什么是 Hash 表"></a>一、什么是 Hash 表</h2><p>先看一下 hash 表的结构图：</p><center><br><img src="http://dzliving.com/Hash_0.png" alt="数组 + 链表"><br></center><p>哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">num</span> = hash(key);      // 把 Key 通过一个固定的算法函数（hash 函数）转换成一个整型数字</span><br><span class="line"><span class="attr">num2</span> = num MOD n;     // 用该数字对数组的长度进行取余</span><br><span class="line"><span class="attr">array[num2]</span> = value;  // 取余结果就当作数组的下标，将 value 存储在数组的该下标处</span><br></pre></td></tr></table></figure><p>当使用 hash 表查询时，就是使用 hash 函数将 <font color="#cc0000">key</font> 转换成对应的数组下标，并定位到该下标的数组空间里获取 value，这样就充分利用到数组的定位性能进行数据定位。</p><blockquote><p>index = F(key)</p></blockquote><p>hash 函数就是根据 key 计算出该存储地址的位置，hash 表就是基于 hash 函数建立的一种查找表。</p><h2 id="二、Hash函数的构造方法"><a href="#二、Hash函数的构造方法" class="headerlink" title="二、Hash函数的构造方法"></a>二、Hash函数的构造方法</h2><ol><li><p>方法</p><p> 方法有很多种，比如直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。</p></li><li><p>hash函数设计的考虑因素</p><ul><li>计算 hash 地址所需时间</li><li>关键字的长度</li><li>表长</li><li>关键字分布是否均匀，是否有规律可循</li><li>尽量减少冲突</li></ul></li></ol><h2 id="三、hash冲突"><a href="#三、hash冲突" class="headerlink" title="三、hash冲突"></a>三、hash冲突</h2><h4 id="3-1-什么是-hash-冲突"><a href="#3-1-什么是-hash-冲突" class="headerlink" title="3.1 什么是 hash 冲突"></a>3.1 什么是 hash 冲突</h4><p>对不同的关键字可能得到同一散列地址，即 <strong>k1≠k2</strong>，而 <strong>f(k1)=f(k2)</strong>，或 <strong>f(k1) MOD 容量 = f(k2) MOD 容量</strong>，这种现象称为碰撞，亦称冲突。</p><p>通过构造性能良好的 hash 函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是 hash 表的另一个关键问题。</p><p>创建和查找 hash 表都会遇到冲突，两种情况下解决冲突的方法应该一致。</p><h4 id="3-2-解决-hash-冲突"><a href="#3-2-解决-hash-冲突" class="headerlink" title="3.2 解决 hash 冲突"></a>3.2 解决 hash 冲突</h4><ol><li><p>开放定址法</p><p> 也称再散列法，基本思想是：</p><blockquote><p>当关键字 key 的 hash 地址 p = F(key) 出现冲突时，以 p 为基础，产生另一个 hash 地址 p1，如果 p1 仍然冲突，再以 p 为基础，再产生另一个 hash 地址 p2。。。直到找出一个不冲突的 hash 地址 pi，然后将元素存入其中。</p></blockquote><p> 通用的再散列函数的形式：</p><blockquote><p>H = (F(key) + di) MOD m</p></blockquote><ul><li>i = 1，2，。。。，m-1 为碰撞次数</li><li>m 为表长</li><li>F(key) 为 hash 函数。</li><li><p>di 为增量序列，增量序列的取值方式不同，相应的再散列方式也不同。</p><p>1）线性探测再散列</p><blockquote><p>di = 1，2，3，。。。，m-1</p></blockquote><p>冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p><p>2）二次探测再散列</p><blockquote><p>di = 1<sup>2</sup>，-1<sup>2</sup>，2<sup>2</sup>，-2<sup>2</sup>，…，k<sup>2</sup>，-k<sup>2</sup>    (k &lt;= m-1)</p></blockquote><p>发生冲突时，在表的左右进行跳跃式探测，比较灵活。</p><p>3）伪随机数探测再散列</p><blockquote><p>di = 伪随机序列</p></blockquote><p>下面有个网上的示例：</p><p>现有一个长度为 11 的哈希表，已填有关键字分别为 17，60，29 的三条记录。其中采用的哈希函数为 <code>f(key)= key MOD 11</code>。现有第四个记录，关键字为 38。根据以上哈希算法，得出哈希地址为 5，跟关键字 60 的哈希地址一样，产生了冲突。根据增量 d 的取法的不同，有以下三种场景：</p><center><br><img src="http://dzliving.com/Hash_1.png" alt><br></center><p>线性探测法：当发生冲突时，因为 f(key) + d，所以首先 5 + 1 = 6，得到下一个 hash 地址为 6，又冲突，依次类推，最后得到空闲的 hash 地址是 8，然后将数据填入 hash 地址为 8 的空闲区域。</p><p>二次探测法：当发生冲突时，因为 d = 1<sup>2</sup>，所以 5 + 1 = 6，得到的下一个 hash 地址为 6，又冲突，因为 d = -1<sup>2</sup>,所以 5 + (-1) = 4，得到下一个 hash 地址为 4，是空闲则将数据填入该区域。</p><p>伪随机数探测法：随机数法就是完全根据伪随机序列来决定的，如果根据一个随机数种子得到一个伪随机序列 {1，-2，2，。。。，k}，那么首先得到的地址为 6，第二个是 3，依次类推，空闲则将数据填入。</p><p>开放定址法在 iOS 中的应用还是有很多的，具体可参考<a href="https://juejin.im/post/5c510617f265da613f2fdac4" target="_blank" rel="noopener">笔记-集合 NSSet、字典NSDictionary的底层实现原理</a></p></li></ul></li><li><p>链地址法（拉链法，位桶法）</p><p> 将产生冲突的关键字的数据存储在冲突 hash 地址的一个线性链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。</p> <center><br> <img src="http://dzliving.com/Hash_2.png" alt><br> </center></li></ol><h2 id="四、负载因子（load-factor）"><a href="#四、负载因子（load-factor）" class="headerlink" title="四、负载因子（load factor）"></a>四、负载因子（load factor）</h2><p>这里要提到两个参数：初始容量，加载因子，这两个参数是影响 hash 表性能的重要参数。</p><ul><li>容量：表示 hash 表中数组的长度，初始容量是创建 hash 表时的容量。</li><li>加载因子：是 hash 表在其容量自动增加之前可以达到多满的一种尺度（存储元素的个数），它衡量的是一个散列表的空间的使用程度。</li></ul><blockquote><p>loadFactor = 加载因子 / 容量</p></blockquote><p>一般情况下，当 loadFactor &lt;= 1 时，hash 表查找的期望复杂度为 O(1)。</p><p>对使用链表法的散列表来说，<strong>负载因子越大，对空间的利用更充分，然后后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为 0.75</strong>。</p><h2 id="五、扩容"><a href="#五、扩容" class="headerlink" title="五、扩容"></a>五、扩容</h2><p>当 hash 表中元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对数组进行扩容。而在数组扩容之后，最消耗性能的点就出现了，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是扩容。</p><blockquote><p>什么时候进行扩容呢？</p></blockquote><p>当表中元素个数超过了<code>容量 * loadFactor</code>时，就会进行数组扩容。</p><p>用 OC 粗略的实现了一下扩容的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)resizeOfNewCapacity:(<span class="built_in">NSInteger</span>)newCapacity </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> oldCapacity = _elementArray.count;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_CAPACITY) &#123;         <span class="comment">// 扩容前的数组大小如果已经达到最大2^30</span></span><br><span class="line">        _threshold = oldCapacity - <span class="number">1</span>;       <span class="comment">// 修改阈值为int的最大值（2^30 - 1），这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个新的数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:newCapacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newCapacity; i ++) &#123;</span><br><span class="line">        [newArray addObject:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> transferWithNewTable:newArray];            <span class="comment">// 将数据转移到新的数组里</span></span><br><span class="line">    [_elementArray removeAllObjects];</span><br><span class="line">    [_elementArray addObjectsFromArray:newArray];    <span class="comment">// hash表的数组引用新建的数组</span></span><br><span class="line">    _threshold = (<span class="built_in">NSInteger</span>)_capacity * _loadFactor; <span class="comment">// 修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)transferWithNewTable:(<span class="built_in">NSMutableArray</span> *)array </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历旧数组，将元素转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elementArray.count; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[[_elementArray objectAtIndex:i] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            SingleLinkedNode *node = _elementArray[i];</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    [<span class="keyword">self</span> insertElementToArrayWith:array andNode:node];</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (node != <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertElementToArrayWith:(<span class="built_in">NSMutableArray</span> *)array andNode:(SingleLinkedNode *)node </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> index = [node.key integerValue] % _capacity;                      <span class="comment">// 计算每个元素在新数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> (![[[array objectAtIndex:index] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [array replaceObjectAtIndex:index withObject:node];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        SingleLinkedNode *headNode = [array objectAtIndex:index];</span><br><span class="line">        <span class="keyword">while</span> (headNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            headNode = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接把元素插入</span></span><br><span class="line">        headNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重哈希   </p></blockquote><p>哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。</p><p>哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。</p><blockquote><p>哈希表的两个问题</p></blockquote><ol><li>如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。</li><li>如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。</li></ol><h2 id="六、如何重写-hash-方法"><a href="#六、如何重写-hash-方法" class="headerlink" title="六、如何重写 hash 方法"></a>六、如何重写 hash 方法</h2><p>一个合理的 hash 方法要尽量让 hash 表中的元素均匀分布，来保证较高的查询性能。</p><p>如果两个对象可以被视为同一个对象，那么他们的 hash 值要一样。</p><p>mattt 在文章 <a href="https://nshipster.com/equality/" target="_blank" rel="noopener">Equality</a> 中给出了一个普遍的算法:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)<span class="built_in">hash</span> </span><br><span class="line">&#123;</span><br><span class="line">// 假设对象有三个属性，那么对这三个属性分别算出 <span class="built_in">hash</span> 值，然后进行异或运算</span><br><span class="line">    <span class="built_in">return</span> [self.property1 <span class="built_in">hash</span>] ^ [self.property2 <span class="built_in">hash</span>] ^ [self.property3 <span class="built_in">hash</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Instagram 在开源 IGListKit 的同时，鼓励这么写 hash 方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">NSUInteger subhashes[] = &#123;[self.property1 hash], [self.property2 hash], [self.property3 hash]&#125;;</span><br><span class="line"></span><br><span class="line">NSUInteger result = subhashes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">1</span>; ii &lt; <span class="number">3</span>; ++ii) &#123;</span><br><span class="line">unsigned <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">base</span> = (((unsigned <span class="keyword">long</span> <span class="keyword">long</span>)result) &lt;&lt; <span class="number">32</span> | subhashes[ii]);</span><br><span class="line"><span class="keyword">base</span> = (~<span class="keyword">base</span>) + (<span class="keyword">base</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">base</span> *=  <span class="number">21</span>;</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">11</span>);</span><br><span class="line"><span class="keyword">base</span> += (<span class="keyword">base</span> &lt;&lt; <span class="number">6</span>);</span><br><span class="line"><span class="keyword">base</span> ^= (<span class="keyword">base</span> &gt;&gt; <span class="number">22</span>);</span><br><span class="line">result = <span class="keyword">base</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、OC语言的实现"><a href="#七、OC语言的实现" class="headerlink" title="七、OC语言的实现"></a>七、OC语言的实现</h2><p>构建 HashTable 对象</p><ol><li><p>HashTable.h文件</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">SingleLinkedNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HashTable</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *elementArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> capacity;       <span class="comment">// 容量  数组（hash表）长度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> modCount;       <span class="comment">// 计数器，计算put的元素个数（不包括重复的元素）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> threshold;          <span class="comment">// 阈值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> loadFactor;         <span class="comment">// 加载因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 初始化Hash表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param capacity 数组的长度</span></span><br><span class="line"><span class="comment"> @return hash表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSInteger</span>)capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 插入</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param newNode 存入的键值对newNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)insertElementByNode:(SingleLinkedNode *)newNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 查询</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param key key值</span></span><br><span class="line"><span class="comment"> @return 想要获取的value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)findElementByKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure></li><li><p>HashTable.m 文件：</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MAX_CAPACITY pow(2, 30)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"HashTable.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"SingleLinkedNode.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HashTable</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCapacity:(<span class="built_in">NSInteger</span>)capacity &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _capacity = capacity;</span><br><span class="line">        _loadFactor = <span class="number">0.75</span>;</span><br><span class="line">        _threshold = (<span class="built_in">NSInteger</span>) _loadFactor * _capacity;</span><br><span class="line">        _modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 直接初始化数组，这里为了方便理解hash，所以就直接给定capacity，java中默认是16</span></span><br><span class="line">        _elementArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i ++) &#123;</span><br><span class="line">            [_elementArray addObject:<span class="string">@""</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertElementByNode:(SingleLinkedNode *)newNode &#123;</span><br><span class="line">    <span class="keyword">if</span> (newNode.key.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (_threshold &lt; _modCount * _capacity) &#123;</span><br><span class="line">        _capacity *= <span class="number">2</span>;</span><br><span class="line">        [<span class="keyword">self</span> resizeOfNewCapacity:_capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算存储位置</span></span><br><span class="line">    <span class="built_in">NSInteger</span> keyValue = [newNode.key integerValue]; <span class="comment">// F(x) = x; 得到hash值</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = keyValue % _capacity;         <span class="comment">// hash值 MOD 容量 = 数组下标</span></span><br><span class="line">    </span><br><span class="line">    newNode.hashValue = keyValue;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果插入的区域是空闲的，则直接把数据存入该空间区域</span></span><br><span class="line">    <span class="keyword">if</span> (![[[_elementArray objectAtIndex:index] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [_elementArray replaceObjectAtIndex:index withObject:newNode];</span><br><span class="line">        _modCount++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发生冲突，通过链表法解决冲突</span></span><br><span class="line">        SingleLinkedNode *headNode = [_elementArray objectAtIndex:index];</span><br><span class="line">        <span class="keyword">while</span> (headNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 插入的key重复，则覆盖原来的元素</span></span><br><span class="line">            <span class="keyword">if</span> ([headNode.key isEqualToString:newNode.key]) &#123;</span><br><span class="line">                headNode.value = newNode.value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            headNode = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        _modCount++;</span><br><span class="line">        <span class="comment">// 直接把元素插入</span></span><br><span class="line">        headNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)findElementByKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算存储位置</span></span><br><span class="line">    <span class="built_in">NSInteger</span> keyValue = [key integerValue];</span><br><span class="line">    <span class="built_in">NSInteger</span> index = keyValue % _capacity;    <span class="comment">// hash函数keyValue % _capacity (0~9)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &gt;= _capacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![[[_elementArray objectAtIndex:index] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历链表，知道找到key值相等的node，然后返回value</span></span><br><span class="line">        SingleLinkedNode *headNode = [_elementArray objectAtIndex:index];</span><br><span class="line">        <span class="keyword">while</span> (headNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([headNode.key isEqualToString:key]) &#123;</span><br><span class="line">                <span class="keyword">return</span> headNode.value;</span><br><span class="line">            &#125;</span><br><span class="line">            headNode = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resizeOfNewCapacity:(<span class="built_in">NSInteger</span>)newCapacity &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> oldCapacity = _elementArray.count;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAX_CAPACITY) &#123;         <span class="comment">// 扩容前的数组大小如果已经达到最大2^30</span></span><br><span class="line">        _threshold = oldCapacity - <span class="number">1</span>;       <span class="comment">// 修改阈值为int的最大值（2^30 - 1），这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一个新的数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:newCapacity];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newCapacity; i ++) &#123;</span><br><span class="line">        [newArray addObject:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> transferWithNewTable:newArray];            <span class="comment">// 将数据转移到新的数组里</span></span><br><span class="line">    [_elementArray removeAllObjects];</span><br><span class="line">    [_elementArray addObjectsFromArray:newArray];    <span class="comment">// hash表的数组引用新建的数组</span></span><br><span class="line">    _threshold = (<span class="built_in">NSInteger</span>)_capacity * _loadFactor; <span class="comment">// 修改阈值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)transferWithNewTable:(<span class="built_in">NSMutableArray</span> *)array &#123;</span><br><span class="line">    <span class="comment">// 遍历旧数组，将元素转移到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _elementArray.count; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[[_elementArray objectAtIndex:i] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            SingleLinkedNode *node = _elementArray[i];</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    [<span class="keyword">self</span> insertElementToArrayWith:array andNode:node];</span><br><span class="line">                    node = node.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (node != <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertElementToArrayWith:(<span class="built_in">NSMutableArray</span> *)array andNode:(SingleLinkedNode *)node &#123;</span><br><span class="line"><span class="comment">//    下面这个方法没有成功的获取到新数组中的位置</span></span><br><span class="line"><span class="comment">//    NSInteger index = [self indexForHashValue:node.hashValue andNewCapacity:array.count];</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = [node.key integerValue] % _capacity;                      <span class="comment">// 计算每个元素在新数组中的位置</span></span><br><span class="line">    <span class="keyword">if</span> (![[[array objectAtIndex:index] <span class="keyword">class</span>] isEqual:[SingleLinkedNode <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        [array replaceObjectAtIndex:index withObject:node];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        SingleLinkedNode *headNode = [array objectAtIndex:index];</span><br><span class="line">        <span class="keyword">while</span> (headNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            headNode = headNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接把元素插入</span></span><br><span class="line">        headNode.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)indexForHashValue:(<span class="built_in">NSInteger</span>)hash andNewCapacity:(<span class="built_in">NSInteger</span>)newCapacity &#123;</span><br><span class="line">    <span class="keyword">return</span> hash &amp; (newCapacity - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li><li><p>SingleLinkedNode.h文件：</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SingleLinkedNode</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *value;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SingleLinkedNode *next;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> hashValue;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSString</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure></li><li><p>SingleLinkedNode.m 文件：</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"SingleLinkedNode.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SingleLinkedNode</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSString</span> *)value &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _key = key;</span><br><span class="line">        _value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://juejin.im/user/5b9b0ef16fb9a05d353c6418" target="_blank" rel="noopener">佐笾</a> - <a href="https://juejin.im/post/5c4e9c2af265da61561f9de8" target="_blank" rel="noopener">笔记-数据结构之 Hash（OC的粗略实现）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是-Hash-表&quot;&gt;&lt;a href=&quot;#一、什么是-Hash-表&quot; class=&quot;headerlink&quot; title=&quot;一、什么是 Hash 表&quot;&gt;&lt;/a&gt;一、什么是 Hash 表&lt;/h2&gt;&lt;p&gt;先看一下 hash 表的结构图：&lt;/p&gt;
&lt;center&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS Crash</title>
    <link href="http://yoursite.com/2019/10/29/iOS/iOS%E4%BC%98%E5%8C%96/iOS%20Crash/"/>
    <id>http://yoursite.com/2019/10/29/iOS/iOS优化/iOS Crash/</id>
    <published>2019-10-29T13:06:00.136Z</published>
    <updated>2019-10-29T13:06:27.725Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="noopener">Understanding and Analyzing Application Crash Reports</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION&quot; targe
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS继承</title>
    <link href="http://yoursite.com/2019/10/29/iOS/iOS%E5%8E%9F%E7%90%86/iOS%20%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2019/10/29/iOS/iOS原理/iOS 继承/</id>
    <published>2019-10-29T13:00:54.502Z</published>
    <updated>2019-11-04T13:44:50.840Z</updated>
    
    <content type="html"><![CDATA[<p>是否使用继承需要考虑三个点：</p><ol><li>父类只是给子类提供服务，并不涉及子类的业务逻辑</li><li>层级关系明显，功能划分清晰，父类和子类各做各的。</li><li>父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求</li></ol><blockquote><p>万不得已不要用继承，优先考虑组合等方式。</p></blockquote><ul><li><p>如果只是共享接口，我们可以使用<font color="#cc0000">协议</font>；</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> ptc &lt;NSObject&gt;</span><br><span class="line">- (void)do;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">A </span>: NSObject &lt;ptc&gt;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> A </span><br><span class="line"></span><br><span class="line">- (void)do</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">B </span>: NSObject &lt;ptc&gt;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> B</span><br><span class="line"></span><br><span class="line">- (void)do</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li><li><p>如果希望共用一个方法的部分实现，但希望根据需要执行不同的其他行为，我们可以使用<font color="#cc0000">代理</font>或者 <font color="#cc0000">AOP</font>；</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> ptc &lt;NSObject&gt;</span><br><span class="line">- (void)do;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">A </span>: NSObject </span><br><span class="line"><span class="variable">@property</span> (nonatomic, weak) id&lt;ptc&gt; delegate;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> A</span><br><span class="line"></span><br><span class="line">- (void)func</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[self.delegate do]</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">B </span>: NSObject &lt;ptc&gt;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> B</span><br><span class="line"></span><br><span class="line">- (void)do</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li><li><p>如果是添加方法，我们可以优先使用<font color="#cc0000">类别</font>；</p></li></ul><ul><li><p>如果是为了使用一个类的很多方法，我们可以使用<font color="#cc0000">组合</font>来实现。</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="string">A :</span> NSObject</span><br><span class="line">- (<span class="keyword">void</span>)methodA;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="string">B :</span> NSObject</span><br><span class="line">-(<span class="keyword">void</span>)methodB;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 C 以及其需要的 methodA，methodB</span></span><br><span class="line"><span class="meta">@interface</span> <span class="string">C :</span> NSObject </span><br><span class="line">&#123;</span><br><span class="line">A * __a;</span><br><span class="line">B * __b;</span><br><span class="line">&#125;</span><br><span class="line">- (id)<span class="string">initWithA:</span>(A *)a <span class="string">b:</span>(B *)b;</span><br><span class="line">- (<span class="keyword">void</span>)methodA;</span><br><span class="line">- (<span class="keyword">void</span>)methodB;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span>  ClassC</span><br><span class="line"></span><br><span class="line">- (id)<span class="string">initWithA:</span>(A *)a <span class="string">b:</span>(B *)b</span><br><span class="line">&#123;</span><br><span class="line">__a = [[A alloc] <span class="string">initWithA:</span>a];  <span class="comment">// [A copy];</span></span><br><span class="line">__b = [[B alloc] <span class="string">initWithB:</span>b];  <span class="comment">// [B copy];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodA</span><br><span class="line">&#123;</span><br><span class="line">[__a methodA];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodB</span><br><span class="line">&#123;</span><br><span class="line">[__b methodB];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure></li></ul><p>如果只是出于代码复用的目的而不区分类别和场景，就采用继承是不恰当的。当你发现你的继承超过 2 层的时候，你就要好好考虑是否这个继承的方案了，第三层继承正是滥用的开端。</p><p><a href="https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="noopener">跳出面向对象思想(一) 继承</a><br><a href="https://www.jianshu.com/p/ee8c6fcc1746" target="_blank" rel="noopener">iOS架构师之路：慎用继承</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;是否使用继承需要考虑三个点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父类只是给子类提供服务，并不涉及子类的业务逻辑&lt;/li&gt;
&lt;li&gt;层级关系明显，功能划分清晰，父类和子类各做各的。&lt;/li&gt;
&lt;li&gt;父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 保持界面流畅的技巧</title>
    <link href="http://yoursite.com/2019/10/29/iOS/iOS%E4%BC%98%E5%8C%96/iOS%20%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%95%85%E6%8A%80%E5%B7%A7(2)/"/>
    <id>http://yoursite.com/2019/10/29/iOS/iOS优化/iOS 页面流畅技巧(2)/</id>
    <published>2019-10-29T05:36:08.654Z</published>
    <updated>2019-10-29T05:36:15.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、屏幕显示图像的原理"><a href="#一、屏幕显示图像的原理" class="headerlink" title="一、屏幕显示图像的原理"></a>一、屏幕显示图像的原理</h2><center><br><img src="http://dzliving.com/iOSOptimize_0.png" alt><br></center><p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用<font color="#cc0000">硬件时钟</font>产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p><center><br><img src="http://dzliving.com/iOSOptimize_1.png" alt="ios_screen_display"><br></center><p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即<font color="#cc0000">双缓冲机制</font>。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><center><br><img src="http://dzliving.com/iOSOptimize_2.jpg" alt="ios_vsync_off"><br></center><p>为了解决这个问题，GPU 通常有一个机制叫做<font color="#cc0000">垂直同步</font>（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><p>那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</p><h2 id="二、卡顿产生的原因和解决方案"><a href="#二、卡顿产生的原因和解决方案" class="headerlink" title="二、卡顿产生的原因和解决方案"></a>二、卡顿产生的原因和解决方案</h2><center><br><img src="http://dzliving.com/iOSOptimize_3.png" alt="ios_frame_drop"><br></center><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h4 id="2-1-CPU-资源消耗原因和解决方案"><a href="#2-1-CPU-资源消耗原因和解决方案" class="headerlink" title="2.1 CPU 资源消耗原因和解决方案"></a>2.1 CPU 资源消耗原因和解决方案</h4><ol><li><p>对象创建</p><p> 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p><p> 尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p></li><li><p>对象调整</p><p> 对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p><p> 当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p></li><li><p>对象销毁</p><p> 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>布局计算</p><p> 视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p><p> 不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p></li><li><p>Autolayout</p><p> Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" rel="noopener">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p></li><li><p>文本计算</p><p> 如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p> 如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p></li><li><p>文本渲染</p><p> 屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p></li><li><p>图片的解码</p><p> 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p></li><li><p>图像的绘制</p><p> 图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-GPU-资源消耗原因和解决方案"><a href="#2-2-GPU-资源消耗原因和解决方案" class="headerlink" title="2.2 GPU 资源消耗原因和解决方案"></a>2.2 GPU 资源消耗原因和解决方案</h4><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p><ol><li><p>纹理的渲染</p><p> 所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p><p> 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：<a href="http://iosres.com/" target="_blank" rel="noopener">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p></li><li><p>视图的混合 (Composing)</p><p> 当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p></li><li><p>图形的生成</p><p> CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p></li></ol><h2 id="三、AsyncDisplayKit"><a href="#三、AsyncDisplayKit" class="headerlink" title="三、AsyncDisplayKit"></a>三、AsyncDisplayKit</h2><p>AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。</p><h4 id="3-1-ASDK-的由来"><a href="#3-1-ASDK-的由来" class="headerlink" title="3.1 ASDK 的由来"></a>3.1 ASDK 的由来</h4><center><br><img src="http://api.cocoachina.com/uploads/20151127/1448608884427724.png" alt><br></center><p>ASDK 的作者是 Scott Goodson (<a href="https://www.linkedin.com/in/iosengineer" target="_blank" rel="noopener">Linkedin</a>)，他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置以及 Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。</p><center><br><img src="http://dzliving.com/iOSOptimize_4.png" alt="asdk_history"><br></center><p>ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。<br>V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。<br>现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。</p><h4 id="3-2-ASDK-的资料"><a href="#3-2-ASDK-的资料" class="headerlink" title="3.2 ASDK 的资料"></a>3.2 ASDK 的资料</h4><p>想要了解 ASDK 的原理和细节，最好从下面几个视频开始：</p><ul><li><a href="https://www.youtube.com/watch?v=-IPMNWqA638" target="_blank" rel="noopener">2014.10.15 NSLondon - Scott Goodson - Behind AsyncDisplayKit</a></li><li><a href="https://www.youtube.com/watch?v=ZPL4Nse76oY" target="_blank" rel="noopener">2015.03.02 MCE 2015 - Scott Goodson - Effortless Responsiveness with AsyncDisplayKit</a></li><li><a href="https://www.youtube.com/watch?v=RY_X7l1g79Q" target="_blank" rel="noopener">2015.10.25 AsyncDisplayKit 2.0: Intelligent User Interfaces - NSSpain 2015</a></li></ul><p>前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。后一个视频增加了 ASDK 2.0 的新特性的介绍。</p><p>除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容：</p><ul><li><a href="https://github.com/facebook/AsyncDisplayKit/issues/42" target="_blank" rel="noopener">关于 Runloop Dispatch</a></li><li><a href="https://github.com/facebook/AsyncDisplayKit/issues/70" target="_blank" rel="noopener">关于 ComponentKit 和 ASDK 的区别</a></li><li><a href="https://github.com/facebook/AsyncDisplayKit/issues/132" target="_blank" rel="noopener">为什么不支持 Storyboard 和 Autolayout</a></li><li><a href="https://github.com/facebook/AsyncDisplayKit/issues/204" target="_blank" rel="noopener">如何评测界面的流畅度</a></li></ul><p>之后，还可以到 Google Groups 来查看和讨论更多内容：</p><ul><li><a href="https://groups.google.com/forum/#!forum/asyncdisplaykit" target="_blank" rel="noopener">https://groups.google.com/forum/#!forum/asyncdisplaykit</a></li></ul><h4 id="3-3-ASDK-的基本原理"><a href="#3-3-ASDK-的基本原理" class="headerlink" title="3.3 ASDK 的基本原理"></a>3.3 ASDK 的基本原理</h4><center><br><img src="http://dzliving.com/iOSOptimize_5.png" alt="asdk_design"><br></center><p>ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。</p><p>为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：</p><center><br><img src="http://dzliving.com/iOSOptimize_6.png" alt="asdk_layer_backed_view"><br></center><p>这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p><center><br><img src="http://dzliving.com/iOSOptimize_7.png" alt="asdk_view_backed_node"><br></center><p>ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&gt;CALayer 相同的方式，实现了 ASNode-&gt;UIView 这样一个关系。</p><center><br><img src="http://dzliving.com/iOSOptimize_8.png" alt="asdk_layer_backed_node"><br></center><p>当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。</p><p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。</p><p>通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。</p><h4 id="3-4-ASDK-的图层预合成"><a href="#3-4-ASDK-的图层预合成" class="headerlink" title="3.4 ASDK 的图层预合成"></a>3.4 ASDK 的图层预合成</h4><center><br><img src="http://dzliving.com/iOSOptimize_9.png" alt="asdk_comoose_1.pngasdk_compose_2"><br></center><p>有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。</p><p>通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。</p><h4 id="3-5-ASDK-异步并发操作"><a href="#3-5-ASDK-异步并发操作" class="headerlink" title="3.5 ASDK 异步并发操作"></a>3.5 ASDK 异步并发操作</h4><center><br><img src="http://dzliving.com/iOSOptimize_10.jpg" alt="asdk_a9_chip"><br></center><p>自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。</p><h4 id="3-6-Runloop-任务分发"><a href="#3-6-Runloop-任务分发" class="headerlink" title="3.6 Runloop 任务分发"></a>3.6 Runloop 任务分发</h4><p>Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章 <a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>，里面对 ASDK 也有所提及。</p><center><br><img src="http://dzliving.com/iOSOptimize_11.png" alt="ios_vsync_runloop"><br></center><p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p><p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p><p>ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="noopener">ASAsyncTransactionGroup</a>。</p><p>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</p><h4 id="3-7-其他"><a href="#3-7-其他" class="headerlink" title="3.7 其他"></a>3.7 其他</h4><p>ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0 添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。</p><h2 id="四、微博-Demo-性能优化技巧"><a href="#四、微博-Demo-性能优化技巧" class="headerlink" title="四、微博 Demo 性能优化技巧"></a>四、微博 Demo 性能优化技巧</h2><p>我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。</p><h4 id="4-1-预排版"><a href="#4-1-预排版" class="headerlink" title="4.1 预排版"></a>4.1 预排版</h4><p>当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。</p><p>对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell/" target="_blank" rel="noopener">FDTemplateLayoutCell</a>。</p><h4 id="4-2-预渲染"><a href="#4-2-预渲染" class="headerlink" title="4.2 预渲染"></a>4.2 预渲染</h4><p>微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。</p><p>对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。</p><h4 id="4-3-异步绘制"><a href="#4-3-异步绘制" class="headerlink" title="4.3 异步绘制"></a>4.3 异步绘制</h4><p>我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="noopener">YYAsyncLayer</a>。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。</p><p>当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。</p><p>目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。</p><h4 id="4-4-全局并发控制"><a href="#4-4-全局并发控制" class="headerlink" title="4.4 全局并发控制"></a>4.4 全局并发控制</h4><p>当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题：</p><center><br><img src="http://dzliving.com/iOSOptimize_12.png" alt="ios_vsync_runloop"><br></center><p>大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：<a href="https://github.com/facebook/AsyncDisplayKit/tree/master/examples/SocialAppLayout" target="_blank" rel="noopener">SocialAppLayout</a>，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。</p><p>使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 <a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="noopener">YYDispatchQueuePool</a>，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。</p><h4 id="4-5-更高效的异步图片加载"><a href="#4-5-更高效的异步图片加载" class="headerlink" title="4.5 更高效的异步图片加载"></a>4.5 更高效的异步图片加载</h4><p>SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。</p><h4 id="4-6-其他可以改进的地方"><a href="#4-6-其他可以改进的地方" class="headerlink" title="4.6 其他可以改进的地方"></a>4.6 其他可以改进的地方</h4><p>上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下：</p><ol><li>列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。</li><li>再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。</li><li>目前每个 Cell 的类型都是相同的，但显示的内容却各不一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。</li><li>把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。</li></ol><h2 id="五、如何评测界面的流畅度"><a href="#五、如何评测界面的流畅度" class="headerlink" title="五、如何评测界面的流畅度"></a>五、如何评测界面的流畅度</h2><p>最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。</p><p>如果你需要一个明确的 FPS 指示器，可以尝试一下 KMCGeigerCounter。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。</p><p>我自己也写了个简单的 FPS 指示器：FPSLabel 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。</p><p>最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。</p><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">ibireme</a> - <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、屏幕显示图像的原理&quot;&gt;&lt;a href=&quot;#一、屏幕显示图像的原理&quot; class=&quot;headerlink&quot; title=&quot;一、屏幕显示图像的原理&quot;&gt;&lt;/a&gt;一、屏幕显示图像的原理&lt;/h2&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://dzliving
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>贝塞尔曲线</title>
    <link href="http://yoursite.com/2019/10/28/iOS/iOS%E5%8A%A8%E7%94%BB/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/10/28/iOS/iOS动画/贝塞尔曲线/</id>
    <published>2019-10-28T14:09:48.201Z</published>
    <updated>2019-10-28T14:10:06.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、贝塞尔曲线"><a href="#一、贝塞尔曲线" class="headerlink" title="一、贝塞尔曲线"></a>一、贝塞尔曲线</h2><p>贝塞尔曲线，可以通过三个点，来确定一条平滑的曲线。</p><p>Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的<a href="http://baike.baidu.com/view/627248.htm" target="_blank" rel="noopener">数学曲线</a>。 </p><blockquote><p>曲线定义：起始点、终止点(也称锚点)、控制点。</p></blockquote><p>通过调整控制点，贝塞尔曲线的形状会发生变化。矢量绘制曲线。</p><p>公式：B(t)为时间 t 下点的坐标，P<sub>0</sub> 为起点，P<sub>n</sub> 为终点，P<sub>i</sub> 为控制点</p><ol><li><p>一阶贝塞尔曲线(线段)：由 P<sub>0</sub> 至 P<sub>1</sub> 的连续点描述一条线段</p> <center><br> <img src="http://dzliving.com/BezierPath_0.png" alt><br> <img src="http://dzliving.com/BezierPath_1.gif" alt><br> </center></li><li><p>二阶贝塞尔曲线(抛物线)： 由 P<sub>0</sub> 至 P<sub>1</sub> 的连续点 Q<sub>0</sub> 描述一条线段；由 P<sub>1</sub> 至 P<sub>2</sub> 的连续点 Q<sub>1</sub> 描述一条线段；由 Q<sub>0</sub> 至 Q<sub>1</sub> 的连续点 B(t) 描述一条二次贝塞尔曲线</p> <center><br> <img src="http://dzliving.com/BezierPath_2.png" alt><br> <img src="http://dzliving.com/BezierPath_3.gif" alt><br> </center></li><li><p>三阶贝塞尔曲线：</p> <center><br> <img src="http://dzliving.com/BezierPath_4.png" alt><br> <img src="http://dzliving.com/BezierPath_5.gif" alt><br> </center></li><li><p>通用公式：</p> <center><br> <img src="http://dzliving.com/BezierPath_6.png" alt><br> </center></li><li><p>四阶贝塞尔曲线：    </p> <center><br> <img src="http://dzliving.com/BezierPath_7.gif" alt><br> </center></li><li><p>五阶贝塞尔曲线：</p> <center><br> <img src="http://dzliving.com/BezierPath_8.gif" alt><br> </center></li></ol><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><center><br><img src="http://dzliving.com/BezierPath_15.jpg" alt><br></center><ul><li>miterLimit 最大斜接长度（只有在使用 kCGLineJoinMiter 是才有效），边角的角度越小，斜接长度就会越大</li></ul><center><br><img src="http://dzliving.com/BezierPath_13.png" alt><br></center><p>为了避免斜接长度过长，使用 lineLimit 属性限制，如果斜接长度超过 miterLimit，边角就会以 KCALineJoinBevel 类型来显示。</p><center><br><img src="http://dzliving.com/BezierPath_14.png" alt><br></center><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@brief</span>  绘制三次贝塞尔曲线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">addCurveToPoint:</span>(CGPoint)endPoint <span class="string">controlPoint1:</span>(CGPoint)controlPoint1 <span class="string">controlPoint2:</span>(CGPoint)controlPoint2;</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/uibezier_curve.jpg" alt><br></center><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>addQuadCurveToPoint:<span class="params">(CGPoint)</span>endPoint controlPoint:<span class="params">(CGPoint)</span>controlPoint;</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/quadratic_bezier_curve.jpg" alt><br></center><p><a href="https://www.cnblogs.com/small-octopus/p/4874600.html" target="_blank" rel="noopener">贝塞尔曲线（UIBezierPath）属性、方法汇总</a></p><h2 id="三、德卡斯特里奥算法-De-Casteljau’s-Algorithm-绘制贝塞尔曲线"><a href="#三、德卡斯特里奥算法-De-Casteljau’s-Algorithm-绘制贝塞尔曲线" class="headerlink" title="三、德卡斯特里奥算法(De Casteljau’s Algorithm)绘制贝塞尔曲线"></a>三、德卡斯特里奥算法(De Casteljau’s Algorithm)绘制贝塞尔曲线</h2><p><a href="http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html" target="_blank" rel="noopener">http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html</a></p><p>德卡斯特里奥算法可以计算贝塞尔曲线上的点 C(u)，u ∈ [0,1]。因此，通过给定一组 u 的值，便可以计算出贝塞尔曲线上的坐标序列，从而绘制出贝塞尔曲线。</p><p>德卡斯特里奥算法的基础就是在向量 AB 上选择一个点 C，使得 C 分向量 AB 为 u：1-u(也就是∣AC∣:∣AB∣= u)。给定点 A、B 的坐标以及 u(u ∈ [0,1]) 的值，点 C 的坐标便为：C = A + (B - A) <em> u = (1 - u) </em> A + B * u。</p><center><br><img src="http://dzliving.com/BezierPath_9.png" alt><br></center><p>定义贝塞尔曲线的控制点 P<sub>i</sub> 编号为 0<sub>i</sub>，其中 0 表示是第 0 次迭代，递推。</p><p>德卡斯特里奥算法的思想如下：</p><blockquote><p>为了计算 n 次贝塞尔曲线上的点 C(u)，u ∈ [0,1]，首先将控制点连接形成一条折线 00-01-02…0(n - 1)-0n。利用上述方法，计算出折线中每条线段 0j-0(j+1) 上的一个点 1j，使得点 1j 分该线段的比为 u:1-u。然后在折线 10-11-…-1(n-1) 上递归调用该算法，以此类推。最终，求得最后一个点 n0。 德卡斯特里奥证明了，点 n0 一定是曲线上的点。</p></blockquote><center><br><img src="http://dzliving.com/BezierPath_10.png" alt><br></center><p>如上图，曲线控制点是 00、01、02、03、04、05。线段 00-01 上取点 10 分该线段的比为 u:1-u，类似的取点 11、12、13、14，然后第二次迭代在线段 10-11 上取点 20 分该线段的比为 u:1-u，类似地取点 21、22、23。然后进行下一次迭代，依次类推，直到最后在线段 40-41 上取点 50，50 是最终惟一的点，也是在曲线上的点。</p><p>上述直观的算法描述可以表达成一个计算方法</p><center><br><img src="http://dzliving.com/BezierPath_11.png" alt><br></center><p>首先，将所有给定的控制点排列成一列，在上图中，即为最左边的一列。每一对相邻的控制点可以伸出两个箭头，分别指向右下方和右上方。在相邻箭头的交叉处，生成一个新的控制点。例如，控制点 ij 和 i(j +1) 生成新的控制点 (i + 1)j。指向右下方的箭头表示乘以 (1 - u)，指向右上方的箭头表示乘以 u。</p><p>因此，通过第 0 列，可以求出第 1 列，然后求出第 2 列…，最终，在 n 次迭代后，可以到达惟一的一个点 n0，这个点就是曲线上的点。</p><p>但是，直接通过递归方法计算 P<sub>ij</sub> 效率低下，其原因与通过递归方法计算斐波那契数列一样：递归方法有大量的重复计算。</p><p>德卡斯特里奥算法还有一个有趣的性质。对于同一列中的连续的一组控制点，对其应用德卡斯特里奥算法，那么由这些控制点确定的曲线上的点，就是以这组控制点为边的等边三角形中，与这些控制点相对的顶点。</p><p>例如：由控制点 02、03、04、05 确定的曲线上对应 u 的点是 32(蓝色的等边三角形)。同样，控制点 11、12、13 确定的曲线上对应 u 的点是 31(黄色三角形)。</p><center><br><img src="http://dzliving.com/BezierPath_12.png" alt><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、贝塞尔曲线&quot;&gt;&lt;a href=&quot;#一、贝塞尔曲线&quot; class=&quot;headerlink&quot; title=&quot;一、贝塞尔曲线&quot;&gt;&lt;/a&gt;一、贝塞尔曲线&lt;/h2&gt;&lt;p&gt;贝塞尔曲线，可以通过三个点，来确定一条平滑的曲线。&lt;/p&gt;
&lt;p&gt;Bézier curve(贝塞尔曲
      
    
    </summary>
    
      <category term="iOS动画" scheme="http://yoursite.com/categories/iOS%E5%8A%A8%E7%94%BB/"/>
    
    
  </entry>
  
</feed>
