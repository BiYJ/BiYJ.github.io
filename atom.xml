<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-02T06:25:59.841Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2019/08/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/01/排序算法/</id>
    <published>2019-08-01T15:02:32.000Z</published>
    <updated>2019-08-02T06:25:59.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h4 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h4><p>冒泡排序是<font color="#cc0000">蛮力法</font>在排序问题上的一个典型的应用场景。</p><blockquote><p>对于一个给定长度为 n 的无序数组，由初始位置开始，比较数组相邻两个元素。如果是逆序排列的，就交换它们的位置，重复多次之后，最大数就“<font color="#cc0000">沉</font>”到了数组最后的位置。第二次再从初始位置开始，将第二大的元素沉到倒数第二个位置。这样一直做 n-1 次，整个数组就是有序的了。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b62f26f8b7dc357b.gif?imageMogr2/auto-orient/strip" alt></p><p>对于一个长度为 n 的数组，整个算法消耗的时间为：(n-1) + (n-2) + … + 1 = n(n-1)/2，那么它的时间复杂度为 <font color="#cc0000">O(n<sup>2</sup>)</font>。同时，显而易见，整个算法只消耗一份数组的空间，所以空间复杂度为 <font color="#cc0000">O(1)</font>。</p><p>另外，普及一下排序算法另一个重要的特性：<strong><font color="#cc0000">稳定性</font></strong>。</p><blockquote><p>所谓的稳定性，通俗地讲就是能保证两个相等的数在排序前后的顺序相同。</p><p>假定原数组有两个相同的元素 Ω，在数组的 a[i] 和 a[j] 位置。排序前 a[i] 在 a[j] 的前面，在排序之后，a[i] 仍然在 a[j] 的前面，那么就说这种排序方法具有稳定性。</p></blockquote><p><font color="#cc0000">冒泡排序是一种稳定排序</font>。</p><p>蛮力法的应用有一个显著的特点，就是在经过适当的努力之后，可以对算法进行一定的改良，从而提高它的性能，但并不会减弱算法本身的时间复杂度。冒泡排序作为蛮力法的典型应用，自然也有这种特性。</p><h4 id="1-2-改进"><a href="#1-2-改进" class="headerlink" title="1.2 改进"></a>1.2 改进</h4><blockquote><p>设定交换发生的标识位</p></blockquote><p>对于待排序的数组，可以设定一个标志位，检查一次比较之后，是否有数据进行了交换，若是没有，那么整个数组就已经有序了，可以直接退出。极端情况下，如刚才提到的，对有序数组进行排序，只需要执行 n-1 次操作，就可以完成排序。</p><blockquote><p>记录最后一次发生交换的位置</p></blockquote><p>初始排序时，数组是在 [0, n] 区间遍历，那么下一轮的遍历是在 [0, n-1] 区间。</p><p>现在记录数组本轮遍历的最后一次交换发生在 lastSwapPos 位置，那么下一轮的遍历实际上是在 [0, lastSwapPos] 区间。</p><h4 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH  10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastSwapPos = ARRAY_LENGTH - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lastSwapPosTemp = ARRAY_LENGTH - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp  = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ARRAY_LENGTH - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        lastSwapPos = lastSwapPosTemp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lastSwapPos; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                lastSwapPosTemp = j;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一次都未交换的情况</span></span><br><span class="line">        <span class="keyword">if</span> (lastSwapPos == lastSwapPosTemp) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><p>优点：</p><ul><li>空间复杂度 T = O(1)</li><li>稳定排序</li><li>在排序过程中，整个数组趋向稳定</li><li>对于已经有序的数组，排序效率高</li></ul><p>缺点：</p><ul><li>效率低</li><li>交换次数多，交换效率低（每次交换只减少一组逆序对）</li><li>不能并发执行</li></ul><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><h4 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h4><p>选择排序是<font color="#cc0000">蛮力法</font>的一种实际应用。</p><blockquote><p>首先扫描整个数组，<font color="#cc0000">找到最小的元素</font>，然后和第一个元素进行交换，如此一来就等同于将最小的元素放到它在有序表中最终的位置上。然后从第二个元素开始扫描整个表，找到剩余 n-1 个元素中最小的元素，与第二个元素交换位置。以此类推，在执行 n-1 遍之后，这个数组就自然有序了。（当然每次找最大的元素，与最后一个元素交换也是可行的）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5294842-95d0e230361f79d5.gif?imageMogr2/auto-orient/strip" alt="SelectSortGif.gif"></p><p>选择排序有一个最明显的优于冒泡排序的：<font color="#cc0000">数据交换的次数</font>。在完全逆序的情况下，冒泡排序需要最多的 n*(n-1)/2 次交换，而选择排序最多产生 n-1 次交换。</p><p>选择排序的时间复杂度是 <font color="#cc0000">O(n^2)</font>，空间复杂度是 <font color="#cc0000">O(1)</font>。</p><p>选择排序有一个很重要的特性——<font color="#cc0000">它是一种不稳定排序</font>。假定一个数组：[5, 5, 6, 1, 8]，可以很清晰的发现，在选择排序结束之后，两个 5 并不能保持原来的顺序，第一个 5 在第四的位置，第二个 5 还在第二的位置。</p><h4 id="2-2-改进"><a href="#2-2-改进" class="headerlink" title="2.2 改进"></a>2.2 改进</h4><p>每一次外循环的遍历，可以同时找到最小值（minIndex）和最大值（maxIndex），分别和头、尾两个元素进行交换。这样一来外循环只要执行原来一半的循环次数就可以了。</p><p>但是需要注意一点：每次循环要进行 2 次交换，第一次最小值交换结束之后，在进行最大值交换的时候要先判断最大值是不是在第一个位置，在第一次最小值交换的时候已经换到了后面。</p><p>如 [5, 4, 3, 2, 1] 第一次最小值交换后变成了 [1, 4, 3, 2, 5]，初始记录的 maxIndex = 0 就指向了 1，而不是 5。</p><h4 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH  10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组内容合法性判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">int</span> maxIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式 ①</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; ARRAY_LENGTH; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断第一个是不是最小值，是的话可以不用交换</span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">            swap(i, minIndex, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式 ②</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        minIndex = i;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; ARRAY_LENGTH - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[maxIndex]) &#123;</span><br><span class="line">                maxIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断第一个是不是最小值，是的话可以不用交换</span></span><br><span class="line">        <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">            swap(i, minIndex, arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ARRAY_LENGTH - <span class="number">1</span> - i != maxIndex) &#123;</span><br><span class="line">            <span class="comment">// 防止最大数在第一个，优先和最小数进行交换</span></span><br><span class="line">            swap(ARRAY_LENGTH - <span class="number">1</span> - i, (i == maxIndex) ? minIndex : maxIndex, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2, <span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp  = arr[idx1];</span><br><span class="line">    arr[idx1] = <span class="built_in">array</span>[idx2];</span><br><span class="line">    arr[idx2] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h2><h4 id="3-1-减治法（增量法）"><a href="#3-1-减治法（增量法）" class="headerlink" title="3.1 减治法（增量法）"></a>3.1 减治法（增量法）</h4><blockquote><ul><li>减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。</li><li>增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。</li></ul></blockquote><p>减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。</p><p>很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式：</p><ul><li>减去一个常量。（直接插入排序）</li><li>减去一个常量因子。（二分查找法）</li><li>减去的规模可变。（辗转相除法）</li></ul><h4 id="3-2-直接插入排序"><a href="#3-2-直接插入排序" class="headerlink" title="3.2 直接插入排序"></a>3.2 直接插入排序</h4><p>直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：</p><blockquote><p>对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。</p><p>考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n - 1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5294842-efaf86b318ef2893.gif?imageMogr2/auto-orient/strip" alt="InsertSort.gif"></p><p>很显然，基于增量法的思想在解决这个问题上拥有更高的效率。</p><p>直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。</p><p>当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）</p><p>直接插入排序的时间复杂度是 <font color="#cc0000">O(n<sup>2</sup>)</font>，空间复杂度是 <font color="#cc0000">O(1)</font>，同时也是<font color="#cc0000">稳定排序</font>。</p><h4 id="3-3-优化"><a href="#3-3-优化" class="headerlink" title="3.3 优化"></a>3.3 优化</h4><blockquote><p>设置哨兵位</p></blockquote><p>仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。</p><p>不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：<font color="#cc0000">记录上一次插入的值和位置，与当前插入值比较</font>。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。</p><blockquote><p>二分查找法</p></blockquote><p>优化直接插入排序的核心在于：<font color="#cc0000">快速定位当前数字待插入的位置</font>。</p><p>在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。</p><p>这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会<strong>打破排序算法的稳定性</strong>，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？</p><h4 id="3-4-简单的性能比较"><a href="#3-4-简单的性能比较" class="headerlink" title="3.4 简单的性能比较"></a>3.4 简单的性能比较</h4><p><img src="https://upload-images.jianshu.io/upload_images/5294842-53aa065d1538f636.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多种优化方式性能比较"></p><p>结论：</p><ul><li><p><strong>在某些特定场景下</strong>，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。</p></li><li><p>对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。</p></li><li><p>大规模数组，二分查找优化效率明显。</p></li></ul><h4 id="3-5-代码"><a href="#3-5-代码" class="headerlink" title="3.5 代码"></a>3.5 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH  10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">list</span>[i]; <span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt; <span class="number">-1</span> &amp;&amp; temp &lt; <span class="built_in">list</span>[j]; j--) &#123;</span><br><span class="line">            <span class="built_in">list</span>[j + <span class="number">1</span>] = <span class="built_in">list</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据上一次的位置，简化下一次定位</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimized_1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录上一个插入值的位置和数值</span></span><br><span class="line">    <span class="keyword">int</span> checkValue = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> checkIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cur = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> start = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 根据上一个值，定位开始遍历的位置</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; checkValue) &#123;</span><br><span class="line">            start = checkIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; start - <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的</span></span><br><span class="line">        <span class="comment">// 循环判断 + 插入</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &gt; <span class="number">-1</span>; j--) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + <span class="number">1</span>] = cur;</span><br><span class="line">        checkValue = cur;</span><br><span class="line">        checkIndex = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h2><h4 id="4-1-和直接插入排序的关系"><a href="#4-1-和直接插入排序的关系" class="headerlink" title="4.1 和直接插入排序的关系"></a>4.1 和直接插入排序的关系</h4><p>希尔排序 Shell sort 是直接插入排序的<font color="#cc0000">变种</font>方式之一，更高效的改进版本。其基本思想如下：</p><p>①、记录按下标的一定增量分组，对每组进行直接插入排序。</p><p>②、不断地<font color="#cc0000">缩小增量</font>，对每组进行直接插入排序，直至增量为 1。</p><p>数组：a[33, 13, 44, 21, 88, 8, 17]</p><ol><li><p>增量 d = 3  分组 [33, 21, 17]、[13, 88]、[44, 8]  排序结果：[17, 13, 8, 21, 88, 44, 33]</p></li><li><p>增量 d = 3/2 = 1  分组 [17, 13, 8, 21, 88, 44, 33]  排序结果：[8, 13, 17, 21, 33, 44, 88]</p></li></ol><p>由上可知，希尔排序本质就是<font color="#cc0000">多次使用直接插入排序</font>。其优于直接插入排序的原因在之前也提到过，就是：<font color="#cc0000">直接插入排序对于基本有序的数组，拥有较高的性能</font>。</p><p>希尔排序的时间复杂度是 O(n<sup>2</sup>)（只是针对最坏情况而言，平均的效率要远远高出其他时间复杂度为 O(n<sup>2</sup>) 的排序算法），空间复杂度是 O(1)。</p><p>希尔排序在提供优秀性能的同时，<font color="#cc0000">打破了排序算法的稳定性</font>。</p><h4 id="4-2-希尔排序的实现"><a href="#4-2-希尔排序的实现" class="headerlink" title="4.2 希尔排序的实现"></a>4.2 希尔排序的实现</h4><p>希尔排序，又称为<strong>缩小增量排序</strong>，其重点显然在于<strong>初始增量 d 的选取，以及每次增量 d 缩小的额度</strong>。一般来说，初始增量设为数组长度的一半，同时每次增量减半，直至 d = 1，可以满足大多数的需求。</p><h4 id="4-3-优化"><a href="#4-3-优化" class="headerlink" title="4.3 优化"></a>4.3 优化</h4><p>1、设置哨兵位优化各分组的直接插入排序</p><p>2、二分查找法优化各分组的直接插入排序</p><h4 id="4-4-简单的性能比较"><a href="#4-4-简单的性能比较" class="headerlink" title="4.4 简单的性能比较"></a>4.4 简单的性能比较</h4><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2fb33b6584777046.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="希尔排序优化性能比较"></p><p>结论：</p><ul><li><p><strong>直接插入排序的优化手段，对希尔排序没有作用，反而是一种伤害</strong>。原因是直接插入排序的优化手段对于小规模的数组是有害的，而希尔排序的原理是将整个数组拆成若干个小数组，利用直接插入排序对基本有序的数组拥有良好的性能这一特性出发的。</p></li><li><p>同样是不稳定排序，对比直接插入排序的二分查找优化，无论数组规模的大小，希尔排序在性能上都有明显的优势。</p></li></ul><h2 id="五、堆排序"><a href="#五、堆排序" class="headerlink" title="五、堆排序"></a>五、堆排序</h2><p>堆排序 Heap Sort，是指将整个数组转化成 “堆” 这种数据结构，利用堆的性质，去简化排序的过程。堆排序，可以看做是“<font color="#cc0000">变治法</font>”的一种实现。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-e25b62dbcc16d8fb.gif?imageMogr2/auto-orient/strip" alt="堆排序"></center><p>From Wikipedia：<a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h4 id="5-1-堆"><a href="#5-1-堆" class="headerlink" title="5.1 堆"></a>5.1 堆</h4><p><font color="#cc0000">堆是一个可以被看做一棵树的数组对象</font>，但是堆总是需要满足以下两条性质：</p><pre><code>①、堆是一棵完全二叉树。树的每一层都是满的，除了最后一层最右边的元素有可能出现缺位。  ②、父母优势。即堆中的所有子节点，总是不大于或不小于其父节点的值。</code></pre><p>根据子节点与父节点的关系，可以将堆分为最大堆（大的值在上）和最小堆（小的值在上）两种情况。</p><h4 id="5-2-堆的数组表现形式"><a href="#5-2-堆的数组表现形式" class="headerlink" title="5.2 堆的数组表现形式"></a>5.2 堆的数组表现形式</h4><p>数组 [9, 7, 3, 5, 1, 2, 6, 0, 8, 4] 按照顺序逐层放置可以转化为以下二叉树结构。（目前不具备堆的性质）</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-656e3af0d584deef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></center><h4 id="5-3-堆的性质"><a href="#5-3-堆的性质" class="headerlink" title="5.3 堆的性质"></a>5.3 堆的性质</h4><p>1、获取堆中某个节点的左节点、右节点、父节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)leftNode:(<span class="keyword">int</span>)node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (node &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;    <span class="comment">// 0 &lt;&lt; 1 = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)rightNode:(<span class="keyword">int</span>)node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (node &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)parentNode:(<span class="keyword">int</span>)node</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (node - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①、把完全二叉树每层的节点个数看成二进制 1、2、4、8…</p><p>②、当前节点在层 n（从 0 开始）的位置为 m（从 0 开始），那么节点在数组的位置为 index = 2<sup>(n - 1)</sup> + 2<sup>(n - 2)</sup> + … + 2<sup>0</sup> + m</p><p>左边子节点就是 2<sup>n</sup> + 2<sup>(n - 1)</sup> + … + 2<sup>0</sup> + m <em> 2 + 1 = index </em> 2 + 1<br>右边子节点就是 2<sup>n</sup> + 2<sup>(n - 1)</sup> + … + 2<sup>0</sup> + m <em> 2 + 2 = index </em> 2 + 2</p><p>2、保持最大堆/最小堆的性质</p><p>当二叉树中的某个子节点，其左子树和右子树都具备堆的性质，那么可以通过一系列的交换，将以该子节点为根节点的树，转化为堆的结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param  array   待排序数组</span></span><br><span class="line"><span class="comment"> *  @param  node   当前节点</span></span><br><span class="line"><span class="comment"> *  @param  lastNode   最后一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)maxHeapSort:(NSMutableArray *)<span class="built_in">array</span> node:(<span class="keyword">int</span>)node lastNode:(<span class="keyword">int</span>)lastNode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> lNode = [self  leftNode:node];   <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">int</span> rNode = [self rightNode:node];  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">int</span> largestNode = node;   <span class="comment">// 最大值节点。初始为当前节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果左子节点没有超出范围 &amp;&amp; 左子节点数值比 largestNode 的大</span></span><br><span class="line">    <span class="keyword">if</span> (lNode &lt;= lastNode &amp;&amp; [<span class="built_in">array</span>[lNode] integerValue] &gt; [<span class="built_in">array</span>[largestNode] integerValue]) &#123;</span><br><span class="line">        largestNode = lNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果右子节点没有超出范围 &amp;&amp; 右子节点数值比 largestNode 的大</span></span><br><span class="line">    <span class="keyword">if</span> (rNode &lt;= lastNode &amp;&amp; [<span class="built_in">array</span>[rNode] integerValue] &gt; [<span class="built_in">array</span>[largestNode] integerValue]) &#123;</span><br><span class="line">        largestNode = rNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前节点不是最大值，发生交换</span></span><br><span class="line">    <span class="keyword">if</span> (node != largestNode) &#123;</span><br><span class="line">        [<span class="built_in">array</span> exchangeObjectAtIndex:node withObjectAtIndex:largestNode];</span><br><span class="line">        [self maxHeapSort:<span class="built_in">array</span> node:largestNode lastNode:lastNode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造最大堆/最小堆</p><p>将一个不具备堆性质的数组，转化为堆的结构，一般都是<font color="#cc0000">自底向上</font>开始的。</p><p>自二叉树的第一个非叶节点开始，自底向上，依次保持二叉树的堆的性质，直至根节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@<span class="number">9</span>, @<span class="number">7</span>, @<span class="number">3</span>, @<span class="number">5</span>, @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">6</span>, @<span class="number">0</span>, @<span class="number">8</span>, @<span class="number">4</span>, nil];</span><br><span class="line"><span class="keyword">int</span> lastNonLeaf = (<span class="keyword">int</span>)(arr.count - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lastNonLeaf; i &gt; <span class="number">-1</span>; --i) &#123;</span><br><span class="line">     [self maxHeapSort:arr node:i lastNode:arr.count - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="https://upload-images.jianshu.io/upload_images/5294842-51affe09b8c2ff2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><h4 id="5-4-堆排序"><a href="#5-4-堆排序" class="headerlink" title="5.4 堆排序"></a>5.4 堆排序</h4><p>①、将原数组转化为堆的形式。升序排列使用最大堆，降序排列使用最小堆。</p><p>②、将数组最后一位与第一位交换，因为是最大堆的关系，第一位数字就是最大值，落在了最后一位上。</p><p>③、剔除最后一位数字，将数组剩余部分，看作一颗新的二叉树。其中根节点的左子树和右子树都满足最大堆的性质，保持这棵新二叉树的最大堆性质。这里是通过自顶向下的方式直到最后一个叶子节点调整二叉树。</p><p>④、循环 ②、③，直至根节点，整个数组即自然有序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray * arr = [NSMutableArray arrayWithObjects:@<span class="number">9</span>, @<span class="number">7</span>, @<span class="number">3</span>, @<span class="number">5</span>, @<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">6</span>, @<span class="number">0</span>, @<span class="number">8</span>, @<span class="number">4</span>, nil];</span><br><span class="line"><span class="keyword">int</span> lastNonLeaf = (<span class="keyword">int</span>)(arr.count - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;  <span class="comment">// 从第一个非叶子节点开始构造，即最后一个叶子节点的父节点。</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 数组 -&gt; 堆 -&gt; 最大堆 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lastNonLeaf; i &gt; <span class="number">-1</span>; --i) &#123;</span><br><span class="line">     [self maxHeapSort:arr node:i lastNode:(<span class="keyword">int</span>)arr.count - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大堆 -&gt; 第一个与最后一个交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)arr.count - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">     [arr exchangeObjectAtIndex:i withObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">     [self maxHeapSort:arr node:<span class="number">0</span> lastNode:i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-变治法代码"><a href="#5-5-变治法代码" class="headerlink" title="5.5 变治法代码"></a>5.5 变治法代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num 10</span></span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Description</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief   筛选算法。用于维护堆，保持最大堆的性质</span></span><br><span class="line"><span class="comment">  *  @param   a   数组</span></span><br><span class="line"><span class="comment">  *  @param   k   调整的结点</span></span><br><span class="line"><span class="comment">  *  @param   n  堆的大小</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapify</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = k, j;</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span>;  <span class="comment">// 置 i 为要筛的结点，j 为 i 的左孩子</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt; n) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// j + 1 &lt; n 用于判断 i 是否有右孩子。a[j] &lt; a[j+1] 用于比较左右孩子的大小</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>])</span><br><span class="line">            j++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[j]) &#123;  <span class="comment">// i 节点大于左右孩子中的最大者</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">            i = j;</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每建立一次堆，只能确定根节点是最大值，其他节点并没有按序排好，所以后面有重复建堆的过程，但是需要建堆的区间慢慢变少了</span></span><br><span class="line">    <span class="keyword">for</span>(i = (num - <span class="number">1</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        MaxHeapify(a, i, num);  <span class="comment">// 初始建堆，其中一开始 i 表示的是最后一个元素的父节点</span></span><br><span class="line">        </span><br><span class="line">        Description(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重复执行移走堆项及重建堆的操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; num; i++) &#123;   <span class="comment">// i 表示当前堆的大小，即等待排序的元素的个数</span></span><br><span class="line">        temp = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[num - i];</span><br><span class="line">        a[num - i] = temp;</span><br><span class="line">        </span><br><span class="line">        MaxHeapify(a, <span class="number">0</span>, num - i);  <span class="comment">//从根节点处继续调整建堆，0 ... n-i 是无序区</span></span><br><span class="line">        </span><br><span class="line">        Description(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[num] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    HeapSort(a);</span><br><span class="line">    Description(a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">4</span>  <span class="number">2</span>  </span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">2</span>  </span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">9</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">2</span>  </span><br><span class="line"><span class="number">0</span>  <span class="number">7</span>  <span class="number">9</span>  <span class="number">6</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">1</span>  </span><br><span class="line"><span class="number">9</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">1</span>  </span><br><span class="line"><span class="number">8</span>  <span class="number">7</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">7</span>  <span class="number">6</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">6</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">5</span>  <span class="number">4</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">4</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  </span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><center><img src="https://upload-images.jianshu.io/upload_images/5294842-cf0540213656f143.gif?imageMogr2/auto-orient/strip" alt></center><h4 id="5-6-堆排序的时间复杂度"><a href="#5-6-堆排序的时间复杂度" class="headerlink" title="5.6 堆排序的时间复杂度"></a>5.6 堆排序的时间复杂度</h4><p>堆排序由两部分组成：</p><ul><li>构建最大堆</li><li>循环保持最大堆的性质</li></ul><p>1、构建最大堆的时间复杂度 T = O(n)</p><p>构建最大堆的过程，是从第一个非叶节点开始的，即数组的 1/2 处。</p><p>考虑最坏情况：</p><ul><li>二叉树的倒数第二行，总会与最后一行发生一次比较/交换。</li><li>二叉树的倒数第三行，总会与倒数第二行发生一次比较/交换，与最后一行发生一次比较/交换。</li><li>…</li><li>二叉树的第一行，总会与它下面的每一行都发生一次比较/交换，即交换次数为二叉树高度 d = log<sub>2</sub>n。</li></ul><p>将这些比较/交换次数累加：</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-f2146ea58f83597c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较/交换次数"></center><p>2、循环保持最大堆的性质的时间复杂度 T = O(n * log<sub>2</sub>n)</p><p>这一步的时间计算就相对比较明显了，在 n 次循环的内部，进行时间复杂度为 O(log<sub>2</sub>n) 的 maxHeapSort()。</p><p>所以总时间复杂度 T = O(n) + O(nlog<sub>2</sub>n) =O(nlog<sub>2</sub>n)</p><h2 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h2><p>归并排序 Merge Sort，又称为二路归并排序，是指将一个数组一分为二，对每一个子数组递归排序，最后将排好的子数组合并为一个有序数组的过程。</p><p>归并排序，是 “<font color="#cc0000">分治法</font>” 应用的完美实现。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-afe49cc3836f79c9.gif?imageMogr2/auto-orient/strip" alt="归并排序"></center><p>From Wikipedia: <a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><h4 id="6-1-图示"><a href="#6-1-图示" class="headerlink" title="6.1 图示"></a>6.1 图示</h4><center><img src="https://upload-images.jianshu.io/upload_images/5294842-1e234cd74bc0737e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归并排序图示"></center><h4 id="6-2-流程"><a href="#6-2-流程" class="headerlink" title="6.2 流程"></a>6.2 流程</h4><p>通过图示可以发现归并排序一共只需要两个步骤：</p><ul><li>分：将原数组分为 n 个子数组，每个子数组长度为 1。</li><li>合：依次将两个相邻的有序数组，合并成一个有序数组，重复操作直至剩下一个有序数组。</li></ul><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><p>1、分成两个子数组，左右递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sort:(NSMutableArray *)arr left:(NSInteger)left right:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        NSInteger mid = (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">//  ÷ 2</span></span><br><span class="line">        </span><br><span class="line">        [self sort:arr left:left right:mid];</span><br><span class="line">        [self sort:arr left:(mid + <span class="number">1</span>) right:right];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将分开的两部分子数组合并</span></span><br><span class="line">        [self merge:arr left:left mid:mid right:right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、合并两个有序数组，此时处理新数组的排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)merge:(NSMutableArray *)arr left:(NSInteger)left mid:(NSInteger)mid right:(NSInteger)right</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 注意新数组的长度</span></span><br><span class="line">    NSMutableArray * newArr = [NSMutableArray arrayWithCapacity:right - left + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    NSInteger startIndex1 = left;</span><br><span class="line">    NSInteger startIndex2 = mid + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 左侧数组检索完毕</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex1 == mid + <span class="number">1</span>) &#123;</span><br><span class="line">            newArr[i] = arr[startIndex2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右侧数组检索完毕</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (startIndex2 == right + <span class="number">1</span>) &#123;</span><br><span class="line">            newArr[i] = arr[startIndex1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用两个指针记录数组位置，依次比较指针位置的数字，将较小的数字放入新数组。这样可以在线性的时间内完成合并工作。</span></span><br><span class="line">            newArr[i] = [arr[startIndex1] integerValue] &lt; [arr[startIndex2] integerValue] ? arr[startIndex1++] : arr[startIndex2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr replaceObjectsInRange:NSMakeRange(left, newArr.count) withObjectsFromArray:newArr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、相似的完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SR[max], TR[max];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @param   SR   两个有序序列构成的序列</span></span><br><span class="line"><span class="comment">  *  @param   TR   一个空数组，用来存放排序好之后的数字</span></span><br><span class="line"><span class="comment">  *  @param   left   起始位置</span></span><br><span class="line"><span class="comment">  *  @param   mid   两个序列的分解位置</span></span><br><span class="line"><span class="comment">  *  @param   right   结束位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = left;  <span class="comment">// k 是 TR 当前存入数字的下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(SR[i] &lt; SR[j]) &#123;</span><br><span class="line">            TR[k++] = SR[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TR[k++] = SR[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        TR[k++] = SR[i++];  <span class="comment">// 当前面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        TR[k++] = SR[j++];  <span class="comment">// 当后面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> TR[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &lt;= t; i++) &#123;</span><br><span class="line">        SR[i] = TR[i];  <span class="comment">// TR -》 SR，相当于 TR 所在的区间有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergesort2</span><span class="params">(<span class="keyword">int</span> SR[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        mergesort2(SR, left, mid);    <span class="comment">// 前一半序列继续进行归并排序</span></span><br><span class="line">        mergesort2(SR, mid+<span class="number">1</span>, right); <span class="comment">// 后一半序列同时进行归并排序</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 以上递归调用的结束条件是 left ≥ right，也就是分到只有一个数字进行归并排序的时候，一个序列只有一个数字，那么这个序列肯定是有序的</span></span><br><span class="line">        <span class="comment">// 以上都是属于“分”的阶段，目的是获得两个有序的数列。</span></span><br><span class="line">       </span><br><span class="line">        merge(SR, TR, left, mid, right);  <span class="comment">// 对这两个有序的数列，进行排序，变成一个同样大小但是有序的数列</span></span><br><span class="line">        </span><br><span class="line">        copy(SR, TR, left, right); <span class="comment">//将在TR中排序好的数列给SR，方便SR递归调用归并排序，因为每次两个归并排序的结果都是保存在TR中的，现在要进行下一步就必须在TR数列的基础上面=进行，所以我们把TR给SR</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++) &#123;</span><br><span class="line">        SR[i] = arc4random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, SR[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    mergesort2(SR, <span class="number">0</span>, n<span class="number">-1</span>); <span class="comment">// 升序排列</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,SR[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-时间复杂度和空间复杂度"><a href="#6-4-时间复杂度和空间复杂度" class="headerlink" title="6.4 时间复杂度和空间复杂度"></a>6.4 时间复杂度和空间复杂度</h4><p>显而易见，递归的次数为 m = log<sub>2</sub>n，合并操作的时间消耗是线性的，所以时间复杂度 T(n) 如下：</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-933f84923c81633c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归并排序时间复杂度"></center><p><font color="#cc0000">空间复杂度为 O(n)</font>。</p><h4 id="6-5-空间复杂度为-O-1-的归并排序"><a href="#6-5-空间复杂度为-O-1-的归并排序" class="headerlink" title="6.5 空间复杂度为 O(1) 的归并排序"></a>6.5 空间复杂度为 O(1) 的归并排序</h4><p>因为两个子数组已经有序，合并的步骤可以采取直接插入排序。</p><p>如此一来，可以将空间复杂度由 O(n) 降低至 O(1)，然而相对的时间复杂度则由 O(nlog<sub>2</sub>n) 升至 O(n<sup>2</sup>)。</p><h4 id="6-6-性能分析及优化"><a href="#6-6-性能分析及优化" class="headerlink" title="6.6 性能分析及优化"></a>6.6 性能分析及优化</h4><p>两种归并排序的算法，分别是采取了空间换时间，以及时间换空间的策略，性能各有优劣，但是通过分析可以得出以下特点：</p><ul><li>计算机对于<font color="#cc0000">频繁</font>开辟小数组空间的消耗，比开辟等价大的单个数组空间，代价要来的更大。</li><li>使用直接插入排序（从 1/2 处开始），由于拥有较小的最高次幂系数，其性能在长度 n 较小的时候，与 T(n) = O(log<sub>2</sub>n) 相差不大。</li></ul><p>根据以上两个性质，可以在归并排序中，设置一个阈值。超过这个给定的阈值，则采取空间换时间的策略；反之，采用时间换空间的策略，从而提高归并排序的效率。</p><h2 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h2><h4 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1 简介"></a>7.1 简介</h4><p>快速排序 Quick Sort，有时又称划分-交换排序（Partition-Exchange Sort）。</p><p>快速排序的主要思想是：<font color="#cc0000">选取一个数字，通过一次遍历，将这个数字放到其最终的位置，并且保证其最终位置的左侧都小于等于这个数字，其右侧都大于等于这个数字</font>。</p><p>与归并排序相同，是“<font color="#cc0000">分治法</font>”的又一个实现案例。快速排序中分治的思想体现在哪里呢？</p><p>①、把大问题分解成很多子问题（分区操作可以每次使得一位元素有序）</p><p>②、解决子问题（进行分区操作，每次使得一位元素有序）</p><p>③、所有子问题解决了，那么最大的问题也解决了。</p><p>一个优秀的快速排序实现，能比其竞争对手（归并排序、堆排序，都是时间复杂度为 O(nlog<sub>2</sub>n) 的排序算法），快 2-3 倍。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-9346a733700bb606.gif?imageMogr2/auto-orient/strip" alt="快速排序"></center><p>From Wikipedia: <a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><h4 id="7-2-快速排序的具体步骤"><a href="#7-2-快速排序的具体步骤" class="headerlink" title="7.2 快速排序的具体步骤"></a>7.2 快速排序的具体步骤</h4><p>快速排序的过程可以拆分成以下三个步骤：</p><ul><li>从数组中选择一个数字。</li><li>根据这个数字，对整个数组进行一次划分，即：通过一系列的交换，将这个数字放到其最终位置，并且保证其左侧的数字都小于等于它，右侧的数字都大于等于它。</li><li>对两侧的子数组进行递归。</li></ul><h4 id="7-3-快速排序的基本代码"><a href="#7-3-快速排序的基本代码" class="headerlink" title="7.3 快速排序的基本代码"></a>7.3 快速排序的基本代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> q = partition(<span class="built_in">array</span>, left, right);</span><br><span class="line">        sort(<span class="built_in">array</span>, left, q - <span class="number">1</span>);</span><br><span class="line">        sort(<span class="built_in">array</span>, q + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-划分-挖坑取数"><a href="#7-4-划分-挖坑取数" class="headerlink" title="7.4 划分 - 挖坑取数"></a>7.4 划分 - 挖坑取数</h4><p>快速排序的核心内容：<font color="#cc0000">如何对一个数组进行一次划分</font>（partition）。</p><p>这里先介绍一种常见的划分算法，我（原作者<a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a>）称之为“挖坑取数”，具体过程如下：</p><ul><li>将最左侧的数字作为待划分的数字，在快速排序中，称这个数字是划分的主元（pivot）。</li><li>从最右侧开始向前寻找，找到第一个比 pivot 小的数字（坑），交换 pivot。</li><li>此时“坑”的位置被交换到了最左侧，从最左侧的下一个位置开始向后寻找，找到第一个比 pivot 大的数字，交换 pivot。</li><li>循环从两侧“夹逼”找“坑”的步骤，直至 pivot 到它的最终位置。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[left];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> forward = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span>(forward &amp;&amp; <span class="built_in">array</span>[++i] &lt;= pivot &amp;&amp; i &lt; j);</span><br><span class="line">        <span class="keyword">while</span>(!forward &amp;&amp; <span class="built_in">array</span>[--j] &gt;= pivot &amp;&amp; i &lt; j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换 i、j 的内容</span></span><br><span class="line">        swap(<span class="built_in">array</span>, i, j);</span><br><span class="line">        </span><br><span class="line">        forward = !forward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> one, <span class="keyword">int</span> two)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[one];</span><br><span class="line">    arr[one] = arr[two];</span><br><span class="line">    arr[two] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中在“夹逼”过程中的最后一个判断 i &lt; j，是为了防止在夹逼的过程中出现左侧小于右侧的情况。</p><p>退出循环后 i = j，所以最后一次交换也不会影响结果。</p><h4 id="7-5-划分-挖坑取数-演示步骤"><a href="#7-5-划分-挖坑取数-演示步骤" class="headerlink" title="7.5 划分 - 挖坑取数 - 演示步骤"></a>7.5 划分 - 挖坑取数 - 演示步骤</h4><p>如果上面的说明过于抽象，这里演示一遍“挖坑取数”在数组 {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤：</p><ul><li>取 pivot = 3。</li><li>从最右侧 7 开始，向前寻找，找到第一个小于等于 3 的数字：2，交换两者位置，得到数组： {2, 5, 1, 9, 8, 6, 0, 3, 4, 7} 。</li><li>从最左侧的下一个数字 5 开始，向后寻找，找到第一个大于等于 3 的数字：5，交换两者位置，得到数组： {2, 3, 1, 9, 8, 6, 0, 5, 4, 7} 。</li><li>从最右侧的上一个数字 0 开始，向前寻找，找到第一个小于等于 3 的数字：0，交换两者位置，得到数组： {2, 0, 1, 9, 8, 6, 3, 5, 4, 7} 。</li><li>从最左侧的下一个数字 1 开始，向后寻找，找到第一个大于等于 3 的数字：9，交换两者位置，得到数组： {2, 0, 1, 3, 8, 6, 9, 5, 4, 7} 。</li><li>从最右侧的上一个数字 6 开始，向前寻找，找到第一个小于等于 3 的数字，没有找到，得到最终数组：{2, 0, 1, 3, 8, 6, 9, 5, 4, 7}。</li><li>此时，pivot = 3 的左侧数字全部小于等于 3，右侧数字全部大于等于 3，划分完成。</li></ul><h4 id="7-6-划分-快慢指针"><a href="#7-6-划分-快慢指针" class="headerlink" title="7.6 划分 - 快慢指针"></a>7.6 划分 - 快慢指针</h4><p>这里介绍另外一种划分算法，我（原作者）称之为“快慢指针”，具体过程如下：</p><ul><li>将最右侧的数字作为主元。</li><li>使用两个指针 faster 和 slower，faster 初始指向第一个数字，slower 初始时指向 faster 上一个数字。</li><li>从第一个数字开始遍历数组，快指针随着数组遍历的过程增大。</li><li>遍历数组时，每当数字小于等于 pivot 时，慢指针前进一位，然后交换快慢指针的位置，即慢指针指向的数字，永远小于等于 pivot。</li><li>当遍历结束时，0-慢指针的最终位置，都保证小于等于 pivot。快指针的最终位置，为 pivot 的前一位。</li><li>慢指针向前移动一位（指向的数字保证大于等于 pivot，只有指向 pivot 时，等号成立），交换 pivot 与此时慢指针的位置。</li></ul><center><br>    <img src="https://upload-images.jianshu.io/upload_images/5294842-54e5e96157b51ff0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">              <img src="https://upload-images.jianshu.io/upload_images/5294842-2a65e2da6be6333b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-6427ad9f79406cd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"> <img src="https://upload-images.jianshu.io/upload_images/5294842-51db182f928595df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-fa93dee0833380ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"> <img src="https://upload-images.jianshu.io/upload_images/5294842-1fb5445bff02d08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><br></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">array</span>[right];</span><br><span class="line">    <span class="comment">// 慢指针指向小于 pivot 的值的位置</span></span><br><span class="line">    <span class="keyword">int</span> slower = left - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> faster = left; faster &lt; right; ++faster) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[faster] &lt;= pivot) &#123;</span><br><span class="line">            <span class="comment">// 因为发现一个小于 pivot 的值，慢指针向右移一位，用于交换</span></span><br><span class="line">            slower++;</span><br><span class="line">            swap(<span class="built_in">array</span>, slower, faster);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终，慢指针右侧即为 pivot 的位置</span></span><br><span class="line">    swap(<span class="built_in">array</span>, slower + <span class="number">1</span>, right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slower + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-7-划分-快慢指针-演示步骤"><a href="#7-7-划分-快慢指针-演示步骤" class="headerlink" title="7.7 划分 - 快慢指针 - 演示步骤"></a>7.7 划分 - 快慢指针 - 演示步骤</h4><p>同样地，演示一遍“快慢指针”在数组 A = {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤：</p><ul><li>取 pivot = 7，快指针初始位置指向 3，faster = 0，慢指针初始位置在快指针的前一个位置，slower = -1。</li><li>第一个数，3 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 0，faster = 1。</li><li>第二个数，5 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 1，faster = 2。</li><li>第三个数，1 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 3。</li><li>第四个数，9 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 4。</li><li>第五个数，8 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 5。</li><li>第六个数，6 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 8, 9, 0, 2, 4, 7}，slower = 3，faster = 6。</li><li>第七个数，0 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 9, 8, 2, 4, 7}，slower = 4，faster = 7。</li><li>第八个数，2 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 8, 9, 4, 7}，slower = 5，faster = 8。</li><li>第九个数，4 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 4, 9, 8, 7}，slower = 6，faster = 9。</li><li>此时，快指针 faster = 9，不满足小于 right = 9 的条件，退出循环，将主元 pivot = 7，与慢指针的后一个数字 A[7] = 9，做一次交换，得到最终数组：{3, 5, 1, 6, 0, 2, 4, 7, 8, 9}，划分完成。</li></ul><h4 id="7-8-快速排序的时间复杂度和稳定性"><a href="#7-8-快速排序的时间复杂度和稳定性" class="headerlink" title="7.8 快速排序的时间复杂度和稳定性"></a>7.8 快速排序的时间复杂度和稳定性</h4><ul><li>最坏情况时间复杂度 T(n) = O(n<sup>2</sup>)。</li><li>最好情况时间复杂度 T(n) = O(nlog<sub>2</sub>n)。</li><li>平均情况时间复杂度 T(n) = O(nlog<sub>2</sub>n)。</li><li>最坏情况空间复杂度 T(n) = O(n)。</li><li><p>最好情况空间复杂度 T(n) = O(log<sub>2</sub>n)。</p></li><li><p>快速排序，始终只使用原来的数组空间 O(1)，真正消耗的空间，是由递归的深度决定的。</p></li><li><p>无论哪一种快速排序排序的划分算法，都会打破快速排序的稳定性。</p></li></ul><h4 id="7-9-代码"><a href="#7-9-代码" class="headerlink" title="7.9 代码"></a>7.9 代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_t</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">par</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> x = a[left]; <span class="comment">// 基准元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left + <span class="number">1</span>; j &lt;= right; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt;= x) &#123;  <span class="comment">// 比 x 小的换到左侧</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">swap_t</span>(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">swap_t</span>(a, left, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 轴位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = par(a, left, right);</span><br><span class="line">        QuickSort(a, left, r - <span class="number">1</span>);</span><br><span class="line">        QuickSort(a, r + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = arc4random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    QuickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"交换了 %d 次"</span>, count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">87</span>  <span class="number">71</span>  <span class="number">39</span>  <span class="number">75</span>  <span class="number">61</span>  </span><br><span class="line"><span class="number">39</span>  <span class="number">61</span>  <span class="number">71</span>  <span class="number">75</span>  <span class="number">87</span>  </span><br><span class="line">交换了 <span class="number">8</span> 次</span><br></pre></td></tr></table></figure><p>随机选择元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> n 5</span></span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_t</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">par</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> x = a[left];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = left + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt;= x) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">swap_t</span>(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">swap_t</span>(a, left, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 生成随机的基准元素下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Random</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arc4random() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用随机的基准元素进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Randomizedpar</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = Random(left, right);</span><br><span class="line">    <span class="keyword">swap_t</span>(a, left, i); <span class="comment">// 第一个和第 i 个交换，相当于有了一个随机基准元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> par(a, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RandomizedQuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = Randomizedpar(a, left, right);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d到%d之间的随机数：%d\n"</span>, left, right, r);</span><br><span class="line">        </span><br><span class="line">        RandomizedQuickSort(a, left, r - <span class="number">1</span>);</span><br><span class="line">        RandomizedQuickSort(a, r + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(; i&lt; n; i++) &#123;</span><br><span class="line">        a[i] = arc4random() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d  "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    RandomizedQuickSort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d  "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-10-快速排序的性能瓶颈与优化策略"><a href="#7-10-快速排序的性能瓶颈与优化策略" class="headerlink" title="7.10 快速排序的性能瓶颈与优化策略"></a>7.10 快速排序的性能瓶颈与优化策略</h4><p>详情见：<a href="https://www.cnblogs.com/jing-an-feng-shao/p/9865644.html" target="_blank" rel="noopener">排序算法杂谈（五）关于快速排序的优化策略分析</a></p><h2 id="八、学习文章"><a href="#八、学习文章" class="headerlink" title="八、学习文章"></a>八、学习文章</h2><p><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/5951431.html" target="_blank" rel="noopener">排序算法(一) 冒泡排序</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/5956672.html" target="_blank" rel="noopener">排序算法(二) 选择排序</a><br><a href="https://www.cnblogs.com/idorax/p/6537412.html" target="_blank" rel="noopener">常见排序算法导读(3)[简单选择排序]</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/6165094.html" target="_blank" rel="noopener">排序算法(三) 直接插入排序</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/6169690.html" target="_blank" rel="noopener">排序算法(四) 希尔排序</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/9017120.html" target="_blank" rel="noopener">排序算法（五）堆排序</a><br><a href="https://blog.csdn.net/hjl_heart/article/details/80024865" target="_blank" rel="noopener">使用减治法求解堆排序</a><br><a href="https://blog.csdn.net/xiaoxiaoxuewen/article/details/7570621/" target="_blank" rel="noopener">堆排序原理及算法实现（最大堆）</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> &amp; <a href="https://www.cnblogs.com/jing-an-feng-shao/p/9038915.html" target="_blank" rel="noopener">排序算法（六）归并排序</a><br><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> <a href="https://www.cnblogs.com/jing-an-feng-shao/p/9069091.html" target="_blank" rel="noopener">排序算法（七）快速排序</a><br><a href="https://www.cnblogs.com/yinbiao/p/8805233.html" target="_blank" rel="noopener">快速排序算法分析和实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、冒泡排序&quot;&gt;&lt;a href=&quot;#一、冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;一、冒泡排序&quot;&gt;&lt;/a&gt;一、冒泡排序&lt;/h2&gt;&lt;h4 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计策略</title>
    <link href="http://yoursite.com/2019/08/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/08/01/算法设计策略/</id>
    <published>2019-08-01T14:21:48.000Z</published>
    <updated>2019-08-01T14:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h2><h4 id="1-1-基本思想"><a href="#1-1-基本思想" class="headerlink" title="1.1 基本思想"></a>1.1 基本思想</h4><blockquote><p>将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，<font color="#cc0000">分而治之</font>。</p></blockquote><p>能用分治法的基本特征：</p><p>①、问题缩小到一定规模容易解决</p><p>②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想）</p><p>③、分解而成的小问题在解决之后要可以合并</p><p>④、子问题是相互独立的，即子问题之间没有公共的子问题</p><font color="#cc0000">第 ③ 条是能分治的关键</font>。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。<br><br>如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。<br><br>分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。<br><br>根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。<br><br>#### 1.2 分治步骤<br><br>①、分解成很多子问题<br><br>②、解决这些子问题<br><br>③、将解决的子问题合并从而解决整个大问题<br><br>化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。<br><br>它的一般的算法设计模式如下：<br><br>Divide-and-Conquer(P)<br><br>1.   if |P|≤n0<br>2.   then return(ADHOC(P))<br>3.   将 P 分解为较小的子问题 P1, P2, …, Pk<br>4.   for i←1 to k<br>5.   do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi<br>6.   T ← MERGE(y1,y2,…,yk) △ 合并子问题<br>7.   return(T)<br><br><br>#### 1.3 分类<br><br>根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形：<br><br>1.   原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可；<br>2.   原始问题的解需要由各个子问题的解再经过综合处理得到。<br><br>#### 1.4 效果<br><br>适当运用分治策略往往可以<font color="#cc0000">较快地缩小问题求解的范围</font>，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。<br><br>分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好<font color="#cc0000">符合递归的特性</font>。<br><br>因此，计算机算法中的分治策略往往与递归联系在一起。<br><br>#### 1.5 算法的典型应用<br><br>    ①、MAXMIN问题<br><br>    ②、二分搜索<br><br>    ③、归并排序<br><br>    ④、寻找第 K 小的元素<br><br>    ⑤、大整数的乘法<br><br>    ⑥、Strassen 矩阵乘法<br><br>    ⑦、快速排序<br><br>    ⑧、二叉树遍历<br><br>    ⑨、棋盘覆盖<br><br>    ⑩、线性时间选择<br><br>最接近点对问题<br><br>循环赛日程表<br><br>汉诺塔。。。<br><br>#### 1.6 依据分治法设计程序时的思维过程<br><br>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。<br><br>①、一定是先找到最小问题规模时的求解方法；<br>②、然后考虑随着问题规模增大时的求解方法；<br>③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。<br><br><br>文章：<a href="https://blog.csdn.net/effective_coder/article/details/8697789" target="_blank" rel="noopener">分治算法详解</a><br><br><br>## 二、减治<br><br>#### 2.1 基本思想<br><br>减治技术利用了一种关系：<font color="#cc0000">一个问题给定实例的解和同样问题较小实例的解之间的关系</font>。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡）<br><br>有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫<font color="#cc0000">增量法</font>。<br><br>一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。<br><br>#### 2.2 分类<br><br>减治法有 3 种主要的变种：<br><br>1.   减去一个常量<br>2.   减去一个常数因子<br>3.   减去的规模是可变的<br><br>#### 2.3 减去一个常量<br><br>每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。<br><br>函数 f(n) = a<sup>n</sup> 可以用一递归定义来计算<br><br>f(n) = f(n-1) * a   <font color="#067500">如果 n &gt; 1</font><p>f(n) = a          <font color="#067500">如果 n = 1</font></p><p>虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！</p><h4 id="2-4-减去常量因子"><a href="#2-4-减去常量因子" class="headerlink" title="2.4 减去常量因子"></a>2.4 减去常量因子</h4><p>每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。</p><p>计算 a<sup>n</sup> 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 a<sup>n/2</sup> 的值；它们之间有着明显的关系： a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>。</p><p>a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>                       n 是正偶数</p><p>a<sup>n</sup> = (a<sup>(n-1)/2</sup>)<sup>2</sup> * a     n 是大于 1 的奇数，先提出一个 a 来再减半</p><p>a<sup>n</sup> = a               n = 1</p><p>上式递归根据所做的乘法次数来度量效率，该算法属于 <font color="#cc0000">O(log n)</font>;</p><p>因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。</p><h4 id="2-5-减可变规模"><a href="#2-5-减可变规模" class="headerlink" title="2.5 减可变规模"></a>2.5 减可变规模</h4><p>每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法</p><h4 id="2-6-算法思想的典型应用"><a href="#2-6-算法思想的典型应用" class="headerlink" title="2.6 算法思想的典型应用"></a>2.6 算法思想的典型应用</h4><p>减去一个常量：</p><pre><code>①、插入排序③、深度优先查找④、广度优先查找⑤、拓扑排序（源删除法对无环有向图进行拓扑排序）⑥、生成排列⑦、生成子集</code></pre><p>减去常量因子：</p><pre><code>①、折半查找②、假币问题③、俄式乘法④、约瑟夫斯问题</code></pre><p>减可变规模</p><pre><code>①、插值查找、二叉查找树②、欧几里得算法，随着不断求余，n 越来越小</code></pre><h2 id="三、分治减治区别"><a href="#三、分治减治区别" class="headerlink" title="三、分治减治区别"></a>三、分治减治区别</h2><p>分治法：求解多个子问题（每个子问题都需要求解），<font color="#cc0000">合并</font>子问题的解。</p><p>减治法：求解一个子问题（子问题只需要求解一次），<font color="#cc0000">扩展</font>子问题的解。</p><p>求 a<sup>n</sup>。</p><p>分治法：a<sup>(n/2)</sup> * a<sup>(n/2)</sup> 则左右两个 a<sup>(n/2)</sup> 均需要求解，所以时间复杂度为 O(n)。<br>减治法：(a<sup>(n/2)</sup>)<sup>2</sup> 则只需要求 a<sup>(n/2)</sup> 再平方即可，所以时间复杂度为 O(lgn)。</p><p>也就是说<strong>分治法</strong>是分解的部分需要进行分开的单独计算（需要计算两遍），而<strong>减治法</strong>则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量<strong>。</strong></p><h2 id="四、变治"><a href="#四、变治" class="headerlink" title="四、变治"></a>四、变治</h2><p>基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据<font color="#cc0000">对问题实例的变换方式</font>，变治思想有 3 种主要类型：</p><ul><li>变换为同样问题的一个更简单或者更方便的实例：<strong>实例化简</strong>；</li><li>变换为同样实例的不同表现：<strong>改变表现</strong>；</li><li>变换为另一个问题的实例， 这种问题的算法是已知的：<strong>问题化简</strong>。</li></ul><p>基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。</p><h4 id="4-1-实例化简"><a href="#4-1-实例化简" class="headerlink" title="4.1 实例化简"></a>4.1 实例化简</h4><pre><code>①、检验数组中元素的唯一性（预排序）②、模式计算（预排序）③、AVL 树</code></pre><h4 id="4-2-改变表现"><a href="#4-2-改变表现" class="headerlink" title="4.2 改变表现"></a>4.2 改变表现</h4><pre><code>①、2-3 树、2-3-4 树（二叉排序树）②、堆和堆排序（利用最大/小堆总是找到最大/小值）③、霍纳法则（多项式的计算）④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组）</code></pre><h4 id="4-3-问题化简"><a href="#4-3-问题化简" class="headerlink" title="4.3 问题化简"></a>4.3 问题化简</h4><pre><code>①、背包问题（线性规划）</code></pre><h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往<font color="#cc0000">不是相互独立的</font>。这种情况下若用分治法会对一些子问题进行<font color="#cc0000">多次求解</font>，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。</p><p>动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质：</p><ol><li><p>最优子结构性质</p><p> 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。</p><p> 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。</p></li><li><p>子问题重叠性质</p><p> 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。</p></li></ol><p>用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法：</p><p>①、自底向上递归法</p><p>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>②、自顶向下递归法（即备忘录法）</p><p>利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。</p><p>当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。</p><p>文章：<a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="noopener">动态规划：从新手到专家</a></p><h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单<font color="#cc0000">更直接效率更高</font>的算法：贪心法。</p><p>贪心法总是做出在<font color="#cc0000">当前</font>看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。</p><p>贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质：</p><ol><li><p>贪心选择性质</p><p> 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。</p><p> 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。</p></li><li><p>最优子结构性质</p><p> 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。</p></li></ol><p>贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。</p><h2 id="七、回溯"><a href="#七、回溯" class="headerlink" title="七、回溯"></a>七、回溯</h2><p>回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。</p><p>回溯法通常的解题步骤如下：</p><p>①、定义问题的解空间。</p><p>②、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。</p><p>③、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。</p><p>用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h)</p><p>用回溯法解题时，常会遇到以下两类典型的解空间树：</p><p>(1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><p>回溯法中的剪枝函数通常分为两类：</p><p>(1)、用约束函数在指定节点处剪去不满足约束的子树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、用限界函数在指定节点处剪去得不到最优解的子树，例如<a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><h2 id="八、分支限界"><a href="#八、分支限界" class="headerlink" title="八、分支限界"></a>八、分支限界</h2><p>回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。</p><p>分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。</p><h2 id="九、学习文章"><a href="#九、学习文章" class="headerlink" title="九、学习文章"></a>九、学习文章</h2><p><a href="https://www.cnblogs.com/laifeiyao/" target="_blank" rel="noopener">姚来飞的博客</a> &amp; <a href="https://www.cnblogs.com/laifeiyao/p/3476258.html" target="_blank" rel="noopener">常见的算法设计策略</a></p><p><a href="https://www.cnblogs.com/lsgxeva/p/7800564.html" target="_blank" rel="noopener">算法设计之五大常用算法设计方法总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、分治&quot;&gt;&lt;a href=&quot;#一、分治&quot; class=&quot;headerlink&quot; title=&quot;一、分治&quot;&gt;&lt;/a&gt;一、分治&lt;/h2&gt;&lt;h4 id=&quot;1-1-基本思想&quot;&gt;&lt;a href=&quot;#1-1-基本思想&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>简单算法</title>
    <link href="http://yoursite.com/2019/07/31/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/07/31/简单算法/</id>
    <published>2019-07-31T15:24:20.000Z</published>
    <updated>2019-07-31T15:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、交换-A-和-B"><a href="#1、交换-A-和-B" class="headerlink" title="1、交换 A 和 B"></a>1、交换 A 和 B</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.中间变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.加法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a + b; </span><br><span class="line">   b = a - b;</span><br><span class="line">   a = a - b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.异或（相同为0，不同为1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">   b = a ^ b;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、求最大公约数"><a href="#2、求最大公约数" class="headerlink" title="2、求最大公约数"></a>2、求最大公约数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1.直接遍历法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCommonDivisor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 2.辗转相除法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCommonDivisor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(a % b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展：最小公倍数 = (a * b)/最大公约数</span></span><br></pre></td></tr></table></figure><h4 id="3、文章"><a href="#3、文章" class="headerlink" title="3、文章"></a>3、文章</h4><p><a href="https://www.jianshu.com/u/033641990ba6" target="_blank" rel="noopener">iOS开发_小迷糊</a> &amp; <a href="https://www.jianshu.com/p/1f9e00abc958" target="_blank" rel="noopener">iOS面试题：算法与数据结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、交换-A-和-B&quot;&gt;&lt;a href=&quot;#1、交换-A-和-B&quot; class=&quot;headerlink&quot; title=&quot;1、交换 A 和 B&quot;&gt;&lt;/a&gt;1、交换 A 和 B&lt;/h4&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 项目</title>
    <link href="http://yoursite.com/2019/07/31/iOS%20%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2019/07/31/iOS 项目/</id>
    <published>2019-07-31T07:45:38.339Z</published>
    <updated>2019-08-02T03:42:37.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Apple开发者账号"><a href="#一、Apple开发者账号" class="headerlink" title="一、Apple开发者账号"></a>一、Apple开发者账号</h2><h4 id="1-1-开发者账号类型"><a href="#1-1-开发者账号类型" class="headerlink" title="1.1 开发者账号类型"></a>1.1 开发者账号类型</h4><ul><li>个人级</li><li>公司级</li><li>企业级</li></ul><p>公司和企业的可多人协作。</p><p>在苹果的开发者平台登录后，可在 <code>People</code> 界面邀请其他人员协作开发，邀请的人需要注册一个 appleId 账号，并且可以设置开发人员的权限。</p><p><img src="http://pugqga7mf.bkt.clouddn.com/People.png" alt></p><h4 id="1-2-辨别账号类型"><a href="#1-2-辨别账号类型" class="headerlink" title="1.2 辨别账号类型"></a>1.2 辨别账号类型</h4><ol><li><p>个人级</p><p> 账户的 Apple Developer Program 下方只有 <code>Certificates，identifiers &amp; Profiles</code> 和 <code>App Store Connect</code> 两个图标。</p><p> <img src="http://pugqga7mf.bkt.clouddn.com/Personal.png" alt></p></li></ol><ol start="2"><li><p>公司级</p><p> 账户的 Apple Developer Program 下方包含 <code>People</code>、<code>Certificates，identifiers &amp; Profiles</code> 和 <code>App Store Connect</code> 三个图标。</p><blockquote><p>图标一：邀请其他开发人员的入口</p><p>图标二：开发者证书、App ID 和描述文件生成的入口</p><p>图标三：将 APP 上传到 App Store 的入口</p></blockquote><p> <img src="http://pugqga7mf.bkt.clouddn.com/Company.png" alt></p></li></ol><ol start="3"><li><p>企业级</p><p> 账户的 Apple Developer <font color="#cc0000">Enterprise</font> Program 下方有<code>People</code>、<code>Certificates，identifiers &amp; Profiles</code> 两个图标，第一个图标邀请其他开发人员的入口，第二个图标是开发者证书、App ID和描述文件生成的入口。</p><p> <img src="http://pugqga7mf.bkt.clouddn.com/Enterprise.png" alt></p></li></ol><h4 id="1-3-账号对比"><a href="#1-3-账号对比" class="headerlink" title="1.3 账号对比"></a>1.3 账号对比</h4><ol><li><p>个人（Individual）</p><ul><li>99 美元/年  </li><li>只能上架到 App Store</li><li>最大支持 100 台设备   </li><li><p>1 人使用</p><p>“个人”开发者可以申请<font color="#cc0000">升级</font>成“公司”，通过拨打苹果公司客服电话（400-6701-855）进行咨询办理。</p></li></ul></li><li><p>公司（Company）</p><ul><li>99美元/年</li><li>只能上架到 App Store</li><li>最大支持 100 台设备</li><li><p>多人协作</p><p>允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为 4 种级别的权限。</p><p>申请时需要填写公司的邓白氏码（DUNS Number）。</p></li></ul></li><li><p>企业（Enterprise）</p><ul><li>299美元/年</li><li>不能上架到 App Store，只能企业内部使用。通过 item-services 分发来下载</li><li>不限制设备数</li><li><p>多人协作</p><p>允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为4种级别的权限。</p><p>申请时需要填写公司的邓白氏码（DUNS Number）。</p><p>只能企业内部使用，否则有被<font color="#cc0000">封号</font>的风险。</p></li></ul></li><li><p>总结</p><ul><li><p>个人级和公司级只能上架 App Store 供用户下载，企业级不能上架 App Store，只能放在自己的服务器或者三方平台；</p><p>  个人/公司级账号可以将<font color="#cc0000">开发环境</font>的包上传到自己的服务器，或者第三方平台。首先在开发者账号添加最多 100 个手机的 UUID，创建开发 developer 证书和描述文件，将它两下载到电脑上，双击安装，在 Xcode 选择开发证书打包。这种可调式（Debug）包的有效期也是一年，一年内需要重新创建证书，并更新 ipa 包，否则 APP 将闪退。注意：每次添加设备 UUID 需要重新生成描述文件。    </p></li><li><p>企业级账号，每年至少重新打包 ipa 一次，更新 ipa 包中的证书信息，证书的有效期是一年，一年不更新，APP将闪退，无法进入。个人/公司级别的没有限制，只要成功上架到 App Store，如果没有特殊情况，理论可以放到苹果公司倒闭也不用去更新。</p></li><li><p>安装企业级账号分发的包后，需要去设置中信任 APP，系统级限制，无法跳过。个人/公司级没有该限制。</p></li><li><p>个人/公司必须经过苹果的人工审核才能在 App Store 上架，而企业级发布到自己服务器或者第三方平台是不需要审核的。</p></li></ul></li></ol><h2 id="二、名词介绍"><a href="#二、名词介绍" class="headerlink" title="二、名词介绍"></a>二、名词介绍</h2><h4 id="2-1-开发者证书"><a href="#2-1-开发者证书" class="headerlink" title="2.1 开发者证书"></a>2.1 开发者证书</h4><p>总共有两种类型：</p><ul><li>Developer（开发证书）</li><li>Distribution（发布证书）</li></ul><p><img src="http://pugqga7mf.bkt.clouddn.com/Certificates.png" alt></p><p>不论是真机调试，还是上传到 appstore 都是需要的，是一个基证书，用来证明自己开发者身份的。</p><h4 id="2-2-App-ID"><a href="#2-2-App-ID" class="headerlink" title="2.2 App ID"></a>2.2 App ID</h4><blockquote><p>是一个 APP 的唯一标示，相当于人的身份证号</p></blockquote><center><img src="http://pugqga7mf.bkt.clouddn.com/Identifiers.png" alt></center><ul><li>Description 是一个 App ID 的描述，可以随便</li><li>App ID Prefix 苹果自动填了，可以看出，它是一个团队的 ID Suffix</li><li>App ID Suffix 有两个选项：<ul><li>Explicit App ID : 一个明确的 App ID，什么意思呢？可以这么来解释：我们做项目时的Bundle Identifier (Bundle ID)是用来标示我们的 app 的。我们的 App ID 也是用来标示我们的app 的。这两个有什么联系呢？Explicit App ID 就是要我们确定一个唯一的 Bundle ID，用来标示我们的 app，使它有一个<font color="#cc0000">固定的</font>身份。可以发现，当提交应用到苹果时，如果我们一开始没写 Explicit App ID，苹果会自动帮我们生成一个与我们发布时填的一样的 Bundle ID 到我们的 App ID 中。填写 Explicit App ID 的格式为：com.xxx.yyy。</li><li>Wildcard App ID : 一个通配符的 App ID。这个 App ID 能够在所有能够匹配的应用中使用。填写 WildcardApp ID 的格式为：com.xxx.*。</li></ul></li></ul><p>手机安装 app 时，会先查找是否已有相同 App ID 的 app，如果没有，则直接进行安装；如果已有，则进行覆盖安装。</p><h4 id="2-3-CSR"><a href="#2-3-CSR" class="headerlink" title="2.3 CSR"></a>2.3 CSR</h4><blockquote><p>在苹果开发者中心生成证书时需要一个 CSR（证书签名请求）文件。</p></blockquote><p>当创建 CSR 时，电脑系统实际上会生成公钥和私钥对。<font color="#cc0000">CSR 包含公钥</font>。</p><center><img src="http://pugqga7mf.bkt.clouddn.com/CSRContent.png" alt></center><p>Apple 使用该公钥来制作证书。证书或多或少是一种发布公钥的方式以及关于该密钥的一些相关信息，并且验证发布实体，表示该信息是有效的。</p><p>由于每个证书都有自己的公钥 - 私钥对，因此推送证书、开发发证书和发布证书都可以使用不同的 CSR，每个证书用于验证和保护该特定项目。</p><p>生成 CSR 文件步骤：</p><center><br>    <img src="http://pugqga7mf.bkt.clouddn.com/KeyAccess.png" alt><br>    <img src="http://pugqga7mf.bkt.clouddn.com/CSR.png" alt><br>    <img src="http://pugqga7mf.bkt.clouddn.com/CSR2.png" alt><br></center><ol><li>用户电子邮件地址随便填写，并不一定非要填写邮件格式，无实际作用</li><li>常用名字使用默认的就可以，也可以修改</li><li>选择存储到磁盘。</li><li>选择继续，保存到指定位置即可。最终得到一个 <code>CertificateSigningRequest.certSigningRequest</code> 文件，也就是 CSR 文件。该文件后缀名不要更改，文件名可自由指定。</li></ol><p>CSR文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字。</p><center><img src="http://pugqga7mf.bkt.clouddn.com/P12CSR.png" alt></center><h4 id="2-4-cer"><a href="#2-4-cer" class="headerlink" title="2.4 .cer"></a>2.4 .cer</h4><blockquote><p>在苹果开发者中心生成的证书，导出后就是 .cer 文件。.cer 证书仅包含公钥。</p></blockquote><center><img src="http://pugqga7mf.bkt.clouddn.com/CreateCer.png" alt></center><p>提交 CSR 文件后就会生成一个 cer 证书，有效期为一年。</p><p>证书不可轻易删除，可能会造成相应的 Provisioning Profiles 失效，尤其是企业级的发布证书，删除后已经安装在手机上的 APP 将会闪退。如果是一个团队大家都在用，把这个证书删除了，会导致别人的描述文件失效。</p><h4 id="2-5-p12"><a href="#2-5-p12" class="headerlink" title="2.5 .p12"></a>2.5 .p12</h4><blockquote><p>.p12证书可能既包含公钥也包含私钥。</p></blockquote><p>双击安装下载后的 .cer 文件，都可以在<code>钥匙串访问</code>工具中导出 .p12 文件。</p><p>为什么要导出.p12文件？</p><p>开发证书和发布证书是有数量限制的，当超过数量后再也申请不了。</p><p>多台电脑开发程序时，没必要生成很多的证书，导出证书生成的 .p12 文件，供给所有的 mac 设备使用，使新设备不需要在苹果开发者网站重新申请开发和发布证书，就能使用。</p><p>点击 .p12 文件加入钥匙串中，使我们的电脑<font color="#cc0000">具备开发的证明</font>。</p><p>注意：一般 .p12 文件是给别人使用的，本机必须已经有一个带秘钥的证书才可以生成.p12文件。</p><h4 id="2-6-描述文件"><a href="#2-6-描述文件" class="headerlink" title="2.6 描述文件"></a>2.6 描述文件</h4><blockquote><p>Profiles 将 App ID、开发者证书、硬件 Device 绑定到一块儿。</p></blockquote><center><img src="http://pugqga7mf.bkt.clouddn.com/Mobile.png" alt></center><p>在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在描述文件中添加真机的 UDID。</p><h4 id="2-7-邓白氏码"><a href="#2-7-邓白氏码" class="headerlink" title="2.7 邓白氏码"></a>2.7 邓白氏码</h4><blockquote><p>邓氏编码（D-U-N-S® Number，是 Data Universal Numbering System的缩写）。它是一个独一无二的 9 位数字全球编码系统，相当于企业的身份识别码，被广泛应用于企业识别、商业信息的组织及整理。可以帮助识别和迅速定位全球 2.4 亿家企业的信息。</p></blockquote><h2 id="三、打包"><a href="#三、打包" class="headerlink" title="三、打包"></a>三、打包</h2><h4 id="3-1-payload"><a href="#3-1-payload" class="headerlink" title="3.1 payload"></a>3.1 payload</h4><p>操作步骤：</p><ol><li><p>选中 target -&gt; edit Scheme，修改 run 操作的 Build Configuration 是 budeg/release。</p> <center><img src="http://pugqga7mf.bkt.clouddn.com/SchemeRun.png" alt></center></li><li><p>真机运行工程，在左侧工程目录 -&gt; Products 找到 .app 文件，show in Finder。</p> <center><img src="http://pugqga7mf.bkt.clouddn.com/DemoApp.png" alt></center></li><li><p>桌面生成一个名为 Payload 的空文件夹，将 .app 文件拖入其中。</p></li><li><p>压缩 Payload 文件夹，修改后缀名为 .ipa，此时就可以将包上传 fir.im 网站，进行提测。</p> <center><img src="http://pugqga7mf.bkt.clouddn.com/Payload.png" alt></center></li></ol><h4 id="3-2-Archive"><a href="#3-2-Archive" class="headerlink" title="3.2 Archive"></a>3.2 Archive</h4><ol><li><p>常规打包方式</p><p> 运行设备选择 <code>Generic iOS Device</code> 或者真机，顶部 Xcode 导航栏 -&gt; Product -&gt; Archive。</p></li><li><p>命令行使用 xcodebuild 自动打包</p><p> ①、clean 工程</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd Desktop/CYKJ/CYKJMain/CYKJMain/</span><br><span class="line"></span><br><span class="line">$ xcodebuild clean -project CYKJMain.xcodeproj -scheme CC -configuration Release</span><br><span class="line"></span><br><span class="line">$ xcodebuild clean -workspace CYKJMain.xcworkspace -scheme CC -configuration Release</span><br></pre></td></tr></table></figure><p> 如果工程使用了 pod，选择 <code>-workspace</code>，否则使用 <code>-project</code>。</p><p> 上面的命令中：</p><blockquote><p>-project CYKJMain.xcodeproj : 编译项目名称  </p><p>-workspace CYKJMain.xcworkspace : 编译工作空间名称  </p><p>-scheme CC : scheme 名称</p><p>-configuration Release : (Debug/Release)</p></blockquote><p> clean 成功：</p> <center><img src="http://pugqga7mf.bkt.clouddn.com/XCodeBuildClean.png" alt></center><p> ②、archive 导出 .xcarchive 文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild archive -project CYKJMain.xcodeproj -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive</span><br><span class="line"></span><br><span class="line">$ xcodebuild archive -workspace CYKJMain.xcworkspace -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive</span><br></pre></td></tr></table></figure><p> 上面的命令中：</p><blockquote><p>-archivePath /Users/cykj/Desktop/cc.xcarchive : 导出 .xcarchive 文件的目录以及文件名称</p></blockquote><p> archive 成功：</p> <center><br>     <img src="http://pugqga7mf.bkt.clouddn.com/XCodeBuildArchive.png" alt><br>     <img src="http://pugqga7mf.bkt.clouddn.com/CCArchive.png" alt><br> </center><p> ③、导出 ipa 包</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -exportArchive -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc -exportFormat ipa -exportProvisioningProfile <span class="string">"developmentProfile"</span></span><br></pre></td></tr></table></figure></li></ol><pre><code>上面的命令中:  &gt; -archivePath /Users/cykj/Desktop/cc.xcarchive : 刚刚导出的 .xcarchive 文件的目录  &gt;&gt; -exportPath /Users/cykj/Desktop/cc : 将要导出的 ipa 文件的目录以及文件名&gt;&gt; -exportFormat ipa : 导出为ipa文件&gt;&gt; -exportProvisioningProfile &quot;developmentProfile&quot; : 工程配置的 profile 文件的名称&lt;font color=#cc0000&gt;``xcodebuild: error: invalid option ‘-exportFormat’``&lt;/font&gt;报错原因：Xcode8 之后，对之前的 exportFormat 方式不再支持。解决方法：不使用 exportFormat ipa 引入 ``exportOptionsPlist``。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVEPATH&#125;/$&#123;TARGET_NAME&#125;.xcarchive&quot; -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125;</span><br></pre></td></tr></table></figure>直接使用 xcodebuild -help 查看 exportOptionsPlist。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Available keys for -exportOptionsPlist:</span><br><span class="line"></span><br><span class="line">compileBitcode : Bool</span><br><span class="line"></span><br><span class="line">  For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">embedOnDemandResourcesAssetPacksInBundle : Bool</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.</span><br><span class="line"></span><br><span class="line">iCloudContainerEnvironment</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options: Development and Production. Defaults to Development.</span><br><span class="line"></span><br><span class="line">manifest : Dictionary</span><br><span class="line"></span><br><span class="line">For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.</span><br><span class="line"></span><br><span class="line">method : String</span><br><span class="line"></span><br><span class="line">Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.</span><br><span class="line"></span><br><span class="line">onDemandResourcesAssetPacksBaseURL : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&apos;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.</span><br><span class="line"></span><br><span class="line">teamID : String</span><br><span class="line"></span><br><span class="line">The Developer Portal team to use for this export. Defaults to the team used to build the archive.</span><br><span class="line"></span><br><span class="line">thinning : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.</span><br><span class="line"></span><br><span class="line">uploadBitcode : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">uploadSymbols : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include symbols? Defaults to YES.</span><br></pre></td></tr></table></figure>plist 格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">&lt;string&gt;xxxx&lt;/string&gt;</span><br><span class="line">&lt;key&gt;method&lt;/key&gt;</span><br><span class="line">&lt;string&gt;app-store&lt;/string&gt;</span><br><span class="line">&lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">&lt;false/&gt;</span><br><span class="line">&lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;com.xxx.yyy&lt;/key&gt;</span><br><span class="line">&lt;string&gt;&#123;iOS Provisioning Profiles Name&#125;&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>命令行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -exportArchive -exportOptionsPlist /Users/cykj/Desktop/cc.plist -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc</span><br></pre></td></tr></table></figure>导出 ipa 成功：&lt;center&gt;![](http://pugqga7mf.bkt.clouddn.com/XCodeBuildIPA.png)&lt;/center&gt;&lt;font color=#cc0000&gt;``Error Domain=IDEProfileLocatorErrorDomain Code=4 &quot;No &quot;iOS App Development&quot;``&lt;/font&gt;问题原因：plist 文件中提供的 mehtod 的 value 不对。</code></pre><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/u/fd1e679c3ac1" target="_blank" rel="noopener">Benjamin丶</a> &amp; <a href="https://www.jianshu.com/p/8190cf4a8172" target="_blank" rel="noopener">Apple开发者账号介绍及证书配置说明</a></p><p><a href="https://www.jianshu.com/u/80f9260b9fb7" target="_blank" rel="noopener">PersonChen_QJ</a> &amp; <a href="https://www.jianshu.com/p/da6663c8fd5f" target="_blank" rel="noopener">iOS申请邓白氏编码图文流程</a></p><p><a href="https://cloud.tencent.com/developer/ask/205801" target="_blank" rel="noopener">用于创建开发人员或分发证书和推送证书的CSR（证书签名请求）文件是否必须相同？</a></p><p><a href="http://www.sohu.com/a/324460196_120174355" target="_blank" rel="noopener">2019年最新苹果企业开发者账号创建证书完整流程</a></p><p><a href="https://www.jianshu.com/u/bb0d2c0a0880" target="_blank" rel="noopener">MrCoderLin</a> &amp; <a href="https://www.jianshu.com/p/87a1eba7caeb" target="_blank" rel="noopener">Payload文件压缩法打包ipa</a></p><p><a href="https://www.jianshu.com/u/ced5bf319bfe" target="_blank" rel="noopener">咖啡绿茶1991</a> &amp; <a href="https://www.jianshu.com/p/347056c3f49c" target="_blank" rel="noopener">iOS命令行自动打包(archive)</a></p><p><a href="https://blog.csdn.net/zhangxiweicaochen/article/details/72730355" target="_blank" rel="noopener">iOS自动化打包</a></p><p><a href="https://blog.csdn.net/yuanmengong886/article/details/78214978" target="_blank" rel="noopener">Xcode9 xcodebuild 命令行打包遇到的坑与解决方案</a></p><p><a href="https://www.jianshu.com/p/36d2c6d65aa7" target="_blank" rel="noopener">一键打包完整Shell脚本xcodebuild archive</a></p><p><a href="https://www.jianshu.com/p/1c9ad924c79b" target="_blank" rel="noopener">iOS 如何填App Store Connect信息</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Apple开发者账号&quot;&gt;&lt;a href=&quot;#一、Apple开发者账号&quot; class=&quot;headerlink&quot; title=&quot;一、Apple开发者账号&quot;&gt;&lt;/a&gt;一、Apple开发者账号&lt;/h2&gt;&lt;h4 id=&quot;1-1-开发者账号类型&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 响应链</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>http://yoursite.com/2019/05/23/iOS 响应链/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T03:41:49.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、UIResponder"><a href="#一、UIResponder" class="headerlink" title="一、UIResponder"></a>一、UIResponder</h2><blockquote><p>app 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。</p></blockquote><p>UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。</p><p>响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。</p><p>有时候可能会通过 UIResponder 来查找控件的父视图。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过遍历 UIView 上的响应链来查找当前顶部 vc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)firstVC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> * next = <span class="keyword">self</span>; next; next = next.superview) &#123;</span><br><span class="line">        <span class="built_in">UIResponder</span> * nextResponder = [next nextResponder];</span><br><span class="line">        <span class="keyword">if</span> ([nextResponder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)nextResponder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过遍历 button 上的响应链来查找 cell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (MyCell *)buttonTaped:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIResponder</span> * responder = button.nextResponder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([responder isKindOfClass:[MyCell <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            MyCell * cell = (MyCell *)responder;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responder = responder.nextResponder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、事件的第一响应者"><a href="#二、事件的第一响应者" class="headerlink" title="二、事件的第一响应者"></a>二、事件的第一响应者</h2><p>事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。</p><ul><li><p>Touch event 第一响应者是触摸事件产生的 view</p></li><li><p>Press event 第一响应者是焦点响应者。</p></li><li><p>Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象</p></li></ul><p>⚠️注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。</p><p>控件直接与它相关的 target 对象使用 action 消息通信。</p><p>当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。</p><p>如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。</p><h2 id="三、事件的分发和传递"><a href="#三、事件的分发和传递" class="headerlink" title="三、事件的分发和传递"></a>三、事件的分发和传递</h2><ol><li>当iOS程序中发生触摸事件后，系统会<font color="#cc0000">将事件加入到 UIApplication 管理的一个任务队列</font>中；</li><li>UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。</li><li>UIWindow 将事件向下分发，即 UIView。</li><li>UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。</li><li>遍历子控件，重复以上两步。</li><li>如果没有找到，那么自己就是事件处理者。</li><li>如果自己不能处理，那么不做任何处理。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ec30446fe33b1976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其中 UIView <font color="#cc0000">不接受事件处理</font>的情况主要有以下三种</p><ol><li>alpha &lt; 0.01</li><li>userInteractionEnabled = NO</li><li>hidden ＝ YES</li></ol><p>这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果<font color="#cc0000">父视图不接受事件处理，那么子视图也不能接收事件</font>。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。</p><h2 id="四、hitTest-withEvent"><a href="#四、hitTest-withEvent" class="headerlink" title="四、hitTest:withEvent:"></a>四、hitTest:withEvent:</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return 本次点击事件需要的最佳 View</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><p>UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。</p><p>⚠️注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。</p><p>当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-bff8ab2f91a231b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。</p><blockquote><p>如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢?</p></blockquote><p>事件传递给窗口或控件的后，就调用 <font color="#cc0000">hitTest:withEvent:</font> 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到<font color="#cc0000">找到最合适的 view 或者废弃事件</font>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ①、判断当前控件能否接收事件</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden == <span class="literal">YES</span> || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ②、判断触摸点在不在当前控件内</span></span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event] == <span class="literal">NO</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ②、倒序遍历自己的子控件</span></span><br><span class="line">   <span class="built_in">NSInteger</span> count = <span class="keyword">self</span>.subviews.count;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">UIView</span> * childView = <span class="keyword">self</span>.subviews[i];</span><br><span class="line">       <span class="comment">// 把当前控件上的坐标系转换成子控件上的坐标系</span></span><br><span class="line">       <span class="built_in">CGPoint</span> childP = [<span class="keyword">self</span> convertPoint:point toView:childView];</span><br><span class="line"></span><br><span class="line">       <span class="built_in">UIView</span> * fitView = [childView hitTest:childP withEvent:event];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (fitView) &#123; </span><br><span class="line">           <span class="keyword">return</span> fitView;  <span class="comment">// 找到了最合适的 view</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 循环结束，表示没有比自己更合适的 view</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。</p></li><li><p><font color="#cc0000">从后往前遍历</font>子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f9515b7b8aab8425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。</p><p>如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。</p><p>如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。</p><p>如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。</p><p>如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。</p><h2 id="四、pointInside-withEvent"><a href="#四、pointInside-withEvent" class="headerlink" title="四、pointInside:withEvent:"></a>四、pointInside:withEvent:</h2><p>1、判断触摸点是否在视图内。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  判断一个点是否落在范围内</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure><p>如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢?</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-df8b1e917c015d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ul><li>扩大响应范围。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and decrease its size by `(2*dx, 2*dy)'. </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">       CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bounds = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-10</span>, <span class="number">-10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不规则的点击区域</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  改变图片的点击范围</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 控件范围宽度 +40，高度 +40</span></span><br><span class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-20</span>, <span class="number">-20</span>);</span><br><span class="line">    <span class="built_in">UIBezierPath</span> * path1 = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="number">-20</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">120</span>)];</span><br><span class="line">    <span class="built_in">UIBezierPath</span> * path2 = [<span class="built_in">UIBezierPath</span> bezierPathWithRect:<span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.frame.size.width - <span class="number">20</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">120</span>)];</span><br><span class="line">    <span class="keyword">if</span> (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; <span class="built_in">CGRectContainsPoint</span>(bounds, point))&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;  <span class="comment">// 如果在 path 区域内返回 YES</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：</p><ol><li><p>在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。</p></li><li><p>不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。</p></li><li>在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。</li></ol><h2 id="五、响应者链"><a href="#五、响应者链" class="headerlink" title="五、响应者链"></a>五、响应者链</h2><p>响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。</p><p>在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。</p><p>1、改变响应链</p><p>可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。</p><ul><li><p>UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。</p></li><li><p>UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。</p><p>-UIWindow 下一个响应者为 UIApplication 对象。</p></li><li><p>UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。</p></li></ul><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc" target="_blank" rel="noopener">Using Responders and the Responder Chain to Handle Events</a></p><p><a href="http://www.cocoachina.com/ios/20160113/14896.html" target="_blank" rel="noopener">iOS开发 - 事件传递响应链</a></p><p><a href="https://www.jianshu.com/p/4155c9ffe1a8" target="_blank" rel="noopener">iOS响应链（Responder Chain）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、UIResponder&quot;&gt;&lt;a href=&quot;#一、UIResponder&quot; class=&quot;headerlink&quot; title=&quot;一、UIResponder&quot;&gt;&lt;/a&gt;一、UIResponder&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;app 使用响应者对象接收
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 页面流畅技巧</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%95%85%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/05/23/iOS 页面流畅技巧/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-11T11:56:08.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、屏幕显示图像原理"><a href="#一、屏幕显示图像原理" class="headerlink" title="一、屏幕显示图像原理"></a>一、屏幕显示图像原理</h2><p>首先明确两个概念：水平同步信号、垂直同步信号。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-920b300dcddfb38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。</p><p>CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1cc88c02ec5e957b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="二、卡顿产生的原因"><a href="#二、卡顿产生的原因" class="headerlink" title="二、卡顿产生的原因"></a>二、卡顿产生的原因</h2><p><font color="#cc0000">如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃</font>，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。</p><h2 id="三、CPU-资源消耗的原因和解决方案"><a href="#三、CPU-资源消耗的原因和解决方案" class="headerlink" title="三、CPU 资源消耗的原因和解决方案"></a>三、CPU 资源消耗的原因和解决方案</h2><h4 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h4><p>对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以：</p><p>①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适；</p><p>②、如果对象不涉及 UI 操作，尽量放到后台线程去创建；</p><p>③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用；</p><p>④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去；</p><p>⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p><h4 id="3-2-对象调整"><a href="#3-2-对象调整" class="headerlink" title="3.2 对象调整"></a>3.2 对象调整</h4><p>对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer：</p><p>①、CALayer 内部没有属性，当调用属性方法时，它内部是<font colro="#cc0000">通过运行时</font> resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源；</p><p>②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改；</p><p>③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><h4 id="3-3-对象销毁"><a href="#3-3-对象销毁" class="headerlink" title="3.3 对象销毁"></a>3.3 对象销毁</h4><p>当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * tmp = <span class="keyword">self</span>.arr_data;</span><br><span class="line"><span class="keyword">self</span>.arr_data = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="3-4-对象布局"><a href="#3-4-对象布局" class="headerlink" title="3.4 对象布局"></a>3.4 对象布局</h4><p>在后台线程提前计算好视图布局、并对视图的布局进行缓存。</p><p>不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。</p><h4 id="3-5-Autolayout"><a href="#3-5-Autolayout" class="headerlink" title="3.5 Autolayout"></a>3.5 Autolayout</h4><p>这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但<font color="#cc0000">对于复杂视图来说常会产生严重的性能问题</font>。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。</p><h4 id="3-6-文本计算"><a href="#3-6-文本计算" class="headerlink" title="3.6 文本计算"></a>3.6 文本计算</h4><p>如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。</p><h4 id="3-7-文本渲染"><a href="#3-7-文本渲染" class="headerlink" title="3.7 文本渲染"></a>3.7 文本渲染</h4><p>屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。</p><p>显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，<font color="#cc0000">用 TextKit 或最底层的 CoreText 对文本异步绘制</font>，尽管麻烦但优势强大：</p><p>①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；</p><p>②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。</p><h4 id="3-8-图片解码"><a href="#3-8-图片解码" class="headerlink" title="3.8 图片解码"></a>3.8 图片解码</h4><p>用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。</p><p>该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是<font color="#cc0000">在后台线程先把图片绘制到 CGBitmapContext 中</font>，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p><h4 id="3-9-图像的绘制"><a href="#3-9-图像的绘制" class="headerlink" title="3.9 图像的绘制"></a>3.9 图像的绘制</h4><p>是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、GPU-资源消耗原因和解决方案"><a href="#四、GPU-资源消耗原因和解决方案" class="headerlink" title="四、GPU 资源消耗原因和解决方案"></a>四、GPU 资源消耗原因和解决方案</h2><p>GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。</p><h4 id="4-1-纹理的渲染"><a href="#4-1-纹理的渲染" class="headerlink" title="4.1 纹理的渲染"></a>4.1 纹理的渲染</h4><p>所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。</p><p>当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。</p><p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。</p><h4 id="4-2-视图的混合（Composing）"><a href="#4-2-视图的混合（Composing）" class="headerlink" title="4.2 视图的混合（Composing）"></a>4.2 视图的混合（Composing）</h4><p>当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。</p><p>所以应当<font color="#cc0000">尽量减少视图数量和层次</font>，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。</p><p>也可以把多个视图预先渲染为一张图片来显示。</p><h4 id="4-3-图形的生成"><a href="#4-3-图形的生成" class="headerlink" title="4.3 图形的生成"></a>4.3 图形的生成</h4><p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。</p><p>当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。</p><p>对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。</p><p>最彻底的做法：<font color="#cc0000">把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性</font>。</p><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.jianshu.com/u/93bd6c9bc835" target="_blank" rel="noopener">幸运的芳1990</a> &amp; <a href="https://www.jianshu.com/p/bade6ce45b8b" target="_blank" rel="noopener">浅谈iOS页面流畅技巧</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、屏幕显示图像原理&quot;&gt;&lt;a href=&quot;#一、屏幕显示图像原理&quot; class=&quot;headerlink&quot; title=&quot;一、屏幕显示图像原理&quot;&gt;&lt;/a&gt;一、屏幕显示图像原理&lt;/h2&gt;&lt;p&gt;首先明确两个概念：水平同步信号、垂直同步信号。&lt;/p&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>isa 和 Class</title>
    <link href="http://yoursite.com/2019/05/23/isa%20%E5%92%8C%20Class/"/>
    <id>http://yoursite.com/2019/05/23/isa 和 Class/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T05:56:46.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Runtime-简介"><a href="#一、Runtime-简介" class="headerlink" title="一、Runtime 简介"></a>一、Runtime 简介</h2><p>Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，<font color="#cc0000">在编译阶段只是确定了要向接收者发送这条消息</font>，而接受者将要如何响应和处理这条消息，那就要由运行时来决定了。</p><p>C 语言中，函数的调用在编译期就会决定调用哪个函数。而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。</p><p>Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。</p><p>Objc 在三种层面上与 Runtime 系统进行交互：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b4ed02142f8f97fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p>1、通过 Objective-C 源代码</p><p>一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。</p><p>2、通过 Foundation 框架的 NSObject 类定义的方法</p><p>在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。</p><p>在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回对象的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (Class)<span class="keyword">class</span> OBJC_SWIFT_UNAVAILABLE(<span class="string">"use 'anObject.dynamicType' instead"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否是某个类的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象能否响应指定的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查对象是否实现了指定协议类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>在 NSObject 的类中还定义了一个方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定方法实现的地址 IMP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (IMP)methodForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure><p>3、通过对 Runtime 库函数的直接调用</p><p>关于库函数可以在 <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">Objective-C Runtime Reference</a> 中查看 Runtime 函数的详细文档。</p><p>关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。</p><p>具体设置如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-4a2ea408888ae8cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt></p><p>如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。</p><h2 id="二、NSObject-起源"><a href="#二、NSObject-起源" class="headerlink" title="二、NSObject 起源"></a>二、NSObject 起源</h2><p>与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自<a href="https://link.jianshu.com?t=http://opensource.apple.com//source/objc4/" target="_blank" rel="noopener">objc4-680</a></p><p>NSObject 的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Objc2.0 之前，objc_class 源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;  <span class="comment">// 指向成员变量列表的指针</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;  <span class="comment">// 指向方法列表指针的指针</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。</p><p>动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。</p><p>关于 Category，推荐 2 篇文章可以仔细研读：<a href="https://link.jianshu.com?t=http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>、<a href="https://link.jianshu.com?t=https://bestswifter.com/jie-he-category-gong-zuo-yuan-li-fen-xi-oc2-0-zhong-de-runtime/" target="_blank" rel="noopener">结合 Category 工作原理分析 OC2.0 中的 runtime</a></p><p>然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 <a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/objc-private.h.auto.html" target="_blank" rel="noopener">objc_private</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Object</span> </span>&#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1194012-06a854913380136c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/956/format/webp" alt></p><p>把源码的定义转化成类图，就是上图的样子。</p><p>从上述源码中，我们可以看到，<font color="#cc0000">Objective-C 对象都是 C 语言结构体实现的</font>，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。</p><p>objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。</p><p>objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论：</p><blockquote><p><font color="#cc0000">Objective-C 中类也是一个对象</font>。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。</p></blockquote><p>object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。</p><h4 id="2-1-isa"><a href="#2-1-isa" class="headerlink" title="2.1 isa"></a>2.1 isa</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line"><span class="meta"># if __arm64__</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;  <span class="comment">// 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化  </span></span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否有设置过关联对象，如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;  <span class="comment">// 是否有被弱引用指向过，如果没有，释放时会更快</span></span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中</span></span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>; <span class="comment">// 里面存储的值是引用计数 - 1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># elif __x86_64__</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;  </span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">44</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># else</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012581760/article/details/81230721" target="_blank" rel="noopener">isa 详解</a></p><p>在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 <font color="#cc0000">64</font> 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。</p><p>当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。</p><p>但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 <a href="https://link.jianshu.com?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a></p><p>在引入元类之后，类对象和对象查找方法的机制就完全统一了。</p><blockquote><p>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</p><p>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p></blockquote><p>meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。</p><p>对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-d7b097e86f9e488d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/625/format/webp" alt></p><p>实线是 super_class 指针，虚线是 isa 指针。</p><ol><li><p>Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。</p></li><li><p>每个 Class 都有一个 isa 指针指向唯一的 Meta class</p></li><li><p>Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。</p></li><li><p>每个 Meta class 的 isa 指针都指向 Root class（meta）。</p></li></ol><p>我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 <a href="https://link.jianshu.com?t=http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">iOS 程序 main 函数之前发生了什么</a></p><h6 id="2-1-1-isa-t-结构体的具体实现"><a href="#2-1-1-isa-t-结构体的具体实现" class="headerlink" title="2.1.1 isa_t 结构体的具体实现"></a>2.1.1 isa_t 结构体的具体实现</h6><p>接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="keyword">void</span> initIsa(Class cls <span class="comment">/*indexed=false*/</span>);</span><br><span class="line">    <span class="keyword">void</span> initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor);</span><br><span class="line">private:</span><br><span class="line">    <span class="keyword">void</span> initIsa(Class newCls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor);</span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 <a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/objc-object.h.auto.html" target="_blank" rel="noopener">objc_object</a>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># if __arm64__</span></span><br><span class="line"><span class="meta">#   define ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        uintptr_t indexed           : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_assoc         : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        uintptr_t magic             : <span class="number">6</span>;</span><br><span class="line">        uintptr_t weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        uintptr_t deallocating      : <span class="number">1</span>;</span><br><span class="line">        uintptr_t has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        uintptr_t extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       define RC_ONE   (1ULL<span class="meta-string">&lt;&lt;45)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_HALF  (1ULL&lt;&lt;18)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string"># elif __x86_64__</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MASK        0x00007ffffffffff8ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    struct &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t indexed           : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_assoc         : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_cxx_dtor      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t magic             : 6;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t weakly_referenced : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t deallocating      : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t has_sidetable_rc  : 1;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        uintptr_t extra_rc          : 8;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_ONE   (1ULL&lt;&lt;56)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#       define RC_HALF  (1ULL&lt;&lt;7)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#125;;</span></span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1194012-2f2760cc2bc4034e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-78ff71b4e40f616f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/829/format/webp" alt="6"></p><p>参数的说明：</p><ul><li>index</li></ul><blockquote><p>代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。</p></blockquote><p>在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。</p><p>在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。</p><font color="#cc0000">Tagged Pointer 的存在主要是为了节省内存</font>。我们知道，<font color="#cc0000">对象的指针大小一般是与机器字长有关</font>，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。<br><br>假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1f205ac1ee6d1db9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-c1a948684d801b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>关于 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer 技术</a>详细的，可以看上面链接那个文章。<br><br><em> has_assoc<br><br>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</em> has_cxx_dtor<br><br>表示该对象是否有 C++ 或者 Objc 的析构器<br><br><em> shiftcls<br><br>类的指针。arm64 架构中有 33 位可以存储类指针。<br><br>源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br><br>将当前地址右移三位的主要原因是用于<font color="#cc0000">将 Class 指针中无用的后三位清除减小内存的消耗</font>，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md#shiftcls" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a>这篇文章里面的 shiftcls 分析。</em> magic<br><br>判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。<br><br><em> weakly_referenced<br><br>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</em> deallocating<br><br>对象是否正在释放内存<br><br><em> has_sidetable_rc<br><br>判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。</em> extra_rc<br><br>存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。<br><br>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>关于 x86_64 的架构，具体可以看<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BB%8E%20NSObject%20%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E8%A7%A3%20isa.md" target="_blank" rel="noopener">从 NSObject 的初始化了解 isa</a>文章里面的详细分析。<br><br><br>#### 2.2 cache_t 的具体实现<br><br>继续看源码<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;      <span class="comment">// 分配用来缓存 bucket 的总数</span></span><br><span class="line">    mask_t _occupied;  <span class="comment">// 表明实际占用的缓存 bucket 的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint32_t;</span><br><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  uintptr_t;</span><br><span class="line"><span class="keyword">typedef</span> uintptr_t cache_key_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-3ab871ca22e8e5a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt><br><br>根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。<br><br>bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。<br><br>cache_t 中的 bucket_t <em>_buckets 其实就是一个散列表，用来存储 Method 的链表。<br><br>Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，<font color="#cc0000">因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%</font>。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。<br><br>#### 2.3 class_data_bits_t 的具体实现<br><br>源码实现：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-dfecb7c37d335fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_data_bits_t bits; <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><br><br>它为我们提供了便捷方法用于返回其中的 class_rw_t </em> 指针：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class_rw_t *data() &#123;</span><br><span class="line">    <span class="keyword">return</span> bits.data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly<br><br>在编译期，类的结构中的 class_data_bits_t <em>data 指向的是一个 class_ro_t </em> 指针：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-2dad1ac70ec7dac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>在运行时调用 realizeClass方法，会做以下 3 件事情：<br><br>1.  从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针<br><br>2.  初始化一个 class_rw_t 结构体<br><br>3.  设置结构体 ro 的值以及 flag<br><br><br>最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;   <span class="comment">// 方法名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">// Type Encoding 类型编码</span></span><br><span class="line">    IMP imp;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;<span class="keyword">const</span> method_t&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> method_t&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> operator() (<span class="keyword">const</span> method_t&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> method_t&amp; rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 <a href="https://link.jianshu.com?t=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a>。<br><br>IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。<br><br>整个运行时过程描述如下：<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-06da58b9bbe05c6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>更加详细的分析，请看<a href="https://link.jianshu.com?t=https://github.com/Draveness" target="_blank" rel="noopener">@Draveness</a> 的这篇文章<a href="https://link.jianshu.com?t=https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20ObjC%20%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84.md#%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-objc-%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">深入解析 ObjC 中方法的结构</a><br><br>到此，总结 objc_class 1.0 和 2.0 的差别。<br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-8b2987b38e6e5d2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><img src="https://upload-images.jianshu.io/upload_images/1194012-cd2c3afd17d40e9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><br>## 三、测试题<br><br>1. [self class] 与 [super class]<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br><br>self 和 super 的区别：<br><br>    self 是类的一个<font color="#cc0000">隐藏参数</font>，每个方法的实现的第一个参数即为 self。<br><br>　 super 并不是隐藏参数，它实际上只是一个“<font color="#cc0000">编译器标示符</font>”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。<br><br>在调用 [super class] 的时候，runtime 会去调用 <font color="#cc0000">objc_msgSendSuper</font> 方法，而不是 objc_msgSend。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_msgSendSuper(<span class="keyword">void</span> <span class="comment">/* struct objc_super *super, SEL op, ... */</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br>在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。<br><br>objc_msgSendSuper 的工作原理应该是这样的：<br><br>&gt; 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。<br><br>那么 objc_msgSendSuper 最后就转变成<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里是从父类开始 msgSend，而不是从本类开始。</span></span><br><span class="line">objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(<span class="keyword">class</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies an instance of a class.  这是类的一个实例</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于是实例调用，所以是减号方法</span></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。<br><br><br>2. isKindOfClass 与 isMemberOfClass<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span>@<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">         <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</span><br><span class="line">         <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>先来分析一下源码这两个函数的对象实现<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::getIsa() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) &#123;</span><br><span class="line">        uintptr_t slot = ((uintptr_t)<span class="keyword">this</span> &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;</span><br><span class="line">        <span class="keyword">return</span> objc_tag_classes[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ISA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>首先题目中 NSObject 和 Sark 分别调用了 class 方法。<br><br>+ (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去<font color="#cc0000">调用当前类的 obj-&gt;getIsa()</font>，最后在 <font color="#cc0000">ISA()</font> 方法中获得 meta class 的指针。<br><br>接着在 isKindOfClass 中有一个<font color="#cc0000">循环</font>，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。<br><br>[NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。<br><br>同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。<br><br>如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。<br><br>&gt; isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。<br><br>第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。<br><br><br>3. Class 与内存地址<br><br>下面的代码会？Compile Error / Runtime Crash / NSLog…?<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name's %@"</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br><br>这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？<br><br>首先需要谈谈隐藏参数 self 和 _cmd 的问题。<br><br>当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。<br><br>难点一：能不能调用 speak 方法？<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>]; </span><br><span class="line"><span class="keyword">void</span> *obj = &amp;cls;</span><br></pre></td></tr></table></figure><br><br>答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。<br><br>难点二：如果能调用 speak，会输出什么呢？<br><br>很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。<br><br>正确的答案会输出<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is &lt;ViewController: <span class="number">0x7ff6d9f31c50</span>&gt;</span><br></pre></td></tr></table></figure><br><br>内存地址每次运行都不同，但是前面一定是 ViewController。why？<br><br>我们把代码改变一下，打印更多的信息出来。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController = %@ , 地址 = %p"</span>, <span class="keyword">self</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark class = %@ 地址 = %p"</span>, cls, &amp;cls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@ 地址 = %p"</span>, obj, &amp;obj);</span><br><span class="line">    </span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    </span><br><span class="line">    Sark *sark = [[Sark alloc]init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark instance = %@ 地址 = %p"</span>,sark, &amp;sark);</span><br><span class="line">    </span><br><span class="line">    [sark speak];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我们把对象的指针地址都打印出来。输出结果：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ViewController = &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt; , 地址 = <span class="number">0x7fff543f5aa8</span></span><br><span class="line">Sark <span class="keyword">class</span> = Sark 地址 = <span class="number">0x7fff543f5a88</span></span><br><span class="line">Void *obj = &lt;Sark: <span class="number">0x7fff543f5a88</span>&gt; 地址 = <span class="number">0x7fff543f5a80</span></span><br><span class="line"></span><br><span class="line">my name is &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt;</span><br><span class="line"></span><br><span class="line">Sark instance = &lt;Sark: <span class="number">0x7fb570d20b10</span>&gt; 地址 = <span class="number">0x7fff543f5a78</span></span><br><span class="line">my name is (null)</span><br></pre></td></tr></table></figure><br><br><img src="//upload-images.jianshu.io/upload_images/1194012-c794987c90515f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt><br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_msgSendSuper2() takes the current search class, not its superclass.</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_msgSendSuper2(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><br><br>objc_msgSendSuper2 方法入参是一个 objc_super <em>super。<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><br><br>所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-75370b4b3f3e6c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。<br><br>在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。<br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1de5156e2caa715e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><br>从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。<br><br>至此，Objc 中的对象到底是什么呢？<br><br>实质：<font color="#cc0000">Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject<strong>，</strong>而对象的实例变量 void </font></em>ivar = &amp;obj + offset(N)<p>加深一下对上面这句话的理解，下面这段代码会输出什么？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ViewController = %@ , 地址 = %p"</span>, <span class="keyword">self</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *myName = <span class="string">@"halfrost"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark class = %@ 地址 = %p"</span>, cls, &amp;cls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Void *obj = %@ 地址 = %p"</span>, obj,&amp;obj);</span><br><span class="line">    </span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    </span><br><span class="line">    Sark *sark = [[Sark alloc]init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sark instance = %@ 地址 = %p"</span>,sark,&amp;sark);</span><br><span class="line">    </span><br><span class="line">    [sark speak];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ViewController = &lt;ViewController: <span class="number">0x7fff44404ab0</span>&gt; ,  地址  = <span class="number">0x7fff56a48a78</span></span><br><span class="line">Sark <span class="keyword">class</span> = Sark  地址  = <span class="number">0x7fff56a48a50</span></span><br><span class="line">Void *obj = &lt;Sark: <span class="number">0x7fff56a48a50</span>&gt;  地址 = <span class="number">0x7fff56a48a48</span></span><br><span class="line"></span><br><span class="line">my name is halfrost</span><br><span class="line"></span><br><span class="line">Sark instance = &lt;Sark: <span class="number">0x6080000233e0</span>&gt;  地址 = <span class="number">0x7fff56a48a40</span></span><br><span class="line">my name is (null)</span><br></pre></td></tr></table></figure><p>由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。</p><p>原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-86a075b8fd3adf92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my name is &lt;ViewController: <span class="number">0x7fb570e2ad00</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5294842-428635ce01f15146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/1194012-cccbecc99506dbe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。</p><p>LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：</p><blockquote><p>x/</p><p>n、f、u 是可选的参数。</p><p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</p><p>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。</p><p>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。</p><p>u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1194012-3111309aaef61c73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><p>我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。</p><p>这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。</p><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="noopener">一缕殇流化隐半边冰霜</a> &amp; <a href="https://www.jianshu.com/p/9d649ce6d0b8" target="_blank" rel="noopener">神经病院Objective-C Runtime入院第一天–isa和Class</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Runtime-简介&quot;&gt;&lt;a href=&quot;#一、Runtime-简介&quot; class=&quot;headerlink&quot; title=&quot;一、Runtime 简介&quot;&gt;&lt;/a&gt;一、Runtime 简介&lt;/h2&gt;&lt;p&gt;Runtime 又叫运行时，是一套底层的 C 语言 API，
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Runtime</title>
    <link href="http://yoursite.com/2019/05/23/Runtime/"/>
    <id>http://yoursite.com/2019/05/23/Runtime/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-07-12T08:00:41.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。<font color="#cc0000">函数标识与函数实现之间的关联可以动态修改</font>。</p><p><font color="#cc000">OC 把一些决定工作从编译链接推迟到运行时</font>，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。</p><p>Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事：</p><ol><li><p>封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。</p></li><li><p>传递消息，找出方法的最终执行代码。</p><p> ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）；  </p><p> ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发）</p></li></ol><blockquote><p>动态加载：<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="noopener">NSBundle</a>类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[receiver message];  </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)</span></span><br><span class="line">[receiver message:(<span class="keyword">id</span>)arg...]; </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...)</span></span><br></pre></td></tr></table></figure><p>Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。</p><p>当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p><p>Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。</p><h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><p>Objc 与 Runtime 相关：</p><p>①、通过 Objective-C 源代码<br>②、通过 Foundation 框架的 NSObject 类定义的方法<br>③、通过对 Runtime 库函数的直接调用</p><h4 id="2-1-Objective-C-源代码"><a href="#2-1-Objective-C-源代码" class="headerlink" title="2.1 Objective-C 源代码"></a>2.1 Objective-C 源代码</h4><p>多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。</p><h4 id="2-2-通过-Foundation-框架的-NSObject-类定义的方法"><a href="#2-2-通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="2.2 通过 Foundation 框架的 NSObject 类定义的方法"></a>2.2 通过 Foundation 框架的 NSObject 类定义的方法</h4><p>Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类）</p><p>NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。</p><p>一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如：</p><ul><li>-class 方法返回对象的类；</li><li>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中</li><li>-respondsToSelector: 检查对象能否响应指定的消息；</li><li>-conformsToProtocol: 检查对象是否实现了指定协议类的方法；</li><li>-methodForSelector: 返回指定方法实现的地址。</li></ul><h4 id="2-3-通过对-Runtime-库函数的直接调用"><a href="#2-3-通过对-Runtime-库函数的直接调用" class="headerlink" title="2.3 通过对 Runtime 库函数的直接调用"></a>2.3 通过对 Runtime 库函数的直接调用</h4><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。</p><p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。</p><h2 id="三、Runtime-相关的头文件"><a href="#三、Runtime-相关的头文件" class="headerlink" title="三、Runtime 相关的头文件"></a>三、Runtime 相关的头文件</h2><p>ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List.h</span><br><span class="line"><span class="built_in">NSObjCRuntime</span>.h</span><br><span class="line"><span class="built_in">NSObject</span>.h</span><br><span class="line">Object.h</span><br><span class="line">Protocol.h</span><br><span class="line">a.txt</span><br><span class="line">hashtable.h</span><br><span class="line">hashtable2.h</span><br><span class="line">message.h</span><br><span class="line">module.map</span><br><span class="line">objc-api.h</span><br><span class="line">objc-auto.h</span><br><span class="line">objc-<span class="keyword">class</span>.h</span><br><span class="line">objc-exception.h</span><br><span class="line">objc-load.h</span><br><span class="line">objc-runtime.h</span><br><span class="line">objc-sync.h</span><br><span class="line">objc.h</span><br><span class="line">runtime.h</span><br></pre></td></tr></table></figure><p>都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括：</p><h4 id="3-1-操作对象的类型的定义"><a href="#3-1-操作对象的类型的定义" class="headerlink" title="3.1 操作对象的类型的定义"></a>3.1 操作对象的类型的定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.  一个类型，代表着类定义中的一个方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an instance variable.  代表实例(对象)的变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents a category.  代表一个分类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C declared property.  代表OC声明的属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls = obj.class;</span><br><span class="line"><span class="comment">// NSLog(@"%s", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLE</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(cls);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br></pre></td></tr></table></figure><h4 id="3-2-函数的定义"><a href="#3-2-函数的定义" class="headerlink" title="3.2 函数的定义"></a>3.2 函数的定义</h4><blockquote><p>操作对象的方法一般以 object_ 开头<br>操作类的方法一般以 class_ 开头<br>操作类或对象的方法的方法一般以 method_ 开头<br>操作成员变量的方法一般以 ivar_ 开头<br>操作属性的方法一般以 property_ 开头<br>操作协议的方法一般以 protocol_ 开头</p><p>以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。</p></blockquote><p>根据以上的函数的前缀可以大致了解到层级关系。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 runtime 对当前的应用中加载的类进行打印</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Class * clsList = objc_copyClassList(&amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(clsList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、术语及其数据结构"><a href="#四、术语及其数据结构" class="headerlink" title="四、术语及其数据结构"></a>四、术语及其数据结构</h2><h4 id="4-1-SEL"><a href="#4-1-SEL" class="headerlink" title="4.1 SEL"></a>4.1 SEL</h4><p>它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，<font color="#cc0000">本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度</font>。它的数据结构是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;  <span class="comment">// An opaque type that represents a method selector.</span></span><br></pre></td></tr></table></figure><p>可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。</p><blockquote><p>注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p></blockquote><h4 id="4-2-id"><a href="#4-2-id" class="headerlink" title="4.2 id"></a>4.2 id</h4><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">struct</span> objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure><p>objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。</p><blockquote><p>注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。</p><p>Direct access to Objective-C’s isa is deprecated in favor of object_getClass()</p></blockquote><p><a href="http://lizhaoloveit.com/2014/05/11/KVO/" target="_blank" rel="noopener">KVO</a> 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。</p><h4 id="4-3-Class"><a href="#4-3-Class" class="headerlink" title="4.3 Class"></a>4.3 Class</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure><p>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">/*  父类  */</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;   </span><br><span class="line">    <span class="comment">/*  类名  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类的版本信息，默认为 0 */</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类信息，供运行时期使用的一些位标识。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;</span></span><br><span class="line"><span class="comment">         CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量大小（包括从父类继承下来的实例变量）*/</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员变量地址列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法地址列表，与 info 的一些标志位有关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists   OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 缓存最近使用的方法地址，用于提升效率 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 存储该类声明遵守的协议的列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;  </span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p><p>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解 Objective-C: Category</a>。</p><p>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p><p>值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。</p><blockquote><p>实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）；</p><p>类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。</p></blockquote><p>为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p><p>开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p><p>当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span>.class alloc];    <span class="comment">// [NSObject alloc]</span></span><br></pre></td></tr></table></figure><p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f45adc9fd1faea0b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Meta Class"></p><p>实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。</p><p>最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。</p><h4 id="4-4-Method"><a href="#4-4-Method" class="headerlink" title="4.4 Method"></a>4.4 Method</h4><p>代表类中某个方法的类型。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name            OBJC2_UNAVAILABLE;   <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable method_types       OBJC2_UNAVAILABLE;   <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp             OBJC2_UNAVAILABLE;   <span class="comment">// 方法实现</span></span><br><span class="line">&#125;   </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">*   method\_name 类型为 SEL</span><br><span class="line">*   method\_types 是个 <span class="keyword">char</span> 指针，存储方法的参数类型和返回值类型</span><br><span class="line">*   method\_imp 指向了方法的实现，本质是一个函数指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 4.5 Ivar</span></span><br><span class="line"></span><br><span class="line">表示成员变量的类型。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                           OBJC2_UNAVAILABLE;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                 OBJC2_UNAVAILABLE;  <span class="comment">// 占用空间</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-IMP"><a href="#4-6-IMP" class="headerlink" title="4.6 IMP"></a>4.6 IMP</h4><p>objc.h 中定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br></pre></td></tr></table></figure><p>它就是一个<font color="#cc0000">由编译器生成的函数指针，指向方法实现的首地址</font>。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p><p>如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p><p>你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p><h4 id="4-7-Cache"><a href="#4-7-Cache" class="headerlink" title="4.7 Cache"></a>4.7 Cache</h4><p>runtime.h 中定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">/* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实际占用cache buckets的总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Method _Nullable buckets[<span class="number">1</span>]                              OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。</p><p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p><h4 id="4-8-Property"><a href="#4-8-Property" class="headerlink" title="4.8 Property"></a>4.8 Property</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;  <span class="comment">// 这个更常用</span></span><br></pre></td></tr></table></figure><p>可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">protocol_copyPropertyList(Protocol * _Nonnull proto,</span><br><span class="line">                          <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。</p></blockquote><p>property_getName() 用来查找属性的名称，返回 c 字符串。<br>property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。<br>class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e2cb59d1344df2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象结构图"></p><h2 id="五、消息"><a href="#五、消息" class="headerlink" title="五、消息"></a>五、消息</h2><p>体会官方文档中的 messages aren’t bound to method implementations until Runtime。<font color="#cc0000">消息直到运行时才会与方法实现进行绑定</font>。</p><p>这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2d3464848b8f4fc2?imageMogr2/auto-orient/strip" alt="消息发送"></p><p>①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数；</p><p>②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</p><p>③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。</p><p>④、如果 cache 找不到就找类的方法列表中是否有对应的方法。</p><p>⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。</p><p>⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。</p><p>在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。</p><h4 id="5-1-方法中的隐藏参数"><a href="#5-1-方法中的隐藏参数" class="headerlink" title="5.1 方法中的隐藏参数"></a>5.1 方法中的隐藏参数</h4><blockquote><p>我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？</p></blockquote><p>其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。</p><p>当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p><ul><li>self 当前方法的对象指针，接受消息的对象</li><li>_cmd 当前方法的 SEL 指针，方法选择器</li></ul><p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p><p>这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p><p>这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体指明了消息应该被传递给特定的父类。</p><p>receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">25.082134</span>+<span class="number">0800</span> Demo[<span class="number">22838</span>:<span class="number">128408</span>] ViewController   <span class="comment">// 当前类</span></span><br></pre></td></tr></table></figure><h4 id="5-2-获取方法地址"><a href="#5-2-获取方法地址" class="headerlink" title="5.2 获取方法地址"></a>5.2 获取方法地址</h4><p>NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          [<span class="keyword">self</span> fail:<span class="literal">YES</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fail:(<span class="built_in">BOOL</span>)value</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">06</span>:<span class="number">22.683838</span>+<span class="number">0800</span> Demo[<span class="number">36187</span>:<span class="number">211037</span>] <span class="number">4.104993</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>) = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(fail:)];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">setter</span>(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fail:), <span class="literal">YES</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">05</span>:<span class="number">48.480498</span>+<span class="number">0800</span> Demo[<span class="number">36095</span>:<span class="number">209893</span>] <span class="number">3.751424</span></span><br></pre></td></tr></table></figure><p>虽然是更高效的调用方法，但这种做法很少用，除非是<font color="#cc0000">需要持续大量重复调用某个方法</font>的情况，才会选择使用，<font color="#cc0000">以免消息发送泛滥</font>。</p><blockquote><p>注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</p></blockquote><h2 id="六、动态方法解析"><a href="#六、动态方法解析" class="headerlink" title="六、动态方法解析"></a>六、动态方法解析</h2><p>如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure><p>这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p><p>Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p><blockquote><p>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。</p></blockquote><h2 id="七、消息转发"><a href="#七、消息转发" class="headerlink" title="七、消息转发"></a>七、消息转发</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f7a92a32f8cc7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p><p>①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步；</p><p>②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步；</p><p>③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步；</p><p>④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。</p><h4 id="7-1-重定向"><a href="#7-1-重定向" class="headerlink" title="7.1 重定向"></a>7.1 重定向</h4><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(xxx:))&#123;</span><br><span class="line">          <span class="keyword">return</span> otherObj;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。</p><h4 id="7-2-转发"><a href="#7-2-转发" class="headerlink" title="7.2 转发"></a>7.2 转发</h4><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [otherObj methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param  anInvocation  封装了原始的消息和消息的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 判断 otherObj 对象是否实现了方法</span></span><br><span class="line">     <span class="keyword">if</span> ([otherObj respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:otherObj];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p><blockquote><p>参数 anInvocation 是从哪来的？</p><p>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</p></blockquote><p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p><p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p><blockquote><p>forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。</p></blockquote><h4 id="7-3-转发和多继承"><a href="#7-3-转发和多继承" class="headerlink" title="7.3 转发和多继承"></a>7.3 转发和多继承</h4><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-70cda98ab8c42661?imageMogr2/auto-orient/strip" alt></p><p>在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p><h4 id="7-4-转发与继承"><a href="#7-4-转发与继承" class="headerlink" title="7.4 转发与继承"></a>7.4 转发与继承</h4><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p><p>如果判断上图中的 Warrior 对象是否能响应 negotiate 消息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。</p><p>如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* Here, test whether the aSelector message can     *</span></span><br><span class="line"><span class="comment">           * be forwarded to another object and whether that  *</span></span><br><span class="line"><span class="comment">           * object can respond to it. Return YES if it can.  */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。</p><p>如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。</p><h2 id="八、应用场景"><a href="#八、应用场景" class="headerlink" title="八、应用场景"></a>八、应用场景</h2><h4 id="8-1-获取属性-成员变量列表"><a href="#8-1-获取属性-成员变量列表" class="headerlink" title="8.1 获取属性/成员变量列表"></a>8.1 获取属性/成员变量列表</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的定义了一个成员变量和两个属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">         <span class="built_in">CGFloat</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"Person"</span>);   <span class="comment">// Class cls = Person.class;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取成员变量数组</span></span><br><span class="line">    Ivar * ivarList = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取成员变量名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivarList[i]); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivarName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性数组</span></span><br><span class="line">    objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ptyName = property_getName(ptyList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ptyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905326</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905486</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905616</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905745</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905877</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] age</span><br></pre></td></tr></table></figure><p>从这里就可以看出 @property 做了三件事：</p><p>①、生成一个带下划线的成员变量<br>②、生成这个成员变量的 set 方法<br>③、生成这个成员变量的 get 方法</p><p>因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> * name;  <span class="comment">// 只读属性</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"job"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.690815</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691025</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691159</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691308</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] age</span><br></pre></td></tr></table></figure><p>当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。</p><blockquote><p>一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好?</p></blockquote><p>大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。</p><blockquote><p>在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？</p></blockquote><p>首先要了解 setValue:forKeyPath: 方法的底层实现：</p><p>①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]<br>②、查找有没有成员变量 _XX，如果有 _XX = value；<br>③、查找有没有成员变量 XX，如果有 XX = value；<br>④、如果都没有找到，直接报错。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSUnknownKeyException', </span><br><span class="line">reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: </span><br><span class="line"><span class="keyword">this</span> <span class="keyword">class</span> is not key value coding-compliant <span class="keyword">for</span> the key name.<span class="string">'</span></span><br></pre></td></tr></table></figure><p>首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。</p><p>另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc；</p><p>使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。</p><p>要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> * timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> * thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AModel * a;  <span class="comment">// 自定义对象</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     objc_property_t * propertyList = class_copyPropertyList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_getAttributes(propertyList[i]));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839596</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSTimer"</span>,W,N,V_timer</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839692</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSThread"</span>,&amp;,N,V_thread</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839771</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"AModel"</span>,R,N,V_a</span><br></pre></td></tr></table></figure><p>通过 property_getAttributes() 方法获取属性的参数。</p><h4 id="8-2-KVC字典转模型"><a href="#8-2-KVC字典转模型" class="headerlink" title="8.2 KVC字典转模型"></a>8.2 KVC字典转模型</h4><p>获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。</p><p>为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程：</p><p>①、遍历字典里面的所有 key，取出 key；<br>②、取出 key 的 value，即 dict[key]；<br>③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。</p><p>因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。</p><p>因此使用逐一为属性赋值的方法进行 KVC：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">     Class cls = Person.class;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     Person * person = [[Person alloc] init];</span><br><span class="line">     <span class="built_in">NSDictionary</span> * dict = @&#123;  <span class="string">@"name"</span> : <span class="string">@"Tom"</span>, <span class="string">@"age"</span> : @<span class="number">19</span>, <span class="string">@"height"</span>: @<span class="number">175</span> &#125;;</span><br><span class="line">    </span><br><span class="line">     Ivar * ivars = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * clsName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:clsName];</span><br><span class="line">          <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];  <span class="comment">// 去掉'_'</span></span><br><span class="line">          [person setValue:dict[key] forKey:key];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">42</span>:<span class="number">16.964474</span>+<span class="number">0800</span> Demo[<span class="number">6425</span>:<span class="number">1574210</span>] height:<span class="number">175.0000</span>，name:Tom，age:<span class="number">19</span>，time:(null)</span><br></pre></td></tr></table></figure><p>使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。</p><p>但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。</p><blockquote><p>setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。</p></blockquote><p>解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。</p><p>runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">     <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">     <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * coding = ivar_getTypeEncoding(ivars[i]); <span class="comment">// 获取类型</span></span><br><span class="line">     <span class="built_in">NSString</span> * strCode = [<span class="built_in">NSString</span> stringWithUTF8String:coding];</span><br><span class="line">     <span class="keyword">id</span> value = dict[key];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ([strCode isEqualToString:<span class="string">@"f"</span>]) &#123;  <span class="comment">// 判断类型是否是 float</span></span><br><span class="line">          value = @(<span class="number">0.0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     [person setValue:value forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>method_getTypeEncoding() 函数可以获取到方法类型编码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     Method m = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(<span class="keyword">do</span>:at:on:));</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, method_getTypeEncoding(m));</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)<span class="keyword">do</span>:(<span class="built_in">NSString</span> *)something at:(<span class="keyword">char</span>)place on:(<span class="keyword">int</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">42</span>:<span class="number">30.891829</span>+<span class="number">0800</span> Demo[<span class="number">38588</span>:<span class="number">270099</span>] B32@<span class="number">0</span>:<span class="number">8</span>@<span class="number">16</span>c24i28</span><br></pre></td></tr></table></figure><p>property_getAttributes() 函数可以获取到属性的参数。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="noopener">Declared Properties</a></p><h4 id="8-3-NSCoding-归档和解档"><a href="#8-3-NSCoding-归档和解档" class="headerlink" title="8.3 NSCoding 归档和解档"></a>8.3 NSCoding 归档和解档</h4><p>获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">          <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];  <span class="comment">// 取出 key 对应的 value</span></span><br><span class="line">          [aCoder encodeObject:value forKey:key];   <span class="comment">// 编码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">               <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">               <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];  <span class="comment">// 解码</span></span><br><span class="line">               [<span class="keyword">self</span> setValue:value forKey:key];  <span class="comment">// 设置 key 对应的 value</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-交换方法实现"><a href="#8-4-交换方法实现" class="headerlink" title="8.4 交换方法实现"></a>8.4 交换方法实现</h4><p>交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">          Method orginalMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">          Method swizzleMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(my_imageNamed:));</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//方法交换</span></span><br><span class="line">          method_exchangeImplementations(orginalMethod, swizzleMethod);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)my_imageNamed:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> my_imageNamed:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是</p><p>①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。<br>②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。</p><p>任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。</p><h4 id="8-5-类-对象的关联对象"><a href="#8-5-类-对象的关联对象" class="headerlink" title="8.5 类/对象的关联对象"></a>8.5 类/对象的关联对象</h4><p>关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参数 1 : 关联到对象</span></span><br><span class="line"><span class="comment">   参数 2 : 关联的 key，可以是任意类型</span></span><br><span class="line"><span class="comment">   参数 3 : 被关联的对象</span></span><br><span class="line"><span class="comment">   参数 4 : 关联引用的规则</span></span><br><span class="line"><span class="comment">           enum &#123;</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_ASSIGN = 0,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY_NONATOMIC = 3,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN = 01401,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY = 01403</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> value = objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br></pre></td></tr></table></figure><h4 id="8-6-动态添加方法，拦截未实现的方法"><a href="#8-6-动态添加方法，拦截未实现的方法" class="headerlink" title="8.6 动态添加方法，拦截未实现的方法"></a>8.6 动态添加方法，拦截未实现的方法</h4><p>每个类都有继承自 NSObject 的两个类方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure><p>一个适用于类方法，一个适用于对象方法。</p><p>在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmd</span></span><br><span class="line"><span class="keyword">void</span> method(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"doSomething"</span>]) &#123;       </span><br><span class="line">     </span><br><span class="line">          <span class="comment">/* 参数 4 : const char *types 方法的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             如果想要再增加参数，就可以从实现的第三个参数算起：</span></span><br><span class="line"><span class="comment">                 class_addMethod(self, sel, method, "v@:@"); // 多一个对象类型参数增加了 @</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 void method(id self, SEL _cmd, NSString * name) &#123;  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             返回值：YES if the method was found and added to the receiver, otherwise NO.</span></span><br><span class="line"><span class="comment">          */</span> </span><br><span class="line">          class_addMethod(<span class="keyword">self</span>, sel, method, <span class="string">"v@:"</span>);  <span class="comment">// 为 sel 指定实现为 method</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-7-动态创建一个类"><a href="#8-7-动态创建一个类" class="headerlink" title="8.7 动态创建一个类"></a>8.7 动态创建一个类</h4><p>动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> sayFunction(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> param) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld岁的%@在%@说%@"</span>, [object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_age"</span>)) integerValue], object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>)), object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"schoolName"</span>)), param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 Student 类。参数 1 : 父类   参数 2 : 类名   参数 3 : 通常为 0</span></span><br><span class="line">    Class StudentClass = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">"Student"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型</span></span><br><span class="line">    <span class="comment">// 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用</span></span><br><span class="line">    <span class="keyword">if</span> (class_addIvar(StudentClass, <span class="string">"schoolName"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="string">"@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加成员变量成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 NSString * _name 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_name"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">    <span class="comment">// 添加 int _age 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_age"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为 Student 类添加方法 "v@:" 这种写法见参数类型连接</span></span><br><span class="line">    SEL sel = sel_registerName(<span class="string">"sayFunction:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(StudentClass, sel, (IMP)sayFunction, <span class="string">"v@:@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加方法成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册这个类到 runtime 系统中就可以使用了</span></span><br><span class="line">    objc_registerClassPair(StudentClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用创建的类</span></span><br><span class="line">    <span class="keyword">id</span> student = [[StudentClass alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给刚刚添加的变量赋值</span></span><br><span class="line">    <span class="comment">// object_setInstanceVariable(student, "schoolName", (void *)&amp;str);在ARC下不允许使用</span></span><br><span class="line">    [student setValue:<span class="string">@"清华大学"</span> forKey:<span class="string">@"schoolName"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KVC 动态改变实例变量</span></span><br><span class="line">    [student setValue:<span class="string">@"Tom"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从类中获取成员变量Ivar</span></span><br><span class="line">    Ivar ageIvar = class_getInstanceVariable(StudentClass, <span class="string">"_age"</span>);</span><br><span class="line">    <span class="comment">// 为peopleInstance的成员变量赋值</span></span><br><span class="line">    object_setIvar(StudentClass, ageIvar, @<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息</span></span><br><span class="line">    objc_msgSend(student, <span class="string">"sayFunction:"</span>, <span class="string">@"你好~"</span>); </span><br><span class="line">    <span class="comment">// [student performSelector:sel withObject:@"你好~"]; // 动态调用未显式在类中声明的方法</span></span><br><span class="line">    </span><br><span class="line">    student = <span class="literal">nil</span>;</span><br><span class="line">    StudentClass = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    objc_disposeClassPair(StudentClass);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d8496fe34a524c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt></p><h2 id="九、健壮的实例变量-Non-Fragile-ivars"><a href="#九、健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="九、健壮的实例变量(Non Fragile ivars)"></a>九、健壮的实例变量(Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。</p><p>当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b75736c89991ff2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ddfa1eb170bae83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a4a0f676708f0a30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="健壮的实例变量自动偏移"></p><p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p><p>需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。</p><h2 id="十、文章"><a href="#十、文章" class="headerlink" title="十、文章"></a>十、文章</h2><p><a href="http://home.cnblogs.com/u/Mike-zh/" target="_blank" rel="noopener">Mike_zh</a> &amp; <a href="https://www.cnblogs.com/Mike-zh/p/4557014.html" target="_blank" rel="noopener">iOS-Runtime知识点整理</a></p><p><a href="https://www.ianisme.com/" target="_blank" rel="noopener">ian</a> &amp; <a href="https://www.ianisme.com/ios/2019.html" target="_blank" rel="noopener">Objective-C Runtime 1小时入门教程</a></p><p><a href="https://www.cnblogs.com/ioshe/p/5489086.html" target="_blank" rel="noopener">iOS开发-Runtime 详解</a></p><p><a href="https://www.jianshu.com/p/26c41f48267d" target="_blank" rel="noopener">iOS RunTime 之数据结构</a></p><p><a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">iOS 模块分解—「Runtime面试、工作」</a></p><p><a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Runtime 源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>消息转发</title>
    <link href="http://yoursite.com/2019/05/23/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/05/23/消息转发/</id>
    <published>2019-05-23T10:19:03.940Z</published>
    <updated>2019-07-12T15:44:59.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unrecognized selector sent to instance，导致应用 crash 的情况。</p><p>针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。</p><p>消息转发的整个过程主要涉及的 3 个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span>*)anInvocation;</span><br></pre></td></tr></table></figure><p>其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。</p><h2 id="二、消息转发过程"><a href="#二、消息转发过程" class="headerlink" title="二、消息转发过程"></a>二、消息转发过程</h2><p>首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-21f16eb1cfa08e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下边分析消息转发的过程，以 [MyObjet Length] 为例：</p><p>①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。</p><p>②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。</p><p>③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。</p><h2 id="三、结合-MyObject-中的代码对消息转发流程进一步分析"><a href="#三、结合-MyObject-中的代码对消息转发流程进一步分析" class="headerlink" title="三、结合 MyObject 中的代码对消息转发流程进一步分析"></a>三、结合 MyObject 中的代码对消息转发流程进一步分析</h2><p>①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel </span><br><span class="line">&#123;    </span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ ,<span class="built_in">NSStringFromSelector</span>(sel).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(length)) &#123;</span><br><span class="line">         <span class="built_in">BOOL</span> success = class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)(length), <span class="string">"q@:"</span>); </span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (success) &#123;</span><br><span class="line">             <span class="keyword">return</span> success;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 “q@:” 分别代表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q : 返回值 <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">@ : 调用方法的的实例为对象类型</span><br><span class="line">: : 表示方法</span><br></pre></td></tr></table></figure><p>下图表示了编码类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a5925ae21f498603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * respondClasses;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(aSelector).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> forwardTarget = [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (forwardTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> forwardTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class someClass = [<span class="keyword">self</span> myResponedClassForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (someClass) &#123;</span><br><span class="line">        forwardTarget = [someClass new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forwardTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。</p><p>③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。</p><blockquote><p> -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。</p><p>摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.</p><p>这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。</p></blockquote><p>相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n\n\n\n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(anInvocation.selector).UTF8String);</span><br><span class="line"></span><br><span class="line">    anInvocation.target = <span class="literal">nil</span>;</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        Class responededClass = [<span class="keyword">self</span> myResponedClassForSelector:selector];</span><br><span class="line">        <span class="keyword">if</span> (responededClass) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                signature = [responededClass instanceMethodSignatureForSelector:selector];</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">@finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">NSMethodSignature</span>: <span class="number">0x6000030a17c0</span>&gt;</span><br><span class="line">    number of arguments = <span class="number">2</span></span><br><span class="line">    frame size = <span class="number">224</span></span><br><span class="line">    is special <span class="keyword">struct</span> <span class="keyword">return</span>? <span class="literal">NO</span></span><br><span class="line">    <span class="keyword">return</span> value: -------- -------- -------- --------</span><br><span class="line">        type encoding (f) <span class="string">'f'</span></span><br><span class="line">        flags &#123;isFloat&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">16</span>, offset adjust = <span class="number">0</span>, size = <span class="number">16</span>, size adjust = <span class="number">-12</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">4</span>&#125;</span><br><span class="line">    argument <span class="number">0</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (@) <span class="string">'@'</span></span><br><span class="line">        flags &#123;isObject&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">0</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">    argument <span class="number">1</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (:) <span class="string">':'</span></span><br><span class="line">        flags &#123;&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">8</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span>。</span><br><span class="line"></span><br><span class="line">仍然以`myObject`调用`length`方法为例。 \- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> \*)anInvocation中的 anInvocation 的信息如下：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x6000025b8140</span>&gt;</span><br><span class="line"><span class="keyword">return</span> value: &#123;Q&#125; <span class="number">0</span></span><br><span class="line">target: &#123;@&#125; <span class="number">0x60000322c360</span></span><br><span class="line">selector: &#123;:&#125; length</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">return</span> value 指返回值，<span class="string">"Q"</span> 表示返回值类型为 <span class="keyword">long</span> <span class="keyword">long</span> 类型；</span><br><span class="line">&gt; target 指的是消息的接收者，<span class="string">"@"</span>标识对象类型；</span><br><span class="line">&gt; selector 指的是方法，<span class="string">":"</span>表示是方法，后边的 length 为方法名。</span><br></pre></td></tr></table></figure><p>更多内容可见下图 NSInvocation 的 types：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> _NSObjCValueType &#123;</span><br><span class="line">    <span class="built_in">NSObjCNoType</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSObjCVoidType</span> = <span class="string">'v'</span>,</span><br><span class="line">    <span class="built_in">NSObjCCharType</span> = <span class="string">'c'</span>,</span><br><span class="line">    <span class="built_in">NSObjCShortType</span> = <span class="string">'s'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLongType</span> = <span class="string">'l'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLonglongType</span> = <span class="string">'q'</span>,</span><br><span class="line">    <span class="built_in">NSObjCFloatType</span> = <span class="string">'f'</span>,</span><br><span class="line">    <span class="built_in">NSObjCDoubleType</span> = <span class="string">'d'</span>,</span><br><span class="line">    <span class="built_in">NSObjCBoolType</span> = <span class="string">'B'</span>,</span><br><span class="line">    <span class="built_in">NSObjCSelectorType</span> = <span class="string">':'</span>,</span><br><span class="line">    <span class="built_in">NSObjCObjectType</span> = <span class="string">'@'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStructType</span> = <span class="string">'&#123;'</span>,</span><br><span class="line">    <span class="built_in">NSObjCPointerType</span> = <span class="string">'^'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStringType</span> = <span class="string">'*'</span>,</span><br><span class="line">    <span class="built_in">NSObjCArrayType</span> = <span class="string">'['</span>,</span><br><span class="line">    <span class="built_in">NSObjCUnionType</span> = <span class="string">'('</span>,</span><br><span class="line">    <span class="built_in">NSObjCBitfield</span> = <span class="string">'b'</span></span><br><span class="line">&#125; API_DEPRECATED(<span class="string">"Not supported"</span>, macos(<span class="number">10.0</span>,<span class="number">10.5</span>), ios(<span class="number">2.0</span>,<span class="number">2.0</span>), watchos(<span class="number">2.0</span>,<span class="number">2.0</span>), tvos(<span class="number">9.0</span>,<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><h2 id="四、尚存疑点"><a href="#四、尚存疑点" class="headerlink" title="四、尚存疑点"></a>四、尚存疑点</h2><p>细心的读者可能会发现在首次消息转发的时候流程并不是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>而是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:_forwardStackInvocation: </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>查看了开源源码 <a href="https://opensource.apple.com/source/objc4/objc4-750.1/runtime/NSObject.mm.auto.html" target="_blank" rel="noopener">NSObject.mm</a> 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Replaced by CF (returns an NSMethodSignature)</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot;</span><br><span class="line">                &quot;not available without CoreFoundation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];</span><br><span class="line">&#125;</span><br><span class="line">// Replaced by CF (throws an NSException)</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、NSNull-QiNullSafe-m"><a href="#五、NSNull-QiNullSafe-m" class="headerlink" title="五、NSNull+QiNullSafe.m"></a>五、NSNull+QiNullSafe.m</h2><p>根据 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a> 仿写的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FQiShare%2FQiSafeType%2Fblob%2Fmaster%2FQiSafeType%2FNullSafe%2FNSNull%252BQiNullSafe.m" target="_blank" rel="noopener">NSNull+QiNullSafe.m</a>。</p><p>NSNull+QiNullSafe.m 能够避免的问题有：</p><blockquote><p>NSNull *null = [NSNull null];</p><p>[null performSelector:@selector(addObject:) withObject:@”aaa”];<br>[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];<br>[null performSelector:@selector(valueForKey:) withObject:@”aaa”];<br>[null performSelector:@selector(length) withObject:nil];<br>[null performSelector:@selector(integerValue) withObject:nil];<br>[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];<br>[null performSelector:@selector(bytes) withObject:nil];</p></blockquote><h2 id="六、NullSafe-是怎么处理-null-问题"><a href="#六、NullSafe-是怎么处理-null-问题" class="headerlink" title="六、NullSafe 是怎么处理 null 问题"></a>六、NullSafe 是怎么处理 null 问题</h2><p>其实 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>  处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。</p><p>不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。</p><p>注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。</p><h2 id="七、单元测试"><a href="#七、单元测试" class="headerlink" title="七、单元测试"></a>七、单元测试</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testStringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * string = [null stringValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertNil</span>(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testFloatValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> f = [null floatValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertEqualWithAccuracy</span>(f, <span class="number">0.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNull</span> * null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    [null performSelector:<span class="keyword">@selector</span>(addObject:) withObject:<span class="string">@"aaa"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、文章"><a href="#八、文章" class="headerlink" title="八、文章"></a>八、文章</h2><p><a href="https://juejin.im/post/5c6e773be51d451b25716d0e" target="_blank" rel="noopener">iOS 消息转发</a></p><p><a href="http://www.olinone.com/?p=643" target="_blank" rel="noopener">Protocol 协议分发器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unr
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>图片加载和处理</title>
    <link href="http://yoursite.com/2019/05/23/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/23/图片加载和处理/</id>
    <published>2019-05-23T10:19:03.939Z</published>
    <updated>2019-07-11T11:48:36.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、图片显示"><a href="#一、图片显示" class="headerlink" title="一、图片显示"></a>一、图片显示</h2><p>图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-08b5bf1385f387ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。<font color="#cc0000">UIImage 持有的数据是未解码的压缩数据</font>，能节省较多的内存和加快存储。</p><p>当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。</p><p>解码是一个<font color="#cc0000">计算量较大且需要 CPU 来执行的任务</font>；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 <em> 高 </em> 每个像素点的大小 = width <em> height </em> 4bytes。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-819f47a678632a85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>图像解码操作会造成什么问题？</p><p>以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于<font color="#cc0000">在主线程同时进行 IO 操作、解码操作</font>等，会造成<font color="#cc0000">内存迅速增长和 CPU 负载瞬间提升</font>。</p><p>并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2746a469e302ca58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="1-1-优化一：降采样"><a href="#1-1-优化一：降采样" class="headerlink" title="1.1 优化一：降采样"></a>1.1 优化一：降采样</h4><p>在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用<font color="#cc0000">加载缩略图的方式减少图片的占用内存</font>。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-362199218d9322bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。</p><p>思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)downsampleImageAt:(<span class="built_in">NSURL</span> *)imageURL to:(<span class="built_in">CGSize</span>)pointSize scale:(<span class="built_in">CGFloat</span>)scale</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> imageSourceOptions = <span class="built_in">CFDictionaryCreate</span> ( <span class="built_in">CFAllocatorGetDefault</span>(),</span><br><span class="line">                                                              (<span class="keyword">void</span> *)@[ (<span class="built_in">NSString</span> *)kCGImageSourceShouldCache ],</span><br><span class="line">                                                              (<span class="keyword">void</span> *)@[ @(<span class="literal">YES</span>) ],</span><br><span class="line">                                                              <span class="number">1</span>,</span><br><span class="line">                                                              &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">                                                              &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((__bridge <span class="built_in">CFURLRef</span>)imageURL, imageSourceOptions);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFDictionaryRef</span> downsampleOptions = (__bridge <span class="built_in">CFDictionaryRef</span>)@&#123; (<span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailFromImageAlways : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceShouldCacheImmediately : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceCreateThumbnailWithTransform : @(<span class="literal">YES</span>),</span><br><span class="line">                                           (<span class="built_in">NSString</span> *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, downsampleOptions);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:downsampledImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。</p><h4 id="1-2-优化二：异步处理"><a href="#1-2-优化二：异步处理" class="headerlink" title="1.2 优化二：异步处理"></a>1.2 优化二：异步处理</h4><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fb940b0c9a90d4b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以<font color="#cc0000">在 Prefetching 时把降采样放到子线程进行处理</font>，因为降采样过程就包括解码操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/1049769-adc5d8f6870f9d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/890/format/webp" alt></p><p>Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。</p><p>需要特别注意，此处不能是并发队列，否则会造成<font color="#cc0000">线程爆炸</font>，原因见总结部分。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建串行队列</span></span><br><span class="line">    _serialQueue = dispatch_queue_create(<span class="string">"DecodeQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  获取单元格的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView prefetchItemsAt:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> * indexPath <span class="keyword">in</span> indexPaths) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(_serialQueue, ^&#123;</span><br><span class="line">            <span class="built_in">UIImage</span> * downsampledImage = [<span class="keyword">self</span> downsample];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [<span class="keyword">self</span> updateAt:indexPath with:downsampledImage];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  @brief  降采样。自行实现。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)downsample</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  更新单元格的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)updateAt:(<span class="built_in">NSIndexPath</span> *)indexPath with:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-优化三：使用-Image-Asset-Catalogs"><a href="#1-3-优化三：使用-Image-Asset-Catalogs" class="headerlink" title="1.3 优化三：使用 Image Asset Catalogs"></a>1.3 优化三：使用 Image Asset Catalogs</h4><p>苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。</p><p><a href="https://developer.apple.com/videos/play/wwdc2018/227/" target="_blank" rel="noopener">WWDC Session</a>。</p><h2 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h2><p>应用上述的优化策略，已经能对图片加载有比较好的优化。</p><p>WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。</p><h2 id="三、WWDC学习"><a href="#三、WWDC学习" class="headerlink" title="三、WWDC学习"></a>三、WWDC学习</h2><p>原作者的经验：<a href="https://www.jianshu.com/u/815d10a4bdce" target="_blank" rel="noopener">落影loyinglin</a></p><p>先主观假设两个前提：</p><p>①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚；</p><p>②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。</p><p>所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，<font color="#cc0000">看我们的 iOS 知识体系是否存在缺陷</font>；另外，WWDC 介绍的很多知识点同样<font color="#cc0000">免验证</font>的加入自己的知识体系。</p><p>以上文提到的线程爆炸为例，看看这种方式的好处。</p><p>原文如下：</p><blockquote><p>Thread Explosion（线程爆炸）</p><p>More images to decode than available CPUs（解码图像数量大于 CPU 数量）<br>GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）<br>Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像）</p></blockquote><p>从这个案例我们学习到<font color="#cc0000">如何避免图像解码的线程爆炸</font>，我们分析苹果工程师的逻辑，然后扩散思维：</p><blockquote><p>原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间</p></blockquote><p>延伸出来的问题：</p><blockquote><p>GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？…</p></blockquote><p>举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来：</p><p>①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别；</p><p>②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。</p><p>接下来的表现是操作系统相关的知识：</p><p>①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程；</p><p>②、cpu 的时间是分为多个时间片，每个线程轮询执行；</p><p>③、线程切换执行有代价，但比进程切换小得多；</p><p>④、每个 cpu 核心在同一时刻只能执行一个线程。</p><p>至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现：</p><p>主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。</p><p>结合此案例，我们能回答相关问题：</p><p>①、现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？</p><p>②、GCD 的串行队列和并发队列的应用场景有何不同？</p><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p><a href="https://www.jianshu.com/p/7d8a82115060" target="_blank" rel="noopener">iOS性能优化–图片加载和处理</a></p><p><a href="https://developer.apple.com/videos/play/wwdc2018/219/" target="_blank" rel="noopener">WWDC2018-Image and Graphics Best Practices</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、图片显示&quot;&gt;&lt;a href=&quot;#一、图片显示&quot; class=&quot;headerlink&quot; title=&quot;一、图片显示&quot;&gt;&lt;/a&gt;一、图片显示&lt;/h2&gt;&lt;p&gt;图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>NSDateFormatter性能</title>
    <link href="http://yoursite.com/2019/05/23/NSDateFormatter%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2019/05/23/NSDateFormatter性能/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-11T11:18:11.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、探究"><a href="#一、探究" class="headerlink" title="一、探究"></a>一、探究</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span> * dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">[dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * current = [dateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br></pre></td></tr></table></figure><p>关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:       %8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter once: %8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)----------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">08</span>:<span class="number">42.184</span> Demo[<span class="number">95118</span>:<span class="number">1359994</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">48.73</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">08</span>:<span class="number">42.188</span> Demo[<span class="number">95118</span>:<span class="number">1359994</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">3.57</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.871</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">61.18</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.875</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">3.85</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.123</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:          <span class="number">79.80</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.129</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span> once:     <span class="number">6.08</span> ms</span><br></pre></td></tr></table></figure><p>上面可以看出两者之间消耗时间差距很大。<font color="#cc0000">创建单例很有必要</font>。</p><p>那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    a += (end - begin);</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    b += (end - begin);</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    c += (end - begin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:alloc          %8.2f ms"</span>, a * <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:setFormat      %8.2f ms"</span>, b * <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSDateFormatter:stringFromDate %8.2f ms"</span>, c * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">-------------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)-------------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">7.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.28</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">11</span>:<span class="number">18.939</span> Demo[<span class="number">95164</span>:<span class="number">1361958</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">55.98</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.198</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">7.69</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.199</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.25</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">12</span>:<span class="number">03.199</span> Demo[<span class="number">95178</span>:<span class="number">1362677</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">60.97</span> ms</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:alloc              <span class="number">6.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:setFormat          <span class="number">0.20</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">18</span>:<span class="number">43.946</span> Demo[<span class="number">95261</span>:<span class="number">1366071</span>] <span class="built_in">NSDateFormatter</span>:stringFromDate    <span class="number">49.06</span> ms</span><br></pre></td></tr></table></figure><p>从上面可以看出，实际<font color="#cc0000">最耗时的方法是 stringFromDate:/dateFromString:</font>。再往下细究。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">NSDateFormatter</span> * formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">    [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">    </span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%8.2f ms"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------Xcode <span class="number">10.0</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)-------------</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.218</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">1.43</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.218</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.03</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.02</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.219</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.02</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.220</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.221</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">27</span>:<span class="number">06.221</span> Demo[<span class="number">95456</span>:<span class="number">1372764</span>]     <span class="number">0.01</span> ms</span><br></pre></td></tr></table></figure><p>从上面可以看出，只有<font =#cc0000>首次调用 stringFromDate:/dateFromString: 方法才会很耗时</font>。再往下细究。</p><p>还有人说应该针对 format 格式创建对应的单例对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> begin = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> end   = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的对象不同的 format 格式</span></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter1  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter2  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter3  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter4  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter1 setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter1 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter2 setDateFormat:<span class="string">@"MM-dd-yyyy"</span>];</span><br><span class="line">        [formatter2 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter3 setDateFormat:<span class="string">@"MM-dd"</span>];</span><br><span class="line">        [formatter3 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter4 setDateFormat:<span class="string">@"MM-yyyy"</span>];</span><br><span class="line">        [formatter4 stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"NSDateFormatter: different format  %8.2f ms\n"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一个对象不同的 format 格式</span></span><br><span class="line">&#123;</span><br><span class="line">    begin = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> * formatter  = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"yyyy-MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-dd-yyyy"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-dd"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        [formatter setDateFormat:<span class="string">@"MM-yyyy"</span>];</span><br><span class="line">        [formatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">    end = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"NSDateFormatter:                   %8.2f ms\n"</span>, (end - begin) * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------Xcode <span class="number">10.1</span> iPhone <span class="number">6</span>s(<span class="number">10.0</span>)---------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDateFormatter</span>: different format     <span class="number">23.26</span> ms</span><br><span class="line"><span class="built_in">NSDateFormatter</span>:                      <span class="number">16.25</span> ms</span><br></pre></td></tr></table></figure><p>如果不计 NSDateFormatter 对象的初始化时间，那么打印输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateFormatter</span>:different format     <span class="number">23.81</span> ms</span><br><span class="line"><span class="built_in">NSDateFormatter</span>:                     <span class="number">23.02</span> ms</span><br></pre></td></tr></table></figure><p>两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。</p><h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://www.jianshu.com/p/b000518c3eb8" target="_blank" rel="noopener">NSDateFormatter 性能测试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、探究&quot;&gt;&lt;a href=&quot;#一、探究&quot; class=&quot;headerlink&quot; title=&quot;一、探究&quot;&gt;&lt;/a&gt;一、探究&lt;/h2&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>.pch</title>
    <link href="http://yoursite.com/2019/05/23/pch/"/>
    <id>http://yoursite.com/2019/05/23/pch/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T07:26:36.262Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的<font color="#cc0000">预编译头文件</font>，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之后则需要手动创建。</p><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>①、定义全局性宏；</p><p>②、引用全局性头文件；</p><p>③、根据运行环境，自动打开或者关闭日志输出功能。</p><h2 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h2><p>①、PCH 文件的内容能被项目中的其他所有文件<font color="#cc0000">共享和访问</font>，其它地方可直接使用，不用再手动重复定义或引用；</p><p>②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而<font color="#cc0000">提高编译速度</font>。</p><h2 id="三、缺点"><a href="#三、缺点" class="headerlink" title="三、缺点"></a>三、缺点</h2><p>①、把类中使用的框架等放到 PCH 中，<font color="#cc0000">依赖关系不明确</font>，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。</p><p>②、大量的<font color="#cc0000">共用性不高</font>的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长；</p><h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><p>①、PCH 的目的是：提高编译速度，而不是少敲几行 #import；</p><p>②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用；</p><p>③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。</p><p>④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。</p><p>⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。</p><p>⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。</p><p>⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。</p><h2 id="五、文章"><a href="#五、文章" class="headerlink" title="五、文章"></a>五、文章</h2><p><a href="https://www.jianshu.com/p/001980b7a0c4" target="_blank" rel="noopener">PCH 文件的优缺点</a></p><p><a href="https://www.jianshu.com/p/2b449a4ae20f" target="_blank" rel="noopener">PCH文件的新建和其缺点</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的&lt;font color=&quot;#cc0000&quot;&gt;预编译头文件&lt;/font&gt;，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>第 k 小的数</title>
    <link href="http://yoursite.com/2019/05/23/%E7%AC%AC%20k%20%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/23/第 k 小的数/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-08-02T10:28:44.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、寻找两个有序数组的中位数"><a href="#一、寻找两个有序数组的中位数" class="headerlink" title="一、寻找两个有序数组的中位数"></a>一、<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></h2><h4 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p>给定两个大小为 m 和 n 的不同时为空的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><h4 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h4><p>题目要求的时间复杂度是 O(log(m + n))，要产生这样级别的时间复杂度只有采用二分查找法，用分治递归的思路来考虑这个问题。</p><p>需要转换题目中求中位数的问题为求第 k 小数的问题。如果 m + n 是奇数，那么寻找第 <font color="#cc0000">k = (m + n)/2 + 1</font> 小的数即可；如果长度和是偶数，那么我们还需要寻找第 (m + n)/2 小的数，然后计算两数的平均值。</p><p>在求解整个问题的过程中，我们始终需要考虑一个很重要的问题–<font color="#cc0000">数组索引越界问题</font>。</p><p>下面将详细地分析整个递归流程。</p><p>①、首先定义递归函数的作用：寻找两个有序数组 nums1 数组中 [L1, R1] 范围内和 nums2 数组 [L2, R2] 范围内第 k 小的数，k 从 1开始计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  L1   nums1数组的寻找范围的左边界</span></span><br><span class="line"><span class="comment"> *  R1   nums1数组的寻找范围的右边界</span></span><br><span class="line"><span class="comment"> *  L2   nums2数组的寻找范围的左边界</span></span><br><span class="line"><span class="comment"> *  R2   nums2数组的寻找范围的右边界</span></span><br><span class="line"><span class="comment"> *  k    需要寻找第k小的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2, <span class="keyword">int</span> k)</span></span></span><br></pre></td></tr></table></figure><p>②、用 len1 = R1 - L1 + 1 来记录 nums1 数组中寻找范围的长度，用 len2 = R2 - L2 + 1 来记录 nums2 数组中寻找范围的长度。</p><p>③、如果要寻找的 k &gt; len1 + len2，就像只有 3 个数字要找第 4 小的数一样，超出寻找区域，显然无法找到。</p><p>④、递归的终止条件：</p><ol><li><p>当 len1 = 0 时，说明只有 nums2 数组中有元素，直接取 nums2[L2 + k - 1] 位元素即可。</p></li><li><p>当 k = 1 时，说明要取的是两个有序数组中的最小值 MIN(nums1[L1], nums2[L2])。</p></li></ol><p>⑤、递归过程：</p><p>由于要求的是第 k 小的数，而且是在两个有序数组中求。划分两个数组时按照 k 值来分。取变量 i = MIN(len1, k/2)，之所以这么取，是为了防止 L1 + k/2 - 1 &gt; len1 导致从 nums1 取值越界。再取变量 j = MIN(len2, k/2)。</p><p>接下来比较 nums1[L1 + i - 1] 和 nums2[L2 + i - 1] 这两个值。</p><p>如果 nums1[L1 + i - 1] &lt;= nums2[L2 + j - 1]，<font color="#cc0000">显然 nums1 数组中索引为 L1 + i - 1 及之前的元素不可能是中位数</font>，去除 nums1 数组中 [L1, L1 + i - 1] 范围内的元素，缩小了查找范围。我们递归调用该函数，此时在 nums1 中的查找范围变成了 nums1[L1 + i, R1]，此时要找的也不应该是第 k 小的元素，因为<font color="#cc0000">已经剔除了 i 个比 k 小的元素</font>，因此我们要找的元素变成了第 k - i 小的元素。</p><p>如果 nums1[L1 + i - 1] &gt; nums2[L2 + j - 1]，同理，nums2 数组中索引为 L2 + j - 1 及之前的元素不可能是中位数，缩小查找范围，剔除了 j 个比 k 小的元素，因此我们要找的元素变成了第 k - j 小的元素。</p><blockquote><p>因为 i + j = MIN(len1, k/2) + MIN(len2, k/2) &lt;= k，所以可以直接判断 [L1, L1 + i - 1] 或者 [L2, L2 + j -1] 区间的元素不可能是中位数。 </p></blockquote><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-19b4f9b39cfc6c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center><p>总结：<font color="#cc0000">算法的思想是不断的剔除数据，逐渐逼近第 k 小的数</font>。</p><h2 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h2><p>假设数组长度足够长，每次剔除的元素都是 k/2(i 或者j)，显然我们需要 log(k) 次才能找到第 k 小数，这和二分查找法是同理的，而我们要找的 k 值要么是 (m + n)/2 + 1，要么额外再加上 (m + n)/2，因此时间复杂度是 O(log(m + n)) 级别的。</p><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a, b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> left1, <span class="keyword">int</span> right1, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = right1 - left1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = right2 - left2 + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归退出条件</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt; n1 + n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 实际上 k 不会小于 n1 + n2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2[left2 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[left1 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> MIN(nums1[left1], nums2[left2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = MIN(n1, k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> j = MIN(n2, k / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除比第 k 小的数还小的数，逐渐逼近</span></span><br><span class="line">    <span class="keyword">if</span>(nums1[left1 + i - <span class="number">1</span>] &gt; nums2[left2 + j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, left1, right1, nums2, left2 + j, right2, k - j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, left1 + i, right1, nums2, left2, right2, k - i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// k = (nums1Size + nums2Size) /2 + 1，因为 k 从 1 开始计数</span></span><br><span class="line">    <span class="keyword">int</span> mid1 = findKth(nums1, <span class="number">0</span>, nums1Size - <span class="number">1</span>, nums2, <span class="number">0</span>, nums2Size - <span class="number">1</span>, (nums1Size + nums2Size) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个数组总长度是奇数</span></span><br><span class="line">    <span class="keyword">if</span>((nums1Size + nums2Size) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个数组总长度是偶数</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 额外求 (nums1Size + nums2Size) / 2 的值</span></span><br><span class="line">        <span class="keyword">int</span> mid2 = findKth(nums1, <span class="number">0</span>, nums1Size - <span class="number">1</span>, nums2, <span class="number">0</span>, nums2Size - <span class="number">1</span>, (nums1Size + nums2Size) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (mid1 + mid2) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://blog.csdn.net/qq_41231926/article/details/81805795" target="_blank" rel="noopener">LeetCode004——两个排序数组的中位数</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#一、寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;一、寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;一、&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 内置图片瘦身</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%86%85%E7%BD%AE%E5%9B%BE%E7%89%87%E7%98%A6%E8%BA%AB/"/>
    <id>http://yoursite.com/2019/05/23/iOS 内置图片瘦身/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-12T01:20:52.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、iOS-内置资源的集中方式"><a href="#一、iOS-内置资源的集中方式" class="headerlink" title="一、iOS 内置资源的集中方式"></a>一、iOS 内置资源的集中方式</h2><h4 id="1-1-将图片存放在-bundle"><a href="#1-1-将图片存放在-bundle" class="headerlink" title="1.1 将图片存放在 bundle"></a>1.1 将图片存放在 bundle</h4><p>这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到<font color="#cc0000">隔离资源</font>的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。</p><p>这种方式有比较明显的缺点：</p><p>①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。</p><p>②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。</p><p>在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。</p><p>下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-66c00dd63d65a971.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt> <img src="https://upload-images.jianshu.io/upload_images/5294842-b85758fdfe19f422.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-94a016df24024865.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt> <img src="https://upload-images.jianshu.io/upload_images/5294842-da19d42d7f21cb5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。</p><h4 id="1-2-使用-ttf-字体文件替代图标"><a href="#1-2-使用-ttf-字体文件替代图标" class="headerlink" title="1.2 使用 .ttf 字体文件替代图标"></a>1.2 使用 .ttf 字体文件替代图标</h4><p>使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。</p><p>使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。</p><p>字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILabel</span> * iconLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">iconLabel.font = [<span class="built_in">UIFont</span> fontWithName:<span class="string">@"icomoon"</span> size:<span class="number">50</span>];</span><br><span class="line">iconLabel.text = [<span class="built_in">NSString</span> stringWithUTF8String:<span class="string">"\ue902"</span>];</span><br></pre></td></tr></table></figure><p>由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。</p><p>优点：</p><p>①、可以降低应用图片内置资源的体积。</p><p>②、可以随意缩放和修改颜色。</p><p>缺点：</p><p>①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。</p><p>②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。</p><p>任何一种需要大刀阔斧改革的优化都是一种不明智的行为。</p><h4 id="1-3-图片存在-Assets-xcassets"><a href="#1-3-图片存在-Assets-xcassets" class="headerlink" title="1.3 图片存在 Assets.xcassets"></a>1.3 图片存在 Assets.xcassets</h4><p>使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。</p><h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><p>项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。</p><p>为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。</p><p>与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。<font color="#cc0000">.framework 中可以存放资源，但 .a 不可以</font>，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。</p><p>优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。</p><p>先要抛出两个问题：</p><p>&emsp;①、cocoapods 是否支持使用 Assets.xcassets。</p><p>&emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。</p><p>为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d91c042de77985a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s.source_files ：源文件路径。</span><br><span class="line"></span><br><span class="line">s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。</span><br><span class="line"></span><br><span class="line">s.resources ：资源文件路径及文件类型。</span><br><span class="line"></span><br><span class="line">s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。</span><br></pre></td></tr></table></figure><p>实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。</p><p>如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。</p><p>查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-7ad0badccde39e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-26d283bdb3e0ab53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。</p><p>既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案：</p><p>①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。</p><p>②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。</p><p>③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。</p><p>④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。</p><p>只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1d1c0b0a5829ddce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-25e5c59026031224.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。</p><p>为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e90e00f3d0c80b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b33cce60e4a67ef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a3bfbde2e9e119c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_decodeObjectForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    <span class="keyword">id</span> (*functionPoint)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)) function;</span><br><span class="line">    <span class="keyword">id</span> value = functionPoint(<span class="keyword">self</span>, _cmd, key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b2355951a7c86b6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6d040ecd395f34fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e65336fc35468c15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_decodeObjectForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool <span class="keyword">class</span>], <span class="keyword">@selector</span>(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    <span class="keyword">id</span> (*functionPoint)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>)) function;</span><br><span class="line">    <span class="keyword">id</span> value = functionPoint(<span class="keyword">self</span>, _cmd, key);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span>* propKey = <span class="string">@"emaNecruoseRIU"</span>;</span><br><span class="line">    <span class="comment">// 反转字符串</span></span><br><span class="line">    propKey = [XUtil stringByReversed:propKey];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:propKey]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (normal_imageName) &#123;</span><br><span class="line">            select_imageName = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            normal_imageName = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook UIImageView 的 initWithCoder:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)swizzle_imageView_initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。</span></span><br><span class="line">    <span class="comment">// tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。</span></span><br><span class="line">    normal_imageName = <span class="literal">nil</span>;</span><br><span class="line">    select_imageName = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImageView</span> * instance = (<span class="built_in">UIImageView</span> *)[<span class="keyword">self</span> swizzle_imageView_initWithCoder:aDecoder];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] &amp;&amp; normal_imageName.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIImage</span> * normalImage = [HookTool imageAfterSearch:normal_imageName];</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (normalImage) &#123;</span><br><span class="line">            instance.image = normalImage;</span><br><span class="line">        &#125;</span><br><span class="line">        normal_imageName = <span class="literal">nil</span>;</span><br><span class="line">        select_imageName = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。</p><p>但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对<font color="#cc0000">增加了项目维护的难度</font>。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。</p><p>hook method_exchangeImplementations 方法。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-53182782221fe7cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>检测方法（字典写入时不要忘了加锁）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fe1b0b6cdef8e479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><font color="#cc0000">这种方式不能区分 image 和 backgroundImage、normal 和 Selected</font>。目前根据观察顺序应该是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIResourceName</span> ： normal - image(前景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： normal - backgroundImage(背景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： selected - image(前景图)</span><br><span class="line"><span class="built_in">UIResourceName</span> ： selected - backgroundImage(背景图)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、iOS-内置资源的集中方式&quot;&gt;&lt;a href=&quot;#一、iOS-内置资源的集中方式&quot; class=&quot;headerlink&quot; title=&quot;一、iOS 内置资源的集中方式&quot;&gt;&lt;/a&gt;一、iOS 内置资源的集中方式&lt;/h2&gt;&lt;h4 id=&quot;1-1-将图片存放在-bu
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 单例</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%8D%95%E4%BE%8B/"/>
    <id>http://yoursite.com/2019/05/23/iOS 单例/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T08:28:00.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、单例介绍"><a href="#一、单例介绍" class="headerlink" title="一、单例介绍"></a>一、单例介绍</h2><p>单例：该类在程序运行期间有且仅有一个实例。</p><h4 id="1-1-单例的主要优点"><a href="#1-1-单例的主要优点" class="headerlink" title="1.1 单例的主要优点"></a>1.1 单例的主要优点</h4><p>①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例；</p><p>②、因为类控制了实例化过程，所以类可以灵活更改实例化过程；</p><p>③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。</p><h4 id="1-2-单例的主要缺点"><a href="#1-2-单例的主要缺点" class="headerlink" title="1.2 单例的主要缺点"></a>1.2 单例的主要缺点</h4><p>①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放；</p><p>②、单例不能继承。</p><h2 id="二、单例的实现"><a href="#二、单例的实现" class="headerlink" title="二、单例的实现"></a>二、单例的实现</h2><p>单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。</p><p>主要是做到以下几点：</p><p>防止调用 [[A alloc] init] 引起的错误<br>防止调用 new 引起的错误<br>防止调用 copy 引起的错误<br>防止调用 mutableCopy 引起的错误</p><h4 id="2-1-实现方式一"><a href="#2-1-实现方式一" class="headerlink" title="2.1 实现方式一"></a>2.1 实现方式一</h4><blockquote><p>把所有可能出现的初始化方法做了相应的处理来其保证安全性</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 不能再使用 alloc 方法</span></span><br><span class="line">        <span class="comment">// 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法</span></span><br><span class="line">        _sharedSingleton = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-实现方式二"><a href="#2-2-实现方式二" class="headerlink" title="2.2 实现方式二"></a>2.2 实现方式二</h4><blockquote><p>不做处理的情况下禁止外部调用</p></blockquote><p>一些成熟的第三方代码的单例中也有使用该方法的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.h 文件</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span> <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopy <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">.m 文件</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          _sharedSingleton = [[<span class="keyword">self</span> alloc] init];  <span class="comment">// 要使用 self 来调用</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。</p><h2 id="三、单例的滥用"><a href="#三、单例的滥用" class="headerlink" title="三、单例的滥用"></a>三、单例的滥用</h2><h4 id="3-1-全局状态"><a href="#3-1-全局状态" class="headerlink" title="3.1 全局状态"></a>3.1 全局状态</h4><p>大多数的开发者都认同使用<font color="#cc0000">全局可变的状态</font>是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SPMath</span></span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSInteger</span> _a;</span><br><span class="line">     <span class="built_in">NSInteger</span> _b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)add</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题：</p><ol><li><p>add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。</p></li><li><p>当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。</p></li></ol><p>把下面的代码和上面的例子做对比:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSUInteger</span>)addOf:(<span class="built_in">NSUInteger</span>)a plus:(<span class="built_in">NSUInteger</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为<font color="#cc0000">类方法</font>，这样就显式的告诉了代码的阅读者：这个方法<font color="#cc0000">不会修改任何实例的状态</font>。</p><p>那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“<a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">单例就是披着羊皮的全局状态</a>” 。</p><p>一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Singleton</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)a </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([[Singleton sharedInstance] name]) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     [[Singleton sharedInstance] setName:<span class="string">""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的<font color="#cc0000">共享状态</font>来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致<font color="#cc0000">隐式的在两个看起来完全不相关的模块之间建立了耦合</font>。</p><p>来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。</p><p>想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">URLCache</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSCache</span> *)sharedURLCache;</span><br><span class="line">- (<span class="keyword">void</span>)storeCachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。</p><p>几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？</p><p>原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。</p><p><font color="#cc0000">持久化状态是单元测试的敌人</font>，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。</p><h4 id="3-2-对象的生命周期"><a href="#3-2-对象的生命周期" class="headerlink" title="3.2 对象的生命周期"></a>3.2 对象的生命周期</h4><p>另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。</p><p>假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThumbnailCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache;</span><br><span class="line">- (<span class="keyword">void</span>)cacheProfileImage:(<span class="built_in">NSData</span> *)imageData forUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="built_in">NSData</span> *)cachedProfileImageForUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。</p><p>当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。</p><p>问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThumbnailCache * sharedThumbnailCache;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!sharedThumbnailCache) &#123;</span><br><span class="line">           sharedThumbnailCache = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sharedThumbnailCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cleanUp</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// The SPThumbnailCache will clean up persistent states when deallocated</span></span><br><span class="line">     sharedThumbnailCache = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个明显的对单例模式的滥用，但是它可以工作，对吧。</p><p>当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。</p><p>由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。</p><p>分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。</p><p>举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持<a href="https://www.dropbox.com/business/two-dropboxes" target="_blank" rel="noopener">多个用户账号</a>登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。</p><p>这里我们得到的教训是：<font color="#cc0000">单例应该只用来保存全局的状态，并且不能和任何作用域绑定</font>。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。</p><h2 id="四、避免使用单例"><a href="#四、避免使用单例" class="headerlink" title="四、避免使用单例"></a>四、避免使用单例</h2><p>既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？</p><p>重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ThumbnailCache * thumbnailCache;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">          _thumbnailCache = [[ThumbnailCache alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。</p><p>现在假设我们有一个 VC 来展现好友列表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FriendListVC</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUser:(User *)user; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是<a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">依赖注入</a>，并且它有很多优点：</p><p>①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。</p><p>②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。</p><p>为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。</p><ol><li>假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-5a3d085872ee313f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。</p><p>当用户登出后，清理 rootViewController 并且退出到登录页面：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d7ce97acfc9e7890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。</p><ol start="2"><li>使用依赖注入的对象图：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5294842-42f2c8e7764a543b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了<a href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank" rel="noopener">简化</a> applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a00b35bf8a96f6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这个对象图看起来和使用单例时很像。这有什么区别？</p><p>关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b011ee68eba70df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f0268e3703574ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。</p><p>这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。</p><h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://blog.csdn.net/zhengang007/article/details/70336612" target="_blank" rel="noopener">避免滥用单例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、单例介绍&quot;&gt;&lt;a href=&quot;#一、单例介绍&quot; class=&quot;headerlink&quot; title=&quot;一、单例介绍&quot;&gt;&lt;/a&gt;一、单例介绍&lt;/h2&gt;&lt;p&gt;单例：该类在程序运行期间有且仅有一个实例。&lt;/p&gt;
&lt;h4 id=&quot;1-1-单例的主要优点&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>依赖注入</title>
    <link href="http://yoursite.com/2019/05/23/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/05/23/依赖注入/</id>
    <published>2019-05-23T10:19:03.938Z</published>
    <updated>2019-07-13T08:02:59.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。</p><p>初始化方法注入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2;</span><br></pre></td></tr></table></figure><p>属性注入：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency1 * dependency1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency2 * dependency2;</span><br></pre></td></tr></table></figure><p>一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。</p><h2 id="二、为什么使用依赖注入"><a href="#二、为什么使用依赖注入" class="headerlink" title="二、为什么使用依赖注入"></a>二、为什么使用依赖注入</h2><p>依赖注入的几个重要之处：</p><p>①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量；</p><p>②、使用构成。 即一直坚持的<font color="#cc0000">多构成少继承原则</font>。它能提高代码的可重用性；</p><p>③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。</p><p>④、明确的所有者。</p><p>⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。</p><h2 id="三、使用依赖注入"><a href="#三、使用依赖注入" class="headerlink" title="三、使用依赖注入"></a>三、使用依赖注入</h2><h4 id="3-1-注入类的类型"><a href="#3-1-注入类的类型" class="headerlink" title="3.1 注入类的类型"></a>3.1 注入类的类型</h4><p>首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。</p><p>简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。</p><p>复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。</p><p>分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。</p><h4 id="3-2-在初始化时依赖分配"><a href="#3-2-在初始化时依赖分配" class="headerlink" title="3.2 在初始化时依赖分配"></a>3.2 在初始化时依赖分配</h4><p>原始代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line">         ...</span><br><span class="line">         _engine = [[RCEngine alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用依赖注入改版后：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">         _engine = engine;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="3-3-延迟初始化依赖"><a href="#3-3-延迟初始化依赖" class="headerlink" title="3.3 延迟初始化依赖"></a>3.3 延迟初始化依赖</h4><p>通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;</span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init];</span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。</p><p>工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。</p><p>下面，通过一个工厂，使用依赖注入创建一个灭火器。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RCFireExtinguisher *(^RCFireExtinguisherFactory)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RCFireExtinguisherFactory fireExtinguisherFactory;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          _engine = engine;  </span><br><span class="line">          _fireExtinguisherFactory = [extFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;     </span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = <span class="keyword">self</span>.fireExtinguisherFactory();     </span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;      </span><br><span class="line"> </span><br><span class="line">          _engine = engine;   </span><br><span class="line">          _transmission    = transmission;   </span><br><span class="line">          _leftFrontWheel  = wheelFactory();   </span><br><span class="line">          _leftRearWheel   = wheelFactory();   </span><br><span class="line">          _rightFrontWheel = wheelFactory();  </span><br><span class="line">          _rightRearWheel  = wheelFactory();   <span class="comment">// 保留轮子工厂，之后还需要一个备胎。   </span></span><br><span class="line">          _wheelFactory    = [wheelFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="四、避免多余的配置"><a href="#四、避免多余的配置" class="headerlink" title="四、避免多余的配置"></a>四、避免多余的配置</h2><p>如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。</p><p>在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。</p><p>为了配置我们的对象，将从 4 个点来收集我们的依赖：</p><p>①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中；</p><p>②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值；</p><p>③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。</p><p>④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。</p><p>下面是关于赛车的简单初便利构造器</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency</span><br><span class="line">&#123;</span><br><span class="line">     RCEngine * engine = [[RCEngine alloc] init];   </span><br><span class="line">     RCTransmission * transmission = [[RCTransmission alloc] init];   </span><br><span class="line"></span><br><span class="line">     RCWheel *(^wheelFactory)() = ^&#123;      </span><br><span class="line">          <span class="keyword">return</span> [[RCWheel alloc] init];   </span><br><span class="line">     &#125;;   </span><br><span class="line">     <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithEngine:engine</span><br><span class="line">                            transmission:transmission </span><br><span class="line">                       pitRadioFrequency:frequency</span><br><span class="line">                            wheelFactory:wheelFactory];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。</p><h2 id="五、系统单例"><a href="#五、系统单例" class="headerlink" title="五、系统单例"></a>五、系统单例</h2><p>在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。</p><p>这里建议<font color="#cc0000">避免在你的代码中创建全局的单例</font>，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。</p><h2 id="六、不可修改的构造函数"><a href="#六、不可修改的构造函数" class="headerlink" title="六、不可修改的构造函数"></a>六、不可修改的构造函数</h2><p>有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个我们不能直接调用初始化方法的例子。</span></span><br><span class="line">RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];</span><br><span class="line"><span class="comment">// 我们仍然可以使用属性来配置我们的赛车路径</span></span><br><span class="line">raceTrack.width = <span class="number">10</span>;</span><br><span class="line">raceTrack.numberOfHairpinTurns = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。</p><h2 id="七、类注册"><a href="#七、类注册" class="headerlink" title="七、类注册"></a>七、类注册</h2><p>“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * raceCarClasses = @[ [RCFastRaceCar <span class="keyword">class</span>], [RCSlowRaceCar <span class="keyword">class</span>] ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class raceCarClass <span class="keyword">in</span> raceCarClasses) &#123;   </span><br><span class="line">     <span class="comment">// 所有赛车必须有相同的初始化方法 (在这个例子中是 "init" 方法).</span></span><br><span class="line">     <span class="comment">// 这里意味着我们不能自定义不同的子类</span></span><br><span class="line">     [raceCars addObject:[[raceCarClass alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的替换方法是：使用工厂 block 来代替</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> RCRaceCar *(^RCRaceCarFactory)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * raceCarFactories = @[ ^&#123; <span class="keyword">return</span> [[RCFastRaceCar alloc] initWithTopSpeed:<span class="number">200</span>]; &#125;, </span><br><span class="line">                                ^&#123; <span class="keyword">return</span> [[RCSlowRaceCar alloc] initWithLeatherPlushiness:<span class="number">11</span>]; &#125; ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *  raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RCRaceCarFactory raceCarFactory <span class="keyword">in</span> raceCarFactories) &#123;</span><br><span class="line">    <span class="comment">// 现在这样，我们就不用关心到底是那个初始化方法被调用了</span></span><br><span class="line">    [raceCars addObject:raceCarFactory()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、Storyboards"><a href="#八、Storyboards" class="headerlink" title="八、Storyboards"></a>八、Storyboards</h2><p>Storyboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。</p><p>解决方法是<font color="#cc0000">避免使用 storyboard</font>。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。</p><h2 id="九、公有和私有"><a href="#九、公有和私有" class="headerlink" title="九、公有和私有"></a>九、公有和私有</h2><p>依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In public ObjectA.h.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(ObjectB *)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectB</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也一样：需要暴露 ObjectC.h</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectC:(ObjectC *)objectC;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectC</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(<span class="keyword">id</span> &lt;ObjectB&gt;)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个协议只暴露 ObjectA 需要原始的 ObjectB。</span></span><br><span class="line"><span class="comment">// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectB</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodNeededByObjectA;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="十、一次高效的依赖注入"><a href="#十、一次高效的依赖注入" class="headerlink" title="十、一次高效的依赖注入"></a>十、一次高效的依赖注入</h2><h4 id="10-1-问题场景"><a href="#10-1-问题场景" class="headerlink" title="10.1 问题场景"></a>10.1 问题场景</h4><p>如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ee8e7de4eb46f0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>这里依赖路径有两条：</p><p>①、主项目依赖第三方 pods。</p><p>②、组件依赖第三方 pods，主项目再依赖组件。</p><p><font color="#cc0000">单向的依赖关系</font>决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，<font color="#cc0000">组件却没有办法主动和主项目通讯</font>。</p><p>可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。</p><h4 id="10-2-依赖注入"><a href="#10-2-依赖注入" class="headerlink" title="10.2 依赖注入"></a>10.2 依赖注入</h4><p>依赖注入有另外一个名字，叫做“控制反转”。</p><p>像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。</p><p>所以依赖注入有两个比较重要的点：</p><p>①、要实现这种反转控制的功能。</p><p>②、要解耦。</p><blockquote><p>不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。</p><p>出自这篇文章：<a href="https://laravel-china.org/topics/2104/understanding-dependency-injection-and-inversion-of-control" target="_blank" rel="noopener">理解依赖注入与控制反转</a></p></blockquote><h4 id="10-3-iOS-依赖注入调查"><a href="#10-3-iOS-依赖注入调查" class="headerlink" title="10.3 iOS 依赖注入调查"></a>10.3 iOS 依赖注入调查</h4><p>iOS 平台实现依赖注入功能的开源项目有两个大头：<a href="https://github.com/atomicobject/objection" target="_blank" rel="noopener">objection</a>、<a href="https://github.com/appsquickly/typhoon" target="_blank" rel="noopener">typhoon</a>。</p><p>详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。</p><p>还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。</p><p>那有没有其他没那么方案呢？<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener">libextobjc</a></p><p>libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点：</p><p>①、充分使用了 OC 动态语言的特性，不侵入项目</p><p>②、高度自动化</p><p>③、框架十分轻量（只有一个 .h 和 .m 文件）</p><p>④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。</p><h4 id="10-4-EXTConcreteProtocol-实现原理"><a href="#10-4-EXTConcreteProtocol-实现原理" class="headerlink" title="10.4 EXTConcreteProtocol 实现原理"></a>10.4 EXTConcreteProtocol 实现原理</h4><p>有两个比较重要的概念需要提前明白才能继续往下讲。</p><p>①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。</p><p>②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d6694cba798f0df6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。</p><h6 id="10-4-1-EXTConcreteProtocol-的使用"><a href="#10-4-1-EXTConcreteProtocol-的使用" class="headerlink" title="10.4.1 EXTConcreteProtocol 的使用"></a>10.4.1 EXTConcreteProtocol 的使用</h6><p>比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectProtocol</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello;</span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">@concreteprotocol(ObjectProtocol)</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">ObjectProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们接下来就可以对 Person 调用注入的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     Person * p = [Person new];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [p age]);</span><br><span class="line">     [p.class sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">18</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h6 id="10-4-2-源码解析"><a href="#10-4-2-源码解析" class="headerlink" title="10.4.2 源码解析"></a>10.4.2 源码解析</h6><p>先来看一下头文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define concreteprotocol(NAME) \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a class used to contain all the methods used in this protocol</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">     <span class="comment">// 定义一个容器类</span></span><br><span class="line">    interface NAME <span class="meta">## _ProtocolMethodContainer : NSObject <span class="meta-string">&lt; NAME &gt;</span> &#123;&#125; \</span></span><br><span class="line">    <span class="keyword">@end</span> \</span><br><span class="line">    \</span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">NAME</span> ## <span class="title">_ProtocolMethodContainer</span> \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when this class is loaded into the runtime, add the concrete protocol</span></span><br><span class="line"><span class="comment">     * into the list we have of them</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// load 方法添加混合协议</span></span><br><span class="line">    + (<span class="keyword">void</span>)load &#123; \</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * passes the actual protocol as the first parameter, then this class as</span></span><br><span class="line"><span class="comment">         * the second</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        <span class="keyword">if</span> (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), <span class="keyword">self</span>)) \</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not load concrete protocol %s\n"</span>, metamacro_stringify(NAME)); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * using the "constructor" function attribute, we can ensure that this</span></span><br><span class="line"><span class="comment">     * function is executed only AFTER all the Objective-C runtime setup (i.e.,</span></span><br><span class="line"><span class="comment">     * after all +load methods have been executed)</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// 在 load 之后，main 之前执行方法注入</span></span><br><span class="line">    __attribute__((constructor)) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> ext_ <span class="meta">## NAME ## _inject (void) &#123; \</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * use this injection point to mark this concrete protocol as ready for</span></span><br><span class="line"><span class="comment">         * loading</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** implementation details follow ***/</span></span><br><span class="line"><span class="comment">// load 方法添加混合协议</span></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);</span><br><span class="line"><span class="comment">// load 之后，main 之前执行方法注入</span></span><br><span class="line"><span class="keyword">void</span> ext_loadConcreteProtocol (Protocol *protocol);</span><br></pre></td></tr></table></figure><p>可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。</p><p>然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contains the information needed to reference a full special protocol</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the actual protocol declaration (@protocol block)  用户定义的协议.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the injection block associated with this protocol</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this block is RETAINED and must eventually be released by transferring it</span></span><br><span class="line">    <span class="comment">// back to ARC</span></span><br><span class="line">    <span class="comment">// 在 __attribute__((constructor)) 时往指定类里注入方法的 block.</span></span><br><span class="line">    <span class="keyword">void</span> *injectionBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// whether this protocol is ready to be injected to its conforming classes</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this does NOT refer to a special protocol having been injected already</span></span><br><span class="line">    <span class="comment">// 对应的协议是否已经准备好注入.</span></span><br><span class="line">    <span class="built_in">BOOL</span> ready;</span><br><span class="line">&#125; EXTSpecialProtocol;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123;</span><br><span class="line">        ext_injectConcreteProtocol(protocol, containerClass, destinationClass);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_loadSpecialProtocol (Protocol *protocol, <span class="keyword">void</span> (^injectionBehavior)(Class destinationClass)) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(injectionBehavior != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work    加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if we've hit the hard maximum for number of special protocols, we can't</span></span><br><span class="line">        <span class="comment">// continue</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount == SIZE_MAX) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the array has no more space, we will need to allocate additional</span></span><br><span class="line">        <span class="comment">// entries</span></span><br><span class="line">        <span class="comment">// specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols.</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount &gt;= specialProtocolCapacity) &#123;</span><br><span class="line">            size_t newCapacity;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocolCapacity == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// if there are no entries, make space for just one</span></span><br><span class="line">                newCapacity = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// otherwise, double the current capacity</span></span><br><span class="line">                newCapacity = specialProtocolCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if the new capacity is less than the current capacity, that's</span></span><br><span class="line">                <span class="comment">// unsigned integer overflow</span></span><br><span class="line">                <span class="keyword">if</span> (newCapacity &lt; specialProtocolCapacity) &#123;</span><br><span class="line">                    <span class="comment">// set it to the maximum possible instead</span></span><br><span class="line">                    newCapacity = SIZE_MAX;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// if the new capacity is still not greater than the current</span></span><br><span class="line">                    <span class="comment">// (for instance, if it was already SIZE_MAX), we can't continue</span></span><br><span class="line">                    <span class="keyword">if</span> (newCapacity &lt;= specialProtocolCapacity) &#123;</span><br><span class="line">                        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we have a new capacity, so resize the list of all special protocols</span></span><br><span class="line">            <span class="comment">// to add the new entries</span></span><br><span class="line">            <span class="keyword">void</span> * restrict ptr = realloc(specialProtocols, <span class="keyword">sizeof</span>(*specialProtocols) * newCapacity);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">                <span class="comment">// the allocation failed, abort</span></span><br><span class="line">                pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            specialProtocols = ptr;</span><br><span class="line">            specialProtocolCapacity = newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// at this point, there absolutely must be at least one empty entry in the</span></span><br><span class="line">        <span class="comment">// array</span></span><br><span class="line">        assert(specialProtocolCount &lt; specialProtocolCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// disable warning about "leaking" this block, which is released in</span></span><br><span class="line">        <span class="comment">// ext_injectSpecialProtocols()</span></span><br><span class="line">        <span class="meta">#ifndef __clang_analyzer__</span></span><br><span class="line">        ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// construct a new EXTSpecialProtocol structure and add it to the first</span></span><br><span class="line">        <span class="comment">// empty space in the array</span></span><br><span class="line">        <span class="comment">// 将协议保存为一个 EXTSpecialProtocol 结构体。</span></span><br><span class="line">        specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123;</span><br><span class="line">            .protocol = protocol,</span><br><span class="line">            .injectionBlock = (__bridge_retained <span class="keyword">void</span> *)copiedBlock,</span><br><span class="line">            .ready = <span class="literal">NO</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">        ++specialProtocolCount;</span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。</p><p>ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class <span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="comment">// get the full list of instance methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的实例方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> imethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the full list of class methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的类方法方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> cmethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// get the metaclass of this class (the object on which class</span></span><br><span class="line">    <span class="comment">// methods are implemented)  拿到要注入方法的类的元类.</span></span><br><span class="line">    Class metaclass = object_getClass(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all instance methods in the concrete protocol   注入实例方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; imethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = imethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if such an instance method already exists</span></span><br><span class="line">        <span class="comment">// (on this class or on a superclass)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(<span class="keyword">class</span>, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this instance method to the class in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(<span class="keyword">class</span>, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all class methods in the concrete protocol   注入类方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; cmethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = cmethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +initialize is a special case that should never be copied</span></span><br><span class="line">        <span class="comment">// into a class, as it performs initialization for the concrete</span></span><br><span class="line">        <span class="comment">// protocol</span></span><br><span class="line">        <span class="comment">// +initialize 不能被注入.</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">@selector</span>(initialize)) &#123;</span><br><span class="line">            <span class="comment">// so just continue looking through the rest of the methods</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if a class method already exists (on this</span></span><br><span class="line">        <span class="comment">// class or on a superclass)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// since 'class' is considered to be an instance of 'metaclass',</span></span><br><span class="line">        <span class="comment">// this is actually checking for class methods (despite the</span></span><br><span class="line">        <span class="comment">// function name)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(metaclass, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this class method to the metaclass in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(metaclass, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the instance method list  管理内存</span></span><br><span class="line">    free(imethodList); imethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the class method list</span></span><br><span class="line">    free(cmethodList); cmethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use [containerClass class] and discard the result to call +initialize</span></span><br><span class="line">    <span class="comment">// on containerClass if it hasn't been called yet</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this is to allow the concrete protocol to perform custom initialization</span></span><br><span class="line">    <span class="comment">// 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行.</span></span><br><span class="line">    (<span class="keyword">void</span>)[containerClass <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ext_specialProtocolReadyForInjection (Protocol *protocol) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work   加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through all the special protocols in our list, trying to find the</span></span><br><span class="line">        <span class="comment">// one associated with 'protocol'</span></span><br><span class="line">        <span class="comment">// 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocols[i].protocol == protocol) &#123;</span><br><span class="line">                <span class="comment">// found the matching special protocol, check to see if it's</span></span><br><span class="line">                <span class="comment">// already ready</span></span><br><span class="line">                <span class="keyword">if</span> (!specialProtocols[i].ready) &#123;</span><br><span class="line">                    <span class="comment">// if it's not, mark it as being ready now</span></span><br><span class="line">                    specialProtocols[i].ready = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// since this special protocol was in our array, and it was not</span></span><br><span class="line">                    <span class="comment">// loaded, the total number of protocols loaded must be less</span></span><br><span class="line">                    <span class="comment">// than the total count at this point in time</span></span><br><span class="line">                    assert(specialProtocolsReady &lt; specialProtocolCount);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ... and then increment the total number of special protocols</span></span><br><span class="line">                    <span class="comment">// loaded – if it now matches the total count of special</span></span><br><span class="line">                    <span class="comment">// protocols, begin the injection process</span></span><br><span class="line">                    <span class="keyword">if</span> (++specialProtocolsReady == specialProtocolCount)</span><br><span class="line">                        <span class="comment">// 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入.</span></span><br><span class="line">                        ext_injectSpecialProtocols();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面都是准备工作，接下来开始进入核心方法进行注入。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function actually performs the hard work of special protocol injection.</span></span><br><span class="line"><span class="comment"> * It obtains a full list of all classes registered with the Objective-C</span></span><br><span class="line"><span class="comment"> * runtime, finds those conforming to special protocols, and then runs the</span></span><br><span class="line"><span class="comment"> * injection blocks as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectSpecialProtocols (<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don't lock specialProtocolsLock in this function, as it is called only</span></span><br><span class="line"><span class="comment">     * from public functions which already perform the synchronization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This will sort special protocols in the order they should be loaded. If</span></span><br><span class="line"><span class="comment">     * a special protocol conforms to another special protocol, the former</span></span><br><span class="line"><span class="comment">     * will be prioritized above the latter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对协议进行排序.</span></span><br><span class="line">    <span class="comment">// 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的  load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现.</span></span><br><span class="line">    <span class="comment">// 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面.</span></span><br><span class="line">    qsort_b(specialProtocols, specialProtocolCount, <span class="keyword">sizeof</span>(EXTSpecialProtocol), ^(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)&#123;</span><br><span class="line">        <span class="comment">// if the pointers are equal, it must be the same protocol</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoA = a;</span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoB = b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A higher return value here means a higher priority</span></span><br><span class="line">        <span class="keyword">int</span> (^protocolInjectionPriority)(<span class="keyword">const</span> EXTSpecialProtocol *) = ^(<span class="keyword">const</span> EXTSpecialProtocol *specialProtocol)&#123;</span><br><span class="line">            <span class="keyword">int</span> runningTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">                <span class="comment">// the pointer passed into this block is guaranteed to point</span></span><br><span class="line">                <span class="comment">// into the 'specialProtocols' array, so we can compare the</span></span><br><span class="line">                <span class="comment">// pointers directly for identity</span></span><br><span class="line">                <span class="keyword">if</span> (specialProtocol == specialProtocols + i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol))</span><br><span class="line">                    runningTotal++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> runningTotal;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will return:</span></span><br><span class="line"><span class="comment">         * 0 if the protocols are equal in priority (such that load order does not matter)</span></span><br><span class="line"><span class="comment">         * &lt; 0 if A is more important than B</span></span><br><span class="line"><span class="comment">         * &gt; 0 if B is more important than A</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取项目中所有的类</span></span><br><span class="line">    <span class="keyword">unsigned</span> classCount = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!classCount) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: No classes registered with the runtime\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Class *allClasses = (Class *)malloc(<span class="keyword">sizeof</span>(Class) * (classCount + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!allClasses) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: Could not allocate space for %u classes\n"</span>, classCount);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use this instead of ext_copyClassList() to avoid sending +initialize to</span></span><br><span class="line"><span class="comment">// classes that we don't plan to inject into (this avoids some SenTestingKit</span></span><br><span class="line"><span class="comment">// timing issues)</span></span><br><span class="line">classCount = objc_getClassList(allClasses, classCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set up an autorelease pool in case any Cocoa classes get used during</span></span><br><span class="line"><span class="comment">     * the injection process or +initialize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// loop through the special protocols, and apply each one to all the</span></span><br><span class="line">        <span class="comment">// classes in turn</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in</span></span><br><span class="line">        <span class="comment">// the order in which they appear in specialProtocols. Consider classes</span></span><br><span class="line">        <span class="comment">// X and Y that implement protocols A and B, respectively. B needs to get</span></span><br><span class="line">        <span class="comment">// its implementation into Y before A gets into X.</span></span><br><span class="line">        <span class="comment">// 遍历所有的要注入的协议结构体.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            Protocol *protocol = specialProtocols[i].protocol;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// transfer ownership of the injection block to ARC and remove it</span></span><br><span class="line">            <span class="comment">// from the structure</span></span><br><span class="line">            <span class="comment">// 使用 __bridge_transfer 把对象的内存管理交给 ARC.</span></span><br><span class="line">            ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer <span class="keyword">id</span>)specialProtocols[i].injectionBlock;</span><br><span class="line">            specialProtocols[i].injectionBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop through all classes   遍历所有的类</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> classIndex = <span class="number">0</span>;classIndex &lt; classCount;++classIndex) &#123;</span><br><span class="line">                Class <span class="keyword">class</span> = allClasses[classIndex];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// if this class doesn't conform to the protocol, continue to the</span></span><br><span class="line">                <span class="comment">// next class immediately</span></span><br><span class="line">                <span class="comment">// 如果这个类遵守了要注入的协议，那么就执行注入</span></span><br><span class="line">                <span class="comment">// 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法.</span></span><br><span class="line">                <span class="keyword">if</span> (!class_conformsToProtocol(<span class="keyword">class</span>, protocol))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                injectionBlock(<span class="keyword">class</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理内存.</span></span><br><span class="line">    <span class="comment">// free the allocated class list</span></span><br><span class="line">    free(allClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that everything's injected, the special protocol list can also be</span></span><br><span class="line">    <span class="comment">// destroyed</span></span><br><span class="line">    free(specialProtocols); specialProtocols = <span class="literal">NULL</span>;</span><br><span class="line">    specialProtocolCount = <span class="number">0</span>;</span><br><span class="line">    specialProtocolCapacity = <span class="number">0</span>;</span><br><span class="line">    specialProtocolsReady = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 </p><h6 id="10-4-3-问题在哪？"><a href="#10-4-3-问题在哪？" class="headerlink" title="10.4.3 问题在哪？"></a>10.4.3 问题在哪？</h6><p>接下来讨论 EXTConcreteProtocol 的缺点。</p><p>如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。</p><p>这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。</p><p>这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。</p><h4 id="10-5-解决方案"><a href="#10-5-解决方案" class="headerlink" title="10.5 解决方案"></a>10.5 解决方案</h4><p>从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。</p><p>那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。</p><p>但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。</p><p>如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f80ece7045a2e25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。</p><p>②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。</p><p>③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。</p><p>④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。</p><p><a href="https://github.com/newyjp/BLMethodInjecting" target="_blank" rel="noopener">https://github.com/newyjp/BLMethodInjecting</a></p><h2 id="十一、结语"><a href="#十一、结语" class="headerlink" title="十一、结语"></a>十一、结语</h2><p>依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。</p><h2 id="十二、文章"><a href="#十二、文章" class="headerlink" title="十二、文章"></a>十二、文章</h2><p><a href="https://blog.csdn.net/linshaolie/article/details/47037941" target="_blank" rel="noopener">依赖注入——让iOS代码更简洁</a></p><p><a href="https://blog.csdn.net/Px01Ih8/article/details/84207382" target="_blank" rel="noopener">[iOS]一次高效的依赖注入</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。&lt;/
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>利用预渲染加速iOS设备的图像显示</title>
    <link href="http://yoursite.com/2019/05/23/%E5%88%A9%E7%94%A8%E9%A2%84%E6%B8%B2%E6%9F%93%E5%8A%A0%E9%80%9FiOS%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/05/23/利用预渲染加速iOS设备的图像显示/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-07-11T11:04:07.666Z</updated>
    
    <content type="html"><![CDATA[<p>使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。</p><p>于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。</p><p>接着下面举个例子程序来验证：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ImageView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> * image;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ImageView.h"</span></span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;mach/mach_time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGRect</span> imageRect = &#123; &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ImageView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">self</span>.image) &#123;</span><br><span class="line">          <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     [superawakeFromNib];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">CGRectContainsRect</span>(rect, imageRect)) &#123;</span><br><span class="line"> </span><br><span class="line">          uint64_t start = getTickCount();</span><br><span class="line"></span><br><span class="line">          [<span class="keyword">self</span>.image drawInRect:imageRect];</span><br><span class="line"></span><br><span class="line">          uint64_t drawTime = getTickCount() - start;</span><br><span class="line"> </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%llu"</span>, drawTime);  <span class="comment">// 打印时间间隔    </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。</span></span><br><span class="line">uint64_t getTickCount(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">static</span> mach_timebase_info_data_t sTimebaseInfo;</span><br><span class="line"></span><br><span class="line">     uint64_t machTime = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Convert to nanoseconds - if this is the first time we've run, get the timebase.</span></span><br><span class="line">    <span class="keyword">if</span> (sTimebaseInfo.denom == <span class="number">0</span>) &#123;</span><br><span class="line">         (<span class="keyword">void</span>)mach_timebase_info(&amp;sTimebaseInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom;  <span class="comment">// 纳秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> millis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>测试用一张 1838 * 890 的图</p><p>2018-07-05 11:05:25.950978+0800 Demo[5831:113872] <font color="#cc0000">31802012</font></p><p>接下来就是见证奇迹的时刻了，把这段代码加入程序：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGSize</span> imageSize = &#123;<span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">self</span>.image) &#123;</span><br><span class="line">          <span class="keyword">self</span>.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"xxx"</span>];</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 由于JPEG图像是不透明的，所以第二个参数就设为YES</span></span><br><span class="line">          <span class="comment">// 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了</span></span><br><span class="line">          <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(imageSize, <span class="literal">YES</span>, <span class="number">0</span>);</span><br><span class="line">          <span class="comment">// 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作</span></span><br><span class="line">          [image drawInRect:imageRect];</span><br><span class="line">          <span class="keyword">self</span>.image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">          <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。</p><p>时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] <font color="#cc0000">127939</font>，缩短了很多。</p><p>还能更快吗？让我们来试试 Core Graphics。</p><p>先定义一个全局的 CGImageRef 变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CGImageRef</span> imageRef;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)awakeFromNib</span><br><span class="line">&#123;</span><br><span class="line">    imageRef = <span class="keyword">self</span>.image.CGImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">     CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">     CGContextDrawImage(context, imageRect, imageRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] <font color="#cc0000">27425265</font>，而且图像还上下颠倒了⋯</p><p>这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br></pre></td></tr></table></figure><p>这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] <font color="#cc0000">34242146</font>，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。&lt;/p&gt;
&lt;p&gt;于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Pe
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>最长上升子序列</title>
    <link href="http://yoursite.com/2019/05/23/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/23/最长上升子序列/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-08-02T07:35:25.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, <font color="#cc0000">3</font>, <font color="#cc0000">4</font>, 8, <font color="#cc0000">6</font>, <font color="#cc0000">7</font>] 返回 4。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>面对这个问题，首先要定义一个”<font color="#cc0000">状态</font>“来代表它的子问题， 并且找到它的解。</p><p>注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。</p><p>假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。</p><p>这个 d(i) 就是我们要找的状态。 如果我们把 d(1) 到 d(N) 都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p><p>以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是：</p><p>5  3  4  8  6  7</p><p>根据上面找到的状态，可以得到：</p><ul><li>i = 1 的 LIS 长度 d(1) = 1, d[] = {5}</li><li>i = 2 的 LIS 长度 d(2) = 1, d[] = {3}</li><li>i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4}</li><li>i = 4 的 LIS 长度 d(4) = <font color="#cc0000">max{ d(1), d(2), d(3) } + 1</font> = 3, d[] = {3, 4, 8}</li></ul><p>状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到：</p><pre><code>d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A\[j\] &lt;= A\[i\]</code></pre><p>想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。</p><p>分析完了，上图。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-c89874d9e421af0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><h2 id="3、复杂度分析"><a href="#3、复杂度分析" class="headerlink" title="3、复杂度分析"></a>3、复杂度分析</h2><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：O(n)</p><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *d = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        </span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="comment">// 如果当前的数值 A[i] 大于 它之前的数值 A[j] &amp;&amp; 最长的段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i] &amp;&amp; d[j] + <span class="number">1</span> &gt; d[i])</span><br><span class="line">                d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; len) len = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;</span><br><span class="line">        <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、进阶：O-nlogn-算法"><a href="#5、进阶：O-nlogn-算法" class="headerlink" title="5、进阶：O(nlogn)算法"></a>5、进阶：<a href="https://www.felix021.com/blog/read.php?1587" target="_blank" rel="noopener">O(nlogn)算法</a></h2><p>假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。</p><p>定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。<font color="#cc0000">注意：B 的索引从 1 开始</font>。</p><pre><code>①、把 d\[0\] 有序地放到 B 里，令 B\[1\] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。②、把 d\[2\] 有序地放到 B 里，令 B\[1\] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d\[1\] = 2 已经没用了，因为 2 &gt; 1。③、d\[3\] = 5，因为 d\[3\] &gt; B\[1\]，所以令 B\[1+1\] = B\[2\] = d\[3\] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B\[\] = { 1, 5 }。④、d\[4\] = 3，B\[1\] &lt; d\[3\] &lt; B\[2\]，放在 B\[1\] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B\[\] = { 1, 3 }。⑤、d\[5\] = 6，因为 d\[5\] &gt; B\[2\]，所以令 B\[2+1\] = B\[3\] = d\[5\] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B\[\] = { 1, 3, 6 }。⑥、d\[6\] = 4，3 &lt; d\[6\] &lt; 6，于是把 6 替换掉，这时 Len = 3, B\[\] = { 1, 3, 4 }。⑦、d\[7\] = 8，d\[7\] &gt; B\[3\]，将 8 追加到 B 数组末尾，这时 Len = 4, B\[\] = { 1, 3, 4, 8 }。⑧、d\[8\] = 9，d\[8\] &gt; B\[4\]，将 9 追加到 B 数组末尾，这时 Len = 5, B\[\] = { 1, 3, 4, 8, 9 }。⑨、d\[9\] = 7，B\[3\]=4 &lt; d\[9\] &lt; B\[4\]=8，所以最新的 B\[4\] = 7，这时 Len = 5, B\[\] = 1, 3, 4, 7, 9。</code></pre><font color="#cc0000">注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。</font><center><img src="https://upload-images.jianshu.io/upload_images/5294842-94203c725d0f85fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><p>有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。</p><p>在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> B[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="comment">// 将 key 插入到数组末尾</span></span><br><span class="line">    <span class="keyword">if</span> (B[right] &lt; key)</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// num[left] ≤ key &lt; nums[right] 之后 left 将大于 right，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (B[mid] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">int</span>* B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 无意义</span></span><br><span class="line">    B[<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 从 1 开始是为了让 len、pos 不需要 -1 或 +1</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到插入位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = upper_bound(B, <span class="number">1</span>, len, nums[i]);</span><br><span class="line">        B[pos] = nums[i];</span><br><span class="line">        <span class="comment">// 打印 B 数组，看看每次循环的变化，B[0] 无意义</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d    "</span>, pos);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= pos; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, B[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; pos) &#123;</span><br><span class="line">            len = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">11</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h2&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, &lt;font color=&quot;#cc0000&quot;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://yoursite.com/2019/05/23/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/05/23/最长回文子串/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-08-02T07:19:41.804Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://pugqga7mf.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpg" alt></center><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">问题描述</a></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>大多数问题都可以用暴力法解决。暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。</p><ul><li><p>时间复杂度：O(n<sup>3</sup>)，假设 n 是输入字符串的长度，则 (n * (n−1))/2​ 为此类子字符串（不包括字符本身是回文的一般解法）的总数。因为验证每个子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n<sup>3</sup>)。</p></li><li><p>空间复杂度：O(1)。 </p></li></ul><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><pre><code>如果子串 Si...Sj ​是回文子串   p(i, j) = true其他情况                   p(i, j) = false</code></pre><p>因此：</p><pre><code>P(i, j) = ( P(i+1, j-1) and Si​ == Sj​)</code></pre><p>基本示例如下：</p><pre><code>P(i, i) = trueP(i, i+1) = (Si ​== Si+1​)</code></pre><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><h2 id="3、复杂度分析"><a href="#3、复杂度分析" class="headerlink" title="3、复杂度分析"></a>3、复杂度分析</h2><ul><li><p>时间复杂度：O(n<sup>2</sup>)，这里给出我们的运行时间复杂度为 O(n<sup>2</sup>)。</p></li><li><p>空间复杂度：O(n<sup>2</sup>)，该方法使用 O(n<sup>2</sup>) 的空间来存储表。</p></li></ul><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || <span class="built_in">strlen</span>(s) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">int</span> matrix[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">            matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i 从倒数第二个开始，从右往左。标识子串的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">        matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// j 从 i 的下一位开始，从左往右。标识子串的结束位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ①、s[i] == s[j]     ②、小于或等于 3 个字符     ③、内缩一位是回文子串</span></span><br><span class="line">            matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; <span class="number">3</span> || matrix[i+<span class="number">1</span>][j<span class="number">-1</span>]));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获得最长的子串位置</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &amp;&amp; right - left &lt; j - i) &#123;</span><br><span class="line">                left  = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d   "</span>, matrix[m][k]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* sub = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        sub[i] = s[left + i];  <span class="comment">//strncpy(sub, s+left, right+1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    sub[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, longestPalindrome(<span class="string">"aaabaaaa"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码：</p><font color="#cc0000">matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); 以及 i 和 j 的取值方向</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://pugqga7mf.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpg&quot; alt&gt;&lt;/center&gt;

&lt;h2 id=&quot;1、问题描述
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>爬楼梯</title>
    <link href="http://yoursite.com/2019/05/23/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2019/05/23/爬楼梯/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-08-02T07:41:20.954Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://pugqga7mf.bkt.clouddn.com/ClimbStairs.jpg" alt></center><p>原文：<a href="https://juejin.im/post/5a29d52cf265da43333e4da7" target="_blank" rel="noopener">漫画：什么是动态规划？</a></p><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>从简单的分析，要到第 10 级台阶，有多少种方法？要么从 9 级跨 1 级，要么从 8 级跨 1 级。</p><p>记 10 级台阶的状态为 f(10)，9 级台阶的状态为 f(9)，8 级台阶的状态为 f(8)，那么 f(10) = f(9) + f(8)。</p><center><br>f(9) = f(8) + f(7)<br><br>…<br><br>f(2) = 2<br><br>f(1) = 1<br></center><p>f(8)、f(9) 是 f(10) 的【最优子结构】；f(1)、f(2) 是【边界】；f(n) = f(n-1) + f(n-2) 是【状态转移方程】。</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><p>①、递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> getClimbingWays(n - <span class="number">1</span>) + getClimbingWays(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归调用的执行过程和一颗二叉树一样，所以它的时间复杂度就是叶子节点数。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-e71ec2814301b5d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><p>时间复杂度：O(2<sup>n</sup>)</p><p>②、备忘录算法</p><p>递归方法中会重复计算相同的值，如图中的 f(n-3)。用缓存，先创建一个哈希表，每次把不同参数的计算结果存入哈希。当遇到相同参数时，再从哈希表里去除，避免重复计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* hashMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (hashMap[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = getClimbingWays(n - <span class="number">1</span>, hashMap) + getClimbingWays(n - <span class="number">2</span>, hashMap);</span><br><span class="line">        hashMap[n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashMap[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* hashMap = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getClimbingWays(n, hashMap));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>③、动态规划法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://pugqga7mf.bkt.clouddn.com/ClimbStairs.jpg&quot; alt&gt;&lt;/center&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://juejin.im/post/5a29d52cf265da43333
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
</feed>
