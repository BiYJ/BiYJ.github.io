<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-13T02:05:34.493Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WKWebView</title>
    <link href="http://yoursite.com/2019/06/13/WKWebView/"/>
    <id>http://yoursite.com/2019/06/13/WKWebView/</id>
    <published>2019-06-13T02:05:34.492Z</published>
    <updated>2019-06-13T02:05:34.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、同步执行-JS"><a href="#一、同步执行-JS" class="headerlink" title="一、同步执行 JS"></a>一、同步执行 JS</h2><p>官方提供的方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">evaluateJavaScript</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">javaScriptString</span> </span><br><span class="line">         <span class="selector-tag">completionHandler</span><span class="selector-pseudo">:(void</span> (^ _Nullable)(_Nullable id, NSError * _Nullable error))<span class="selector-tag">completionHandler</span>;</span><br></pre></td></tr></table></figure><p>这个方法是<font color="#CC0000">异步</font>的，同步实现方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)syncExecScript:(<span class="built_in">NSString</span> *)jsString</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">BOOL</span> finished = <span class="literal">NO</span>;</span><br><span class="line">    __block <span class="built_in">NSString</span> * str = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.webview evaluateJavaScript:jsString completionHandler:^(<span class="keyword">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        str = result;</span><br><span class="line">        finished = <span class="literal">YES</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">while</span> (!finished)</span><br><span class="line">    &#123;</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  返回 js 方法执行结果。仿照 UIWebView 的函数名</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByEvaluatingJavaScriptFromString:(<span class="built_in">NSString</span> *)jsString</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> * str = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.viewModel.wkWebView evaluateJavaScript:jsString completionHandler:^(<span class="built_in">NSString</span> * result, <span class="built_in">NSError</span> * error)&#123;</span><br><span class="line">        str = result;</span><br><span class="line">        <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CFRunLoopRun</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">nil</span> || [str isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        str = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接这么写会出现卡死现象。原因：<font color="#cc0000">JS 是单线程的</font>。</p><p>所以，JS 的单线程触发了 WKWebView 的截获事件，一直等着 WKWebView 来告诉它要不要跳转。然后 iOS 的这个线程又调用了 JS 语句，返回数据后才能去做其他事情。于是就<font color="#cc0000">死锁</font>了。</p><p>解决办法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  判断链接是否允许跳转</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">webView</span><span class="selector-pseudo">:(WKWebView</span> *)<span class="selector-tag">webView</span> <span class="selector-tag">decidePolicyForNavigationAction</span><span class="selector-pseudo">:(WKNavigationAction</span> *)<span class="selector-tag">navigationAction</span> <span class="selector-tag">decisionHandler</span><span class="selector-pseudo">:(void</span> (^)(WKNavigationActionPolicy))<span class="selector-tag">decisionHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">decisionHandler</span>(WKNavigationActionPolicyCancel); </span><br><span class="line"></span><br><span class="line"><span class="comment">// decisionHandler(retFlag ?  WKNavigationActionPolicyAllow : WKNavigationActionPolicyCancel);</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、同步执行-JS&quot;&gt;&lt;a href=&quot;#一、同步执行-JS&quot; class=&quot;headerlink&quot; title=&quot;一、同步执行 JS&quot;&gt;&lt;/a&gt;一、同步执行 JS&lt;/h2&gt;&lt;p&gt;官方提供的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight less
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 编译过程原理(2)</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86(2)/"/>
    <id>http://yoursite.com/2019/05/23/iOS 编译过程原理(2)/</id>
    <published>2019-05-23T10:19:03.942Z</published>
    <updated>2019-05-24T08:52:56.548Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://me.csdn.net/Hello_Hwc" target="_blank" rel="noopener">黄文臣</a>/<a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147" target="_blank" rel="noopener">深入浅出iOS编译</a></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚：</p><ul><li>Clang 和 LLVM 究竟是什么</li><li>源文件到机器码的细节</li><li>Linker 做了哪些工作</li><li>编译顺序如何确定</li><li>头文件是什么？XCode 是如何找到头文件的？</li><li>Clang Module</li><li>签名是什么？为什么要签名</li></ul><p>为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。</p><h2 id="二、编译器"><a href="#二、编译器" class="headerlink" title="二、编译器"></a>二、编译器</h2><blockquote><p>把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做<a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">编译器</a>。</p></blockquote><p>大多数编译器由两部分组成：前端和后端。</p><ul><li>前端负责词法分析、语法分析、生成中间代码；</li><li>后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。</li></ul><p><font color="#cc0000">前后端依赖统一格式的中间代码（IR）</font>，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。</p><p>Objective-C/C/C++ 使用的编译器前端是<a href="https://clang.llvm.org/docs/index.html" target="_blank" rel="noopener">clang</a>，swift 是 <a href="https://swift.org/compiler-stdlib/#compiler-architecture" target="_blank" rel="noopener">swift</a>，后端都是 <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-dd65ea5de43d8fc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19"></p><h2 id="三、LLVM"><a href="#三、LLVM" class="headerlink" title="三、LLVM"></a>三、LLVM</h2><p>LLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。</p><p><font color="#cc0000">LLVM 的核心库提供了现代化的 source-target-independent <a href="https://llvm.org/docs/Passes.html" target="_blank" rel="noopener">优化器</a>和支持诸多流行 CPU 架构的代码生成器</font>，这些核心代码是围绕着 LLVM IR（中间代码）建立的。</p><p>基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。</p><h2 id="四、clang"><a href="#四、clang" class="headerlink" title="四、clang"></a>四、clang</h2><p>clang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-867e93a43ad184f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20"></p><p>接下来，从代码层面看一下具体的转化过程，新建一个 main.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello debug\\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、预处理（preprocessor）"><a href="#五、预处理（preprocessor）" class="headerlink" title="五、预处理（preprocessor）"></a>五、预处理（preprocessor）</h2><p>预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。</p><p>#include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，<font color="#cc0000">这个过程是递归的</font>：因为 stdio.h 也有可能包含其他头文件。</p><p>用 clang 查看预处理的结果：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xcrun clang -E main.c</span><br></pre></td></tr></table></figure><p>预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -E main.c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __vsnprintf_chk (<span class="keyword">char</span> * <span class="keyword">restrict</span>, <span class="keyword">size_t</span>, <span class="keyword">int</span>, <span class="keyword">size_t</span>,</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line"># <span class="number">412</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">10</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello debug\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在预处理的时候，注释被删除，条件编译被处理。</p><h2 id="六、词法分析（lexical-anaysis）"><a href="#六、词法分析（lexical-anaysis）" class="headerlink" title="六、词法分析（lexical anaysis）"></a>六、词法分析（lexical anaysis）</h2><p>词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -<span class="type">Xclang</span> -<span class="built_in">dump</span>-tokens main.<span class="built_in">c</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c</span><br><span class="line">annot_module_include '#include &lt;stdio.h&gt;</span><br><span class="line">// 一点注释</span><br><span class="line">#define DEBUG 1</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    printf("hello debug\n");</span><br><span class="line">#else</span><br><span class="line">    printf'Loc=&lt;main.c:<span class="number">9</span>:<span class="number">1</span>&gt;</span><br><span class="line">int <span class="string">'int'</span> [StartOfLine]Loc=&lt;main.c:<span class="number">14</span>:<span class="number">1</span>&gt;</span><br><span class="line">identifier <span class="string">'main'</span> [LeadingSpace]Loc=&lt;main.c:<span class="number">14</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>Loc=&lt;main.c:<span class="number">14</span>:<span class="number">9</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>Loc=&lt;main.c:<span class="number">14</span>:<span class="number">10</span>&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span> [LeadingSpace]Loc=&lt;main.c:<span class="number">14</span>:<span class="number">12</span>&gt;</span><br><span class="line">identifier <span class="string">'printf'</span> [StartOfLine] [LeadingSpace]Loc=&lt;main.c:<span class="number">16</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>Loc=&lt;main.c:<span class="number">16</span>:<span class="number">11</span>&gt;</span><br><span class="line">string_literal <span class="string">'"hello debug\n"'</span>Loc=&lt;main.c:<span class="number">16</span>:<span class="number">12</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>Loc=&lt;main.c:<span class="number">16</span>:<span class="number">27</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>Loc=&lt;main.c:<span class="number">16</span>:<span class="number">28</span>&gt;</span><br><span class="line">return <span class="string">'return'</span> [StartOfLine] [LeadingSpace]Loc=&lt;main.c:<span class="number">20</span>:<span class="number">5</span>&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span> [LeadingSpace]Loc=&lt;main.c:<span class="number">20</span>:<span class="number">12</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>Loc=&lt;main.c:<span class="number">20</span>:<span class="number">13</span>&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span> [StartOfLine]Loc=&lt;main.c:<span class="number">21</span>:<span class="number">1</span>&gt;</span><br><span class="line">eof <span class="string">''</span>Loc=&lt;main.c:<span class="number">21</span>:<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure><p>Loc=\<a href="main.c:9:1\" target="_blank" rel="noopener">main.c:9:1\</a> 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。</p><h2 id="七、语法分析（semantic-analysis）"><a href="#七、语法分析（semantic-analysis）" class="headerlink" title="七、语法分析（semantic analysis）"></a>七、语法分析（semantic analysis）</h2><p>词法分析的 Token 流会被解析成<font color="#cc0000">一颗抽象语法树（abstract syntax tree - AST）</font>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fsyntax-only -<span class="type">Xclang</span> -ast-<span class="built_in">dump</span> main.<span class="built_in">c</span> | <span class="keyword">open</span> -f</span><br></pre></td></tr></table></figure><p>main 函数 AST 的结构：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTranslationUnitDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18166e8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816c60</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __int128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816980</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816cd0</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __uint128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18169a0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816fa8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __NSConstantString[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mRecordType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816db0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mRecord[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816d28</span>[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m '__NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817040</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_ms_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mPointerType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817000</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816780</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817308</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit referenced[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __va_list_tag [<span class="number">1</span>]'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mConstantArrayType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18172b0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有了抽象语法树，<font color="#cc0000">clang 就可以对这个树进行分析，找出代码中的错误</font>。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。</p><p>AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：<a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a>。</p><h2 id="八、CodeGen"><a href="#八、CodeGen" class="headerlink" title="八、CodeGen"></a>八、CodeGen</h2><p>CodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xcrun</span> <span class="selector-tag">clang</span> <span class="selector-tag">-S</span> <span class="selector-tag">-emit-llvm</span> <span class="selector-tag">main</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.ll</span></span><br></pre></td></tr></table></figure><p>main.ll 文件内容：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ModuleID = 'main.c'</span></span><br><span class="line"><span class="comment">source_filename = "main.c"</span></span><br><span class="line"><span class="comment">target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line"><span class="comment">target triple = "x86_64-apple-macosx10.13.0"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello debug\0A\00", align 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone ssp uwtable</span></span><br><span class="line"><span class="comment">define i32 @main() #0 &#123;</span></span><br><span class="line"><span class="comment">  %1 = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  store i32 0, i32* %1, align 4</span></span><br><span class="line"><span class="comment">  %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">...</span></span><br></pre></td></tr></table></figure><p>Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。</p><p>LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 <a href="http://llvm.org/doxygen/classllvm_1_1Pass.html" target="_blank" rel="noopener">Pass</a> 类的子类，每个节点负责做特定的优化，更多细节：<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a>。</p><h2 id="九、生成汇编代码"><a href="#九、生成汇编代码" class="headerlink" title="九、生成汇编代码"></a>九、生成汇编代码</h2><p>LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。</p><p>生成 arm 64 汇编：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -S main<span class="selector-class">.c</span> -o main.s</span><br></pre></td></tr></table></figure><p>查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：<a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Basic/iOS%20assembly%20toturial%20part%201.md" target="_blank" rel="noopener">iOS汇编快速入门</a>。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.section__TEXT,__text,regular,pure_instructions</span><br><span class="line">.macosx_version_min <span class="number">10</span>, <span class="number">13</span></span><br><span class="line">.globl_main                   <span class="comment">## -- Begin function main</span></span><br><span class="line">.p2align<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line">_main:                                  <span class="comment">## @main</span></span><br><span class="line">.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq$16, %rsp</span><br><span class="line">leaqL<span class="number">_</span>.str(%rip), %rdi</span><br><span class="line">movl$0, -<span class="number">4</span>(%rbp)</span><br><span class="line">movb$0, %al</span><br><span class="line">callq_printf</span><br><span class="line">xorl%ecx, %ecx</span><br><span class="line">movl%eax, -<span class="number">8</span>(%rbp)          <span class="comment">## 4-byte Spill</span></span><br><span class="line">movl%ecx, %eax</span><br><span class="line">addq$16, %rsp</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line">.section__TEXT,__cstring,cstring_literals</span><br><span class="line">L<span class="number">_</span>.str:                                 <span class="comment">## @.str</span></span><br><span class="line">.asciz<span class="string">"hello debug\n"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><h2 id="十、汇编器"><a href="#十、汇编器" class="headerlink" title="十、汇编器"></a>十、汇编器</h2><p>汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -<span class="keyword">c</span> main.<span class="keyword">c</span> -o main.o</span><br></pre></td></tr></table></figure><p>还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> main.o</span><br><span class="line">                 (undefined) external _printf</span><br><span class="line"><span class="number">0000000000000000</span> (\<span class="symbol">_</span>\_TEXT,\<span class="symbol">_</span>\_text) external _main</span><br></pre></td></tr></table></figure><p>_printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。</p><h3 id="10-1-什么是符号（Symbols）"><a href="#10-1-什么是符号（Symbols）" class="headerlink" title="10.1 什么是符号（Symbols）?"></a>10.1 什么是符号（Symbols）?</h3><p>符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。</p><h2 id="十一、链接"><a href="#十一、链接" class="headerlink" title="十一、链接"></a>十一、链接</h2><p>连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang main<span class="selector-class">.o</span> -o main</span><br></pre></td></tr></table></figure><p>就得到了一个 mach o 格式的可执行文件</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: Mach-O 64-bit executable x86_64</span><br><span class="line">$ ./main</span><br><span class="line">hello debug</span><br><span class="line"></span><br><span class="line">再用 nm 命令，查看可执行文件的符号表：</span><br><span class="line"></span><br><span class="line">$ nm -nm main</span><br><span class="line">                 (undefined) external _printf (from libSystem)</span><br><span class="line">                 (undefined) external dyld<span class="symbol">\_</span>stub<span class="symbol">\_</span>binder (from libSystem)</span><br><span class="line">0000000100000000 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) <span class="symbol">\[</span>referenced dynamically<span class="symbol">\]</span> external <span class="symbol">\_</span><span class="symbol">\_</span>mh<span class="symbol">\_</span>execute_header</span><br><span class="line">0000000100000f60 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) external _main</span><br></pre></td></tr></table></figure><p>_printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。</p><h2 id="十二、XCode-编译"><a href="#十二、XCode-编译" class="headerlink" title="十二、XCode 编译"></a>十二、XCode 编译</h2><p>通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？</p><p>新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-850e886824831a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21"></p><p>详细的步骤：</p><ul><li>创建 Product.app 的文件夹</li><li>把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。</li><li>创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。</li><li>执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。</li><li>编译 .m 文件，生成 .o 文件。</li><li>链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。</li><li>编译 assets，编译 storyboard，链接 storyboard</li><li>拷贝动态库 Logger.framework，并且对其签名</li><li>执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework</li><li>对 Demo.App 签名，并验证（validate）</li><li>生成 Product.app</li><li>生成 dYSM 文件</li></ul><blockquote><p>Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。</p></blockquote><h2 id="十三、编译顺序"><a href="#十三、编译顺序" class="headerlink" title="十三、编译顺序"></a>十三、编译顺序</h2><p>编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？</p><blockquote><p>答案是：依赖关系。</p></blockquote><p>还是以刚刚的 Demo 项目为例，整个依赖关系如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b0c7342fdc5b545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22"></p><p>可以从 XCode 的 Report Navigator 看到 Target 的编译顺序：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1c02d00b99428ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23"></p><p>XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。</p><p>那么，XCode 又从哪里得到了这些依赖关系呢？</p><ul><li>Target Dependencies - 显式声明的依赖关系</li><li>Linked Frameworks and Libraries - 隐式声明的依赖关系</li><li>Build Phase - 定义了编译一个 Target 的每一步</li></ul><h2 id="十四、增量编译"><a href="#十四、增量编译" class="headerlink" title="十四、增量编译"></a>十四、增量编译</h2><p>日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？</p><p>因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。</p><p>比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0eaaea9ee243f79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="24"></p><h2 id="十五、头文件"><a href="#十五、头文件" class="headerlink" title="十五、头文件"></a>十五、头文件</h2><p>C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。</p><p>头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b5be48b5d1a1c97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25"></p><p>当只有声明，没有实现的时候，链接器就会报错。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture arm64:</span><br><span class="line">“_umimplementMethod”, referenced <span class="keyword">from</span>:</span><br><span class="line">-\[ClassA <span class="function"><span class="keyword">method</span>\] <span class="title">in</span> <span class="title">ClassA</span>.<span class="title">o</span></span></span><br><span class="line"><span class="function"><span class="title">ld</span>:</span> symbol(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture arm64</span><br><span class="line">clang: error: linker command failed <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">1</span> (use -v <span class="keyword">to</span> see invocation)</span><br></pre></td></tr></table></figure><p>Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。</p><p>日常开发中，两种常见的头文件引入方式：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"CustomClass.h"</span> // 自定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span> // 系统或者内部 framework</span></span><br></pre></td></tr></table></figure><p>引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？</p><p>回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d620556105843b4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="27"></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d1cd2dd2e5bb8a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="26"></p><p>把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "..." search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory)</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">clang</span>/10.0.0/<span class="title">include</span></span></span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/System/Library/Frameworks (framework directory)</span><br><span class="line"> </span><br><span class="line">End <span class="keyword">of</span> search list.</span><br></pre></td></tr></table></figure><p>这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。</p><p>可以通过一个辅助的小工具 <a href="https://github.com/milend/hmap" target="_blank" rel="noopener">hmap</a> 查看 hmap 中的内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./hmap print Demo-project-headers<span class="selector-class">.hmap</span> </span><br><span class="line">AppDelegate<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.h</span><br><span class="line">Demo-Bridging-Header<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.h</span><br><span class="line">Dummy<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.h</span><br><span class="line">Framework<span class="selector-class">.h</span> -&gt; Framework/Framework.h</span><br><span class="line">TestView<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.h</span><br><span class="line">ViewController<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h</span><br></pre></td></tr></table></figure><blockquote><p>这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。</p></blockquote><p>clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>AFNetworking<span class="regexp">/AFNetworking.framework/</span>Headers/TestView.h</span><br><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>SDWebImage<span class="regexp">/SDWebImage.framework/</span>Headers/TestView.h</span><br></pre></td></tr></table></figure><p>系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。</p><p>以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时：</p><p>首先查找 framework 是否存在</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework</span><br></pre></td></tr></table></figure><p>如果 framework 存在，再在 headers 目录里查找头文件是否存在</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/headers/</span>Foundation.h</span><br></pre></td></tr></table></figure><h2 id="十六、Clang-Module"><a href="#十六、Clang-Module" class="headerlink" title="十六、Clang Module"></a>十六、Clang Module</h2><p>传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的：</p><ol><li>大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。</li><li>文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。</li><li>边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。</li></ol><p><a href="https://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">clang module</a> 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。</p><p>XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。</p><p>#import &lt;Foundation/NSString.h&gt; 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f9261463ed11b9e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="28"></p><p>那么，如何定义一个 module 呢？答案是：<font color="#cc0000">modulemap 文件，这个文件描述了一组头文件如何转换为一个 module</font>，举个例子：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">framework</span> module Foundation  \[extern_c\] \[system\] &#123;</span><br><span class="line">umbrella header <span class="string">"Foundation.h"</span> // 所有要暴露的头文件</span><br><span class="line"> <span class="meta">export</span> *</span><br><span class="line">module * &#123;</span><br><span class="line"> <span class="meta">export</span> *</span><br><span class="line"> &#125;</span><br><span class="line"> explicit module NSDebug &#123; //<span class="keyword">submodule</span></span><br><span class="line"><span class="keyword"> </span>header <span class="string">"NSDebug.h"</span></span><br><span class="line"> <span class="meta">export</span> *</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="keyword">swift </span>是可以直接 <span class="meta">import</span> 一个 clang module 的，比如你有一些 C 库，需要在 <span class="keyword">Swift </span>中使用，就可以用 modulemap 的方式。</span><br><span class="line"></span><br><span class="line">## 十七、<span class="keyword">Swift </span>编译</span><br><span class="line"></span><br><span class="line">现代化的语言几乎都抛弃了头文件，<span class="keyword">swift </span>也不例外。问题来了，<span class="keyword">swift </span>没有头文件又是怎么找到声明的呢？</span><br><span class="line"></span><br><span class="line">&gt; 编译器干了这些脏活累活。编译一个 <span class="keyword">Swift </span>头文件，需要解析 module 中所有的 <span class="keyword">Swift </span>文件，找到对应的声明。</span><br><span class="line"></span><br><span class="line">![<span class="number">29</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-<span class="keyword">bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">当开发中难免要有 </span>Objective-C 和 <span class="keyword">Swift </span>相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？</span><br><span class="line"></span><br><span class="line">### <span class="number">17</span>.<span class="number">1</span> <span class="keyword">Swift </span>引用 Objective-C</span><br><span class="line"></span><br><span class="line"><span class="keyword">Swift </span>的编译器内部使用了 clang，所以 <span class="keyword">swift </span>可以直接使用 clang module，从而支持直接 <span class="meta">import</span> Objective-C 编写的framework。</span><br><span class="line"></span><br><span class="line">![<span class="number">30</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/<span class="keyword">strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> </span><br><span class="line"><span class="keyword">swift </span>编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：</span><br><span class="line"></span><br><span class="line">*   <span class="keyword">Bridging-Header.h </span>中暴露给 swfit 的头文件</span><br><span class="line">*   framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。</span><br><span class="line"></span><br><span class="line"><span class="symbol">XCode</span> 提供了宏定义 NS\_SWIFT\_NAME 来让开发者定义 Objective-C =&gt; <span class="keyword">Swift的符号映射，可以通过 </span>Related <span class="keyword">Items </span>-&gt; Generate Interface 来查看转换后的结果：</span><br><span class="line"></span><br><span class="line">![<span class="number">31</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-<span class="keyword">bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">### </span><span class="number">17</span>.<span class="number">2</span> Objective-C 引用 <span class="keyword">swift</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">xcode </span>会以 module 为单位，为 <span class="keyword">swift </span>自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-<span class="keyword">Swift.h。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">swift </span>提供了关键词 <span class="comment">@objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。</span></span><br></pre></td></tr></table></figure><p>@objc public class MyClass<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## 十八、深入理解 Linker</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; &lt;font color=#cc0000&gt;链接器会把编译器编译生成的多个文件，链接成一个可执行文件&lt;/font&gt;。链接并不会产生新的代码，只是在现有代码的基础上做&lt;font color=#cc0000&gt;移动和补丁&lt;/font&gt;。</span></span><br><span class="line"></span><br><span class="line">链接器的输入可能是以下几种文件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*   </span>object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。</span><br><span class="line"><span class="bullet">*   </span>动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载</span><br><span class="line"><span class="bullet">*   </span>静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。</span><br><span class="line"><span class="bullet">*   </span>tbd，只包含符号的库文件</span><br><span class="line"></span><br><span class="line">这里提到了一个概念：符号（Symbols），那么符号是什么呢？</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。</span></span><br><span class="line"></span><br><span class="line">以一段代码为例，看看链接时究竟发生了什么？</span><br><span class="line"></span><br><span class="line">源代码：</span><br></pre></td></tr></table></figure></p><ul><li>(void)log<br>{<br>  printf(“hello world\n”);<br>}<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.o</span> 文件：</span><br></pre></td></tr></table></figure></li></ul><p>#代码<br>adrp    x0, l<em>.str@PAGE<br>add     x0, x0, l</em>.str@PAGEOFF<br>bl      _printf</p><p>#字符串符号<br>l_.str:                                 ; @.str<br>        .asciz  “hello world\n”<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 .o 文件中，字符串 "hello world\\n" 作为一个符号（l\<span class="emphasis">_.str）被引用，汇编代码读取的时候按照 l\_</span>.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>l_.str 在可执行文件的哪个位置？</span><br><span class="line"><span class="bullet">2.  </span>printf 函数来自哪里？</span><br><span class="line"></span><br><span class="line">再来看看链接之后的 mach o 文件：</span><br><span class="line"></span><br><span class="line">![<span class="string">32</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">链接器如何解决这两个问题呢？</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。</span><br><span class="line"><span class="bullet">2.  </span>链接后，不再是调用符号 \<span class="emphasis">_printf，而是在 DATA 段上创建了一个函数指针 \_</span>printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 <span class="emphasis">_printf 地址。更多细节，可以参考这篇文章：[深入理解iOS App的启动过程](https://blog.csdn.net/Hello_</span>Hwc/article/details/78317863)。</span><br><span class="line"></span><br><span class="line">Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。</span><br><span class="line"></span><br><span class="line"><span class="section">## 十九、理解签名</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 19.1 基础回顾</span></span><br><span class="line"></span><br><span class="line">非对称加密</span><br><span class="line"></span><br><span class="line">在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。</span><br><span class="line"></span><br><span class="line">数字签名</span><br><span class="line"></span><br><span class="line">数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。</span><br><span class="line"></span><br><span class="line">数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。</span><br><span class="line"></span><br><span class="line">![<span class="string">33</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。</span><br><span class="line"></span><br><span class="line">![<span class="string">34</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。</span></span><br><span class="line"></span><br><span class="line">有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。</span><br><span class="line"></span><br><span class="line"><span class="section">## 二十、iOS App 签名</span></span><br><span class="line"></span><br><span class="line">为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。</span><br><span class="line"></span><br><span class="line">除此之外，Apple 要严格控制 App 的分发：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>App 来自 Apple 信任的开发者</span><br><span class="line"><span class="bullet">2.  </span>安装的设备是 Apple 允许的设备</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.1 证书</span></span><br><span class="line"></span><br><span class="line">通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。</span><br><span class="line"></span><br><span class="line">![<span class="string">35</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.2 Provisioning Profile</span></span><br><span class="line"></span><br><span class="line">iOS App 安装到设备的途径（非越狱）有以下几种：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*   </span>开发包（插线，或者 archive 导出 develop 包）</span><br><span class="line"><span class="bullet">*   </span>Ad Hoc</span><br><span class="line"><span class="bullet">*   </span>App Store</span><br><span class="line"><span class="bullet">*   </span>企业证书</span><br><span class="line"></span><br><span class="line">开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。</span><br><span class="line"></span><br><span class="line">![<span class="string">36</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">可以通过以下命令来查看 Provisioning Profile 中的内容：</span><br></pre></td></tr></table></figure></p><p>security cms -D -i embedded.mobileprovision &gt; result.plist<br>open result.plist<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本质上就是一个编码过后的 plist。</span><br><span class="line"></span><br><span class="line">![<span class="string">37</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.3 iOS 签名</span></span><br><span class="line"></span><br><span class="line">生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。</span><br><span class="line"></span><br><span class="line">创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名</span><br></pre></td></tr></table></figure></p><p><key>Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nib</key><br><data><br>T2g5jlq7EVFHNzL/ip3fSoXKoOI=<br></data></p><p><key>Info.plist</key><br><data><br>5aVg/3m4y30m+GSB8LkZNNU3mug=<br></data></p><p><key>PkgInfo</key><br><data><br>n57qDP4tZfLD1rCS43W0B4LQjzE=<br></data></p><p><key>embedded.mobileprovision</key><br><data><br>tm/I1g+0u2Cx9qrPJeC0zgyuVUE=<br></data><br>…<br><code>`</code></p><p>代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8c96d1f4a8fcb7b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="38"></p><h3 id="20-4-验证"><a href="#20-4-验证" class="headerlink" title="20.4 验证"></a>20.4 验证</h3><h4 id="20-4-1-安装-App-的时候"><a href="#20-4-1-安装-App-的时候" class="headerlink" title="20.4.1 安装 App 的时候"></a>20.4.1 安装 App 的时候</h4><ul><li>从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者</li><li>证书验证通过后，从证书中取出 Leo 的公钥</li><li>读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确</li><li>文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证）</li><li>验证通过后，安装 App</li></ul><h4 id="20-4-2-启动-App-的时候"><a href="#20-4-2-启动-App-的时候" class="headerlink" title="20.4.2 启动 App 的时候"></a>20.4.2 启动 App 的时候</h4><ul><li>验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致</li><li>判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证</li><li>如果是企业证书，验证用户是否信任企业证书</li><li>App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。</li><li>以上都验证通过，App 才能正常启动</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://me.csdn.net/Hello_Hwc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄文臣&lt;/a&gt;/&lt;a href=&quot;https://blog.csdn.net/Hello_Hwc/article/detail
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>BFPRT 算法</title>
    <link href="http://yoursite.com/2019/05/23/BFPRT%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/05/23/BFPRT算法/</id>
    <published>2019-05-23T10:19:03.937Z</published>
    <updated>2019-05-24T09:04:46.414Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qingdujun/article/details/85255119" target="_blank" rel="noopener">https://blog.csdn.net/qingdujun/article/details/85255119</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qingdujun/article/details/85255119&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qingdujun/article
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="排序算法" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>全排列</title>
    <link href="http://yoursite.com/2019/05/23/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://yoursite.com/2019/05/23/全排列/</id>
    <published>2019-05-23T10:19:03.935Z</published>
    <updated>2019-05-24T08:49:57.905Z</updated>
    
    <content type="html"><![CDATA[<p>问题：<strong>有 n 个数或字符，有多少种排列方法</strong>。</p><p>思路：采用<font color="#cc0000">分治法</font>把大问题分解成很多的子问题。大问题是所有的排列方法，分解得到的小问题就是以 1 开头的排列，以 2 开头的排列，以 a 开头的排列，以 b 开头的排列…把这些问题继续分解，以 12 开头的排列，以 123 开头的排列…将余下的看成大问题，一直分解下去，直到分解成的子问题只有一个数字或字符的时候，不再分解。</p><p>因为 1 个数字或字符肯定只有一种排列方式，现在将每个解决了的小问题合并，合并成一个大点的问题，合并之后这个大点的问题也解决了，再将这些大点的问题合并成一个更大的问题，直到最大的问题解决为止。</p><p>先固定一个字符，然后将固定的字符与它后面的每一个进行交换，一直递归下去，直到固定的字符后面只有一个字符。</p><p>下图中，红色字符是被固定的字符，白色字符的没有被固定的字符。具体做法就是每次将没有固定的第一个字符与其他未固定的字符交换（第 1 个与第 1个交换，第 1 个与第 2 个交换，… 第 1 个与第 n 个交换），直到只剩下一个没有被固定的字符时，输出此时的字符排列，但是输出之后要将字符的位置还原。</p><p>全排列可以看做固定前 i 位，对第 i+1 位之后的再进行全排列，比如固定第一位，后面跟着 n-1 位的全排列。那么解决 n-1 位元素的全排列就能解决 n 位元素的全排列了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6fb436eb6f11a3ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapChar</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[k];</span><br><span class="line">    a[k] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">int</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 深度控制。此时只剩一个没有固定的字符，直接输出</span></span><br><span class="line">    <span class="keyword">if</span>(start == count - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(a);   <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; count; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        swapChar(a, i, start);  <span class="comment">// 交换</span></span><br><span class="line">        </span><br><span class="line">        algorithm(a, start + <span class="number">1</span>, count);</span><br><span class="line">        </span><br><span class="line">        swapChar(a, i, start);  <span class="comment">// 复原</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">100</span>] = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;  <span class="comment">// gets(a);</span></span><br><span class="line">    </span><br><span class="line">    algorithm(arr, <span class="number">0</span>, <span class="built_in">strlen</span>(arr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题：&lt;strong&gt;有 n 个数或字符，有多少种排列方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;思路：采用&lt;font color=&quot;#cc0000&quot;&gt;分治法&lt;/font&gt;把大问题分解成很多的子问题。大问题是所有的排列方法，分解得到的小问题就是以 1 开头的排列，以 2 开头的
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="分治法" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>0-1 背包</title>
    <link href="http://yoursite.com/2019/05/23/01-%E8%83%8C%E5%8C%85/"/>
    <id>http://yoursite.com/2019/05/23/01-背包/</id>
    <published>2019-05-23T10:19:03.934Z</published>
    <updated>2019-05-24T08:41:52.176Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5294842-171c0d1ec913da7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>01 背包问题是用来介绍动态规划算法最经典的例子。</p><h2 id="一、解释-1"><a href="#一、解释-1" class="headerlink" title="一、解释 1"></a>一、解释 1</h2><p><strong>①、状态方程</strong></p><font color="#cc0000">f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] }  ( j &gt;= Wi )</font><p>f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。</p><p>决策：为了背包中物品总价值最大化，<strong>第 i 件物品应该放入背包中吗</strong> ？</p><p><strong>②、实例</strong></p><p>假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f2981baf260f8184.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。</p><p>首先要明确<font color="#cc0000">这张表是至底向上，从左到右生成的</font>。</p><p>用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。</p><p>对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。</p><p>同理 c2 = 0，b2 = 3，a2 = 6。</p><p><strong>对于承重为 8 的背包，a8 = 15 是怎么得出的呢？</strong></p><p>根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。</p><p>f[i-1, j]        表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。</p><p>f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。</p><p>Pi 指的是 a 物品的价值，即 6。</p><p>由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。</p><p><strong>③、代码</strong></p><p>物品信息类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PackageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> value;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name weight:(<span class="built_in">NSInteger</span>)weight value:(<span class="built_in">NSInteger</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PackageItem</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name weight:(<span class="built_in">NSInteger</span>)weight value:(<span class="built_in">NSInteger</span>)value</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">        <span class="keyword">self</span>.weight = weight;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>非递归代码</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSArray * nameArr   = @[ @<span class="string">"a"</span>, @<span class="string">"b"</span>, @<span class="string">"c"</span>, @<span class="string">"d"</span>, @<span class="string">"e"</span> ]<span class="comment">;</span></span><br><span class="line">    NSArray * weightArr = @[ @(<span class="number">2</span>), @(<span class="number">2</span>), @(<span class="number">6</span>), @(<span class="number">5</span>), @(<span class="number">4</span>) ]<span class="comment">;</span></span><br><span class="line">    NSArray * valueArr  = @[ @(<span class="number">6</span>), @(<span class="number">3</span>), @(<span class="number">5</span>), @(<span class="number">4</span>), @(<span class="number">6</span>) ]<span class="comment">;</span></span><br><span class="line">    NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    for(<span class="name"><span class="builtin-name">int</span></span> i = <span class="number">0</span><span class="comment">; i &lt; nameArr.count; i++) &#123;</span></span><br><span class="line">        PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i]</span><br><span class="line">                                                        weight:[weightArr[i] integerValue]</span><br><span class="line">                                                         value:[valueArr[i] integerValue]]<span class="comment">;</span></span><br><span class="line">        bagItems[i] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self packageAlgorithm:bagItems bagSize:10]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *  @brief   <span class="number">01</span> 背包算法</span><br><span class="line">  */</span><br><span class="line">- (<span class="name">void</span>)packageAlgorithm:(<span class="name">NSArray</span> *)bagItems bagSize:(<span class="name">NSInteger</span>)bagSize</span><br><span class="line">&#123;</span><br><span class="line">    if (<span class="name">bagSize</span> == <span class="number">0</span> || bagItems.count == <span class="number">0</span>)  return;</span><br><span class="line">    </span><br><span class="line">    NSInteger bagMatrix[bagSize][bagItems.count]<span class="comment">;  // 是否选中数组</span></span><br><span class="line">    PackageItem * item;</span><br><span class="line">    NSInteger i = <span class="number">0</span><span class="comment">; // 背包容量，列数</span></span><br><span class="line">    NSInteger j = <span class="number">0</span><span class="comment">; // 物品数量，行数</span></span><br><span class="line">    </span><br><span class="line">    // 初始化数组</span><br><span class="line">    for (<span class="comment">; i &lt;= bagSize; i++) &#123;</span></span><br><span class="line">        for (<span class="name">j</span> = <span class="number">0</span><span class="comment">; j &lt; bagItems.count; j++)</span></span><br><span class="line">            bagMatrix[i][j] = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 打印二维数组内容</span><br><span class="line">    for (<span class="name">j</span> = <span class="number">0</span><span class="comment">; j &lt; bagItems.count; j++) &#123;</span></span><br><span class="line">        for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt;= bagSize; i++)</span></span><br><span class="line">            printf(<span class="string">"%ld    "</span>, (<span class="name">long</span>)bagMatrix[i][j])<span class="comment">;</span></span><br><span class="line">        printf(<span class="string">"\n"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"\n"</span>)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt;= bagSize; i++) &#123;</span></span><br><span class="line">        </span><br><span class="line">        // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取</span><br><span class="line">        for (<span class="name">j</span> = bagItems.count - <span class="number">1</span><span class="comment">; j &gt; -1; j--) &#123;</span></span><br><span class="line">            </span><br><span class="line">            item = bagItems[j]<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            // 装不下</span><br><span class="line">            if (<span class="name">item.weight</span> &gt; i) &#123;</span><br><span class="line"></span><br><span class="line">                // 价值总和为 <span class="number">0</span></span><br><span class="line">                if (<span class="name">j</span> == bagItems.count - <span class="number">1</span>) &#123;</span><br><span class="line">                    bagMatrix[i][j] = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">                // 价值总和为之前项的和</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 因为 j 是倒着取的，所以这里 - <span class="number">1</span> 变成了 + <span class="number">1</span></span><br><span class="line">                    bagMatrix[i][j] = bagMatrix[i][j+1]<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 能装下</span><br><span class="line">            else &#123;</span><br><span class="line"></span><br><span class="line">                // 是第一个物品，保存起来</span><br><span class="line">                if (<span class="name">j</span> == bagItems.count - <span class="number">1</span>) &#123;</span><br><span class="line">                    bagMatrix[i][j] = item.value;</span><br><span class="line">                &#125;</span><br><span class="line">                // 非第一个物品，求最大值</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 因为 j 是倒着取的，所以这里 - <span class="number">1</span> 变成了 + <span class="number">1</span></span><br><span class="line">                    bagMatrix[i][j] = MAX(<span class="name">bagMatrix</span>[i][j+1], bagMatrix[i - item.weight][j+1] + item.value)<span class="comment">;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 打印二维数组内容</span><br><span class="line">    for (<span class="name">j</span> = <span class="number">0</span><span class="comment">; j &lt; bagItems.count; j++) &#123;</span></span><br><span class="line">        for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt;= bagSize; i++)</span></span><br><span class="line">            printf(<span class="string">"%ld    "</span>, (<span class="name">long</span>)bagMatrix[i][j])<span class="comment">;</span></span><br><span class="line">        printf(<span class="string">"\n"</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSInteger curSize = bagSize; // 当前能装的空间</span><br><span class="line">    NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    // 以 a、b、c、d、e 的顺序获取</span><br><span class="line">    for (<span class="name">j</span> = <span class="number">0</span><span class="comment">; j &lt; bagItems.count; j++) &#123;</span></span><br><span class="line">        </span><br><span class="line">        item = bagItems[j]<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        // 剩下能装的空间为 <span class="number">0</span></span><br><span class="line">        if (<span class="name">curSize</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据变换公式从上至下获得物品</span><br><span class="line">        if (<span class="name">bagMatrix</span>[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123;</span><br><span class="line">            [answer addObject:item.name]<span class="comment">;</span></span><br><span class="line">            curSize -= item.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%@"</span>, answer)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">9</span>    <span class="number">9</span>    <span class="number">12</span>    <span class="number">12</span>    <span class="number">15</span>    <span class="number">15</span>    <span class="number">15</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">9</span>     <span class="number">9</span>     <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">6</span>     <span class="number">6</span>     <span class="number">6</span>     <span class="number">10</span>    <span class="number">11</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">6</span>     <span class="number">6</span>     <span class="number">6</span>     <span class="number">10</span>    <span class="number">10</span>    </span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">6</span>     <span class="number">6</span>     <span class="number">6</span>     <span class="number">6</span>     <span class="number">6</span></span><br><span class="line">  </span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-25</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">03.795695</span><span class="number">+0800</span> Demo[<span class="number">1750</span>:<span class="number">32295</span>] (</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    e</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="二、解释-2"><a href="#二、解释-2" class="headerlink" title="二、解释 2"></a>二、解释 2</h2><p><strong>①、状态方程</strong></p><font color="#cc0000">max.F(n,C,x).   x∈0,1</font><p>展开公式：</p><font color="#cc0000">F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn   x1∗w1 + x2∗w2 + … + xn∗wn ≤ C  xi∈0,1</font><p>x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。</p><p>我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够<font color="#cc0000">自动组合 x 的取值使得 F(n,c,x) 达到最大</font>。</p><p>再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。</p><p>如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。</p><p>B(n, C) = B(n−1, C);   没有多余的空间去放置最后一个物品  </p><p><font color="#cc0000">B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn };</font>   如果有多余的空间去放置，则考虑是否要放置</p><p>B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。</p><p><strong>②、实例</strong></p><p>w = {1, 2}</p><p>v = {1, 2}</p><p>C = 2</p><p>解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。</p><p>拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2</p><p>不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。</p><p>然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 </p><p>B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2</p><p><strong>③、递归代码</strong></p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSArray * nameArr   = @[ @<span class="string">"a"</span>, @<span class="string">"b"</span>, @<span class="string">"c"</span>, @<span class="string">"d"</span>, @<span class="string">"e"</span> ]<span class="comment">;</span></span><br><span class="line">    NSArray * weightArr = @[ @(<span class="number">2</span>), @(<span class="number">2</span>), @(<span class="number">6</span>), @(<span class="number">5</span>), @(<span class="number">4</span>) ]<span class="comment">;</span></span><br><span class="line">    NSArray * valueArr  = @[ @(<span class="number">6</span>), @(<span class="number">3</span>), @(<span class="number">5</span>), @(<span class="number">4</span>), @(<span class="number">6</span>) ]<span class="comment">;</span></span><br><span class="line">    selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]<span class="comment">;</span></span><br><span class="line">    NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    for(<span class="name">NSInteger</span> i = <span class="number">0</span><span class="comment">; i &lt; nameArr.count; i++) &#123;</span></span><br><span class="line">        PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i]</span><br><span class="line">                                                        weight:[weightArr[i] integerValue]</span><br><span class="line">                                                         value:[valueArr[i] integerValue]]<span class="comment">;</span></span><br><span class="line">        bagItems[i] = item;  // a、b、c、d、e</span><br><span class="line">        selectedArray[i] = @(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%ld"</span>, (<span class="name">long</span>)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10])<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    [selectedArray enumerateObjectsUsingBlock:^(<span class="name">NSNumber</span> * obj, NSUInteger idx, BOOL * stop) &#123;</span><br><span class="line">        if (<span class="name">obj.integerValue</span>) &#123;</span><br><span class="line">            NSLog(@<span class="string">"%@   "</span>, nameArr[idx])<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  *  @brief   <span class="number">01</span> 背包算法。递归方式</span><br><span class="line">  */</span><br><span class="line">- (<span class="name">NSInteger</span>)packageAlgorithm:(<span class="name">NSArray</span> *)bagItems bagNo:(<span class="name">NSInteger</span>)bagNo bagSize:(<span class="name">NSInteger</span>)bagSize</span><br><span class="line">&#123;</span><br><span class="line">    if (<span class="name">bagItems.count</span> == <span class="number">0</span> || bagSize == <span class="number">0</span> || bagNo == <span class="number">0</span>)  return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    PackageItem * item = bagItems[bagNo - <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    // 装不下</span><br><span class="line">    if (<span class="name">bagSize</span> &lt; item.weight) &#123;</span><br><span class="line">        // 在剩余的物品中查找</span><br><span class="line">        return [self packageAlgorithm:bagItems bagNo:bagNo - <span class="number">1</span> bagSize:bagSize]<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - <span class="number">1</span> bagSize:bagSize]<span class="comment">;</span></span><br><span class="line">        NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - <span class="number">1</span> bagSize:bagSize - item.weight] + item.value;</span><br><span class="line">        </span><br><span class="line">        if (<span class="name">more</span> &lt; less) &#123;</span><br><span class="line">            selectedArray[bagNo - <span class="number">1</span>] = @(<span class="number">1</span>)<span class="comment">; // 拿</span></span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            selectedArray[bagNo - <span class="number">1</span>] = @(<span class="number">0</span>)<span class="comment">; // 不拿</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return MAX(<span class="name">more</span>, less)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">13.897795</span><span class="number">+0800</span> Demo[<span class="number">3618</span>:<span class="number">88346</span>] <span class="number">15</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">13.897903</span><span class="number">+0800</span> Demo[<span class="number">3618</span>:<span class="number">88346</span>] a</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">13.897979</span><span class="number">+0800</span> Demo[<span class="number">3618</span>:<span class="number">88346</span>] b</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-26</span> <span class="number">00</span>:<span class="number">11</span>:<span class="number">13.898040</span><span class="number">+0800</span> Demo[<span class="number">3618</span>:<span class="number">88346</span>] e</span><br></pre></td></tr></table></figure><h2 id="三、DP-优于递归的好处"><a href="#三、DP-优于递归的好处" class="headerlink" title="三、DP 优于递归的好处"></a>三、DP 优于递归的好处</h2><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。</p><h2 id="四、学习文章"><a href="#四、学习文章" class="headerlink" title="四、学习文章"></a>四、学习文章</h2><p><a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener">动态规划之 01 背包问题（最易理解的讲解）</a><br><a href="https://blog.csdn.net/u014296502/article/details/80015722" target="_blank" rel="noopener">一文彻底搞懂01背包算法</a><br><a href="https://blog.csdn.net/jushang0235/article/details/78841915" target="_blank" rel="noopener">DP——01背包问题使用迭代和动态规划</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5294842-171c0d1ec913da7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>直接插入排序</title>
    <link href="http://yoursite.com/2019/05/23/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/05/23/直接插入排序/</id>
    <published>2019-05-23T10:19:03.934Z</published>
    <updated>2019-05-24T08:46:18.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、减治法（增量法）"><a href="#一、减治法（增量法）" class="headerlink" title="一、减治法（增量法）"></a>一、减治法（增量法）</h2><blockquote><ul><li>减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。</li><li>增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。</li></ul></blockquote><p>减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。</p><p>很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式：</p><ul><li>减去一个常量。（直接插入排序）</li><li>减去一个常量因子。（二分查找法）</li><li>减去的规模可变。（辗转相除法）</li></ul><h2 id="二、直接插入排序"><a href="#二、直接插入排序" class="headerlink" title="二、直接插入排序"></a>二、直接插入排序</h2><p>直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：</p><blockquote><p>对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。</p><p>考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n-1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5294842-efaf86b318ef2893.gif?imageMogr2/auto-orient/strip" alt="InsertSort.gif"></p><p>很显然，基于增量法的思想在解决这个问题上拥有更高的效率。</p><p>直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。</p><p>当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）</p><p>直接插入排序的时间复杂度是 O(n^2)，空间复杂度是 O(1)，同时也是稳定排序。</p><h2 id="三、优化"><a href="#三、优化" class="headerlink" title="三、优化"></a>三、优化</h2><blockquote><p>设置哨兵位</p></blockquote><p>仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。</p><p>不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：记录上一次插入的值和位置，与当前插入值比较。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。</p><blockquote><p>二分查找法</p></blockquote><p>优化直接插入排序的核心在于：快速定位当前数字待插入的位置。</p><p>在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。</p><p>这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会<strong>打破排序算法的稳定性</strong>，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？</p><h2 id="四、简单的性能比较"><a href="#四、简单的性能比较" class="headerlink" title="四、简单的性能比较"></a>四、简单的性能比较</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-53aa065d1538f636.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多种优化方式性能比较"></p><p>结论：</p><ul><li><p><strong>在某些特定场景下</strong>，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。</p></li><li><p>对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。</p></li><li><p>大规模数组，二分查找优化效率明显。</p></li></ul><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH  10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">list</span>[i]; <span class="comment">// 取出第i个数，和前i-1个数比较后，插入合适位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt; <span class="number">-1</span> &amp;&amp; temp &lt; <span class="built_in">list</span>[j]; j--) &#123;</span><br><span class="line">            <span class="built_in">list</span>[j + <span class="number">1</span>] = <span class="built_in">list</span>[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据上一次的位置，简化下一次定位</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">optimized_1</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录上一个插入值的位置和数值</span></span><br><span class="line">    <span class="keyword">int</span> checkValue = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> checkIndex = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cur = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">int</span> start = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 根据上一个值，定位开始遍历的位置</span></span><br><span class="line">        <span class="keyword">if</span> (cur &lt; checkValue) &#123;</span><br><span class="line">            start = checkIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; start - <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的</span></span><br><span class="line">        <span class="comment">// 循环判断 + 插入</span></span><br><span class="line">        <span class="keyword">for</span> (j = start; j &gt; <span class="number">-1</span>; j--) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="built_in">array</span>[j]) &#123;</span><br><span class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[j + <span class="number">1</span>] = cur;</span><br><span class="line">        checkValue = cur;</span><br><span class="line">        checkIndex = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARRAY_LENGTH; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://home.cnblogs.com/u/jing-an-feng-shao/" target="_blank" rel="noopener">Gerrard_Feng</a> <a href="https://www.cnblogs.com/jing-an-feng-shao/p/6165094.html" target="_blank" rel="noopener">排序算法(三) 直接插入排序</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、减治法（增量法）&quot;&gt;&lt;a href=&quot;#一、减治法（增量法）&quot; class=&quot;headerlink&quot; title=&quot;一、减治法（增量法）&quot;&gt;&lt;/a&gt;一、减治法（增量法）&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;减治法：对于一个全局的大问题，将其与一
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>armv7、armv7s、arm64</title>
    <link href="http://yoursite.com/2019/05/23/armv7%E3%80%81armv7s%E3%80%81arm64/"/>
    <id>http://yoursite.com/2019/05/23/armv7、armv7s、arm64/</id>
    <published>2019-05-23T10:19:03.933Z</published>
    <updated>2019-05-24T09:15:55.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>ARM 处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于 ARM，在嵌入式系统中应用广泛。</p><p>armv6｜armv7｜armv7s｜arm64 都是 ARM 处理器的指令集，这些指令集都是<font color="#cc0000">向下兼容</font>的，例如 armv7 指令集兼容 armv6，只是使用 armv6 的时候无法发挥出其性能，无法使用 armv7 的新特性，从而会导致程序执行效率没那么高。</p><h2 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h2><ul><li>armv7｜armv7s｜arm64 都是 ARM 处理器的指令集</li><li>i386｜x86_64 是 Mac 处理器的指令集</li></ul><p>|:————-:|:————-:|:—–:|<br>|arm64|iPhone6s | iphone6s plus | iPhone6 | iPhone6 plus | iPhone5S | iPad Air | iPad mini2 | 真机 64 位 |<br>|armv7s|iPhone5 | iPhone5C | iPad4|真机 32 位|<br>|armv7|iPhone4|iPhone4S|iPad|iPad2|iPad3|iPad mini|iPod Touch 3G|iPod Touch4|真机 32 位|<br>|i386|针对 intel 通用微处理器 32 位处理器|模拟器 32 位|<br>|x86_64|是针对 x86 架构的 64 位处理器|模拟器 64 位|</p><p>模拟器并不运行 arm 代码，软件会被编译成 x86 可以运行的指令。所以生成静态库时都是会先生成两个 .a，一个是 i386 的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个 .a 合并成一个。</p><h2 id="三、Xcode-的指令集选项"><a href="#三、Xcode-的指令集选项" class="headerlink" title="三、Xcode 的指令集选项"></a>三、Xcode 的指令集选项</h2><h3 id="3-1-Architectures"><a href="#3-1-Architectures" class="headerlink" title="3.1 Architectures"></a>3.1 Architectures</h3><blockquote><p>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. </p></blockquote><p>指定工程被编译成可支持哪些指令集类型。支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是 ipa 包会变大。</p><h3 id="3-2-Valid-Architectures"><a href="#3-2-Valid-Architectures" class="headerlink" title="3.2 Valid Architectures"></a>3.2 Valid Architectures</h3><blockquote><p>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. </p></blockquote><p>限制可能被支持的指令集的范围，也就是 Xcode 编译出来的二进制包类型最终从这些类型产生。而编译出哪种指令集的包，将由Architectures 与 Valid Architectures 的交集来确定。</p><p>①、Valid Architectures 支持 arm 指令集版本设置为：armv7/armv7s/arm64，对应的 Architectures 支持 arm 指令集版本为：armv7s，这时 Xcode 只会生成一个 armv7s 指令集的二进制包。</p><p>②、将 Architectures 支持 arm 指令集设置为：armv7/armv7s，对应的 Valid Architectures 的支持的指令集设置为：armv7s/arm64，那么此时，XCode 生成二进制包所支持的指令集只有 armv7s。</p><p>(3)、Build Active Architecture Only</p><p>指定是否只对当前连接设备所支持的指令集编译。</p><p>debug 时设置成 YES 是为了编译速度更快，它只编译当前的 architecture 版本；而 release 时设置为 NO 会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如设置为 YES，用 iphone4 编译出来的是 armv7 版本的，iphone5 也可以运行，但是 armv6 的设备就不能运行。  所以，一般 debug 的时候可以选择设置为 YES，release 的时候要改为 NO，以适应不同设备。 </p><p>情况</p><p>Architectures</p><p>ValidArchitectures</p><p>结果</p><p>分析</p><p>①</p><p>armv7、<br>armv7s、<br>arm64</p><p>armv6、<br>armv7s、<br>arm64</p><p>arm64</p><p>取交集 arm64 和 armv7s，但 iPhone5S 匹配指令集 arm64，所以为 arm64</p><p>②</p><p>armv6、<br>armv7、<br>armv7s</p><p>armv6、<br>armv7s、<br>arm64</p><p>armv7s</p><p>取交集 armv6 和 armv7s，但 iPhone5S 匹配指令集 arm64，但同时支持 armv7s，同时XCode4.5 开始，就不再支持 armv6 指令集，所以为 arm64</p><p>③</p><p>armv6、<br>armv7</p><p>armv6、<br>armv7s、<br>arm64</p><p>armv7</p><p>无交集。但是因为 ValidArchitectures支 持armv7s 则必然支持 armv7，所以最终生成二进制指令集 armv7</p><p>④</p><p>armv6</p><p>armv6、<br>armv7s、<br>arm64</p><p>无响应</p><p>虽然编译成功了，但是并没有任何目标生成。因为从 XCode4.5 开始，就不再支持 armv6 指令集，所以列表中写了也是白写。</p><p>⑤</p><p>armv7、<br>armv7s、<br>arm64</p><p>armv7、<br>armv7s</p><p>error报错</p><p>生成二进制包支持的指令集编译出错 error 信息：<br>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=arm64, VALID_ARCHS=armv7</p><p>如果你对 ipa 安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p><ul><li>$(ARCHS_STANDARD)<br>默认值，以各版本实际的值为准。XCode5 中值为 armv7 armv7s，在 XCode5.1 时，强制加入了对 arm64 的编译，于是该值为 armv7,armv7s,arm64。当前 Xcode10.1 默认为 Standard architectures(armv7,arm64)。</li><li>$(ARCHS_STANDARD_32_BIT)<br>Xcode5 和 5.1 都为 armv7,armv7s，旧一点的版本中应该对应的就只有 armv7。（待验证）</li><li>$(ARCHS_STANDARD_INCLUDING_64_BIT)<br>XCode5 和 5.1 都为 armv7,armv7s,arm64</li></ul><p>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有 32 位、64 位两份代码，在iPhone5s（64 位）下，会首选运行 64 位代码包。包含两种架构的代码包，只有运行在 iOS6、iOS7 系统上。 </p><p>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有 32 位代码， iPhone5s 可以兼容 32 位代码，但是这会降低 iPhone5s 的性能。 </p><p>开启 arm64 支持后，不能开发 iOS 5.1.1 之前的版本，要强制将 deployment target 设置为 5.1.1 或之后。Xcode4.5 中移除了对 arm6 的支持。</p><h4 id="查看-a-framework-库支持的指令集"><a href="#查看-a-framework-库支持的指令集" class="headerlink" title="查看 .a/framework 库支持的指令集"></a>查看 .a/framework 库支持的指令集</h4><p>通过 lipo 命令查看 .a 库所支持的指令集。</p><p>$ lipo -info AFNetworking<br>$ lipo -info AFNetworking.framework/AFNetworking<br>Non-fat file: AFNetworking.framework/AFNetworking is architecture: x86_64<br>$ lipo -info *.a<br>Architectures in the fat file: libPods-AFNetworking.a are: armv7 armv7s<br>Architectures in the fat file: libPods.a are: armv7 armv7s<br>$ lipo -info libBloodTester.a<br>Architectures in the fat file: libBloodTester.a are: armv7 i386 x86_64 arm64</p><h4 id="CocoaPods与Architecture"><a href="#CocoaPods与Architecture" class="headerlink" title="CocoaPods与Architecture"></a>CocoaPods与Architecture</h4><p>出现问题 ld: library not found for -lAFNetworking，需要将 pods 的 Architectures 设置成与工程 targets 里的相同。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ac1144fb7f36f684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="如何选择支持的指令集？"><a href="#如何选择支持的指令集？" class="headerlink" title="如何选择支持的指令集？"></a>如何选择支持的指令集？</h4><p>如果你的软件对安装包大小非常敏感，你可以减少安装包中的指令集数据包，而且这能达到立竿见影的效果。</p><p>很久前 xcode 支持的指令集是 armv7/armv7s，后来改成只支持 armv7 后，比原来小了 10MB 左右。目前 AppStore 上的一些知名应用，比如百度地图、腾讯地图通过反汇编工具查看后，也都只支持 armv7 指令集。（待验证）</p><p>根据向下兼容原则，armv7 指令集的应用是可以正常在支持 armv7s/arm64 指令集的机器上运行的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;ARM 处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于 ARM，在嵌入式系统中应用广泛。&lt;/p&gt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Archives 配置</title>
    <link href="http://yoursite.com/2019/05/23/Archives%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/05/23/Archives配置/</id>
    <published>2019-05-23T10:19:03.932Z</published>
    <updated>2019-05-24T09:03:49.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Archive"><a href="#一、Archive" class="headerlink" title="一、Archive"></a>一、Archive</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1b5c4ce68e064e85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>iOS App Store</strong></p><p>保存到本地，准备上传 App Store 或者在越狱的 iOS 设备上使用，利用的是 Distribution 描述文件，关联 production 证书；</p><p><strong>Ad Hoc</strong></p><p>保存到本地，准备在开发者账户下添加了 UDID 的设备上使用，利用的是 Distribution 描述文件，关联 production 证书；</p><blockquote><p>官方解释：Ad Hoc 模式的包和将来发布到 App Store 的包在各种功能测试上是一样的，只要 Ad Hoc 模式下测试（推送、内购等）没有问题，发布到 App Store 也是没有问题的。</p></blockquote><p><strong>Enterprise</strong></p><p>主要针对企业级账户下准备本地服务器分发的 app。利用的是 Distribution 描述文件，关联 production 证书；</p><p><strong>Development</strong></p><p>保存到本地，给添加了 UDID 的设备使用，开发者模式打包 ipa，通过 development 描述文件，关联 development 证书。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1c407b5f2ac4059c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt>  <img src="https://upload-images.jianshu.io/upload_images/5294842-5981e6b0bcac4065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>Rebuild from Bitcode</strong></p><p>如果工程 Bitcode 为 NO，则不会有此选项。</p><p><strong>Strip Swift symbols</strong></p><p>去除 swift 符号，勾选后会让 ipa 包内存小一些，对包进行了一个压缩。如果项目中未包含 swift 代码，则没有此选项。</p><p><strong>Include manifest for over-the-air installation</strong></p><p>勾选后用户可以在 safari 中下载应用，而不必移步 App Store。</p><p><strong>Upload your app’s symbols to receive symbolicated reports from Apple</strong></p><p>上传应用程序的符号以接收来自苹果的符号化报告。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-988e01e7cc35ade7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="二、学习文章"><a href="#二、学习文章" class="headerlink" title="二、学习文章"></a>二、学习文章</h2><p><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/technotes/tn2151/_index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Archive&quot;&gt;&lt;a href=&quot;#一、Archive&quot; class=&quot;headerlink&quot; title=&quot;一、Archive&quot;&gt;&lt;/a&gt;一、Archive&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>App Thinning</title>
    <link href="http://yoursite.com/2019/05/23/App-Thinning/"/>
    <id>http://yoursite.com/2019/05/23/App-Thinning/</id>
    <published>2019-05-23T10:19:03.932Z</published>
    <updated>2019-05-24T09:00:22.912Z</updated>
    
    <content type="html"><![CDATA[<p>App Thinning 可以译成”应用瘦身”。指的是 App Store 和操作系统在安装 iOS 或者 watchOS 的 app 的时候通过一系列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：slicing、bitcode、on-demand resources。</p><h2 id="一、slicing"><a href="#一、slicing" class="headerlink" title="一、slicing"></a>一、slicing</h2><p>App Slicing 在节省应用所需资源中发挥着最重要的作用。</p><p>很多应用需要在不同尺寸的设备上运行，针对这些不同的设备，它们内含不同的独立资源，而大部分是你的设备不需要的。所以App Store 会针对不同的设备制作不同的”简化版 App”，当你下载 app 时候只需要下载不同的”简化版 app”就可以了。</p><p>比如用户使用的是 iPhone 5c，它运行的是 32 位 CPU 和 GPU，并不支持 Metal API。但如果用户下载的是一款最新的通用游戏应用，它的二进制中含有 64 位代码，iPad 和”@3x”iPhone 6 Plus 资源以及 Metal API 代码，这些都是你的设备用不上的。它只需要 32 位代码，”@2x”iPhone 尺寸资源以及 OpenGL 图形代码。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2c4819d0348f492f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>Note : Sliced apps are supported on devices running 9.0 and later;</strong></p><p>Slicing 的主要的工作流程如下：</p><ol><li>在 Xcode 中选择好目标设备并且使用 asset catalog 提供多分辨率的图片资源；只有使用 asset catalog 才能正确使Slicing 作用于资源文件。</li><li>在模拟器或者设备上编译并运行 app；</li><li>Xcode 会自动构建针对你运行设备的”简化版 app”，同时也是为了减少编译时间和进行本地的测试；</li><li>打包 app（为了及时发现不同目标设备的配置错误，可以在本地为目标设备导出”简化版 app”，测试无误后再打包)</li><li>上传打包好的 app 到 iTunes connect。App Store 将会为上传的 app 归档创建不同的”简化版 app”。</li><li>在 iTunes Connect 中，发布一个预览版给合格的测试者进行测试；</li><li>测试者通过 TestFlight 下载预览版。TestFlight 会自动根据测试者的设备下载合适的”简化版 app”。</li></ol><h2 id="二、Bitcode-iOS-watchOS"><a href="#二、Bitcode-iOS-watchOS" class="headerlink" title="二、Bitcode (iOS, watchOS)"></a>二、Bitcode (iOS, watchOS)</h2><p>Bitcode 是一个编译好的程序的中间表示形式。上传到 iTunes Connect 中的包含 Bitcode 的 app 将会在 App Store 中进行链接和编译。苹果会对包含 Bitcode 的二进制 app 进行二次优化，而不需要提交一个新的 app 版本到 App Store 中。</p><h2 id="三、On-Demand-Resources-iOS"><a href="#三、On-Demand-Resources-iOS" class="headerlink" title="三、On-Demand Resources (iOS)"></a>三、On-Demand Resources (iOS)</h2><p>ODR（on-demand resources 随需应变资源)是 iOS 减少应用资源消耗的另外一种方法。比如多级游戏，用户需要的通常都是他们当前的级数以及下一级。ODR 意味着用户可以下载他们需要的几级游戏。随着你的级数不断增加，应用再下载其他级数，并将用户成功过关的级数删掉。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3691bd525660ea81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>当用户点击应用内容的时候，就会动态从 App Store 上进行下载，也就是说用户只会在需要的时候占用存储空间。这项功能有趣之处还在于当将这些内容在后台进行下载之后，当存储空间紧张的时候会自动进行删除。</p><p><img src="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/Art/ODR_flow_2x.png" alt="image: ../Art/ODR_flow_2x.png"></p><p>On-Demand Resources 可以是除了可执行代码外的任意类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-66c28b72674b28d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在开发过程中，你可以通过分配一个或多个 tag 来识别 On-Demand Resources。你可以使用 tag 的别名来确定什么时候将它加载到你的 App 中。</p><p>好处：</p><ul><li>Smaller app size. app 体积更小。</li><li>Lazy loading of app resources. 懒加载应用资源。</li><li>Remote storage of rarely used resources. 远端存储较少使用的资源。</li><li>Remote storage of in-app purchase resources. 远端存储内购资源。</li></ul><p>下图展示了一个在 App 中保持最小资源占用的例子。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d1ee45f7ae6ebb73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d5bfaeb1150e88bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>可以给资源设置优先级，比如当 App 从 AppStore 安装后就立即加载。</p><blockquote><p> A _tag_ is a string identifier you create. Apps request tags, not individual resources.</p></blockquote><p><strong>On-Demand Resources 的生命周期</strong></p><p>①、App 向操作系统请求资源。操作系统将请求发送给包含所有所需资源的 asset packs。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8053f6eb07507b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>②、asset packs 检查请求的资源本地是否存在。如果存在，则直接提供 App 使用。</p><p>③、如果请求的资源本地不存在，则它们被保存在 App Store。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-316aab844be76e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>④、操作系统开始下载本地不存在的资源</p><p>⑤、远程资源下载完毕</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c5191d663f1b8e89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>⑥、当资源下载成功或监测到资源包已经被下载，资源包内存计数将会被 ＋1，并通知 App 此资源可用。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-bbbb952f642fd22b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>⑦、当请求的资源可用，App 使用资源标签对应的资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9e2fc891d113fdac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>⑧、操作系统在本地释放资源标签</p><p>⑨、操作系统在本地清除资源缓存。当一个缓存资源不与任何请求相关联时，操作系统会在一定时间后将它释放掉。</p><p>完整的生命周期如下图所示：</p><p><img src="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/Art/ODR_flow_2x.png" alt="image: ../Art/ODR_flow_2x.png"></p><h2 id="四、实际处理方法"><a href="#四、实际处理方法" class="headerlink" title="四、实际处理方法"></a>四、实际处理方法</h2><p>①、iOS9 以后 Xcode 默认开启 On-Demand Resources 功能，可以在下图所示位置进行设置。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-20fd1426c699a6c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>②、在 App 中创建 Tags</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-1b4cfc77690df19f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/Art/ODR_Add_New_Tag_2x.png" alt="image: ../Art/ODR_Add_New_Tag_2x.png"></p><p>③、给文件设置 tag</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-62516bc6ffbdee87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>④、给图片设置 tag</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b56358b46094e85e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>⑤、给 tag 设置加载的优先级</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e2b226aa8a0fdfd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><strong>加载优先级</strong></p><ul><li>Initial install tags.资源和 App 同时下载。在 App Store 中，App 的大小计算已经包含了这部分资源。当没有NSBundleResourceRequest 对象访问它们时，它们将会从设备上清除。</li><li>Prefetch tag order. 在 App 安装后开始下载，按照预加载列表中的顺序依次下载。</li><li>Dowloaded only on demand. 只有在 App 中发出请求时才会下载。</li></ul><p><strong>资源大小限制</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/3402279-ea2bc5a27c368c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/715/format/webp" alt></p><h2 id="五、学习文章"><a href="#五、学习文章" class="headerlink" title="五、学习文章"></a>五、学习文章</h2><p><a href="https://help.apple.com/xcode/mac/current/#/devbbdc5ce4f" target="_blank" rel="noopener">What is app thinning? (iOS, tvOS, watchOS)</a><br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/index.html#//apple_ref/doc/uid/TP40015083" target="_blank" rel="noopener">On-Demand Resources Essentials</a><br><a href="https://www.jianshu.com/p/789df0adaac2" target="_blank" rel="noopener">https://www.jianshu.com/p/789df0adaac2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;App Thinning 可以译成”应用瘦身”。指的是 App Store 和操作系统在安装 iOS 或者 watchOS 的 app 的时候通过一系列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：slicin
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>AFNetworking</title>
    <link href="http://yoursite.com/2019/05/23/AFNetworking/"/>
    <id>http://yoursite.com/2019/05/23/AFNetworking/</id>
    <published>2019-05-23T10:19:03.925Z</published>
    <updated>2019-05-24T06:31:44.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-6f0c4c0e6a6b5465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d8ff8c272fa71948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-527878595c6d8c94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>AFNetworking 实际上是对 NSURLSession 高度地封装，提供一些简单易用的 api，方便开发者在 iOS 开发中发出网络请求并在其上更快地构建网络层组件以及提供合理的接口。</p><p>AFNetworking 默认接收 json 格式的响应。</p><h2 id="二、AFURLSessionManager"><a href="#二、AFURLSessionManager" class="headerlink" title="二、AFURLSessionManager"></a>二、AFURLSessionManager</h2><p>AFURLSessionManager 遵守 \&lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying> 协议，根据指定的 NSURLSessionConfiguration 对象创建和管理 NSURLSession 对象。</p><ol><li>负责创建和管理 NSURLSession</li><li>管理 NSURLSessionTask</li><li>实现 NSURLSessionDelegate 等协议中的代理方法</li><li>使用 AFURLSessionManagerTaskDelegate 管理进度</li><li>使用 _AFURLSessionTaskSwizzling 调剂方法</li><li>引入 AFSecurityPolicy 保证请求的安全</li><li>引入 AFNetworkReachabilityManager 监控网络状态</li></ol><h2 id="三、AFURLResponseSerialization-文件"><a href="#三、AFURLResponseSerialization-文件" class="headerlink" title="三、AFURLResponseSerialization 文件"></a>三、AFURLResponseSerialization 文件</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-a4c8de00e051ca4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="3-1-AFURLResponseSerialization-协议"><a href="#3-1-AFURLResponseSerialization-协议" class="headerlink" title="3.1 AFURLResponseSerialization 协议"></a>3.1 AFURLResponseSerialization 协议</h3><p>遵守协议的对象根据详细的服务器响应，将数据转换成更有用的对象表达。响应序列化程序可以对输入的响应和数据进行验证，例如：一个 JSON 响应序列化程序可以检查一个可接受的状态代码(‘2xx’范围)和内容类型(‘application/json’)，然后决定将一个有效的 JSON 响应解码成一个对象。</p><h3 id="3-2-AFHTTPResponseSerializer"><a href="#3-2-AFHTTPResponseSerializer" class="headerlink" title="3.2 AFHTTPResponseSerializer"></a>3.2 AFHTTPResponseSerializer</h3><p>遵守 AFURLRequestSerialization、AFURLResponseSerialization 协议，提供一个查询字符串或 URL 类型编码的参数序列化和默认请求头具体的实现，以及响应状态码和内容类型的验证。鼓励使用 AFHTTPResponseSerializer 的子类来解析请求或相应序列化。</p><h3 id="3-3-AFJSONResponseSerializer"><a href="#3-3-AFJSONResponseSerializer" class="headerlink" title="3.3 AFJSONResponseSerializer"></a>3.3 AFJSONResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型：</p><p>- ‘application/json’<br>- ‘text/json’<br>- ‘text/javascript’</p><h3 id="3-4-AFXMLParserResponseSerializer"><a href="#3-4-AFXMLParserResponseSerializer" class="headerlink" title="3.4 AFXMLParserResponseSerializer"></a>3.4 AFXMLParserResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型：</p><p>- ‘application/xml’<br>- ‘text/xml’</p><h3 id="3-5-AFPropertyListResponseSerializer"><a href="#3-5-AFPropertyListResponseSerializer" class="headerlink" title="3.5 AFPropertyListResponseSerializer"></a>3.5 AFPropertyListResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，验证和解析 XML 响应，如同 NSXMLDocument 对象。可解析的 MIME 类型：</p><p>- ‘application/x-plist’</p><h3 id="3-6-AFImageResponseSerializer"><a href="#3-6-AFImageResponseSerializer" class="headerlink" title="3.6 AFImageResponseSerializer"></a>3.6 AFImageResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，验证和解析 image 响应，解析成 UIImage 或 NSImage，可解析的 MIME 类型：</p><p>- ‘image/tiff’<br>- ‘image/jpeg’<br>- ‘image/gif’<br>- ‘image/png’<br>- ‘image/ico’<br>- ‘image/x-icon’<br>- ‘image/bmp’<br>- ‘image/x-bmp’<br>- ‘image/x-xbitmap’<br>- ‘image/x-win-bitmap’</p><h3 id="3-7-AFCompoundResponseSerializer"><a href="#3-7-AFCompoundResponseSerializer" class="headerlink" title="3.7 AFCompoundResponseSerializer"></a>3.7 AFCompoundResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，将用 AFURLResponseSerialization 的方法解析完成的对象，转成 AFHTTPResponseSerializer 行为的对象。这对于用单个序列化处理多种可能的响应类型来说很有用。This is useful for supporting multiple potential types and structures of server responses with a single serializer.</p><h3 id="3-8-全局方法"><a href="#3-8-全局方法" class="headerlink" title="3.8 全局方法"></a>3.8 全局方法</h3><p>AFErrorWithUnderlyingError()                  处理 NSError 对象</p><p>AFJSONObjectByRemovingKeysWithNullValues()    递归处理空值，返回可变或不可变对象</p><h3 id="3-9-AFHTTPResponseSerializer-方法"><a href="#3-9-AFHTTPResponseSerializer-方法" class="headerlink" title="3.9 AFHTTPResponseSerializer 方法"></a>3.9 AFHTTPResponseSerializer 方法</h3><p>- validateResponse:data:error:           通过 MIME 类型和状态码验证响应是否有效，并记录错误信息</p><p>- responseObjectForResponse:data:error:  AFURLResponseSerializer 协议方法</p><p>…                                      其他协议方法</p><h3 id="3-10-AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer-方法"><a href="#3-10-AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer-方法" class="headerlink" title="3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法"></a>3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法</h3><p>- init                                   设置可解析的类型</p><p>- responseObjectForResponse:data:error:  AFURLResponseSerializer 协议方法，执行步骤：</p><p>①、验证 MIME 类型和状态码</p><p>②、检查内容（JSON 序列化类检查内容是否为一个空格）</p><p>③、调用系统的序列化方法</p><p>④、存储错误信息</p><p>⑤、移除空值</p><h3 id="3-11-AFImageResponseSerialize-方法"><a href="#3-11-AFImageResponseSerialize-方法" class="headerlink" title="3.11 AFImageResponseSerialize 方法"></a>3.11 AFImageResponseSerialize 方法</h3><p>+ af_safeImageWithData:                   使用锁来保证数据安全</p><p>AFImageWithDataAtScale()                  将图片按比例缩放</p><p>AFInflatedImageFromResponseWithDataAtScale()     获取图片数据，执行步骤：</p><p>①、判断数据是否存在，没有返回 nil</p><p>②、使用 CGDataProvider 对象，获取不同响应类型图片文件的内容，其中 JPEG 类型颜色空间为 kCGColorSpaceModelCMYK 的数据不采用此种方式，原因：CGImageCreateWithJPEGDataProvider does not properly handle CMKY</p><p>③、如果 CGDataProvider 没有获取到内容，则使用  AFImageWithDataAtScale 方法进行缩放后直接返回</p><p>④、使用位图对象 CGBitmapContextCreate 重新绘图后缩放，并返回</p><p>AFCompoundResponseSerializer 分派给以上类进行解析。</p><h2 id="四、AFURLRequestSerialization-文件"><a href="#四、AFURLRequestSerialization-文件" class="headerlink" title="四、AFURLRequestSerialization 文件"></a>四、AFURLRequestSerialization 文件</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-846dfe7bfc48e7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><strong>请求序列化器</strong>从 URL 字符串创建请求，将参数编码为查询字符串或 HTTP 正文。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString <span class="symbol">*</span> URLString = <span class="meta">@"http://example.com";</span></span><br><span class="line">NSDictionary <span class="symbol">*</span> parameters = <span class="meta">@&#123;</span> <span class="meta">@"foo":</span> <span class="meta">@"bar",</span> <span class="meta">@"baz":</span> <span class="meta">@[</span><span class="meta">@1,</span> <span class="meta">@2,</span> <span class="meta">@3</span> ]&#125;;</span><br></pre></td></tr></table></figure><p>Query String Parameter Encoding - 查询字符串参数编码</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFHTTPRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">GET</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">GET http://example.com?foo=bar&amp;baz<span class="string">[]</span>=<span class="number">1</span>&amp;baz<span class="string">[]</span>=<span class="number">2</span>&amp;baz<span class="string">[]</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>URL Form Parameter Encoding - URL 表单参数编码</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFHTTPRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">POST</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">POST http://example.com/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;baz<span class="string">[]</span>=<span class="number">1</span>&amp;baz<span class="string">[]</span>=<span class="number">2</span>&amp;baz<span class="string">[]</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>JSON Parameter Encoding - JSON 参数编码</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFJSONRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">POST</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">POST http://example.com/</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>, <span class="string">"baz"</span>: <span class="string">[1,2,3]</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-AFURLRequestSerialization-协议"><a href="#4-1-AFURLRequestSerialization-协议" class="headerlink" title="4.1 AFURLRequestSerialization 协议"></a>4.1 AFURLRequestSerialization 协议</h3><p>遵守协议的对象为指定的 HTTP 请求的参数进行编码，参数包含查询字符串、HTTP bodies、必要设置的合适的 HTTP 头字段。例如：一个 JSON 请求序列化可以将请求的 HTTP 主体设置为JSON 表示，并将 HTTP 头字段 ‘Content-Type’ 设置为 ‘application/json’。</p><h3 id="4-2-AFMultipartFormData-协议"><a href="#4-2-AFMultipartFormData-协议" class="headerlink" title="4.2 AFMultipartFormData 协议"></a>4.2 AFMultipartFormData 协议</h3><p>该协议定义了一些方法。在 AFHTTPRequestSerializer 的 multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock: 方法中，block 参数返回遵守该协议的对象。</p><h3 id="4-3-AFHTTPRequestSerializer"><a href="#4-3-AFHTTPRequestSerializer" class="headerlink" title="4.3 AFHTTPRequestSerializer"></a>4.3 AFHTTPRequestSerializer</h3><p>遵守 AFURLRequestSerialization 协议。主要作用：</p><p>①、处理查询的 URL 参数</p><p>②、设置 HTTP 头部字段</p><p>③、设置请求的属性</p><p>④、分块上传</p><p>- init                 初始化属性，设置可解析的语言，用户信息，对属性添加观察</p><p>- dealloc              移除观察</p><p>SET、GET               属性的 setter、getter 方法。注意观察者模式的问题</p><p>- multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:  创建 NSMutableURLRequest 对象，设置相关参数(请求方法，缓存策略等)，设置请求头字段，拼接查询字符串到 URL 或者放入 body 中</p><h3 id="4-4-AFStreamingMultipartFormData"><a href="#4-4-AFStreamingMultipartFormData" class="headerlink" title="4.4 AFStreamingMultipartFormData"></a>4.4 AFStreamingMultipartFormData</h3><p>遵守 AFMultipartFormData 协议</p><h3 id="4-5-AFHTTPBodyPart"><a href="#4-5-AFHTTPBodyPart" class="headerlink" title="4.5 AFHTTPBodyPart"></a>4.5 AFHTTPBodyPart</h3><ul><li><p>inputStream              根据不同 body 内容设置不同的输入流</p></li><li><p>stringForHeaders         将 headers 字典的内容进行拼接</p></li><li><p>contentLength            求出请求内容的长度，包括：初始边界、</p></li></ul><p>例子：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--<span class="variable">$&#123;bound&#125;</span>   <span class="comment">// 该 bound 表示pdf 的文件名  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"Filename"</span>  </span><br><span class="line">  </span><br><span class="line">HTTP.pdf  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>   <span class="comment">// 该 bound 表示pdf 的文件内容  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"file000"</span>; filename=<span class="string">"HTTP协议详解.pdf"</span>  </span><br><span class="line">Content-<span class="keyword">Type</span>: application/octet-stream  </span><br><span class="line">  </span><br><span class="line">%PDF-1.5  </span><br><span class="line"><span class="keyword">file</span> content  </span><br><span class="line">%%EOF  </span><br><span class="line">  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>    <span class="comment">// 该 bound 表示字符串  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"Upload"</span>  </span><br><span class="line">  </span><br><span class="line">Submit <span class="keyword">Query</span>  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>—   <span class="comment">// 表示 body 结束了</span></span><br></pre></td></tr></table></figure><h3 id="4-6-AFQueryStringPair"><a href="#4-6-AFQueryStringPair" class="headerlink" title="4.6 AFQueryStringPair"></a>4.6 AFQueryStringPair</h3><p>输出字段 - 值对的信息。</p><h2 id="五、Network-Reachability-Manager"><a href="#五、Network-Reachability-Manager" class="headerlink" title="五、Network Reachability Manager"></a>五、Network Reachability Manager</h2><p>AFNetworkReachabilityManager 监控域的可达性，以及 WWAN 和 WiFi 网络接口的地址。</p><ul><li><p>不要使用 Reachability 来确定是否应发送原始请求。</p><p>你应该尝试发送它。</p></li><li><p>可以使用 Reachability 来确定何时应该自动重试请求。</p><p>虽然它可能仍然失败，但是连接可用的可达性通知是重试某件事的好时机。</p></li><li><p>网络可达性是确定请求失败原因的有用工具。</p><p>在网络请求失败后，告诉用户他们处于离线状态比向他们提供更加技术性但准确的错误（如“请求超时”）要好。</p></li></ul><p>可以参考 <a href="https://developer.apple.com/videos/wwdc2012" target="_blank" rel="noopener">WWDC 2012 session 706, “Networking Best Practices.</a></p><p>Shared Network Reachability</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">AFNetworkReachabilityManager</span> sharedManager] setReachabilityStatusChangeBlock:^(<span class="name">AFNetworkReachabilityStatus</span> status) &#123;</span><br><span class="line">    NSLog(<span class="name">@</span><span class="string">"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(<span class="name">status</span>))<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">[[<span class="name">AFNetworkReachabilityManager</span> sharedManager] startMonitoring]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="六、Security-Policy"><a href="#六、Security-Policy" class="headerlink" title="六、Security Policy"></a>六、Security Policy</h2><p>AFSecurityPolicy 通过安全连接评估针对固定的 X.509 证书和公钥的服务器信任。</p><p>将固定的 SSL 证书添加到您的应用程序有助于防止中间人攻击和其他漏洞。 强烈建议处理敏感客户数据或财务信息的应用程序通过 HTTPS 连接路由所有通信，并配置启用 SSL pinning。</p><p>Allowing Invalid SSL Certificates - 允许无效的 SSL 证书</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.securityPolicy.allowInvalidCertificates = YES;  <span class="regexp">//</span> <span class="keyword">not</span> recommended <span class="keyword">for</span> production</span><br></pre></td></tr></table></figure><p>在二进制的文件中获取公钥的过程是这样</p><p>①、NSData *certificate -&gt; CFDataRef -&gt; (SecCertificateCreateWithData) -&gt; SecCertificateRefallowedCertificate</p><p>②、判断 SecCertificateRef allowedCertificate 是不是空，如果为空，直接跳转到后边的代码；</p><p>③、根据函数 SecPolicyCreateBasicX509() -&gt; SecPolicyRef policy</p><p>④、SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust) -&gt; 生成 SecTrustRef allowedTrust；</p><p>⑤、SecTrustEvaluate(allowedTrust, &amp;result) 校验证书；</p><p>⑥、(__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust) -&gt; 得到公钥 id, allowedPublicKey</p><p>这里边值得学习的地方是：__Require_Quiet 和 __Require_noErr_Quiet 这两个宏定义。</p><p>我们看看他们内部是怎么定义的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __Require_Quiet</span></span><br><span class="line"><span class="comment">#define __Require_Quiet(assertion, exceptionLabel)                            \</span></span><br><span class="line">  <span class="keyword">do</span>                                                                          <span class="string">\</span></span><br><span class="line">  &#123;                                                                           <span class="string">\</span></span><br><span class="line">      <span class="keyword">if</span> ( __builtin_expect(!(assertion), <span class="number">0</span>) )                                <span class="string">\</span></span><br><span class="line">      &#123;                                                                       <span class="string">\</span></span><br><span class="line">  goto exceptionLabel;                                                <span class="string">\</span></span><br><span class="line">      &#125;                                                                       <span class="string">\</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( <span class="number">0</span> )</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p>可以看出这个宏的用途是：当条件返回 false 时，执行标记以后的代码</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __Require_noErr_Quiet</span></span><br><span class="line"><span class="comment">#define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">  <span class="keyword">do</span>                                                                          <span class="string">\</span></span><br><span class="line">  &#123;                                                                           <span class="string">\</span></span><br><span class="line">      <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            <span class="string">\</span></span><br><span class="line">      &#123;                                                                       <span class="string">\</span></span><br><span class="line">             goto exceptionLabel;                                                <span class="string">\</span></span><br><span class="line">      &#125;                                                                       <span class="string">\</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( <span class="number">0</span> )</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure><p>可以看出这个宏的用途是：当条件抛出异常时，执行标记以后的代码。</p><p>这样就有很多使用场景了。当必须要对条件进行判断的时候，我们有下边几种方案了</p><p>①、#ifdef  这个是编译特性</p><p>②、if-else  代码层次的判断</p><p>③、__Require_XXX 宏</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="variable">__Require_Quiet</span>(<span class="number">0</span>, <span class="variable">_out</span>);</span><br><span class="line">  </span><br><span class="line">     ...</span><br><span class="line"><span class="variable">_out</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_out 就是一个标记，这段代码 __Require_Quiet 到 _out 之间的代码不会执行。</p><h2 id="七、单元测试"><a href="#七、单元测试" class="headerlink" title="七、单元测试"></a>七、单元测试</h2><p>AFNetworking 在 Tests 子目录中包含一套单元测试。 这些测试可以运行，只需在您想测试的平台框架上执行测试操作即可。</p><h2 id="八、学习文章"><a href="#八、学习文章" class="headerlink" title="八、学习文章"></a>八、学习文章</h2><p><a href="https://draveness.me/afnetworking1" target="_blank" rel="noopener">AFNetworking 概述（一）</a><br><a href="https://www.jianshu.com/p/02488365cff6" target="_blank" rel="noopener">AFNetworking源码探究（一）– 基本介绍</a><br><a href="https://www.cnblogs.com/machao/p/5681645.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（一）之 AFNetworkReachabilityManager</a><br><a href="http://www.cnblogs.com/machao/p/5654661.html" target="_blank" rel="noopener">socket通信</a><br><a href="https://www.cnblogs.com/machao/p/5704201.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（二）之 AFSecurityPolicy</a><br><a href="http://www.cocoachina.com/ios/20151012/13722.html" target="_blank" rel="noopener">iOS 9之适配ATS</a><br><a href="https://www.cnblogs.com/machao/p/5725874.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（三）之 AFURLRequestSerialization</a><br><a href="http://www.cnblogs.com/machao/p/5718945.html" target="_blank" rel="noopener">url 编码（percentcode 百分号编码）</a><br><a href="http://www.cnblogs.com/machao/p/5755947.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（四）之 AFURLResponseSerialization</a><br><a href="http://www.cnblogs.com/machao/p/5768253.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（五）之 AFURLSessionManager</a><br><a href="http://www.cnblogs.com/machao/p/5790708.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（六）之 AFHTTPSessionManager</a><br><a href="http://www.cnblogs.com/machao/p/5796234.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（七）之 AFAutoPurgingImageCache</a><br><a href="http://www.cnblogs.com/machao/p/5803850.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（八）之 AFImageDownloader</a><br><a href="http://www.cnblogs.com/machao/p/5813054.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（九）之 AFNetworkActivityIndicatorManager</a><br><a href="http://www.cnblogs.com/machao/p/5817701.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（十）之 UIActivityIndicatorView/UIRefreshControl/UIImageView + AFNetworking</a><br><a href="https://www.cnblogs.com/machao/p/5821462.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（十一）之 UIButton/UIProgressView/UIWebView + AFNetworking</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、架构&quot;&gt;&lt;a href=&quot;#一、架构&quot; class=&quot;headerlink&quot; title=&quot;一、架构&quot;&gt;&lt;/a&gt;一、架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/529484
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 内存管理：从 MRC 到 ARC 实践</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9AMRC%E3%80%81ARC/"/>
    <id>http://yoursite.com/2019/05/23/iOS 内存管理：MRC、ARC/</id>
    <published>2019-05-23T09:43:10.193Z</published>
    <updated>2019-05-24T08:53:07.910Z</updated>
    
    <content type="html"><![CDATA[<p>对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。</p><p>iOS 内存管理的核心是<font color="#cc0000">引用计数</font>。</p><p>接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？</p><p>同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">"qqstock"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * str2 = [[<span class="built_in">NSString</span> alloc] initWithData:recvData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br></pre></td></tr></table></figure><p>属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.name</span> = @<span class="string">"qqstock"</span>;    </span><br><span class="line"><span class="attr">_name</span> = @<span class="string">"qqstock"</span>;</span><br></pre></td></tr></table></figure><h2 id="一、MRC-的初衷和实现方式"><a href="#一、MRC-的初衷和实现方式" class="headerlink" title="一、MRC 的初衷和实现方式"></a>一、MRC 的初衷和实现方式</h2><p>苹果为什么要做这个？</p><p>首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。</p><p>当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。</p><p>尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：<font color="#cc0000">为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了</font>。要么，自己写许许多多的代码，频繁对容器进行主动操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ce94c096d686dec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>于是，苹果要解决这个问题。初衷就是：<font color="#cc0000">任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责</font>。</p><p>苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。</p><p>与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。</p><p>另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。”</p><p>那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。</p><p>OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。</p><h2 id="二、MRC-的优点和无奈"><a href="#二、MRC-的优点和无奈" class="headerlink" title="二、MRC 的优点和无奈"></a>二、MRC 的优点和无奈</h2><p>总结：</p><ol><li>MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题</li><li>为了应对各种复杂的场景，很无奈的留了一个口子；</li><li>两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。</li></ol><p>难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。</p><p>略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。</p><p>系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！</p><p>引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。</p><p>再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8a9490ca9920ca7b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="三、编程语言和编译器的发展方向"><a href="#三、编程语言和编译器的发展方向" class="headerlink" title="三、编程语言和编译器的发展方向"></a>三、编程语言和编译器的发展方向</h2><p>由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。</p><p>然而，<font color="#cc0000">编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜</font>。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？</p><p>许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？</p><p>更何况，人，总有打盹的时候。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8c741ac3aebd0dd7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="四、ARC-的适时推出"><a href="#四、ARC-的适时推出" class="headerlink" title="四、ARC 的适时推出"></a>四、ARC 的适时推出</h2><p>随着硬件的升级，条件已经成熟了，ARC 到来了！</p><p>ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。</p><p>之前对 C++ 程序员头疼的问题变得异常简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">"qqstock"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * str2 = [[<span class="built_in">NSString</span> alloc] initWithData:recvData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="keyword">self</span>.name = <span class="string">@"qqstock"</span>;</span><br><span class="line">_name = <span class="string">@"qqstock"</span>;</span><br></pre></td></tr></table></figure><p>到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。</p><p>许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。</p><p>逻辑其实很简单。</p><p>首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低；</p><p>其次，一旦出现弱引用，则<font color="#cc0000">将内存对象在系统中建立映射表</font>；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。</p><p>总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-257b99640d8ddfea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="è¾è®¯Bugly"></p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。</p><p>许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。</p><p>①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。</p><p>②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。</p><p>③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。</p><p>④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。&lt;/p&gt;
&lt;p&gt;iOS 内存管理的核心是&lt;font color=&quot;#cc0000&quot;&gt;引用计数&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;接触 MRC 时遇到最头疼的问题就是：为什么那
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 内存监控</title>
    <link href="http://yoursite.com/2019/05/23/iOS%20%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/05/23/iOS 内存监控/</id>
    <published>2019-05-23T09:27:05.583Z</published>
    <updated>2019-05-24T08:53:18.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、导读"><a href="#一、导读" class="headerlink" title="一、导读"></a>一、导读</h2><p>目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，<font color="#cc0000">用于 App 上线后发现内存问题</font>。</p><p>FOOM(Foreground Out Of Memory) 是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。Facebook 早在 2015 年 8 月提出 FOOM 检测办法。</p><p>微信自 15 年年底上线 FOOM 上报，从最初数据来看，每天 FOOM 次数与登录用户数比例接近 3%，同期 crash 率 1% 不到。而后发现 kv 上报频繁打 log 引起 FOOM。接着分析大量日志还是不能找到 FOOM 原因。微信急需一个有效的内存监控工具来发现问题。</p><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>微信内存监控最初版本是使用 Facebook 的 <a href="https://github.com/facebook/FBAllocationTracker" target="_blank" rel="noopener">FBAllocationTracker</a> 工具监控 OC 对象分配，用 <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> 工具 <font color="#cc0000">hook malloc/free</font> 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP200 最大堆内存及其分配堆栈，用文本 log 输出到本地。该方案实现简单，一天内完成，通过给用户下发 TestFlight，最终发现联系人模块因迁移 DB 加载大量联系人导致FOOM。</p><p>不过这方案有不少缺点：</p><p>①、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用；</p><p>②、输出 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io 频繁等性能问题；</p><p>③、上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。</p><p>所以二期版本以 Instruments 的 Allocations 为参考，着重四个方面优化：数据收集、存储、上报及展现。</p><h3 id="2-1-数据收集"><a href="#2-1-数据收集" class="headerlink" title="2.1 数据收集"></a>2.1 数据收集</h3><p>16 年 9 月底为了解决 ios10 nano crash，研究了 <a href="https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c.auto.html" target="_blank" rel="noopener">libmalloc 源码</a>，无意中发现这几个接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(<span class="keyword">malloc_logger_t</span>)</span><span class="params">(<span class="keyword">uint32_t</span> type, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg1, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg2, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg3, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> result, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> num_hot_frames_to_skip)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">malloc_logger_t</span> *__syscall_logger;   <span class="comment">// use this to set up syscall logging (e.g., vm_allocate, vm_deallocate, mmap, munmap)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">malloc_logger_t</span> *malloc_logger = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。</p><p>有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址 = 堆栈地址 - slide。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ae86221f47c0df54.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>另外为了更好的归类数据，每个内存对象应该有它所属的分类 Category。如上图所示。对于堆内存对象，它的 Category 名是 “Malloc” +分配大小，如 “Malloc 48.00KiB”。</p><p>对于虚拟内存对象，调用 vm_allocate 创建时，最后的参数 flags 代表它是哪类虚拟内存，而这个 flags 正对应于上述函数指针 __syscall_logger 的第一个参数 type，每个 flag 具体含义可以在头文件 \&lt;mach/vm_statistics.h> 找到；</p><p>对于 OC 对象，它的 Category 名是 OC 类名，我们可以通过 hook OC方法 +[NSObject alloc] 来获取：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Logger</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL originSEL = <span class="keyword">@selector</span>(alloc);</span><br><span class="line">        SEL swizzeSEL = <span class="keyword">@selector</span>(event_logging_alloc);</span><br><span class="line">        Method originMethod = class_getClassMethod(<span class="keyword">self</span>.class, originSEL);</span><br><span class="line">        Method swizzeMethod = class_getClassMethod(<span class="keyword">self</span>.class, swizzeSEL);</span><br><span class="line">        </span><br><span class="line">        method_exchangeImplementations(originMethod, swizzeMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)event_logging_alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> object = [<span class="keyword">self</span> event_logging_alloc];  <span class="comment">// 对于 NSAutoreleasePool 对象会崩掉</span></span><br><span class="line">    </span><br><span class="line">    nsobject_set_last_allocation_event_name(object, class_getName(<span class="keyword">self</span>.class));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> nsobject_set_last_allocation_event_name(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> * clsName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);  <span class="comment">// 输出类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但后来发现，NSData 创建对象的类静态方法没有调用 +[NSObject alloc]，里面实现是调用 C 方法 NSAllocateObject 来创建对象，也就是说类方式创建的 OC 对象无法通过 hook 来获取 OC 类名。最后在苹果开源代码 CF-1153.18 找到了答案，当__CFOASafe=true 并且 __CFObjectAllocSetLastAllocEventNameFunction != NULL 时，CoreFoundation 创建对象后通过这个函数指针告诉上层当前对象是什么类型：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRuntime.c</span></span><br><span class="line"></span><br><span class="line">bool __CFOASafe = <span class="keyword">false</span>;</span><br><span class="line">void <span class="comment">(*__CFObjectAllocSetLastAllocEventNameFunction)(void *, const char *)</span> = NULL;</span><br></pre></td></tr></table></figure><p>通过上面方式，我们的监控数据来源基本跟 Allocations 一样了，当然是借助了私有 API，这是可能会被苹果打回的。只能退而求其次，修改 malloc_default_zone 函数返回的 malloc_zone_t 结构体里的 malloc、free 等函数指针，也是可以监控堆内存分配，效果等同于 malloc_logger；而虚拟内存分配只能通过 fishhook 方式。</p><h3 id="2-2-数据存储"><a href="#2-2-数据存储" class="headerlink" title="2.2 数据存储"></a>2.2 数据存储</h3><p>①、存活对象管理</p><p>APP 在运行期间会大量申请/释放内存。以上图为例，微信启动 10 秒内，已经创建了 80 万对象，释放了 50 万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了 sqlite，改用了更轻量级的平衡二叉树来存储。</p><p>伸展树 Splay Tree，也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是 O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过 “伸展” 操作搬移到离树根更近的地方。</p><p>大部分情况下，内存申请很快又被释放，如 autoreleased 对象、临时变量等；而 OC 对象申请内存后紧接着会更新它所属 Category。所以用伸展树管理最适合不过了。</p><p>传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ef31fa94463803da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>②、堆栈存储</p><p>据统计，微信运行期间，backtrace 的堆栈有成百万上千万种，在捕获最大栈长 64 情况下，平均栈长 35。如果 36bits 存储一个地址（armv8 最大虚拟内存地址 48bits，实际上 36bits 够用了），一个堆栈平均存储长度 157.5bytes，1M 个堆栈需要157.5M 存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后 7 个地址是一样的：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-babc876580258a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>为此，可以用 Hash Table 来存储这些堆栈。思路是整个堆栈以链表的方式插入到 table 里，链表结点存放当前地址和上一个地址所在 table 的索引。每插入一个地址，先计算它的 hash 值，作为在 table 的索引，如果索引对应的 slot 没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash 命中，继续处理下一个地址；数据不一致，意味着 hash 冲突，需要重新计算 hash 值，直到满足存储条件。举个例子（简化了 hash 计算）：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-2f441cfc778e63f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol><li>Stack1 的 G、F、E、D、C、A 依次插入到哈希表，索引 1～6 结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1 索引入口是 6</li><li>轮到插入 Stack2，由于 G、F、E、D、C 结点数据跟 Stack1 前 5 个结点一致，hash 命中；B 插入新的 7 号位置 (B, 5)。Stack2 索引入口是 7</li><li>最后插入 Stack3，G、F、E、D 结点 hash 命中；但由于 Stack3 的 A 的上一个地址 D 索引是 4，而不是已有的 (A, 5)，hash 不命中，查找下一个空白位置 8，插入结点 (A, 4)；B 上一个地址 A 索引是 8，而不是已有的 (B, 5)，hash 不命中，查找下一个空白位置 9，插入结点 (B, 9)。Stack3 索引入口是 9</li></ol><p>经过这样的后缀压缩存储，平均栈长由原来的 35 缩短到 5 不到。而每个结点存储长度为 64bits（36bits 存储地址，28bits 储存 parent 索引），hashTable 空间利用率 60%+，一个堆栈平均存储长度只需要 66.7bytes，压缩率高达 42%。</p><p>③、性能数据</p><p>经过上述优化，内存监控工具在 iPhone6Plus 运行占用 CPU 占用率 13% 不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量 20M 左右，都用 mmap 方式把文件映射到内存。有关 mmap 好处可自行google。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e698f9596c1ad5b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="三、数据上报"><a href="#三、数据上报" class="headerlink" title="三、数据上报"></a>三、数据上报</h2><p>由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现 FOOM 时，不可能全量上报，而是按某些规则有选择性的上报。</p><p>首先把所有对象按 Category 进行归类，统计每个 Category 的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对 Category 下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些 Category，如分配大小 TOP N，或者UI相关的（如 UIViewController、UIView 之类的），它里面分配大小 TOP M 的堆栈才做上报。上报格式类似这样：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"items"</span> : [&#123;</span><br><span class="line">        <span class="string">"name"</span> : <span class="string">"NSObject"</span>,         # 分类名字</span><br><span class="line">        <span class="string">"size"</span> : <span class="number">123456</span>,             # 该分类下分配内存总大小</span><br><span class="line">        <span class="string">"count"</span> : <span class="number">123</span>,</span><br><span class="line">        <span class="string">"stacks"</span> : [&#123;</span><br><span class="line">            <span class="string">"size"</span> : <span class="number">21313</span>,          # 总大小</span><br><span class="line">            <span class="string">"count"</span> : <span class="number">123</span>,           # 对象个数</span><br><span class="line">            <span class="string">"frames"</span> : [&#123;</span><br><span class="line">                <span class="string">"uuid"</span> : uuid1,      # 地址所在 image 的 uuid</span><br><span class="line">                <span class="string">"offset"</span> : offset1   # 地址所在 image 的偏移</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、页面展现"><a href="#四、页面展现" class="headerlink" title="四、页面展现"></a>四、页面展现</h2><p>页面展现参考了 Allocations，可看出有哪些 Category，每个 Category 分配大小和对象数，某些 Category 还能看分配堆栈。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6f0873784b782d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>为了突出问题，提高解决问题效率，后台先根据规则找出可能引起 FOOM 的 Category（如上面的 Suspect Categories），规则有： </p><ol><li>UIViewController 数量是否异常</li><li>UIView 数量是否异常</li><li>UIImage 数量是否异常</li><li>其它 Category 分配大小是否异常，对象个数是否异常</li></ol><p>接着对可疑的 Category 计算特征值，也就是 OOM 原因。特征值是由 “Caller1”、”Caller2” 和 “Category, Reason” 组成。Caller1 是指申请内存点，Caller2 是指具体场景或业务，它们都是从 Category 下分配大小第一的堆栈提取。Caller1 提取尽量是有意义的，并不是分配函数的上一地址。例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-e03ff1c09c9eec15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所有 report 计算出特征值后，可以对它们进行归类了。一级分类可以是 Caller1，也可以是 Category，二级分类是与Caller1/Category 有关的特征聚合。效果如下：</p><h3 id="4-1-一级分类"><a href="#4-1-一级分类" class="headerlink" title="4.1 一级分类"></a>4.1 一级分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fab3ef4fe960cff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="4-2-二级分类"><a href="#4-2-二级分类" class="headerlink" title="4.2 二级分类"></a>4.2 二级分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ddf305f28b7511d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="五、运营策略"><a href="#五、运营策略" class="headerlink" title="五、运营策略"></a>五、运营策略</h2><p>上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概 300K 左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做 100% 开启。本地最多只保留最近三次数据。</p><h2 id="六、降低误判"><a href="#六、降低误判" class="headerlink" title="六、降低误判"></a>六、降低误判</h2><p>先回顾 Facebook 如何判定上一次启动是否出现 FOOM：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-f1aca616a4878bf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ol><li>App 没有升级</li><li>App 没有调用 exit() 或 abort() 退出</li><li>App 没有出现 crash</li><li>用户没有强退 App</li><li>系统没有升级/重启</li><li>App 当时没有后台运行</li><li>App 出现 FOOM</li></ol><p>1、2、4、5 比较容易判断，3 依赖于自身 CrashReport 组件的 crash 回调，6、7 依赖于 ApplicationState 和前后台切换通知。<strong>微信自上线 FOOM 数据上报以来，出现不少误判，主要情况有：</strong></p><h3 id="6-1-ApplicationState-不准"><a href="#6-1-ApplicationState-不准" class="headerlink" title="6.1 ApplicationState 不准"></a>6.1 ApplicationState 不准</h3><p>部分系统会在后台短暂唤起 app，ApplicationState 是 Active，但又不是 BackgroundFetch；执行完 didFinishLaunchingWithOptions 就退出了，也有收到 BecomeActive 通知，但很快也退出；整个启动过程持续 5～8 秒不等。解决方法是收到 BecomeActive 通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。</p><h3 id="6-2-群控类外挂"><a href="#6-2-群控类外挂" class="headerlink" title="6.2 群控类外挂"></a>6.2 群控类外挂</h3><p>这类外挂是可以远程控制 iPhone 的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。</p><h3 id="6-3-CrashReport-组件出现-crash-没有回调上层"><a href="#6-3-CrashReport-组件出现-crash-没有回调上层" class="headerlink" title="6.3 CrashReport 组件出现 crash 没有回调上层"></a>6.3 CrashReport 组件出现 crash 没有回调上层</h3><p>微信曾经在 17 年 5 月底爆发大量 GIF crash，该 crash 由内存越界引起，但收到 crash 信号写 crashlog 时，由于内存池损坏，组件无法正常写 crashlog，甚至引起二次 crash；上层也无法收到 crash 通知，因此误判为 FOOM。目前改成不依赖 crash回调，只要本地存在上一次 crashlog（不管是否完整），就认为是 crash 引起的 APP 重启。</p><h3 id="6-4-前台卡死引起系统-watchdog-强杀"><a href="#6-4-前台卡死引起系统-watchdog-强杀" class="headerlink" title="6.4 前台卡死引起系统 watchdog 强杀"></a>6.4 前台卡死引起系统 watchdog 强杀</h3><p>也就是常见的 0x8badf00d，通常原因是前台线程过多，死锁，或 CPU 使用率持续过高等，这类强杀无法被 App 捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被 watchdog 强杀。同时我们从 FOOM 划分出新的重启原因叫“App 前台卡死导致重启”，列入重点关注。</p><h2 id="七、成果"><a href="#七、成果" class="headerlink" title="七、成果"></a>七、成果</h2><p>微信自 2017 年三月上线内存监控以来，解决了 30 多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM 率由 17 年年初 3%，降到目前 0.67%，而前台卡死率由 0.6% 下降到 0.3%，效果特别明显。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0d49c3bc2a47404f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ed1e1b21c8bbd785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="八、常见问题"><a href="#八、常见问题" class="headerlink" title="八、常见问题"></a>八、常见问题</h2><p>1、UIGraphicsEndImageContext</p><p>UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode的 Analyze 也能扫出这类问题。</p><p>2、UIWebView</p><p>无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 APP 大量内存。而 WKWebView 不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。</p><p>3、autoreleasepool</p><p>通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。</p><p>4、互相引用</p><p>比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer的target、CAAnimation 的 delegate，是对 Obj 强引用。目前微信通过自己实现的 MMNoRetainTimer 和MMDelegateCenter 来规避这类问题。</p><p>5、大图片处理</p><p>举个例子，以往图片缩放接口是这样写的：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)scaleImage:<span class="type"></span>(UIImage *)originIamge <span class="keyword">new</span><span class="type">Size</span>:(CGSize)<span class="keyword">new</span><span class="type">Size</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(originIamge.size, NO, <span class="number">0</span>);</span><br><span class="line">    [originIamge drawInRect:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span><span class="type">Size</span>.width, <span class="keyword">new</span><span class="type">Size</span>.height)];</span><br><span class="line">    UIImage * <span class="keyword">new</span><span class="type">Image</span> = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很耗内存的。解决方法是使用更低层的 ImageIO 接口，避免中间 bitmap 产生：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)scaleImageWithData:(<span class="built_in">NSData</span> *)data withSize:(<span class="built_in">CGSize</span>)size scale:(<span class="built_in">CGFloat</span>)scale orientation:(<span class="built_in">UIImageOrientation</span>)orientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> maxPixelSize = MAX(size.width, size.height);</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> sourceRef = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> * options = @&#123; (__bridge <span class="keyword">id</span>)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge <span class="keyword">id</span>)kCFBooleanTrue, (__bridge <span class="keyword">id</span>)kCGImageSourceThumbnailMaxPixelSize : @(maxPixelSize)&#125;;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(sourceRef, <span class="number">0</span>, (__bridge <span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line">    <span class="built_in">UIImage</span> * resultImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:scale orientation:orientation];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    <span class="built_in">CFRelease</span>(sourceRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br></pre></td></tr></table></figure><p>6、大视图</p><p>大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。</p><h2 id="九、学习文章"><a href="#九、学习文章" class="headerlink" title="九、学习文章"></a>九、学习文章</h2><p><a href="https://cloud.tencent.com/developer/article/1359436" target="_blank" rel="noopener">iOS微信内存监控</a><br><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1" target="_blank" rel="noopener">Memory Usage Performance Guidelines</a><br><a href="http://www.newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="noopener">No pressure, Mon!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、导读&quot;&gt;&lt;a href=&quot;#一、导读&quot; class=&quot;headerlink&quot; title=&quot;一、导读&quot;&gt;&lt;/a&gt;一、导读&lt;/h2&gt;&lt;p&gt;目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>property</title>
    <link href="http://yoursite.com/2019/05/23/property/"/>
    <id>http://yoursite.com/2019/05/23/property/</id>
    <published>2019-05-23T08:46:45.820Z</published>
    <updated>2019-05-24T08:54:01.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>属性 property 是 Objective-C 的一项特性，<font color="#cc0000">用于封装对象中的数据</font>。这一特性可以令编译器自动编写与属性存取方法，并且保存为各种实例变量。</p><p>属性的本质是实例变量与存取方法的结合。@property = ivar + getter + setter</p><h2 id="二、特质"><a href="#二、特质" class="headerlink" title="二、特质"></a>二、特质</h2><h3 id="2-1-原子性-atomic-noatomic"><a href="#2-1-原子性-atomic-noatomic" class="headerlink" title="2.1 原子性 atomic/noatomic"></a>2.1 原子性 atomic/noatomic</h3><blockquote><p>原子性：并发编程中确保其操作具备整体性，系统其它部分无法观察到中间步骤，只能看到操作前后的结果。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b314acb38d50545e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="property"></p><p>由于要保证操作完整，atomic 速度比较慢，线程相对安全；nonatomic 速度比较快，但是线程不安全。</p><p>atomic 也不是绝对的线程安全，当多个线程同时调用 set 和 get 时，就会导致获取的值不一样。由于锁定机制开销较大，一般 iOS 开发中会使用 nonatomic，而 macOS 中使用 atomic 通常不会有性能瓶颈。</p><p>要想线程绝对安全，就要使用 @synchronized 同步锁。但是由于<font color="#cc0000">同步锁有等待操作，会降低代码效率</font>。为了兼顾线程安全和提升效率，可采用 GCD 并发队列进行优化改进。get 使用同步派发，set 使用异步栅栏。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步锁</span></span><br><span class="line">-(<span class="built_in">NSString</span> *)some</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _some;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setSome:(<span class="built_in">NSString</span> *)some</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        _some = some;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发队列</span></span><br><span class="line">_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)some</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *localSome;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_queue, ^ &#123;</span><br><span class="line">        localSome = _some;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> localSome;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setSome:(<span class="built_in">NSString</span> *)some</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        _some = some;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-读写权限-readwrite-readonly"><a href="#2-2-读写权限-readwrite-readonly" class="headerlink" title="2.2 读写权限 readwrite/readonly"></a>2.2 读写权限 readwrite/readonly</h3><p>默认为 readwrite。一般可在 .h 里写成 readonly，对外只提供读取方法，在 .m 的 Extension 中再设置为 readwrite 可进行写入。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,  <span class="keyword">readonly</span>, <span class="keyword">strong</span>) AModel * model;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) AModel * model;</span><br></pre></td></tr></table></figure><h3 id="2-3-内存管理语义-assign、strong、copy、weak、unsafe-unretained"><a href="#2-3-内存管理语义-assign、strong、copy、weak、unsafe-unretained" class="headerlink" title="2.3 内存管理语义 assign、strong、copy、weak、unsafe_unretained"></a>2.3 内存管理语义 assign、strong、copy、weak、unsafe_unretained</h3><h4 id="2-3-1-关键词"><a href="#2-3-1-关键词" class="headerlink" title="2.3.1 关键词"></a>2.3.1 关键词</h4><p>strong：指向并拥有该对象。其修饰的对象引用计数会 +1，该对象只要引用计数不为 0 就不会销毁，置为 nil 可以销毁它，一般<font color="#cc0000">用于修饰对象类型、字符串和集合类的可变版本</font>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * nArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSMutableArray</span> * mArr = [[<span class="built_in">NSMutableArray</span> alloc] initWithObjects:<span class="string">@"a"</span>, <span class="string">@"b"</span>, <span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line">     <span class="keyword">self</span>.nArr = mArr;   <span class="comment">// 赋值</span></span><br><span class="line">     [mArr addObject:<span class="string">@"d"</span>];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@  %p  %p"</span>, <span class="keyword">self</span>.nArr, <span class="keyword">self</span>.nArr, mArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-10</span><span class="number">-16</span> <span class="number">19</span>:<span class="number">29</span>:<span class="number">27.550029</span>+<span class="number">0800</span> Demo[<span class="number">64192</span>:<span class="number">936916</span>] (</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c,</span><br><span class="line">     d</span><br><span class="line">)    <span class="number">0x60000005bc60</span>     <span class="number">0x60000005bc60</span>    <span class="comment">// 地址相同</span></span><br></pre></td></tr></table></figure><p>copy：与 strong 类似，设置方法会拷贝一份副本。一般用于修饰字符串和集合类的不可变版，block 用 copy 修饰。自定义对象需要实现 NSCoping 协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> * nArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSMutableArray</span> * mArr = [[<span class="built_in">NSMutableArray</span> alloc] initWithObjects:<span class="string">@"a"</span>, <span class="string">@"b"</span>, <span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line">     <span class="keyword">self</span>.nArr = mArr;   <span class="comment">// 赋值</span></span><br><span class="line">     [mArr addObject:<span class="string">@"d"</span>];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@  %p  %p"</span>, <span class="keyword">self</span>.nArr, <span class="keyword">self</span>.nArr, mArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-10</span><span class="number">-16</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">27.678093</span>+<span class="number">0800</span> Demo[<span class="number">63966</span>:<span class="number">933713</span>] (</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">)    <span class="number">0x60000024e070</span>    <span class="number">0x60000024c960</span>   <span class="comment">// 地址不同</span></span><br></pre></td></tr></table></figure><p>自定义对象实现 NSCoping 协议</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">     AModel * model = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] init];</span><br><span class="line">     model.title = <span class="keyword">self</span>.title;</span><br><span class="line">     model.desc = <span class="keyword">self</span>.desc;</span><br><span class="line">     <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak：指向但不拥有该对象。其修饰的对象引用计数不会增加，属性所指的对象遭到摧毁时值会清空。ARC 环境下一般用于修饰可能会引起循环引用的对象，delegate、xib 控件用 weak 修饰。</p><p>assign：主要用于修饰基本数据类型，如 NSInteger、CGFloat 等，这些数值主要存在于栈中。</p><p>unsafe_unretained：与 weak 类型，但是销毁时不自动清空，容易形成野指针。</p><h4 id="2-3-2-比较-copy-和-strong"><a href="#2-3-2-比较-copy-和-strong" class="headerlink" title="2.3.2 比较 copy 和 strong"></a>2.3.2 比较 copy 和 strong</h4><p>相同：用于修饰表示拥有关系的对象；</p><p>不同：strong 赋值是多个指针指向同一个地址，而 copy 的赋值是每次会在内存中赋值一份对象，指针指向不同的地址。</p><p>NSString、NSArray、NSDictionary 等不可变对象用 copy 修饰，因为有可能赋值一个可变类型的指针，此时能保证属性值不会受外界影响。</p><p>注意：若用 strong 修饰 NSArray，当数组接收一个可变数组，可变数组若发生变化，被修饰的属性数组也会发生变化，也就是说属性值容易被篡改；若用 copy 修饰 NSMutableArray，当试图修改属性数组里的值时，程序会崩溃，因为数组被复制成了一个不可变的版本。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> * nArr;   <span class="comment">// strong 修改不可变属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .m 文件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> * mArr = [[<span class="built_in">NSMutableArray</span> alloc] initWithObjects:<span class="string">@"a"</span>, <span class="string">@"b"</span>, <span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.nArr = mArr;   <span class="comment">// 赋值</span></span><br><span class="line">    [mArr addObject:<span class="string">@"d"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@  %p  %p"</span>, <span class="keyword">self</span>.nArr, <span class="keyword">self</span>.nArr, mArr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-02</span> <span class="number">11</span>:<span class="number">12</span>:<span class="number">25.479726</span>+<span class="number">0800</span> DemoDemo[<span class="number">11401</span>:<span class="number">1924103</span>] (</span><br><span class="line">    a,</span><br><span class="line">    b,</span><br><span class="line">    c,</span><br><span class="line">    d</span><br><span class="line">)  <span class="number">0x60000045bed0</span>  <span class="number">0x60000045bed0</span>   <span class="comment">// 地址相同</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-比较-assign、weak、unsafe-unretained"><a href="#2-3-3-比较-assign、weak、unsafe-unretained" class="headerlink" title="2.3.3 比较 assign、weak、unsafe_unretained"></a>2.3.3 比较 assign、weak、unsafe_unretained</h4><p>相同点：都不是强引用</p><p>不同点：weak 引用的 OC 对象被销毁时，指针会被自动清空，不再指向销毁的对象，不会产生野指针错误；unsafe_unretained 引用的 OC 对象被销毁时，指针并不会被自动清空，依然指向销毁的对象，很容易产生野指针错误：EXC_BAD_ACCESS；assign 修饰基本数据类型，内存在栈上由系统自动回收，修饰对象类型时，也可能存在野指针。</p><p>在使用 delegate 时，需要注意：MRC 时是使用 assign，到了 ARC 环境，都建议使用 weak，这样更安全。</p><p>不管是 MRC 还是 ARC，使用 assign 时，都需要注意释放。如果在 ARC 下，没有做这个逻辑的话，当页面销毁的时候，很可能出现delegate 对象无效，导致程序 crash。</p><h3 id="2-4-方法-setter-与-getter"><a href="#2-4-方法-setter-与-getter" class="headerlink" title="2.4 方法 setter= 与 getter="></a>2.4 方法 setter= 与 getter=</h3><p>&lt;&gt; 中为方法名，通过此特质来指定存取方法的名称。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isOn) <span class="built_in">BOOL</span> on;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">BOOL</span>)isOn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d5216327dca37789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="property"></p><h2 id="三、默认设置"><a href="#三、默认设置" class="headerlink" title="三、默认设置"></a>三、默认设置</h2><p>基本数据类型：(atomic, readwrite, assign)<br>对象类型：(atomic, readwrite, strong)</p><p>注意：考虑到代码可读性以及日常代码修改频率，规范的编码风格中关键词的顺序是：原子性、读写权限、内存管理语义、setter/getter。</p><h2 id="四、延伸"><a href="#四、延伸" class="headerlink" title="四、延伸"></a>四、延伸</h2><p>@property 会使编译器自动编写访问这些属性所需的方法，此过程在编译期完成，称为自动合成（autosynthesis）。与此相关的还有两个关键词：@dynamic 和 @synthesize。</p><h3 id="4-1-dynamic"><a href="#4-1-dynamic" class="headerlink" title="4.1 @dynamic"></a>4.1 @dynamic</h3><p>告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。即使编译器发现没有定义存取方法也不会报错，运行期会导致崩溃。</p><h3 id="4-2-synthesize"><a href="#4-2-synthesize" class="headerlink" title="4.2 @synthesize"></a>4.2 @synthesize</h3><p>在类的实现文件里可以通过 @synthesize 指定实例变量的名称。</p><p>注意：Xcode4.4 之前，@property 配合 @synthesize 使用，@property 负责声明属性，@synthesize 负责让编译器生成带下划线的实例变量并且自动生成 setter、getter 方法；在 Xcode4.4 之后 @property 得到增强，直接一并替代了@synthesize 的工作。</p><h2 id="五、学习文章"><a href="#五、学习文章" class="headerlink" title="五、学习文章"></a>五、学习文章</h2><p><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">《Effective Objective-C 2.0》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;p&gt;属性 property 是 Objective-C 的一项特性，&lt;font color=&quot;#cc0000&quot;&gt;用于封装对象中的
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARC</title>
    <link href="http://yoursite.com/2019/05/23/ARC/"/>
    <id>http://yoursite.com/2019/05/23/ARC/</id>
    <published>2019-05-23T08:17:05.311Z</published>
    <updated>2019-05-24T08:52:32.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ARC"><a href="#一、ARC" class="headerlink" title="一、ARC"></a>一、ARC</h2><p>ARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果修改了一些内存管理代码的书写方式，干脆编译器在编译时把内存管理的代码都自动补上。</p><p><font color="#cc0000">ARC 是编译器特性，而不是运行时特性，更不是垃圾回收器（GC）</font>。</p><blockquote><p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p></blockquote><p>程序在编译的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，编译器帮我们在合适的地方插入retain、release 等代码以管理对象的引用计数，从而达到自动管理对象生命周期的目的。</p><p>所以 ARC 是工作在编译期的一种技术方案，这样的好处：</p><ol><li><p>编译之后，ARC 与 MRC 代码是没有什么差别的，所以二者可以<font color="#cc0000">在源码中共存</font>。</p></li><li><p>相对于垃圾回收这类内存管理方案，<font color="#cc0000">ARC 不会带来运行时的额外开销</font>，所以对于应用的运行效率不会有影响。相反的，由于ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。</p></li></ol><p>只有编译器是无法单独完成这一工作的，还需要 OC 运行时库的配合协助，因此 ARC 的实现工具主要包括：</p><ol><li>LLVM 编译器（clang 3.0 以上）</li><li>OC 运行时库 493.9 以上</li></ol><p>weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。</p><p>ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外 10% 的内存管理问题是需要开发者处理的，这主要是与底层 Core Foundation 对象交互的部分，底层 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。</p><h2 id="二、ARC-的开启和关闭"><a href="#二、ARC-的开启和关闭" class="headerlink" title="二、ARC 的开启和关闭"></a>二、ARC 的开启和关闭</h2><p>在 Targets -》Build Settings 中搜索 Automatic Reference Counting，可以修改它的布尔值，yes - 开启　no - 关闭。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-186571a065bdb139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p><p>如果需要对特定文件开启或关闭 ARC，可以在 Targets -》Build Phases -》Compile Sources，在里面找到对应文件，添加flag：</p><p>开启：-fobjc-arc  关闭：-fno-objc-arc</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-de31d9803c80902b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p><h2 id="三、ARC-的修饰符"><a href="#三、ARC-的修饰符" class="headerlink" title="三、ARC 的修饰符"></a>三、ARC 的修饰符</h2><p>主要提供了 4 种修饰符，他们分别是：__strong、__weak、__autoreleasing、__unsafe_unretained。</p><h3 id="3-1-strong"><a href="#3-1-strong" class="headerlink" title="3.1 __strong"></a>3.1 __strong</h3><p>强引用。相当于 @property 的 “strong”。所有对象只有当没有任何一个强引用指向（引用计数为 0）时，才会被释放。</p><blockquote><p>注意：如果在声明引用时不加修饰符，那么将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置 nil。</p></blockquote><p>使用 __strong 修饰变量的程序运行过程。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的模拟源代码为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">id <span class="keyword">object</span> = objc_msgSend(NSObjct, <span class="meta">@selector(alloc)</span>);</span><br><span class="line">objc_msgSend(<span class="keyword">object</span>, <span class="meta">@selector(init)</span>);</span><br><span class="line">objc_release(<span class="keyword">object</span>);</span><br></pre></td></tr></table></figure><p>对象变量生成时，分别调用 alloc 和 init 方法，对象变量作用域结束时调用 objc_release 方法释放对象变量，虽然 ARC 情况下不能使用 release 方法，但是由此可见编译器编译时在合适的地方插入了 release。</p><p>在使用 alloc、new、copy、mutableCopy 以外的方法生成对象变量方法时会有什么不同</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> object = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 array 的类方法转换后：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /*编译器的模拟代码*/</span><br><span class="line">    id object = objc_msgSend(<span class="name">NSMutableArray</span>, @selector(<span class="name">array</span>))<span class="comment">;</span></span><br><span class="line">    objc_retainAutoreleasedReturnValue(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_retainAutoreleasedReturnValue(object) 函数的作用：最优化程序运行。</p><p>自己持有（retain）对象的函数，但它持有的应为返回注册在 autoreleasepool 中对象的方法或函数的返回值。</p><p>objc_retainAutoreleasedReturnValue 函数与 objc_autoreleasedReturnValue 是成对出现的，现在看看 NSMutableArray 类的 array 类方法的编译器实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    <span class="keyword">return</span> [[NSMutableArray alloc] <span class="keyword">init</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的源代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, <span class="meta">@selector(alloc)</span>);</span><br><span class="line">    objc_msgSend(obj, <span class="meta">@selector(init)</span>);</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 objc_autoreleaseReturnValue 函数将对象注册在自动释放池 autoreleasepool 中并返回，但是与 objc_autorelease 函数不同的是，objc_autoreleaseReturnValue 函数一般不仅限于注册对象到 autoreleasepool 中去。</p><p>objc_autoreleaseReturnValue 与 objc_retainAutoreleasedReturnValue 的配合使用，可以不将对象注册到autoreleasepool 中而直接传递，达到最优化。</p><p>objc_autoreleaseReturnValue 函数会检查使用该函数的方法或者函数的调用方的执行命令列表，如果调用方在调用该函数或方法之后，紧接着调用了 objc_retainAutoreleasedReturnValue 函数，那么不再将对象注册到 autoreleasepool 中去，而直接将对象传递给调用方。</p><p>相比于 objc_retain 函数来说 objc_retainAutoreleasedReturnValue 函数在返回一个即使没有注册到autoreleasepool 中的对象，也能正确的获取对象。</p><h3 id="3-2-weak"><a href="#3-2-weak" class="headerlink" title="3.2 __weak"></a>3.2 __weak</h3><p>弱引用。相当于 @property 的 “weak”。弱引用不会影响对象的引用计数，即只要对象没有任何强引用指向，即使有 n 个弱引用对象指向也没用，该对象依然会被释放。</p><p>对象在被释放的同时，指向它的弱引用（weak）会自动被置 nil，这个技术叫 zeroing weak pointer。这样有效的防止无效指针、野指针的产生。__weak 一般用在 delegate 关系中防止循环引用或者用来修饰指向由 Interface Builder 编辑与生成的 UI 控件。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id _weak object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的模拟源代码。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id object;</span><br><span class="line">    id tmp = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">tmp</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    objc_initWeak(<span class="name">&amp;object</span>, tmp)<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">    objc_destoryWeak(<span class="name">&amp;object</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己生成并且持有的对象通过 objc_initWeak 函数赋值给 __weak 修饰符的变量，但是编译器判断并没有对其进行持有，因此该对象通过 objc_release 函数被释放和废弃。</p><p>随后通过 objc_destoryWeak 将引用废弃对象的附有 __weak 修饰符的变量置为 nil。</p><p>如果不是直接赋值，而是通过使用 __weak 修饰符来引用变量时。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak <span class="class"><span class="keyword">object</span> </span>= obj;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, <span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的模拟源代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">&#123;</span><br><span class="line">    id <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">    objc_initWeak(&amp;<span class="class"><span class="keyword">object</span>, <span class="title">obj</span>)</span>;</span><br><span class="line">    id temp = objc_loadWeakRetained(&amp;<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">    objc_autorelease(temp);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, temp);</span><br><span class="line">    objc_destoryWeak(&amp;<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显增加了 objc_loadWeakRetained 与 objc_autorelease 函数调用，他们的主要作用是：</p><ol><li>objc_loadWeakRetained 函数取出 __weak 修饰符变量引用的对象并且 retain</li><li>objc_autorelease 函数将引用的对象注册到 autoreleasepool 中。</li></ol><p>因此，使用 __weak 修饰符引用的对象都被注册到 autoreleasepool 中，在 @autoreleasepool 块结束之前都可以放心使用，大量使用 __weak 修饰符的变量，导致注册到 autoreleasepool 中的对象也大量地增加。所以在使用 __weak 修饰符引用的变量时，最好先暂时用 __strong 修饰符的变量进行引用后再使用。</p><p>2 种不能使用 __weak 修饰符的情况：</p><ul><li>重写了 retain/release 的类，例如 NSMachPort 类；</li><li>当 allowsWeakReference/retainWeakReference 实例方法返回 NO 时。</li></ul><h3 id="3-3-autoreleasing"><a href="#3-3-autoreleasing" class="headerlink" title="3.3 __autoreleasing"></a>3.3 __autoreleasing</h3><p>对象被加入到 autorelease pool，是会自动释放的引用，与 MRC 中 autorelease 的用法相同。定义 @property 时不能使用这个修饰符。</p><p>对于 alloc、new、copy、mutableCopy 的实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id __autoreleasing <span class="keyword">object</span> = [[NSObject alloc] <span class="keyword">init</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的模拟源代码。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id pool = objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line">    id object = objc_msgSend(<span class="name">NSObjct</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">object</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    // 调用autorelease方法</span><br><span class="line">    objc_autorelease(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    id pool = objc_autoreleasePoolPop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSMutableArray 类中的 array 方法如何实现 autorelease 功能。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing object = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后的模拟源代码。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id pool = objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line">    id object = objc_msgSend(<span class="name">NSMutableArray</span>, @selector(<span class="name">array</span>))<span class="comment">;</span></span><br><span class="line">    objc_retainAutoreleasedReturnValue(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    // 调用 autorelease 方法</span><br><span class="line">    objc_autorelease(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    id pool = objc_autoreleasePoolPop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了持有对象的方法从 alloc 变成了 objc_retainAutoreleasedReturnValue 函数，但是注册到 autoreleasepool 的方法没有变化，都是调用了 objc_autorelease 函数。</p><p>一个常见的误解是，在 ARC 中没有 autorelease，因为这样一个“自动释放”看起来好像有点多余。</p><p>这个误解可能源自于将 ARC 的“自动” 和 autorelease “自动” 的混淆。其实你只要看一下每个 iOS App 的 main.m 文件就能知道，autorelease 不仅好好的存在着，并且不需要再手工被创建，也不需要再显式得调用 [pool drain] 方法释放内存池。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下两行代码的意义是相同的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"China"</span>] autorelease];   <span class="comment">// MRC</span></span><br><span class="line"><span class="built_in">NSString</span> * __autoreleasing str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"China"</span>]; <span class="comment">// ARC</span></span><br></pre></td></tr></table></figure><p>__autoreleasing 在 ARC 中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。</p><blockquote><p>__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</p></blockquote><p>比如常见的 NSError 的使用：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError * __autoreleasing <span class="keyword">error</span>;</span><br><span class="line"> </span><br><span class="line">// writeToFile方法中 <span class="keyword">error</span> 参数的类型为 (NSError *__autoreleasing *)）</span><br><span class="line">￼<span class="keyword">if</span> (![data writeToFile:<span class="keyword">filename</span> options:NSDataWritingAtomic <span class="keyword">error</span>:&amp;<span class="keyword">error</span>])  &#123; </span><br><span class="line">　　NSLog(@<span class="string">"Error: %@"</span>, <span class="keyword">error</span>.localizedDescription); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果 error 的修饰符为 strong，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个 __autoreleasing 类型的引用。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSError</span> * <span class="keyword">error</span>; </span><br><span class="line"><span class="type">NSError</span> * __autoreleasing tempError = <span class="keyword">error</span>;  <span class="comment">// 编译器添加</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (![data writeToFile:filename options:<span class="type">NSDataWritingAtomic</span> <span class="keyword">error</span>:&amp;tempError]) </span><br><span class="line">￼&#123; </span><br><span class="line">　　<span class="keyword">error</span> = tempError; <span class="comment">// 编译器添加 </span></span><br><span class="line">　　<span class="type">NSLog</span>(@<span class="string">"Error: %@"</span>, <span class="keyword">error</span>.localizedDescription); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免这种情况，提高效率，一般在定义 error 的时候将其声明为__autoreleasing 类型的：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSError</span> *__autoreleasing <span class="literal">error</span>;</span><br></pre></td></tr></table></figure><p>加上 __autoreleasing 之后，相当于在 MRC 中对返回值 error 做了如下事情：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*error = <span class="comment">[<span class="comment">[<span class="comment">[NSError alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure><p>*error 指向的对象在创建出来后，被放入到了 autoreleasing pool 中，等待使用结束后的自动释放，函数外 error 的使用者并不需要关心 *error 指向对象的释放。</p><p>另外，在 ARC 中，所有这种指针的指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 __autoreleasing 类型。</p><p>比如下面的两段代码是等同的：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">doSomething</span><span class="selector-pseudo">:(NSNumber</span> **)<span class="selector-tag">value</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">doSomething</span><span class="selector-pseudo">:(NSNumber</span> * <span class="selector-tag">__autoreleasing</span> *)<span class="selector-tag">value</span></span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非显式得给 value 声明了 __strong，否则 value 默认就是 __autoreleasing 的。</p><p>最后一点，某些类的方法会隐式地使用自己的 autorelease pool，在这种时候使用 __autoreleasing 类型要特别小心。</p><p>比如 NSDictionary 的 - enumerateKeysAndObjectsUsingBlock: 方法会隐式地创建一个 autorelease pool.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">          <span class="comment">// do stuff  </span></span><br><span class="line">          <span class="keyword">if</span> (...)  &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">￼&#125;</span><br></pre></td></tr></table></figure><p>上面代码实际类似于：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">          <span class="keyword">@autoreleasepool</span>  <span class="comment">// 被隐式创建</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">              <span class="keyword">if</span> (...) &#123;</span><br><span class="line">                    *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">              &#125;</span><br><span class="line">￼          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// *error 在这里已经被dict的做枚举遍历时创建的 autorelease pool 释放掉了 </span></span><br><span class="line">￼&#125;</span><br></pre></td></tr></table></figure><p>为了能够正常的使用 *error，我们需要一个 strong 型的临时引用，在 dict 的枚举 block 中使用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 block 后被释放，正确的方式如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">　　__block <span class="built_in">NSError</span> * tempError;  <span class="comment">// 加 __block 保证可以在 Block 内被修改  </span></span><br><span class="line">　　</span><br><span class="line">   [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123; </span><br><span class="line">　　　　</span><br><span class="line">      <span class="keyword">if</span> (...)  &#123; </span><br><span class="line">　　　　　　*tempError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>]; </span><br><span class="line">　　　　&#125; ￼ </span><br><span class="line">　　&#125;] </span><br><span class="line">　　<span class="keyword">if</span> (error != <span class="literal">nil</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　*error = tempError; </span><br><span class="line">　　&#125; ￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-unsafe-unretained"><a href="#3-4-unsafe-unretained" class="headerlink" title="3.4 __unsafe_unretained"></a>3.4 __unsafe_unretained</h3><p>ARC 是在 iOS 5 引入的，而这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些低版本的设备没有 weak pointer system，这个系统简单的理解就是上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil。</p><p>相当于 @property 的 “unsafe_unretained”，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然指向原来被释放的对象（所在的内存区域）。所以非常不安全。</p><p>现在可以完全忽略掉这个修饰符了，因为 iOS 4 早已退出历史舞台很多年。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __unsafe_unretained object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的模拟源代码。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     /*编译器的模拟代码*/</span><br><span class="line">    id object = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">object</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见通过 __unsafe_unretained 修饰的变量引用了对象但是并不持有对象，对象在释放和废弃后，并没有调用被 __unsafe_unretained 修饰的变量的 objc_destoryWeak 函数，因此该对象的悬垂指针被赋值给变量 object，导致引用变量 object 时发生崩溃。</p><h3 id="3-5-正确使用修饰符"><a href="#3-5-正确使用修饰符" class="headerlink" title="3.5 正确使用修饰符"></a>3.5 正确使用修饰符</h3><p>苹果的文档中明确地写道：</p><blockquote><p>You should decorate variables correctly. When using qualifiers in an object variable declaration,<br>the correct format is:<br>  ClassName * qualifier variableName;</p></blockquote><p>按照这个说明，要定义一个 weak 修饰的 NSString 引用，它的写法应该是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * __<span class="keyword">weak</span> str = <span class="string">@"Hello"</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>而不应该是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *str = <span class="string">@"Hello"</span>;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：</p><blockquote><p>Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see <a href="http://cdecl.org/" target="_blank" rel="noopener">http://cdecl.org/</a>.</p></blockquote><p>看来是苹果考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符。</p><h3 id="3-6-栈中指针默认值为-nil"><a href="#3-6-栈中指针默认值为-nil" class="headerlink" title="3.6 栈中指针默认值为 nil"></a>3.6 栈中指针默认值为 nil</h3><p>无论是被 strong、weak 还是 autoreleasing 修饰，声明在栈中的指针默认值都会是 nil。所有这类型的指针不用再初始化的时候置 nil 了。这个特性更加降低了“野指针”出现的可能性。</p><p>在 ARC 中，以下代码会输出 null 而不是 crash。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMethod </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * name;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、ARC-与-Block"><a href="#四、ARC-与-Block" class="headerlink" title="四、ARC 与 Block"></a>四、ARC 与 Block</h2><p>在手动管理内存时代，block 会隐式地对进入其作用域内的对象（或者说被 block 捕获的指针指向的对象）执行 retain 操作，来确保 block 使用到该对象时，能够正确的访问。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * myController = [[MyViewController alloc] init…]; </span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    <span class="comment">// 隐式地调用 [myController retain]; 造成循环引用</span></span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:myController animated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">    <span class="comment">// 调用[myController release];是在 MRC 中的一个常规写法，并不能解决上面循环引用的问题</span></span><br><span class="line">    [myController release]; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondVC</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^ block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">&#123;</span><br><span class="line">    SecondVC * vc = [[SecondVC alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)vc.retainCount);</span><br><span class="line">    </span><br><span class="line">    vc.block = ^ &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)vc.retainCount);</span><br><span class="line">    &#125;;</span><br><span class="line">    vc.block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">26</span>:<span class="number">05.872092</span>+<span class="number">0800</span> Demo[<span class="number">49289</span>:<span class="number">1083433</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">26</span>:<span class="number">05.872214</span>+<span class="number">0800</span> Demo[<span class="number">49289</span>:<span class="number">1083433</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure><p>dismissBlock 调用了 [myController dismiss..] 方法，这时 dismissBlock 会对 myController 执行 retain 操作。</p><p>而作为 myController 的属性，myController 对 dismissBlock 也至少有一个 retain（一般准确讲是 copy），这时就出现了在内存管理中最糟糕的情况：循环引用。也就是说：相互持有对方。循环引用导致了 myController 和 dismissBlock 最终都不能被释放。</p><p>对 delegate 指针用 weak 就是为了避免这种问题。</p><p>不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-56f8ed9fe539a49f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p><p>我们一般用如下方法解决：给进入 block 的指针加一个 __block 修饰符。</p><p>这个 __block 在 MRC 时代有两个作用：</p><ul><li>说明变量可改</li><li>说明指针指向的对象不做隐式的 retain 操作</li></ul><p>除了静态变量和全局变量不需要加 __block 就可以在 block 中修改外，其他变量不加则不能在 block 中修改。</p><p>对代码做出修改，解决了循环引用的问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __block myController = [[MyViewController alloc] init…]; </span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 之后正常的 release 或者 retain</span></span><br></pre></td></tr></table></figure><p>在 ARC 环境下，没有了 retain 和 release 等操作，情况也发生了改变：</p><blockquote><p>在任何情况下，__block 修饰符的作用只有上面的第一条：说明变量可改。即使加上了 __block 修饰符，一个被 block 捕获的强引用也依然是一个强引用。</p></blockquote><p>所以在 ARC 下，如果还按照 MRC 下的写法，添加 __block 是没有解决循环引用的问题。</p><p>代码修改如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block MyViewController * myController = [[MyViewController alloc] init…]<span class="comment">; </span></span><br><span class="line">myController.<span class="keyword">dismissBlock </span>=  ^(NSString * result) &#123;</span><br><span class="line">    [myController <span class="keyword">dismissViewControllerAnimated:YES </span>completion:nil]<span class="comment">;</span></span><br><span class="line">    myController = nil<span class="comment">;  // 注意这里，保证了 block 结束对 myController 强引用的解除</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在 block 中将捕获的指针置为 nil，保证了 dismissBlock 对 myController 强引用的解除，不过也同时解除了myController 指针对 myController 对象的强引用。</p><p>更好的方法就是使用 weak。（或者为了考虑 iOS4 的兼容性用 unsafe_unretained，具体用法和 weak 相同）</p><p>为了保证 dismissBlock 对 myController 没有强引用，我们可以定义一个临时的弱引用 weakMyViewController 来指向原myController 的对象，并把这个弱引用传入到 dismissBlock 内，这样就保证了 dismissBlock 对 myController 持有的是一个弱引用，而不是一个强引用。如此，继续修改代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __weak weakMyViewController = myController<span class="comment">;</span></span><br><span class="line">myController.<span class="keyword">dismissBlock </span>=  ^(NSString * result) &#123;</span><br><span class="line">    [weakMyViewController <span class="keyword">dismissViewControllerAnimated:YES </span>completion:nil]<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样循环引用的问题就解决了，但是却引入了一个新的问题：由于传入 dismissBlock 的是一个弱引用，那么当 myController指向的对象在 dismissBlock 被调用前释放，那么 dismissBlock 就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。</p><p>为了保证在 dismissBlock 内能够访问到正确的 myController，我们在 dismissBlock 内新定义一个强引用strongMyController 来指向 weakMyController 指向的对象，这样多了一个强引用，就能保证这个 myController 对象不会在 dismissBlock 被调用前释放掉了。于是，对代码再次做出修改：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __<span class="keyword">weak</span> weakMyController = myController;</span><br><span class="line"><span class="comment">// __weak typeof(myController) weakMyController = myController;</span></span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    MyViewController * strongMyController = weakMyController;</span><br><span class="line">    <span class="comment">// __strong typeof(weakMyController) strongMyController = weakMyController;</span></span><br><span class="line">    <span class="keyword">if</span> (strongMyController) &#123;</span><br><span class="line">         [strongMyController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很多读者会有疑问，不是不希望 block 对原 myController 对象增加强引用么，这里为什么堂而皇之地在 block 内新定义了一个强引用，这个强引用不会造成循环引用么？</p><p>理解这个问题的关键在于被 block 捕获的引用和在 block 内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block 的实现原理，详细的内容可以参考其他的文章：<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" title="谈Objective-C block的实现" target="_blank" rel="noopener">谈Objective-C block的实现</a>、<a href="http://blog.csdn.net/hherima/article/details/38586101" target="_blank" rel="noopener">block 实现</a>、<a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">正确使用Block避免Cycle Retain和Crash</a>。</p><p>为了更清楚地说明问题，这里用一个简单的程序举例。如下程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^ block)() = ^() &#123;</span><br><span class="line">         <span class="keyword">int</span> *c = a;</span><br><span class="line">    &#125;;</span><br><span class="line">    block(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中，同为 int 型的指针，a 变量被 block 捕获，而 c 变量是在 block 内定义的。用 clang -rewrite-objc 命令处理后，可以看到如下代码。</p><p>原 main 函数：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int b = <span class="number">10</span>;</span><br><span class="line">    int *a = &amp;b;</span><br><span class="line">   </span><br><span class="line">    <span class="literal">void</span> (*block)() = (<span class="literal">void</span> (*)())&amp;__main_block_impl_0((<span class="literal">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);</span><br><span class="line">    <span class="function"><span class="params">((<span class="literal">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block)</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">return</span> 1;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>block 的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc; </span><br><span class="line">    </span><br><span class="line">    int *a;  <span class="comment">// 被捕获的引用 a 出现在了 block 的结构体里面</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际执行的函数：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">__main_block_func_0</span><span class="params">(struct __main_block_impl_0 *__cself)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> *a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">     <span class="keyword">int</span> *c = a; <span class="comment">// 在 block 中声明的引用 c 在函数中声明，存在于函数栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以清楚的看到，a 和 c 存在的位置完全不同，如果 block 存在于堆上（在 ARC 下 block 默认在堆上），那么 a 作为 block 结构体的一个成员，也自然会存在于堆上，而 c 无论如何，永远位于 block 内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c 在 block 的函数运行完毕，即会被释放，而 a 只有在 block 被从堆上释放的时候才会释放。</p><p>回到之前的示例，如果直接让 dismissBlock 捕获 myController 引用，那么这个引用会被复制后作为 dismissBlock 的成员变量存在于其所在的堆空间中，也就是为 dismissBlock 增加了一个指向 myController 对象的强引用，这就是造成循环引用的本质原因。</p><p>对于 MyViewController 的例子，dismissBlock 的结构体大概是这个样子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    MyViewController * __strong myController;  <span class="comment">// 被捕获的强引用 myController</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">         <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">         <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">         <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">         Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而给 dismissBlock 传入一个弱引用 weakMyController，这时 dismissBlock 的结构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    MyViewController * __weak weakMyController;  <span class="comment">// 被捕获的弱引用 weakMyController</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 dismissBlock 内声明的强引用 strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，一直持有 myController 对象，但当函数执行完毕，strongMyController 即被销毁，于是它对 myController 对象的强引用被解除，这时 dismissBlock 对 myController 对象就不存在强引用关系了！</p><p>加入了 strongMyController 的函数大体会是这个样子：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">     MyViewController * <span class="variable">__strong</span> strongMyController = <span class="variable">__cself</span>-&gt;weakMyController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ARC 中，block 捕获的引用和 block 内声明的引用，存储空间与生命周期都是不同的。</p><p>实际上，在自动引用计数环境下，对 block 捕获对象的内存管理已经简化了很多，由于没有了 retain 和 release 等操作，实际只需要考虑循环引用的问题就行了。</p><h2 id="五、ARC-与-Toll-Free-Bridging"><a href="#五、ARC-与-Toll-Free-Bridging" class="headerlink" title="五、ARC 与 Toll-Free Bridging"></a>五、ARC 与 Toll-Free Bridging</h2><blockquote><p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called <em>toll-free bridging</em>, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message.</p></blockquote><p>Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。详细的内容可参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="noopener">官方文档</a>。以下是官方文档中给出的示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocale</span> * gbNSLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_GB"</span>];</span><br><span class="line"><span class="built_in">CFLocaleRef</span> gbCFLocale = (<span class="built_in">CFLocaleRef</span>) gbNSLocale;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfIdentifier = <span class="built_in">CFLocaleGetIdentifier</span> (gbCFLocale);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"cfIdentifier: %@"</span>, (<span class="built_in">NSString</span> *)cfIdentifier); <span class="comment">// logs: "cfIdentifier: en_GB"</span></span><br><span class="line"><span class="built_in">CFRelease</span>((<span class="built_in">CFLocaleRef</span>) gbNSLocale);</span><br><span class="line"><span class="built_in">CFLocaleRef</span> myCFLocale = <span class="built_in">CFLocaleCopyCurrent</span>();</span><br><span class="line"><span class="built_in">NSLocale</span> * myNSLocale = (<span class="built_in">NSLocale</span> *) myCFLocale;</span><br><span class="line">[myNSLocale autorelease];</span><br><span class="line"><span class="built_in">NSString</span> * nsIdentifier = [myNSLocale localeIdentifier];</span><br><span class="line"><span class="built_in">CFShow</span>((<span class="built_in">CFStringRef</span>) [<span class="string">@"nsIdentifier: "</span> stringByAppendingString:nsIdentifier]); <span class="comment">// logs identifier for current locale</span></span><br></pre></td></tr></table></figure><p>在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 retain 和 release 操作规则，所以Toll-Free Bridging 的使用比较简单，但是自从 ARC 加入后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。</p><p>这个时候就必须要考虑一个问题，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership 的改变。</p><blockquote><p>If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined in NSObject.h)</p></blockquote><p>于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。</p><h3 id="5-1-bridge"><a href="#5-1-bridge" class="headerlink" title="5.1 __bridge"></a>5.1 __bridge</h3><blockquote><p>只是声明类型转变，但是不做内存管理规则的转变。</p></blockquote><p>示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> s = (__bridge <span class="built_in">CFStringRef</span>)[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hi, %@!"</span>, name];</span><br></pre></td></tr></table></figure><p>只是 NSString 到 CFStringRef 的类型转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s，不能用CFRelease() 去释放 s。</p><h3 id="5-2-bridge-retained、CFBridgingRetain"><a href="#5-2-bridge-retained、CFBridgingRetain" class="headerlink" title="5.2 __bridge_retained、CFBridgingRetain()"></a>5.2 __bridge_retained、CFBridgingRetain()</h3><blockquote><p>将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给 Core Foundation 来处理，也就是，将 ARC 转变为 MRC。</p></blockquote><p>示例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = [[NSString alloc] initWithFormat:@<span class="string">"Hi, %@!"</span>, name]<span class="comment">;</span></span><br><span class="line">￼CFStringRef <span class="built_in">s2</span> = (__bridge_retained CFStringRef)<span class="built_in">s1</span><span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">￼CFRelease(<span class="built_in">s2</span>)<span class="comment">;  // 注意在使用结束后释放</span></span><br></pre></td></tr></table></figure><p>在第二行做了转化，这时内存管理规则由 ARC 变成了 MRC，需要手动的来管理 s2 的内存，而对于 s1，即使将其置为 nil，也不能释放内存。</p><p>也可以写成：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = [[NSString alloc] initWithFormat:@<span class="string">"Hi, %@!"</span>, name]<span class="comment">;</span></span><br><span class="line">￼CFStringRef <span class="built_in">s2</span> = (CFStringRef)CFBridgingRetain(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">￼CFRelease(<span class="built_in">s2</span>)<span class="comment">;  // 注意在使用结束后释放</span></span><br></pre></td></tr></table></figure><h3 id="5-3-bridge-transfer、CFBridgingRelease"><a href="#5-3-bridge-transfer、CFBridgingRelease" class="headerlink" title="5.3 __bridge_transfer、CFBridgingRelease()"></a>5.3 __bridge_transfer、CFBridgingRelease()</h3><blockquote><p>功能与 __bridge_retained 相反，表示将管理的责任由 Core Foundation 转交给 Objective-C，即将管理方式由MRC 转变为 ARC。</p></blockquote><p>比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> result = <span class="built_in">CFURLCreateStringByAddingPercentEscapes</span>(. . .);</span><br><span class="line">￼<span class="built_in">NSString</span> * s = (__bridge_transfer <span class="built_in">NSString</span> *)result; </span><br><span class="line"><span class="comment">// 或 NSString * s = (NSString *)CFBridgingRelease(result);</span></span><br><span class="line">￼<span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><p>这里将 result 的管理责任交给了 ARC 来处理，就不需要再显式地调用 CFRelease() 了。</p><p>这里和 ARC 中 4 个主要的修饰符 __strong、__weak、__autoreleasing… 不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但最好与官方的相同。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-77a3391ea512ac3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p><h2 id="六、ARC下获取引用计数"><a href="#六、ARC下获取引用计数" class="headerlink" title="六、ARC下获取引用计数"></a>六、ARC下获取引用计数</h2><h3 id="6-1-使用-KVC"><a href="#6-1-使用-KVC" class="headerlink" title="6.1 使用 KVC"></a>6.1 使用 KVC</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">obj</span> valueForKey:@<span class="string">"retainCount"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-使用私有-API"><a href="#6-2-使用私有-API" class="headerlink" title="6.2 使用私有 API"></a>6.2 使用私有 API</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXTERN int _objc_rootRetainCount(<span class="name">id</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">_objc_rootRetainCount(<span class="name">obj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这个不一定完全可信。Xcode 10.1 用的示例一直返回 1。</p><h3 id="6-3-使用-CFGetRetainCount"><a href="#6-3-使用-CFGetRetainCount" class="headerlink" title="6.3 使用 CFGetRetainCount"></a>6.3 使用 CFGetRetainCount</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFGetRetainCount((<span class="name">__bridge</span> CFTypeRef)(<span class="name">obj</span>))</span><br></pre></td></tr></table></figure><p>使用 Toll-Free-Bridging 将 OC 对象的内容管理转为 Core Foundation 对象。</p><h2 id="七、学习文章"><a href="#七、学习文章" class="headerlink" title="七、学习文章"></a>七、学习文章</h2><p><a href="https://www.cnblogs.com/flyFreeZn/p/4264220.html" target="_blank" rel="noopener">iOS 开发ARC内存管理技术要点</a><br><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" title="谈Objective-C block的实现" target="_blank" rel="noopener">谈 Objective-C block的实现</a><br><a href="http://blog.csdn.net/hherima/article/details/38586101" target="_blank" rel="noopener">block 的实现</a><br><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">正确使用 Block 避免Cycle Retain和Crash</a><br><a href="https://blog.csdn.net/geeklee609/article/details/82142337" target="_blank" rel="noopener">ARC 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、ARC&quot;&gt;&lt;a href=&quot;#一、ARC&quot; class=&quot;headerlink&quot; title=&quot;一、ARC&quot;&gt;&lt;/a&gt;一、ARC&lt;/h2&gt;&lt;p&gt;ARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>引用计数</title>
    <link href="http://yoursite.com/2019/05/23/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2019/05/23/引用计数/</id>
    <published>2019-05-23T07:16:48.623Z</published>
    <updated>2019-05-24T08:52:12.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><blockquote><p>OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。</p></blockquote><p>OC 在内存管理上采用了引用计数，它是一个<font color="#cc0000">简单而有效管理对象生命周期的方式</font>。在对象内部保存一个用来表示被引用次数的数字，init、new 和 copy 都会让计数 +1，调用 release 让计数 -1。当计数等于 0 的时候，系统调用 dealloc 方法来销毁对象。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A  * a = [[A alloc] init]<span class="comment">;  // retain count = 1</span></span><br><span class="line">A  * <span class="keyword">b </span>= a<span class="comment">;   // 指针赋值时，retain count 不会自动增加</span></span><br><span class="line">[<span class="keyword">b </span>retain]<span class="comment">;   // retain count = 2</span></span><br></pre></td></tr></table></figure><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    OBJC_EXTERN int _objc_rootRetainCount(<span class="name"><span class="builtin-name">id</span></span>)<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    NSObject * obj = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">    // 创建对象并引用，引用计数为 <span class="number">1</span></span><br><span class="line">    NSLog(@<span class="string">"obj retainCount:%lu"</span>, (<span class="name">unsigned</span> long)_objc_rootRetainCount(<span class="name">obj</span>))<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    NSObject * obj1 = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">    // 创建对象并引用，引用计数为 <span class="number">1</span></span><br><span class="line">    NSLog(@<span class="string">"obj1 retainCount:%lu"</span>, (<span class="name">unsigned</span> long)_objc_rootRetainCount(<span class="name">obj1</span>))<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    // obj 指向了 obj1 所指的对象 B，失去了对原来对象A的引用,所以对象A的引用计数<span class="number">-1</span>，为 <span class="number">0</span>。A 被销毁</span><br><span class="line">    // 对于 B，obj 引用了它，所以引用计数 <span class="number">+1</span>，为 <span class="number">2</span></span><br><span class="line">    obj = obj1;</span><br><span class="line">    // self.obj 又引用了 A,所以引用计数 <span class="number">+1</span>，为 <span class="number">3</span></span><br><span class="line">    self.obj = obj;</span><br><span class="line">    NSLog(@<span class="string">"strong obj1 retainCount:%lu"</span>,(<span class="name">unsigned</span> long)_objc_rootRetainCount(<span class="name">obj1</span>))<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"strong obj retainCount:%lu"</span>,(<span class="name">unsigned</span> long)_objc_rootRetainCount(<span class="name">obj</span>))<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用计数分为自动引用计数「ARC :  Automatic Reference Counting」和手动引用计数「MRC : Manual Reference Counting」。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8a6895639c25af4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * obj1 = [<span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数: %lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount]);</span><br><span class="line"><span class="built_in">NSObject</span> * obj2 = [obj1 <span class="keyword">retain</span>];</span><br><span class="line"><span class="built_in">NSObject</span> * obj3 = [obj1 <span class="keyword">retain</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数: %lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount]);</span><br><span class="line">[obj1 release];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数: %lu %@"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount], obj1);</span><br><span class="line">[obj1 release];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数: %lu %@"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount], obj1);</span><br><span class="line">[obj1 release];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"引用计数: %lu %@"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)[obj1 retainCount], obj1);</span><br><span class="line"></span><br><span class="line">引用计数：<span class="number">1</span></span><br><span class="line">引用计数：<span class="number">3</span></span><br><span class="line">引用计数：<span class="number">2</span> &lt;<span class="built_in">NSObject</span>：<span class="number">0x60400001ecd0</span>&gt;</span><br><span class="line">引用计数：<span class="number">1</span> &lt;<span class="built_in">NSObject</span>：<span class="number">0x60400001ecd0</span>&gt;</span><br><span class="line">*** -[<span class="built_in">NSObject</span> retainCount]: message sent to deallocated instance <span class="number">0x60400001ecd0</span></span><br></pre></td></tr></table></figure><p>根据 Debug 输出可以看到：obj1 可以调用多次 release 方法。</p><p>从两次打印 obj1 的地址相同可以猜测，在 [obj1 release] 执行之后对象的引用计数 -1，不再强引用对象，但 obj1 仍然指向对象所在的那片内存空间。在第三次执行 release 后，对象的引用计数为 0，对象所在的内存空间被销毁，但是 obj1 指针仍然存在，此时调用 retainCount 会报野指针错误。可以通过置 obj1 = nil 解决这个问题。</p><p>对 Linux 文件系统比较了解的可能发现，引用计数的这种管理方式类似于文件系统里面的<strong>硬链接</strong>。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于 retain），当删除一个文件时（相当于 release），系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。</p><h2 id="四、僵尸对象、野指针、空指针"><a href="#四、僵尸对象、野指针、空指针" class="headerlink" title="四、僵尸对象、野指针、空指针"></a>四、僵尸对象、野指针、空指针</h2><p>僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用。</p><blockquote><p>野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC_BAD_ACCESS）。</p><p>空指针：没有指向任何对象的指针（存储的是 nil、NULL），给空指针发送消息不会报错；空指针的一个经典使用场景就是在开发中获取服务器 API 数据时，转换野指针为空指针，避免发送消息报错。</p></blockquote><h2 id="五、为什么需要引用计数？"><a href="#五、为什么需要引用计数？" class="headerlink" title="五、为什么需要引用计数？"></a>五、为什么需要引用计数？</h2><p>引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于<font color="#cc0000">对象之间传递和共享数据</font>。</p><p>举个例子：</p><p>对象 A 生成了一个对象 O，需要调用对象 B 的某个方法，并将对象 O 作为参数传递过去。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[objB doSomething:O]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在没有引用计数的情况下，一般内存管理的原则是「谁申请谁释放」。</p><p>那么对象 A 就需要在对象 B 不再需要 O 的时候，将 O 销毁。但对象 B 可能临时用一下 O，也可能将它设置为自己的一个成员变量，在这种情况下，什么时候销毁就成了一个难题了。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ed988afe64d00f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"> </p><p>对于以上情况有两种做法：</p><p>①、对象 A 在调用完对象 B 的某个方法之后，马上销毁参数 O；然后对象 B 需要将对象 O 复制一份，生成另一个对象 O2，同时自己来管理对象 O2 的生命周期。</p><p>这种做法带来更多的内存申请、复制、释放的工作。本来可以复用的对象，因为不方便管理它的生命周期，就简单地把它销毁，又重新构造一份一样的，实在太影响性能。</p><p>②、对象 A 只负责生成 O，之后就由对象 B 负责完成 O 的销毁工作。如果对象 B 只是临时用一下 O，就可以用完后马上销毁；如果对象 B 需要长时间使用 O，就不销毁它。</p><p>这种做法看似解决了对象复制的问题，但是它强烈依赖于 A 和 B 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于 O 的生成和释放在不同对象中，使得它的内存管理代码分散在不同对象中，管理起来也很费劲。如果这个时候情况更加复杂一些，例如对象 B 需要再向对象 C 传递参数 O，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方法带来的复杂度更高，更加不可取。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-15dc0b70f8c7558f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"> </p><p>引用计数的出现很好地解决这个问题，在参数 O 的传递过程中，哪些对象需要长时间使用它，就把它的引用计数 +1，使用完就-1。所有对象遵守这个规则，对象的生命周期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。</p><h2 id="六、ARC-下的内存管理问题"><a href="#六、ARC-下的内存管理问题" class="headerlink" title="六、ARC 下的内存管理问题"></a>六、ARC 下的内存管理问题</h2><p>问题主要体现在：</p><ol><li>过度使用 block 之后，无法解决循环引用问题。</li><li>遇到底层 Core Foundation 对象，需要手工管理它们的引用计数时，显得一筹莫展。</li></ol><h3 id="6-1-循环引用"><a href="#6-1-循环引用" class="headerlink" title="6.1 循环引用"></a>6.1 循环引用</h3><p>引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁又依赖于对象 A 的销毁，这样就造成了循环引用 Reference Cycle 的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-9bf50b90b4ebb81c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"></p><p>不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，<font color="#cc0000">环越大就越难被发现</font>。下图是 4 个对象形成的循环引用问题。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c679f014ddb0842b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"></p><h3 id="6-2-主动断开循环引用"><a href="#6-2-主动断开循环引用" class="headerlink" title="6.2 主动断开循环引用"></a>6.2 主动断开循环引用</h3><p>解决循环引用问题主要有两个办法。第一个办法：明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c6f3631df5d44320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"></p><p>主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。</p><p>不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存，所以这种解决方法并不常用，更常见的办法是使用弱引用的办法。</p><h3 id="6-3-使用弱引用"><a href="#6-3-使用弱引用" class="headerlink" title="6.3 使用弱引用"></a>6.3 使用弱引用</h3><p>弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-d7832da14f2870e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"></p><h3 id="6-4-弱引用的实现原理"><a href="#6-4-弱引用的实现原理" class="headerlink" title="6.4 弱引用的实现原理"></a>6.4 弱引用的实现原理</h3><p>弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。</p><p>从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为：</p><p>①、在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。</p><p>②、大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。</p><p>③、早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见<a href="http://blog.devtang.com/2013/05/18/goodbye-viewdidunload/" target="_blank" rel="noopener">《再见，viewDidUnload方法》</a>。</p><h3 id="6-5-检测循环引用"><a href="#6-5-检测循环引用" class="headerlink" title="6.5 检测循环引用"></a>6.5 检测循环引用</h3><p><img src="https://upload-images.jianshu.io/upload_images/5294842-6d266d7ad597be42.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="å¼ç¨è®¡æ°"></p><h3 id="七、学习文章"><a href="#七、学习文章" class="headerlink" title="七、学习文章"></a>七、学习文章</h3><p><a href="https://www.cnblogs.com/huangjianwu/p/4962772.html" target="_blank" rel="noopener">iOS 内存管理</a><br><a href="https://cloud.tencent.com/developer/article/1127761" target="_blank" rel="noopener">iOS 的内存管理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>weak</title>
    <link href="http://yoursite.com/2019/05/23/weak/"/>
    <id>http://yoursite.com/2019/05/23/weak/</id>
    <published>2019-05-23T06:43:21.310Z</published>
    <updated>2019-05-24T08:54:16.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候<font color="#cc0000">自动被设置为 nil</font>，大大避免了野指针访问坏内存引起崩溃的情况，另外 weak 还可以用于解决循环引用。</p><h2 id="二、原理概括"><a href="#二、原理概括" class="headerlink" title="二、原理概括"></a>二、原理概括</h2><blockquote><p>weak 表其实是一个 hash（哈希）表。</p><p>key：所引用对象的地址；value：weak 指针的地址数组（这个地址的值是指向对象的指针的地址）。</p></blockquote><p>weak 的底层实现的原理是什么？</p><blockquote><p>runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。<font color="#cc0000">weak 表是由单个自旋锁管理的散列表</font>。 </p></blockquote><p>为什么 value 是数组？</p><blockquote><p>因为一个对象可能被多个弱引用指针指向。</p></blockquote><h2 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h2><p>weak 的实现原理可概括三步：</p><p>①、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c6a57d0e28dea17a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak"></p><p>②、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ef6cd0f22373bbef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak"></p><p>③、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</p><h2 id="四、详细过程"><a href="#四、详细过程" class="headerlink" title="四、详细过程"></a>四、详细过程</h2><p>1、初始化时：runtime 会调用 objc_initWeak 函数，objc_initWeak 函数会初始化一个新的 weak 指针指向对象的地址。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br></pre></td></tr></table></figure><p>当初始化一个 weak 变量时，runtime 会调用 NSObject.mm 中的 objc_initWeak 函数。</p><p>这个函数在 Clang 中的声明如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> objc_initWeak(<span class="built_in">id</span> *object, <span class="built_in">id</span> value);</span><br></pre></td></tr></table></figure><p>而对于 objc_initWeak() 方法的实现如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">id objc_initWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 查看对象实例是否有效，无效对象直接导致指针释放</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">          *location = nil;</span><br><span class="line">          <span class="keyword">return</span> nil;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 这里传递了三个 bool 数值</span></span><br><span class="line">     <span class="comment">// 使用 template 进行常量参数传递是为了优化性能</span></span><br><span class="line">     <span class="keyword">return</span> storeWeakfalse<span class="comment">/*old*/</span>, <span class="literal">true</span><span class="comment">/*new*/</span>, <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;(location, (objc_object*)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断了其指针指向的类对象是否有效，无效直接释放返回，不再往深层调用函数。否则 object 将被注册为一个指向 value 的 __weak 对象，而这事应该是 objc_storeWeak 函数干的。可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断）。</p><p>注意：objc_initWeak 函数有一个前提条件：就是 object 必须是一个没有被注册为 __weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。</p><p>2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。</p><p>objc_storeWeak() 的函数声明如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> objc_storeWeak(<span class="built_in">id</span> *location, <span class="built_in">id</span> value);</span><br></pre></td></tr></table></figure><p>objc_storeWeak() 的具体实现如下，请参考 <a href="https://link.jianshu.com/?t=http://ios.jobbole.com/89012/" target="_blank" rel="noopener">weak弱引用实现的方式</a>。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HaveOld:     true - 变量有值</span></span><br><span class="line"><span class="comment">//             false - 需要被及时清理，当前值可能为 nil</span></span><br><span class="line"><span class="comment">// HaveNew:     true - 需要被分配的新值，当前值可能为 nil</span></span><br><span class="line"><span class="comment">//             false - 不需要分配新值</span></span><br><span class="line"><span class="comment">// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停</span></span><br><span class="line"><span class="comment">//             false - 用 nil 替代存储</span></span><br><span class="line">template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> id storeWeak(id *location, objc_object *<span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">     <span class="comment">// 该过程用来更新弱引用指针的指向</span></span><br><span class="line">     <span class="comment">// 初始化 previouslyInitializedClass 指针</span></span><br><span class="line">     Class previouslyInitializedClass = nil;</span><br><span class="line">     id oldObj;</span><br><span class="line">     <span class="comment">// 声明两个 SideTable</span></span><br><span class="line">     <span class="comment">// ①、创建新旧散列</span></span><br><span class="line">     SideTable *oldTable;</span><br><span class="line">     SideTable *<span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">     <span class="comment">// 获得新值和旧值的锁存位置（用地址作为唯一标示）</span></span><br><span class="line">     <span class="comment">// 通过地址来建立索引标志，防止桶重复</span></span><br><span class="line">     <span class="comment">// 下面指向的操作会改变旧值</span></span><br><span class="line">retry:<span class="type"></span></span><br><span class="line"><span class="type">     if </span>(HaveOld) &#123;</span><br><span class="line">          <span class="comment">// 如果 HaveOld 为 true，更改指针，获得以 oldObj 为索引所存储的值地址</span></span><br><span class="line">          oldObj = *location;</span><br><span class="line">          oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          oldTable = nil;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">          <span class="comment">// 更改新值指针，获得以 newObj 为索引所存储的值地址</span></span><br><span class="line">          <span class="keyword">new</span><span class="type">Table</span> = &amp;SideTables()[<span class="keyword">new</span><span class="type">Obj</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Table</span> = nil;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 加锁操作，防止多线程中竞争冲突</span></span><br><span class="line">     SideTable:<span class="type"></span>:lockTwoHaveOld, HaveNew&gt;(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 避免线程冲突重处理</span></span><br><span class="line">     <span class="comment">// location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span></span><br><span class="line">     <span class="keyword">if</span> (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">          SideTable:<span class="type"></span>:unlockTwoHaveOld, HaveNew&gt;(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">          goto retry;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 防止弱引用间死锁</span></span><br><span class="line">     <span class="comment">// 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向</span></span><br><span class="line">     <span class="keyword">if</span> (HaveNew  &amp;&amp;  <span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">          <span class="comment">// 获得新对象的 isa 指针</span></span><br><span class="line">          Class cls = <span class="keyword">new</span><span class="type">Obj</span>-&gt;getIsa();</span><br><span class="line">          <span class="comment">// 判断 isa 非空且已经初始化</span></span><br><span class="line">          <span class="keyword">if</span> (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">               <span class="comment">// 解锁</span></span><br><span class="line">               SideTable:<span class="type"></span>:unlockTwoHaveOld, HaveNew&gt;(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">               <span class="comment">// 对其 isa 指针进行初始化</span></span><br><span class="line">               _class_initialize(_class_getNonMetaClass(cls, (id)<span class="keyword">new</span><span class="type">Obj</span>));</span><br><span class="line">               <span class="comment">// 如果该类已经完成执行 +initialize 方法是最理想情况</span></span><br><span class="line">               <span class="comment">// 如果该类 +initialize 在线程中</span></span><br><span class="line">               <span class="comment">// 例如 +initialize 正在调用 storeWeak 方法</span></span><br><span class="line">               <span class="comment">// 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记</span></span><br><span class="line">               previouslyInitializedClass = cls;</span><br><span class="line">               <span class="comment">// 重新尝试</span></span><br><span class="line">               goto retry;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ② 清除旧值</span></span><br><span class="line">     <span class="keyword">if</span> (HaveOld) &#123;</span><br><span class="line">          weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ③ 分配新值</span></span><br><span class="line">     <span class="keyword">if</span> (HaveNew) &#123;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Obj</span> = (objc_object *)weak_register_no_lock(&amp;<span class="keyword">new</span><span class="type">Table</span>-&gt;weak_table, (id)<span class="keyword">new</span><span class="type">Obj</span>, location, CrashIfDeallocating);</span><br><span class="line">          <span class="comment">// 如果弱引用被释放 weak_register_no_lock 方法返回 nil</span></span><br><span class="line">          <span class="comment">// 在引用计数表中设置若引用标记位</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Obj</span>  &amp;&amp;  !<span class="keyword">new</span><span class="type">Obj</span>-&gt;isTaggedPointer()) &#123;</span><br><span class="line">               <span class="comment">// 弱引用位初始化操作</span></span><br><span class="line">               <span class="comment">// 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用</span></span><br><span class="line">               <span class="keyword">new</span><span class="type">Obj</span>-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 之前不要设置 location 对象，这里需要更改指针指向</span></span><br><span class="line">          *location = (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 没有新值，则无需更改</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     SideTable:<span class="type"></span>:unlockTwoHaveOld, HaveNew&gt;(oldTable, <span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撇开源码中各种锁操作，来看看这段代码都做了些什么。</p><p>①、SideTable</p><p>SideTable 这个结构体，我给它起名引用计数和弱引用依赖表，因为它主要<font color="#cc0000">用于管理对象的引用计数和 weak 表</font>。使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable。实例在 NSObject.mm 中声明其数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">     <span class="comment">// 保证原子操作的自旋锁</span></span><br><span class="line">     <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">     <span class="comment">// 引用计数的 hash 表</span></span><br><span class="line">     RefcountMap refcnts;</span><br><span class="line">     <span class="comment">// weak 引用全局 hash 表</span></span><br><span class="line">     <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slock 是为了防止竞争选择的自旋锁，用来保证线程安全；</p><p>refcnts 是协助对象的 isa 指针的 extra_rc 共同引用计数的变量，每个对象的引用计数保存在<font color="#cc0000">全局的引用计数表</font>中，一个对象地址对应一个引用计数；</p><p>weak_table 就是接下来要讲的 weak 表，所有的 weak 变量会被加入到全局的 weak 表中，表的 key 是 weak 修饰的变量指向的对象， value 值就是 weak 修饰的变量。这里主要看 weak 全局 hash 表的结构与作用。</p><p>②、weak 表</p><p>weak 表是一个弱引用表，实现为一个 weak_table_t 结构体，存储了某个对象相关的所有的弱引用信息。其定义如下（具体定义在 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="noopener">objc-weak.h</a> 中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">     <span class="comment">// 保存了所有指向指定对象的 weak 指针</span></span><br><span class="line">     <span class="keyword">weak_entry_t</span> * weak_entries;</span><br><span class="line">     <span class="comment">// 存储空间，即 entries 的数目</span></span><br><span class="line">     <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">     <span class="comment">// 参与判断引用计数辅助量</span></span><br><span class="line">     <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">     <span class="comment">// hash key 最大偏移值</span></span><br><span class="line">     <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个全局弱引用 hash 表，它的作用就是在<font color="#cc0000">对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil</font>，避免悬空指针。使用不定类型对象的地址的 hash 化后的数值作为 key，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。</p><p>weak_entry_t 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> objc_object ** <span class="keyword">weak_referrer_t</span>;</span><br><span class="line"><span class="comment">// 存储在弱引用表中的一个内部结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">     DisguisedPtr&lt;objc_object&gt; referent;   <span class="comment">// 封装 objc_object 指针，即 weak 修饰的变量指向的对象</span></span><br><span class="line">     <span class="keyword">union</span> &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">               <span class="keyword">weak_referrer_t</span> *referrers; </span><br><span class="line">               <span class="keyword">uintptr_t</span>        out_of_line : <span class="number">1</span>;  <span class="comment">// LSB 最低有效元。当标志位为0时，增加引用表指针纬度，当其为0的时候， weak_referrer_t 成员将扩展为静态数组型的 hash table</span></span><br><span class="line">               <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_1; <span class="comment">// 引用数值，这里记录弱引用表中引用有效数字，即里面元素的数量</span></span><br><span class="line">               <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">               <span class="keyword">uintptr_t</span>        max_hash_displacement;  <span class="comment">// hash 元素上限阀值</span></span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">               <span class="comment">// out_of_line=0 is LSB of one of these (don't care which)</span></span><br><span class="line">               <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">          &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题，其内容可以理解为<font color="#cc0000">对象的内存地址</font>。</p><p>从注释中写 out_of_line 成员为最低有效位，当其为 0 的时候， weak_referrer_t 成员将扩展为一个静态数组型的 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。</p><p>那么在有效位未生效的时候，out_of_line、num_refs、mask、max_hash_displacement 有什么作用？以下是笔者自身的猜测：</p><p>out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。</p><p>num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。</p><p>mask：计数辅助量。</p><p>max_hash_displacement：hash 元素上限阀值。</p><p>其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT。</p><p>每个对象的 SideTable 中的 weak_table_t 都是全局 weak 表的入口，以引用计数对象为键找到其所记录的 weak 修饰的对象。</p><p>weak_entry_t 中的 referrers 有两种形式：当 out_of_line 为 0 的时候，referrers 是一个静态数组型的表，数组大小默认为 WEAK_INLINE_COUNT 大小；当 out_of_line 不为 0 的时候，referrers 是一个动态数组，内容随之增加。</p><p>StripedMap[] 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ee1ed03f1b1fa58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak"> </p><p>③、旧对象解除注册操作 weak_unregister_no_lock</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, </span><br><span class="line">                        id *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">empty</span> = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">empty</span> = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    <span class="keyword">empty</span> = <span class="keyword">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。</p><p>来看看这个函数的逻辑：</p><p>首先参数是 weak_table_t 表、键和值。声明 weak_entry_t 变量，如果 key，也就是引用计数对象为空，直接返回。根据全局入口表和键获取对应的 weak_entry_t 对象，也就是 weak 表记录。获取到记录后，将记录表以及 weak 对象作为参数传入 remove_referrer 函数中，这个函数就是解除操作。然后判断这个 weak 记录是否为空，如果为空，从全局记录表中清除相应的引用计数对象的 weak 记录表。</p><p>从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。</p><p>再来了解一下解除对象的函数：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (! entry-&gt;</span>out_of_line) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = <span class="literal">nil</span>;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                     <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                     <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                     <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                     old_referrer);</span><br><span class="line">        objc_weak_error();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = w_hash_pointer(old_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != old_referrer) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"Attempted to unregister unknown __weak variable "</span></span><br><span class="line">                         <span class="string">"at %p. This is probably incorrect use of "</span></span><br><span class="line">                         <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                         <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                         old_referrer);</span><br><span class="line">            objc_weak_error();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>referrers[index] = <span class="literal">nil</span>;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>num_refs--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数传入的是 weak 对象，当 out_of_line 为 0 时，遍历数组，找到对应的对象，置 nil，如果未找到，报错并返回。当 out_of_line 不为 0 时，根据对象的地址 hash 化并和 mask 做与操作作为下标，查找相应的对象，若没有，报错并返回，若有，相应的置为 nil，并减少元素数量，即 num_refs 减 1。</p><p>④、新对象添加注册操作 weak_register_no_lock</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">id weak<span class="number">_</span>register<span class="number">_n</span>o<span class="number">_</span>lock(weak<span class="number">_</span>table<span class="number">_</span>t *weak<span class="number">_</span>table, id referent<span class="number">_</span>id, </span><br><span class="line">                      id *referrer<span class="number">_</span>id, bool crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> *referent = (objc<span class="number">_</span><span class="keyword">object</span> *)referent<span class="number">_</span>id;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> **referrer = (objc<span class="number">_</span><span class="keyword">object</span> **)referrer<span class="number">_</span>id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent<span class="number">_</span>id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    bool deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        BOOL (*allowsWeakReference)(objc<span class="number">_</span><span class="keyword">object</span> *, SEL) = </span><br><span class="line">            (BOOL(*)(objc<span class="number">_</span><span class="keyword">object</span> *, SEL))</span><br><span class="line">            <span class="keyword">object</span><span class="number">_</span>getMethodImplementation((id)referent, </span><br><span class="line">                                           SEL<span class="number">_</span>allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == <span class="number">_</span>objc<span class="number">_m</span>sgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL<span class="number">_</span>allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            <span class="number">_</span>objc<span class="number">_f</span>atal(<span class="string">"Cannot form weak reference to instance (%p) of "</span></span><br><span class="line">                        <span class="string">"class %s. It is possible that this object was "</span></span><br><span class="line">                        <span class="string">"over-released, or is in the process of deallocation."</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, <span class="keyword">object</span><span class="number">_</span>getClassName((id)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak<span class="number">_</span>entry<span class="number">_</span>t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak<span class="number">_</span>entry<span class="number">_f</span>or<span class="number">_</span>referent(weak<span class="number">_</span>table, referent))) &#123;</span><br><span class="line">        append<span class="number">_</span>referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>t <span class="keyword">new</span><span class="number">_</span>entry;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.referent = referent;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.<span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>line = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[<span class="number">0</span>] = referrer;</span><br><span class="line">        <span class="keyword">for</span> (size<span class="number">_</span>t i = <span class="number">1</span>; i &lt; WEAK<span class="number">_</span>INLINE<span class="number">_</span>COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weak<span class="number">_</span>grow<span class="number">_m</span>aybe(weak<span class="number">_</span>table);</span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>insert(weak<span class="number">_</span>table, &amp;<span class="keyword">new</span><span class="number">_</span>entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent<span class="number">_</span>id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步与上一步相反，通过 weak_register_no_lock 函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。</p><p>一大堆 if-else 主要是为了判断该对象是不是 taggedPoint 以及是否正在调用 dealloc 等。下面操作开始，同样是先获取 weak 表记录，如果获取到，则调用 append_referrer 插入对象，若没有，则新建一个 weak 表记录，默认为 out_of_line，然后将新对象放到 0 下标位置，其他位置置为 nil 。下面两个函数 weak_grow_maybe 是用来判断是否需要重申请内存重 hash，weak_entry_insert 函数是用来将新建的 weak 表记录插入到全局 weak 表中。插入时同样是以对象地址的 hash 化和 mask 值相与作为下标来记录的。</p><p>接下来看看 append_referrer 函数，源代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (! entry-&gt;</span>out_of_line) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>out_of_line = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">assert</span>(entry-&gt;</span>out_of_line);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⑤、初始化弱引用对象流程一览</p><p>弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图：</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-c6a57d0e28dea17a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weak"> </p><p>这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然，storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。</p><p>3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。</p><p>当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？当释放对象时，其基本流程如下：</p><p>①、调用 objc_release<br>②、因为对象的引用计数为 0，所以执行 dealloc<br>③、在 dealloc 中，调用了_objc_rootDealloc 函数<br>④、在 _objc_rootDealloc 中，调用了 object_dispose 函数<br>⑤、调用 objc_destructInstance<br>⑥、最后调用 objc_clear_deallocating，详细过程如下：<br>    a. 从 weak 表中获取废弃对象的地址为键值的记录<br>    b. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nil<br>    c. 将 weak 表中该记录删除<br>    d. 从引用计数表中删除废弃对象的地址为键值的记录</p><p>重点看对象被释放时调用的 objc_clear_deallocating 函数。该函数实现如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  objc_clear_deallocating(id obj) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">assert</span>(obj);</span><br><span class="line">     <span class="keyword">assert</span>(!UseGC);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">     obj-&gt;clearDeallocating();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数只是做一些判断以及更深层次的函数调用。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void objc_object::sidetable_clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; <span class="keyword">table</span> = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear any weak table items</span></span><br><span class="line">    <span class="comment">// clear extra retain count and deallocating bit</span></span><br><span class="line">    <span class="comment">// (fixme warn or abort if extra retain count == 0 ?)</span></span><br><span class="line">    <span class="keyword">table</span>.lock();</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    RefcountMap::iterator it = <span class="keyword">table</span>.refcnts.find(this);</span><br><span class="line">    if (it != <span class="keyword">table</span>.refcnts.end()) &#123;</span><br><span class="line">        if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123;</span><br><span class="line">            weak_clear_no_lock(&amp;<span class="keyword">table</span>.weak_table, (id)this);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">table</span>.refcnts.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是调用了 clearDeallocating()，继续追踪可以发现，它最终是使用了迭代器来取 weak 表的 value，然后调用 weak_clear_no_lock，然后查找对应的 value，将该 weak 指针置空，weak_clear_no_lock 函数的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the</span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table</span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">          <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">          <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// zero out references</span></span><br><span class="line">     <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">     <span class="keyword">size_t</span> count;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (entry-&gt;out_of_line) &#123;</span><br><span class="line">          referrers = entry-&gt;referrers;</span><br><span class="line">          count = TABLE_SIZE(entry);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          referrers = entry-&gt;inline_referrers;</span><br><span class="line">          count = WEAK_INLINE_COUNT;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">          objc_object **referrer = referrers[i];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">               <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                    *referrer = nil;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                                 <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                                 <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                                 <span class="string">"Break on objc_weak_error to debug.\n"</span>, referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line"></span><br><span class="line">                    objc_weak_error();</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说，这个方法首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组，把每个地址存储的数据设为 nil ，最后把这个 key-value entry 从 weak 表中删除。</p><p>注意：</p><p>①、从实现中可以看出，weak 指针的使用涉及到 hash 表的增删改查，存在一定的性能开销。<br>②、使用 weak 指针的时候，应首先获取一个 Strong 指针再使用。倒不是为了防止在使用过程中对象被回收，形成野指针。这个不用担心，因为你使用了 weak 指针，对象就会被加入到 autoreleasepool 中，可以放心使用。但是要注意的是，如果在一个代码块中频繁使用 weak 指针，还是应首先获取一个 Strong 指针，否则这个对象会被一次又一次的加入 autoreleasepool 中，也存在一定的性能开销。</p><h2 id="五、拓展补充"><a href="#五、拓展补充" class="headerlink" title="五、拓展补充"></a>五、拓展补充</h2><p>weak、__unsafe_unretained、unowned 与 assign 区别</p><ul><li>__unsafe_unretained：不会对对象进行 retain，当对象销毁时，会依然指向之前的内存空间（野指针）</li><li>weak：不会对对象进行 retain，当对象销毁时，会自动置为 nil</li></ul><p>__unsafe_unretained 可以修饰代表基础数据类型的 property，weak 不能修饰基础数据类型的 property。</p><p>使用 weak 是有代价的，因为通过上面的原理可知，__weak 需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况，因此 __unsafe_unretained 比 __weak 快。所以当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，__unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。</p><ul><li>unowned 使用在 Swift 中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。</li></ul><p>假如很明确的知道对象的生命期，也可以选择 unowned。</p><ul><li>assign：实质与 __unsafe_unretained 等同</li></ul><p>通过上面的描述，我们基本能了解一个 weak 引用从生到死的过程。从这个流程可以看出，一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 __weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 __weak 修饰符。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章 "></a>六、学习文章 </h2><p><a href="https://link.jianshu.com/?t=http://ios.jobbole.com/89012/" target="_blank" rel="noopener">weak 弱引用的实现方式</a><br><a href="https://link.jianshu.com/?t=http://www.cocoachina.com/ios/20170328/18962.html" target="_blank" rel="noopener">iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）</a><br><a href="http://www.jianshu.com/p/3c5e335341e0" target="_blank" rel="noopener">iOS weak 的底层实现</a><br><a href="http://www.cocoachina.com/ios/20150605/11990.html" target="_blank" rel="noopener">weak 的生命周期：具体实现方法</a><br><a href="https://blog.csdn.net/i_am_what_i_am/article/details/80024957" target="_blank" rel="noopener">iOS 中 weak 的实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基本用法&quot;&gt;&lt;a href=&quot;#一、基本用法&quot; class=&quot;headerlink&quot; title=&quot;一、基本用法&quot;&gt;&lt;/a&gt;一、基本用法&lt;/h2&gt;&lt;p&gt;weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候&lt;fon
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2019/05/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/05/22/深拷贝和浅拷贝/</id>
    <published>2019-05-22T10:52:52.721Z</published>
    <updated>2019-05-24T08:51:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>深拷贝和浅拷贝的<font color="#cc0000">本质区别是地址是否相同</font>。</p><ul><li>浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址；</li><li>深拷贝是真正的复制了一份，复制的对象指向了新的地址。</li></ul><h2 id="一、非容器类对象"><a href="#一、非容器类对象" class="headerlink" title="一、非容器类对象"></a>一、非容器类对象</h2><p>对象的 copy 是浅拷贝，mutableCopy 是深拷贝。</p><p>1、不可变</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = @<span class="string">"AAA"</span><span class="comment">;</span></span><br><span class="line">NSString * <span class="built_in">s2</span> = [<span class="built_in">s1</span> copy]<span class="comment">;</span></span><br><span class="line">NSString * <span class="built_in">s3</span> = [<span class="built_in">s1</span> mutableCopy]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s1</span>, <span class="built_in">s1</span>.class)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s2</span>, <span class="built_in">s2</span>.class)<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"%p   %@"</span>, <span class="built_in">s3</span>, <span class="built_in">s3</span>.class)<span class="comment">;</span></span><br><span class="line"><span class="number">0x1083a40e8</span>   __NSCFConstantString</span><br><span class="line"><span class="number">0x1083a40e8</span>   __NSCFConstantString</span><br><span class="line"><span class="number">0x60400044f840</span>   __NSCFString</span><br></pre></td></tr></table></figure><p>结论：</p><p>①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝；</p><p>②、浅拷贝返回不可变对象，深拷贝返回可变对象。</p><p>2、可变</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> * ms1 = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSMutableString</span> * ms2 = [ms1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSString</span> * ms3 = [ms1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms1, ms1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms2, ms2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, ms3, ms3.class);</span><br><span class="line"><span class="number">0x6040004500b0</span>   __NSCFString</span><br><span class="line"><span class="number">0xa000000000000311</span>   <span class="built_in">NSTaggedPointerString</span></span><br><span class="line"><span class="number">0x60400044fc60</span>   __NSCFString</span><br></pre></td></tr></table></figure><p>结论：</p><p>①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝；</p><p>②、copy 和 mutableCopy 返回对象都为可变对象。</p><h2 id="二、容器对象"><a href="#二、容器对象" class="headerlink" title="二、容器对象"></a>二、容器对象</h2><p>1、不可变</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSMutableString</span> * ms = [<span class="symbol">NSMutableString</span> stringWithString:@<span class="string">"1"</span>];</span><br><span class="line"><span class="symbol">NSArray</span> * arr1 = [<span class="symbol">NSArray</span> arrayWithObjects:ms, @<span class="string">"2"</span>, nil];</span><br><span class="line"><span class="symbol">NSArray</span> * arr2 = [arr1 copy];</span><br><span class="line"><span class="symbol">NSArray</span> * arr3 = [arr1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr1, arr1.class, arr1[<span class="number">0</span>], [arr1[<span class="number">0</span>] class], arr1[<span class="number">1</span>], [arr1[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr2, arr2.class, arr2[<span class="number">0</span>], [arr2[<span class="number">0</span>] class], arr2[<span class="number">1</span>], [arr2[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, arr3, arr3.class, arr3[<span class="number">0</span>], [arr3[<span class="number">0</span>] class], arr3[<span class="number">1</span>], [arr3[<span class="number">1</span>] class]);</span><br><span class="line">    </span><br><span class="line"><span class="number">0x600000037620</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x600000037620</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x60000025a940</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br></pre></td></tr></table></figure><p>结论：</p><p>①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝；</p><p>②、浅拷贝返回不可变对象，深拷贝返回可变对象。</p><p>③、容器内的元素始终都是浅拷贝。</p><p>2、可变</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">NSMutableString</span> * ms = [<span class="symbol">NSMutableString</span> stringWithString:@<span class="string">"1"</span>];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr1 = [<span class="symbol">NSMutableArray</span> arrayWithObjects:ms, @<span class="string">"2"</span>, nil];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr2 = [mArr1 copy];</span><br><span class="line"><span class="symbol">NSMutableArray</span> * mArr3 = [mArr1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr1, mArr1.class, mArr1[<span class="number">0</span>], [mArr1[<span class="number">0</span>] class], mArr1[<span class="number">1</span>], [mArr1[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr2, mArr2.class, mArr2[<span class="number">0</span>], [mArr2[<span class="number">0</span>] class], mArr2[<span class="number">1</span>], [mArr2[<span class="number">1</span>] class]);</span><br><span class="line"><span class="symbol">NSLog</span>(@<span class="string">"%p  %@  %p  %@  %p  %@"</span>, mArr3, mArr3.class, mArr3[<span class="number">0</span>], [mArr3[<span class="number">0</span>] class], mArr3[<span class="number">1</span>], [mArr3[<span class="number">1</span>] class]);</span><br><span class="line"><span class="number">0x60000025aeb0</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x600000037640</span>  <span class="symbol">__NSArrayI</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br><span class="line"><span class="number">0x60000025ae80</span>  <span class="symbol">__NSArrayM</span>  <span class="number">0x60000025ab80</span>  <span class="symbol">__NSCFString</span>  <span class="number">0x1032b2148</span>  <span class="symbol">__NSCFConstantString</span></span><br></pre></td></tr></table></figure><p>结论：</p><p>①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；<br>②、copy 返回不可变对象，mutableCopy 返回可变对象；<br>③、容器内的元素始终是浅拷贝。</p><h2 id="三、自定义类对象的深浅拷贝"><a href="#三、自定义类对象的深浅拷贝" class="headerlink" title="三、自定义类对象的深浅拷贝"></a>三、自定义类对象的深浅拷贝</h2><p>自定义的类需要遵循 <nscopying> 才支持 copy，遵循 <nsmutablecopying> 支持 mutableCopy。</nsmutablecopying></nscopying></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  [Person allocWithZone:zone];   <span class="comment">// return self;</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span>  [Person allocWithZone:zone];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">Person * p1 = [[Person alloc] init];</span><br><span class="line">Person * p2 = [p1 <span class="keyword">copy</span>];</span><br><span class="line">Person * p3 = [p1 mutableCopy];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p1, p1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p2, p2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p   %@"</span>, p3, p3.class);</span><br><span class="line"><span class="number">0x600000011e30</span>   Person</span><br><span class="line"><span class="number">0x600000011f70</span>   Person</span><br><span class="line"><span class="number">0x600000011f90</span>   Person</span><br></pre></td></tr></table></figure><h2 id="四、实现容器对象的完全拷贝"><a href="#四、实现容器对象的完全拷贝" class="headerlink" title="四、实现容器对象的完全拷贝"></a>四、实现容器对象的完全拷贝</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> * ms = [<span class="built_in">NSMutableString</span> stringWithFormat:<span class="string">@"1"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> * arr = [<span class="built_in">NSArray</span> arrayWithObjects:ms, <span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">NSMutableArray</span> * mArr = [[<span class="built_in">NSMutableArray</span> alloc] initWithArray:arr copyItems:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, mArr[<span class="number">0</span>], mArr[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">NSData</span> * data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:mArr];</span><br><span class="line"><span class="built_in">NSMutableArray</span> * newMutableArr = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p  %p"</span>, newMutableArr[<span class="number">0</span>], newMutableArr[<span class="number">1</span>]);</span><br><span class="line"><span class="number">0x6040004434b0</span>  <span class="number">0x109c93100</span></span><br><span class="line"><span class="number">0xa000000000000311</span>  <span class="number">0x109c93100</span></span><br><span class="line"><span class="number">0xa000000000000311</span>  <span class="number">0xa000000000000321</span></span><br></pre></td></tr></table></figure><p>由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。</p><blockquote><p>自定义类对象需要遵循 <nscoding> 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。</nscoding></p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.xxx = [aDecoder decodeObjectForKey:<span class="string">@"key"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.xxx forKey:<span class="string">@"key"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://www.jianshu.com/p/33f175d97b86" target="_blank" rel="noopener">深刻理解iOS中的“深拷贝”和“浅拷贝”</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深拷贝和浅拷贝的&lt;font color=&quot;#cc0000&quot;&gt;本质区别是地址是否相同&lt;/font&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址；&lt;/li&gt;
&lt;li&gt;深拷贝是真正的复制了一份，复制的对象指向了新的地址。&lt;/li
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>String</title>
    <link href="http://yoursite.com/2019/05/22/String/"/>
    <id>http://yoursite.com/2019/05/22/String/</id>
    <published>2019-05-22T10:48:05.651Z</published>
    <updated>2019-05-24T08:54:07.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字符串常量"><a href="#一、字符串常量" class="headerlink" title="一、字符串常量"></a>一、字符串常量</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * string1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSString</span> * string2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * temp = <span class="string">@"AAAA"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.s1 = temp;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"temp -&gt; %p"</span>, temp);</span><br><span class="line">    <span class="keyword">self</span>.s2 = <span class="keyword">self</span>.s1;</span><br><span class="line">    <span class="keyword">self</span>.s1 = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"s1 = %@，s2 = %@"</span>, <span class="keyword">self</span>.s1, <span class="keyword">self</span>.s2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"s1 -&gt; %p，s2 -&gt; %p"</span>, <span class="keyword">self</span>.s1, <span class="keyword">self</span>.s2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount = %@"</span>, [temp valueForKey:<span class="string">@"retainCount"</span>]);</span><br><span class="line">&#125;</span><br><span class="line">temp -&gt; <span class="number">0x108551118</span></span><br><span class="line">s1 = (null)，s2 = AAAA</span><br><span class="line">s1 -&gt; <span class="number">0x0</span>，s2 -&gt; <span class="number">0x108551118</span></span><br><span class="line">retainCount = <span class="number">18446744073709551615</span></span><br></pre></td></tr></table></figure><p><strong>解释 1</strong></p><p>temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。</p><p>即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。</p><p>另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString ** <span class="built_in">s2</span> = <span class="built_in">s1</span><span class="comment">;  // 需要关闭 arc 才能使用二级指针</span></span><br></pre></td></tr></table></figure><p>这样 s1 = nil 后 s2 也是 nil 了。</p><p><strong>解释 2</strong></p><p>@”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。</p><p>self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。</p><p>字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。</p><p>致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * temp1 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"AAAAAAA"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp2 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"AAAAAAA"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp3 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"BBBBBBBBBBBB"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> * temp4 = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%@"</span>, <span class="string">@"BBBBBBBBBBBB"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p   %p"</span>, temp1, temp2);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p   %p"</span>, temp3, temp4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0xa414141414141417</span>   <span class="number">0xa414141414141417</span></span><br><span class="line"><span class="number">0x60000022a3a0</span>   <span class="number">0x60000022a260</span></span><br></pre></td></tr></table></figure><p>通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区：</p><p>如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；<br>如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。</p><h2 id="二、Copy-和-strong"><a href="#二、Copy-和-strong" class="headerlink" title="二、Copy 和 strong"></a>二、Copy 和 strong</h2><pre><code>@interface ViewController ()@property (nonatomic, strong) NSString * sString;@property (nonatomic, copy) NSString * cString;@end@implementation ViewController- (void)viewDidLoad{    [super viewDidLoad];    NSMutableString * mString = [NSMutableString string];    [mString appendFormat:@&quot;AA&quot;];    self.sString = mString;    self.cString = mString;    NSLog(@&quot;mString -&gt; %p, sString -&gt; %p, cString -&gt; %p&quot;, mString, _sString, _cString);   // mString -&gt; 0x600002565b30, sString -&gt; 0x600002565b30, cString -&gt; 0xcac34ab7cb397e8b    NSLog(@&quot;%@&quot;, self.sString);  // AA    NSLog(@&quot;%@&quot;, self.cString);  // AA    [mString appendFormat:@&quot;BB&quot;];    NSLog(@&quot;%@&quot;, self.sString);  // AABB    NSLog(@&quot;%@&quot;, self.cString);  // AA}@end</code></pre><p>结果分析:</p><p>使用 strong 修饰 NSString 类型属性，指针指向可变字符串对象的地址，当可变字符串内容发生变化时，self.sStrong 相对应的也发生变化；<br>使用 copy 修饰，会将可变字符串重新拷贝一份，重新开辟内存空间，修改 mutableString 的值不会对 self.cString 造成影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、字符串常量&quot;&gt;&lt;a href=&quot;#一、字符串常量&quot; class=&quot;headerlink&quot; title=&quot;一、字符串常量&quot;&gt;&lt;/a&gt;一、字符串常量&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>atomic</title>
    <link href="http://yoursite.com/2019/05/22/atomic/"/>
    <id>http://yoursite.com/2019/05/22/atomic/</id>
    <published>2019-05-22T09:54:44.720Z</published>
    <updated>2019-05-24T08:52:41.241Z</updated>
    
    <content type="html"><![CDATA[<p>参考文章：<a href="http://blog.csdn.net/kangguang/article/details/79194563" target="_blank" rel="noopener">http://blog.csdn.net/kangguang/article/details/79194563</a></p><p>atomic 在 set 方法里加了锁，防止了多线程一直去写这个 property，造成难以预计的数值。</p><p>当属性使用 atomic 修饰时，它的读和写是原子性的：当线程 A 进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当 A 线程的写操作结束后，B 线程进行写操作，然后当 A 线程需要读操作时，获得了在 B 线程中修改的值。如果有 C 线程在 A 线程读操作之前 release了该属性，可能导致程序崩溃。</p><p>导致崩溃并不是线程安全问题。所谓线程安全是保证同一时间只有一个线程对该内存进行访问。只要我们使用 getter、setter 方法来访问，上面的表述中的每一个步骤都只有一条线程在访问该内存，哪个线程会获得锁完全取决于代码顺序，这个崩溃就是程序员自身的问题了。如果绕开 getter、setter 方法访问这个属性，才会造成线程不安全，比如使用 KVC。</p><h2 id="一、atomic-是绝对安全的"><a href="#一、atomic-是绝对安全的" class="headerlink" title="一、atomic 是绝对安全的"></a>一、atomic 是绝对安全的</h2><p>在 64 位的操作系统下，所有类型的指针(包括 void *)都是占用 8 个字节的。超过 4 个字节的基本类型数据都会有线程并发的问题。</p><p>那所有的指针类型都会有这个问题。</p><p>以 Objective-C 的 NSArray * 为例子，如果一个多线程操作这个数据，会有两个层级的并发问题：</p><p>①、指针本身</p><p>②、指针所指向的内存</p><p>指针本身也是占用内存的，并且一定是 8 个字节。第二部分，指针所指向的内存，有可能非常大，有可能也就 1 个字节。</p><p>所以考虑 NSArray * array 这个数据在进行多线程操作的时候，必须分成两部分来描述，一个是 &amp;array 这个指针本身，另一个则是它所指向的内存 array。想象现在有两块内存，一块是 8 字节，一块 n 字节，8 字节里面放的值，就是 n 字节内存的首地址。</p><p>如果用 atomic 修饰之后，会有什么影响？</p><p>从内存的角度来解释这个过程。atomic 其实修饰的是这个指针 &amp;array，与指针指向的第二部分 n 字节数据没有任何关系，被atomic 修饰之后，你不可能随意去多线程操作这个 8 字节，但是对 8 字节里面所指向的 n 字节没有任何限制！</p><p>atomic 已经完美的履行了它的指责，你不可能对这个 8 字节进行无序的多线程操作，这就够了呀！有问题的是程序员，程序员并未对 n 字节做任何的限制。</p><h2 id="二、NSMutableArray-本身是线程不安全的"><a href="#二、NSMutableArray-本身是线程不安全的" class="headerlink" title="二、NSMutableArray 本身是线程不安全的"></a>二、NSMutableArray 本身是线程不安全的</h2><p>简单来说，线程安全就是多个线程访问同一段代码，程序不会异常、不 Crash。而编写线程安全的代码主要依靠线程同步。</p><p>1、不使用 atomic 修饰属性。原因有二：</p><p>①、atomic 的内存管理语义是原子性的，仅保证了属性的 setter 和 getter 方法是原子性的、线程安全的，但是属性的其他方法，如数组添加/移除元素等并不是原子操作，所以不能保证属性是线程安全的。</p><p>②、atomic 虽然保证了 getter、setter 方法线程安全，但是付出的代价很大，执行效率要比 nonatomic 慢很多倍(有说法是慢 10-20 倍)。</p><p>总之：使用 nonatomic 修饰 NSMutableArray 对象就可以了，而使用锁、dispatch_queue 来保证 NSMutableArray 对象的线程安全。</p><p>2、打造线程安全的 NSMutableArray</p><p>在<strong>《</strong>Effective Objective-C 2.0..<strong>》</strong>书中<strong>第 </strong>41<strong> 条：</strong>多用派发队列，少用同步锁中指出：使用“串行同步队列”(serial synchronization queue)，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD 的栅栏块(barrier)来不仅实现数据同步线程安全，还比串行同步队列方式更高效。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-5fb527a419acf5a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="automic"></p><p>GCD 的栅栏块作用示意图</p><p><strong>说明</strong>：栅栏块单独执行，不能与其他块并行。直到当前所有并发块都执行完毕，才会单独执行这个栅栏块</p><p>线程安全实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QSThreadSafeMutableArray</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> * MDataArray;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> MSyncQueue;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QSThreadSafeMutableArray</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initCommon</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// %p 以 16 进制的形式输出内存地址，附加前缀 0x</span></span><br><span class="line">        <span class="built_in">NSString</span> * uuid = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"com.jzp.array_%p"</span>, <span class="keyword">self</span>];</span><br><span class="line">        <span class="comment">// 注意：_MSyncQueue 是并行队列</span></span><br><span class="line">        _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initCommon]) &#123;</span><br><span class="line">        _MDataArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">id</span> obj;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            obj = _MDataArray[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSEnumerator</span> *)objectEnumerator</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSEnumerator</span> * enu;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>( _MSyncQueue, ^&#123;</span><br><span class="line">        enu = [_MDataArray objectEnumerator];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> enu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)insertObject:(<span class="keyword">id</span>)anObject atIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray insertObject:anObject atIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span>(anObject)&#123;</span><br><span class="line">            [_MDataArray addObject:anObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray removeObjectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeLastObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        [_MDataArray removeLastObject];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)replaceObjectAtIndex:(<span class="built_in">NSUInteger</span>)index withObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123;</span><br><span class="line">            [_MDataArray replaceObjectAtIndex:index withObject:anObject];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)indexOfObject:(<span class="keyword">id</span>)anObject</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSUInteger</span> index = <span class="built_in">NSNotFound</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>( _MSyncQueue, ^&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; [_MDataArray count]; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([_MDataArray objectAtIndex:i] == anObject) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_MSyncQueue) &#123;</span><br><span class="line">        _MSyncQueue = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>说明 ①：使用 dispatch queue 实现线程同步；将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，又不会阻塞执行异步派发的线程；使用同步队列及栅栏块，可以令同步行为更加高效。</p><p>说明 ②：NSMutableDictionary 本身也是线程不安全的，实现线程安全的 NSMutableDictionary 原理同线程安全的NSMutableArray。(代码见 <a href="https://github.com/buaa0300/QSKitDemo/tree/master/QSUseCollectionDemo" target="_blank" rel="noopener">QSUseCollectionDemo</a>)</p><p>3、线程安全的 NSMutableArray 使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testQsMutableArray</span><br><span class="line">&#123;</span><br><span class="line">    _MSafeArray = [[QSThreadSafeMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="built_in">NSString</span> * str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"数组%d"</span>, (<span class="keyword">int</span>)i+<span class="number">1</span>];</span><br><span class="line">            [_MSafeArray addObject:str];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSEnumerator</span> * enu = [_MSafeArray objectEnumerator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> * object <span class="keyword">in</span> enu) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value: %@"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、atomic-与-nonatomic-的区别"><a href="#三、atomic-与-nonatomic-的区别" class="headerlink" title="三、atomic 与 nonatomic 的区别"></a>三、atomic 与 nonatomic 的区别</h2><p>在默认情况下，由编译器生成的属性的 set、get 方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不需要同步锁。</p><p>尽管没有指明 atomic 的特质（如果某属性不具备 nonatomic 特质，那它就是”原子的”(atomic)），仍然可以在属性特质中写明这一点，编译器是不会报错的。</p><p>一般 iOS 程序中，所有属性都声明为 nonatomic。这样做的原因是：</p><p>①、在 iOS 中使用同步锁的开销比较大， 会带来性能问题。</p><p>②、一般情况下并不要求属性必须是”原子的”，因为这并不能保证线程安全。若要实现线程安全的操作，还需采用更为深层的锁的机制。</p><p>一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic 也还是会读取到不同的属性值。</p><p>因此，iOS 程序一般都会使用 nonatomic 属性。但在 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。</p><p>nonatomic 的实现：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setImage:(UIImage *)<span class="built_in">image</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_image</span> != <span class="built_in">image</span>) &#123;</span><br><span class="line">        [<span class="variable">_image</span> release];</span><br><span class="line">        <span class="variable">_image</span> = [<span class="built_in">image</span> retain];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)<span class="built_in">image</span></span><br><span class="line">&#123;</span><br><span class="line">    return <span class="variable">_image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic 的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁</span></span><br><span class="line">        <span class="keyword">if</span> (_image != image) &#123;</span><br><span class="line">            [_image release];</span><br><span class="line">            _image = [image <span class="keyword">retain</span>];</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImage</span> *)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@synchronized 的介绍：</p><blockquote><p>The @synchronized directive is a convenient way to create mutex locks on the fly in Objective-C code. The @synchronized directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example:</p><p>- (void)myMethod:(id)anObj<br>{</p><p>@synchronized(anObj) {</p><p>// Everything between the braces is protected by the @synchronized directive.</p><p>}</p><p>}</p><p>The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the anObj parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section.</p><p>As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes.</p><p>For more information about the @synchronized directive, see The Objective-C Programming Language.</p></blockquote><p>更准确的说应该是读写安全，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考文章：&lt;a href=&quot;http://blog.csdn.net/kangguang/article/details/79194563&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/kangguang/arti
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc</title>
    <link href="http://yoursite.com/2019/05/22/malloc/"/>
    <id>http://yoursite.com/2019/05/22/malloc/</id>
    <published>2019-05-22T09:54:44.720Z</published>
    <updated>2019-05-24T08:53:53.735Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://yq.aliyun.com/articles/3065" target="_blank" rel="noopener">iOS内存管理和malloc源码解读</a></p><p>在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。</p><p>与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？</p><p>和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。</p><p>如上所述，iOS 在外存没有交换区，没有内存页换出的过程。</p><h2 id="一、malloc-基本原理"><a href="#一、malloc-基本原理" class="headerlink" title="一、malloc 基本原理"></a>一、malloc 基本原理</h2><p>在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。</p><ul><li>创建新对象    [NSObject alloc];</li><li>释放对象       [Object release];</li></ul><p>而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。</p><p>从苹果公开的 malloc 源码上来看，它的原理大致如下：</p><ul><li>malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。</li><li>malloc 在首次调用时，初始化 default zone。在 64 位环境下，会初始化 default zone 为 nano zone，同时初始化一个 scalable zone 作为 helper zone。nano zone 负责 nano 大小的分配，scalable zone 则负责 tiny、small 和 large内存的分配。</li><li>每次 malloc 时，根据传入的 size 参数，优先交给 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5294842-58b5a941da813178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。</p><h2 id="二、nano-malloc"><a href="#二、nano-malloc" class="headerlink" title="二、nano malloc"></a>二、nano malloc</h2><p>在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。</p><p>nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为Magazine、Band 和 Slot 几个级别。</p><ul><li>Magazine 范围对应于 CPU，CPU0 对应 Mag0，CPU1 对应 Mag1，依次类推</li><li>Band 范围为 2M，连续内存分配当内存不够时以 Band 为单位向内核请求</li><li>Slot 则对应于每个 Band 中 128K 大小的范围，每个 Band 都分为 16 个 Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配</li></ul><p>分配过程：</p><ul><li>确定当前 cpu 对应的 mag 和通过 size 参数计算出来的 slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。</li><li>初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。</li><li>如当前 Band 中当前 Slot 耗尽则向系统申请新的 Band(每个 Band 固定大小 2M，容纳了 16 个 128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是 16 个)的二维数组形式，放在 nanozone_t 的 meta_data 字段中。</li></ul><p>当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。</p><p>其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。</p><p>下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-b41dd6a71ee927ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data上挂着的空闲链表上内存区块回收来完成。</p><h2 id="三、scalable-zone-上内存分配简要分析"><a href="#三、scalable-zone-上内存分配简要分析" class="headerlink" title="三、scalable zone 上内存分配简要分析"></a>三、scalable zone 上内存分配简要分析</h2><p>对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。</p><p>在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。</p><p>tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为-1 的 magazine 作为后备之用。</p><p>下面是一个简图。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-10c246c2019af0d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="malloc"></p><p>分配时(以 tiny 的情况为例)：</p><ol><li>确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。</li><li>优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。</li><li>如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。</li><li>如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。这里需要注意的是，在一般情况下 free list 分为 64 个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63 为所有更大的内存区块挂载的地方。</li><li>上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。</li><li>如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。</li><li>如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。</li><li>要是再不行就没招了，系统也给不到内存，就报错返回。</li></ol><p>free 时：</p><ol><li>检查指针指向地址是否有问题。</li><li>如果 last free 指针上没有挂载内存区块，则放到 last free 上就 OK 了。</li><li>如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上(在挂载的 free list 前，会先根据 region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。</li><li>合并后所在的 region 如果空闲字节超过一定条件，则将把此 region 放到后备的 magazine 中(-1)。</li><li>如果整个 region 都是空的，则直接还给系统内核，一了百了。</li></ol><p>而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://yq.aliyun.com/articles/3065&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS内存管理和malloc源码解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在内存管理方面，iOS 和其它操作系统总体上来说是大同
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
</feed>
