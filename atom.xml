<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>D</title>
  
  <subtitle>While there is life there is hope</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T09:55:42.400Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BiYJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSPredicate</title>
    <link href="http://yoursite.com/2019/08/31/iOS/iOS%E5%8E%9F%E7%90%86/NSPredicate/"/>
    <id>http://yoursite.com/2019/08/31/iOS/iOS原理/NSPredicate/</id>
    <published>2019-08-31T05:34:34.645Z</published>
    <updated>2019-09-03T09:55:42.400Z</updated>
    
    <content type="html"><![CDATA[<p>官方的解释:</p><blockquote><p>The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering.</p></blockquote><p>NSPredicate 类是用来定义逻辑条件，用来有约束的获取内存中的对象或过滤搜索。</p><p>简而言之：只选取符合条件的对象。</p><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><p>使用谓词（NSPredicate）都需要为谓词定义<font color="#cc0000"><code>谓词表达式</code></font>，而这个表达式必须是一个返回 BOOL 的值。</p><p>谓词表达式由表达式、运算符和值构成。</p><h4 id="1-1-比较运算符"><a href="#1-1-比较运算符" class="headerlink" title="1.1 比较运算符"></a>1.1 比较运算符</h4><ol><li><p>=、==：判断两个表达式是否相等，在谓词中 = 和 == 是相同的意思，而没有赋值的概念。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSString * string = @&quot;1234&quot;;</span><br><span class="line">NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF = &apos;1234&apos;&quot;];</span><br><span class="line"></span><br><span class="line">// 验证对象是否符合条件。底层调用了 [xx compare:] 方法</span><br><span class="line">if ([predicate evaluateWithObject:string]) &#123;</span><br><span class="line">    NSLog(@&quot;Evaluate Success!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    NSLog(@&quot;Evaluate Fail!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-31 11:53:35.305452+0800 Predicate[7069:1165684] Evaluate Success!</span><br></pre></td></tr></table></figure><p> 当传入数组对象时，报错：<font color="#cc0000">*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSArrayI compare:]: unrecognized selector sent to instance 0x600000234c00’</font>。可以发现底层调用了 compare: 方法。</p></li><li><p>>=、=>：判断左边表达式的值是否大于或等于右边表达式的值</p></li><li>\&lt;=、=\&lt;：判断左边表达式的值是否小于或等于右边表达式的值</li><li>>：判断左边表达式的值是否大于右边表达式的值</li><li>\&lt;：判断左边表达式的值是否小于右边表达式的值</li><li>!=、\&lt;>：判断两个表达式是否不相等</li></ol><h4 id="1-2-逻辑运算符"><a href="#1-2-逻辑运算符" class="headerlink" title="1.2 逻辑运算符"></a>1.2 逻辑运算符</h4><ol><li>AND、&amp;&amp;：逻辑与。两个表达式的值都为 YES 时，结果才为 YES。</li><li>OR、||：逻辑或。要求其中一个表达式为 YES 时，结果就是 YES。</li><li>NOT、!：逻辑非。对原有的表达式取反</li></ol><h4 id="1-3-关系运算符"><a href="#1-3-关系运算符" class="headerlink" title="1.3 关系运算符"></a>1.3 关系运算符</h4><ol><li><p>ANY、SOME：集合中任意一个元素满足条件，就返回 YES。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString * name;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">NSArray * arr = @[ person1, person2, ... ];  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-31 13:33:03.764130+0800 Predicate[8478:1206451] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;The left hand side for an ALL or ANY operator must be either an NSArray or an NSSet.&apos;</span><br></pre></td></tr></table></figure></li></ol><pre><code>根据报错信息得知，谓词表达式中 ANY 的操作的主体需要是 NSArray 或者 NSSet。上面 filteredArrayUsingPredicate: 方法传入的是 Person 对象，所以报错，因此 ANY 操作的数据结构要是 @[ @[] ] 双层数组。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">NSArray * arr = @[ @[ person1, person2, ... ] ];  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>ALL：集合中所有元素都满足条件，才返回 YES。</li><li>NONE：集合中没有任何元素满足条件就返回 YES，等同于 not any。如: NONE person.age &lt; 18，表示 person 集合中所有元素的 age &gt;= 18 时，才返回 YES。</li><li><p>IN：等价于 SQL 语句中的 IN 运算符，只有当左边表达式或值出现在右边的集合中才会返回 YES</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predicateString = @&quot;self.name IN &#123;&apos;Tom&apos;,&apos;Jay&apos;&#125; || self.age IN&#123;25,30&#125;&quot;;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:predicateString];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@ = %@&quot;, predicateString, [self.persons filteredArrayUsingPredicate:predicate]);</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-4-范围运算符"><a href="#1-4-范围运算符" class="headerlink" title="1.4 范围运算符"></a>1.4 范围运算符</h4><ol><li><p>BETWEEN：BETWEEN 表达式必须满足表达式 <font color="#cc0000">BETWEEN {下限，上限}</font> 的格式，要求该表达式必须大于或等于下限，并小于或等于上限</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSNumber * number = @(1234);</span><br><span class="line">   predicate = [NSPredicate predicateWithFormat:@&quot;SELF BETWEEN &#123;1000, 2000&#125;&quot;];</span><br><span class="line">   </span><br><span class="line">   if ([predicate evaluateWithObject:number]) &#123;</span><br><span class="line">       NSLog(@&quot;Success!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">       NSLog(@&quot;Fail!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   2019-08-31 13:06:59.443083+0800 Predicate[8050:1192540] Success!</span><br></pre></td></tr></table></figure></li><li><p>IN</p></li></ol><h4 id="1-5-字符串比较运算符"><a href="#1-5-字符串比较运算符" class="headerlink" title="1.5 字符串比较运算符"></a>1.5 字符串比较运算符</h4><ol><li>BEGINSWITH：检查某个字符串是否以指定的字符串开头</li><li>ENDSWITH：检查某个字符串是否以指定的字符串结尾</li><li>CONTAINS：检查某个字符串是否包含指定的字符串</li><li>LIKE：检查某个字符串是否匹配指定的字符串模板。其之后可以跟 ? 代表一个字符和 * 代表任意多个字符。比如 “name LIKE ‘*ac*‘“，这表示 name 的值中包含 ac 则返回 YES；”name LIKE ‘?ac*’”，表示 name 的第 2、3 个字符为 ac 时返回 YES。</li><li>MATCHES：检查某个字符串是否匹配指定的正则表达式。虽然<font color="#cc0000">正则表达式的执行效率是最低的</font>，但其功能是最强大的，也是我们最常用的。</li></ol><p>注意：字符串比较都是区分大小写和重音符号的。如：café 和 cafe 是不一样的，Cafe 和 cafe 也是不一样的。如果希望字符串比较运算不区分大小写和重音符号，请在这些运算符后使用 <font color="#cc0000">[c]、[d]</font> 选项。其中 [c] 是不区分大小写，[d] 是不区分重音符号，其写在字符串比较运算符之后，比如：name LIKE[cd] ‘cafe’，那么不论 name 是cafe、Cafe 还是 café 上面的表达式都会返回 YES。</p><h4 id="1-6-直接量"><a href="#1-6-直接量" class="headerlink" title="1.6 直接量"></a>1.6 直接量</h4><p>在谓词表达式中可以使用如下直接量</p><ol><li>FALSE、NO：代表逻辑假</li><li>TRUE、YES：代表逻辑真</li><li>NULL、NIL：代表空值</li><li>SELF：代表正在被判断的对象自身，不区分大小写，self 也可以。</li><li>“string” 或 ‘string’：代表字符串</li><li>数组：和 c 中的写法相同，如：{‘one’, ‘two’, ‘three’}。</li><li>数值：包括整数、小数和科学计数法表示的形式</li><li>十六进制数：0x开头的数字</li><li>八进制：0o开头的数字</li><li>二进制：0b开头的数字</li></ol><h4 id="1-7-数组操作"><a href="#1-7-数组操作" class="headerlink" title="1.7 数组操作"></a>1.7 数组操作</h4><ol><li>array[index]：指定数组中特定索引处的元素。</li><li>array[first]：指定第一个元素</li><li>array[last]：指定最后一个元素</li><li>array[size]：指定数组大小</li></ol><h4 id="1-8-保留字"><a href="#1-8-保留字" class="headerlink" title="1.8 保留字"></a>1.8 保留字</h4><p>下列单词都是保留字（不区分大小写）</p><p>AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSEPREDICATE</p><blockquote><p>虽然大小写都可以，但是更推荐使用大写来表示这些保留字</p></blockquote><h2 id="二、谓词的用法"><a href="#二、谓词的用法" class="headerlink" title="二、谓词的用法"></a>二、谓词的用法</h2><h4 id="2-1-数据校验"><a href="#2-1-数据校验" class="headerlink" title="2.1 数据校验"></a>2.1 数据校验</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// MATCHES（正则表达式）</span><br><span class="line">NSString * phoneRegex = @&quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;;</span><br><span class="line">NSString * phoneNumber = @&quot;15180168516&quot;;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, phoneRegex];</span><br><span class="line">    </span><br><span class="line">if ([predicate evaluateWithObject:phoneNumber]) &#123;</span><br><span class="line">    NSLog(@&quot;%@ 是电话号码!&quot;, phoneNumber);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    NSLog(@&quot;%@ 不是电话号码!&quot;, phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evaluateWithObject: 方法返回的是一个 BOOL 值，如果符合条件就返回 YES，不符合就返回 NO。常见的有判断手机号码、邮编等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 检测字符串中是否有特殊字符</span><br><span class="line">- (BOOL)checkSpecialCharacter:(NSString *)string</span><br><span class="line">&#123;</span><br><span class="line">    NSString *regex = @&quot;[`~!@#$^&amp;*()=|&#123;&#125;&apos;:;&apos;,\\[\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“&apos;。，、？]+&quot;;</span><br><span class="line">    NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];</span><br><span class="line">    return [pred evaluateWithObject:string];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-过滤集合"><a href="#2-2-过滤集合" class="headerlink" title="2.2 过滤集合"></a>2.2 过滤集合</h4><p>谓词本身就代表了一个逻辑条件，计算谓词之后返回的结果永远为 BOOL 类型的值。而谓词最常用的功能就是对集合进行过滤。当程序使用谓词对集合元素进行过滤时，程序会自动遍历其元素，并根据集合元素来计算谓词的值，当这个集合中的元素计算谓词并返回 YES 时，这个元素才会被保留下来。请注意程序会自动遍历其元素，它会将自动遍历过之后返回为YES的值重新组合成一个集合返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @brief  NSArray</span><br><span class="line"> * @return  使用指定的谓词过滤 NSArray 集合，返回符合条件的元素组成的新集合</span><br><span class="line"> */</span><br><span class="line">- (NSArray&lt;ObjectType&gt; *)filteredArrayUsingPredicate:(NSPredicate *)predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  使用指定的谓词过滤 NSMutableArray，剔除集合中不符合条件的元素</span><br><span class="line"> */</span><br><span class="line">- (void)filterUsingPredicate:(NSPredicate *)predicate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  NSSet</span><br><span class="line"> */</span><br><span class="line">- (NSSet&lt;ObjectType&gt; *)filteredSetUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief  NSMutableSet</span><br><span class="line"> */</span><br><span class="line">- (void)filterUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);</span><br></pre></td></tr></table></figure><p>使用谓词过滤不可变集合和可变集合的区别是：过滤不可变集合时，会返回符合条件的集合元素<font color="#cc0000">组成</font>的新集合；过滤可变集合时，没有返回值，会直接<font color="#cc0000">剔除</font>不符合条件的集合元素。</p><h4 id="2-3-在谓词中使用占位符参数"><a href="#2-3-在谓词中使用占位符参数" class="headerlink" title="2.3 在谓词中使用占位符参数"></a>2.3 在谓词中使用占位符参数</h4><p>上面所有的例子中谓词总是固定的，然而我们在现实中处理变量时决定了谓词应该是可变的。</p><p>首先如果我们想在谓词表达式中使用变量，那么我们需要了解下列两种占位符：</p><blockquote><p>%K：用于动态传入属性名<br>%@：用于动态设置属性值</p></blockquote><p>相当于变量名与变量值。</p><p>除此之外，还可以在谓词表达式中使用动态改变的属性值，就像环境变量一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate * predicate1 = [NSPredicate predicateWithFormat:@&quot;%K CONTAINS %@&quot;, key, value];</span><br><span class="line">NSArray * filterArray = [array filteredArrayUsingPredicate:predicate];</span><br><span class="line"></span><br><span class="line">// 包含 $VALUE 字符串</span><br><span class="line">NSPredicate * predicateTemp = [NSPredicate predicateWithFormat:@&quot;%K &gt; $VALUE&quot;, @&quot;age&quot;];</span><br><span class="line">// 指定 $VALUE 的值为 25</span><br><span class="line">NSPredicate * predicate2 = [predicateTemp predicateWithSubstitutionVariables:@&#123; @&quot;VALUE&quot; : @25&#125; ];</span><br><span class="line">filterArray = [array filteredArrayUsingPredicate:predicate2];</span><br></pre></td></tr></table></figure><h2 id="三、文章"><a href="#三、文章" class="headerlink" title="三、文章"></a>三、文章</h2><p><a href="https://www.jianshu.com/u/c2f0de304708" target="_blank" rel="noopener">sunny_zl</a> &amp; <a href="https://www.jianshu.com/p/88be28860cde" target="_blank" rel="noopener">iOS中的谓词（NSPredicate）使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方的解释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or fo
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>静态、动态 pod</title>
    <link href="http://yoursite.com/2019/08/30/iOS/iOS%E5%8E%9F%E7%90%86/%E9%9D%99%E6%80%81%E3%80%81%E5%8A%A8%E6%80%81%20Pod/"/>
    <id>http://yoursite.com/2019/08/30/iOS/iOS原理/静态、动态 Pod/</id>
    <published>2019-08-30T07:20:43.836Z</published>
    <updated>2019-09-03T09:52:56.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、静态和动态"><a href="#一、静态和动态" class="headerlink" title="一、静态和动态"></a>一、静态和动态</h2><p>在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。</p><p>当在 podfile 中指定 use_frameworks! 时，子模块和第三方类库将被打包成 <code>.framework</code> 动态库，模块之间的代码不能直接引用，需要添加依赖；</p><center><br><img src="http://dzliving.com/DynamicModule2.png" alt><br></center><p>反之（默认情况）将打包成 <code>.a</code> 静态库。</p><center><br><img src="http://dzliving.com/StaticModule3.png" alt><br></center><p>动态库和静态库的区别：</p><ul><li>资源加载方式</li><li>包的大小 </li><li>编译速度</li></ul><h4 id="1-1-资源加载方式"><a href="#1-1-资源加载方式" class="headerlink" title="1.1 资源加载方式"></a>1.1 资源加载方式</h4><ol><li><p>s.dependency ‘xx’</p><p> 静态方式中各模块的 podspec 文件不用设置依赖，就可以直接 #import 其他模块的类头文件。</p> <center><br>￼    <img src="http://dzliving.com/StaticModule1.png" alt><br> </center><p> 而动态方式则会报错。</p> <center><br> <img src="http://dzliving.com/DynamicModule1.png" alt><br> </center></li></ol><ol start="2"><li><p>s.resources</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.resources = [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt&#125;&apos;, &apos;Resource/**/*&apos;]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">图片等资源是都放入 mainbundle，直接用 imageNamed: 访问，不用增加很多获取 bundle 的代码。</span><br></pre></td></tr></table></figure><p> s.resource = ‘xx/xxx.bundle’</p><p> s.resource_bundles = { ‘xxx’ =&gt; [‘/Classes/<strong>/*.{xib,storyboard,Bundle,png,gif,jpg,jpeg,txt}’, ‘Resource/</strong>/*’] }</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这两种写法，资源都在模块自己的 bundle 里面，文件名为 xxx.bundle，工程中需要通过 ``bundleForClass`` 等获取资源路径。</span><br><span class="line"></span><br><span class="line">#### 1.2 包的大小</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/StaticModule2.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">在图中，上面的是使用 use\_frameworks! 的动态包， 下面的是默认（或使用 use\_modular\_headers!）的静态包，几次验证，都是&lt;font color=#cc0000&gt;动态的更小&lt;/font&gt;。</span><br><span class="line"></span><br><span class="line">#### 1.3 编译速度</span><br><span class="line"></span><br><span class="line">这个未验证。</span><br><span class="line"></span><br><span class="line">#### 1.4 工程实例</span><br><span class="line"></span><br><span class="line">在项目开发中的场景是一个第三方类库 bongSDK.framework 引入了 Realm.framework 和 RealmSwift.framework，RealmSwift.framework 是通过 swift 语言写的，它的内部调用 Realm。</span><br><span class="line"></span><br><span class="line">最初静态方式的 pod 遇到了难以理解的报错，因为知识的欠缺和时间的紧迫，放弃了静态这条路，使用 use\_frameworks! 动态 pod 的方式。</span><br><span class="line"></span><br><span class="line">动态方式在 pod install 阶段没有报错，但子模块需要添加依赖，更困难的是图片、xib、storyboard 等资源需要获取到模块的 bundle 才能加载，导致工程大面积的图片加载错误，页面跳转崩溃。因此不得不增加很多获取 bundle 路径的代码，修改的位置几百上千处。</span><br><span class="line"></span><br><span class="line">```oc</span><br><span class="line">+ (NSBundle *)bundleWithClassName:(Class)cls moduleName:(NSString*)module</span><br><span class="line">&#123;</span><br><span class="line">    if (module == nil) &#123;</span><br><span class="line">        return [NSBundle mainBundle];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSBundle * bundle = [NSBundle bundleForClass:cls];</span><br><span class="line">    NSURL * bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;];</span><br><span class="line">    </span><br><span class="line">    if (bundleURL == nil) &#123;</span><br><span class="line"></span><br><span class="line">        __block UINavigationController* nav;</span><br><span class="line">        [[UIApplication sharedApplication].windows enumerateObjectsUsingBlock:^(__kindof UIWindow * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            UIViewController * windowVC = obj.rootViewController;</span><br><span class="line">            if ([windowVC isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">                nav = (UINavigationController *)windowVC;</span><br><span class="line">                *stop = YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        if (nav != nil) &#123;</span><br><span class="line">            Class callerCls = [nav.viewControllers.firstObject class];</span><br><span class="line">            bundle = [NSBundle bundleForClass:callerCls];</span><br><span class="line">            bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (bundleURL == nil) &#123;</span><br><span class="line">            return [NSBundle mainBundle];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>图片加载则更加困难，因为很多图片是在 xib 中写的，通过断点发现，系统并没有调用 <code>imageNamed:</code> 方法，导致使用 runtime 替换方法实现图片位置修改的方式失败，通过查找资料，发现 xib 中的 UIButton、UIImageView 会调用 <code>- initWithCoder:</code> 方法，底层会调用 UINibDecoder 类的 <code>decodeObjectForKey</code>。</p><p>runtime 替换 decodeObjectForKey 方法后，打印输出发现，UIButton、UIImageView 控件加载的图片名称在 <font color="#cc0000"><code>UIResourceName</code></font> 字段。由此就有了如下的处理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    _imageViewImageArray = [NSMutableArray arrayWithCapacity:2];</span><br><span class="line"></span><br><span class="line">    propKey = [CYKJXUtil stringByReversed:@&quot;emaNecruoseRIU&quot;];</span><br><span class="line">    btnKey = [CYKJXUtil stringByReversed:@&quot;tnetnoClufetatSnottuBIU&quot;];</span><br><span class="line"></span><br><span class="line">    // hook UINibDecoder      - decodeObjectForKey:</span><br><span class="line">    NSString* clsName = [NSString stringWithFormat:@&quot;redoce%@biNIU&quot;, @&quot;D&quot;];</span><br><span class="line">    clsName = [CYKJXUtil stringByReversed:clsName];</span><br><span class="line"></span><br><span class="line">    [HookTool exchangeInstanceMethod:NSClassFromString(clsName)</span><br><span class="line">                         originalSEL:@selector(decodeObjectForKey:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_decodeObjectForKey:)];</span><br><span class="line"></span><br><span class="line">    // hook UIImageView        - initWithCoder:</span><br><span class="line">    [HookTool exchangeInstanceMethod:UIImageView.class</span><br><span class="line">                         originalSEL:@selector(initWithCoder:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_imageView_initWithCoder:)];</span><br><span class="line"></span><br><span class="line">    // hook UIButton        - initWithCoder:</span><br><span class="line">    [HookTool exchangeInstanceMethod:UIButton.class</span><br><span class="line">                         originalSEL:@selector(initWithCoder:)</span><br><span class="line">                         swizzledSEL:@selector(swizzle_button_initWithCoder:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)swizzle_decodeObjectForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:));</span><br><span class="line">    IMP function = method_getImplementation(originalMethod);</span><br><span class="line">    id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function;</span><br><span class="line">    id value = functionPoint(self, _cmd, key);</span><br><span class="line">    </span><br><span class="line">    // 保存图片名称</span><br><span class="line">    if ([key isEqualToString:propKey]) &#123;</span><br><span class="line">        [_imageViewImageArray addObject:value];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 保存 button 状态数据</span><br><span class="line">    if ([key isEqualToString:btnKey]) &#123;</span><br><span class="line">        if ([value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">            _buttonImageDictionary = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UIImageView</span><br><span class="line"></span><br><span class="line">- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。</span><br><span class="line">    // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。</span><br><span class="line">    [_imageViewImageArray removeAllObjects];</span><br><span class="line"></span><br><span class="line">    UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder];</span><br><span class="line"></span><br><span class="line">    // 设置 image</span><br><span class="line">    if (_imageViewImageArray.count &gt; 0) &#123;</span><br><span class="line">        UIImage * normalImage = [HookTool imageAfterSearch:_imageViewImageArray[0]];</span><br><span class="line">        if (normalImage) &#123;</span><br><span class="line">            instance.image = normalImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置 highlightedImage</span><br><span class="line">    if (_imageViewImageArray.count &gt; 1) &#123;</span><br><span class="line">        UIImage * highlightedImage = [HookTool imageAfterSearch:_imageViewImageArray[1]];</span><br><span class="line">        if (highlightedImage) &#123;</span><br><span class="line">            instance.highlightedImage = highlightedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - UIButton</span><br><span class="line"></span><br><span class="line">- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。</span><br><span class="line">    // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。</span><br><span class="line">    [_imageViewImageArray removeAllObjects];</span><br><span class="line">    _buttonImageDictionary = nil;</span><br><span class="line">    </span><br><span class="line">    UIButton * instance = (UIButton *)[self swizzle_button_initWithCoder:aDecoder];</span><br><span class="line">    </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [_buttonImageDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key,</span><br><span class="line">                                                                    id  _Nonnull obj,</span><br><span class="line">                                                                    BOOL * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            if (_imageViewImageArray.count == 0) &#123;</span><br><span class="line">                *stop = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                switch ([key integerValue]) &#123;</span><br><span class="line">                    case ButtonImageOrder_Normal:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateNormal];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Highlighted:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateHighlighted];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Selected:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateSelected];</span><br><span class="line">                        break;</span><br><span class="line">                    case ButtonImageOrder_Disabled:</span><br><span class="line">                        [HookTool setImageForButton:instance object:obj state:UIControlStateDisabled];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更详细的代码：<a href="https://github.com/BiYJ/ImageTool" target="_blank" rel="noopener">ImageTool</a></p><p>如上可见，这种动态方式对于编码并不友好，资源必须要特定的 bundle，一旦资源路径出错，轻则图片未加载，重则程序崩溃。</p><p>所以需要研究下如果使用静态方式 pod 子模块代码。</p><p>首先将 use_frameworks! 删除，重新执行 pod install，等 Pod installation complete! 之后，运行工程，报错，一个一个的解决。</p><ol><li><p>dyld: Library not loaded: @rpath/Realm.framework/Realm</p><p> 现在不用 pod 导入 realm，而是将 realm.framework 拖入 basicModule 工程。这里找了<a href="https://static.realm.io/downloads/objc/realm-objc-3.13.1.zip?_ga=2.256310156.625208557.1551076206-43540051.1551076206" target="_blank" rel="noopener">官方最新的</a> realm.framework，它分为静态版和动态版，添加到工程的 <code>Embedded Binaries</code>，编译时报错 <code>Unknown type name namespace</code>。</p><p> 不管通过修改 .h 为 .hpp，还是修改 build settings -&gt; Compile Sources As -&gt; Objectoive-C++ 都没有效果，无计可施之时想到了，可以将 use_frameworks! 时 cocoapods 生成 的 Realm.framework 拷贝一份，拖入工程死马等活马医。</p><p> 编译运行，这个问题解决了~</p></li><li><p>Argument list too long: recursive header expansion failed</p><p> Search Paths -&gt; Header Search Paths，去掉 <code>$(PODS_ROOT)/**</code>，去掉不必要的 <code>recursive</code> search。</p></li></ol><p>其余的就是解决一些资源加载问题，资源重名问题，动态库的引用问题 #import “” 改为 #import &lt;&gt;。</p><center><br><img src="http://dzliving.com/DuplicateFile.png" alt><br></center>    <h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://juejin.im/post/5bea871ef265da612e282f54" target="_blank" rel="noopener">关于Argument list too long的问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、静态和动态&quot;&gt;&lt;a href=&quot;#一、静态和动态&quot; class=&quot;headerlink&quot; title=&quot;一、静态和动态&quot;&gt;&lt;/a&gt;一、静态和动态&lt;/h2&gt;&lt;p&gt;在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>编程思想</title>
    <link href="http://yoursite.com/2019/08/17/iOS/iOS%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2019/08/17/iOS/iOS原理/编程思想/</id>
    <published>2019-08-17T15:41:19.406Z</published>
    <updated>2019-09-03T09:52:51.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、链式编程"><a href="#一、链式编程" class="headerlink" title="一、链式编程"></a>一、链式编程</h2><blockquote><p>链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[self one] two];</span><br></pre></td></tr></table></figure><p>在 Objective-C 中，没有传递参数的方法可以写成<font color="#cc0000">点语法</font>的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.one.two;</span><br></pre></td></tr></table></figure><p>上面的写法会产生警告：<code>Property access result unused - getters should not be used for side effects</code>。这是因为 two 方法被当成 <font color="#cc0000"><code>getter</code></font> 方法，getter 方法会有返回值，self.one.two 没有使用该返回值。</p><blockquote><p>Objective-C : 点语法 + 事务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.one.two(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void(^)(NSString *))two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    return ^ (NSString * s) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, s);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-17 19:45:34.079059+0800 Demo[858:23949] 1</span><br><span class="line">2019-08-17 19:45:34.079188+0800 Demo[858:23949] 2</span><br><span class="line">2019-08-17 19:45:34.079271+0800 Demo[858:23949] 3</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>经典使用链式编程思想的开源代码：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a></p><h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><p>在数学中 y = f(x), y = f(f(x)) 都是函数，x 既可以是一个简单的参数，也可以是一个表达式。</p><p>在 OC 中，将 block 作为参数传递可实现<font color="#cc0000">灵活的</font>函数封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two:(void (^)(NSString *))block</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    block(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.one two:^(NSString * s) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, s);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>函数式编程（Functional Programming）相对于要理解「函数」，我们更需要理解的其实是「状态」。</p><h4 id="2-1-状态"><a href="#2-1-状态" class="headerlink" title="2.1 状态"></a>2.1 状态</h4><p>说到状态，很容易会联想到变量、局部变量、全局变量、property、model，这些都可以成为状态，但变量和状态又不是一回事，要真正理解状态，得先理解下面一行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>简单的一行代码，分析起来却有不少门道。</p><ul><li>「i」就是变量，一个变量可以看做是一个实体，真实存在于内存空间的实体。</li><li>int 是它的类型信息，是对于它的一种约束。</li><li>0 是它被赋予的一个值。</li></ul><p>变量是我们要分析的目标。它的类型信息、值信息虽然会约束变量的行为，但不是我们关注的重点，真正让变量变得危险的是中间的等号，= 是个赋值操作，意味着改变 i 的值，原本处于<font color="#cc0000">静态的</font> i，由于一个 = 发生了变化，它的值可以变为 1，或者 10000，或者其他任何值，我们可以说这个变量有了状态。</p><p>状态也是个相对的概念，变量都有其生命周期，一旦变量被回收，其所包含的状态也随之消失，所以状态所带来的影响是受限于变量的生命周期的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)<span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是函数 do 方法内部的临时变量，分配在内存的栈上。在 do 函数内部这个空间范畴来说，i 是有状态的，i 被赋予了值 0。一旦 return，i 的生命周期也随之结束，其所对应的状态也消失了。所以一旦出了do，i 又变得没有状态了。代码虽然执行了 return i，但返回的其实是 i 所代表的值，i 将自己的值交出来之后，就完成了自己的使命。</p><p>所以 do 函数的使用者是感受不到 i 的存在的，do 的调用方可以认为 do 是无状态（stateless）的，<font color="#cc0000">无状态意味着静止，静止的事物都是安全的</font>，飞驰而过的火车和静止的石块，当然是后者感觉更安全。</p><p>我们编写代码的时候会经常谈论状态，函数的状态、类的状态、App 的状态，归根结底，我们所讨论的是：<font color="#cc0000">在某个空间范畴内会发生变化的变量</font>。</p><p>函数式编程当中的函数 f(x) 强调无状态，其实是强调<font color="#cc0000">将状态锁定在函数的内部</font>。一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，前面说过变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量。下面两个函数，一个入参是传值，一个入参是传变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)do:(int)value  // 传值</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)do:(NSMutableArray *)arr  // 传变量</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个没状态，对调用方来说是安全的，对整个app来说也是安全的，既避免了依赖外部的状态，也不会修改外部的状态，即：不会产生 side effect，没有副作用。</p><p>第二个 do 函数，不但是传入了变量，还是可以变化的变量，是真正意义上的外部状态。很有可能在你遍历这个 arr 的时候，外部某个同时执行的线程正在尝试改变这个 arr 里的元素。</p><p>所以让我来总结函数式编程当中的函数，可以一句话归结为：<font color="#cc0000">隔绝一切外部状态，传入值，输出值</font>。</p><p>再看看函数式编程当中的纯函数（Pure Function）的定义:</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a>, a <a href="https://en.wikipedia.org/wiki/Function_(computer_science" target="_blank" rel="noopener">function</a>) may be considered a pure function if both of the following statements about the function hold:</p><ol><li><p>The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or bet`ween different executions of the program, nor can it depend on any external input from <a href="https://en.wikipedia.org/wiki/Input/output" target="_blank" rel="noopener">I/O</a> devices (usually—see below).</p></li><li><p>Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below).</p></li></ol></blockquote><p>纯函数即为函数式编程所强调的函数，上述两点可翻译为：</p><p>①、不依赖外部状态<br>②、不改变外部状态</p><p>所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解：<font color="#cc0000">时间和空间</font>。</p><h4 id="2-2-时间"><a href="#2-2-时间" class="headerlink" title="2.2 时间"></a>2.2 时间</h4><p>变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。</p><p>时间的武器是赋值，赋予变量新的值，在不可预知的未来埋下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setUserName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">//before assignment</span><br><span class="line">_userName = name;</span><br><span class="line">//after assignment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦有了赋值操作，时间就找到了空隙，可以对代码的执行产生影响。或许是现在，或许是明天，或许是在  appDidFinishLaunch，或许是在 didReceiveMemoryWarning。</p><p><font color="#cc0000">变量会随着时间变化</font>。有状态的函数也会随着时间的流动产生不同的输出，Pure Function 却是对时间免疫的，纯函数没有状态，无论怎样去执行一个纯函数，它所输出的结果永远不会变。</p><h4 id="2-3-空间"><a href="#2-3-空间" class="headerlink" title="2.3 空间"></a>2.3 空间</h4><p>如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。(线程安全问题)</p><p>Pure Function 同样是对空间免疫的。</p><p>多线程的 bug 调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。</p><h4 id="2-4-离不开的状态"><a href="#2-4-离不开的状态" class="headerlink" title="2.4 离不开的状态"></a>2.4 离不开的状态</h4><p>函数式编程通过 Pure Function，使得我们的代码经得起时间和空间的考验。</p><p>我们可以把一个 App 的代码按照函数式编程的方式，拆分成一个个合格的 pure function，再通过某种方式串联起来，要方便的串联函数，需要能像使用变量一样方便的使用函数。</p><p>一个 Pure Function 可以是 stateless 的，但 App 可以变成 stateless 吗？显然不能。</p><p>离开了变量和状态，我们很难完整的描述业务。用户购物车里的商品总是会发生变化，今天或明天，我们总是需要在一个地方接收这种变化，保存这种变化，继而反应这种变化。所以，大多数时候，我们离不开状态，但我们能做的是，<font color="#cc0000">将一定会变化的状态，锁定在尽可能小的时间和空间跨度之内</font>，通过改变代码的组织方式或架构，将必须改变的难以管教的状态，囚禁在特定的模块代码之中，让不可控变得尽量可控。</p><p>其实，即使不严格遵从函数式编程，我们同样可以写出带有 Functional Programming 精髓的代码，一切的一切，都是对于状态（state）的理解。</p><p>NSMutableArray 的 copy 也是颇具函数式编程精髓的。</p><h4 id="2-5-一等公民"><a href="#2-5-一等公民" class="headerlink" title="2.5 一等公民"></a>2.5 一等公民</h4><p>当我们把函数改造成 pure function 之后，会产生一些奇妙的化学连锁反应，这些反应甚至会改变我们的编程习惯。</p><p>一旦我们有了绝对安全的纯函数，我们当然希望能尽最大可能的去发挥它的价值，增加它出现和被使用的场景。为了加大纯函数的使用率，我们需要在语言层面做一些改造或者增强，以提高纯函数传递性。怎么增强呢？答案是将函数变为一等公民。</p><p>何谓公民？有身份证才叫公民，有身份证还能自由迁徙的就叫一等公民。</p><p>当我们的变量可以指向函数时，这个变量就有了函数的身份。当我们把这个变量当做函数的参数传入，或者函数的返回值传出的时候，这个变量就有了自由迁徙的能力。</p><p>一个函数 A，可以接收另一个函数 B 作为参数，然后再返回第三个函数 C 作为返回值。类似下面的一段swift代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">(funcB: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; input <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> funcB(input)</span><br><span class="line">&#125; <span class="comment">//funcC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 funcA 的定义里，funcB 是作为参数传入，funcC（匿名的）是作为返回值返回。funcB 和 funcC 在这个语境里就称之为 first class function。而 funcA 作为 funcB 和 funcC 的管理者，有个更高端的称谓：high order function。</p><p>有了 first class function 和 high order function，我们还会收获另一个成果：语言的表达力更灵活，更简洁，更强大了。举个例子，我们写一段代码来实现一个功能：参加 party 前选一件衣服。用传统的方式来写：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseColor</span><span class="params">(gender: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dressup</span><span class="params">(dressColor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//imperative</span></span><br><span class="line"><span class="keyword">let</span> dressColor = chooseColor(gender: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> dress = dressup(dressColor: dressColor)</span><br><span class="line">user.dress = dress</span><br></pre></td></tr></table></figure><p>先定义函数，再分三步依次调用 chooseColor, dressup，然后赋值。</p><p>如果用 first class function 和 high order function 的方式来写就是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoParty</span><span class="params">(dressup: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>, chooseColor: @escaping (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; gender <span class="keyword">in</span></span><br><span class="line"><span class="keyword">let</span> dressColor = chooseColor(gender)</span><br><span class="line"><span class="keyword">return</span> dressup(dressColor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declarative</span></span><br><span class="line"><span class="keyword">let</span> prepare = gotoParty(dressup: &#123; color <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, chooseColor: &#123; gender <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">user.dress = prepare(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>gotoParty 函数糅合了 dressup 和 chooseColor，gotoParty 成了一个 high order function，当我们读 gotoParty 的代码的时候，这单一一个函数就将我们的目的和结果都表明了。</p><p>这就是 high order function 的神奇之处，原先啰啰嗦嗦的几句话变成一句话就说清楚了，它更接近我们自然语言的表达方式，比如 gotoParty 可以这样阅读：我要挑选一件颜色适合的衣服去参加 party，这样的代码是不是语意更简洁更美呢？</p><p>注意，<font color="#cc0000">functional programming 并不会减少我们的代码量，它改变的只是我们书写代码的方式</font>。</p><p>这种更为强大的表达力我们也有个行话来称呼它：declarative programming。而我们传统的代码表达方式（OOP当中所使用的方式）则叫做：imperative programming。</p><p>imperative programming 更强调实现的步骤，而 declarative programming 则重在表达我们想要的结果。这句话理解起来可能有些抽象，实在理解不了也没啥关系，只要记住declarative programming 能更简洁精炼的表达我们想要的结果即可。</p><p>以上都是我们将function变为一等公民所产生的结果，这一改变还有更多的妙用，比如lazy evaluation。</p><p>上述代码中的dressup和chooseColor虽然都是function，但是他们在传入gotoParty的时候并不会立马执行（evaluation），而是等gotoParty被执行的时候再一起执行。这也很大程度上增强了我们的表达能力，dressup和chooseColor都具备了lazy evaluation的属性，可以被拼装，被delay，最后在某一时刻才被执行。</p><p>所以，functional programming改变了我们使用函数的方式，之前使用 OOP，我们对于怎么处理变量（定义变量，修改值，传递值，等）轻车熟路，到了函数式编程的世界，我们要学会如何同函数打交道了，要能像使用变量一样灵活自如的使用函数，这在刚开始的时候确实需要一段适应期。</p><h2 id="三、响应式编程"><a href="#三、响应式编程" class="headerlink" title="三、响应式编程"></a>三、响应式编程</h2><p>在网上流传一个非常经典的解释｀响应式编程的概念｀</p><blockquote><p>在程序开发中： a ＝ b ＋ c<br>赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化。<br>响应式编程的目标就是：如果 b 或者 c 的数值发生变化，a 的数值会同时发生变化。</p></blockquote><ol><li><p>什么是响应式编程？</p><p> 响应式编程是一种编程范例，它处理异步数据流和特定的变更传播，按照特定顺序对执行环境（上下文）进行修改。</p></li><li><p>使用响应式编程有哪些好处？</p><p> 提高系统性能：使用响应式编程能提高处理大量数据的反应速度。提升用户体验：使用响应式编程能提升系统的响应能力。简化修改和维护：代码更容易理解。</p></li><li><p>所有都应该是响应式的么？</p><p>响应式编程可以作为应用的一部分集成到应用中，没必要将已经证明有效的编程模式全部推倒。如果只是简单的网站，肯定没有必要应用响应式编程；如果需要引入推荐系统，引入响应式编程处理来大数据、高负载就是个好办法。</p></li><li><p>什么时候使用响应式编程？</p><p>响应式编程是高负载、多用户应用的优雅的解决方案，像社交应用、游戏、音视频应用；此外，应用有以下模块也适合应用：需要大量交互的服务端代码、代理服务器/负载均衡器、人工智能/机器学习、实时数据流处理。</p></li></ol><h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p>suiling &amp; <a href="http://www.cocoachina.com/articles/18325" target="_blank" rel="noopener">简单点，理解iOS与函数式编程</a><br><a href="https://www.jianshu.com/u/456d7ff700c2" target="_blank" rel="noopener">阳仔dynamics</a> &amp; <a href="https://www.jianshu.com/p/ca10c143ff0d" target="_blank" rel="noopener">ReactiveCocoa学习笔记（三）：响应式和函数响应式编程</a><br><a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="noopener">Why Reactive(Cocoa)?</a><br><a href="https://www.jianshu.com/u/18eb197607ff" target="_blank" rel="noopener">吴启辉</a> &amp; <a href="https://www.jianshu.com/p/a3598fb73eda" target="_blank" rel="noopener">关于响应式编程的十个问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、链式编程&quot;&gt;&lt;a href=&quot;#一、链式编程&quot; class=&quot;headerlink&quot; title=&quot;一、链式编程&quot;&gt;&lt;/a&gt;一、链式编程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。&lt;
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>dyld</title>
    <link href="http://yoursite.com/2019/08/07/iOS/iOS%E5%8E%9F%E7%90%86/dyld/"/>
    <id>http://yoursite.com/2019/08/07/iOS/iOS原理/dyld/</id>
    <published>2019-08-07T08:13:26.814Z</published>
    <updated>2019-09-03T09:56:44.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。</p><blockquote><p>dyld 全称 the dynamic link editor，即动态链接器，其本质是 Mach-O 文件，是专门用来加载动态库的库。</p></blockquote><p>源码下载地址：<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/dyld/</a></p><p>dyld 会将 App 依赖的动态库和 App 文件加载到内存以后执行，动态库不是可执行文件，无法独自执行。当点击 App 的时候，系统在内核态完成一些必要配置，从 App 的 MachO 文件解析出 dyld 的地址，这里会记录在 MachO 的 LC_LOAD_DYLINKER 命令中，内容参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          cmd LC_LOAD_DYLINKER</span><br><span class="line">      cmdsize 28</span><br><span class="line">         name /usr/lib/dyld (offset 12)</span><br><span class="line">Load command 8</span><br><span class="line">     cmd LC_UUID</span><br><span class="line"> cmdsize 24</span><br><span class="line">    uuid DF0F9B2D-A4D7-37D0-BC6B-DB0297766CE8</span><br><span class="line">Load command 9</span><br><span class="line">      cmd LC_VERSION_MIN_IPHONEOS</span><br></pre></td></tr></table></figure><p>dyld 位于 <code>/usr/lib/dyld</code>，可以从越狱机或者 mac 电脑中找到。以 mac 为例，终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/lib</span><br><span class="line">$ file dyld</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/dyld_path.png" alt><br></center><p>dyld 是 <font color="#cc0000">Mach-O 类型的通用二进制文件</font>，支持 x86_64 和 i386 两种架构。iPhone 真机对应的 dyld 支持的为 arm 系列架构。</p><h2 id="二、otool"><a href="#二、otool" class="headerlink" title="二、otool"></a>二、otool</h2><blockquote><p>otool 是专门用来查看 Mach-O 类型文件的工具</p></blockquote><p>Mac OS X 下二进制可执行文件的动态链接库是 <code>dylib</code> 文件。</p><blockquote><p>dylib 也就是 bsd 风格的动态库。基本可以认为等价于 windows 的 dll 和 linux 的so。mac 基于 bsd，所以也使用的是 dylib。</p></blockquote><p>Linux 下用 ldd 查看，苹果系统用 otool。</p><h4 id="2-1-查看-otool-地址"><a href="#2-1-查看-otool-地址" class="headerlink" title="2.1 查看 otool 地址"></a>2.1 查看 otool 地址</h4><p>电脑已安装 Xcode。终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ otool</span><br><span class="line">Usage: /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&apos;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&apos;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&apos;s disassembler</span><br><span class="line">-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure><p>由上可知 otool 的地址：<font color="#cc0000"><code>/Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</code></font></p><p>进入地址发现 otool 文件是一个替身（软连接）。</p><p>查看 otool 指向的软连接地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/</span><br><span class="line">$</span><br><span class="line">$ ls -l</span><br><span class="line">total 223352</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     33920 10 20  2018 ar</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     28000 10 20  2018 as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     18176 10 20  2018 asa</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    212208 10 20  2018 bison</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    150048 10 20  2018 bitcode_strip</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 c++ -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23152 10 20  2018 c89</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23248 10 20  2018 c99</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 cc -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  78705232 10 20  2018 clang</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 clang++ -&gt; clang</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120064 10 20  2018 cmpdylib</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145872 10 20  2018 codesign_allocate</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        17 11 22  2018 codesign_allocate-p -&gt; codesign_allocate</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   4937600 10 20  2018 coremlcompiler</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3344  9 26  2018 cpp</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     27712 10 20  2018 ctags</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145824 10 20  2018 ctf_insert</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        13 11 22  2018 dsymutil -&gt; llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1006032 10 20  2018 dwarfdump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    219088 10 20  2018 dyldinfo</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex++</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         8 11 22  2018 gcov -&gt; llvm-cov</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 gm4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     90960 10 20  2018 gperf</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     65520 10 20  2018 indent</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    136784 10 20  2018 install_name_tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2480704 10 20  2018 ld</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       230  9 26  2018 lex</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    154592 10 20  2018 libtool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     66000 10 20  2018 lipo</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   3320816 10 20  2018 llvm-cov</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  29723968 10 20  2018 llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  10591472 10 20  2018 llvm-nm</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  11899296 10 20  2018 llvm-objdump</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     32672 10 20  2018 llvm-otool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1272096 10 20  2018 llvm-profdata</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2873440 10 20  2018 llvm-size</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3567  9 26  2018 lorder</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 m4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24800 10 20  2018 metal</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-ar</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-link</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-opt</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metallib</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      7604  9 26  2018 mig</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 nm -&gt; llvm-nm</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132896 10 20  2018 nm-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    162720 10 20  2018 nmedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        12 11 22  2018 objdump -&gt; llvm-objdump</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        10 11 22  2018 otool -&gt; llvm-otool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    648720 10 20  2018 otool-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132784 10 20  2018 pagestuff</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 ranlib -&gt; libtool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59344 10 20  2018 rebase</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    204960 10 20  2018 redo_prebinding</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     73664 10 20  2018 rpcgen</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     48864 10 20  2018 segedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         9 11 22  2018 size -&gt; llvm-size</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120080 10 20  2018 size-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120400 10 20  2018 strings</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    189568 10 20  2018 strip</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  87671328 10 20  2018 swift</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swift-autolink-extract -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031520 10 20  2018 swift-build</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    384480 10 20  2018 swift-build-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    461136 10 20  2018 swift-demangle</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031552 10 20  2018 swift-package</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031472 10 20  2018 swift-run</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     53024 10 20  2018 swift-stdlib-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031504 10 20  2018 swift-test</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swiftc -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  12042320 10 20  2018 tapi</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     32592 10 20  2018 unifdef</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      2946  9 26  2018 unifdefall</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59776 10 20  2018 unwinddump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       135  9 26  2018 yacc</span><br></pre></td></tr></table></figure><p>可以看到 otool 指向 <font color="#cc0000">llvm-otool</font>，而 llvm-otool 和 otool 在同一个目录中。</p><p>另外，还可以发现，这个文件夹下面还有很多有用的文件，如 <code>lipo</code>。</p><h4 id="2-2-otool-L"><a href="#2-2-otool-L" class="headerlink" title="2.2 otool -L"></a>2.2 otool -L</h4><blockquote><p>查看动态链接库</p></blockquote><p>终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-fpfdxjbemnwnqcfjimbqpbzpnpem/Build/Products/Debug-iphonesimulator/Demo.app/</span><br><span class="line">$</span><br><span class="line">$ otool -L Demo</span><br><span class="line">Demo:</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0)</span><br><span class="line">/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)</span><br></pre></td></tr></table></figure><p>查看动态库的依赖库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/lib/system/libdispatch.dylib</span><br><span class="line">/usr/lib/system/libdispatch.dylib:</span><br><span class="line">/usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 913.60.3)</span><br><span class="line">/usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 551.4.0)</span><br><span class="line">/usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 62.0.0)</span><br><span class="line">/usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 4570.71.8)</span><br><span class="line">/usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 161.50.1)</span><br><span class="line">/usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 301.50.1)</span><br><span class="line">/usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 140.50.6)</span><br><span class="line">/usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1244.50.9)</span><br><span class="line">/usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 67.0.0)</span><br><span class="line">/usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 35.3.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure><h4 id="2-3-otool-ov"><a href="#2-3-otool-ov" class="headerlink" title="2.3 otool -ov"></a>2.3 otool -ov</h4><blockquote><p>显示 Objective-C 类结构及其定义的方法。</p></blockquote><p>终端执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ otool -ov Demo</span><br><span class="line">Demo:</span><br><span class="line">Contents of (__DATA,__objc_classlist) section</span><br><span class="line">00000001000041f0 0x100005080 _OBJC_CLASS_$_HookTool</span><br><span class="line">           isa 0x1000050a8 _OBJC_METACLASS_$_HookTool</span><br><span class="line">    superclass 0x0 _OBJC_CLASS_$_NSObject</span><br><span class="line">         cache 0x0 __objc_empty_cache</span><br><span class="line">        vtable 0x0</span><br><span class="line">          data 0x100004328 (struct class_ro_t *)</span><br><span class="line">                    flags 0x80</span><br><span class="line">            instanceStart 8</span><br><span class="line">             instanceSize 8</span><br><span class="line">                 reserved 0x0</span><br><span class="line">               ivarLayout 0x0</span><br><span class="line">                     name 0x100003555 HookTool</span><br><span class="line">              baseMethods 0x1000042f0 (struct method_list_t *)</span><br><span class="line">   entsize 24</span><br><span class="line">     count 2</span><br><span class="line">      name 0x1000028b3 swizzle_decodeObjectForKey:</span><br><span class="line">     types 0x1000035c4 @24@0:8@16</span><br><span class="line">       imp 0x1000015f0 -[HookTool swizzle_decodeObjectForKey:]</span><br><span class="line">      name 0x100002914 swizzle_button_initWithCoder:</span><br><span class="line">     types 0x1000035c4 @24@0:8@16</span><br><span class="line">       imp 0x1000017c0 -[HookTool swizzle_button_initWithCoder:]</span><br><span class="line">            baseProtocols 0x0</span><br><span class="line">                    ivars 0x0</span><br><span class="line">           weakIvarLayout 0x0</span><br><span class="line">           baseProperties 0x0</span><br><span class="line">Meta Class</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-4-otool-tV-Mach-O"><a href="#2-4-otool-tV-Mach-O" class="headerlink" title="2.4 otool -tV [Mach-O]"></a>2.4 otool -tV [Mach-O]</h4><blockquote><p>查看 ARM 汇编码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ otool -tV Demo</span><br><span class="line">Demo:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">+[HookTool load]:</span><br><span class="line">0000000100001400pushq%rbp</span><br><span class="line">0000000100001401movq%rsp, %rbp</span><br><span class="line">0000000100001404subq$0x40, %rsp</span><br><span class="line">0000000100001408movl$0x2, %eax</span><br><span class="line">000000010000140dmovl%eax, %edx</span><br><span class="line">000000010000140fmovq%rdi, -0x8(%rbp)</span><br><span class="line">0000000100001413movq%rsi, -0x10(%rbp)</span><br><span class="line">0000000100001417movq0x3c1a(%rip), %rsi ## Objc class ref: _OBJC_CLASS_$_NSMutableArray</span><br><span class="line">000000010000141emovq0x3b33(%rip), %rdi ## Objc selector ref: arrayWithCapacity:</span><br><span class="line">0000000100001425movq%rdi, -0x20(%rbp)</span><br><span class="line">0000000100001429movq%rsi, %rdi</span><br><span class="line">000000010000142cmovq-0x20(%rbp), %rsi</span><br><span class="line">0000000100001430callq*0x2bf2(%rip) ## Objc message: +[NSMutableArray arrayWithCapacity:]</span><br><span class="line">0000000100001436movq%rax, %rdi</span><br><span class="line">0000000100001439callq0x10000265a ## symbol stub for: _objc_retainAutoreleasedReturnValue</span><br><span class="line">000000010000143emovq__imageViewImageArray(%rip), %rdx</span><br><span class="line">0000000100001445movq%rax, __imageViewImageArray(%rip)</span><br><span class="line">000000010000144cmovq%rdx, %rdi</span><br><span class="line">000000010000144fcallq*0x2bdb(%rip) ## literal pool symbol address: _objc_release</span><br><span class="line">0000000100001455leaq0x2cb4(%rip), %rax ## Objc cfstring ref: @&quot;emaNecruoseRIU&quot;</span><br><span class="line">000000010000145cmovq0x3bdd(%rip), %rdx ## Objc class ref: HookTool</span><br><span class="line">0000000100001463movq0x3af6(%rip), %rsi ## Objc selector ref: stringByReversed:</span><br><span class="line">000000010000146amovq%rdx, %rdi</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-5-otool-h-Mach-O"><a href="#2-5-otool-h-Mach-O" class="headerlink" title="2.5 otool -h [Mach-O]"></a>2.5 otool -h [Mach-O]</h4><blockquote><p>查看 Mach-O 头结构等</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ otool -h Demo</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> 0xfeedfacf 16777223          3  0x00           2    21       3272 0x00200085</span><br></pre></td></tr></table></figure><p>一个 Mach-O 的文件头结构为：</p><center><br><img src="http://dzliving.com/MachOHeader.png" alt><br></center><p>各字段的含义，可参看 <code>/usr/include/mach-o/loader.h</code>。</p><h4 id="2-6-otool-l-Mach-O-grep-crypt1"><a href="#2-6-otool-l-Mach-O-grep-crypt1" class="headerlink" title="2.6 otool -l [Mach-O] | grep crypt1"></a>2.6 otool -l [Mach-O] | grep crypt1</h4><blockquote><p>查看 ipa 包是否加壳</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ otool -l Demo | grep crypt1</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>没有进行过加壳处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6651904</span><br><span class="line">  cryptid 0</span><br><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6553600</span><br><span class="line">  cryptid 0123456</span><br></pre></td></tr></table></figure><p>cryptid 代表是否加壳，1 - 加壳，0 - 已脱壳。</p><p>上面打印了两遍，其实代表着该可执行文件支持两种架构 armv7 和 arm64。</p><p>Mach-O 文件可以用 GUI 图形软件 <a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a> 更加直观的查看相关信息。</p><center><br><img src="http://dzliving.com/MachOView.png" alt><br></center><h2 id="三、dyld加载"><a href="#三、dyld加载" class="headerlink" title="三、dyld加载"></a>三、dyld加载</h2><blockquote><p>动态库链接、load 方法执行都是在 main 函数执行之前的。</p></blockquote><p>如图所示进行操作：</p><center><br><img src="http://dzliving.com/SymbolicBreakPoint.png" alt><br><img src="http://dzliving.com/NSObjectLoad.png" alt><br><img src="http://dzliving.com/ThreadStatck.png" alt><br></center><p>由上可知，load 的加载是从 <code>__dyld_start</code> 这个函数开始的。</p><h4 id="3-1-dyld-start"><a href="#3-1-dyld-start" class="headerlink" title="3.1 __dyld_start"></a>3.1 __dyld_start</h4><p>系统内核在加载动态库前，会加载 dyld，然后调用去执行 __dyld_start（汇编语言实现）。该函数会执行 dyldbootstrap::start()，后者会执行 _main()函数，dyld 的加载动态库的代码就是从_main()开始执行的。这里可以查看 dyldStartup.s的部分内容（以x86_x64架构做参考)，其中标出了 _dyld_start() 与 dyldbootstrap 的 start 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">.data</span><br><span class="line">.align <span class="number">3</span></span><br><span class="line">__dyld_start_static:</span><br><span class="line">.quad   __dyld_start</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">.text</span><br><span class="line">.align <span class="number">2</span>,<span class="number">0x90</span></span><br><span class="line">.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">popq%rdi# param1 = mh of app</span><br><span class="line">pushq$<span class="number">0</span># push a zero <span class="keyword">for</span> debugger end of frames marker</span><br><span class="line">movq%rsp,%rbp# pointer to base of kernel frame</span><br><span class="line">andq    $<span class="number">-16</span>,%rsp       # force SSE alignment</span><br><span class="line">subq$<span class="number">16</span>,%rsp# room <span class="keyword">for</span> local variables</span><br><span class="line"></span><br><span class="line"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">movl<span class="number">8</span>(%rbp),%esi# param2 = argc into %esi</span><br><span class="line">leaq<span class="number">16</span>(%rbp),%rdx# param3 = &amp;argv[<span class="number">0</span>] into %rdx</span><br><span class="line">movq__dyld_start_static(%rip), %r8</span><br><span class="line">leaq__dyld_start(%rip), %rcx</span><br><span class="line">subq %r8, %rcx# param4 = slide into %rcx</span><br><span class="line">leaq___dso_handle(%rip),%r8 # param5 = dyldsMachHeader</span><br><span class="line">leaq<span class="number">-8</span>(%rbp),%r9</span><br><span class="line">call__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">movq<span class="number">-8</span>(%rbp),%rdi</span><br><span class="line">cmpq$<span class="number">0</span>,%rdi</span><br><span class="line">jneLnew</span><br><span class="line"></span><br><span class="line">    # clean up <span class="built_in">stack</span> <span class="keyword">and</span> jump to <span class="string">"start"</span> in main executable</span><br><span class="line">movq%rbp,%rsp# restore the unaligned <span class="built_in">stack</span> pointer</span><br><span class="line">addq$<span class="number">8</span>,%rsp # remove the mh argument, <span class="keyword">and</span> debugger end frame marker</span><br><span class="line">movq$<span class="number">0</span>,%rbp# restore ebp back to zero</span><br><span class="line">jmp*%rax# jump to the entry point</span><br><span class="line"></span><br><span class="line"># LC_MAIN <span class="keyword">case</span>, <span class="built_in">set</span> up <span class="built_in">stack</span> <span class="keyword">for</span> call to main()</span><br></pre></td></tr></table></figure><h4 id="3-2-dyldInitialization-cpp"><a href="#3-2-dyldInitialization-cpp" class="headerlink" title="3.2 dyldInitialization.cpp"></a>3.2 dyldInitialization.cpp</h4><p>__dyld_start 内部调用 dyldbootstrap::start，位于 dyldInitialization.cpp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line"><span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line"><span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    <span class="comment">// ①、获取 dyld 对应的 slide</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">    shouldRebase = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        <span class="comment">// ②、通过 slide 对 dyld 进行 rebase</span></span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">    <span class="comment">// ③、mach 初始化</span></span><br><span class="line">mach_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="comment">// ④、栈溢出保护</span></span><br><span class="line"><span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">++apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set up random value for stack canary</span></span><br><span class="line">__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line"><span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">    <span class="comment">// ⑤、获取应用的 slide（appsSlide）</span></span><br><span class="line"><span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⑥、调用 dyld 的 main 函数</span></span><br><span class="line"><span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-slide、rebase"><a href="#3-3-slide、rebase" class="headerlink" title="3.3 slide、rebase"></a>3.3 slide、rebase</h4><p>由于 apple 采用了 <a href="https://baike.baidu.com/item/aslr/5779647?fr=aladdin" target="_blank" rel="noopener">ASLR（Address space layout randomization）</a>技术，所以 Mach-O 每次加载到内存中的<font color="#cc0000">首地址是变化的</font>，此时想找到代码在内存中对应的地址需要重定位 rebase。rebase 要用到 slide 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  The kernel may have slid a Position Independent Executable</span><br><span class="line">//</span><br><span class="line">static uintptr_t slideOfMainExecutable(const struct macho_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Mach-O 文件中 load commands 数量</span><br><span class="line">const uint32_t cmd_count = mh-&gt;ncmds;</span><br><span class="line">    </span><br><span class="line">    // 偏移地址到 load commands 的首地址</span><br><span class="line">const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header));</span><br><span class="line">const struct load_command* cmd = cmds;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        // 选中 cmd = LC_SEGMENT_COMMAND</span><br><span class="line">if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</span><br><span class="line">            // 实际对应 LC_SEGMENT_COMMAND(_TEXT)</span><br><span class="line">if ( (segCmd-&gt;fileoff == 0) &amp;&amp; (segCmd-&gt;filesize != 0)) &#123;</span><br><span class="line">                </span><br><span class="line">                // Mach-O 文件首地址 - LC_SEGMENT_COMMAND(_TEXT).vmaddr</span><br><span class="line">return (uintptr_t)mh - segCmd-&gt;vmaddr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        // 偏移 command 指针</span><br><span class="line">cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><br><img src="http://dzliving.com/MachOTEXT.png" alt><br></center><p>应用本身的 Mach-O 及 dyld 采用的是 <code>slideOfMainExecutable</code> 的方式获取 slide。从上代码得知：side = Mach-O header 首地址 - Load Commands 中 __TEXT 段的 VM Address 的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_slide(<span class="keyword">const</span> mach_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_slide(%p)\n"</span>, mh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Mach-O 文件加载对象</span></span><br><span class="line">    <span class="keyword">const</span> MachOLoaded* mf = (MachOLoaded*)mh;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 mach 文件头没有 magic 值</span></span><br><span class="line">    <span class="keyword">if</span> ( !mf-&gt;hasMachOMagic() )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 MachOLoaded::getSlide() 方法</span></span><br><span class="line">    <span class="keyword">return</span> mf-&gt;getSlide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> imageIndex)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_vmaddr_slide(%d)\n"</span>, imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到 Mach-O 文件</span></span><br><span class="line">    <span class="keyword">const</span> mach_header* mh = gAllImages.imageLoadAddressByIndex(imageIndex);</span><br><span class="line">    <span class="keyword">if</span> ( mh != <span class="literal">nullptr</span> )</span><br><span class="line">        <span class="comment">// 调用上面的方法</span></span><br><span class="line">        <span class="keyword">return</span> dyld3::_dyld_get_image_slide(mh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> MachOLoaded::getSlide() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 诊断对象。</span></span><br><span class="line">    Diagnostics diag;</span><br><span class="line">    __block <span class="keyword">intptr_t</span> slide = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环 load command</span></span><br><span class="line">    forEachLoadCommand(diag, ^(<span class="keyword">const</span> load_command* cmd, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 64 位</span></span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_64 ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command_64* seg = (segment_command_64*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT_64(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT_64(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 32 位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command* seg = (segment_command*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    diag.assertNoError();   <span class="comment">// any malformations in the file should have been caught by earlier validate() call</span></span><br><span class="line">    <span class="keyword">return</span> slide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态库加载采用的是 <code>\_dyld\_get\_image\_vmaddr\_slide</code> 的方式获取 slide。</p><p>简单验证一下，以应用 Mach-O 为例：</p><ol><li><p>Load Commands __TEXT 段 VM Address 值。</p><p> <center><br> <img src="http://dzliving.com/MachOVMAddress.png" alt><br> </center></p><p> VM Address 的地址为 4294967296（10进制）。</p></li><li><p>在 Demo 项目中 ViewController.m <code>viewDidLoad</code> 方法设置断点，触发后，在 lldb 执行 <code>image list</code></p> <center><br> <img src="http://dzliving.com/ImageList.png" alt><br> </center><p> 应用 Mach-O 的地址为 0x00000001004f8000（16进制）。</p></li><li><p>计算 viewDidLoad 在应用 Mach-O 文件中的地址，<code>symbol address = stack address - slide</code>。</p> <center><br> <img src="http://dzliving.com/LLVMAddress.png" alt><br> </center><p> ①、用 Mach-O 的 VM Address 减去对应虚拟地址，得到的 5210112（10进制）为 slide 值；<br> ②、获取 viewDidLoad 函数在当前<font color="#cc0000">内存</font>中的地址；<br> ③、用 viewDidLoad 内存地址减去 slide 得到它在 Mach-O 中对应的虚拟地址；<br> ④、将 10 进制转化为 16 进制。</p><p> 计算得到地址：0x00000001000022c0</p></li><li><p>在 Mach-O 文件中查看。</p> <center><br> <img src="http://dzliving.com/ViewDidLoadAddress.png" alt><br> </center><p> 可以看到，通过计算得出的值 0x100001750 与 Mach-O 中看到的值一致。</p></li></ol><p>当然，也可以通过命令行直接获取 slide 的值。</p><h4 id="3-4-dyld-main"><a href="#3-4-dyld-main" class="headerlink" title="3.4 dyld::_main"></a>3.4 dyld::_main</h4><p>对 ASLR 有了基本认知后，接着看看位于 <code>dyld.cpp</code> 中的 _main 干了什么。</p><h5 id="3-4-1-设置运行环境"><a href="#3-4-1-设置运行环境" class="headerlink" title="3.4.1 设置运行环境"></a>3.4.1 设置运行环境</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line"><span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line"><span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (<span class="keyword">uint64_t</span>)mainExecutableMH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line"><span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">"executable_cdhash"</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line"><span class="comment">// 获取主程序 hash</span></span><br><span class="line">mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trace dyld's load</span></span><br><span class="line"><span class="comment">// 告知 kernel，dyld 已加载</span></span><br><span class="line">notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">"dyld_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// Trace the main executable's load</span></span><br><span class="line"><span class="comment">// 告知 kernel，主程序 Mach-O 已加载</span></span><br><span class="line">notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, <span class="string">"executable_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 赋值参数。</span></span><br><span class="line"><span class="comment">// mach_header 类型结构体，表示当前 App 的 Mach-O头部信息。有了头部信息，加载器就可以从头开始，遍历整个 Mach-O 文件的信息。</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line"><span class="comment">// long 类型数据，表示 ASLR 位移长度</span></span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// if this is host dyld, check to see if iOS simulator is being run</span></span><br><span class="line"><span class="comment">// 获取 dyld 路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rootPath = _simple_getenv(envp, <span class="string">"DYLD_ROOT_PATH"</span>);</span><br><span class="line"><span class="keyword">if</span> ( (rootPath != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line"><span class="comment">// look to see if simulator has its own dyld</span></span><br><span class="line"><span class="keyword">char</span> simDyldPath[PATH_MAX]; </span><br><span class="line">strlcpy(simDyldPath, rootPath, PATH_MAX);</span><br><span class="line">strlcat(simDyldPath, <span class="string">"/usr/lib/dyld_sim"</span>, PATH_MAX);</span><br><span class="line"><span class="comment">// 打开 dyld_sim 路径</span></span><br><span class="line"><span class="keyword">int</span> fd = my_open(simDyldPath, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">if</span> ( fd != <span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="comment">// 如果是模拟器，并且正确加载`dyld_sim`，则直接返回主程序地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result);</span><br><span class="line"><span class="keyword">if</span> ( errMessage != <span class="literal">NULL</span> )</span><br><span class="line">halt(errMessage);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">CRSetCrashLogMessage(<span class="string">"dyld: launch started"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个全局链接上下文，包括一些回调函数、参数与标志设置信息，其中的 context 结构体实例、回调函数都是 dyld 自己的实现</span></span><br><span class="line">setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line"><span class="comment">// 获取主程序路径</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line"><span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取应用 Mach-O 文件的绝对路径</span></span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">'/'</span> ) &#123;</span><br><span class="line"><span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line"><span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">    <span class="keyword">if</span> ( getcwd(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line"><span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line"><span class="built_in">strcat</span>(s, <span class="string">"/"</span>);</span><br><span class="line"><span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">sExecPath = s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line"><span class="comment">// 设置进程名称</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置进程受限模式。根据当前进程是否受限，再次配置链接上下文以及其他环境参数</span></span><br><span class="line">configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次检测/设置上下文环境</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">    <span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123;</span><br><span class="line">pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line"><span class="comment">// set again because envp and apple may have changed or moved</span></span><br><span class="line">setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">&#123;</span><br><span class="line">checkEnvironmentVariables(envp);</span><br><span class="line">defaultUninitializedFallbackPaths(envp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="keyword">if</span> (  ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac)</span><br><span class="line">  &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) &#123;</span><br><span class="line">gLinkContext.rootPaths = parseColonList(<span class="string">"/System/iOSSupport"</span>, <span class="literal">NULL</span>);</span><br><span class="line">gLinkContext.marzipan = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths )</span><br><span class="line">sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths;</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths )</span><br><span class="line">sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_OPTS，则打印参数</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">printOptions(argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果设置了DYLD_PRINT_ENV，则打印环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">printEnvironmentVariables(envp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取主程序架构信息</span></span><br><span class="line">getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>从源码可以看到，在模拟器运行程序时，通过 <code>dyld_sim</code> 来进行后续加载工作的，与正常真机加载流程略有不同。</p><p>模拟器：</p><center><br><img src="http://dzliving.com/DyldMainSim.png" alt><br></center><p>真机：</p><center><br><img src="http://dzliving.com/DyldMainPhone.png" alt><br></center><p>具体实现在 <code>useSimulatorDyld</code> 这个函数中，本文不做进一步解析。</p><p>这里还有一个知识点，环境变量 <font color="#cc0000"><code>DYLD_PRINT_OPTS</code></font> 与 <font color="#cc0000"><code>DYLD_PRINT_ENV</code></font>。在 processDyldEnvironmentVariable 方法中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_IMAGE_SUFFIX"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">gLinkContext.imageSuffix = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_INSERT_LIBRARIES"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">sEnv.DYLD_INSERT_LIBRARIES = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 secheme 添加这两个环境变量，对应的字段会被设置为 true，并不需要设置 value。</p><center><br><img src="http://dzliving.com/DyldPrintSetting.png" alt><br><img src="http://dzliving.com/DyldPrintLog.png" alt><br></center><p>但是并非每个环境变量都不需要配置 value，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processDyldEnvironmentVariable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">const</span> <span class="keyword">char</span>* mainExecutableDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FRAMEWORK_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_FRAMEWORK_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_LIBRARY_PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_LIBRARY_PATH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="3-4-2-加载共享缓存"><a href="#3-4-2-加载共享缓存" class="headerlink" title="3.4.2 加载共享缓存"></a>3.4.2 加载共享缓存</h5><p>dyld3 与 dyld 不同点在 _main 方法中可以看出。在 dyld 的 _main 方法中，完成第一步以后会初始化主 App，然后加载共享缓存。到了 dyld3，调整了顺序：加载缓存的步骤可以划分为 mapSharedCache 和 checkVersionedPaths，先执行 mapSharedCache，然后加载主 App，最后checkVersionedPaths。（苹果在 2017 年发布的 dyld3，<a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">视频链接</a>）</p><p>对于共享缓存的理解：dyld 加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被 dyld 映射到内存中，之后，当任何 Mach-O 映像加载时，dyld 首先会检查该 Mach-O 映像及所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// load shared cache</span></span><br><span class="line"><span class="comment">// 检查共享缓存是否可用</span></span><br><span class="line">checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed</span></span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line"><span class="comment">// &lt;/HACK&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 非 Dont Use</span></span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line"><span class="comment">// 映射共享缓存到共享区</span></span><br><span class="line">mapSharedCache();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存是否兼容（DyldSharedCache * loadAddress 为空 || 版本相同 -》YES）</span></span><br><span class="line"><span class="keyword">bool</span> cacheCompatible = (sSharedCacheLoadInfo.loadAddress == <span class="literal">nullptr</span>) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置了 DYLD_USE_CLOSURES || 在白名单</span></span><br><span class="line"><span class="keyword">if</span> ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line"><span class="comment">// 不使用closure，因为共享缓存格式版本与 dyld 不匹配</span></span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: not using closure because shared cache format version does not match dyld's\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could not use closure info, launch old way</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// install gdb notifier</span></span><br><span class="line">stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);</span><br><span class="line">stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);</span><br><span class="line"><span class="comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span></span><br><span class="line">sImageRoots.reserve(<span class="number">16</span>);</span><br><span class="line">sAddImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sRemoveImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sAddLoadImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">sImageFilesNeedingTermination.reserve(<span class="number">16</span>);</span><br><span class="line">sImageFilesNeedingDOFUnregistration.reserve(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WAIT_FOR_SYSTEM_ORDER_HANDSHAKE</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process</span></span><br><span class="line">WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// add dyld itself to UUID list</span></span><br><span class="line"><span class="comment">// 添加 dyld 的 UUID 到共享缓存 UUID 列表中</span></span><br><span class="line">addDyldImageToUUIDList();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检测共享缓存是否可用；</li><li>如果可用，映射共享缓存到共享区；</li><li>添加 dyld 的 UUID 到缓存列表。</li></ul><p>其中，检测共享缓存是否可用的函数 <font color="#cc0000"><code>checkSharedRegionDisable</code></font> 中有两句注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSharedRegionDisable</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// if main executable has segments that overlap the shared region, then disable using the shared region</span></span><br><span class="line"><span class="comment">// 如果主程序 Mach-O 有 segments 与共享区重叠，那么共享区不可用。并且，iOS 不开启共享区无法运行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测两者是否重叠</span></span><br><span class="line"><span class="keyword">if</span> ( mainExecutableMH-&gt;intersectsRange(SHARED_REGION_BASE, SHARED_REGION_SIZE) ) &#123;</span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.verboseMapping )</span><br><span class="line">dyld::warn(<span class="string">"disabling shared region because main executable overlaps\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line"><span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPath ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/15280847&gt; use private or no shared region for suid processes</span></span><br><span class="line">gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// iOS cannot run without shared region</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体检测代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MachOLoaded::intersectsRange(<span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> length) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> slide = getSlide();</span><br><span class="line">    forEachSegment(^(<span class="keyword">const</span> SegmentInfo&amp; info, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ①、主程序 segment 中的虚拟地址 + 虚拟地址大小 + 偏移量 &gt;= 共享区起始地址</span></span><br><span class="line"><span class="comment">            ②、主程序 segment 中的虚拟地址 + 偏移量 &lt; 共享区终止地址</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            ① 和 ② 同时 YES，那么认为主程序 Mach-O 有 segments 与共享区重叠，此时共享区不可用，从而动态库缓存不可用</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">            疑问：地址是从高到低分配？</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ( (info.vmAddr+info.vmSize+slide &gt;= start) &amp;&amp; (info.vmAddr+slide &lt; start+length) )</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这段检测代码在满足重叠条件后，并没有设置 stop = true 停止 <font color="#cc0000"><code>forEachLoadCommand</code></font> 中的循环，这里值得深究和讨论。</p><p>加载共享缓存最核心的步骤在 <font color="#cc0000"><code>mapSharedCache</code></font> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dyld3::SharedCacheOptions opts;</span><br><span class="line">opts.cacheDirOverride= sSharedCacheOverrideDir;</span><br><span class="line">opts.forcePrivate= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__ &amp;&amp; !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">opts.useHaswell= sHaswell;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">opts.useHaswell= <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">opts.verbose= gLinkContext.verboseMapping;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 dyld 缓存</span></span><br><span class="line">loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// update global state</span></span><br><span class="line"><span class="comment">// 更新进程的全局状态信息</span></span><br><span class="line"><span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">gLinkContext.dyldCache = sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SharedCacheRuntime.cpp 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="comment">// 模拟器只支持 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">    <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="comment">// 只加载 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="keyword">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 已加载过的</span></span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未加载过的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载缓存分三种情况：</p><p>①、仅加载到当前进程。通过 <code>mapCachePrivate()</code> 加载并返回错误信息；<br>②、已经加载过的。通过 <code>reuseExistingCache()</code> 加载并返回错误信息，同时返回是否加载过 BOOL 值；<br>③、未加载过的。通过 <code>mapCacheSystemWide()</code> 加载缓存并映射，返回错误信息。</p><p>options.forcePrivate 的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld.cpp</span></span><br><span class="line">opts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion)</span><br><span class="line"></span><br><span class="line">gLinkContext.sharedRegionMode= ImageLoader::kUseSharedRegion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageLoader.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">enum</span> SharedRegionMode &#123; kUseSharedRegion, kUsePrivateSharedRegion, kDontUseSharedRegion, kSharedRegionIsSharedCache &#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gLinkContext.sharedRegionMode 在 setContext() 方法中设置默认值，默认值为 kUseSharedRegion，也就是之前检测共享区是否可用的标识值。</p><h5 id="3-4-3-实例化主程序"><a href="#3-4-3-实例化主程序" class="headerlink" title="3.4.3 实例化主程序"></a>3.4.3 实例化主程序</h5><p>系统会对已经映射到进程空间的主程序（在 XNU 解析 MachO 阶段就完成了映射操作）创建一个ImageLoaderMachO，再将其加入到 master list 中（sAllImages）。如果加载的 MachO 的硬件架构与本设备相符，就执行 imageLoader 的创建和添加操作。其中主要实现是ImageLoaderMachO::instantiateMainExecutable方法，该方法将主 App 的 MachHeader、ASLR，文件路径和前面提到的链接上下文作为参数，做 imageLoader 的实例化操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line"><span class="comment">// 实例化主程序</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line"><span class="comment">// 代码签名</span></span><br><span class="line">gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// check main executable is not too new for this OS</span></span><br><span class="line"><span class="comment">// 检测主程序是否支持当前设备版本</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 检查是否是模拟器二进制文件</span></span><br><span class="line"><span class="keyword">if</span> ( ! isSimulatorBinary((<span class="keyword">uint8_t</span>*)mainExecutableMH, sExecPath) ) &#123;</span><br><span class="line">throwf(<span class="string">"program was built for a platform that is not supported by this runtime"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint32_t</span> mainMinOS = sMainExecutable-&gt;minOSVersion();</span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld is always built for the current OS, so we can get the current OS version</span></span><br><span class="line"><span class="comment">// from the load command in dyld itself.</span></span><br><span class="line"><span class="comment">// 获取 dyld 中存储的当前 OS 版本</span></span><br><span class="line"><span class="keyword">uint32_t</span> dyldMinOS = ImageLoaderMachO::minOSVersion((<span class="keyword">const</span> mach_header*)&amp;__dso_handle);</span><br><span class="line"><span class="comment">// 应用 mach-O 文件的版本超过了当前模拟器设备的版本，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> ( mainMinOS &gt; dyldMinOS ) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WATCH</span></span><br><span class="line">throwf(<span class="string">"app was built for watchOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> TARGET_OS_TV</span></span><br><span class="line">throwf(<span class="string">"app was built for tvOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">throwf(<span class="string">"app was built for iOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries</span></span><br><span class="line"><span class="keyword">uint32_t</span> mainSDK = sMainExecutable-&gt;sdkVersion();</span><br><span class="line">gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// simulators, iOS, tvOS, and watchOS are always strict</span></span><br><span class="line">gLinkContext.strictMachORequired = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">sAllImages.reserve((sAllCacheImagesProxy != <span class="literal">NULL</span>) ? <span class="number">16</span> : INITIAL_IMAGE_COUNT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">sAllImages.reserve(INITIAL_IMAGE_COUNT);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line">checkVersionedPaths(); <span class="comment">// 设置加载的动态库版本。这里的动态库还没有包括经 DYLD_INSERT_LIBRARIES 插入的库。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line"><span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line"><span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line"><span class="comment">// dyld 加载的 image_infos 并不包含 dyld 本身，它被放到 dyld_all_image_infos 的 dyldPath 字段中去了。而对于模拟器，dyld 加载的 image_infos 是包含 dyld_sim 的。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line"><span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// get path of dyld itself</span></span><br><span class="line"><span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 dyld 路径并与 gProcessInfo-&gt;dyldPath 对比</span></span><br><span class="line"><span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len = proc_regionfilename(getpid(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line"><span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">dyldPathBuffer[len] = <span class="string">'\0'</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line"><span class="comment">// 如果不同将获取到的路径复制给 gProcessInfo-&gt;dyldPath</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#cc0000"><code>dyld_all_image_infos</code></font> 是个结构体，同样分为 32 位和 64 位两个版本，分别对应 dyld_all_image_infos_32 与 dyld_all_image_infos_64，由于获取 dyld_all_image_infos 需要用到一些未开源信息，这里为了方便，从侧面验证一下这条注释信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); ++i) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%s"</span>, _dyld_get_image_name(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟器：</p><center><br><img src="http://dzliving.com/DyldSimAllImageInfo.png" alt><br></center><p>真机：</p><center><br><img src="http://dzliving.com/DyldPhoneAllImageInfo.png" alt><br></center><p>可以看到：模拟器打印的 image 没有 dyld，第 0 个 image 是 dyld_sim，第一个 image 才是主程序；真机打印出的加载 image 中也没有 dyld，第 0 个 image 是主程序。</p><p>回到最核心的 <font color="#cc0000"><code>instantiateFromLoadedImage</code></font> 实例化主程序函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="comment">// kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化成 ImageLoader 加载到内存中交给 dyld 管理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// try mach-o loader</span></span><br><span class="line"><span class="comment">// CPU 架构是否匹配</span></span><br><span class="line"><span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line"><span class="comment">// 实例化 ImageLoader 对象。参数：macho header、ASLR、执行路径、链接上下文</span></span><br><span class="line">ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line"><span class="comment">// 分配主程序image的内存，更新。</span></span><br><span class="line">addImage(image);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化ImageLoader 对象，加载到内存，返回交给 dyld 管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line"><span class="comment">//sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line"><span class="keyword">bool</span> compressed;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line"><span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line"><span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sniffLoadCommands 函数会对主程序 Mach-O进 行一系列的校验：对代码签名，MachO加密，动态库数量，段的数量相关信息的 loadCommand 做解析，提取出 command 数据。</span></span><br><span class="line"><span class="comment">/*      case LC_DYLD_INFO:</span></span><br><span class="line"><span class="comment"> case LC_DYLD_INFO_ONLY:</span></span><br><span class="line"><span class="comment"> *compressed = true;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line"><span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line"><span class="comment">// 已解密</span></span><br><span class="line"><span class="keyword">if</span> ( compressed ) </span><br><span class="line"><span class="comment">// Compressed</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line"><span class="comment">// Classic</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sniffLoadCommands 的校验并不包括对主程序 Mach-O 的解密操作，解密操作是由 xnu 完成的。</p><p>ImageLoaderMachOCompressed::instantiateMainExecutable、ImageLoaderMachOClassic::instantiateMainExecutable 两者内部的逻辑相同，只是返回类型一个是 ImageLoaderMachOCompressed 一个是 ImageLoaderMachOClassic。</p><p>以 ImageLoaderMachOCompressed 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 image</span></span><br><span class="line">ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set slide for PIE programs</span></span><br><span class="line"><span class="comment">// 设置 image 偏移量</span></span><br><span class="line">image-&gt;setSlide(slide);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for PIE record end of program, to know where to start loading dylibs</span></span><br><span class="line"><span class="keyword">if</span> ( slide != <span class="number">0</span> )</span><br><span class="line"><span class="comment">// 设置动态库起始地址</span></span><br><span class="line">fgNextPIEDylibAddress = (<span class="keyword">uintptr_t</span>)image-&gt;getEnd();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用段覆盖检测</span></span><br><span class="line">image-&gt;disableCoverageCheck();</span><br><span class="line"><span class="comment">// 结束 image 上下文</span></span><br><span class="line">image-&gt;instantiateFinish(context);</span><br><span class="line"><span class="comment">// 设置 image 加载状态为 dyld_image_state_mapped</span></span><br><span class="line">image-&gt;setMapped(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( context.verboseMapping ) &#123;</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: Main executable mapped %s\n"</span>, path);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = image-&gt;segName(i);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(name, <span class="string">"__PAGEZERO"</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(name, <span class="string">"__UNIXSTACK"</span>) == <span class="number">0</span>)  )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::setMapped(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">fState = dyld_image_state_mapped;</span><br><span class="line">context.notifySingle(dyld_image_state_mapped, <span class="keyword">this</span>, <span class="literal">NULL</span>);  <span class="comment">// note: can throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instantiateFinish() 在内部解析 loadCmds、设置动态库连接信息、设置符号表相关信息等。setMapped() 内部调用 notifySingle 进行处理。</p><h5 id="3-4-4-加载插入的动态库"><a href="#3-4-4-加载插入的动态库" class="headerlink" title="3.4.4 加载插入的动态库"></a>3.4.4 加载插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="comment">// 插入动态库</span></span><br><span class="line"><span class="keyword">if</span>( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line"><span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line"><span class="comment">// 记录插入的动态库个数</span></span><br><span class="line">sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置了 <font color="#cc0000"><code>DYLD_INSERT_LIBRARIES</code></font> 环境变量，通过loadInsertedDylib() 方法插入配置的动态库。对于越狱插件而言，其实就是通过添加 DYLD_INSERT_LIBRARIES 这个环境变量达到加载插件的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInsertedDylib</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> cacheIndex;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LoadContext context;</span><br><span class="line">context.useSearchPaths= <span class="literal">false</span>;</span><br><span class="line">context.useFallbackPaths= <span class="literal">false</span>;</span><br><span class="line">context.useLdLibraryPath= <span class="literal">false</span>;</span><br><span class="line">context.implicitRPath= <span class="literal">false</span>;</span><br><span class="line">context.matchByInstallName= <span class="literal">false</span>;</span><br><span class="line">context.dontLoad= <span class="literal">false</span>;</span><br><span class="line">context.mustBeBundle= <span class="literal">false</span>;</span><br><span class="line">context.mustBeDylib= <span class="literal">true</span>;</span><br><span class="line">context.canBePIE= <span class="literal">false</span>;</span><br><span class="line">context.enforceIOSMac= <span class="literal">true</span>;</span><br><span class="line">context.origin= <span class="literal">NULL</span>;<span class="comment">// can't use @loader_path with DYLD_INSERT_LIBRARIES</span></span><br><span class="line">context.rpath= <span class="literal">NULL</span>;</span><br><span class="line">image = load(path, context, cacheIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.allowInsertFailures )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: warning: could not load inserted library '%s' into hardened process because %s\n"</span>, path, msg);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s' because %s\n"</span>, path, msg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) &#123;</span><br><span class="line">halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s'\n"</span>, path));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部构建 context 后调用 load() 函数生成 image。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  做路径展开，搜索查找，排重，以及缓存查找工作。其中路径的展开和搜索分几个阶段（phase）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 查找 image</span></span><br><span class="line">ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line"><span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// 继续查找</span></span><br><span class="line">CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</span></span><br><span class="line"><span class="comment">// 在共享缓存中查找</span></span><br><span class="line"><span class="keyword">if</span> ( image == <span class="literal">NULL</span>)</span><br><span class="line">image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::iterator it = exceptions.begin(); it != exceptions.end(); ++it) &#123;</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span>*)(*it));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if loaded image is not from cache, but original path is in cache</span></span><br><span class="line"><span class="comment">// set gSharedCacheOverridden flag to disable some ObjC optimizations</span></span><br><span class="line"><span class="keyword">if</span> ( !gSharedCacheOverridden &amp;&amp; !image-&gt;inSharedCache() &amp;&amp; image-&gt;isDylib() &amp;&amp; cacheablePath(path) &amp;&amp; inSharedCache(path) ) &#123;</span><br><span class="line">gSharedCacheOverridden = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load 方法不仅被 loadInsertedDylib 调用，也会被 dlopen 等运行时加载动态库的方法使用。</p><p>内部有一整套 loadPhase0~loadPhase6 的流程来查找及加载 image。如果在共享缓存中找到则直接调用 instantiateFromCache 实例化 image，否则通过 loadPhase5open 打开文件并调用loadPhase6，内部通过 instantiateFromFile 实例化 image，最后再调用 checkandAddImage 将image 加载进内存。</p><p> 这些 phase 的搜索路径对应各个环境变量：DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p><p> ImageLoaderMachO 的 <code>instantiateFromFile</code>、<code>instantiateFromCache</code> 是 loader 将 MachO 文件解析映射到内存的核心方法，两个都会进入 Compressed 和 Classic 的分叉步骤。以 Compressed 下的 instantiateFromFile 来分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image by mapping in a mach-o file</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateFromFile(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* fileData, <span class="keyword">size_t</span> lenFileData,</span><br><span class="line"><span class="keyword">uint64_t</span> offsetInFat, <span class="keyword">uint64_t</span> lenInFat, <span class="keyword">const</span> struct stat&amp; info, </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, </span><br><span class="line"><span class="keyword">const</span> struct linkedit_data_command* codeSigCmd, </span><br><span class="line"><span class="keyword">const</span> struct encryption_info_command* encryptCmd, </span><br><span class="line"><span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart((macho_header*)fileData, path, segCount, libCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// record info about file  </span></span><br><span class="line">image-&gt;setFileInfo(info.st_dev, info.st_ino, info.st_mtime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if this image is code signed, let kernel validate signature before mapping any pages from image</span></span><br><span class="line"><span class="comment">// ①、交给内核去验证动态库的代码签名</span></span><br><span class="line">image-&gt;loadCodeSignature(codeSigCmd, fd, offsetInFat, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate that first data we read with pread actually matches with code signature</span></span><br><span class="line"><span class="comment">// ②、映射到内存的 first page, （4k大小）与代码签名是否match。在这里会执行沙盒，签名认证</span></span><br><span class="line">image-&gt;validateFirstPages(codeSigCmd, fd, fileData, lenFileData, offsetInFat, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap segments</span></span><br><span class="line">image-&gt;mapSegments(fd, offsetInFat, lenInFat, info.st_size, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if framework is FairPlay encrypted, register with kernel</span></span><br><span class="line"><span class="comment">// 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据cryptid是否为1做了解密操作。</span></span><br><span class="line">image-&gt;registerEncryption(encryptCmd, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// probe to see if code signed correctly</span></span><br><span class="line">image-&gt;crashIfInvalidCodeSignature();</span><br><span class="line"></span><br><span class="line"><span class="comment">// finish construction</span></span><br><span class="line">image-&gt;instantiateFinish(context);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中几个需要留意的步骤：</p><ul><li>交给内核去验证动态库的代码签名 loadCodeSignature。</li><li>映射到内存的 first page（4k 大小）与代码签名是否 match。在这里会执行沙盒，签名认证，对于在线上运行时加载动态库的需求，可以重点研究<a href="https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg" target="_blank" rel="noopener">这里</a>。</li><li>根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息 registerEncryption。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了<a href="http://newosxbook.com/src.jl?tree=xnu-3789.70.16&amp;file=bsd/kern/kern_mman.c#mremap_encrypted" target="_blank" rel="noopener">内核代码</a>，应该是根据 cryptid 是否为 1 做了解密操作。</li><li>如果走到 Phase6, 会调 xmap 函数将动态库从本地 mmap 到用户态内存空间。</li></ul><p>根据上面的分析，<font color="#cc0000">主程序 imageLoader 在全局 image 表的首位</font>，后面的是插入的动态库的 imageLoader，每个动态库对应一个 loader。</p><h5 id="3-4-5-链接主程序"><a href="#3-4-5-链接主程序" class="headerlink" title="3.4.5 链接主程序"></a>3.4.5 链接主程序</h5><p>链接所有动态库，进行符号修正绑定工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        // link main executable</span><br><span class="line">        gLinkContext.linkingMainExecutable = true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">        if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">            // previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">            // work around that by rebasing by inverse amount</span><br><span class="line">            sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">                // 链接主程序</span><br><span class="line">        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">        sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">        if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">            gLinkContext.bindFlat = true;</span><br><span class="line">            gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主程序的链接是通过 <code>link</code> 这个函数完成的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</span><br><span class="line">&#123;</span><br><span class="line">// add to list of known images.  This did not happen at creation time for bundles</span><br><span class="line">// 添加到已知镜像列表中。这在创建 bundles 时没有处理。</span><br><span class="line">if ( image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked() )</span><br><span class="line">addImage(image);</span><br><span class="line"></span><br><span class="line">// we detect root images as those not linked in yet</span><br><span class="line">// 在根镜像中检测是否尚未链接</span><br><span class="line">if ( !image-&gt;isLinked() )</span><br><span class="line">addRootImage(image);</span><br><span class="line"></span><br><span class="line">// process images</span><br><span class="line">try &#123;</span><br><span class="line">const char* path = image-&gt;getPath();</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">if ( image == sAllCacheImagesProxy )</span><br><span class="line">path = sAllCacheImagesProxy-&gt;getIndexedPath(cacheIndex);</span><br><span class="line">#endif</span><br><span class="line">// 调用 ImageLoader::link() 链接</span><br><span class="line">image-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path);</span><br><span class="line">&#125;</span><br><span class="line">catch (const char* msg) &#123;</span><br><span class="line">// 标记 image 为未使用，处理</span><br><span class="line">garbageCollectImages();</span><br><span class="line">throw;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span><br><span class="line"></span><br><span class="line">// clear error strings</span><br><span class="line">(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">// 起始时间。用于记录时间间隔</span><br><span class="line">uint64_t t0 = mach_absolute_time();</span><br><span class="line">// ①、递归加载主程序依赖的库，完成之后发送一个状态为 dyld_image_state_dependents_mapped的通知。</span><br><span class="line">this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">// we only do the loading step for preflights  只做预检的装载步骤</span><br><span class="line">if ( preflightOnly )</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">uint64_t t1 = mach_absolute_time();</span><br><span class="line">// 清空 image 层级关系</span><br><span class="line">context.clearAllDepths();</span><br><span class="line">// 递归更新 image 层级关系</span><br><span class="line">this-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">__block uint64_t t2, t3, t4, t5;</span><br><span class="line">&#123;</span><br><span class="line">dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);</span><br><span class="line">t2 = mach_absolute_time();</span><br><span class="line">// ②、递归修正自己和依赖库的基地址，因为 ASLR 的原因，需要根据随机 slide 修正基地址。</span><br><span class="line">this-&gt;recursiveRebase(context);</span><br><span class="line">context.notifyBatch(dyld_image_state_rebased, false);</span><br><span class="line"></span><br><span class="line">t3 = mach_absolute_time();</span><br><span class="line">if ( !context.linkingMainExecutable )</span><br><span class="line">// ③、递归绑定 noLazy 的符号表，lazy的符号会在运行时动态绑定（首次被调用才去绑定）</span><br><span class="line">this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">t4 = mach_absolute_time();</span><br><span class="line">if ( !context.linkingMainExecutable )</span><br><span class="line">// ④、绑定弱符号表，比如未初始化的全局变量就是弱符号。</span><br><span class="line">this-&gt;weakBind(context);</span><br><span class="line">t5 = mach_absolute_time();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    if ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, false);</span><br><span class="line">uint64_t t6 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line">// ⑤、递归获取/注册程序的 DOF 节区，dtrace 会用其动态跟踪。</span><br><span class="line">this-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">// 注册</span><br><span class="line">context.registerDOFs(dofs);</span><br><span class="line">uint64_t t7 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line">// interpose any dynamically loaded images</span><br><span class="line">if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123;</span><br><span class="line">dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);</span><br><span class="line">// 递归应用插入的动态库</span><br><span class="line">this-&gt;recursiveApplyInterposing(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// clear error strings</span><br><span class="line">(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">// 计算出各种时间间隔</span><br><span class="line">fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">fgTotalRebaseTime += t3 - t2;</span><br><span class="line">fgTotalBindTime += t4 - t3;</span><br><span class="line">fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">fgTotalDOF += t7 - t6;</span><br><span class="line"></span><br><span class="line">// done with initial dylib loads</span><br><span class="line">fgNextPIEDylibAddress = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部加载动态库、rebase、绑定符号表、注册dofs信息等，同时还计算各步骤的耗时。如果想获取这些耗时，只需要在环境变量中添加 <font color="#cc0000"><code>DYLD_PRINT_STATISTICS</code></font> 就可以了，这个环境变量不需要 value。</p><p>在步骤 ① 里，递归加载主 App 在打包阶段就确定好的动态库的操作，会使用前面提到的 setContext 里的链接上下文，调用它的 loadLibrary 方法；然后优先去加载依赖的动态库。loadLibary 的实现在设置链接上下文的时候就已经赋值确定，即 libraryLocator，在这个方法里会用到上面提到的 load 方法。</p><p>在步骤 ③ 里，会有符号绑定的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief   recursiveBind 完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，对于 DYLD_BIND_AT_LAUNCH 等特殊情况下的 non-lazy 符号才执行立即绑定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::recursiveBind(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> neverUnload)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Normally just non-lazy pointers are bound immediately.</span></span><br><span class="line"><span class="comment">// The exceptions are:</span></span><br><span class="line"><span class="comment">//   1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately</span></span><br><span class="line"><span class="comment">//   2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately</span></span><br><span class="line"><span class="keyword">if</span> ( fState &lt; dyld_image_state_bound ) &#123;</span><br><span class="line"><span class="comment">// break cycles</span></span><br><span class="line">fState = dyld_image_state_bound;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// bind lower level libraries first</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">ImageLoader* dependentImage = libImage(i);</span><br><span class="line"><span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> )</span><br><span class="line">dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bind this image</span></span><br><span class="line"><span class="comment">// 绑定。this 表示递归调用时，recursiveBind 方法的调用者</span></span><br><span class="line"><span class="keyword">this</span>-&gt;doBind(context, forceLazysBound);</span><br><span class="line"><span class="comment">// mark if lazys are also bound</span></span><br><span class="line"><span class="keyword">if</span> ( forceLazysBound || <span class="keyword">this</span>-&gt;usablePrebinding(context) )</span><br><span class="line">fAllLazyPointersBound = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// mark as never-unload if requested</span></span><br><span class="line"><span class="keyword">if</span> ( neverUnload )</span><br><span class="line"><span class="keyword">this</span>-&gt;setNeverUnload();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知</span></span><br><span class="line">context.notifySingle(dyld_image_state_bound, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="comment">// restore state</span></span><br><span class="line">fState = dyld_image_state_rebased;</span><br><span class="line">            CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的核心是 ImageLoaderMach 的 doBind，读取 image 的动态链接信息的 bind_off 与 bind_size 来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用 <font color="#cc0000">bindAt</font> 函数；调用 resolve 解析完符号表后，调用 bindLocation 完成最终的绑定操作，需要绑定的符号信息有三种：</p><ul><li>BIND_TYPE_POINTER：需要绑定的是一个指针。直接将计算好的新值屿值即可。</li><li>BIND_TYPE_TEXT_ABSOLUTE32：一个32位的值。取计算的值的低32位赋值过去。</li><li>BIND_TYPE_TEXT_PCREL32：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。</li></ul><p>对延迟绑定的实现感兴趣的可以在Xcode中调试查看，或者参考<a href="https://leylfl.github.io/2018/05/28/dyld%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">这个</a>。</p><h5 id="3-4-6-链接插入的动态库"><a href="#3-4-6-链接插入的动态库" class="headerlink" title="3.4.6 链接插入的动态库"></a>3.4.6 链接插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="comment">// 链接其他被插入的动态库</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="comment">// 循环处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 链接</span></span><br><span class="line">link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 递归修改 image 的 fNeverUnload 属性</span></span><br><span class="line">image-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line"><span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line"><span class="comment">// 只有插入可插入的库。在绑定所有插入的库后注册插入信息，以便链接工作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line"><span class="comment">// 即使没有 DYLD_INSERT_LIBRARIES，dyld 也应该支持插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;inSharedCache() )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES  <span class="comment">// !TARGET_IPHONE_SIMULATOR，非模拟器</span></span></span><br><span class="line"><span class="keyword">if</span> ( (sAllCacheImagesProxy != <span class="literal">NULL</span>) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line"><span class="comment">// Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span></span><br><span class="line"><span class="comment">// 加速键表不能与隐式插入一起使用，因此在禁用加速键表的情况下重新启动</span></span><br><span class="line">ImageLoader::clearInterposingTuples();</span><br><span class="line"><span class="comment">// unmap all loaded dylibs (but not main executable)</span></span><br><span class="line"><span class="comment">// 取消映射所有加载的 dylib 文件，除了主程序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i];</span><br><span class="line"><span class="keyword">if</span> ( image == sMainExecutable )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ( image == sAllCacheImagesProxy )</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">image-&gt;setCanUnload();</span><br><span class="line">ImageLoader::deleteImage(image);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span></span><br><span class="line">sAllImages.clear();</span><br><span class="line">sImageRoots.clear();</span><br><span class="line">sImageFilesNeedingTermination.clear();</span><br><span class="line">sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">sAddImageCallbacks.clear();</span><br><span class="line">sRemoveImageCallbacks.clear();</span><br><span class="line">sAddLoadImageCallbacks.clear();</span><br><span class="line">sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line">sAllCacheImagesProxy = <span class="literal">NULL</span>;  <span class="comment">// 下次不再进入</span></span><br><span class="line">sMappedRangesStart = <span class="literal">NULL</span>;</span><br><span class="line">mainExcutableAlreadyRebased = <span class="literal">true</span>;</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">resetAllImages();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转回上面的步骤，重新执行，加载所有的镜像</span></span><br><span class="line"><span class="keyword">goto</span> reloadAllImages;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply interposing to initial set of images</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line"><span class="comment">// 是调用 ImageLoader::applyInterposing()，不是 ClosureWriter.cpp。内部递归，最终是执行 doInterpose() 方法</span></span><br><span class="line">sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入信息存入 dyld 缓存</span></span><br><span class="line">ImageLoader::applyInterposingToDyldCache(gLinkContext);</span><br><span class="line"><span class="comment">// 修改主程序插入标识</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the main executable now that interposing has been registered</span></span><br><span class="line"><span class="comment">// 从主程序开始调用，递归执行绑定、通知（插入信息已经注册）</span></span><br><span class="line"><span class="keyword">uint64_t</span> bindMainExecutableStartTime = mach_absolute_time();</span><br><span class="line"><span class="comment">// 内部执行 doBind()、notifySingle()</span></span><br><span class="line">sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> bindMainExecutableEndTime = mach_absolute_time();</span><br><span class="line"><span class="comment">// 绑定和通知处理时间</span></span><br><span class="line">ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime;</span><br><span class="line">gLinkContext.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 绑定插入的动态库</span></span><br><span class="line">image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里参与链接的动态库根据第 4 步中加载的插入的动态库，从 sAllImages 的第二个 imageLoader 开始，取出 image，重复 <code>link</code> 操作进行连接。registerInterposing 内部会加载 loadCmds 并查找 __interpose 及 __DATA 段，读取段信息保存到 fgInterposingTuples 中，然后调用 applyInterposing，内部调用 recursiveApplyInterposing，通过这个函数调用到 doInterpose。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoaderMachOCompressed::doInterpose(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( context.verboseInterposing )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: interposing %lu tuples onto image: %s\n"</span>, fgInterposingTuples.size(), <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// update prebound symbols。更新预绑定的符号</span></span><br><span class="line">eachBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line"><span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line"><span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">ExtraBindData *extraBindData,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line"><span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">   addend, libraryOrdinal, extraBindData,</span><br><span class="line">   msg, last, runResolver);</span><br><span class="line">&#125;);</span><br><span class="line">eachLazyBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line"><span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line"><span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">ExtraBindData *extraBindData,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line"><span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line"><span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">   addend, libraryOrdinal, extraBindData,</span><br><span class="line">   msg, last, runResolver);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interposeAt 通过 interposedAddress 在上文提到的 fgInterposingTuples 中找到需要替换的符号地址进行替换。</p><h5 id="3-4-7-弱符号绑定"><a href="#3-4-7-弱符号绑定" class="headerlink" title="3.4.7 弱符号绑定"></a>3.4.7 弱符号绑定</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">        <span class="comment">// 弱符号绑定</span></span><br><span class="line">        sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::weakBind(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind start:\n"</span>);</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"><span class="comment">// get set of ImageLoaders that participate in coalecsing</span></span><br><span class="line">ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing];</span><br><span class="line"><span class="keyword">unsigned</span> imageIndexes[fgImagesRequiringCoalescing];</span><br><span class="line"><span class="comment">// 合并所有动态库的弱符号到列表中</span></span><br><span class="line"><span class="keyword">int</span> count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// count how many have not already had weakbinding done</span></span><br><span class="line"><span class="keyword">int</span> countNotYetWeakBound = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> countOfImagesWithWeakDefinitionsNotInSharedCache = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;weakSymbolsBound(imageIndexes[i]) )</span><br><span class="line"><span class="comment">// 获取未进行绑定的弱符号的个数</span></span><br><span class="line">++countNotYetWeakBound;</span><br><span class="line"><span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;inSharedCache() )</span><br><span class="line"><span class="comment">// 获取在共享缓存中已绑定的弱符号个数</span></span><br><span class="line">++countOfImagesWithWeakDefinitionsNotInSharedCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don't need to do any coalescing if only one image has overrides, or all have already been done</span></span><br><span class="line"><span class="keyword">if</span> ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; <span class="number">0</span>) &amp;&amp; (countNotYetWeakBound &gt; <span class="number">0</span>) ) &#123;</span><br><span class="line"><span class="comment">// make symbol iterators for each</span></span><br><span class="line">ImageLoader::CoalIterator iterators[count];</span><br><span class="line">ImageLoader::CoalIterator* sortedIts[count];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line"><span class="comment">// 对需要绑定的弱符号排序</span></span><br><span class="line">imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i, imageIndexes[i]);</span><br><span class="line">sortedIts[i] = &amp;iterators[i];</span><br><span class="line"><span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind load order %d/%d for %s\n"</span>, i, count, imagesNeedingCoalescing[i]-&gt;getIndexedPath(imageIndexes[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// walk all symbols keeping iterators in sync by </span></span><br><span class="line"><span class="comment">// only ever incrementing the iterator with the lowest symbol </span></span><br><span class="line"><span class="keyword">int</span> doneCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( doneCount != count ) &#123;</span><br><span class="line"><span class="comment">//for(int i=0; i &lt; count; ++i)</span></span><br><span class="line"><span class="comment">//dyld::log("sym[%d]=%s ", sortedIts[i]-&gt;loadOrder, sortedIts[i]-&gt;symbolName);</span></span><br><span class="line"><span class="comment">//dyld::log("\n");</span></span><br><span class="line"><span class="comment">// increment iterator with lowest symbol</span></span><br><span class="line"><span class="comment">// 计算弱符号偏移量及大小，绑定弱符号</span></span><br><span class="line"><span class="keyword">if</span> ( sortedIts[<span class="number">0</span>]-&gt;image-&gt;incrementCoalIterator(*sortedIts[<span class="number">0</span>]) )</span><br><span class="line">++doneCount; </span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程：合并所有动态库的弱符号到列表中 -&gt; 对需要绑定的弱符号排序 -&gt; 计算弱符号偏移量及大小，绑定弱符号</p><h5 id="3-4-8-初始化主程序"><a href="#3-4-8-初始化主程序" class="headerlink" title="3.4.8 初始化主程序"></a>3.4.8 初始化主程序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">CRSetCrashLogMessage(<span class="string">"dyld: launch, running initializers"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line"><span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line"><span class="keyword">if</span> ( ! gRunInitializersOldWay )</span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// run all initializers</span></span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line"><span class="comment">// 通知任何监视进程，此进程将要进入main（）。</span></span><br><span class="line"><span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">notifyMonitoringDyldMain();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// record that we've reached this step。开始初始化标识</span></span><br><span class="line">gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line"><span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line"><span class="comment">// 初始化动态库</span></span><br><span class="line">sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line"><span class="comment">// 初始化主程序</span></span><br><span class="line">sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line"><span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dump info if requested</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先初始化动态库，然后初始化主程序。上文提到的 DYLD_PRINT_STATISTICS 环境变量在这里也出现了，除此之外还有个 detail 版的环境变量 <font color="#cc0000">DYLD_PRINT_STATISTICS_DETAILS</font>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::runInitializers(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程</span></span><br><span class="line"><span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">ImageLoader::UninitedUpwards up;</span><br><span class="line">up.count = <span class="number">1</span>;</span><br><span class="line">up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 在进程中初始化</span></span><br><span class="line">processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line"><span class="comment">// 初始化耗时</span></span><br><span class="line">fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/14412057&gt; upward dylib initializers can be run too soon</span></span><br><span class="line"><span class="comment">// To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs</span></span><br><span class="line"><span class="comment">// have their initialization postponed until after the recursion through downward dylibs</span></span><br><span class="line"><span class="comment">// has completed.</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::processInitializers(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span><br><span class="line"> InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">ups.count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line"><span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line"><span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line">processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态库和主程序的初始化是调用 runInitializers，内部通过 processInitializers 调用 recursiveInitialization 递归初始化当前 image 所依赖的库。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::recursiveInitialization(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span><br><span class="line">  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 递归锁</span></span><br><span class="line"><span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line"><span class="comment">// break cycles</span></span><br><span class="line"><span class="comment">// 退出递归循环</span></span><br><span class="line">fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// initialize lower level libraries first</span></span><br><span class="line"><span class="comment">// 先初始化低级别的库</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">ImageLoader* dependentImage = libImage(i);</span><br><span class="line"><span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line"><span class="comment">// 不要试图初始化级别高于我的</span></span><br><span class="line"><span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">uninitUps.images[uninitUps.count] = dependentImage;</span><br><span class="line">uninitUps.count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// record termination order. 记录终止命令</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">fState = dyld_image_state_dependents_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="comment">// 真正初始化镜像</span></span><br><span class="line"><span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">fState = dyld_image_state_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line">context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line"><span class="comment">// this image is not initialized</span></span><br><span class="line">fState = oldState;</span><br><span class="line">recursiveSpinUnLock();</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意内部有个调用 context.notifySingle(dyld_image_state_initialized, this, NULL)，其实每次 image 状态改变都会调用 notifySingle 这个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//dyld::log("notifySingle(state=%d, image=%s)\n", state, image-&gt;getPath());</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</span><br><span class="line"><span class="keyword">if</span> ( handlers != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">dyld_image_info info;</span><br><span class="line">info.imageLoadAddress= image-&gt;machHeader();</span><br><span class="line">info.imageFilePath= image-&gt;getRealPath();</span><br><span class="line">info.imageFileModDate= image-&gt;lastModified();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* result = (*it)(state, <span class="number">1</span>, &amp;info);</span><br><span class="line"><span class="keyword">if</span> ( (result != <span class="literal">NULL</span>) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</span><br><span class="line"><span class="comment">//fprintf(stderr, "  image rejected by handler=%p\n", *it);</span></span><br><span class="line"><span class="comment">// make copy of thrown string so that later catch clauses can free it</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = strdup(result);</span><br><span class="line"><span class="keyword">throw</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( state == dyld_image_state_mapped ) &#123;</span><br><span class="line"><span class="comment">// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</span></span><br><span class="line"><span class="keyword">if</span> ( !image-&gt;inSharedCache() ) &#123;</span><br><span class="line">dyld_uuid_info info;</span><br><span class="line"><span class="keyword">if</span> ( image-&gt;getUUID(info.imageUUID) ) &#123;</span><br><span class="line">info.imageLoadAddress = image-&gt;machHeader();</span><br><span class="line">addNonSharedCacheImageUUID(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line"><span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">dyld3::<span class="function">ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line"><span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line"><span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line"><span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line"><span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// mach message csdlc about dynamically unloaded images</span></span><br><span class="line"><span class="keyword">if</span> ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</span><br><span class="line">notifyKernel(*image, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">loadAddress</span>[] = &#123;</span> image-&gt;machHeader() &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* loadPath[] = &#123; image-&gt;getPath() &#125;;</span><br><span class="line">notifyMonitoringDyld(<span class="literal">true</span>, <span class="number">1</span>, loadAddress, loadPath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 state == dyld_image_state_mapped 时，将 image 对应的 UUID 存起来，当state == dyld_image_state_dependents_initialized 并且有 sNotifyObjCInit 回调时调用sNotifyObjCInit函数。</p><p>搜索回调函数赋值入口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// record functions to call</span></span><br><span class="line">    sNotifyObjCMapped   = mapped;</span><br><span class="line">    sNotifyObjCInit     = init;</span><br><span class="line">    sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">    dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是通过 _dyld_objc_notify_register 这个函数注册回调的。</p><p>[NSObject load] 的堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2</span><br><span class="line">  * frame #0: 0x000000010944f3b1 libobjc.A.dylib`+[NSObject load]</span><br><span class="line">    frame #1: 0x000000010943d317 libobjc.A.dylib`call_load_methods + 691</span><br><span class="line">    frame #2: 0x000000010943e814 libobjc.A.dylib`load_images + 77</span><br><span class="line">    frame #3: 0x0000000108b73b97 dyld_sim`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 260</span><br><span class="line">    frame #4: 0x000000010b779bf3 libdyld.dylib`_dyld_objc_notify_register + 113</span><br><span class="line">    frame #5: 0x000000010944ca12 libobjc.A.dylib`_objc_init + 115</span><br><span class="line">    frame #6: 0x000000010b7015c0 libdispatch.dylib`_os_object_init + 13</span><br><span class="line">    frame #7: 0x000000010b70f4e5 libdispatch.dylib`libdispatch_init + 300</span><br><span class="line">    frame #8: 0x0000000109e05a78 libSystem.B.dylib`libSystem_initializer + 164</span><br><span class="line">    frame #9: 0x0000000108b82b96 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 506</span><br><span class="line">    frame #10: 0x0000000108b82d9c dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40</span><br><span class="line">    frame #11: 0x0000000108b7e3fc dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 324</span><br><span class="line">    frame #12: 0x0000000108b7e392 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 218</span><br><span class="line">    frame #13: 0x0000000108b7d5d3 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 133</span><br><span class="line">    frame #14: 0x0000000108b7d665 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 73</span><br><span class="line">    frame #15: 0x0000000108b71333 dyld_sim`dyld::initializeMainExecutable() + 129</span><br><span class="line">    frame #16: 0x0000000108b75434 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4384</span><br><span class="line">    frame #17: 0x0000000108b70630 dyld_sim`start_sim + 136</span><br><span class="line">    frame #18: 0x00000001155c1234 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2238</span><br><span class="line">    frame #19: 0x00000001155bf0ce dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 522</span><br><span class="line">    frame #20: 0x00000001155ba503 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1167</span><br><span class="line">    frame #21: 0x00000001155ba036 dyld`_dyld_start + 54</span><br></pre></td></tr></table></figure><p>可以看到，_dyld_objc_notify_register 是在初始化 libobjc.A.dylib 这个动态库时调用的，然后 _objc_init 内部调用了 load_images，进而调用 call_load_methods，从而调用各个类中的load方法，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F" target="_blank" rel="noopener">Objc源码</a>。</p><p>notifySingle 调用完毕后，开始真正初始化工作 <font color="#cc0000"><code>doInitialization</code></font>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ImageLoaderMachO::doInitialization(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">    doImageInit(context);</span><br><span class="line">    doModInitFunctions(context);</span><br><span class="line">    </span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doImageInit 执行 <code>LC_ROUTINES_COMMAND</code> segment 中保存的函数，doModInitFunctions执行 __DATA,__mod_init_func section 中保存的函数。这个 section 中保存的是 C++ 的构造函数及带有 attribute((constructor)) 的 C 函数，简单验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.mm</span><br><span class="line"></span><br><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">    Test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::Test()&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test test;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) void testConstructor() &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    testConstructor();</span><br><span class="line"></span><br><span class="line">    Test * t = new Test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-19 13:26:33.587051+0800 Demo[7105:314102] testConstructor</span><br><span class="line">2019-08-19 13:26:33.587109+0800 Demo[7105:314102] Test</span><br></pre></td></tr></table></figure><p>通过 MachOView 可以看到：</p><p>显然，__mod_init_func 中的函数在类对应的 load 方法之后调用。</p><ol><li>对于 dumpdcrypted 这一类注入方法实现功能的插件，他们添加的静态方法会在 doModInitFunctions方法中被解析出来，位置在 MachO 文件的 __DATA 段的 __mod_init_func section。C++ 的全局对象也会出现在这个section中。</li><li>在递归初始化 (recursiveInitialization）中，如果当前执行的是主程序 image，doInitialization 完毕后会执行 notifySingle 方法去通知观察者。在 doInitialization 方法前会发送 state 为 dyld_image_state_dependents_initialized 的通知，由这个通知，会调用 libobjc 的 load_images，最后去依次调用各个 OC 类的 load 方法以及分类的 load 方法。</li><li><p>Objective-C 的入口方法是 _objc_init，dyld 唤起它的执行路径是从 runInitializers -&gt; recursiveInitialization -&gt; doInitialization -&gt; doModInitFunctions -&gt;.. _objc_init。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;       </span><br><span class="line"><span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">_dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                         <span class="number">1</span><span class="comment">/*batch*/</span>, &amp;map_2_images);</span><br><span class="line">dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>_objc_init 会在 dyld 中注册两个通知，对应的回调会分别执行将 OC 类加载到内存和调用 load 方法的操作。后面的就是 OC 类加载的经典方法 map_2_images 了。</p></li><li><p>从 recursiveInitialization 的以下代码片段可以看出 load 是在全局实例或者方法调用前被触发的。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"><span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">fState = dyld_image_state_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line">context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-4-9-查找主程序入口函数指针并返回"><a href="#3-4-9-查找主程序入口函数指针并返回" class="headerlink" title="3.4.9 查找主程序入口函数指针并返回"></a>3.4.9 查找主程序入口函数指针并返回</h5><p>调用getEntryFromLC_MAIN 获取主程序 main 函数的地址，如果未找到则调用getEntryFromLC_UNIXTHREAD 获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_MAIN() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="keyword">char</span>*)fMachOData);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">"LC_MAIN entryoff is out of range"</span>;</span><br><span class="line">&#125;</span><br><span class="line">cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ( cmd-&gt;cmd == LC_UNIXTHREAD ) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">i386_thread_state_t</span>* registers = (<span class="keyword">i386_thread_state_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;eip + fSlide);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">x86_thread_state64_t</span>* registers = (<span class="keyword">x86_thread_state64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;rip + fSlide);</span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __arm64__ &amp;&amp; !__arm64e__</span></span><br><span class="line"><span class="comment">// temp support until &lt;rdar://39514191&gt; is fixed</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span>* regs64 = (<span class="keyword">uint64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line"><span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(regs64[<span class="number">32</span>] + fSlide); <span class="comment">// arm_thread_state64_t.__pc</span></span><br><span class="line"><span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"no valid entry point"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，入口是在 load_command 的 LC_MAIN 或者 LC_UNIXTHREAD 中 LC_MAIN。</p><h2 id="四、dyld-闭包"><a href="#四、dyld-闭包" class="headerlink" title="四、dyld 闭包"></a>四、dyld 闭包</h2><p>在第 2 步和第 3 步之间有一个查找闭包并以其结果作为程序入口返回的代码，这里是 <a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">WWDC 2017</a> 推出的 dyld3 中提出的一种优化 App 启动速度的技术。大致步骤如下：</p><ol><li>如果满足条件：开启闭包（DYLD_USE_CLOSURES 环境变量为 1），App 的路径在白名单中（目前只有系统 Ap p享有使用闭包的特权），共享缓存加载地址不为空，则往下执行。</li><li>去内存中查找闭包数据，这里的方法是 findClosure。如果内存中不存在，再去 <code>/private/var/staged_system_apps</code> 路径下去查找硬盘数据，找到就返回结果。</li><li>如果没有闭包数据，就会调用 socket 通信走 RPC 去获取闭包数据，执行方法为 callClosureDaemon，感兴趣可以研究下。</li><li>如果闭包数据不为空，就会走核心方法：launchWithClosure，基于闭包去启动 App，并且返回该方法中获取的程序入口地址给外界。这个方法重复了上面的各个步骤。具体实现和内部的数据结构有待分析。</li></ol><h2 id="五、共享缓存机制"><a href="#五、共享缓存机制" class="headerlink" title="五、共享缓存机制"></a>五、共享缓存机制</h2><p>在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个一个加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到 <font color="#cc0000"><code>/System/Library/Caches/com.apple.dyld/</code></font> 目录下，按不同的架构保存分别保存着，原作者的 iPhone6 里面就有 dyld_shared_cache_armv7s 和 dyld_shared_cache_armv64 两个文件，如下图所示。</p><p>想要分析某个系统库，就需要从 dyld_shared_cache 里先将的原始二进制文件提取出来，这里从易到难提供 3 种方法：</p><h4 id="5-1-dyld-cache-extract-提取"><a href="#5-1-dyld-cache-extract-提取" class="headerlink" title="5.1 dyld_cache_extract 提取"></a>5.1 dyld_cache_extract 提取</h4><p><a href="https://github.com/macmade/dyld_cache_extract" target="_blank" rel="noopener">dyld_cache_extract</a> 是一个可视化的工具，使用极其简单，把 dyld_shared_cache 载入即可解析出来，如下图所示。</p><h4 id="5-2-jtool-提取"><a href="#5-2-jtool-提取" class="headerlink" title="5.2 jtool 提取"></a>5.2 jtool 提取</h4><p>以提取 CFNetwork 为例，使用如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jtool -extract CFNetwork ./dyld_shared_cache_arm64</span><br></pre></td></tr></table></figure><h4 id="5-3-dsc-extractor-提取"><a href="#5-3-dsc-extractor-提取" class="headerlink" title="5.3 dsc_extractor 提取"></a>5.3 dsc_extractor 提取</h4><p>在 dyld 源代码的 launch-cache 文件夹里面找到 dsc_extractor.cpp，将 653 行的“#if 0”修改为“#if 1”，然后用如下命令编译生成 dsc_extractor，并使用它提取所有缓存文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ dsc_extractor.cpp dsc_iterator.cpp  -o dsc_extractor</span><br><span class="line">$ ./dsc_extractor ./dyld_shared_cache_arm64 ./</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>每个 MachO 都会由一个 imageLoader 来处理加载和依赖管理的操作，这里是由 dyld 来安排。主程序 app 的 image 的加载是由内核来完成的。其他的动态库的加载细节可以参考上面提到的 link 方法实现，当一个 image 加载完毕，dyld 会发送 dyld_image_state_bound 通知；著名的 hook 工具 fishhook 的实现原理也是借助监听这个通知，在回调里完成 hook 操作的。</p><h2 id="七、文章"><a href="#七、文章" class="headerlink" title="七、文章"></a>七、文章</h2><p><a href="https://www.jianshu.com/u/02a488e1e71e" target="_blank" rel="noopener">01_Jack</a> &amp; <a href="https://www.jianshu.com/p/82e6fdaa0e41" target="_blank" rel="noopener">dyld源码解读</a><br><a href="https://me.csdn.net/lovechris00" target="_blank" rel="noopener">伊织__</a> &amp; <a href="https://blog.csdn.net/lovechris00/article/details/81561627#otool_0" target="_blank" rel="noopener">Mac - otool</a><br><a href="https://www.jianshu.com/u/3b5a95e93778" target="_blank" rel="noopener">RemisKrlet</a> &amp; <a href="https://www.jianshu.com/p/72e34948dac0" target="_blank" rel="noopener">App启动过程 - dyld加载动态库</a><br><a href="https://www.dllhook.com/post/238.html" target="_blank" rel="noopener">dyld详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。&lt;/p&gt;
&lt;bloc
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>终端</title>
    <link href="http://yoursite.com/2019/08/06/%E5%B7%A5%E5%85%B7/%E7%BB%88%E7%AB%AF/"/>
    <id>http://yoursite.com/2019/08/06/工具/终端/</id>
    <published>2019-08-06T05:54:23.090Z</published>
    <updated>2019-08-31T07:24:51.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、github-clone-提速"><a href="#1、github-clone-提速" class="headerlink" title="1、github clone 提速"></a>1、github clone 提速</h2><h4 id="1-1-修改-hosts-文件"><a href="#1-1-修改-hosts-文件" class="headerlink" title="1.1 修改 hosts 文件"></a>1.1 修改 hosts 文件</h4><ol><li><p>在 <a href="https://www.ipaddress.com/" target="_blank" rel="noopener">IPAddress.com</a> 网站中中分别查询 <code>https://www.github.com</code> 和 <code>github.global.ssl.fastly.net</code> 域名的 IP 地址。</p> <center><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubIPSearch.png" alt><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubIP.png" alt><br> <img src="http://pugqga7mf.bkt.clouddn.com/GithubSSLIP.png" alt><br> </center></li><li><p>打开的 hosts 文件</p></li></ol><p>【Windows】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\host</span><br></pre></td></tr></table></figure><p>【Mac】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/hosts</span><br></pre></td></tr></table></figure><center><br><img src="http://pugqga7mf.bkt.clouddn.com/ViHosts.png" alt><br><img src="http://pugqga7mf.bkt.clouddn.com/EditHosts.png" alt><br></center><p><a href="https://www.jianshu.com/p/8577c9401fe1" target="_blank" rel="noopener">更多阅读</a></p><blockquote><p>重启 Finder 进程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ $ killall Finder</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、github-clone-提速&quot;&gt;&lt;a href=&quot;#1、github-clone-提速&quot; class=&quot;headerlink&quot; title=&quot;1、github clone 提速&quot;&gt;&lt;/a&gt;1、github clone 提速&lt;/h2&gt;&lt;h4 id=&quot;1-1-修
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode</title>
    <link href="http://yoursite.com/2019/08/06/%E5%B7%A5%E5%85%B7/Xcode/"/>
    <id>http://yoursite.com/2019/08/06/工具/Xcode/</id>
    <published>2019-08-06T05:35:43.506Z</published>
    <updated>2019-09-03T09:11:21.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、整行上下移动"><a href="#一、整行上下移动" class="headerlink" title="一、整行上下移动"></a>一、整行上下移动</h2><p>Xcode 自带的配置文件路径：/Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Versions/A/Resources/IDETextKeyBindingSet.plist，用文本编辑 IDETextKeyBindingSet.plist，并添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;GDI Commands&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">       &lt;key&gt;GDI Duplicate Current Line&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, copy:, moveToEndOfLine:,insertNewline:, paste:, deleteBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Delete Current Line&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveToEndOfLine:, deleteToBeginningOfLine:,deleteBackward:,moveDown:,moveToEndOfLine:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Move Current Line Up&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, cut:, moveUp:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Move Current Line Down&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;selectLine:, cut:, moveDown:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Insert Line Above&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveUp:, moveToEndOfLine:, insertNewline:&lt;/string&gt;</span><br><span class="line">       &lt;key&gt;GDI Insert Line Below&lt;/key&gt;</span><br><span class="line">       &lt;string&gt;moveToEndOfLine:, insertNewline:&lt;/string&gt;</span><br><span class="line">   &lt;/dict&gt;</span><br></pre></td></tr></table></figure><p><font color="#cc0000">注意</font>：Xcode.app 需要换成实际的应用名，如 Xcode10.1.app。</p><p>详细文章：<a href="https://www.cnblogs.com/goodboy-heyang/p/4732365.html" target="_blank" rel="noopener">xcode 设置快捷键 整行上下移动</a></p><h2 id="二、Other-linker-flags"><a href="#二、Other-linker-flags" class="headerlink" title="二、Other linker flags"></a>二、Other linker flags</h2><p>Other linker flags 用来填写 XCode 的<font color="#cc0000">链接器参数</font>。</p><p>从 C 代码到可执行文件经历的步骤是：</p><blockquote><p>源代码 -&gt; 预处理器 -&gt; 编译器 -&gt; 汇编器 -&gt; 机器码 -&gt; 链接器 -> 可执行文件</p></blockquote><p>在最后一步需要<font color="#cc0000">把 .o 文件和 C 语言运行库链接起来</font>，这时候需要用到 <font color="#cc0000">ld</font> 命令。</p><p>源文件经过一系列处理以后，会生成对应的 <font color="#cc0000">.obj</font> 文件，然后一个项目必然会有许多 .obj 文件，并且这些文件之间会有各种各样的联系，例如函数调用。<font color="#cc0000">链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件</font>。</p><p>Other linker flags 设置的值<font color="#cc0000">实际上就是 ld 命令执行时后面所加的参数</font>。</p><blockquote><p>The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. </p><p>运行时的异常是由于标准 XNIX 静态库、链接器与 OC 语言的动态的特性之间的问题，OC 语言并不是对每一个函数或者方法建立链接器符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不知道将核心类与分类之间的代码实现联系起来，这就导致最终的应用程序中的可执行文件缺失了分类中的代码，这样函数调用就失败了。</p></blockquote><p>常用参数：</p><ul><li><p>－ObjC</p><p>  链接器就会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中。</p><p>  这样编译之后的 app 会变大，因为加载了很多不必要的文件而导致可执行文件变大。但是如果静态库中有类和 category 的话只有加入这个 flag 才行。但是 Objc 也不是万能的，当静态库中只有分类而没有类的时候，Objc 就失效了，这就需要使用 -all_load 或者 -force_load 了。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyStaticLib</span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;sssss&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyStaticLib (Cate)</span><br><span class="line">/**</span><br><span class="line"> * 重写方法</span><br><span class="line"> */</span><br><span class="line">+ (void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;哈哈哈&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><pre><code>静态库中分类重写了方法，导入工程中，设置 -Objc 参数将打印：哈哈哈；不设置将打印：sssss。</code></pre><ul><li><p>－all_load</p><p>  会让链接器把所有找到的目标文件都加载到可执行文件中，即使没有 objc 代码。但是这个参数也有一个弊端，假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到 <font color="#cc0000">ld: duplicate symbol</font> 错误，因为不同的库文件里面可能会有相同的目标文件，有两种方法解决：1、用命令行进行拆包；2、使用 -force_load 参数。</p></li><li><p>-force_load</p><p>  适用于 Xcode3.2+ 版本，它允许 finer 得到文档加载的控制，所做的事情跟 -all_load 其实是一样的，但是每一个 -force_load 操作必须跟着一个文档路径，文档中的每一个对象文件将会被加载，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</p></li><li><p>-lstdc++</p><p>  OC 和 C++ 混编时，在 Compile 阶段一切顺利，Clang 会根据后缀（.m .cpp）选择编译器进行编译，产物都是 Object File（.o 文件）。如果一个文件调用另一个文件的方法，编译出的 Object File 中会出现 undefined symbol 去代表这个方法。在链接阶段，Linker 通过把依赖的文件也加到最终的 executable 中 resolve undefined symbol。</p><p>  Linker 没有主动的去 link stdc++ 库，解决方案 1：在 Other Linker Flags 中新增标志 -lstdc++；解决方案2：在 Linked Framework and Libraries 中添加 libstdc++.tbd。</p></li><li><p>总结：</p><p>  建议 -ObjC 与 -force_load 搭配使用比较好。</p><p>  包含静态库时需要在 Target 的 Other linker flags 里面加上值：-objC、-all_load、-force_load</p><p>  对于 64 位机器和 iPhone O S应用，解决方法是使用 -all_load 或者 -force_load。</p></li><li><p>文章：</p><p>  <a href="https://blog.csdn.net/bobo553443/article/details/78633340" target="_blank" rel="noopener">Xcode 中 other linker flags 的作用</a><br>  <a href="https://blog.csdn.net/fly1183989782/article/details/80558831" target="_blank" rel="noopener">当我们在设置 Other Linker Flags -lstdc++时，我们到底在设置什么？</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、整行上下移动&quot;&gt;&lt;a href=&quot;#一、整行上下移动&quot; class=&quot;headerlink&quot; title=&quot;一、整行上下移动&quot;&gt;&lt;/a&gt;一、整行上下移动&lt;/h2&gt;&lt;p&gt;Xcode 自带的配置文件路径：/Applications/Xcode.app/Conten
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计策略</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/08/06/算法/算法设计策略/</id>
    <published>2019-08-05T16:07:52.660Z</published>
    <updated>2019-08-05T16:07:52.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、分治"><a href="#一、分治" class="headerlink" title="一、分治"></a>一、分治</h2><h4 id="1-1-基本思想"><a href="#1-1-基本思想" class="headerlink" title="1.1 基本思想"></a>1.1 基本思想</h4><blockquote><p>将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，<font color="#cc0000">分而治之</font>。</p></blockquote><p>能用分治法的基本特征：</p><p>①、问题缩小到一定规模容易解决</p><p>②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想）</p><p>③、分解而成的小问题在解决之后要可以合并</p><p>④、子问题是相互独立的，即子问题之间没有公共的子问题</p><font color="#cc0000">第 ③ 条是能分治的关键</font>。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。<br><br>如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。<br><br>分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。<br><br>根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。<br><br>#### 1.2 分治步骤<br><br>①、分解成很多子问题<br><br>②、解决这些子问题<br><br>③、将解决的子问题合并从而解决整个大问题<br><br>化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。<br><br>它的一般的算法设计模式如下：<br><br>Divide-and-Conquer(P)<br><br>1.   if |P|≤n0<br>2.   then return(ADHOC(P))<br>3.   将 P 分解为较小的子问题 P1, P2, …, Pk<br>4.   for i←1 to k<br>5.   do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi<br>6.   T ← MERGE(y1,y2,…,yk) △ 合并子问题<br>7.   return(T)<br><br><br>#### 1.3 分类<br><br>根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形：<br><br>1.   原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可；<br>2.   原始问题的解需要由各个子问题的解再经过综合处理得到。<br><br>#### 1.4 效果<br><br>适当运用分治策略往往可以<font color="#cc0000">较快地缩小问题求解的范围</font>，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。<br><br>分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好<font color="#cc0000">符合递归的特性</font>。<br><br>因此，计算机算法中的分治策略往往与递归联系在一起。<br><br>#### 1.5 算法的典型应用<br><br>    ①、MAXMIN问题<br><br>    ②、二分搜索<br><br>    ③、归并排序<br><br>    ④、寻找第 K 小的元素<br><br>    ⑤、大整数的乘法<br><br>    ⑥、Strassen 矩阵乘法<br><br>    ⑦、快速排序<br><br>    ⑧、二叉树遍历<br><br>    ⑨、棋盘覆盖<br><br>    ⑩、线性时间选择<br><br>最接近点对问题<br><br>循环赛日程表<br><br>汉诺塔。。。<br><br>#### 1.6 依据分治法设计程序时的思维过程<br><br>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。<br><br>①、一定是先找到最小问题规模时的求解方法；<br>②、然后考虑随着问题规模增大时的求解方法；<br>③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。<br><br><br>文章：<a href="https://blog.csdn.net/effective_coder/article/details/8697789" target="_blank" rel="noopener">分治算法详解</a><br><br><br>## 二、减治<br><br>#### 2.1 基本思想<br><br>减治技术利用了一种关系：<font color="#cc0000">一个问题给定实例的解和同样问题较小实例的解之间的关系</font>。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡）<br><br>有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫<font color="#cc0000">增量法</font>。<br><br>一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。<br><br>#### 2.2 分类<br><br>减治法有 3 种主要的变种：<br><br>1.   减去一个常量<br>2.   减去一个常数因子<br>3.   减去的规模是可变的<br><br>#### 2.3 减去一个常量<br><br>每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。<br><br>函数 f(n) = a<sup>n</sup> 可以用一递归定义来计算<br><br>f(n) = f(n-1) * a   <font color="#067500">如果 n &gt; 1</font><p>f(n) = a          <font color="#067500">如果 n = 1</font></p><p>虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！</p><h4 id="2-4-减去常量因子"><a href="#2-4-减去常量因子" class="headerlink" title="2.4 减去常量因子"></a>2.4 减去常量因子</h4><p>每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。</p><p>计算 a<sup>n</sup> 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 a<sup>n/2</sup> 的值；它们之间有着明显的关系： a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>。</p><p>a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup>                       n 是正偶数</p><p>a<sup>n</sup> = (a<sup>(n-1)/2</sup>)<sup>2</sup> * a     n 是大于 1 的奇数，先提出一个 a 来再减半</p><p>a<sup>n</sup> = a               n = 1</p><p>上式递归根据所做的乘法次数来度量效率，该算法属于 <font color="#cc0000">O(log n)</font>;</p><p>因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。</p><h4 id="2-5-减可变规模"><a href="#2-5-减可变规模" class="headerlink" title="2.5 减可变规模"></a>2.5 减可变规模</h4><p>每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法</p><h4 id="2-6-算法思想的典型应用"><a href="#2-6-算法思想的典型应用" class="headerlink" title="2.6 算法思想的典型应用"></a>2.6 算法思想的典型应用</h4><p>减去一个常量：</p><pre><code>①、插入排序③、深度优先查找④、广度优先查找⑤、拓扑排序（源删除法对无环有向图进行拓扑排序）⑥、生成排列⑦、生成子集</code></pre><p>减去常量因子：</p><pre><code>①、折半查找②、假币问题③、俄式乘法④、约瑟夫斯问题</code></pre><p>减可变规模</p><pre><code>①、插值查找、二叉查找树②、欧几里得算法，随着不断求余，n 越来越小</code></pre><h2 id="三、分治减治区别"><a href="#三、分治减治区别" class="headerlink" title="三、分治减治区别"></a>三、分治减治区别</h2><p>分治法：求解多个子问题（每个子问题都需要求解），<font color="#cc0000">合并</font>子问题的解。</p><p>减治法：求解一个子问题（子问题只需要求解一次），<font color="#cc0000">扩展</font>子问题的解。</p><p>求 a<sup>n</sup>。</p><p>分治法：a<sup>(n/2)</sup> * a<sup>(n/2)</sup> 则左右两个 a<sup>(n/2)</sup> 均需要求解，所以时间复杂度为 O(n)。<br>减治法：(a<sup>(n/2)</sup>)<sup>2</sup> 则只需要求 a<sup>(n/2)</sup> 再平方即可，所以时间复杂度为 O(lgn)。</p><p>也就是说<strong>分治法</strong>是分解的部分需要进行分开的单独计算（需要计算两遍），而<strong>减治法</strong>则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量<strong>。</strong></p><h2 id="四、变治"><a href="#四、变治" class="headerlink" title="四、变治"></a>四、变治</h2><p>基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据<font color="#cc0000">对问题实例的变换方式</font>，变治思想有 3 种主要类型：</p><ul><li>变换为同样问题的一个更简单或者更方便的实例：<strong>实例化简</strong>；</li><li>变换为同样实例的不同表现：<strong>改变表现</strong>；</li><li>变换为另一个问题的实例， 这种问题的算法是已知的：<strong>问题化简</strong>。</li></ul><p>基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。</p><h4 id="4-1-实例化简"><a href="#4-1-实例化简" class="headerlink" title="4.1 实例化简"></a>4.1 实例化简</h4><pre><code>①、检验数组中元素的唯一性（预排序）②、模式计算（预排序）③、AVL 树</code></pre><h4 id="4-2-改变表现"><a href="#4-2-改变表现" class="headerlink" title="4.2 改变表现"></a>4.2 改变表现</h4><pre><code>①、2-3 树、2-3-4 树（二叉排序树）②、堆和堆排序（利用最大/小堆总是找到最大/小值）③、霍纳法则（多项式的计算）④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组）</code></pre><h4 id="4-3-问题化简"><a href="#4-3-问题化简" class="headerlink" title="4.3 问题化简"></a>4.3 问题化简</h4><pre><code>①、背包问题（线性规划）</code></pre><h2 id="五、动态规划"><a href="#五、动态规划" class="headerlink" title="五、动态规划"></a>五、动态规划</h2><p>将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往<font color="#cc0000">不是相互独立的</font>。这种情况下若用分治法会对一些子问题进行<font color="#cc0000">多次求解</font>，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。</p><p>动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质：</p><ol><li><p>最优子结构性质</p><p> 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。</p><p> 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。</p></li><li><p>子问题重叠性质</p><p> 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。</p></li></ol><p>用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法：</p><p>①、自底向上递归法</p><p>利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><p>②、自顶向下递归法（即备忘录法）</p><p>利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。</p><p>当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。</p><p>文章：<a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html" target="_blank" rel="noopener">动态规划：从新手到专家</a></p><h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单<font color="#cc0000">更直接效率更高</font>的算法：贪心法。</p><p>贪心法总是做出在<font color="#cc0000">当前</font>看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。</p><p>贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质：</p><ol><li><p>贪心选择性质</p><p> 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。</p><p> 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。</p></li><li><p>最优子结构性质</p><p> 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。</p></li></ol><p>贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。</p><h2 id="七、回溯"><a href="#七、回溯" class="headerlink" title="七、回溯"></a>七、回溯</h2><p>回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。</p><p>回溯法通常的解题步骤如下：</p><p>①、定义问题的解空间。</p><p>②、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。</p><p>③、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。</p><p>用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h)</p><p>用回溯法解题时，常会遇到以下两类典型的解空间树：</p><p>(1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><p>回溯法中的剪枝函数通常分为两类：</p><p>(1)、用约束函数在指定节点处剪去不满足约束的子树，例如 <a href="http://www.cnblogs.com/laifeiyao/p/3481800.html" target="_blank" rel="noopener">0-1背包问题</a></p><p>(2)、用限界函数在指定节点处剪去得不到最优解的子树，例如<a href="http://www.cnblogs.com/laifeiyao/p/3492758.html" target="_blank" rel="noopener">回溯法解旅行推销员问题</a></p><h2 id="八、分支限界"><a href="#八、分支限界" class="headerlink" title="八、分支限界"></a>八、分支限界</h2><p>回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。</p><p>分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。</p><h2 id="九、学习文章"><a href="#九、学习文章" class="headerlink" title="九、学习文章"></a>九、学习文章</h2><p><a href="https://www.cnblogs.com/laifeiyao/" target="_blank" rel="noopener">姚来飞的博客</a> &amp; <a href="https://www.cnblogs.com/laifeiyao/p/3476258.html" target="_blank" rel="noopener">常见的算法设计策略</a></p><p><a href="https://www.cnblogs.com/lsgxeva/p/7800564.html" target="_blank" rel="noopener">算法设计之五大常用算法设计方法总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、分治&quot;&gt;&lt;a href=&quot;#一、分治&quot; class=&quot;headerlink&quot; title=&quot;一、分治&quot;&gt;&lt;/a&gt;一、分治&lt;/h2&gt;&lt;h4 id=&quot;1-1-基本思想&quot;&gt;&lt;a href=&quot;#1-1-基本思想&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>重构 AppDelegate</title>
    <link href="http://yoursite.com/2019/08/06/iOS/iOS%E4%BC%98%E5%8C%96/%E9%87%8D%E6%9E%84AppDelegate/"/>
    <id>http://yoursite.com/2019/08/06/iOS/iOS优化/重构AppDelegate/</id>
    <published>2019-08-05T16:07:52.660Z</published>
    <updated>2019-08-05T16:07:52.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Massive-AppDelegate"><a href="#一、Massive-AppDelegate" class="headerlink" title="一、Massive AppDelegate"></a>一、Massive AppDelegate</h2><blockquote><p>AppDelegate 是应用程序的根对象，<font color="#cc0000">它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互</font>，通常被认为是每个 iOS 项目的核心。</p></blockquote><p>随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。</p><p>在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的<font color="#cc0000">简洁和清晰</font>对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。</p><p>AppDelegate 常见的业务代码如下：</p><ul><li>日志埋点统计数据分析</li><li>初始化数据存储系统</li><li>配置 UIAppearance</li><li>管理 App Badge 数字</li><li>管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分</li><li>管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换</li><li>管理 UserDefaults：设置首先启动标志，保存和加载数据</li><li>管理后台任务</li><li>管理设备方向</li><li>更新位置信息</li><li>初始化第三方库（如分享、日志、第三方登陆、支付）</li></ul><p>这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。</p><p>看看以下可能的解决方案，每个 Recipe（方案）<font color="#cc0000">遵循单一职责、易于扩展、易于测试原则</font>。</p><h2 id="二、命令模式-Command-Design-Pattern"><a href="#二、命令模式-Command-Design-Pattern" class="headerlink" title="二、命令模式 Command Design Pattern"></a>二、命令模式 Command Design Pattern</h2><blockquote><p>命令模式是一种数据驱动的设计模式，属于行为型模式。</p></blockquote><p>请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。</p><p>可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 命令协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Command</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)execute;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeThirdPartiesCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化主视图</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeRootViewControllerCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIWindow</span> * keyWindow;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 初始化视图全局配置</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">InitializeAppearanceCommand</span> : <span class="title">NSObject</span> &lt;<span class="title">Command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// ...</span></span><br></pre></td></tr></table></figure><p>然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">StartupCommandsBuilder</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组，元素为遵守 Command 协议的对象</span></span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;Command&gt;&gt; *)build</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> @[ [InitializeAppearanceCommand new], </span><br><span class="line">              [InitializeRootViewControllerCommand new], </span><br><span class="line">              [InitializeThirdPartiesCommand new] ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;    </span><br><span class="line">    [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(<span class="keyword">id</span>&lt;Command&gt; _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        [obj execute];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="三、组合设计模式-Composite-Design-Pattern"><a href="#三、组合设计模式-Composite-Design-Pattern" class="headerlink" title="三、组合设计模式 Composite Design Pattern"></a>三、组合设计模式 Composite Design Pattern</h2><blockquote><p>组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。</p></blockquote><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于<font color="#cc0000">结构型模式</font>，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。</p><p>这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 组装类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CompositeAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CompositeAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefault</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里要实现单例</span></span><br><span class="line">    <span class="keyword">return</span> [[CompositeAppDelegate alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>实现执行具体职责的叶子类。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 叶子类。推送消息处理</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushNotificationAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 叶子类。初始化第三方库</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PushNotificationAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"PushNotificationAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ThirdPartiesConfiguratorAppDelegate</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ThirdPartiesConfiguratorAppDelegate"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。</p><h2 id="四、中介者模式-Mediator-Design-Pattern"><a href="#四、中介者模式-Mediator-Design-Pattern" class="headerlink" title="四、中介者模式 Mediator Design Pattern"></a>四、中介者模式 Mediator Design Pattern</h2><blockquote><p>中介者模式是用来降低多个对象和类之间的通信复杂性。</p></blockquote><p>这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于<font color="#cc0000">行为型模式</font>。</p><p>如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。</p><p>让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">APPLifeCycleMediator</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">APPLifeCycleMediator</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; * _listeners;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithListeners:(<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;AppLifeCycleListener&gt;&gt; *)listeners</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        _listeners = listeners;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppWillEnterForeground)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationWillEnterForegroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidEnterBackgroud)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                                 selector:<span class="keyword">@selector</span>(onAppDidFinishLaunching)</span><br><span class="line">                                                     name:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span></span><br><span class="line">                                                   object:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义好静态类方法，初始化所有监听者</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)makeDefaultMediator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> APPLifeCycleMediator * mediator;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mediator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">1</span>] onAppWillEnterForeground];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    [_listeners[<span class="number">0</span>] onAppDidEnterBackgroud];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>定义 AppLifecycleListener 协议，以及协议的的实现者。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 监听协议</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AppLifeCycleListener</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud;</span><br><span class="line">- (<span class="keyword">void</span>)onAppDidFinishLaunching;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VideoListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SocketListener</span> : <span class="title">NSObject</span> &lt;<span class="title">AppLifeCycleListener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">VideoListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppDidEnterBackgroud</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"停止视频播放"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SocketListener</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onAppWillEnterForeground</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"开启长链接"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>加入到 AppDelegate 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [APPLifeCycleMediator makeDefaultMediator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。</p><p>通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。</p><p>这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。</p><h2 id="六、学习文章"><a href="#六、学习文章" class="headerlink" title="六、学习文章"></a>六、学习文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247484070&amp;idx=1&amp;sn=8f784d2931c90bbc10c1d07bb634f01d&amp;chksm=a6f95840918ed156b8333751242eab54caacc5502af2e177018f0fc9df8f8955cee36e92eaf8&amp;mpshare=1&amp;scene=23&amp;srcid=1201w1cWjo0tBpIGir7EcNQD#rd" target="_blank" rel="noopener">最佳实践：重构AppDelegate</a></p><p><a href="https://www.vadimbulavin.com/refactoring-massive-app-delegate/" target="_blank" rel="noopener">Refactoring Massive App Delegate</a></p><p><a href="https://github.com/GesanTung/iOSTips" target="_blank" rel="noopener">iOSTips</a></p><p>OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》</p><p> Swift 设计模式：《<a href="http://mp.weixin.qq.com/s?__biz=MjM5NTQ2NzE0NQ==&amp;mid=2247483977&amp;idx=1&amp;sn=5994f8456884df158e7263be8179b79f&amp;chksm=a6f958af918ed1b92625986d22a19e7ddaf85367386b9edf19b93e8ce836f83e0c5556997d13&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Design_Patterns_by_Tutorials_v0.9.1</a>》</p><p>重构：《重构改善既有代码的设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Massive-AppDelegate&quot;&gt;&lt;a href=&quot;#一、Massive-AppDelegate&quot; class=&quot;headerlink&quot; title=&quot;一、Massive AppDelegate&quot;&gt;&lt;/a&gt;一、Massive AppDelegate&lt;/
      
    
    </summary>
    
      <category term="iOS优化" scheme="http://yoursite.com/categories/iOS%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>第 k 小的数</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%AC%AC%20k%20%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://yoursite.com/2019/08/06/算法/第 k 小的数/</id>
    <published>2019-08-05T16:07:52.659Z</published>
    <updated>2019-08-05T16:07:52.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、寻找两个有序数组的中位数"><a href="#一、寻找两个有序数组的中位数" class="headerlink" title="一、寻找两个有序数组的中位数"></a>一、<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></h2><h4 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p>给定两个大小为 m 和 n 的不同时为空的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><h4 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h4><p>题目要求的时间复杂度是 O(log(m + n))，要产生这样级别的时间复杂度只有采用二分查找法，用分治递归的思路来考虑这个问题。</p><p>需要转换题目中求中位数的问题为求第 k 小数的问题。如果 m + n 是奇数，那么寻找第 <font color="#cc0000">k = (m + n)/2 + 1</font> 小的数即可；如果长度和是偶数，那么我们还需要寻找第 (m + n)/2 小的数，然后计算两数的平均值。</p><p>在求解整个问题的过程中，我们始终需要考虑一个很重要的问题–<font color="#cc0000">数组索引越界问题</font>。</p><p>下面将详细地分析整个递归流程。</p><p>①、首先定义递归函数的作用：寻找两个有序数组 nums1 数组中 [L1, R1] 范围内和 nums2 数组 [L2, R2] 范围内第 k 小的数，k 从 1开始计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  L1   nums1数组的寻找范围的左边界</span></span><br><span class="line"><span class="comment"> *  R1   nums1数组的寻找范围的右边界</span></span><br><span class="line"><span class="comment"> *  L2   nums2数组的寻找范围的左边界</span></span><br><span class="line"><span class="comment"> *  R2   nums2数组的寻找范围的右边界</span></span><br><span class="line"><span class="comment"> *  k    需要寻找第k小的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2, <span class="keyword">int</span> k)</span></span></span><br></pre></td></tr></table></figure><p>②、用 len1 = R1 - L1 + 1 来记录 nums1 数组中寻找范围的长度，用 len2 = R2 - L2 + 1 来记录 nums2 数组中寻找范围的长度。</p><p>③、如果要寻找的 k &gt; len1 + len2，就像只有 3 个数字要找第 4 小的数一样，超出寻找区域，显然无法找到。</p><p>④、递归的终止条件：</p><ol><li><p>当 len1 = 0 时，说明只有 nums2 数组中有元素，直接取 nums2[L2 + k - 1] 位元素即可。</p></li><li><p>当 k = 1 时，说明要取的是两个有序数组中的最小值 MIN(nums1[L1], nums2[L2])。</p></li></ol><p>⑤、递归过程：</p><p>由于要求的是第 k 小的数，而且是在两个有序数组中求。划分两个数组时按照 k 值来分。取变量 i = MIN(len1, k/2)，之所以这么取，是为了防止 L1 + k/2 - 1 &gt; len1 导致从 nums1 取值越界。再取变量 j = MIN(len2, k/2)。</p><p>接下来比较 nums1[L1 + i - 1] 和 nums2[L2 + i - 1] 这两个值。</p><p>如果 nums1[L1 + i - 1] &lt;= nums2[L2 + j - 1]，<font color="#cc0000">显然 nums1 数组中索引为 L1 + i - 1 及之前的元素不可能是中位数</font>，去除 nums1 数组中 [L1, L1 + i - 1] 范围内的元素，缩小了查找范围。我们递归调用该函数，此时在 nums1 中的查找范围变成了 nums1[L1 + i, R1]，此时要找的也不应该是第 k 小的元素，因为<font color="#cc0000">已经剔除了 i 个比 k 小的元素</font>，因此我们要找的元素变成了第 k - i 小的元素。</p><p>如果 nums1[L1 + i - 1] &gt; nums2[L2 + j - 1]，同理，nums2 数组中索引为 L2 + j - 1 及之前的元素不可能是中位数，缩小查找范围，剔除了 j 个比 k 小的元素，因此我们要找的元素变成了第 k - j 小的元素。</p><blockquote><p>因为 i + j = MIN(len1, k/2) + MIN(len2, k/2) &lt;= k，所以可以直接判断 [L1, L1 + i - 1] 或者 [L2, L2 + j -1] 区间的元素不可能是中位数。 </p></blockquote><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-19b4f9b39cfc6c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center><p>总结：<font color="#cc0000">算法的思想是不断的剔除数据，逐渐逼近第 k 小的数</font>。</p><h2 id="3、时间复杂度"><a href="#3、时间复杂度" class="headerlink" title="3、时间复杂度"></a>3、时间复杂度</h2><p>假设数组长度足够长，每次剔除的元素都是 k/2(i 或者j)，显然我们需要 log(k) 次才能找到第 k 小数，这和二分查找法是同理的，而我们要找的 k 值要么是 (m + n)/2 + 1，要么额外再加上 (m + n)/2，因此时间复杂度是 O(log(m + n)) 级别的。</p><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a, b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> left1, <span class="keyword">int</span> right1, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> left2, <span class="keyword">int</span> right2, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = right1 - left1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = right2 - left2 + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归退出条件</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt; n1 + n2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 实际上 k 不会小于 n1 + n2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums2[left2 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1[left1 + k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> MIN(nums1[left1], nums2[left2]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = MIN(n1, k / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> j = MIN(n2, k / <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剔除比第 k 小的数还小的数，逐渐逼近</span></span><br><span class="line">    <span class="keyword">if</span>(nums1[left1 + i - <span class="number">1</span>] &gt; nums2[left2 + j - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, left1, right1, nums2, left2 + j, right2, k - j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, left1 + i, right1, nums2, left2, right2, k - i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>* nums1, <span class="keyword">int</span> nums1Size, <span class="keyword">int</span>* nums2, <span class="keyword">int</span> nums2Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// k = (nums1Size + nums2Size) /2 + 1，因为 k 从 1 开始计数</span></span><br><span class="line">    <span class="keyword">int</span> mid1 = findKth(nums1, <span class="number">0</span>, nums1Size - <span class="number">1</span>, nums2, <span class="number">0</span>, nums2Size - <span class="number">1</span>, (nums1Size + nums2Size) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个数组总长度是奇数</span></span><br><span class="line">    <span class="keyword">if</span>((nums1Size + nums2Size) % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个数组总长度是偶数</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 额外求 (nums1Size + nums2Size) / 2 的值</span></span><br><span class="line">        <span class="keyword">int</span> mid2 = findKth(nums1, <span class="number">0</span>, nums1Size - <span class="number">1</span>, nums2, <span class="number">0</span>, nums2Size - <span class="number">1</span>, (nums1Size + nums2Size) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (mid1 + mid2) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、文章"><a href="#二、文章" class="headerlink" title="二、文章"></a>二、文章</h2><p><a href="https://blog.csdn.net/qq_41231926/article/details/81805795" target="_blank" rel="noopener">LeetCode004——两个排序数组的中位数</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#一、寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;一、寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;一、&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>简单算法</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/06/算法/简单算法/</id>
    <published>2019-08-05T16:07:52.659Z</published>
    <updated>2019-08-05T16:07:52.659Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、交换-A-和-B"><a href="#1、交换-A-和-B" class="headerlink" title="1、交换 A 和 B"></a>1、交换 A 和 B</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.中间变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.加法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a + b; </span><br><span class="line">   b = a - b;</span><br><span class="line">   a = a - b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.异或（相同为0，不同为1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">   b = a ^ b;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、求最大公约数"><a href="#2、求最大公约数" class="headerlink" title="2、求最大公约数"></a>2、求最大公约数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1.直接遍历法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCommonDivisor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 2.辗转相除法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCommonDivisor</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(a % b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展：最小公倍数 = (a * b)/最大公约数</span></span><br></pre></td></tr></table></figure><h4 id="3、文章"><a href="#3、文章" class="headerlink" title="3、文章"></a>3、文章</h4><p><a href="https://www.jianshu.com/u/033641990ba6" target="_blank" rel="noopener">iOS开发_小迷糊</a> &amp; <a href="https://www.jianshu.com/p/1f9e00abc958" target="_blank" rel="noopener">iOS面试题：算法与数据结构</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、交换-A-和-B&quot;&gt;&lt;a href=&quot;#1、交换-A-和-B&quot; class=&quot;headerlink&quot; title=&quot;1、交换 A 和 B&quot;&gt;&lt;/a&gt;1、交换 A 和 B&lt;/h4&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>爬楼梯</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <id>http://yoursite.com/2019/08/06/算法/爬楼梯/</id>
    <published>2019-08-05T16:07:52.658Z</published>
    <updated>2019-09-03T09:57:01.412Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://dzliving.com/ClimbStairs.jpg" alt></center><p>原文：<a href="https://juejin.im/post/5a29d52cf265da43333e4da7" target="_blank" rel="noopener">漫画：什么是动态规划？</a></p><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>从简单的分析，要到第 10 级台阶，有多少种方法？要么从 9 级跨 1 级，要么从 8 级跨 1 级。</p><p>记 10 级台阶的状态为 f(10)，9 级台阶的状态为 f(9)，8 级台阶的状态为 f(8)，那么 f(10) = f(9) + f(8)。</p><center><br>f(9) = f(8) + f(7)<br><br>…<br><br>f(2) = 2<br><br>f(1) = 1<br></center><p>f(8)、f(9) 是 f(10) 的【最优子结构】；f(1)、f(2) 是【边界】；f(n) = f(n-1) + f(n-2) 是【状态转移方程】。</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><p>①、递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> getClimbingWays(n - <span class="number">1</span>) + getClimbingWays(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归调用的执行过程和一颗二叉树一样，所以它的时间复杂度就是叶子节点数。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-e71ec2814301b5d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><p>时间复杂度：O(2<sup>n</sup>)</p><p>②、备忘录算法</p><p>递归方法中会重复计算相同的值，如图中的 f(n-3)。用缓存，先创建一个哈希表，每次把不同参数的计算结果存入哈希。当遇到相同参数时，再从哈希表里去除，避免重复计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* hashMap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有缓存</span></span><br><span class="line">    <span class="keyword">if</span> (hashMap[n] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = getClimbingWays(n - <span class="number">1</span>, hashMap) + getClimbingWays(n - <span class="number">2</span>, hashMap);</span><br><span class="line">        hashMap[n] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashMap[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* hashMap = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, getClimbingWays(n, hashMap));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>③、动态规划法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://dzliving.com/ClimbStairs.jpg&quot; alt&gt;&lt;/center&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://juejin.im/post/5a29d52cf265da43333e4da7&quot; target
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>硬币问题</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/06/算法/硬币问题/</id>
    <published>2019-08-05T16:07:52.658Z</published>
    <updated>2019-09-03T09:57:15.770Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://dzliving.com/CoinProblem.jpg" alt></center><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>假设有 1 元、3 元、5 元的硬币无限个，现在需要凑出 11 元，问如何组合才能使硬币的数量最少？</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>有最小单位 1 的情况下，可以使用贪心算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSInteger count = m / <span class="number">5</span>;</span><br><span class="line">NSInteger mol   = m % <span class="number">5</span>;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(mol/<span class="number">3</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     count++;</span><br><span class="line">     mol %= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">count += mol;</span><br></pre></td></tr></table></figure><p>但当硬币的种类改变，并且需要凑出的总价值变大时，很难靠简单的计算得出结果。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。</p><p>这里运用动态规划的思路解决该问题。动态规划中有三个重要的元素：<strong>最优子结构、边界、状态转移公式。</strong>按照一般思路，先从最基本的情况来一步一步地推导。</p><p>注意：<font color="#cc0000">动态规划的策略在于当前的硬币（或其他物品）是否能算进去</font>。</p><p>先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量。</p><ol><li>当 i = 0 时，很显然知道 d(0) = 0。</li><li>当 i = 1 时，因为有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = d(0) + 1。</li><li>当 i = 2 时，因为并没有 2 元的硬币，所以在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = d(1) + 1。</li><li>当 i = 3 时，需要 3 个 1 元硬币或者 1 个 3 元硬币，d(3) = min{ d(2)+1, d(3-3)+1 };</li><li>…</li><li>抽离出来 d(i) = min{ d(i-1)+1, d(i-v<sub>j</sub>)+1 }，其中 i - v<sub>j</sub> &gt;= 0，v<sub>j</sub> 表示第 j 个硬币的面值。</li></ol><p>这里 d(i-1)+1 和 d(i-v<sub>j</sub>)+1 是 d(i) 的最优子结构；d(0) = 0 是边界；d(i) = min{ d(i-1)+1, d(i-v<sub>j</sub>)+1 } 是状态转移公式。其实我们根据边界 + 状态转移公式就能得到最终动态规划的结果。</p><h2 id="3、算法实现"><a href="#3、算法实现" class="headerlink" title="3、算法实现"></a>3、算法实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Coins 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// min 数组包含 d(0)~d(n)，所以数组长度是 n+1</span></span><br><span class="line">    n++;</span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line">    <span class="keyword">int</span>* min = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可选硬币种类</span></span><br><span class="line">    <span class="keyword">int</span> v[Coins] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        min[i] = min[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Coins; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 装不下</span></span><br><span class="line">            <span class="keyword">if</span> (v[j] &gt; i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 装得下</span></span><br><span class="line">            <span class="keyword">if</span> (min[i - v[j]] &lt; min[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                min[i] = min[i - v[j]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, min[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d"</span>, dp(<span class="number">101</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、拓展"><a href="#4、拓展" class="headerlink" title="4、拓展"></a>4、拓展</h2><p>上面的问题中包含了最小单位 1 元的硬币，所以每次 i 增加时，都能 min[i] = min[i - 1] + 1（<font color="#cc0000">+1 是用了 1 元硬币</font>），但如果硬币为 2 元、3 元、5 元呢？应该如何求出 11 元呢？</p><p>来推算下：</p><pre><code>①、n = 1，不存在 1 元硬币，且 2、3、5 &gt; 1，所以 f(1) = 0;②、n = 2，存在 2 元硬币，所以 f(2) = 1;③、n = 3，存在 3 元硬币，所以 f(3) = 1;④、n = 4，不存在 4 元硬币，而 2 和3 &lt; 4，5 &gt; 4，其中    f(4-3) = f(1) = 0 说明在去除 3 元的情况下，不能获得剩下的 1 元；    f(4-2) = f(2) = 1 说明在去除2 元的情况下，可以获得剩下的2 元，f(4) = f(2) + 1 = 2;    结合上面两种情况 f(4) = MIN{ f(4-2) + 1 }⑤、n = 5，存在 5 元硬币，所以 f(5) = 1;⑥、n = 6，不存在 6元硬币，而 2、3、5 &lt; 6，其中     f(6-5) = f(1) = 0 说明在去除 5 元的情况下，不能获得剩下的 1 元；    f(6-3) = f(3) = 1 说明在去除 3 元的情况下，可以获得剩下的 3 元，f(6) = f(6-3) + 1 = 2;    f(6-2) = f(4) = 2 说明在去除 2 元的情况下，可以获得剩下的 3 元，f(6) = f(6-4) + 1 = 3;    结合上面三种情况 f(6) = MIN{ f(6-3) + 1, f(6-2) + 1 }</code></pre><p>【状态】是 f(n)</p><p>【边界】是 n = 2、3、5 时只有一种选择</p><p>【状态转移方程】是 f(n) = MIN{  f(n - ci) +1 }, 其中 n 表示当前的总额，ci 表示金币数额。</p><p><strong>注意：</strong>因为是取最小值，所以是无法获得的总额时，如 f(1)，应该让 f(1)等于很大的值，这样就可以将它剔除出去。</p><p>下面的代码为了直观每次选币的过程，增加了结构体、打印代码，不需要时可以自行删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Coins     3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(a, b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CoinLog</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minCoin;   <span class="comment">// 最少的硬币数</span></span><br><span class="line">    <span class="keyword">int</span> coin[<span class="number">100</span>]; <span class="comment">// 所选硬币</span></span><br><span class="line">&#125; CoinLog;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n++;  <span class="comment">// result 数组包含 d(0)~d(n)，所以数组长度是 n+1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数组</span></span><br><span class="line"><span class="comment">//    int* result = (int*)malloc(sizeof(int) * n);</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        result[i] = n;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    CoinLog* result = (CoinLog *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CoinLog) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        CoinLog <span class="built_in">log</span> = &#123; n, &#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">        result[i] = <span class="built_in">log</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 硬币种类</span></span><br><span class="line">    <span class="keyword">int</span> v[Coins] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d ="</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Coins; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 硬币正好</span></span><br><span class="line">            <span class="keyword">if</span> (v[j] == i) &#123;</span><br><span class="line">                result[i].minCoin = <span class="number">1</span>;</span><br><span class="line">                result[i].coin[<span class="number">0</span>] = v[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 硬币太大</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v[j] &gt; i) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环 Coins，找出最少的币数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result[i - v[j]].minCoin &lt; result[i].minCoin) &#123;</span><br><span class="line">                result[i].minCoin = result[i - v[j]].minCoin + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (; k &lt; result[i - v[j]].minCoin; k++) &#123;</span><br><span class="line">                    result[i].coin[k] = result[i - v[j]].coin[k];</span><br><span class="line">                &#125;</span><br><span class="line">                result[i].coin[k] = v[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result[i].minCoin &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 显示每次怎么找的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; result[i].minCoin; k++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%3d  "</span>, result[i].coin[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    for (int i = 1; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//        printf("%d  ", result[i]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result[n - <span class="number">1</span>].minCoin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n最少的币数 = %d"</span>, dp(<span class="number">21</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">1</span> =</span><br><span class="line">  <span class="number">2</span> =  <span class="number">2</span>  </span><br><span class="line">  <span class="number">3</span> =  <span class="number">3</span>  </span><br><span class="line">  <span class="number">4</span> =  <span class="number">2</span>    <span class="number">2</span>  </span><br><span class="line">  <span class="number">5</span> =  <span class="number">5</span>  </span><br><span class="line">  <span class="number">6</span> =  <span class="number">3</span>    <span class="number">3</span>  </span><br><span class="line">  <span class="number">7</span> =  <span class="number">2</span>    <span class="number">5</span>  </span><br><span class="line">  <span class="number">8</span> =  <span class="number">3</span>    <span class="number">5</span>  </span><br><span class="line">  <span class="number">9</span> =  <span class="number">2</span>    <span class="number">2</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">10</span> =  <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">11</span> =  <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">12</span> =  <span class="number">2</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">13</span> =  <span class="number">3</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">14</span> =  <span class="number">2</span>    <span class="number">2</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">15</span> =  <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">16</span> =  <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">17</span> =  <span class="number">2</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">18</span> =  <span class="number">3</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">19</span> =  <span class="number">2</span>    <span class="number">2</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">20</span> =  <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>  </span><br><span class="line"> <span class="number">21</span> =  <span class="number">3</span>    <span class="number">3</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span> </span><br><span class="line">  </span><br><span class="line">最少的币数 = <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://dzliving.com/CoinProblem.jpg&quot; alt&gt;&lt;/center&gt;

&lt;h2 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>汉诺塔</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>http://yoursite.com/2019/08/06/算法/汉诺塔/</id>
    <published>2019-08-05T16:07:52.657Z</published>
    <updated>2019-08-05T16:07:52.657Z</updated>
    
    <content type="html"><![CDATA[<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-683e4629858b6dbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center><p>学习文章：<a href="https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94/3468295?fr=aladdin" target="_blank" rel="noopener">汉诺塔</a></p><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>在三根柱子之间一次只能移动一个圆盘，在小圆盘上不能放大圆盘。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>依据分治的策略，将问题化简为两个圆盘，三根柱子 A、B、C，首先解决倒数第二个圆盘的移动，将 n - 1（小盘） 从 A 移到 B，然后将 n（大盘） 从 A 移到 C，再将小盘从 B 移到 C。</p><p>子问题分别为：<font color="#cc0000">小盘和大盘的移动</font>。</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num  5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a[num] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  <span class="comment">// 1 - 最小的物品    5 - 最大的物品</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b[num] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 0 - 为空</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c[num] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// 0 - 为空</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idxA = <span class="number">0</span>; <span class="comment">// 当前有物品的下标</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idxB = num;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idxC = num;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 定义 move 函数，移动物品</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> from, <span class="keyword">char</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c -&gt; %c\n"</span>, from, to);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移出</span></span><br><span class="line">    <span class="keyword">if</span> (from == <span class="string">'A'</span> &amp;&amp; idxA &gt; <span class="number">-1</span> &amp;&amp; idxA &lt; num) &#123;</span><br><span class="line">        x = a[idxA];</span><br><span class="line">        a[idxA] = <span class="number">0</span>;</span><br><span class="line">        idxA++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (from == <span class="string">'B'</span> &amp;&amp; idxB &gt; <span class="number">-1</span> &amp;&amp; idxB &lt; num) &#123;</span><br><span class="line">        x = b[idxB];</span><br><span class="line">        b[idxB] = <span class="number">0</span>;</span><br><span class="line">        idxB++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (from == <span class="string">'C'</span> &amp;&amp; idxC &gt; <span class="number">-1</span> &amp;&amp; idxC &lt; num) &#123;</span><br><span class="line">        x = c[idxC];</span><br><span class="line">        c[idxC] = <span class="number">0</span>;</span><br><span class="line">        idxC++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c from 数组越界！"</span>, from);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存入</span></span><br><span class="line">    <span class="keyword">if</span> (to == <span class="string">'A'</span> &amp;&amp; --idxA &gt; <span class="number">-1</span> &amp;&amp; idxA &lt; num) &#123;</span><br><span class="line">        a[idxA] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (to == <span class="string">'B'</span> &amp;&amp; --idxB &gt; <span class="number">-1</span> &amp;&amp; idxB &lt; num) &#123;</span><br><span class="line">        b[idxB] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (to == <span class="string">'C'</span> &amp;&amp; --idxC &gt; <span class="number">-1</span> &amp;&amp; idxC &lt; num)&#123;</span><br><span class="line">        c[idxC] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c to 数组越界！"</span>, to);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印移动后结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d      %d      %d\n"</span>, a[i], b[i], c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将 n 个物品从 one 座借助 two 座，移到 three 座</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> one, <span class="keyword">char</span> two, <span class="keyword">char</span> three)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        move(one, three); <span class="comment">// 只有一个物品，直接移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>, one, three, two); <span class="comment">//首先把 n - 1 个从 one 移动到 two</span></span><br><span class="line">        move(one, three); <span class="comment">// 然后把最后一个 n 从 one 移动到 three</span></span><br><span class="line">        hanoi(n<span class="number">-1</span>, two, one, three); <span class="comment">// 最后再把 n - 1 个从 two 移动到 three</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hanoi(num, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"></span><br><span class="line">A -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2</span>      <span class="number">1</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">2</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">B -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">5</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">4</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">5</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">A -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">2</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">C -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">3</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">1</span></span><br><span class="line"></span><br><span class="line">A -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">1</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">4</span>      <span class="number">0</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">2</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>      <span class="number">2</span></span><br><span class="line"><span class="number">0</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">2</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">C -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">3</span>      <span class="number">0</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">A -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">C -&gt; B</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">4</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>      <span class="number">4</span></span><br><span class="line"><span class="number">0</span>      <span class="number">2</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; A</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">1</span>      <span class="number">2</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">B -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">1</span>      <span class="number">0</span>      <span class="number">5</span></span><br><span class="line"></span><br><span class="line">A -&gt; C</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">2</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">3</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">4</span></span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5294842-683e4629858b6dbb.png?imageMogr2/auto-orient/strip%7CimageView2/
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>消息转发</title>
    <link href="http://yoursite.com/2019/08/06/iOS/iOS%E5%8E%9F%E7%90%86/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2019/08/06/iOS/iOS原理/消息转发/</id>
    <published>2019-08-05T16:07:52.657Z</published>
    <updated>2019-09-03T09:53:06.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unrecognized selector sent to instance，导致应用 crash 的情况。</p><p>针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。</p><p>消息转发的整个过程主要涉及的 3 个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line">-(<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;</span><br><span class="line">-(<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span>*)anInvocation;</span><br></pre></td></tr></table></figure><p>其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。</p><h2 id="二、消息转发过程"><a href="#二、消息转发过程" class="headerlink" title="二、消息转发过程"></a>二、消息转发过程</h2><p>首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-21f16eb1cfa08e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>下边分析消息转发的过程，以 [MyObjet Length] 为例：</p><p>①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。</p><p>②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。</p><p>③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。</p><h2 id="三、结合-MyObject-中的代码对消息转发流程进一步分析"><a href="#三、结合-MyObject-中的代码对消息转发流程进一步分析" class="headerlink" title="三、结合 MyObject 中的代码对消息转发流程进一步分析"></a>三、结合 MyObject 中的代码对消息转发流程进一步分析</h2><p>①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel </span><br><span class="line">&#123;    </span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ ,<span class="built_in">NSStringFromSelector</span>(sel).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(length)) &#123;</span><br><span class="line">         <span class="built_in">BOOL</span> success = class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)(length), <span class="string">"q@:"</span>); </span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (success) &#123;</span><br><span class="line">             <span class="keyword">return</span> success;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的 “q@:” 分别代表：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q : 返回值 <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">@ : 调用方法的的实例为对象类型</span><br><span class="line">: : 表示方法</span><br></pre></td></tr></table></figure><p>下图表示了编码类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/5294842-a5925ae21f498603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * respondClasses;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(aSelector).UTF8String);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> forwardTarget = [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (forwardTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> forwardTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class someClass = [<span class="keyword">self</span> myResponedClassForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> (someClass) &#123;</span><br><span class="line">        forwardTarget = [someClass new];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> forwardTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。</p><p>③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。</p><blockquote><p> -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。</p><p>摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.</p><p>这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。</p></blockquote><p>相关代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"%s:%s \n\n\n\n"</span>, __func__ , <span class="built_in">NSStringFromSelector</span>(anInvocation.selector).UTF8String);</span><br><span class="line"></span><br><span class="line">    anInvocation.target = <span class="literal">nil</span>;</span><br><span class="line">    [anInvocation invoke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        Class responededClass = [<span class="keyword">self</span> myResponedClassForSelector:selector];</span><br><span class="line">        <span class="keyword">if</span> (responededClass) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                signature = [responededClass instanceMethodSignatureForSelector:selector];</span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">@finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)myResponedClassForSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    respondClasses = @[</span><br><span class="line">                       [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSNumber</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSDate</span> <span class="keyword">class</span>],</span><br><span class="line">                       [<span class="built_in">NSData</span> <span class="keyword">class</span>]</span><br><span class="line">                       ];</span><br><span class="line">    <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> respondClasses) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector]) &#123;</span><br><span class="line">            <span class="keyword">return</span> someClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">NSMethodSignature</span>: <span class="number">0x6000030a17c0</span>&gt;</span><br><span class="line">    number of arguments = <span class="number">2</span></span><br><span class="line">    frame size = <span class="number">224</span></span><br><span class="line">    is special <span class="keyword">struct</span> <span class="keyword">return</span>? <span class="literal">NO</span></span><br><span class="line">    <span class="keyword">return</span> value: -------- -------- -------- --------</span><br><span class="line">        type encoding (f) <span class="string">'f'</span></span><br><span class="line">        flags &#123;isFloat&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">16</span>, offset adjust = <span class="number">0</span>, size = <span class="number">16</span>, size adjust = <span class="number">-12</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">4</span>&#125;</span><br><span class="line">    argument <span class="number">0</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (@) <span class="string">'@'</span></span><br><span class="line">        flags &#123;isObject&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">0</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">    argument <span class="number">1</span>: -------- -------- -------- --------</span><br><span class="line">        type encoding (:) <span class="string">':'</span></span><br><span class="line">        flags &#123;&#125;</span><br><span class="line">        modifiers &#123;&#125;</span><br><span class="line">        frame &#123;offset = <span class="number">8</span>, offset adjust = <span class="number">0</span>, size = <span class="number">8</span>, size adjust = <span class="number">0</span>&#125;</span><br><span class="line">        memory &#123;offset = <span class="number">0</span>, size = <span class="number">8</span>&#125;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocation</span>。</span><br><span class="line"></span><br><span class="line">仍然以`myObject`调用`length`方法为例。 \- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> \*)anInvocation中的 anInvocation 的信息如下：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">&lt;<span class="built_in">NSInvocation</span>: <span class="number">0x6000025b8140</span>&gt;</span><br><span class="line"><span class="keyword">return</span> value: &#123;Q&#125; <span class="number">0</span></span><br><span class="line">target: &#123;@&#125; <span class="number">0x60000322c360</span></span><br><span class="line">selector: &#123;:&#125; length</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">return</span> value 指返回值，<span class="string">"Q"</span> 表示返回值类型为 <span class="keyword">long</span> <span class="keyword">long</span> 类型；</span><br><span class="line">&gt; target 指的是消息的接收者，<span class="string">"@"</span>标识对象类型；</span><br><span class="line">&gt; selector 指的是方法，<span class="string">":"</span>表示是方法，后边的 length 为方法名。</span><br></pre></td></tr></table></figure><p>更多内容可见下图 NSInvocation 的 types：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> _NSObjCValueType &#123;</span><br><span class="line">    <span class="built_in">NSObjCNoType</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSObjCVoidType</span> = <span class="string">'v'</span>,</span><br><span class="line">    <span class="built_in">NSObjCCharType</span> = <span class="string">'c'</span>,</span><br><span class="line">    <span class="built_in">NSObjCShortType</span> = <span class="string">'s'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLongType</span> = <span class="string">'l'</span>,</span><br><span class="line">    <span class="built_in">NSObjCLonglongType</span> = <span class="string">'q'</span>,</span><br><span class="line">    <span class="built_in">NSObjCFloatType</span> = <span class="string">'f'</span>,</span><br><span class="line">    <span class="built_in">NSObjCDoubleType</span> = <span class="string">'d'</span>,</span><br><span class="line">    <span class="built_in">NSObjCBoolType</span> = <span class="string">'B'</span>,</span><br><span class="line">    <span class="built_in">NSObjCSelectorType</span> = <span class="string">':'</span>,</span><br><span class="line">    <span class="built_in">NSObjCObjectType</span> = <span class="string">'@'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStructType</span> = <span class="string">'&#123;'</span>,</span><br><span class="line">    <span class="built_in">NSObjCPointerType</span> = <span class="string">'^'</span>,</span><br><span class="line">    <span class="built_in">NSObjCStringType</span> = <span class="string">'*'</span>,</span><br><span class="line">    <span class="built_in">NSObjCArrayType</span> = <span class="string">'['</span>,</span><br><span class="line">    <span class="built_in">NSObjCUnionType</span> = <span class="string">'('</span>,</span><br><span class="line">    <span class="built_in">NSObjCBitfield</span> = <span class="string">'b'</span></span><br><span class="line">&#125; API_DEPRECATED(<span class="string">"Not supported"</span>, macos(<span class="number">10.0</span>,<span class="number">10.5</span>), ios(<span class="number">2.0</span>,<span class="number">2.0</span>), watchos(<span class="number">2.0</span>,<span class="number">2.0</span>), tvos(<span class="number">9.0</span>,<span class="number">9.0</span>));</span><br></pre></td></tr></table></figure><h2 id="四、尚存疑点"><a href="#四、尚存疑点" class="headerlink" title="四、尚存疑点"></a>四、尚存疑点</h2><p>细心的读者可能会发现在首次消息转发的时候流程并不是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>而是</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">-[MyObject forwardingTargetForSelector:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:length </span><br><span class="line">+[MyObject resolveInstanceMethod:]:_forwardStackInvocation: </span><br><span class="line">-[MyObject forwardInvocation:]:length</span><br></pre></td></tr></table></figure><p>查看了开源源码 <a href="https://opensource.apple.com/source/objc4/objc4-750.1/runtime/NSObject.mm.auto.html" target="_blank" rel="noopener">NSObject.mm</a> 相关源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Replaced by CF (returns an NSMethodSignature)</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot;</span><br><span class="line">                &quot;not available without CoreFoundation&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];</span><br><span class="line">&#125;</span><br><span class="line">// Replaced by CF (throws an NSException)</span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、NSNull-QiNullSafe-m"><a href="#五、NSNull-QiNullSafe-m" class="headerlink" title="五、NSNull+QiNullSafe.m"></a>五、NSNull+QiNullSafe.m</h2><p>根据 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a> 仿写的 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FQiShare%2FQiSafeType%2Fblob%2Fmaster%2FQiSafeType%2FNullSafe%2FNSNull%252BQiNullSafe.m" target="_blank" rel="noopener">NSNull+QiNullSafe.m</a>。</p><p>NSNull+QiNullSafe.m 能够避免的问题有：</p><blockquote><p>NSNull *null = [NSNull null];</p><p>[null performSelector:@selector(addObject:) withObject:@”aaa”];<br>[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];<br>[null performSelector:@selector(valueForKey:) withObject:@”aaa”];<br>[null performSelector:@selector(length) withObject:nil];<br>[null performSelector:@selector(integerValue) withObject:nil];<br>[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];<br>[null performSelector:@selector(bytes) withObject:nil];</p></blockquote><h2 id="六、NullSafe-是怎么处理-null-问题"><a href="#六、NullSafe-是怎么处理-null-问题" class="headerlink" title="六、NullSafe 是怎么处理 null 问题"></a>六、NullSafe 是怎么处理 null 问题</h2><p>其实 <a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="noopener">NullSafe</a>  处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。</p><p>不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。</p><p>注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。</p><h2 id="七、单元测试"><a href="#七、单元测试" class="headerlink" title="七、单元测试"></a>七、单元测试</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testStringValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * string = [null stringValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertNil</span>(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testFloatValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> f = [null floatValue];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">XCTAssertEqualWithAccuracy</span>(f, <span class="number">0.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testPerformSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNull</span> * null = [<span class="built_in">NSNull</span> null];</span><br><span class="line">    [null performSelector:<span class="keyword">@selector</span>(addObject:) withObject:<span class="string">@"aaa"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、文章"><a href="#八、文章" class="headerlink" title="八、文章"></a>八、文章</h2><p><a href="https://juejin.im/post/5c6e773be51d451b25716d0e" target="_blank" rel="noopener">iOS 消息转发</a></p><p><a href="http://www.olinone.com/?p=643" target="_blank" rel="noopener">Protocol 协议分发器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现  unr
      
    
    </summary>
    
      <category term="iOS原理" scheme="http://yoursite.com/categories/iOS%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>构造子集</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%9E%84%E9%80%A0%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2019/08/06/算法/构造子集/</id>
    <published>2019-08-05T16:07:52.656Z</published>
    <updated>2019-08-05T16:07:52.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>构造出 0~n-1 的所有子集。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>一次选出一个元素放入集合。</p><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_LENGTH  10</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">int</span> A[ARRAY_LENGTH];</span><br><span class="line">    print_subset(ARRAY_LENGTH, A, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_subset</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* A, <span class="keyword">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cur:当前位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cur = %d      "</span>, cur);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定当前元素的最小可能值</span></span><br><span class="line">    <span class="keyword">int</span> s = cur ? A[cur<span class="number">-1</span>] + <span class="number">1</span> : <span class="number">0</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s = %d     "</span>, s); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前子集元素。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur; i++) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 每次选出一个元素当子集的首元素,</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &lt; n; i++) &#123;</span><br><span class="line">        A[cur] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印加入元素后的数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"       after："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cur; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        print_subset(n, A, cur + <span class="number">1</span>); <span class="comment">// 递归构造子集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = <span class="number">0</span>      s = <span class="number">0</span>                  after：<span class="number">0</span> </span><br><span class="line">cur = <span class="number">1</span>      s = <span class="number">1</span>     <span class="number">0</span>            after：<span class="number">0</span> <span class="number">1</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">2</span>     <span class="number">0</span> <span class="number">1</span>          after：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> </span><br><span class="line">cur = <span class="number">3</span>      s = <span class="number">3</span>     <span class="number">0</span> <span class="number">1</span> <span class="number">2</span>        after：<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">4</span>      s = <span class="number">4</span>     <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>      after：<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">3</span>      s = <span class="number">4</span>     <span class="number">0</span> <span class="number">1</span> <span class="number">3</span>        after：<span class="number">0</span> <span class="number">2</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">3</span>     <span class="number">0</span> <span class="number">2</span>          after：<span class="number">0</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">3</span>      s = <span class="number">4</span>     <span class="number">0</span> <span class="number">2</span> <span class="number">3</span>        after：<span class="number">0</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">4</span>     <span class="number">0</span> <span class="number">3</span>          after：<span class="number">1</span> </span><br><span class="line">cur = <span class="number">1</span>      s = <span class="number">2</span>     <span class="number">1</span>            after：<span class="number">1</span> <span class="number">2</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">3</span>     <span class="number">1</span> <span class="number">2</span>          after：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">3</span>      s = <span class="number">4</span>     <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>        after：<span class="number">1</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">4</span>     <span class="number">1</span> <span class="number">3</span>          after：<span class="number">2</span> </span><br><span class="line">cur = <span class="number">1</span>      s = <span class="number">3</span>     <span class="number">2</span>            after：<span class="number">2</span> <span class="number">3</span> </span><br><span class="line">cur = <span class="number">2</span>      s = <span class="number">4</span>     <span class="number">2</span> <span class="number">3</span>          after：<span class="number">3</span> </span><br><span class="line">cur = <span class="number">1</span>      s = <span class="number">4</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-8e32679a27ba0063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h2&gt;&lt;p&gt;构造出 0~n-1 的所有子集。&lt;/p&gt;
&lt;h2 id=&quot;2、算法分析&quot;&gt;&lt;a href=&quot;#2、算法分析&quot;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>第 k 小/大元素</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%B1%82%E7%AC%AC%20k%20%E5%B0%8F:%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/08/06/算法/求第 k 小:大元素/</id>
    <published>2019-08-05T16:07:52.656Z</published>
    <updated>2019-08-05T16:07:52.657Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap_t(int a[],int i,int j)</span><br><span class="line">&#123;</span><br><span class="line">    int t=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int par(int a[],int p,int q)//p是轴,轴前面是比a[p]小的，后面是比a[p]大的</span><br><span class="line">&#123;</span><br><span class="line">    int i=p,x=a[p];</span><br><span class="line">    for(int j=p+1;j&lt;=q;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[j]&gt;=x)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap_t(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap_t(a,p,i);</span><br><span class="line">    return i;//返回轴位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Random(int p,int q)//返回p，q之间的随机数</span><br><span class="line">&#123;</span><br><span class="line">    return rand()%(q-p+1)+p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Randomizedpar(int a[],int p,int q)</span><br><span class="line">&#123;</span><br><span class="line">    int i=Random(p,q);</span><br><span class="line">    swap_t(a,p,i);//第一个和第i个交换，相当于有了一个随机基准元素</span><br><span class="line">    return par(a,p,q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int RandomizedSelect(int a[],int p,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">    if(p==r)</span><br><span class="line">        return a[p];</span><br><span class="line">    int i=Randomizedpar(a,p,r);</span><br><span class="line">    int j=i-p+1;</span><br><span class="line">    printf(&quot;i=%d j=%d\n&quot;,i,j);</span><br><span class="line">    if(k&lt;=j)</span><br><span class="line">        return RandomizedSelect(a,p,i,k);</span><br><span class="line">    else</span><br><span class="line">        return RandomizedSelect(a,i+1,r,k-j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int a[n];</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int x=RandomizedSelect(a,0,n-1,2);</span><br><span class="line">    printf(&quot;%d\n&quot;,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>棋盘覆盖</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2019/08/06/算法/棋盘覆盖/</id>
    <published>2019-08-05T16:07:52.656Z</published>
    <updated>2019-08-05T16:07:52.656Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://blog.csdn.net/acm_jl/article/details/50938164" target="_blank" rel="noopener">棋盘覆盖问题</a>、<a href="https://www.cnblogs.com/yinbiao/p/8666209.html" target="_blank" rel="noopener">分治法之棋盘覆盖问题</a></p><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>在一个 2k * 2k（k ≥ 0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格，显然，特殊方格在棋盘中出现的位置有 4k 种情形，因而有 4k 种不同的棋盘。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-4e263f9511be87c0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  <img src="https://upload-images.jianshu.io/upload_images/5294842-d912d205684d9cce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br></center><h2 id="2、算分分析"><a href="#2、算分分析" class="headerlink" title="2、算分分析"></a>2、算分分析</h2><p>用分治策略。</p><p>①、当 k &gt; 0 时，将 2k * 2k 棋盘分割成 4 个 2k-1 * 2k-1 子棋盘，特殊方格必定只位于某个子棋盘中。</p><p>②、用一个 L 型骨牌覆盖 3 个无特殊方格子棋盘的结合处，由原问题转化成 4 个较小规模的棋盘覆盖子问题。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-58fa2a838622c8b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><img src="https://upload-images.jianshu.io/upload_images/5294842-0f516f0ea267569a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-fc3eee0a9b3e3e1d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-11418711797e2e4a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  <img src="https://upload-images.jianshu.io/upload_images/5294842-6261d8c315417239?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-93b83d27e3ca1c22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image">  <img src="https://upload-images.jianshu.io/upload_images/5294842-87a869ed3d36ea3d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br></center><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> board[max][max]; <span class="comment">// 最大棋盘</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tile = <span class="number">0</span>; <span class="comment">// 覆盖标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  （tr，tc）  棋盘左上角的方格坐标</span></span><br><span class="line"><span class="comment">  *  （dr，dc） 特殊方格所在的坐标</span></span><br><span class="line"><span class="comment">  *    size   是棋盘的行数和列数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChessBoard</span><span class="params">(<span class="keyword">int</span> tr,<span class="keyword">int</span> tc,<span class="keyword">int</span> dr,<span class="keyword">int</span> dc,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 递归到棋盘大小为 1 时，则结束递归</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = tile++;   <span class="comment">// L型骨牌号</span></span><br><span class="line">    <span class="keyword">int</span> s = size / <span class="number">2</span>; <span class="comment">// 分割棋盘，使得新得到的棋盘为原来棋盘大小的四分之一</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ①、左上角子棋盘</span></span><br><span class="line">    <span class="comment">// 如果特殊方格在左上角，就对这个棋盘左上角的四分之一重新进行棋盘覆盖</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">        <span class="comment">// 特殊方格在此棋盘中</span></span><br><span class="line">        ChessBoard(tr, tc, dr, dc, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为特殊方格不在左上角，所以要在左上角构造一个特殊方格</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用 t 号 L 型骨牌覆盖右下角</span></span><br><span class="line">        board[tr + s - <span class="number">1</span>][ tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        <span class="comment">// 在构造完特殊方格之后，棋盘的左上角的四分之一又有了特殊方格，所以就对左上角棋盘的四分之一进行棋盘覆盖，直到棋盘大小为 1 * 1</span></span><br><span class="line">        ChessBoard(tr, tc, tr+s<span class="number">-1</span>, tc+s<span class="number">-1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ②、右上角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">        ChessBoard(tr, tc+s, dr, dc, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        board[tr + s - <span class="number">1</span>][tc + s] = t;</span><br><span class="line">        </span><br><span class="line">        ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ③、左下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">        ChessBoard(tr + s, tc, dr, dc, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用 t 号 L 型骨牌覆盖右上角</span></span><br><span class="line">        board[tr + s][tc + s - <span class="number">1</span>] = t;</span><br><span class="line">        </span><br><span class="line">        ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ④、右下角子棋盘</span></span><br><span class="line">    <span class="keyword">if</span>(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line">        ChessBoard(tr + s, tc + s, dr, dc, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用 t 号 L 型骨牌覆盖左上角</span></span><br><span class="line">        board[tr + s][tc + s] = t;</span><br><span class="line">        ChessBoard(tr + s, tc + s, tr + s, tc + s, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">8</span>, dr = <span class="number">0</span>, dc = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"不可覆盖点的值为 -1！\n\n"</span>);</span><br><span class="line">    board[dr][dc] = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    ChessBoard(<span class="number">0</span>, <span class="number">0</span>, dr, dc, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; size; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d"</span>, board[m][<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">1</span>; n &lt; size; n++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  %2d"</span>, board[m][n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不可覆盖点的值为 <span class="number">-1</span>！</span><br><span class="line"></span><br><span class="line"><span class="number">-1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">3</span>   <span class="number">7</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">8</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">2</span>   <span class="number">1</span>   <span class="number">3</span>   <span class="number">7</span>   <span class="number">6</span>   <span class="number">6</span>   <span class="number">8</span></span><br><span class="line"> <span class="number">4</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">5</span>   <span class="number">9</span>   <span class="number">9</span>   <span class="number">6</span>  <span class="number">10</span></span><br><span class="line"> <span class="number">4</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">5</span>   <span class="number">0</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">10</span></span><br><span class="line"><span class="number">12</span>  <span class="number">12</span>  <span class="number">13</span>   <span class="number">0</span>   <span class="number">0</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">18</span></span><br><span class="line"><span class="number">12</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">13</span>  <span class="number">17</span>  <span class="number">17</span>  <span class="number">16</span>  <span class="number">18</span></span><br><span class="line"><span class="number">14</span>  <span class="number">11</span>  <span class="number">11</span>  <span class="number">15</span>  <span class="number">19</span>  <span class="number">16</span>  <span class="number">16</span>  <span class="number">20</span></span><br><span class="line"><span class="number">14</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">15</span>  <span class="number">19</span>  <span class="number">19</span>  <span class="number">20</span>  <span class="number">20</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://blog.csdn.net/acm_jl/article/details/50938164&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;棋盘覆盖问题&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>最长上升子序列</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://yoursite.com/2019/08/06/算法/最长上升子序列/</id>
    <published>2019-08-05T16:07:52.655Z</published>
    <updated>2019-08-05T16:07:52.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, <font color="#cc0000">3</font>, <font color="#cc0000">4</font>, 8, <font color="#cc0000">6</font>, <font color="#cc0000">7</font>] 返回 4。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>面对这个问题，首先要定义一个”<font color="#cc0000">状态</font>“来代表它的子问题， 并且找到它的解。</p><p>注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。</p><p>假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。</p><p>这个 d(i) 就是我们要找的状态。 如果我们把 d(1) 到 d(N) 都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p><p>以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是：</p><p>5  3  4  8  6  7</p><p>根据上面找到的状态，可以得到：</p><ul><li>i = 1 的 LIS 长度 d(1) = 1, d[] = {5}</li><li>i = 2 的 LIS 长度 d(2) = 1, d[] = {3}</li><li>i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4}</li><li>i = 4 的 LIS 长度 d(4) = <font color="#cc0000">max{ d(1), d(2), d(3) } + 1</font> = 3, d[] = {3, 4, 8}</li></ul><p>状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到：</p><pre><code>d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A\[j\] &lt;= A\[i\]</code></pre><p>想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。</p><p>分析完了，上图。</p><center><img src="https://upload-images.jianshu.io/upload_images/5294842-c89874d9e421af0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><h2 id="3、复杂度分析"><a href="#3、复杂度分析" class="headerlink" title="3、复杂度分析"></a>3、复杂度分析</h2><p>时间复杂度：O(n<sup>2</sup>)</p><p>空间复杂度：O(n)</p><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *d = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        </span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="comment">// 如果当前的数值 A[i] 大于 它之前的数值 A[j] &amp;&amp; 最长的段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i] &amp;&amp; d[j] + <span class="number">1</span> &gt; d[i])</span><br><span class="line">                d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; len) len = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;</span><br><span class="line">        <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、进阶：O-nlogn-算法"><a href="#5、进阶：O-nlogn-算法" class="headerlink" title="5、进阶：O(nlogn)算法"></a>5、进阶：<a href="https://www.felix021.com/blog/read.php?1587" target="_blank" rel="noopener">O(nlogn)算法</a></h2><p>假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。</p><p>定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。<font color="#cc0000">注意：B 的索引从 1 开始</font>。</p><pre><code>①、把 d\[0\] 有序地放到 B 里，令 B\[1\] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。②、把 d\[2\] 有序地放到 B 里，令 B\[1\] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d\[1\] = 2 已经没用了，因为 2 &gt; 1。③、d\[3\] = 5，因为 d\[3\] &gt; B\[1\]，所以令 B\[1+1\] = B\[2\] = d\[3\] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B\[\] = { 1, 5 }。④、d\[4\] = 3，B\[1\] &lt; d\[3\] &lt; B\[2\]，放在 B\[1\] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B\[\] = { 1, 3 }。⑤、d\[5\] = 6，因为 d\[5\] &gt; B\[2\]，所以令 B\[2+1\] = B\[3\] = d\[5\] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B\[\] = { 1, 3, 6 }。⑥、d\[6\] = 4，3 &lt; d\[6\] &lt; 6，于是把 6 替换掉，这时 Len = 3, B\[\] = { 1, 3, 4 }。⑦、d\[7\] = 8，d\[7\] &gt; B\[3\]，将 8 追加到 B 数组末尾，这时 Len = 4, B\[\] = { 1, 3, 4, 8 }。⑧、d\[8\] = 9，d\[8\] &gt; B\[4\]，将 9 追加到 B 数组末尾，这时 Len = 5, B\[\] = { 1, 3, 4, 8, 9 }。⑨、d\[9\] = 7，B\[3\]=4 &lt; d\[9\] &lt; B\[4\]=8，所以最新的 B\[4\] = 7，这时 Len = 5, B\[\] = 1, 3, 4, 7, 9。</code></pre><font color="#cc0000">注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。</font><center><img src="https://upload-images.jianshu.io/upload_images/5294842-94203c725d0f85fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center><p>有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。</p><p>在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> B[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="comment">// 将 key 插入到数组末尾</span></span><br><span class="line">    <span class="keyword">if</span> (B[right] &lt; key)</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// num[left] ≤ key &lt; nums[right] 之后 left 将大于 right，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (B[mid] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">int</span>* B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 无意义</span></span><br><span class="line">    B[<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 从 1 开始是为了让 len、pos 不需要 -1 或 +1</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到插入位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = upper_bound(B, <span class="number">1</span>, len, nums[i]);</span><br><span class="line">        B[pos] = nums[i];</span><br><span class="line">        <span class="comment">// 打印 B 数组，看看每次循环的变化，B[0] 无意义</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d    "</span>, pos);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= pos; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, B[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; pos) &#123;</span><br><span class="line">            len = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">11</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h2&gt;&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, &lt;font color=&quot;#cc0000&quot;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/08/06/算法/最长回文子串/</id>
    <published>2019-08-05T16:07:52.655Z</published>
    <updated>2019-08-05T16:07:52.656Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://pugqga7mf.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpg" alt></center><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">问题描述</a></h2><p>给定一个字符串 s，找到 s 中最长的回文子串。</p><h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>大多数问题都可以用暴力法解决。暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。</p><ul><li><p>时间复杂度：O(n<sup>3</sup>)，假设 n 是输入字符串的长度，则 (n * (n−1))/2​ 为此类子字符串（不包括字符本身是回文的一般解法）的总数。因为验证每个子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n<sup>3</sup>)。</p></li><li><p>空间复杂度：O(1)。 </p></li></ul><p>为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。</p><p>我们给出 P(i,j) 的定义如下：</p><pre><code>如果子串 Si...Sj ​是回文子串   p(i, j) = true其他情况                   p(i, j) = false</code></pre><p>因此：</p><pre><code>P(i, j) = ( P(i+1, j-1) and Si​ == Sj​)</code></pre><p>基本示例如下：</p><pre><code>P(i, i) = trueP(i, i+1) = (Si ​== Si+1​)</code></pre><p>这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推…</p><h2 id="3、复杂度分析"><a href="#3、复杂度分析" class="headerlink" title="3、复杂度分析"></a>3、复杂度分析</h2><ul><li><p>时间复杂度：O(n<sup>2</sup>)，这里给出我们的运行时间复杂度为 O(n<sup>2</sup>)。</p></li><li><p>空间复杂度：O(n<sup>2</sup>)，该方法使用 O(n<sup>2</sup>) 的空间来存储表。</p></li></ul><h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || <span class="built_in">strlen</span>(s) &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二维数组</span></span><br><span class="line">    <span class="keyword">int</span> matrix[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">            matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// i 从倒数第二个开始，从右往左。标识子串的起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">        matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// j 从 i 的下一位开始，从左往右。标识子串的结束位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ①、s[i] == s[j]     ②、小于或等于 3 个字符     ③、内缩一位是回文子串</span></span><br><span class="line">            matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; <span class="number">3</span> || matrix[i+<span class="number">1</span>][j<span class="number">-1</span>]));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获得最长的子串位置</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &amp;&amp; right - left &lt; j - i) &#123;</span><br><span class="line">                left  = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n; m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d   "</span>, matrix[m][k]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* sub = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (right - left + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        sub[i] = s[left + i];  <span class="comment">//strncpy(sub, s+left, right+1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    sub[i] = <span class="string">'\0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, longestPalindrome(<span class="string">"aaabaaaa"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键代码：</p><font color="#cc0000">matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); 以及 i 和 j 的取值方向</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://pugqga7mf.bkt.clouddn.com/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.jpg&quot; alt&gt;&lt;/center&gt;

&lt;h2 id=&quot;1、问题描述
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>整数划分</title>
    <link href="http://yoursite.com/2019/08/06/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/"/>
    <id>http://yoursite.com/2019/08/06/算法/整数划分/</id>
    <published>2019-08-05T16:07:52.654Z</published>
    <updated>2019-08-05T16:07:52.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>将一个正整数 n 写成如下形式</p><pre><code>n = m1 + m2 + ... + mi; （其中 mi 为正整数，并且 1 &lt;= mi &lt;= n），则 {m1, m2, ..., mi} 为 n 的一个划分。</code></pre><p>如果 { m1, m2, …, mi } 中的最大值不超过 m，即 max(m1, m2, …, mi) &lt;= m，则称它属于 n 的一个 m 划分。</p><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>这里记 n 的 m 划分的个数为 f(n, m); 例如当 n = 4 时，有 5 个划分 {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1};</p><p>该问题是求出 n 的所有划分个数，即 f(n, n)。下面考虑求 f(n,m) 的方法。</p><pre><code>①、m = 1 || n = 1  只有一种划分情况，即 n 个 1 相加， 所以 f(n, m) = 1;②、m = n &gt; 1       f(n, m) = f(n, n-1) + 1  加上的 1 代表 n + 0 = n 这个划分方案③、n &lt; m           f(n, m) = f(n, n) 逻辑上不存在 m &gt; n 的情况④、n &gt; m           f(n, m) = f(n, m-1) + f(n-m, m); </code></pre><p>f(n, m-1) 表示划分方案中没有 m 的情况，f(n-m, m) 表示划分方案中有 m 的情况。</p><center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-2795457f53fbd73d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center><h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  @brief  整数划分问题，将一个整数划分为若干个数相加。例：整数 4，最大加数 4</span></span><br><span class="line"><span class="comment">         4 =4 + 0</span></span><br><span class="line"><span class="comment">         1+3=4</span></span><br><span class="line"><span class="comment">         1+1+2=4</span></span><br><span class="line"><span class="comment">         2+2=4</span></span><br><span class="line"><span class="comment">         1+1+1+1=4</span></span><br><span class="line"><span class="comment">     注意：1+3=4，3+1=4被认为是同一种划分方案</span></span><br><span class="line"><span class="comment">  *  @param   n   需要划分的数字</span></span><br><span class="line"><span class="comment">  *  @param   m   最大的加数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">algorithm</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || m == <span class="number">1</span>) &#123;  <span class="comment">// 只要存在一个为 1，那么划分的方法数肯定只有一种，那就是 n 个 1 相加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == m &amp;&amp; n &gt; <span class="number">1</span>) &#123; <span class="comment">// 等价于：q(n, n-1) + 1; 最后面 +1 代表的是：0+n，这个划分的方案</span></span><br><span class="line">        <span class="keyword">return</span> algorithm(n, m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; m) &#123; <span class="comment">// 如果 m &gt; n,那么令 m = n，因为最大加数在逻辑上不可能超过 n</span></span><br><span class="line">        <span class="keyword">return</span> algorithm(n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; m) &#123; <span class="comment">// 分为两种：划分方案没有 m 的情况 + 划分方案有 m 的情况</span></span><br><span class="line">        <span class="keyword">return</span> algorithm(n, m - <span class="number">1</span>) + algorithm(n - m, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = algorithm(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、问题描述&quot;&gt;&lt;a href=&quot;#1、问题描述&quot; class=&quot;headerlink&quot; title=&quot;1、问题描述&quot;&gt;&lt;/a&gt;1、问题描述&lt;/h2&gt;&lt;p&gt;将一个正整数 n 写成如下形式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;n = m1 + m2 + ... + mi;
      
    
    </summary>
    
      <category term="algorithm" scheme="http://yoursite.com/categories/algorithm/"/>
    
    
  </entry>
  
</feed>
