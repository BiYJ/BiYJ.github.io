<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> 二、在OpenGL中使用GLSL		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> 二、在OpenGL中使用GLSL		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> 二、在OpenGL中使用GLSL		</h1><div class="post-meta"><a href="/2017/10/27/e4-ba-8c-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e4-bd-bf-e7-94-a8glsl/#comments" class="comment-count"></a><p><span class="date">Oct 27, 2017</span><span><a href="/categories/GLSL/" class="category">GLSL</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="http://www.cnblogs.com/mazhenyu/p/5580916.html" target="_blank" rel="noopener">http://www.cnblogs.com/mazhenyu/p/5580916.html</a> <strong>配置 GLSL</strong>在 OpenGL 中，GLSL 的 shader 使用的流程与 C 语言相似，每个 shader 类似一个 C 模块，首先需要单独编译(compile)，然后一组编译好的 shader 连接(link)成一个完整程序。 这里将忽略 ARB 扩展，只列举 OpenGL2.0 的代码。建议使用 <a href="http://glew.sourceforge.net/" target="_blank" rel="noopener">GLEW</a> 库。下面的代码检查 OpenGL 2.0 是否可用：</p>
<blockquote>
<ol>
<li>#include &lt;GL/glew.h&gt;  </li>
<li><p>#include &lt;GL/glut.h&gt;  </p>
</li>
<li><p>void main(int argc, char **argv)  </p>
</li>
<li>{   </li>
<li>glutInit(&amp;argc, argv);  </li>
<li>…  </li>
<li><p>glewInit();  </p>
</li>
<li><p>if (glewIsSupported(“GL_VERSION_2_0”))  </p>
</li>
<li>printf(“Ready for OpenGL 2.0n”);  </li>
<li>else  </li>
<li>{  </li>
<li>printf(“OpenGL 2.0 not supportedn”);  </li>
<li>exit(1);  </li>
<li>}  </li>
<li><p>setShaders();  </p>
</li>
<li><p>glutMainLoop();  </p>
</li>
<li>}  </li>
</ol>
</blockquote>
<p>下图显示了创建shader的必要步骤，函数的具体使用方法将在下面各小结描述：<img src="http://hi.csdn.net/attachment/201107/19/0_1311044363779z.gif" alt> 1<strong>、创建 shader</strong>下图显示了创建 shader 的步骤：<img src="http://hi.csdn.net/attachment/201107/19/0_1311044426J7IF.gif" alt> 首先创建一个对象作为 shader 的容器，这个创建函数将返回容器的句柄。</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  shaderType  - GL_VERTEX_SHADER or GL_FRAGMENT_SHADER</li>
</ul>
</li>
<li>*/ </li>
<li>GLuint glCreateShader(GLenum shaderType);  </li>
</ol>
</blockquote>
<p>你可以创建许多 shader，但记住所有的顶点 shader 只能有一个 main 函数，所有像素 shader 也一样。 下一步将添加源代码。shader 的源代码是一个字符串数组，添加的语法如下：</p>
<ol>
<li><ol>
<li>/** </li>
<li><ul>
<li>@param  shader  - the handler to the shader </li>
</ul>
</li>
<li><ul>
<li>@param  numOfStrings  - the number of strings in the array</li>
</ul>
</li>
<li><ul>
<li>@param  strings  - the array of strings</li>
</ul>
</li>
<li><ul>
<li>@param  lenOfStrings - an array with the length of each string, or NULL, meaning that the strings are NULL terminated.   </li>
</ul>
</li>
<li>*/</li>
<li>void glShaderSource(GLuint shader, int numOfStrings, const char **strings, int *lenOfStrings);  </li>
</ol>
</li>
</ol>
<p>最后编译 shader：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  shader  - the handler to the shader</li>
</ul>
</li>
<li>*/</li>
<li>void glCompileShader(GLuint shader);  </li>
</ol>
</blockquote>
<p> <strong>2、创建程序</strong>下图显示了获得一个可以运行的 shader 程序的步骤：<img src="http://hi.csdn.net/attachment/201107/19/0_1311044506YZxf.gif" alt> 首先创建一个对象，作为程序的容器。此函数返回容器的句柄。</p>
<blockquote>
<ol>
<li>GLuint glCreateProgram(void);</li>
</ol>
</blockquote>
<p>你可以创建任意多个程序，在渲染时，可以在不同程序中切换，甚至在某帧返回固定功能流水线。比如你想用折射和反射 shader 绘制一个茶杯，然后回到固定功能生成立方体环境贴图(cube map)显示背景。 下面将把上一节编译的 shader 附加到刚刚创建的程序中。方法如下：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  program - the handler to the program</li>
</ul>
</li>
<li><ul>
<li>@param  shader  - the handler to the shader you want to attach</li>
</ul>
</li>
<li>*/</li>
<li>void glAttachShader(GLuint program, GLuint shader);</li>
</ol>
</blockquote>
<p>如果同时有顶点 shader 和片断 shader，你需要把它们都附加到程序中。你可以把多个相同类型(顶点或像素)的 shader 附加到一个程序中，如同一个 C 程序可以有多个模块一样，但它们只能有一个main 函数。 你也可以把一个 shader 附加到多个程序，比如你想在不同程序中使用某个相同的 shader。 最后一步是连接程序。方法如下：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  program  - the handler to the program</li>
</ul>
</li>
<li>*/</li>
<li>void glLinkProgram(GLuint program);  </li>
</ol>
</blockquote>
<p>在连接操作之后，shader 的源代码可以被修改并重新编译，并不会影响到整个程序。 程序连接后，可以调用 glUseProgram 来使用程序。每个程序都分配了一个句柄，你可以事先连接多个程序以备使用。</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  prog  - the handler to the program you want to use, or zero to return to fixed functionality.</li>
</ul>
</li>
<li>*/</li>
<li>void glUseProgram(GLuint prog);  </li>
</ol>
</blockquote>
<p>当一个程序被使用后，如果被再次连接，它将被自动替换并投入使用，所以没有必要再次调用上面这个函数。如果使用的参数为 0，表示将使用固定功能流水线。 <strong>3、例子</strong>下面的代码包含了上面描述的所有步骤，参数 p, f, v 是全局的 GLuint 型变量。</p>
<blockquote>
<ol>
<li>void setShaders()  </li>
<li>{  </li>
<li>v = glCreateShader(GL_VERTEX_SHADER);  // 顶点着色器</li>
<li><p>f = glCreateShader(GL_FRAGMENT_SHADER);// 片元着色器</p>
</li>
<li><p>char *vs, *fs;   // 读取 shader 文件</p>
</li>
<li>vs = textFileRead(“toon.vert”);</li>
<li><p>fs = textFileRead(“toon.frag”);  </p>
</li>
<li><p>const char *vv = vs;  </p>
</li>
<li><p>const char *ff = fs;</p>
</li>
<li><p>glShaderSource(v, 1, &amp;vv, NULL);</p>
</li>
<li><p>glShaderSource(f, 1, &amp;ff, NULL);</p>
</li>
<li><p>free(vs); free(fs);  // 释放 </p>
</li>
<li>glCompileShader(v);</li>
<li><p>glCompileShader(f);</p>
</li>
<li><p>p = glCreateProgram();</p>
</li>
<li>glAttachShader(p, v);</li>
<li>glAttachShader(p, f);</li>
<li>glLinkProgram(p);  // 连接</li>
<li>glUseProgram(p);   // 使用</li>
<li>}  </li>
</ol>
</blockquote>
<p>GLUT 版的完整例子(包含了 shader 代码及文本文件读入程序)如下：<a href="http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl_2.0.zip" target="_blank" rel="noopener">http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl_2.0.zip</a> <strong>4、错误处理</strong>调试 shader 是很困难的。目前还没有像 printf 这样的东西，虽然未来可能出现有调试功能的开发工具。 编译阶段的状态可以用如下函数获得：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  object  – the handler to the object. Either a shader or a program</li>
</ul>
</li>
<li><ul>
<li>@param  type    - GL_COMPILE_STATUS</li>
</ul>
</li>
<li><ul>
<li>@param  param   -  the return value, GL_TRUE if OK, GL_FALSE otherwise</li>
</ul>
</li>
<li>*/</li>
<li>void glGetShaderiv(GLuint object, GLenum type, int *param);  </li>
</ol>
</blockquote>
<p> 连接阶段的状态可以用如下函数获得：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  object – the handler to the object. Either a shader or a program</li>
</ul>
</li>
<li><ul>
<li>@param  type   - GL_LINK_STATUS</li>
</ul>
</li>
<li><ul>
<li>@param  param  - the return value, GL_TRUE if OK, GL_FALSE otherwise.</li>
</ul>
</li>
<li>*/</li>
<li>void glGetProgramiv(GLuint object, GLenum type, int *param);  </li>
</ol>
</blockquote>
<p>如果发生错误，就需要从 InfoLog 中找到更多的信息。这个日志保存了最后一次操作的信息，比如编译时的警告、错误，连接时发生的各种问题。这个日志甚至可以告诉你硬件是否支持你的 shader。不幸的是 InfoLog 没有一个规范，所以不同的驱动/硬件可能产生不同的日志信息。 为了获得特定 shader 或程序的日志，可以使用如下程序：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  object  - the handler to the object. Either a shader or a program</li>
</ul>
</li>
<li><ul>
<li>@param  maxLen  - The maximum number of chars to retrieve from the InfoLog</li>
</ul>
</li>
<li><ul>
<li>@param  len     -  returns the actual length of the retrieved InfoLog</li>
</ul>
</li>
<li><ul>
<li>@param  log     - The log itself</li>
</ul>
</li>
<li>*/</li>
<li>void glGetShaderInfoLog(GLuint object, int maxLen, int *len, char *log); </li>
<li>void glGetProgramInfoLog(GLuint object, int maxLen, int *len, char *log);   </li>
</ol>
</blockquote>
<p>GLSL 规范有必要在这里进行一些改进：你必须知道接收 InfoLog 的长度。为了找到这个准确的值，使用下面的函数：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  object  - the handler to the object. Either a shader or a program</li>
</ul>
</li>
<li><ul>
<li>@param  type    - GL_INFO_LOG_LENGTH</li>
</ul>
</li>
<li><ul>
<li>@param  param   - the return value, the length of the InfoLog</li>
</ul>
</li>
<li>*/</li>
<li>void glGetShaderiv(GLuint object, GLenum type, int *param);</li>
<li>void glGetProgramiv(GLuint object, GLenum type, int *param); </li>
</ol>
</blockquote>
<p>下面的函数可以用来打印 InfoLog 的内容：</p>
<blockquote>
<ol>
<li>void printShaderInfoLog(GLuint obj)  </li>
<li>{ </li>
<li>char *infoLog;</li>
<li>int infologLength = 0; </li>
<li><p>int charsWritten  = 0; </p>
</li>
<li><p>glGetShaderiv(obj, GL_INFO_LOG_LENGTH, &amp;infologLength);</p>
</li>
<li><p>if (infologLength &gt; 0) {</p>
</li>
<li><p>infoLog = (char *)malloc(infologLength);</p>
</li>
<li>glGetShaderInfoLog(obj, infologLength, &amp;charsWritten, infoLog);</li>
<li>printf(“%sn”,infoLog);</li>
<li>free(infoLog);  // 释放</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>void printProgramInfoLog(GLuint obj)</p>
</li>
<li>{</li>
<li>int infologLength = 0;</li>
<li>int charsWritten  = 0;</li>
<li><p>char *infoLog;</p>
</li>
<li><p>glGetProgramiv(obj, GL_INFO_LOG_LENGTH, &amp;infologLength);</p>
</li>
<li><p>if (infologLength &gt; 0) {</p>
</li>
<li><p>infoLog = (char *)malloc(infologLength);</p>
</li>
<li>glGetProgramInfoLog(obj, infologLength, &amp;charsWritten, infoLog);</li>
<li>printf(“%sn”, infoLog);</li>
<li>free(infoLog);  // 释放</li>
<li>}</li>
<li>}  </li>
</ol>
</blockquote>
<p> <strong>5、清理</strong>前面的小节讲到了附加一个 shader 到一个程序中，这里的调用是将 shader 从程序中分离：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  program  - The program to detach from</li>
</ul>
</li>
<li><ul>
<li>@param  shader   - The shader to detach</li>
</ul>
</li>
<li>*/</li>
<li>void glDetachShader(GLuint program, GLuint shader);  </li>
</ol>
</blockquote>
<p>注意：只有没有附加到任何程序的 shader 可以被删除，删除 shader 和程序的调用如下：</p>
<blockquote>
<ol>
<li>/**</li>
<li><ul>
<li>@param  id  - The hanuler of the shader or program to delete</li>
</ul>
</li>
<li>*/</li>
<li>void glDeleteShader(GLuint id);  </li>
<li>void glDeleteProgram(GLuint id);  </li>
</ol>
<p>如果一个 shader 还附加在某个程序中，这个 shader 并不能真正删除，只能标记为删除。当这个 shader 从所有程序中分离之后，才会被最终删除。</p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2017/10/27/e4-ba-8c-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e4-bd-bf-e7-94-a8glsl/">http://yoursite.com/2017/10/27/e4-ba-8c-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e4-bd-bf-e7-94-a8glsl/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2017/10/27/e4-b8-89-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e5-90-91shader-e4-bc-a0-e9-80-92-e4-bf-a1-e6-81-af/" class="pre"> 三、在OpenGL中向shader传递信息		</a><a href="/2017/10/27/e4-b8-80-e3-80-81-e5-9b-be-e5-bd-a2-e6-b5-81-e6-b0-b4-e7-ba-bf/" class="next"> 一、图形流水线		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>