<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> SpriteKit 样例		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> SpriteKit 样例		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> SpriteKit 样例		</h1><div class="post-meta"><a href="/2017/11/28/spritekit-e6-a0-b7-e4-be-8b/#comments" class="comment-count"></a><p><span class="date">Nov 28, 2017</span><span><a href="/categories/SpriteKit/" class="category">SpriteKit</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>用 Xcode 8 直接创建 game 工程，系统会帮助创建 GameViewController、GameScene.sks、Actions.sks、GameScene 文件，下面手动创建、编写这些文件，以便熟悉过程：</p>
<p>1、创建视图控制器并在 storyboard 中将 view 的类型设置为 SKView，在 vc.h 文件可以设置显示FPS 等信息。</p>
<p>SKView * skView = (SKView *)self.view;</p>
<p>skView.showsDrawCount = YES;   // 使用多少绘画传递来渲染内容的详情，越少越好</p>
<p>skView.showsFPS= YES;   // 帧率</p>
<p>skView.showsNodeCount = YES;   // 节点数</p>
<p>2、创建 GameScene.sks 文件</p>
<p>创建新文件时选择 SpriteKit Scene 类型：</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Scene.png" alt></p>
<p>样例中只是简单的在场景中添加了一个文本子节点，注意修改文本子节点的 name(便于用代码获取对象)、文本内容、对齐方式。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-GameScene-300x211.jpg" alt></p>
<p>3、创建 GameScene 文件</p>
<p>继承自 SKScene，先不在里面写代码。打开 GameScene.sks，关联 GameScene 类</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-GameSceneRelation-300x24.jpg" alt></p>
<p>4、创建 Actions.sks 文件</p>
<p>创建新文件时选择 SpriteKit Action 类型：</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Action.png" alt></p>
<p>①、点击左下角创建一个新的动作，名称自己决定；</p>
<p>②、关联到 GameScene.sks，这样就可以在 GameScene 类中直接获取上一步创建的动作对象</p>
<p>③、拖动系统动作至面板，调整动作开始时间、时长、特效等。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Actions-300x84.jpg" alt></p>
<p>5、完善各类的代码</p>
<p>①、创建 GameScene 对象并渲染到屏幕</p>
<p>GameScene * scene = (GameScene *)[SKScene nodeWithFileNamed:@”GameScene”];</p>
<p>scene.scaleMode = SKSceneScaleModeAspectFill;   // 这样可以使场景不超出屏幕</p>
<p>[skView presentScene:scene];</p>
<p>②、GameScene 类代码及注释</p>
<p>@implementation GameScene</p>
<p>{</p>
<p>SKShapeNode * _shapeNode;   // 形状节点</p>
<p>SKLabelNode * _labelNode;   // 文本节点</p>
<p>}</p>
<p>- (void)didMoveToView:(SKView *)view</p>
<p>{</p>
<p>_labelNode = (SKLabelNode *)[self childNodeWithName:@”HelloLabel”];</p>
<p>_labelNode.alpha = 0.0;</p>
<p>[_labelNode runAction:[SKAction fadeInWithDuration:2.0]];  // 显示</p>
<p>CGFloat w = (self.size.width + self.size.height) * 0.05;</p>
<p>_shapeNode = [SKShapeNode shapeNodeWithRectOfSize:CGSizeMake(w, w)</p>
<p>   cornerRadius:w * 0.3];</p>
<p>_shapeNode.lineWidth = 2.5;  // 线框宽度</p>
<p>SKAction * repeatAction = [SKAction rotateByAngle:M_PI duration:1];</p>
<p>[_shapeNode runAction:[SKAction repeatActionForever:repeatAction]];</p>
<p>SKAction * waitAction = [SKAction waitForDuration:0.5];</p>
<p>SKAction * fOAction = [SKAction fadeOutWithDuration:0.5];</p>
<p>SKAction * removeAction = [SKAction removeFromParent];</p>
<p>[_shapeNode runAction:[SKAction sequence:@[ waitAction,</p>
<p>   fOAction,</p>
<p>   removeAction ]]];</p>
<p>}</p>
<p>- (void)touchesBegan:(NSSet<uitouch *\> <em>)touches withEvent:(UIEvent </em>)event</uitouch></p>
<p>{</p>
<p>[_labelNode runAction:[SKAction actionNamed:@”Pulse”] withKey:@”fadeInOut”];</p>
<p>for (UITouch * touch in touches) {</p>
<p>SKShapeNode * shapeNode = [_shapeNode copy];</p>
<p>shapeNode.position = [touch locationInNode:self];</p>
<p>shapeNode.strokeColor = SKColor.greenColor;</p>
<p>[self addChild:shapeNode];</p>
<p>}</p>
<p>}</p>
<p>- (void)touchesMoved:(NSSet<uitouch *\> <em>)touches withEvent:(UIEvent </em>)event</uitouch></p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>SKShapeNode * shapeNode = [_shapeNode copy];</p>
<p>shapeNode.position = [touch locationInNode:self];</p>
<p>shapeNode.strokeColor = SKColor.blueColor;</p>
<p>[self addChild:shapeNode];</p>
<p>}</p>
<p>}</p>
<p>- (void)touchesEnded:(NSSet<uitouch *\> <em>)touches withEvent:(UIEvent </em>)event</uitouch></p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>SKShapeNode * shapeNode = [_shapeNode copy];</p>
<p>shapeNode.position = [touch locationInNode:self];</p>
<p>shapeNode.strokeColor = SKColor.redColor;</p>
<p>[self addChild:shapeNode];</p>
<p>}</p>
<p>}</p>
<p>- (void)touchesCancelled:(NSSet<uitouch *\> <em>)touches withEvent:(UIEvent </em>)event</uitouch></p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>SKShapeNode * shapeNode = [_shapeNode copy];</p>
<p>shapeNode.position = [touch locationInNode:self];</p>
<p>shapeNode.strokeColor = SKColor.redColor;</p>
<p>[self addChild:shapeNode];</p>
<p>}</p>
<p>}</p>
<p><strong>一、锚点</strong></p>
<p>锚点对应着一个在父视图上的坐标，该坐标就是自身的 position，可以通过这两个值来计算子视图的位置信息。子视图锚点位置上的点与父视图上 position 位置重合。</p>
<p>锚点是 CGPoint 类型数据，锚点的取值范围为 (0, 0)~(1, 1) 之间。如下图所示.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1396375-d50da61b2cf371e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>默认值为 (0.5, 0.5) 表示子视图的中心点在 position 位置；</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/ttt-1.gif" alt></p>
<p>图上灰色方块在设置时的 position.y 属性值相同，间距相同。修改它们的 anchorPoint 之后，渲染的位置发生了改变，与实际的位置有差别。</p>
<p>从左往右的，它们的锚点值分别为 (1.0, 1.0)、(0.5, 0.5)、(1.0/3, 1.0/3)、(0, 0)。</p>
<p><strong>二、xScale、yScale</strong></p>
<p>场景中上层精灵的缩放值也作用于下层精灵，这将改变它的有效尺寸，而不改变它的实际 frame。</p>
<p><strong>三、着色和混合模式</strong></p>
<p>node.color = SKColor.redColor;</p>
<p>node.colorBlendFactor = 0.5;  // 默认情况下的颜色混合因子为 0.0，这表明纹理未经更改地使用</p>
<p>当你增加混合因子的值，更多的纹理颜色就会被混合颜色替换。例如在你的游戏中的角色受到伤害时，你可能要添加一个红色的色调。</p>
<p>SKAction * attacked = [SKAction colorizeWithColorBlendFactor:0.5 duration:0.25];</p>
<p>SKAction * normal   = [SKAction colorizeWithColorBlendFactor:0.0 duration:0.25];</p>
<p>[spaceshipNode runAction:[SKAction sequence:@[ attacked, normal ]]];</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Color.gif" alt></p>
<p>渲染的最终阶段是把精灵的纹理混合(blend)到其目标帧缓冲区。默认行为使用纹理的 alpha 值混合纹理与目标像素。但是，当你想添加其他的特效到场景时你可以使用其他混合模式。</p>
<p>你可以使用 BlendMode 属性来控制精灵的混合行为。例如，附加混合模式在把多个精灵结合在 一起时很有用，比如开枪(fire)或发光(lighting)。</p>
<p>lightFlareSprite.blendMode = SKBlendModeAdd</p>
<p><strong>三、使用纹理对象</strong></p>
<p>虽然 SpriteKit 可以在你创建一个精灵时为你创建纹理，但在一些更复杂的游戏中，你需要对纹理有更多的控制。你可能需要做以下任何一项:</p>
<ul>
<li>多个精灵之间共享一个纹理。</li>
<li>在精灵创建后更改它的纹理。</li>
<li>通过一系列的纹理让精灵动起来。</li>
<li>用不直接存储在应用程序 bundle 中的数据创建纹理。</li>
<li>把节点树渲染成纹理。例如，你可能要对游戏进行截屏，在玩家完成了关卡(level)后分享。</li>
</ul>
<p>你通过直接使用 SKTexture 对象可以做所有这些事情。纹理对象是可应用于精灵的可复用的图像。你可以创建纹理对象独立于创造精灵。然后，你可以使用纹理对象来创建新的的精灵或改变现有精灵的纹理。它跟 SpriteKit 为你创建纹理相似，但你对过程有更多的控制权。</p>
<p>1、从存储在 App Bundle 的图像创建纹理</p>
<p>SKTexture * texture = [SKTexture textureWithImageNamed:@”rocket.png”];</p>
<p>…</p>
<p>SKSpriteNode * rocket = [SKSpriteNode spriteNodeWithTexture:texture];</p>
<p>…</p>
<p>[self addChild:rocket];</p>
<p>通常情况下，你会加载一次纹理，并保持对它的强引用，以便每次需要创建一个新的精灵时都可以使用它。</p>
<p>纹理对象本身只是实际的纹理数据的一个占位符。纹理数据占用(intensive)更多的资源，所以当使用它的精灵在屏幕上且可见时，SpriteKit 只保存它在内存中。</p>
<p>2、纹理图册</p>
<p>通常情况下，存储在应用程序 bundle 中的美术资源是不相干的图像，却是一起用于相同精灵的图像的集合。例如，下面是一些常见的美术资源的集合:</p>
<ol>
<li>一个角色的动画帧</li>
<li>用来创建游戏关卡或者迷宫的地形瓦片</li>
<li>用于用户界面控件的图像，如按钮、开关和滑块</li>
</ol>
<p>如果你把这些逻辑分组看成单独的纹理，SpriteKit 和图形硬件必须更加艰难的运行来渲染场景， 而且游戏的性能可能会受到影响。所以 SpriteKit 使用纹理图册把相关的图像收集起来。你指定哪些资源一起使用，然后 Xcode 会自动构建纹理图册。然后在你的游戏加载纹理图册时， SpriteKit 可以更好地管理性能和内存使用。</p>
<p>Xcode 可以自动为你从图像集合构建纹理图册。</p>
<p>在创建一个纹理图册时，在收集太多的纹理与太少的纹理到图册之间，有一个平衡的做法。如果 你使用的项目数量不足，那么纹理之间切换的开销可能仍然太大。如果你把太多的图像放在一个 单一的图册中，那更多的纹理数据会存储在内存中。因为 Xcode 为你构建图册，它可以相对容易地在不同的图册配置之间切换。对你的纹理图册不同的配置做实验，并选择为你供最佳性能的结合。</p>
<p><strong>加载纹理图册</strong></p>
<p>SpriteKit 首先搜索指定的文件名的图像文件，但如果它没有找到，那么它会在内置到应用程序 bundle 里面的任何纹理图册内部进行搜索。这意味着，在你的游戏中你不必作出任何编码上的更改来支持它，美工试验新的纹理时不需要重新构建(rebuild)你的游戏。美工把纹理拖放到应用程序 bundle 中，覆盖任何之前内置到纹理图册的版本，然后就可以自动发现它们。一旦美工对纹理满意了，然后你就可以将它们添加到项目中且合并到你的纹理图册中。</p>
<p>如果你想显式使用纹理图册，你可以使用 SKTextureAtlas 类。首先，你使用图册的名称创建 一个纹理图册对象。然后使用图册中存储的图像文件的名字查看各自的纹理。</p>
<p>下面的例子采用了纹理图册装载一个角色的多个动画帧。代码加载这些帧，并将它们存储在一个数组中。</p>
<p>SKTextureAtlas * atlas = [SKTextureAtlas atlasNamed:@”monster.atlas”];</p>
<p>for (int i = 1; i &lt;= atlas.textureNames.count; i++) {</p>
<p>SKTexture * temp = [atlas textureNamed:[NSString stringWithFormat:@”%d”, i]];</p>
<p>[self.monsterWalkTextures addObject:temp];</p>
<p>}</p>
<p>// for (int i = 0; i &lt; atlas.textureNames.count; i++) {</p>
<p>// SKTexture * temp = [atlas textureNamed:atlas.textureNames[i]];</p>
<p>// [self.monsterWalkTextures addObject:temp];</p>
<p>// }</p>
<p>//self.node = [[SKSpriteNode alloc] initWithTexture:self.monsterWalkTextures[0]</p>
<p>   // color:SKColor.clearColor</p>
<pre><code>// size:CGSizeMake(30, 40)\];
</code></pre><p>self.node = [SKSpriteNode spriteNodeWithTexture:self.monsterWalkTextures[0]];</p>
<p>- (void)run</p>
<p>{</p>
<p>SKAction * repeat = [SKAction animateWithTextures:self.monsterWalkTextures</p>
<p>timePerFrame:0.03f</p>
<p>  resize:NO</p>
<pre><code>restore:YES\];
</code></pre><p>[self.noderunAction:[SKAction repeatActionForever:repeat]];</p>
<p>}</p>
<p>如果出现红色叉，原因是无法正确获取到纹理，需要检查纹理名称与图片名称是否对应。</p>
<p> <img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-AtlasError.gif" alt></p>
<p>3、从已有的纹理的一个区域创建新纹理</p>
<p>SKTexture * rectTexture = [SKTexture textureWithRect:CGRectMake(0, 0, 0.5, 0.5)</p>
<p>  inTexture:texture];</p>
<p>区域是处在一个单元坐标系统中，左下角为 (0, 0)。</p>
<p>(0, 0, 0.5, 0.5) 表示以左下角为起点，选中原纹理宽度的一半 * 高度的一半的区域。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-RectTexture.png" alt></p>
<p>图中分别有完整纹理以及它的四个部分。</p>
<p>4、其他创建纹理的方法</p>
<ul>
<li>使用 SKTexture 初始化方法通过内存中正确格式化的像素数据、核心图像或对现有的纹理应用一个Core Image 滤镜来创建纹理。</li>
<li>SKView 类的textureFromNode 方法可以把一个节点树的内容渲染成纹理。纹理被指定好尺寸，以便它可以包含节点的内容和所有它的可见后代节点。</li>
</ul>
<p>当你从应用程序 bundle 中的文件之外的其他来源创建一个纹理时，纹理数据不能被清除，因为 Sprite Kit不保留用于生成纹理的原始数据的引用。基于这个原因，你应该有节制地使用这些纹 理。一旦不再需要它们，马上移除对它们的强引用。</p>
<p><strong>四、预加载纹理来提高帧率</strong></p>
<p>使用 SpriteKit 的一个主要优点是它自动为你执行了大量的内存管理。Sprite Kit 从图像文件加 载纹理，将这些数据转换成图形硬件可以使用的格式，并将其上传到图形硬件。</p>
<p>Sprite Kit 很擅长于确定当前帧纹理是否需要渲染。如果纹理不在内存中，它会加载纹理。如果纹理在内存中并且有一段时间没有使用，纹理数据会被丢弃，以便可以加载其他需要的纹理。</p>
<p>如果一次有太多没加载纹理的精灵变为可见，它可能无法在一个单一的动画帧内加载所有这些纹理。纹理加载的延迟可能会导致帧速率突然丢失，这是对用户可见的。Sprite Kit 提供了在精灵变为可见之前预加载纹理的选项。因为你非常熟悉你的游戏的设计，你往往更清楚地知道什么时 候即将要使用一套新的纹理。例如，在一个滚动的游戏中，当用户在宇宙间移动时，你知道玩家即将进入宇宙的哪一部分，然后你可以在动画的每一帧加载三两个纹理，这样当玩家到达那里时纹理已经在内存中了。</p>
<p>[newSectionTexture preload];</p>
<p>预加载代码的正确设计要依赖于你的游戏的引擎。这里有两种可能设计要考虑:</p>
<ul>
<li>当玩家开始一个新的关卡，预加载这个关卡的所有纹理。游戏被划分成各个关卡，每个关卡能保持所有纹理资产同时在内存中。这保证了所有纹理在游戏开始前就加载好，消除任何纹理加载的延迟。</li>
<li>如果一个游戏需要比上面在内存中存储更多的纹理，那么你需要动态地预加载纹理。通常，这意味着当你能确定它很快就需要会才预加载纹理。例如，在赛车游戏中，玩家总是在同一方向移动，所以你预加载玩家即将看到的部分赛道的纹理。纹理在后台加载，取代赛道中最旧的纹理。在一个允许玩家时刻控制的冒险游戏中，你可能必须临时加载更多的纹理。</li>
</ul>
<p><strong>五、动作</strong></p>
<p>动作是一个有效不可变的对象，你可以在节点树的多个节点上安全地同时运行相同的动作。因此，如果你有一个在游戏中要反复使用的动作，那么可以构建一个单一的动作实例，然后每当你需要一个节点来执行它时再重用它。</p>
<p>瞬时动作(一帧内完成)或非瞬时动作(每一帧，直到完成)</p>
<p>如果你添加动作到节点时，场景正在处理动作，直到下一帧前，新的动作可能不会执行。</p>
<p>一个节点可以同时运行多个动作，即使那些动作在不同的时间执行。场景跟踪每个动作还要多久才完成并计算动作对节点产生的效果。例如，如果你运行两个动作移动相同的节点，这两个动作对每一帧都应用变化，如果移动动作大小相等、方向相反，则该节点将保持静止。</p>
<p>因为动作处理需要绑定到场景，只有当节点被添加到场景的节点树时动作才会被处理。你可以这样利用此特性：通过创建一个节点并分配动作给它，但等到以后再添加节点到场景。后来，当节点加入到了场景时，会立即开始执行它的动作。这种模式特别有用，因为在复制节点时，一个节点正在运行的动作也被复制和归档。</p>
<p>节点可以添加和移除动作。removeActionForKey: / removeAllActions</p>
<p>新运行一个动作时，如果已经有一个使用相同键的动作在执行，已有的动作会在新的动作添加之前先被移除掉。</p>
<ul>
<li>序列动作。序列中的每一个动作在前一个动作结束后开始。</li>
<li><p>组动作。存储在该组中的所有动作在同一时间开始执行。</p>
</li>
<li><p>重复动作。当子动作完成后，它重新启动。</p>
</li>
</ul>
<p><strong>六、动作计时</strong></p>
<p>默认情况下，一个动作的持续时间根据你指定的持续时间线性变化。但是你可以通过一些属性调整动画的计时：</p>
<ul>
<li>动作的 timingMode 属性可以用来为动画选择一个非线性的计时模式。</li>
<li>动作的 speed 属性可以改变动画播放的速率。speed 值为 1.0 是正常的速度，如果动作的 speed 属性设置为 2.0，当节点执行动作时，它速度快了一倍。要暂停动作，将值设置为 0。如果你调整那些包含其他动作(例如组、序列或重复动作)的动作的速率，速率会应用到所包含的动作。附加的动作也会受到它们自己的 speed 属性的作用。</li>
<li>节点的 speed 属性与动作的 speed 属性具有相同的效果，但节点的速率适用于该节点或节点树中的任意后代所处理的所有动作。</li>
</ul>
<p>动作最好的工作方式：创建一次然后使用多次。只要有可能，早创建动作，并将它们保存在一个很容易地检索和执行的位置。比如存储在节点的 userData 属性。</p>
<p>虽然动作非常有效，但创建动作并执行它是有成本的。如果你打算在动画的每一帧改变节点的属性，而这些变化在每帧都需要重新计算，你最好直接改变节点而不使用动作来做这些。</p>
<p><strong>七、坐标系</strong></p>
<p>当一个节点被放置在节点树中时，它的 position 属性把它定位在由它的父节点提供的坐标系内。Sprite Kit 在 iOS 和 OS X 中使用相同的坐标系。正数 的 x 坐标在右边而正数的 y 坐标在屏幕上方。<img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Axis.png" alt></p>
<p>Sprite Kit 还有一个标准的旋转约定(rotation convention)。弧度为 0 的角指定正 x 轴，沿逆时针方向是正角度。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-Rotate.png" alt></p>
<p>当你仅使用 Sprite Kit 代码时，一致的坐标系意味着你可以轻松地在游戏的 iOS 和 OS X 版本 之间共享代码。然而，它更意味着当你编写特定 OS 专用(OS-specific)的用户界面代码时， 你可能需要在操作系统的视图坐标系与 Sprite Kit 坐标系之间进行转换。最常见的情况就是使用 iOS 视图，它们的坐标系不同。</p>
<p>frame 代表节点在坐标系中的可视区域，calculateAccumulatedFrame 方法包括整个绘制节点及它所有后代的区域，如果父节点没有指定的 size 而子节点有，那么父节点的 size 由子节点决定 。</p>
<p>场景的尺寸以点为单位指定场景中可见部分的尺寸。树中的节点可以定位在该区域之外，这些节点仍由场景处理，但被渲染器(render)忽略。</p>
<p><strong>八、节点树</strong></p>
<p>场景渲染的标准行为遵循以下一对简单的规则：</p>
<ul>
<li>父节点先绘制自身的内容再渲染子节点。</li>
<li>子节点以它们在子节点数组中的顺序依次渲染。</li>
</ul>
<p>子节点在树中的顺序会影响场景处理的多个方 面，包括碰撞测试(hit testing)和渲染。</p>
<p>如果修改了同级节点的 zPosition 属性，那么渲染顺序也发生改变：</p>
<ul>
<li>父节点先绘制自身的内容再渲染子节点(不变)。</li>
<li>父节点从 z 值最大的子节点开始渲染，并以 z 值最小的孩子结束。所以 z 轴位置表示从子节点到一个假想的摄像机位置的距离。如果两个子节点有相同的 z 值，则在数组中较早出现的那个先绘制。</li>
</ul>
<p><strong>碰撞测试的顺序与绘制顺序相反</strong>。当 Sprite Kit 处理场景内的触摸或鼠标事件时，它在场景中查找想接受该事件的最接近节点。如果该节点不处理事件，则检查下一个最接近的节点，依此类推（响应链）。处理碰撞测试的顺序基本上是绘制顺序的反方向：</p>
<ul>
<li>父节点只在它的子节点传给它后才接受事件。</li>
<li>子节点从最小的 z 值到最大的 z 值进行处理。</li>
<li>如果两个子节点有相同的 z 值，先检测数组中后出现的那个。</li>
</ul>
<p>Sprite Kit 只使用 zPosition 的值来确定碰撞测试和绘制顺序。但是你可以使用指定的值来实现自己的游戏特效。例如：</p>
<ul>
<li>使用节点的深度来确定节点在屏幕上移动的速度，模拟视差滚动(parallax scrolling)。</li>
<li>使用节点的深度来影响它渲染的方式。</li>
</ul>
<p><strong>九、搜索节点树</strong></p>
<p>语法</p>
<p>描述</p>
<p>示例</p>
<p>/</p>
<p>放在搜索字符串的开头：表示应该对树的根节点进行搜索</p>
<p>/MyNode</p>
<p>//</p>
<p>放在搜索字符串的开头：指定搜索应从根节点开始，并在整个节点 树中递归进行。这做法在搜索字符串之外的其他地方都是不合法的</p>
<p>//*</p>
<p>//MyNode/SubNode</p>
<p>..</p>
<p>表明搜索应该向上移到该节点的父节点中进行</p>
<p>//MyNode/..</p>
<p> /</p>
<p> 放在搜索字符串的开头以外的任何地方：表明搜索应该移到节点的子节点中进行</p>
<p>MyNode/SubNode</p>
<p>*</p>
<p>搜索匹配零个或多个字符</p>
<p>[以逗号或破折号分隔的字符]</p>
<p>搜索将匹配括号内包含的任意字符</p>
<p>A[0-9]</p>
<p>字母和数字字符</p>
<p>搜索只匹配指定的字符</p>
<p><strong>十、配置过渡期间是否播放动画</strong></p>
<p>过渡对象的 pausesIncomingScene 和 pausesOutgoingScene 属性允许你定义动画是否在过渡期间播放。默认情况下两个场景的动画在过渡期间相继处理。但是可能你有需求暂停一个或两个场景，直到过渡完成。</p>
<p>当一个场景没有使用过渡呈现时，首先移除旧的场景，然后呈现新的场景。当使用过渡时，首先加入 新的场景，然后过渡发生，最后旧的场景被移除。</p>
<p><strong>十一、节点</strong></p>
<p>类</p>
<p>描述</p>
<p>SKNode</p>
<p>所有的节点类都从该类派生。它不绘制任何东西。</p>
<p>SKScene</p>
<p>场景是在节点树的根节点。它控制动画和动作的处理。</p>
<p>SKSpriteNode</p>
<p>绘制纹理精灵的节点。</p>
<p>SKLabelNode</p>
<p>渲染文本字符串的节点。</p>
<p>SKShapeNode</p>
<p>渲染基于 Core Graphics 路径的形状的节点。</p>
<p>SKVideoNode</p>
<p>播放视频内容的节点。</p>
<p>SKEmitterNode</p>
<p>创建和渲染粒子的节点。</p>
<p>SKCropNode</p>
<p>使用遮罩(mask)修剪其子节点的节点。</p>
<p>SKEffectNode</p>
<p>应用 Core Image 滤镜到其子节点的节点。</p>
<p><strong>十一、基础节点</strong></p>
<p>SKNode 类不绘制任何可视化内容。它的主要作用是为其他节点类提供使用的基础行为。然而，这并不意味着在你的游戏中没有使用 SKNode 对象的地方。下面是一些你可能会在你的游戏引擎内使用基础节点的方式：</p>
<ul>
<li>你有一个由多个节点对象组合的内容(无论是精灵或其他内容的节点)。你想在游戏中把此内容作为一个单独的对象，而不想令其中任何一个内容节点成为根节点。这时用基本节点是合适的，因为你可以给定它在场景树的位置，然后让所有的其他节点作为其后代。</li>
<li>使用节点对象组织绘制的内容到一系列的层。例如，许多游戏有一个世界背景层，有另一个角色层，而文本和其他的游戏信息在第三层，以及有更多的层。创建每个层为基本节点，并把它们按顺序插入到场景中。然后，必要时可以使个别图层可见或不可见。</li>
<li>您需要场景中一个不可见的对象，但要它执行一些其他必要的功能。例如，在一个地牢探索游戏中，一个不可见的节点可能用来代表一个隐藏的陷阱。当另一个节点与它相交时，就会触发陷阱。或另一个例子，你可能会添加一个节点作为另一个节点的子节点，而后者代表玩家在视图中的点的位置。</li>
</ul>
<p>在树中用这样的节点代表这些概念有以下优势：</p>
<ul>
<li>您可以通过添加或删除单个节点来添加或删除整个子树。这让场景管理变得有效率。</li>
<li>您可以调整的树中的一个节点的属性，这些属性的效果向下传播到节点的后代。 </li>
<li>您可以利用行动、物理接触和其他 Sprite Kit 的功能来实现此概念。</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2017/11/28/spritekit-e6-a0-b7-e4-be-8b/">http://yoursite.com/2017/11/28/spritekit-e6-a0-b7-e4-be-8b/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2017/11/28/spritekit-e7-bc-96-e7-a8-8b-e6-8c-87-e5-8d-97/" class="pre"> SpriteKit 编程指南		</a><a href="/2017/11/24/spritekit-e5-9c-ba-e6-99-af-e7-bc-96-e8-be-91-e5-99-a8/" class="next"> SpriteKit 场景编辑器		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>