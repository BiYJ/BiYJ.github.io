<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> SpriteKit 入门		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> SpriteKit 入门		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> SpriteKit 入门		</h1><div class="post-meta"><a href="/2017/11/24/spritekit-e5-85-a5-e9-97-a8/#comments" class="comment-count"></a><p><span class="date">Nov 24, 2017</span><span><a href="/categories/SpriteKit/" class="category">SpriteKit</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="http://blog.csdn.net/jiang314/article/details/53130126" target="_blank" rel="noopener">http://blog.csdn.net/jiang314/article/details/53130126</a></p>
<p><strong>一、什么是 SpriteKit</strong></p>
<p>Sprite 的中文译名是精灵。在游戏开发中，精灵指的是以图像方式呈现在屏幕上的一个图像。这个图像也许可以移动，用户可以与其交互，也有可能仅只是游戏的一个静止的背景图。塔防游戏中敌方源源不断涌来的每个小兵都是一个精灵，我方防御塔发出的炮弹也是精灵。可以说精灵构成了游戏的绝大部分主体视觉内容，而一个 2D 引擎的主要工作，就是高效地组织、管理和渲染这些精灵。</p>
<p>SpriteKit 是在 iOS7 SDK 中苹果新加入的一个 2D 游戏引擎框架，之前 iOS 开发平台上已经出现了像 cocos2d 这样的比较成熟的 2D 引擎解决方案。SpriteKit 展现出的是 Apple 将 Xcode 和 iOS/Mac SDK 打造成游戏引擎的野心，但是同时也确实与 IDE 有着更好的集成，减少了开发者的工作。</p>
<p><strong>二、Hello SpriteKit</strong></p>
<p>下面将非常流行的 <a href="http://www.raywenderlich.com/25736/how-to-make-a-simple-iphone-game-with-cocos2d-2-x-tutorial" target="_blank" rel="noopener">raywenderlich的经典 cocos2d 教程</a> 使用全新的 SpriteKit 重新实现一遍。这个 cocos2d 入门实在是太经典了，包括了精灵管理、交互检测、声音播放和场景切换等等方面的内容，麻雀虽小，却五脏俱全。</p>
<p>示例中<a href="https://onevcat.com/assets/images/2013/ResourcePackSpriteKit.zip" target="_blank" rel="noopener">素材</a>，<a href="https://github.com/onevcat/SpriteKitSimpleGame" target="_blank" rel="noopener">工程示例</a>。</p>
<p><strong>三、配置工程</strong></p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKit-300x216.jpg" alt></p>
<p>因为做的是一个横屏游戏，所以在工程 -> target -&gt; General -&gt; Depoyment Info 中Device Orientation 中的 Portrait 勾去掉。</p>
<p>通过 rotation 计算完毕之后再添加新的 Scene，这样得到的 Scene 的尺寸是正确的，如果在appear 之前就使用 bounds.size 添加的话，将会得到竖屏时的尺寸。所以将在 viewWillAppear 中添加 Scene。</p>
<p>- (void)viewDidAppear:(BOOL)animated</p>
<p>{</p>
<p>[super viewDidAppear:animated];</p>
<p>SKView <em> skView = (SKView </em>)self.view;</p>
<p>skView.showsFPS = YES;</p>
<p>skView.showsNodeCount = YES;</p>
<p>SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];</p>
<p>scene.scaleMode = SKSceneScaleModeAspectFill;</p>
<p>[skView presentScene:scene];</p>
<p>}</p>
<p><strong>三、加入精灵</strong></p>
<p>SpriteKit是基于场景(Scene)来组织的，每个 SKView(专门用于呈现 SpriteKit 的 View) 中可以渲染和管理一个 SKScene，每个 Scene 中可以装载多个精灵并管理它们的行为。</p>
<p>所有游戏逻辑和精灵管理都会在 Scene 中完成。在自定义的 MyScene.m 中重写 initWithSize 方法：</p>
<p>-(id)initWithSize:(CGSize)size</p>
<p>{</p>
<p>if (self = [super initWithSize:size]) {</p>
<p>// 1、设置工程的 Scene 背景</p>
<p>self.backgroundColor = SKColor.whiteColor;</p>
<p>}</p>
<p>return self;</p>
<p>}</p>
<p>/// 因为在 initWithSize 中获取的self.size 数值不正确，所以将代码放在didMoveToView</p>
<p>- (void)didMoveToView:(SKView *)view</p>
<p>{</p>
<p>// 2、传入图片名称创建一个精灵</p>
<p>SKSpriteNode * player = [SKSpriteNode spriteNodeWithImageNamed:@”player”];</p>
<p>// 3、设置精灵的位置</p>
<p>player.position = CGPointMake(player.size.width/2, self.size.height/2);</p>
<p>// 将精灵添加到当前的场景中</p>
<p>[self addChild:player];</p>
<p>}</p>
<ol>
<li>SKColor 只是一个宏定义，在 iOS 平台下被定义为 UIColor，在 Mac 下被定义为 NSColor。在 SpriteKit 开发时，尽量使用 SK 开头的对应的 UI 类可以统一代码而减少跨 iOS 和 Mac 平台的成本。</li>
<li>实际上一个 SKSpriteNode 中包含了贴图(SKTexture 对象)、颜色、尺寸等等参数。spriteNodeWithImageNamed:方法为我们读取图片，生成贴图，并设定精灵尺寸和图片大小一致。在实际使用中，绝大多数情况这个简便方法就足够了。</li>
<li>SpriteKit 中的坐标系和其他 OpenGL 游戏坐标系是一致的，屏幕左下角为(0, 0)。不过需要注意的是不论是横屏还是竖屏游戏，view 的尺寸都是按照竖屏进行计算的，而不会因为横屏而发生交换。因此在开发时，请千万不要使用绝对数值来进行位置设定及计算。</li>
</ol>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKitPlayer-300x169.png" alt></p>
<p><strong>四、源源不断涌来的怪物大军</strong></p>
<p>怪物与玩家的区别是会移动的 &amp; 怪物是每隔一段时间就会出现一个的。在 MyScene.m 中，加入一个方法：</p>
<p>- (void)addMonster</p>
<p>{</p>
<p>SKSpriteNode * monster = [SKSpriteNode spriteNodeWithImageNamed:@”monster”];</p>
<p>…    // 1、计算怪物的位置</p>
<p>monster.position = CGPointMake(x, y);</p>
<p>[self addChild:monster];</p>
<p>int duration = …;  // 2、计算运动的时间</p>
<p>SKAction * moveAction = [SKAction moveTo:CGPointMake(x, y)</p>
<p>  duration:duration];</p>
<p>SKAction * completeAction = [SKAction runBlock:^{</p>
<p>[monster removeFromParent];</p>
<p>}];</p>
<p>[monster runAction:[SKAction sequence:@[moveAction, completeAction]]];</p>
<p>}</p>
<ol>
<li>计算怪物的出生点(移动起始位置)的 Y 值。怪物从右侧屏幕外随机的高度处进入屏幕，为了保证怪物图像都在屏幕范围内，需要指定最小和最大 Y 值。然后从这个范围内随机一个 Y 值作为出生点。</li>
<li>怪物都一样的移动速度显得死板，可以设置不同的 duration</li>
<li>SKAction 可以操作 SKNode，完成精灵移动、旋转、消失等等。这里声明了两个 SKAction，moveAction负责将精灵在 duration 的时间间隔内移动到结束点，completeAction负责将精灵移出场景，其实是 run 一段接收到的 block 代码。runAction方法可以让精灵执行某个操作，而在这里我们要做的是先将精灵移动到结束点，当移动结束后，移除精灵。我们需要的是一个顺序执行，这里 sequence: 可以让我们顺序执行多个 action。</li>
</ol>
<p>然后尝试在上面的 -didMoveToView:里调用这个方法</p>
<p>- (void)didMoveToView:(SKView *)view</p>
<p>{</p>
<p>…</p>
<p>[self addMonster];</p>
<p>}</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2017/11/SpriteKitMonster-300x169.png" alt></p>
<p>知道么，游戏的本质是什么？就是一堆能动的图像！</p>
<p>在 -didMoveToView: 方法中创建源源不断的怪物：</p>
<p>- (void)didMoveToView:(SKView *)view</p>
<p>{</p>
<p>// 添加循环创建动作</p>
<p>SKAction * addAction = [SKAction runBlock:^{</p>
<p>[self addMonster];</p>
<p>}];</p>
<p>SKAction * waitAction = [SKAction waitForDuration:1];</p>
<p>SKAction * sequenceAction = [SKAction sequence:@[addAction, waitAction]];</p>
<p>SKAction * repeatAction = [SKAction repeatActionForever:sequenceAction];</p>
<p>[self runAction:repeatAction];</p>
<p>}</p>
<p>这里声明了一个 SKAction 的序列，run 一个 block，然后等待 1 秒。用这个动作序列生成一个无限重复的动作，然后让 scene 执行。这样就可以实现每秒调用一次 addMonster:来向场景中不断添加敌人了。</p>
<p>如果你对 Cocoa(Touch) 开发比较熟悉的话，可能会说，为什么不用一个 NSTimer 来做同样的事情，而要写这样的 SKAction 呢？能不能用 NSTimer 来达到同样的目的？答案是在对场景或者精灵等 SpriteKit 对象进行类似操作时，尽量不要用 NSTimer。因为 NSTimer 将不受 SpriteKit 的影响和管理，使用 SKAction 可以不加入其它任何代码就获取如下好处：</p>
<ul>
<li>自动暂停和继续。当设定一个 SKNode 的 <strong>paused</strong> 属性为 YES 时，这个 SKNode 和它管理的子node 的 action 都会自动被暂停。这里详细说明一下 SKNode 的概念：SKNode是 SpriteKit中要素的基本组织方式，它代表了 SKView 中的一种游戏资源的组织方式。我们现在接触到的SKScene 和 SKSprite 都是 SKNode 的子类，而一个 SKNode 可以有很多的子 Node，从而构成一个 SKNode 的树。在我们的例子中，MyScene 直接加在 SKView 中作为根 node 存在，而英雄或者敌人的精灵都作为 Scene 这个 node 的子 node 被添加进来。SKAction 和 node 上的各种属性的的作用范围是当前这个 node 和它的所有子 node，在这里我们如果设定 MySecnen 这个 node(也就是 self) 的 paused属性被设为 YES 的话，所有的 Action 都会被暂停，包括这个每隔一秒调用一次的 action，而如果使用 NSTimer 的话，必须自行维护它的状态。</li>
<li>当 SKAction 依附的结点被从结点树中拿掉的时候，这个 action 会自动结束并停止，这是符合一般逻辑的。</li>
</ul>
<p><img src="https://onevcat.com/assets/images/2013/sprtekit-monsters.gif" alt="添加了源源不断滚滚而来的敌人大军"></p>
<p><strong>五、奥特曼打小怪兽是天经地义的</strong></p>
<p>我们打算做的是在用户点击屏幕某个位置时，就由英雄所在的位置向点击位置发射一枚固定速度的飞镖。然后这每飞镖要是命中怪物的话，就把怪物从屏幕中移除。</p>
<p>先来实现发射飞镖吧。检测点击，然后让一个精灵朝向点击的方向以某个速度移动，有很多种SKAction 可以实现，但是为了尽量保持简单，我们使用上面曾经使用过的 moveTo:duration:吧。在发射之前，我们先要来做一点基本的数学运算，希望你还能记得相似三角形之类的概念。我们的飞镖是由英雄发出的，然后经过手指点击的点，两点决定一条直线。简单说我们需要求解出这条直线和屏幕右侧边缘外的交点，以此来确定飞镖的最终目的。一旦我们得到了这个终点，就可以控制飞镖 moveTo 到这个终点，从而模拟出发射飞镖的 action 了。</p>
<p><img src="https://onevcat.com/assets/images/2013/spritekit-math.png" alt="通过点击计算飞镖终止位置"></p>
<p>然后开始写代码吧，还记得我们之前点击会出现一个飞机的精灵么，找到相应的地方，MyScene.m里的 -touchesBegan:withEvent:，用下面的代码替换掉原来的。</p>
<p>-(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>CGSize winSize = self.size;</p>
<p>SKSpriteNode * projectile = [SKSpriteNode spriteNodeWithImageNamed:@”projectile.png”];</p>
<p>projectile.position = CGPointMake(projectile.size.width/2, winSize.height/2);</p>
<p>CGPoint location = [touch locationInNode:self];</p>
<p>CGPoint offset = CGPointMake(location.x - projectile.position.x, location.y - projectile.position.y);</p>
<p>if (offset.x &lt;= 0) return;</p>
<p>[self addChild:projectile];</p>
<p>int realX = winSize.width + (projectile.size.width/2);</p>
<p>float ratio = (float)offset.y / (float)offset.x;</p>
<p>int realY = (realX * ratio) + projectile.position.y;</p>
<p>CGPoint realDest = CGPointMake(realX, realY);</p>
<p>int offRealX = realX - projectile.position.x;</p>
<p>int offRealY = realY - projectile.position.y;</p>
<p>float length = sqrtf((offRealX <em> offRealX) + (offRealY </em> offRealY));</p>
<p>float velocity = self.size.width / 1;</p>
<p>float realMoveDuration = length/velocity;</p>
<p>[projectile runAction:[SKAction moveTo:realDest duration:realMoveDuration]</p>
<p>completion:^{</p>
<p>[projectile removeFromParent];</p>
<p>}];</p>
<p>}</p>
<p>}</p>
<ol>
<li>为飞镖设定初始位置。</li>
<li>将点击的位置转换为 node 的坐标系的坐标，并计算点击位置和飞镖位置的偏移量。如果点击位置在飞镖初始位置的后方，则直接返回。</li>
<li>根据相似三角形计算屏幕右侧外的结束位置。</li>
<li>移动飞镖，并在移动结束后将飞镖从场景中移除。注意在移动怪物的时候我们用了两个action(actionMove 和 actionMoveDone 来做移动+移除），这里只使用了一个 action 并用带completion block 移除精灵。这里对飞镖的这种做法是比较简明常见高效的，之前的做法只是为了说明 action 的 sequence: 的用法。</li>
</ol>
<p>运行看看现在的游戏吧，我们有英雄有怪物还有打怪物的小飞镖，好像气氛上已经开始有趣了！</p>
<p><img src="https://onevcat.com/assets/images/2013/spritekit-add-projectile.gif" alt="加入飞镖之后，游戏开始变得有趣了"></p>
<p><strong>六、飞镖击中的检测</strong></p>
<p>但是一个严重的问题是，现在的飞镖就算接触到了怪物也是直穿而过，完全就是空气一般的存在。为什么？因为我们还没有写任何检测飞镖和怪物的接触的代码（废话）。我们想要做的是在飞镖和怪物接触到的时候，将它们都移出场景，这样看起来就像是飞镖打中了怪物，并且把怪物消灭了。</p>
<p>基本思路是在每隔一个小的时间间隔，就扫描一遍场景中现存的飞镖和怪物。这里就需要提到SpriteKit 中最基本的每一帧的周期概念。</p>
<p><img src="https://onevcat.com/assets/images/2013/spritekit-update_loop.png" alt="SpriteKit的更新周期"></p>
<p>在 iOS 传统的 view 的系统中，view 的内容被渲染一次后就将一直等待，直到需要渲染的内容发生改变（比如用户发生交互，view 的迁移等）的时候，才进行下一次渲染。这主要是因为传统的 view 大多工作在静态环境下，并没有需要频繁改变的需求。而对于 SpriteKit 来说，其本身就是用来制作大多数时候是动态的游戏的，为了保证动画的流畅和场景的持续更新，在 SpriteKit 中 view 将会循环不断地重绘。</p>
<p>动画和渲染的进程是和 SKScene 对象绑定的，只有当场景被呈现时，这些渲染以及其中的 action 才会被执行。SKScene 实例中，一个循环按执行顺序包括：</p>
<ul>
<li>每一帧开始时，SKScene 的 -update:方法将被调用，参数是从开始时到调用时所经过的时间。在该方法中，我们应该实现一些游戏逻辑，包括 AI、精灵行为等等，另外也可以在该方法中更新 node的属性或者让 node 执行 action。</li>
<li>在 update 执行完毕后，SKScene 将会开始执行所有的 action。因为 action 是可以由开发者设定的，因此在这一个阶段我们也是可以执行自己的代码的。</li>
<li>在当前帧的 action 结束之后，SKScene 的 -didEvaluateActions 将被调用，我们可以在这个方法里对结点做最后的调整或者限制，之后将进入物理引擎的计算阶段。</li>
<li>然后 SKScene 将会开始物理计算，如果在结点上添加了 SKPhysicsBody 的话，那么这个结点将会具有物理特性，并参与到这个阶段的计算。根据物理计算的结果，SpriteKit 将会决定结点新的状态。</li>
<li>然后 -didSimulatePhysics 会被调用，这类似之前的 -didEvaluateActions。这里是我们开发者能参与的最后的地方，是我们改变结点的最后机会。</li>
<li>一帧的最后是渲染流程，根据之前设定和计算的结果对整个呈现的场景进行绘制。完成之后，SpriteKit 将开始新的一帧。</li>
</ul>
<p>在了解了一些 SpriteKit 的基础概念后，回到我们的 demo。检测场景上每个怪物和飞镖的状态，如果它们相撞就移除，这是对精灵的计算的和操作，我们可以将其放到 -update: 方法中来处理。在此之前，我们需要保存一下添加到场景中的怪物和飞镖，在 MyScene.m 的 @implementation 之前加入下面的声明：</p>
<p>@interface MyScene()</p>
<p>@property (nonatomic, strong) NSMutableArray * monsters;</p>
<p>@property (nonatomic, strong) NSMutableArray * projectiles;</p>
<p>@end</p>
<p>然后在 -initWithSize: 中配置场景之前，初始化这两个数组：</p>
<p>-(id)initWithSize:(CGSize)size</p>
<p>{</p>
<p>if (self = [super initWithSize:size]) {</p>
<p>self.monsters    = [NSMutableArray array];</p>
<p>self.projectiles = [NSMutableArray array];</p>
<p>//…</p>
<p>}</p>
<p>return self;</p>
<p>}</p>
<p>在将怪物或者飞镖加入场景中的同时，分别将它们加入到数组中</p>
<p>- (void)addMonster</p>
<p>{</p>
<p>//…</p>
<p>[self.monsters addObject:monster];</p>
<p>}</p>
<p>- (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>//…</p>
<p>[self.projectiles addObject:projectile];</p>
<p>}</p>
<p>}</p>
<p>同时，在将它们移除场景时，将它们移出所在数组，分别在 [monster removeFromParent] 和[projectile removeFromParent] 后加入[self.monsters removeObject:monster] 和 [self.projectiles removeObject:projectile]。接下来终于可以在 -update: 中检测并移除了：</p>
<p>- (void)update:(CFTimeInterval)currentTime</p>
<p>{</p>
<p>NSMutableArray * projectilesToDelete = [[NSMutableArray alloc] init];</p>
<p>for (SKSpriteNode * projectile in self.projectiles) {</p>
<p>NSMutableArray * monstersToDelete = [[NSMutableArray alloc] init];</p>
<p>for (SKSpriteNode * monster in self.monsters) {</p>
<p>if (CGRectIntersectsRect(projectile.frame, monster.frame)) {</p>
<p>[monstersToDelete addObject:monster];</p>
<p>}</p>
<p>}</p>
<p>for (SKSpriteNode * monster in monstersToDelete) {</p>
<p>[self.monsters removeObject:monster];</p>
<p>[monster removeFromParent];</p>
<p>}</p>
<p>if (monstersToDelete.count &gt; 0) {</p>
<p>[projectilesToDelete addObject:projectile];</p>
<p>}</p>
<p>}</p>
<p>for (SKSpriteNode * projectile in projectilesToDelete) {</p>
<p>[self.projectiles removeObject:projectile];</p>
<p>[projectile removeFromParent];</p>
<p>}</p>
<p>}</p>
<p>代码比较简单，不多解释了。直接运行看结果</p>
<p><img src="https://onevcat.com/assets/images/2013/spritekit-hit.gif" alt="发射飞镖，消灭敌人！"></p>
<p><strong>七、播放声音</strong></p>
<p>音效绝对是游戏的一个重要环节，还记得一开始下载的那个资源文件压缩包么？里面除了 Art 文件夹外还有个 Sounds 文件夹，我们把 Sounds 加入工程里，整个文件夹拖到工程导航里面，然后勾上 “Copy item”。</p>
<p>我们想在发射飞镖时播出一个音效，对于音效的播放是十分简单的，SpriteKit 为我们提供了一个action，用来播放单个音效。因为每次的音效是相同的，所以只需要在一开始加载一次 action，之后就一直使用这个 action，以提高效率。先在 MyScene.m 的 @interface 中加入</p>
<p>@property (nonatomic, strong) SKAction * soundAction;</p>
<p>然后在 -initWithSize: 一开始的地方加入</p>
<p>self.soundAction = [SKAction playSoundFileNamed:@”pew-pew-lei.caf”</p>
<p>waitForCompletion:NO];</p>
<p>最后，修改发射飞镖的 action，使播放音效的 action 和移动精灵的 action 同时执行。将 -touchesBegan:withEvent:最后 runAction 的部分改为</p>
<p>//…</p>
<p>SKAction * moveAction  = [SKAction moveTo:realDest duration:realMoveDuration];</p>
<p>SKAction * soundAction = [SKAction group:@[moveAction, self.soundAction]];</p>
<p>[projectile runAction:projectileCastAction</p>
<p>completion:^{</p>
<p>[projectile removeFromParent];</p>
<p>[self.projectiles removeObject:projectile];</p>
<p>}];</p>
<p>//…</p>
<p>之前我们介绍了用 -sequence: 连接不同的 action，使它们顺序串行执行。在这里我们用了另一个方便的方法 -group: 可以范围一个新的 action，这个 action 将并行同时开始执行传入的所有action。在这里我们在飞镖开始移动的同时，播放了一个 pew-pew-lei 的音效。</p>
<p>游戏中音效一般来说至少会有效果音(SE)和背景音(BGM)两种，SE 可以用 SpriteKit 的 action 来解决，而 BGM 就要惨一些，至少写这篇教程的时候，SpriteKit 还没有一个 BGM 的专门的对应方案（如果之后新加了的话我会更新本教程）。所以现在我们使用传统的播放较长背景音乐的方法来实现背景音，那就是用AVAudioPlayer。在 @interface MyScene() 中加入一个 bgmPlayer 的声明，然后在 -initWithSize: 中加载背景音并一直播放。</p>
<p>@interface MyScene()</p>
<p>//…</p>
<p>@property (nonatomic, strong) AVAudioPlayer * bgmPlayer;</p>
<p>//…</p>
<p>@end</p>
<p>@implementation MyScene -(id)initWithSize:(CGSize)size</p>
<p>{</p>
<p>//…</p>
<p>NSString * bgmPath = [[NSBundle mainBundle] pathForResource:@”bgm-aac”</p>
<p> ofType:@”caf”];</p>
<p>NSURL * url    = [NSURL fileURLWithPath:bgmPath];</p>
<p>self.bgmPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:NULL];</p>
<p>self.bgmPlayer.numberOfLoops = -1;</p>
<p>[self.bgmPlayer play];</p>
<p>//…</p>
<p>}</p>
<p>AVAudioPlayer 用来播放背景音乐相当的合适，唯一的问题是有可能你想在暂停的时候停止这个背景音乐的播放。因为使用的是 SpriteKit 以外的框架，而并非 action，因此 BGM 的播放不会随着设置 Scene 为暂停或者移除这个 Scene 而停止。想要停止播放，必须手动显式地调用[self.bgmPlayer stop]，可以说是比较麻烦，不过有时候你并不想在暂停或者场景切换的时候中断背景音乐的话，这反倒是一个好的选择。</p>
<p><strong>八、结果计算和场景切换</strong></p>
<p>到现在为止，整个关卡作为一个 demo 来说已经比较完善了。最后，我们可以为这个关卡设定一些条件，毕竟不是每个人都喜欢一直无意义地消灭怪物直到手机没电。我们设定规则，当打死 30 个怪物后切换到新的场景，以成功结束战斗的结果；另外，要是有任何一个怪物到达了屏幕左侧边缘，则本场战斗失败。另外我们在显示结果的场景中还需要一个交互按钮，以便我们重新开始一轮游戏。</p>
<p>首先是检测被打死的怪物数，在 MyScene 里添加一个 monstersDestroyed，然后在打中怪物时使这个值 +1，并在随后判断如果消灭怪物数量大于等于 30，则切换场景</p>
<p>@interface MyScene()</p>
<p>//…</p>
<p>@property (nonatomic, assign) int monstersDestroyed;</p>
<p>//…</p>
<p>@end</p>
<p>- (void)update:(CFTimeInterval)currentTime</p>
<p>{</p>
<p>//…</p>
<p>for (SKSpriteNode * monster in monstersToDelete) {</p>
<p>[self.monsters removeObject:monster];</p>
<p>[monster removeFromParent];</p>
<p>self.monstersDestroyed++;</p>
<p>if (self.monstersDestroyed &gt;= 30) {</p>
<p>//TODO: Show a win scene</p>
<p>}</p>
<p>}</p>
<p>//…</p>
<p>}</p>
<p>另外，在怪物到达屏幕边缘的时候也触发场景的切换：</p>
<p>- (void)addMonster</p>
<p>{</p>
<p>//…</p>
<p>SKAction * actionMoveDone = [SKAction runBlock:^{</p>
<p>[monster removeFromParent];</p>
<p>[self.monsters removeObject:monster];</p>
<p>//TODO: Show a lose scene</p>
<p>}];</p>
<p>//…</p>
<p>}</p>
<p>接下来就是制作新的表示结果的场景了。新建一个 SKScene 的子类很简单，和平时我们新建 Cocoa 或者 CocoaTouch 的类没有什么区别。菜单中 File-&gt;New-&gt;File…，选择 Objective-C class，然后将新建的文件取名为 ResultScene，父类填写为 SKScene，并在新建的时候选择合适的 Target 即可。在新建的 ResultScene.m 的 @implementation 中加入如下代码： </p>
<p>- (instancetype)initWithSize:(CGSize)size won:(BOOL)won</p>
<p>{</p>
<p>if (self = [super initWithSize:size]) {</p>
<p>self.backgroundColor = SKColor.whiteColor;</p>
<p>SKLabelNode * resultLabel = [SKLabelNode labelNodeWithFontNamed:@”Chalkduster”];</p>
<p>resultLabel.text = won ? @”You win!” : @”You lose!”;</p>
<p>resultLabel.fontSize  = 30;</p>
<p>resultLabel.fontColor = [SKColor blackColor];</p>
<p>resultLabel.position  = self.view.center;</p>
<p>[self addChild:resultLabel];</p>
<p>SKLabelNode * retryLabel = [SKLabelNode labelNodeWithFontNamed:@”Chalkduster”];</p>
<p>retryLabel.text = @”Try again”;</p>
<p>retryLabel.fontSize = 20;</p>
<p>retryLabel.fontColor = [SKColor blueColor];</p>
<p>retryLabel.position = CGPointMake(resultLabel.position.x, resultLabel.position.y * 0.8);</p>
<p>retryLabel.name = @”retryLabel”;</p>
<p>[self addChild:retryLabel];</p>
<p>}</p>
<p>return self;</p>
<p>}</p>
<p>我们在 ResultScene 中自定义了一个含有结果的初始化方法初始化，之后我们将使用这个方法来初始化 ResultScene。在这个 init 方法中我们做了以下这些事：</p>
<ol>
<li>根据输入添加了一个 SKLabelNode 来显示游戏的结果。SKLabelNode 也是 SKNode 的子类，可以用来方便地显示不同字体、颜色或者样式的文字标签。</li>
<li>在结果标签的下方加入了一个重开一盘的标签</li>
<li><p>我们为这个 node 进行了命名，通过对 node 命名，我们可以在之后方便地拿到这个 node 的参照，而不必新建一个变量来持有它。在实际运用中，这个命名即可以用来存储一个唯一的名字，来帮助我们之后找到特定的 node(使用 -childNodeWithName:)，也可以一堆特性类似的 node 共用一个名字，这样可以方便枚举(使用 -enumerateChildNodesWithName:usingBlock:</p>
<p>方法)。不过这次的 demo 中，我们只是简单地用字符串比较来确定 node，稍后会看到具体的用法。</p>
</li>
</ol>
<p>最后不要忘了这个方法名写到 .h 文件中去，这样我们才能在游戏场景中调用到。</p>
<p>回到游戏场景，在 MyScene.m 的加入对 ResultScene.h 的引用，然后在实现中加入一个切换场景的方法</p>
<p>#import “ResultScene.h”</p>
<p>//…</p>
<p>- (void)changeToResultSceneWithWon:(BOOL)won</p>
<p>{</p>
<p>[self.bgmPlayer stop];</p>
<p>self.bgmPlayer = nil;</p>
<p>ResultScene <em> rs = [[ResultScene alloc] initWithSize:self.size won:won]; SKTransition </em> reveal = [SKTransition revealWithDirection:SKTransitionDirectionUp</p>
<p>duration:1.0];</p>
<p>[self.scene.view presentScene:rs transition:reveal];</p>
<p>}</p>
<p>SKTransition是专门用来做不同的 Scene 之前切换的类，这个类为我们提供了很多”廉价”的场景切换效果。在这里我们建立了一个将当前场景上推的切换效果，来显示新的 ResultScene。另外注意我们在这里停止了 BGM 的播放。之后，将刚才留下来的两个 TODO 的地方，分别替换为以相应参数对这个方法的调用。</p>
<p>最后，我们想要在 ResultScene 中点击 Retry 标签时，重开一盘游戏。在 ResultScene.m 中加入代码：</p>
<p>- (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event</p>
<p>{</p>
<p>for (UITouch * touch in touches) {</p>
<p>SKNode * node = [self nodeAtPoint:[touch locationInNode:self]];</p>
<p>if ([node.name isEqualToString:@”retryLabel”]) {</p>
<p>MyScene * ms = [MyScene sceneWithSize:self.size];</p>
<p>SKTransition * reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:1.0];</p>
<p>[self.scene.view presentScene:ms transition:reveal];</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>运行游戏，消灭足够多的敌人（或者漏过一个敌人），应该能够可能到场景切换和结果显示。然后点击再来一次的话，将重新开始新的游戏。</p>
<p><img src="https://onevcat.com/assets/images/2013/spritekit-result.png" alt="结束时显示结果场景"></p>
<p><strong>九、关于 Sprite 的一些个人补充</strong></p>
<p>首先是性能问题，如果有在 iOS 平台下使用 cocos2d 开发的经验的话，很容易看出来 SpriteKit 在很多地方借鉴了 cocos2d。作为 SDK 内置的框架来说，又有 cocos2d 的开源实现进行参考，效率方面超越 cocos2d 应该是理所当然的。在现有的一系列 benchmark 上来看，实际上 SpriteKit 在图形渲染方面也有着很不错的表现。另外，在编写过程中，也有不少技巧可以使用，以进一步进行优化，比如在内存中保持住常用的 action，预先加载资源，使用 Atlas 等等。在进行比较全面和完整的优化后，SpriteKit 的表现应该是可以期待的。</p>
<p>使用 SpriteKit 一个很明显的优点在于，SKView 其实是基于 UIKit 的 UIView 的一套实现，而其中的所有 SKNode 对象都 UIResponder 的子类，并且实现了 NSCoding 等接口。也就是说，其实在SpriteKit 中是可以很容易地使用其他的非游戏 Cocoa/CocoaTouch 框架的。比如可以使用 UIKit或者 Cocoa 来简单地制作 UI，然后只在需要每帧演算的时候使用 SpriteKit，藉此来达到快速开发的目的。这点上 cocos2d 是无法与之比拟的。另外，因为 SKSprite 同时兼顾了 iOS 和 Mac两者，因此在我们进行开发时如果能稍加注意，理论上可以比较容易地完成 iOS 和 Mac 的跨平台。</p>
<p>由于 SKNode 是 UIResponder 的子类，因此在真正制作游戏的时候，对于相应用户点击等操作我们是不必（也不应该）像 demo 中一样全部放在 Scene 点击事件中，而是应该尽量封装游戏中用到的node，并在 node 中处理用户的点击，并且委托到 Scene 中进行处理，可能逻辑上会更加清晰。</p>
<p>关于用户交互事件的处理，另外一个需要注意的地方在于，使用 UIResponder 监测的用户交互事件和 SKScene 的事件循环是相互独立的。如果像我们的 demo 中那样直接处理用户点击并和 SpriteKit 交互的话，我们并不能确定这个执行时机在 SKScene 循环中的状态。比如点击的相关代码也许会在 -update 后执行，也可能在 -didSimulatePhysics 后被调用，这引入了执行顺序的不确定性。对于上面的这个简单的 demo 来说这没有什么太大关系，但是在对于时间敏感的游戏逻辑或者带有物理模拟的游戏中，也许时序会很关键。由于点击事件的时序和精灵动画和物理等的时序不确定，有可能造成奇怪的问题。对此现在暂时的解决方法是仅在点击事件中设置一个标志位记录点击状态，然后在接下来的 -update: 中进行检测并处理(苹果给出的官方 SpriteKit 的 “Adventure” 是这样处理的)，以此来保证时序的正确性。代价是点击事件会延迟一帧才会被处理，虽然在绝大多数情况下并不是什么问题，但是其实这点上并不优雅，至少在现在的 beta 版中，算不上优雅。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2017/11/24/spritekit-e5-85-a5-e9-97-a8/">http://yoursite.com/2017/11/24/spritekit-e5-85-a5-e9-97-a8/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2017/11/24/spritekit-e5-9c-ba-e6-99-af-e7-bc-96-e8-be-91-e5-99-a8/" class="pre"> SpriteKit 场景编辑器		</a><a href="/2017/11/13/macro/" class="next"> macro		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>