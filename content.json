[{"title":"iOS 页面流畅技巧","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS 页面流畅技巧/","text":"一、屏幕显示图像原理首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。 二、卡顿产生的原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。 三、CPU 资源消耗的原因和解决方案3.1 对象的创建对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以： ①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适； ②、如果对象不涉及 UI 操作，尽量放到后台线程去创建； ③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用； ④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去； ⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 3.2 对象调整对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer： ①、CALayer 内部没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源； ②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改； ③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3.3 对象销毁当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了： 12345NSArray * tmp = self.arr_data;self.arr_data = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 3.4 对象布局在后台线程提前计算好视图布局、并对视图的布局进行缓存。 不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。 3.5 Autolayout这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但对于复杂视图来说常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。 3.6 文本计算如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。 3.7 文本渲染屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。 显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制，尽管麻烦但优势强大： ①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）； ②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。 3.8 图片解码用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。 该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 3.9 图像的绘制是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致） 123456789101112- (void)display&#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 四、GPU 资源消耗原因和解决方案GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。 4.1 纹理的渲染所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。 4.2 视图的混合（Composing）当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。 所以应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 也可以把多个视图预先渲染为一张图片来显示。 4.3 图形的生成CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。 当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。 对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。 最彻底的做法：把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 五、文章幸运的芳1990 &amp; 浅谈iOS页面流畅技巧","tags":[]},{"title":"图片加载和处理","date":"2019-05-23T10:19:03.939Z","path":"2019/05/23/图片加载和处理/","text":"一、图片显示图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。 以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。UIImage 持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。 当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。 解码是一个计算量较大且需要 CPU 来执行的任务；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 高 每个像素点的大小 = width height 4bytes。 图像解码操作会造成什么问题？ 以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于在主线程同时进行 IO 操作、解码操作等，会造成内存迅速增长和 CPU 负载瞬间提升。 并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。 1.1 优化一：降采样在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示： 我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。 思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？ 12345678910111213141516171819202122- (UIImage *)downsampleImageAt:(NSURL *)imageURL to:(CGSize)pointSize scale:(CGFloat)scale&#123; CFDictionaryRef imageSourceOptions = CFDictionaryCreate ( CFAllocatorGetDefault(), (void *)@[ (NSString *)kCGImageSourceShouldCache ], (void *)@[ @(YES) ], 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, imageSourceOptions); NSInteger maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale; CFDictionaryRef downsampleOptions = (__bridge CFDictionaryRef)@&#123; (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @(YES), (NSString *)kCGImageSourceShouldCacheImmediately : @(YES), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @(YES), (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;; CGImageRef downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions); return [UIImage imageWithCGImage:downsampledImage];&#125; 正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。 1.2 优化二：异步处理 从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以在 Prefetching 时把降采样放到子线程进行处理，因为降采样过程就包括解码操作。 Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。 需要特别注意，此处不能是并发队列，否则会造成线程爆炸，原因见总结部分。 123456789101112131415161718192021222324252627282930313233343536&#123; // 创建串行队列 _serialQueue = dispatch_queue_create(\"DecodeQueue\", DISPATCH_QUEUE_SERIAL);&#125;/** * @brief 获取单元格的图片 */- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAt:(NSArray&lt;NSIndexPath *&gt; *)indexPaths&#123; for (NSIndexPath * indexPath in indexPaths) &#123; dispatch_async(_serialQueue, ^&#123; UIImage * downsampledImage = [self downsample]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self updateAt:indexPath with:downsampledImage]; &#125;); &#125;); &#125;&#125;/** * @brief 降采样。自行实现。 */- (UIImage *)downsample&#123; return nil;&#125;/** * @brief 更新单元格的图片 */- (void)updateAt:(NSIndexPath *)indexPath with:(UIImage *)image&#123; &#125; 1.3 优化三：使用 Image Asset Catalogs苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。 WWDC Session。 二、总结应用上述的优化策略，已经能对图片加载有比较好的优化。 WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。 三、WWDC学习原作者的经验：落影loyinglin 先主观假设两个前提： ①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚； ②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。 所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，看我们的 iOS 知识体系是否存在缺陷；另外，WWDC 介绍的很多知识点同样免验证的加入自己的知识体系。 以上文提到的线程爆炸为例，看看这种方式的好处。 原文如下： Thread Explosion（线程爆炸） More images to decode than available CPUs（解码图像数量大于 CPU 数量）GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像） 从这个案例我们学习到如何避免图像解码的线程爆炸，我们分析苹果工程师的逻辑，然后扩散思维： 原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间 延伸出来的问题： GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？… 举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来： ①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别； ②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。 接下来的表现是操作系统相关的知识： ①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程； ②、cpu 的时间是分为多个时间片，每个线程轮询执行； ③、线程切换执行有代价，但比进程切换小得多； ④、每个 cpu 核心在同一时刻只能执行一个线程。 至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现： 主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。 结合此案例，我们能回答相关问题： ①、现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？ ②、GCD 的串行队列和并发队列的应用场景有何不同？ 四、文章iOS性能优化–图片加载和处理 WWDC2018-Image and Graphics Best Practices","tags":[]},{"title":"NSDateFormatter性能","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/NSDateFormatter性能/","text":"一、探究123NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];NSString * current = [dateFormatter stringFromDate:[NSDate date]]; 关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。 1234567891011121314151617181920212223242526272829303132333435363738394041double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = nil;&#123; begin = CACurrentMediaTime(); for (int i = 0; i &lt; 1000; i++) &#123; formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter: %8.2f ms\", (end - begin) * 1000);&#125;&#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter once: %8.2f ms\", (end - begin) * 1000);&#125;-----------Xcode 10.1 iPhone 6s(10.0)----------2019-03-01 10:08:42.184 Demo[95118:1359994] NSDateFormatter: 48.73 ms2019-03-01 10:08:42.188 Demo[95118:1359994] NSDateFormatter once: 3.57 ms2019-03-01 10:11:18.871 Demo[95164:1361958] NSDateFormatter: 61.18 ms2019-03-01 10:11:18.875 Demo[95164:1361958] NSDateFormatter once: 3.85 ms2019-03-01 10:12:03.123 Demo[95178:1362677] NSDateFormatter: 79.80 ms2019-03-01 10:12:03.129 Demo[95178:1362677] NSDateFormatter once: 6.08 ms 上面可以看出两者之间消耗时间差距很大。创建单例很有必要。 那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？ 123456789101112131415161718192021222324252627282930313233343536373839NSDateFormatter * formatter = nil;double begin = 0.0;double end = 0.0;double a = 0, b = 0, c = 0;for (int i = 0; i &lt; 1000; i++) &#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; end = CACurrentMediaTime(); a += (end - begin); begin = CACurrentMediaTime(); [formatter setDateFormat:@\"yyyy-MM-dd\"]; end = CACurrentMediaTime(); b += (end - begin); begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); c += (end - begin);&#125;NSLog(@\"NSDateFormatter:alloc %8.2f ms\", a * 1000);NSLog(@\"NSDateFormatter:setFormat %8.2f ms\", b * 1000);NSLog(@\"NSDateFormatter:stringFromDate %8.2f ms\", c * 1000);-------------Xcode 10.1 iPhone 6s(10.0)-------------2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:alloc 7.01 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:setFormat 0.28 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:stringFromDate 55.98 ms2019-03-01 10:12:03.198 Demo[95178:1362677] NSDateFormatter:alloc 7.69 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:setFormat 0.25 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:stringFromDate 60.97 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:alloc 6.01 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:setFormat 0.20 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:stringFromDate 49.06 ms 从上面可以看出，实际最耗时的方法是 stringFromDate:/dateFromString:。再往下细究。 1234567891011121314151617181920212223242526272829303132double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); NSLog(@\"%8.2f ms\", (end - begin) * 1000);&#125;-------------Xcode 10.0 iPhone 6s(10.0)-------------2019-03-01 10:27:06.218 Demo[95456:1372764] 1.43 ms2019-03-01 10:27:06.218 Demo[95456:1372764] 0.03 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms 从上面可以看出，只有首次调用 stringFromDate:/dateFromString: 方法才会很耗时。再往下细究。 还有人说应该针对 format 格式创建对应的单例对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double begin = 0.0;double end = 0.0;// 不同的对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter1 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter2 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter3 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter4 = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter1 setDateFormat:@\"yyyy-MM-dd\"]; [formatter1 stringFromDate:[NSDate date]]; [formatter2 setDateFormat:@\"MM-dd-yyyy\"]; [formatter2 stringFromDate:[NSDate date]]; [formatter3 setDateFormat:@\"MM-dd\"]; [formatter3 stringFromDate:[NSDate date]]; [formatter4 setDateFormat:@\"MM-yyyy\"]; [formatter4 stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: different format %8.2f ms\\n\", (end - begin) * 1000);&#125;// 同一个对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd-yyyy\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-yyyy\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: %8.2f ms\\n\", (end - begin) * 1000);&#125;---------------Xcode 10.1 iPhone 6s(10.0)---------------NSDateFormatter: different format 23.26 msNSDateFormatter: 16.25 ms 如果不计 NSDateFormatter 对象的初始化时间，那么打印输出： 12NSDateFormatter:different format 23.81 msNSDateFormatter: 23.02 ms 两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。 二、文章NSDateFormatter 性能测试","tags":[]},{"title":"iOS 内置图片瘦身","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/iOS 内置图片瘦身/","text":"一、iOS 内置资源的集中方式1.1 将图片存放在 bundle这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到隔离资源的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。 这种方式有比较明显的缺点： ①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。 ②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。 在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。 下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下： 以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。 1.2 使用 .ttf 字体文件替代图标使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。 使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。 字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。 123UILabel * iconLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];iconLabel.font = [UIFont fontWithName:@\"icomoon\" size:50];iconLabel.text = [NSString stringWithUTF8String:\"\\ue902\"]; 由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。 优点： ①、可以降低应用图片内置资源的体积。 ②、可以随意缩放和修改颜色。 缺点： ①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。 ②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。 任何一种需要大刀阔斧改革的优化都是一种不明智的行为。 1.3 图片存在 Assets.xcassets使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。 二、优化项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。 为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。 与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。.framework 中可以存放资源，但 .a 不可以，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。 优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。 先要抛出两个问题： &emsp;①、cocoapods 是否支持使用 Assets.xcassets。 &emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。 为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数： 1234567s.source_files ：源文件路径。s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。s.resources ：资源文件路径及文件类型。s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。 实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。 如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。 查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。 最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。 运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。 既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案： ①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。 ②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。 ③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。 ④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。 只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示： 看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。 为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如 很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。 123456789- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); return value;&#125; 打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。 在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。 这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息： 重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。 12345678910111213141516171819202122- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @\"emaNecruoseRIU\"; // 反转字符串 propKey = [XUtil stringByReversed:propKey]; if ([key isEqualToString:propKey]) &#123; if (normal_imageName) &#123; select_imageName = value; &#125; else &#123; normal_imageName = value; &#125; &#125; return value;&#125; hook UIImageView 的 initWithCoder: 12345678910111213141516171819202122- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; if (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[NSString class]] &amp;&amp; normal_imageName.length &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:normal_imageName]; // 赋值 if (normalImage) &#123; instance.image = normalImage; &#125; normal_imageName = nil; select_imageName = nil; &#125; return instance;&#125; 上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。 但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对增加了项目维护的难度。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。 hook method_exchangeImplementations 方法。 检测方法（字典写入时不要忘了加锁）。 这种方式不能区分 image 和 backgroundImage、normal 和 Selected。目前根据观察顺序应该是： 1234UIResourceName ： normal - image(前景图)UIResourceName ： normal - backgroundImage(背景图)UIResourceName ： selected - image(前景图)UIResourceName ： selected - backgroundImage(背景图)","tags":[]},{"title":"利用预渲染加速iOS设备的图像显示","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/利用预渲染加速iOS设备的图像显示/","text":"使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。 于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。 接着下面举个例子程序来验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;UIKit/UIKit.h&gt;@interface ImageView : UIView@property (nonatomic, strong) UIImage * image;@end#import \"ImageView.h\"#include &lt;mach/mach_time.h&gt;static const CGRect imageRect = &#123; &#123;0, 0&#125;, &#123;100, 100&#125;&#125;;@implementation ImageView- (void)awakeFromNib&#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; &#125; [superawakeFromNib];&#125; - (void)drawRect:(CGRect)rect&#123; if (CGRectContainsRect(rect, imageRect)) &#123; uint64_t start = getTickCount(); [self.image drawInRect:imageRect]; uint64_t drawTime = getTickCount() - start; NSLog(@\"%llu\", drawTime); // 打印时间间隔 &#125;&#125;// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。uint64_t getTickCount(void)&#123; static mach_timebase_info_data_t sTimebaseInfo; uint64_t machTime = mach_absolute_time(); // Convert to nanoseconds - if this is the first time we've run, get the timebase. if (sTimebaseInfo.denom == 0) &#123; (void)mach_timebase_info(&amp;sTimebaseInfo); &#125; uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom; // 纳秒 return millis;&#125;@end 测试用一张 1838 * 890 的图 2018-07-05 11:05:25.950978+0800 Demo[5831:113872] 31802012 接下来就是见证奇迹的时刻了，把这段代码加入程序： 12345678910111213141516static const CGSize imageSize = &#123;100, 100&#125;;- (void)awakeFromNib &#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; // 由于JPEG图像是不透明的，所以第二个参数就设为YES // 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了 UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0); // 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作 [image drawInRect:imageRect]; self.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); &#125;&#125; 值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。 时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] 127939，缩短了很多。 还能更快吗？让我们来试试 Core Graphics。 先定义一个全局的 CGImageRef 变量： 123456static CGImageRef imageRef;- (void)awakeFromNib&#123; imageRef = self.image.CGImage;&#125; 然后 12345- (void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawImage(context, imageRect, imageRef);&#125; 运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] 27425265，而且图像还上下颠倒了⋯ 这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正： 1234CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, 0, 100);CGContextScaleCTM(context, 1, -1);CGContextDrawImage(context, imageRect, imageRef); 这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] 34242146，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。","tags":[]},{"title":"UITableView优化","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/UITableView优化/","text":"一、Cell 复用在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 解决方案：创建一个静态变量 reuseID，防止重复创建（提高性能），使用系统的缓存池功能。 123456789static NSString * CELL_RUID = @\"CELL\"; // 调用次数太多，static 保证只创建一次 reuseID，提高性能- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 缓存池中取已经创建的 cell UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID forIndexPath:indexPath]; return cell;&#125; 通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。 12- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 复用 Cell 时 不会调用 awakeFromNib。 获取方法的区别 dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示： 1reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard' dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示： 1failed to obtain a cell from its dataSource 判断 nil 后可以自己创建 cell。 123456&#123; MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot;]; if (cell == nil) &#123; cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;]; &#125;&#125; 为什么需要 forIndexPath: 因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。 我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。 注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。 二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的。 好处： ①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（多个 Cell 不是更容易维护？） ②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。 既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。 尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。 三、提前计算并缓存 Cell 的高度3.1 固定高度的 cell1self.tableView.rowHeight = 88; 直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。 3.2 动态高度的 cell实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。 tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。 解决方案：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。 12345678910@interface Model : NSObject@property (nonatomic, assign) CGFloat cellHeight; // Cell 高度/** * @brief 计算高度 */ - (void)calculateCellHeight;@end 在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。 还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。 四、异步绘制（自定义 Cell 绘制）遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。详细整理：UITableView 优化技巧 123456789101112131415161718/** * @brief cell 添加 draw 方法 */- (void)draw&#123; // 异步绘制 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);&#125;/** * @brief 重写 drawRect: 方法 */- (void)drawRect:(CGRect)rect&#123; // 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。&#125; 绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。 五、滑动时，按需加载自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。 123456789101112131415161718192021222324252627282930313233343536- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (needLoadArr.count &gt; 0 &amp;&amp; [needLoadArr indexOfObject:indexPath] == NSNotFound) &#123; [cell clear]; // 清掉内容 &#125; return cell;&#125;// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath * ip = [self.tableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath * cip = [[self.tableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 8; // -8 &lt; 当前位置 - 目标位置 &lt; 8 if (labs(cip.row - ip.row) &gt; skipCount) &#123; // 目标区域的 cell 的 indexPaths NSArray * temp = [self.tableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.tableView.frame.size.width, self.tableView.frame.size.height)]; NSMutableArray * arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y &lt; 0) &#123; NSIndexPath * indexPath = [temp lastObject]; if (indexPath.row + 33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 3 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 2 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。 六、缓存 View当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。 七、尽量显示“大小刚好合适的”图片资源避免大量的图片缩放、颜色渐变等。 八、避免同步的从网络、文件获取数据Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。 九、渲染1、减少 subviews 的个数和层级 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。 2、少用 subviews 的透明图层 渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。 3、背景色不要使用 clearColor 4、避免 CALayer 特效（shadowPath） 给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿： 1234view.layer.shadowColor = color.CGColor;view.layer.shadowOffset = offset;view.layer.shadowOpacity = 1;view.layer.shadowRadius = radius; 5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。 十、总结UITableView 的优化主要从四个方面入手： 1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法； 2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage； 3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。 大概需要关注的： 1、cell 复用 2、cell 高度的计算 3、渲染（混合问题） 4、减少视图的数目（重写 drawRect:） 5、减少多余的绘制操作 6、不要给 cell 动态添加 subView 7、异步化 UI，不要阻塞主线程 8、滑动时按需加载对应的内容 十一、资料图片加载优化官方 Demo：LazyTableImages 文章：提升 UITableView 性能-复杂页面的优化 代码：VVeboTableViewDemo","tags":[]},{"title":"图片设置圆角性能问题","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/图片设置圆角性能问题/","text":"通常设置圆角方式 12imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50; 这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。 注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。 一、设置圆角的方法①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。 ②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化 1234imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50;imageView.layer.shouldRasterize = YES; // 设置光栅化imageView.layer.rasterizationScale = [UIScreen mainScreen].scale; // UIImageView 不加这句会产生一点模糊 设置光栅化可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。 但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 ③、直接覆盖一张中间为圆形透明的图片（推荐使用） 这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。 这种圆片覆盖的方法一般只用在底色为纯色的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色） ④、UIImage drawInRect 绘制圆角 这种方式 GPU 损耗低内存占用大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface CornerImageView ()&#123; NSBlockOperation * _operation; // 任务 NSOperationQueue * _queue; UIImage * _cornerImage; // 圆角化的图片&#125;@end@implementation CornerImageView- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; _queue = [[NSOperationQueue alloc] init]; &#125; return self;&#125;/** * 重写设置方法。如果是 UIButton 可以换成 setImage:forState: */- (void)setImage:(UIImage *)image&#123; [super setImage:nil]; [self roundedImage:image];&#125;- (void)roundedImage:(UIImage *)image&#123; [_queue cancelAllOperations]; [_operation cancel]; _operation = nil; _operation = [NSBlockOperation blockOperationWithBlock:^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, [UIScreen mainScreen].scale); // Add a clip before drawing anything, in the shape of an rounded rect [[UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:self.bounds.size.height / 2] addClip]; [image drawInRect:self.bounds]; _cornerImage = UIGraphicsGetImageFromCurrentImageContext(); // Lets forget about that we were drawing UIGraphicsEndImageContext(); if (!_operation) &#123; return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [super setImage:_cornerImage]; &#125;); &#125;]; [_queue addOperation:_operation];&#125; 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。 问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？ ⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface UIImage (corner)+ (id)createRoundedRectImage:(UIImage *)image;@end@implementation UIImage (corner)static void addRoundedRectToPath(CGContextRef context, CGRect rect, float ovalWidth, float ovalHeight)&#123; float fw, fh; if (ovalWidth == 0 || ovalHeight == 0) &#123; CGContextAddRect(context, rect); return; &#125; CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); CGContextScaleCTM(context, ovalWidth, ovalHeight); fw = CGRectGetWidth(rect) / ovalWidth; fh = CGRectGetHeight(rect) / ovalHeight; // 使的圆角半径为 1 CGContextMoveToPoint(context, fw, fh/2); // Start at lower right corner CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1); // Top right corner CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1); // Top left corner CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1); // Lower left corner CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); // Back to lower right CGContextClosePath(context); CGContextRestoreGState(context);&#125;+ (id)createRoundedRectImage:(UIImage *)image&#123; CGFloat wh = MIN(MAX(image.size.width, image.size.height), 160); CGSize imageSize = CGSizeMake(wh, wh); CGfloat radius = wh / 2; CGContextRef context = CGBitmapContextCreate( NULL, wh, wh, 8, 4 * wh, CGColorSpaceCreateDeviceRGB(), kCGImageAlphaPremultipliedFirst ); // 绘制圆角 CGContextBeginPath(context); addRoundedRectToPath(context, CGRectMake(0, 0, wh, wh), radius, radius); CGContextClosePath(context); CGContextClip(context); CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); CGImageRef imageMasked = CGBitmapContextCreateImage(context); image = [UIImage imageWithCGImage:imageMasked]; CGContextRelease(context); CGImageRelease(imageMasked); return image;&#125; 以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。 123456/** * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 '(x1，y1)' 的直线相切，与 '(x1，y1)' 到 '(x2, y2)' 的直线相切。 */CG_EXTERN void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) CG_AVAILABLE_STARTING(10.0, 2.0); 二、使用 Instruments 的 Core Animation 查看性能 Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 用 Instruments 测试得： ①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。 ②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。 ③、添加圆形透明图片，无任何高亮，说明没离屏渲染。 ④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大） ⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法) 三、问题①、有提到还有一种 mask 方法。 这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考小心别让圆角成了你列表的帧数杀手。 ②、第四种比第一种更卡。 第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。 可以用 Instruments的 GPU Driver 进行测试： Renderer Utilization 如果这个值 &gt; 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization 如果这个值 &gt; 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。 第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。 帧率越接近 60 滑动越顺畅。 发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。 如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。 而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。 所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。 四、参考文章 内存恶鬼drawRect - 谈画图功能的内存优化 github 绘制圆角源码参考 NZCircularImageView、HJCornerRadius","tags":[]},{"title":"0-1 背包","date":"2019-05-23T10:19:03.934Z","path":"2019/05/23/01-背包/","text":"01 背包问题是用来介绍动态规划算法最经典的例子。 一、解释 1①、状态方程 f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] } ( j &gt;= Wi ) f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。 决策：为了背包中物品总价值最大化，第 i 件物品应该放入背包中吗 ？ ②、实例 假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。 只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。 首先要明确这张表是至底向上，从左到右生成的。 用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。 对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。 同理 c2 = 0，b2 = 3，a2 = 6。 对于承重为 8 的背包，a8 = 15 是怎么得出的呢？ 根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。 f[i-1, j] 表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 Pi 指的是 a 物品的价值，即 6。 由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。 ③、代码 物品信息类 12345678910111213141516171819202122232425@interface PackageItem : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger weight;@property (nonatomic, assign) NSInteger value;- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;@end@implementation PackageItem- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value&#123; if (self = [super init]) &#123; self.name = name; self.weight = weight; self.value = value; &#125; return self;&#125;@end 非递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]; for(int i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; &#125; [self packageAlgorithm:bagItems bagSize:10];&#125;/** * @brief 01 背包算法 */- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize&#123; if (bagSize == 0 || bagItems.count == 0) return; NSInteger bagMatrix[bagSize][bagItems.count]; // 是否选中数组 PackageItem * item; NSInteger i = 0; // 背包容量，列数 NSInteger j = 0; // 物品数量，行数 // 初始化数组 for (; i &lt;= bagSize; i++) &#123; for (j = 0; j &lt; bagItems.count; j++) bagMatrix[i][j] = 0; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); for (i = 0; i &lt;= bagSize; i++) &#123; // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取 for (j = bagItems.count - 1; j &gt; -1; j--) &#123; item = bagItems[j]; // 装不下 if (item.weight &gt; i) &#123; // 价值总和为 0 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = 0; &#125; // 价值总和为之前项的和 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = bagMatrix[i][j+1]; &#125; &#125; // 能装下 else &#123; // 是第一个物品，保存起来 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = item.value; &#125; // 非第一个物品，求最大值 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value); &#125; &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; NSInteger curSize = bagSize; // 当前能装的空间 NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]; // 以 a、b、c、d、e 的顺序获取 for (j = 0; j &lt; bagItems.count; j++) &#123; item = bagItems[j]; // 剩下能装的空间为 0 if (curSize == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123; [answer addObject:item.name]; curSize -= item.weight; &#125; &#125; NSLog(@&quot;%@&quot;, answer);&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 9 9 12 12 15 15 15 0 0 3 3 6 6 9 9 9 10 11 0 0 0 0 6 6 6 6 6 10 11 0 0 0 0 6 6 6 6 6 10 10 0 0 0 0 6 6 6 6 6 6 6 2019-01-25 22:12:03.795695+0800 Demo[1750:32295] ( a, b, e) 二、解释 2①、状态方程 max.F(n,C,x). x∈0,1 展开公式： F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn x1∗w1 + x2∗w2 + … + xn∗wn ≤ C xi∈0,1 x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。 我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够自动组合 x 的取值使得 F(n,c,x) 达到最大。 再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。 如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。 B(n, C) = B(n−1, C); 没有多余的空间去放置最后一个物品 B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn }; 如果有多余的空间去放置，则考虑是否要放置 B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。 ②、实例 w = {1, 2} v = {1, 2} C = 2 解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。 拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2 不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。 然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2 ③、递归代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]; for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; // a、b、c、d、e selectedArray[i] = @(0); &#125; NSLog(@&quot;%ld&quot;, (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]); [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123; if (obj.integerValue) &#123; NSLog(@&quot;%@ &quot;, nameArr[idx]); &#125; &#125;];&#125;/** * @brief 01 背包算法。递归方式 */- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize&#123; if (bagItems.count == 0 || bagSize == 0 || bagNo == 0) return 0; PackageItem * item = bagItems[bagNo - 1]; // 装不下 if (bagSize &lt; item.weight) &#123; // 在剩余的物品中查找 return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; &#125; else &#123; NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value; if (more &lt; less) &#123; selectedArray[bagNo - 1] = @(1); // 拿 &#125; else &#123; selectedArray[bagNo - 1] = @(0); // 不拿 &#125; return MAX(more, less); &#125;&#125;2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 152019-01-26 00:11:13.897903+0800 Demo[3618:88346] a2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e 三、DP 优于递归的好处动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。 四、学习文章动态规划之 01 背包问题（最易理解的讲解）一文彻底搞懂01背包算法DP——01背包问题使用迭代和动态规划","tags":[]},{"title":"重构 AppDelegate","date":"2019-05-23T10:19:03.931Z","path":"2019/05/23/重构AppDelegate/","text":"一、Massive AppDelegate AppDelegate 是应用程序的根对象，它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互，通常被认为是每个 iOS 项目的核心。 随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。 在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的简洁和清晰对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。 AppDelegate 常见的业务代码如下： 日志埋点统计数据分析 初始化数据存储系统 配置 UIAppearance 管理 App Badge 数字 管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分 管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换 管理 UserDefaults：设置首先启动标志，保存和加载数据 管理后台任务 管理设备方向 更新位置信息 初始化第三方库（如分享、日志、第三方登陆、支付） 这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。 看看以下可能的解决方案，每个 Recipe（方案）遵循单一职责、易于扩展、易于测试原则。 二、命令模式 Command Design Pattern 命令模式是一种数据驱动的设计模式，属于行为型模式。 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。 可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。 123456789101112131415161718192021/// 命令协议@protocol Command &lt;NSObject&gt;- (void)execute;@end/// 初始化第三方库@interface InitializeThirdPartiesCommand : NSObject &lt;Command&gt;@end/// 初始化主视图@interface InitializeRootViewControllerCommand : NSObject &lt;Command&gt;@property (nonatomic, strong) UIWindow * keyWindow;@end/// 初始化视图全局配置@interface InitializeAppearanceCommand : NSObject &lt;Command&gt;@end/// ... 然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。 1234567891011@implementation StartupCommandsBuilder// 返回数组，元素为遵守 Command 协议的对象- (NSArray&lt;id&lt;Command&gt;&gt; *)build&#123; return @[ [InitializeAppearanceCommand new], [InitializeRootViewControllerCommand new], [InitializeThirdPartiesCommand new] ];&#125;@end 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(id&lt;Command&gt; _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj execute]; &#125;]; return YES;&#125; 如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。 三、组合设计模式 Composite Design Pattern 组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。 这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。 12345678910111213141516171819202122/// 组装类@interface CompositeAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;+ (instancetype)makeDefault;@end@implementation CompositeAppDelegate+ (instancetype)makeDefault&#123; // 这里要实现单例 return [[CompositeAppDelegate alloc] init];&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125;@end 实现执行具体职责的叶子类。 12345678910111213141516171819202122232425262728293031323334/// 叶子类。推送消息处理@interface PushNotificationAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end/// 叶子类。初始化第三方库@interface ThirdPartiesConfiguratorAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end@implementation PushNotificationAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"PushNotificationAppDelegate\"); return YES;&#125;@end@implementation ThirdPartiesConfiguratorAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"ThirdPartiesConfiguratorAppDelegate\"); return YES;&#125;@end 在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125; 它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。 四、中介者模式 Mediator Design Pattern 中介者模式是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。 让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface APPLifeCycleMediator : NSObject+ (instancetype)makeDefaultMediator;@end@implementation APPLifeCycleMediator&#123; @private NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; * _listeners;&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;- (instancetype)initWithListeners:(NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; *)listeners&#123; if (self = [super init]) &#123; _listeners = listeners; // 通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidEnterBackgroud) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidFinishLaunching) name:UIApplicationDidFinishLaunchingNotification object:nil]; &#125; return self;&#125;/// 定义好静态类方法，初始化所有监听者+ (instancetype)makeDefaultMediator&#123; static APPLifeCycleMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]]; &#125;); return mediator;&#125;- (void)onAppWillEnterForeground&#123; [_listeners[1] onAppWillEnterForeground];&#125;- (void)onAppDidEnterBackgroud&#123; [_listeners[0] onAppDidEnterBackgroud];&#125;- (void)onAppDidFinishLaunching&#123;&#125;@end 定义 AppLifecycleListener 协议，以及协议的的实现者。 123456789101112131415161718192021222324252627282930313233343536/// 监听协议@protocol AppLifeCycleListener &lt;NSObject&gt;@optional- (void)onAppWillEnterForeground;- (void)onAppDidEnterBackgroud;- (void)onAppDidFinishLaunching;@end@interface VideoListener : NSObject &lt;AppLifeCycleListener&gt;@end@interface SocketListener : NSObject &lt;AppLifeCycleListener&gt;@end@implementation VideoListener- (void)onAppDidEnterBackgroud&#123; NSLog(@\"停止视频播放\");&#125;@end@implementation SocketListener- (void)onAppWillEnterForeground&#123; NSLog(@\"开启长链接\");&#125;@end 加入到 AppDelegate 中 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [APPLifeCycleMediator makeDefaultMediator]; return YES;&#125; 这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。 五、总结大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。 通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。 这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。 六、学习文章最佳实践：重构AppDelegate Refactoring Massive App Delegate iOSTips OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》 Swift 设计模式：《Design_Patterns_by_Tutorials_v0.9.1》 重构：《重构改善既有代码的设计》","tags":[]}]