[{"title":"iOS UmbrellaFramework","date":"2019-11-06T13:44:48.817Z","path":"2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/","text":"一、umbrella framework 将几个已经封装好的 framework 封装成一个，封装的这种 framework 就是 umbrella framework。 Apple 的官方文档中明确提到了不建议自己去创建 umbrellaframework。首先先引入 Apple 的 Guidelins for Creating Frameworks 的一段： Don’t Create Umbrella Frameworks While it is possible to create umbrella frameworks using Xcode, doing so is unnecessary for most developers and is not recommended. Apple uses umbrella frameworks to mask some of the interdependencies between libraries in the operating system. In nearly all cases, you should be able to include your code in a single, standard framework bundle. Alternatively, if your code was sufficiently modular, you could create multiple frameworks, but in that case, the dependencies between modules would be minimal or nonexistent and should not warrant the creation of an umbrella for them 分三个部分逐步创建并使用 UmbrellaFramework： SubFramework：创建一个基础 framework UmbrellaFramework：framework 里封装 framework UmbrellaFrameworkDemo：使用 demo 二、创建一个基础的 frameworkUmbrellaFramework（一）创建基础framework 创建一个 framework 工程：Subframework； 添加 SubSayHello 类，添加 sayHello 方法； 123456789101112@interface SubSayHello : NSObject- (void)sayHello;@end@implementation SubSayHello- (void)sayHello&#123; NSLog(@\"say Hello\");&#125;@end 在 SubFramework.h 头文件中导入 SubSayHello.h 1#import &lt;Subframework/SubSayHello.h&gt; 将 SubSayHello.h 添加到 Target -&gt; Build Phases -&gt; Headers -&gt; Public，可手动拖拽； Build Settings -&gt; Mach-O Type 选择 Static Library 静态库 生成通用 framework 方式一：分别在模拟器和真机下编译工程，生成两个 framework，用命令行合并成一个通用的。 1$ lipo -create [真机 Framework 二进制文件路径] [模拟器 Framework 二进制文件路径] -output [结果路径] &gt; $ lipo -create /Users/cykj/Library/Developer/Xcode/DerivedData/Subframework-hkwchwbjmtuhoseinwkzbtcjxpbj/Build/Products/Debug-iphoneos/Subframework.framework/Subframework /Users/cykj/Library/Developer/Xcode/DerivedData/Subframework-hkwchwbjmtuhoseinwkzbtcjxpbj/Build/Products/Debug-iphonesimulator/Subframework.framework/Subframework -output /Users/cykj/Desktop/Subframework 注意：如果执行命令报错，可以将结果地址改为 `/Users/cykj/Desktop/Subframework.xx`，生成后再将后缀名去掉。 * 方式二：脚本生成 * 为 SubFramework 工程添加 Target -&gt; Aggregate ![](http://dzliving.com/iOSUmbrellaFramework_2.png) * 在新添加的 Target 中添加脚本 ![](http://dzliving.com/iOSUmbrellaFramework_3.png) * 脚本内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# Sets the target folders and the final framework product.FRAMEWORK_NAME=LibraryNameFRAMEWORK_VERSION=1.0FRAMEWORK_CONFIG=Release# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_PATH=$&#123;PROJECT_DIR&#125;/Products/INSTALL_DIR=$&#123;INSTALL_PATH&#125;/$&#123;FRAMEWORK_NAME&#125;.framework# Working dir will be deleted after the framework creation.WORK_DIR=buildDEVICE_DIR=$&#123;WORK_DIR&#125;/$&#123;FRAMEWORK_CONFIG&#125;-iphoneos/$&#123;FRAMEWORK_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;WORK_DIR&#125;/$&#123;FRAMEWORK_CONFIG&#125;-iphonesimulator/$&#123;FRAMEWORK_NAME&#125;.frameworkxcodebuild -configuration \"$&#123;FRAMEWORK_CONFIG&#125;\" -target \"$&#123;FRAMEWORK_NAME&#125;\" -sdk iphoneosecho \"Build simulator\"xcodebuild -configuration \"$&#123;FRAMEWORK_CONFIG&#125;\" -target \"$&#123;FRAMEWORK_NAME&#125;\" -sdk iphonesimulator# Creates install directory if it not exits.if [ ! -d \"$&#123;INSTALL_DIR&#125;\" ]thenmkdir -p \"$&#123;INSTALL_DIR&#125;\"fi# Creates headers directory if it not exits.if [ ! -d \"$&#123;INSTALL_DIR&#125;/Headers\" ]thenmkdir -p \"$&#123;INSTALL_DIR&#125;/Headers\"fi# Remove all files in the headers diectory.for file in `ls \"$&#123;INSTALL_DIR&#125;/Headers\"`dorm \"$&#123;INSTALL_DIR&#125;/Headers/$&#123;file&#125;\"done# Remove binary library file.rm -f $&#123;INSTALL_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;# Copies the headers files to the final product folder.if [ -d \"$&#123;DEVICE_DIR&#125;/Headers\" ]thenfor file in `ls \"$&#123;DEVICE_DIR&#125;/Headers\"`docp \"$&#123;DEVICE_DIR&#125;/Headers/$&#123;file&#125;\" \"$&#123;INSTALL_DIR&#125;/Headers/$&#123;file&#125;\"donefi# copy nibs to bundle,then copy bundle to final folderBUNDLE_DIR=$&#123;DEVICE_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.bundleif [ -d \"$&#123;BUNDLE_DIR&#125;\" ];thenif ls $&#123;DEVICE_DIR&#125;/*.nib &gt;/dev/null 2&gt;&amp;1;thenrm -rf $&#123;BUNDLE_DIR&#125;/*.nibcp -rf $&#123;DEVICE_DIR&#125;/*.nib $&#123;BUNDLE_DIR&#125;firm -rf \"$&#123;INSTALL_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.bundle\"cp -R \"$&#123;BUNDLE_DIR&#125;\" \"$&#123;INSTALL_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;.bundle\"fiecho \"Merge with simulator\"# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;FRAMEWORK_NAME&#125;\"open \"$&#123;INSTALL_PATH&#125;\"# rm -r \"$&#123;WORK_DIR&#125;\" 查看 framework 支持的架构 1$ lipo -info [framework 二进制文件路径] 三、framework 里封装 frameworkUmbrellaFramework（二）framework里封装framework 创建 Cocoa Touch Framework 工程 UmbrellaFramework 导入 SubFramework 选择 Target -&gt; Build Phases -&gt; 点击左上角+号 -&gt; New Copy Files Phase 添加 Copy Files，将 SubFramework 添加到 Copy Files，选择 Destination 为 Frameworks。 添加 UmbrellaSayHello 类，添加 sayHello 方法，并在 sayHello 方法中调用 SubFramework 的 sayHello 方法。 123456789101112131415161718@interface UmbrellaSayHello : NSObject- (void)sayHello;@end#import &lt;Subframework/SubSayHello.h&gt;@implementation UmbrellaSayHello- (void)sayHello&#123; NSLog(@\"%s\", __func__); SubSayHello * ssh = [[SubSayHello alloc] init]; [ssh test];&#125;@end UmbrellaFramework.h 头文件中导入将 UmbrellaSayHello.h 1#import &lt;UmbrellaFramework/UmbrellaSayHello.h&gt; 将 UmbrellaSayHello.h 添加到 UmbrellaFramework 的公共 headers 中 Architectures 添加 armv7s 连接选项 Mach-O Type 不用改，选择默认选项 Dynamic Library，这意味着外层的 UmbrellaFramework 是一个动态库。 生成真机和模拟器都能用的 framework。见第二章。 四、使用 UmbrellaFrameworkUmbrellaFramework（三）使用demo 创建工程 UmbrellaFrameworkDemo 嵌入UmbrellaFramework，选择工程 -&gt; General -&gt; Embedded binaries，添加UmbrellaFramework。UmbrellaFramework 将会同时添加到 Linked Frameworks and Libraries. 工程中使用 123456789#import &lt;UmbrellaFramework/UmbrellaFramework.h&gt;- (void)viewDidLoad&#123; [super viewDidLoad]; UmbrellaSayHello * ush = [[UmbrellaSayHello alloc] init]; [ush sayHello];&#125;","tags":[]},{"title":"iOS umbrella header","date":"2019-11-06T12:49:53.868Z","path":"2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/","text":"Lexical or Preprocessor Issue - Umbrella header for module ‘xxx’ does not include header ‘xxx.h’ framework 的文件明明被主工程引用了，但是在编译的时候依旧抛出上面的警告。 一、什么是 umbrella header?参考官方文档《Introduction to Framework Programming Guide》，可以了解到 Framework 区分Standard Framework 和 Umbrella Framework。但是并没有找到官方文档有对 Umberlla framework 给出明确的定义。在官方文档《Anatomy of Framework Bundles》章节中， 找到三段比较合理说明 Umbrella Framework 的话： Umbrella frameworks add minor refinements to the standard framework structure， such as the ability to encompass other frameworks The structure of an umbrella framework is similar to that of a standard framework， and applications do not distinguish between umbrella frameworks and standard frameworks when linking to them. However， two factors distinguish umbrella frameworks from other frameworks. The first is the manner in which they include header files. The second is the fact that they encapsulate subframeworks. Physically， umbrella frameworks have a similar structure to standard frameworks. One significant difference is the addition of a Frameworks directory to contain the subframeworks that make up the umbrella framework. 字面上的意思应该是在标准的 Framework 做了一些改良的工作，使其可以嵌套包含 Framework。在物理结构上，Umbrella Framework 只在包含头文件的方式以及是否包含子 Framework 和普通的 Framework 存在区别。 那么引用头文件的地方又有什么区别呢? 还是参考官方文档引用: For most frameworks， you can include header files other than the master header file. You can include any specific header file you want as long as it is available in the framework’s Headers directory. However， if you are including an umbrella framework， you must include the master header file. Umbrella frameworks do not allow you to include the headers of their constituent subframeworks directly. See Restrictions on Subframework Linking for more information. 简单翻译一下: 普通的 Framework 可以通过引用对应的 heaedr 文件而不是 Master Header File 去引用需要使用的类，只需要对应的 header 头文件在 Headers 文件夹下暴露，并没有强制要求引用 Master Header File。Umbrella Framework 要求必须要引用 Master Header File，并且头文件中不能直接引用子 Framework 的东西。 上述描述已经说了 Umbrella Framework 一定要引用 Master Header File，而 Umbrella Framework 的 Master Header File 就是 Umbrella header 文件。 官方说明中只有强制规定一定要引用 Umbrella Header 文件，但是却没有说能不能单独引用 Umbrella Framework 的其他头文件呢? 我们可以自己试验一下: 在 Umbrella Framework 新建一个 testObject 类，分别产生了 testObject.h 和 testObject.m 文件。 打开 Framework 配置文件，在 Build Phases的Headers 里的 Public 目录下，将 testObject.h 文件添加进去。 Build Framework 看是否报错。 在主工程中调用初始化 testObject 对象，看编译是否报错。 执行结果: 步骤3: 没有编译报错， 但是报出了 Lexical or Preprocessor Issue - Umbrella header for module ‘STDemoUI’ does not include header ‘testObject.h’的警告。 步骤4: 执行正常。 总结一下: Standard Framework 不能包含 Sub Framework；Umbrella Framework 可以包含子 Framework; Standard Framework 可以直接引用需要使用的头，也可以通过引用 Master Header file 来引用需要使用的类；Umbrella Framework 需要通过引用 Master Header File(Umbrella Header) 来引用需要使用的类; 二、规范的写法Umbrella Framework 默认会创建一个同名 .h 文件做为 Umbrella Header 文件。规范的写法当然是遵从默认的模式，将所有需要暴露的头文件都写在 Umbrella Header 文件中。 例如: STDemoUI.framework 工程包含了 STClassOne、STClassTwo 和 STClassThree 三个类。 STDemoUI 会生成一个默认的伞头文件（直译 Umbrella Header）STDemoUI.h。假设该 framework 的三个类均需要在外部调用使用，则 STDemoUI.h 需要将三个类的引用均写入伞头文件中。 123456// STDemoUI.h// ...#import &lt;STDemoUI/STClassOne.h&gt;#import &lt;STDemoUI/STClassTwo.h&gt;#import &lt;STDemoUI/STClassThree.h&gt; 在需要调用的主工程中， 仅仅只要将 Umbrella Header 引用即可调用所有在 Umbrella Header 中包含的类了。 12// 在主工程需要应用的类中包含Umbrella Header#import &lt;STDemoUI/STDemoUI.h&gt; 三、重命名 umbrella header如果大家都遵从默认的 Umbrella Framework 的写法，在同名头文件中写需要暴露的引用头文件，那么就不需要考虑怎么重命名 Umbrella header 了。 很多时候，理想和现实是有差距的，程序员写代码多数是在二次接手进行开发的。假设公司的前辈已经将 Framework 的同名文件用作了一个逻辑类， 给同名文件创建了 .m 文件， 并已经书写了逻辑并应用了各个工程里面去了。那么显然迁移头文件功能代码是不可能的，因为很多依赖该 Framework 的业务部门都需要针对库进行代码优化。 在这种不能将同名文件作为 Umbrella header 的情况下，我们又不想通过 Public 强制暴露头文件的情况下（不写在 Umbrella Header 中会有警告）。我们就需要对 Umbrella Header 进行指定了。 指定 Umbrella Header 入口在哪里呢? 在工程全局搜索 umbrella 关键字 - Failed 在Build Settings里搜索umbrella关键字 - Failed 在打包好的 STDemoUI.framework 中搜索 umbrella 关键字 - Success 双击点开 STDemo.framework，内容如下： 初略看名称可以推测出每个文件以及文件夹所承担的作用: _CodeSignature：保存签名相关文件 Headers：framework 暴露的所有头文件 Info.plist：描述了该 framework 所包含的项目配置信息 UmbrellaFramework：编译后的核心库文件 Modules：模块相关文件夹， 目测只包含了 module.modulemap 文件 Frameworks：包含的子 framework 我们在 module.modulemap 文件中找到了 umbrella 关键字。文件内容如下: 123456framework module STDemoUI &#123; umbrella header \"STDemoUI.h\" export * module * &#123; export * &#125;&#125; 原来 Framework 的 umbrella header 是在这个位置被指定的，但是这个已经是编译好的工程， 我们总不能每次编译好了再进到包里面修改下。既然我们已经找到 umbrella header 是在 module 中去指定，那么我们就用 module 作为关键字再去 Build Settings 里重新搜索下。 这回在 Kernel Module 和 Packaging 中均找到了 Module 关键字，在 Packaging 标签中，有一项 Module Map File 属性，看名字应该是用来指定 modulemap 文件的。 指定 Modulemap 文件 创建一个新的 .h 文件，如：STHeader.h。将所有需要暴露的头文件均写入 STHeader.h 创建一个新的 modulemap 文件，如：stdemoalt.modulemap 在新的 modulemap 中指定 umbrella header 123456framework module STDemoUI &#123; umbrella header \"STHeader.h\" export * module * &#123; export * &#125;&#125; 在 framework 的 Build Settings 中的 Module Map File 指定新建的 modulemap 文件。 CMD+B 编译，打开 framework 包中的 Module 文件夹，看是否包含了新指定的 modulemap。 抛出两个疑问: Module 是什么? 如果 Defines Module 指定为 NO， 那会发生什么事情呢? 四、总结本文简单的梳理了官方文章关于 Umbrella Framework 和 Umbrella Header 的介绍说明，产生警告的原因是没有引用 umbrella header 或者暴露头没有写在 umbrella header 中。在 umbrella header 被已使用的前提下，本文提供了一种通过重命名 Umbrella Header 文件的方式来消除警告的解决方案。 虽然引用警告可以被消除，但是建议大家还是采用规范的做法：尽量不要在同名头文件中写业务逻辑代码， 用同名文件作为 Umbrella 库的 Master Header File。 文章iOS - Umbrella Header在framework中的应用","tags":[]},{"title":"iOS 图片","date":"2019-11-06T07:50:47.319Z","path":"2019/11/06/iOS/iOS媒体/iOS 图片/","text":"一、图片加载的工作流概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下： 假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，此时的图片并没有解压缩； 然后将生成的 UIImage 赋值给 UIImageView； 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤： 分配内存缓冲区用于管理文件 IO 和解压缩操作； 将文件数据从磁盘读到内存中； 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作； 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。 由上面的步骤可知，图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。 二、为什么需要解压缩既然图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是位图： A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images. 其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。 下面是一张 PNG 图片，像素为 30 × 30，文件大小为 843B： 使用下面的代码： 12UIImage * image = [UIImage imageNamed:@\"check_green\"];CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage)); 就可以获取到这个图片的原始像素数据，大小为 3600B ： 123456789101112131415161700000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000001020102 032c023c 0567048c 078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf0567048c 032c023c 01020102 00000000 00000000 00000000 00000000 00000000 0000000000000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000000000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 0000000000000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000000000000 00000000 00000000 033d0353 08a607e2 09bb07ff 09bb07ff 09bb07ff 09bb07ff...09bb07ff 09bb07ff 09bb07ff 09bb07ff 08a607e2 033d0353 00000000 00000000 0000000000000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000000000000 01060108 05570476 09ab07e9 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff09bb07ff 09bb07ff 09bb07ff 09bb07ff 09bb07ff 09ab07e9 05570476 01060108 0000000000000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000000000000000 00000000 00000000 00000000 00000000 00000000 01020102 032c023c 0567048c078d06bf 08a006d9 09b307f3 09b307f3 08a006d9 078d06bf 0567048c 032c023c 0102010200000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 也就是说，这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关： 解压缩后的图片大小(3600) = 图片的像素宽(30) 图片的像素高(30) 每个像素所占的字节数(4) 至于这个公式是怎么得来的，后面会有详细的说明。 至此，我们已经知道了什么是位图，并且直观地看到了它的原始像素数据，那么它与我们经常提到的图片的二进制数据有什么联系吗？是同一个东西吗？事实上，这二者是完全独立的两个东西，它们之间没有必然的联系。为了加深理解，我把这个图片拖进 Sublime Text 2 中，得到了这个图片的二进制数据，大小与原始文件大小一致，为 843B： 12345678910111213141516178950 4e47 0d0a 1a0a 0000 000d 4948 4452 0000 001e 0000 001e 0806 0000 003b 30ae a2000000 0173 5247 4200 aece 1ce9 0000 0305 4944 4154 480d c557 4d68 1341 149e 3709 da4d09c6 8a56 2385 9e14 f458 4fa2 d092 f4a6 28d8 2222 de04 3d09 a1d0 7a50 0954 8bad 2d054fde 3c89 482b 2ad6 8334 d183 e049 ef9e 4a41 48b0 42eb a549 6893 1ddf 9bcd b4d9 d9d94dd8 a43a b0d9 9d79 3fdf bc79 3ff3 02ac 8591 1559 3e97 9b3e 5b05 fb32 6330 c098 48a2183d 340a b886 8ff8 1e15 fced 587a e26b 16b2 b643 f2ff 057f 1263 fd9f fbbb 7ed7 7edd1142 8c09 268e 04f1 2a1a 3058 0380 b9c3 91de a7ab 43ab 15b5 aebf 7d81 ad65 eb0a 5a318f4f 9f2e d4da 1c7e e249 64ca c3e5 d726 7eae 2fa2 7510 cb75 3d62 cc5e 0c0f 4a5a 69c3...36ac b11e 7006 f71b 5386 a2b7 1e48 ad82 a26a 2880 95db 3f8b f525 b880 e0ed 7221 75f1fa02 2cd4 1af7 1d0e 546a 98e5 d4ae 342a 337e 6b96 134f 1ba0 0c0b c83b a0f2 3593 7b5c6ca9 b541 cb4f 254e df58 d958 8955 a0fc 2638 658c 2660 f986 b5f1 f4dd 63f2 5aec ce59e3b6 b0a7 cdac ee55 145c c7dc 8f60 f53f e0a6 b436 e3c0 27b0 8ecf 5054 336a ccd0 e1d82335 1f78 323d 6141 09c3 c1aa 5f8b 4e37 0899 e6b0 ed72 4046 759e d262 5247 9d01 1689a976 55fb c993 6ed5 7d10 8ff4 b162 fe6f cd1e ee4a d4bb c18e 594e 96ea 1da6 c762 6539bdff 7943 afc0 c91f bdd1 a327 28fc 29f7 d47a b337 f192 0cc9 36fa 5497 73f9 5827 aa391599 4eff 69fb 0b0d 1f7a 96cd 3eb0 7800 0000 0049 454e 44ae 4260 82 事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片： 12345// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap formatUIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality); 因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。 三、强制解压缩的原理既然图片的解压缩不可避免，而我们也不想让它在主线程执行，影响应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。 当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。 而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* Create a bitmap context. The context draws into a bitmap which is `width' pixels wide and `height' pixels high. The number of components for each pixel is specified by `space', which may also specify a destination color profile. The number of bits for each component of a pixel is specified by `bitsPerComponent'. The number of bytes per pixel is equal to `(bitsPerComponent * number of components + 7)/8'. Each row of the bitmap consists of `bytesPerRow' bytes, which must be at least `width * bytes per pixel' bytes; in addition, `bytesPerRow' must be an integer multiple of the number of bytes per pixel. `data', if non-NULL, points to a block of memory at least `bytesPerRow * height' bytes. If `data' is NULL, the data for context is allocated automatically and freed when the context is deallocated. `bitmapInfo' specifies whether the bitmap should contain an alpha channel and how it's to be generated, along with whether the components are floating-point or integer. */CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);``` 顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。#### 3.1 Pixel Format位图其实就是一个像素数组，而[像素格式](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG)则是用来描述每个像素的组成格式，它包括以下信息：* Bits per component：一个像素中每个独立的颜色分量使用的 bit 数；* Bits per pixel：一个像素使用的总 bit 数；* Bytes per row：位图中的每一行使用的字节数。有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：&lt;center&gt;![](http://dzliving.com/Supported Pixel Formats.png)&lt;/center&gt;从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant，我们在后面会详细介绍。#### 3.2 Color and Color Spaces什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 (0, 0, 1)。而&lt;font color=#cc0000&gt;颜色空间则是用来说明如何解析这些值的&lt;/font&gt;，离开了颜色空间，它们将变得毫无意义。比如,下面的值都表示蓝色：&lt;center&gt;![](http://dzliving.com/blue_color.png)&lt;/center&gt;如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 (0, 0, 1) 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果：&lt;center&gt;![](http://dzliving.com/color_profiles.png)&lt;/center&gt;#### 3.3 Color Spaces and Bitmap Layout像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供[位图的布局信息](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB) CGBitmapInfo： typedef CF_OPTIONS(uint32_t, CGBitmapInfo) { kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatInfoMask = 0xF00, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = kCGImageByteOrderMask, kCGBitmapByteOrderDefault = (0 &lt;&lt; 12), kCGBitmapByteOrder16Little = kCGImageByteOrder16Little, kCGBitmapByteOrder32Little = kCGImageByteOrder32Little, kCGBitmapByteOrder16Big = kCGImageByteOrder16Big, kCGBitmapByteOrder32Big = kCGImageByteOrder32Big } CG_AVAILABLE_STARTING(MAC_10_0, IPHONE_2_0);12345678它主要提供了三个方面的布局信息：* alpha 的信息；* 颜色分量是否为浮点数；* 像素格式的字节顺序。其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示： typedef CF_ENUM(uint32_t, CGImageAlphaInfo) { kCGImageAlphaNone, / For example, RGB. / kCGImageAlphaPremultipliedLast, / For example, premultiplied RGBA / kCGImageAlphaPremultipliedFirst, / For example, premultiplied ARGB / kCGImageAlphaLast, / For example, non-premultiplied RGBA / kCGImageAlphaFirst, / For example, non-premultiplied ARGB / kCGImageAlphaNoneSkipLast, / For example, RBGX. / kCGImageAlphaNoneSkipFirst, / For example, XRGB. / kCGImageAlphaOnly / No color data, alpha data only /};12345678910111213141516上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：* 是否包含 alpha；* 如果包含 alpha，那么 alpha 信息所处的位置，在像素的[最低有效位](https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D)，比如 RGBA，还是[最高有效位](https://zh.wikipedia.org/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D)，比如 ARGB；* 如果包含 alpha，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。那么我们在解压缩图片的时候应该使用哪个值呢？根据 [Which CGImageAlphaInfo should we use](http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use) 和官方文档中对 `UIGraphicsBeginImageContextWithOptions` 函数的讨论：&gt; You use this function to configure the drawing environment for rendering into a bitmap. The format for the bitmap is a ARGB 32-bit integer pixel format using host-byte order. If the opaque parameter is YES, the alpha channel is ignored and the bitmap is treated as fully opaque (kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host). Otherwise, each pixel uses a premultipled ARGB format (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host).我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host，而这个值具体是什么，后面再讨论。至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。接下来，我们来简单地了解下像素格式的[字节顺序](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH)，它是由枚举值 CGImageByteOrderInfo 来表示的： typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) { kCGImageByteOrderMask = 0x7000, kCGImageByteOrder16Little = (1 &lt;&lt; 12), kCGImageByteOrder32Little = (2 &lt;&lt; 12), kCGImageByteOrder16Big = (3 &lt;&lt; 12), kCGImageByteOrder32Big = (4 &lt;&lt; 12)} CG_AVAILABLE_STARTING(MAC_10_12, IPHONE_10_0);1234567它主要提供了两个方面的字节顺序信息：* [小端模式](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F)还是[大端模式](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F)；* 数据以 16 位还是 32 位为单位。对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 [Hardcoding](https://en.wikipedia.org/wiki/Hard_coding)： #ifdef BIG_ENDIAN #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big #else / Little endian. / #define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little #define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little #endif12345678910111213141516171819202122232425262728根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：&lt;center&gt;![](http://dzliving.com/colorformatrgba32.gif)&lt;/center&gt;我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。好了，了解完这些相关知识后，我们再回过头来看看 CGBitmapContextCreate 函数中每个参数所代表的具体含义：* data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；* width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；* bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；* bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 [what is byte alignment (cache line alignment) for Core Animation? Why it matters?](http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters) 和 [Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?](http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width)* space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；* bitmapInfo ：就是我们前面提到的位图的布局信息。到这里，你已经掌握了强制解压缩图片需要用到的最核心的函数，点个赞。## 四、开源库的实现接下来，我们来看看在三个比较流行的开源库 [YYKit](https://github.com/ibireme/YYKit)、[SDWebImage](https://github.com/rs/SDWebImage) 和 [FLAnimatedImage](https://github.com/Flipboard/FLAnimatedImage) 中，对图片的强制解压缩是如何实现的。首先，我们来看看 YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 [YYImageCoder](https://github.com/ibireme/YYKit/blob/master/YYKit/Image/YYImageCoder.m) 类中，核心代码如下： CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) { … if (decodeForDisplay) { // decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -[UIView drawRect:] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; } else { ... } }123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687它接受一个原始的位图参数 imageRef，最终返回一个新的解压缩后的位图 newImage，中间主要经过了以下三个步骤：1. 使用 CGBitmapContextCreate 函数创建一个位图上下文；2. 使用 CGContextDrawImage 函数将原始位图绘制到上下文中；3. 使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别，如下表所示：&lt;center&gt;![](http://dzliving.com/CGBitmapContextCreate.png)&lt;/center&gt;在上表中，用浅绿色背景标记的参数即为我们在前面的分析中所推荐的参数，用这些参数解压缩后的图片渲染的速度会更快。因此，从理论上说 YYKit 中的解压缩算法是三者之中最优的。## 五、性能对比[测试源码 GitHub 地址](https://github.com/leichunfeng/Image-Decompression-Benchmark)。采用的测试样例分别为 5 张 PNG 图片和 5 张 JPEG 图片，像素依次为 128x96、256x192 、512x384、1024x768 和 2048x1536，它们其实都长一个样：&lt;center&gt;![](http://dzliving.com/128x96.png)&lt;/center&gt;首先，我们来了解下测试的原理，我们可以将从磁盘加载一张图片到最终渲染到屏幕上的过程划分为三个阶段：* 初始化阶段：从磁盘初始化图片，生成一个未解压缩的 UIImage 对象；* 解压缩阶段：分别使用 YYKit、SDWebImage 和 FLAnimatedImage 对第 1 步中得到的 UIImage 对象进行解压缩，得到一个新的解压缩后的 UIImage 对象；* 绘制阶段：将第 2 步中得到的 UIImage 对象绘制到屏幕上。这里我们以绘制阶段的耗时为依据来评测解压缩的性能，解压缩的算法越优秀，那么得到的图片就越符合系统渲染时的需求，绘制的时间也就越短。为了让测试的结果更准确，我们对每张图片都解压缩 10 次，然后取平均值。说明，本次使用的测试设备是 iPhone 5s 。首先，我们来看看解压缩 PNG 图片的测试结果：&lt;center&gt;![](http://dzliving.com/decompress_png_compare.png)&lt;/center&gt;相应的柱状图如下：&lt;center&gt;![](http://dzliving.com/decompress_png.png)&lt;/center&gt;从上图可以看出，就我们采用的测试样例来说，解压缩 PNG 图片的性能 SDWebImage 最好，FLAnimatedImage 次之，YYKit 最差。这与我们前面的理论结果有一定的差距，可能是测试样例太少，也可能这就是真实结果。另外，需要说明的是，我们这里使用的 PNG 图片都是不带 alpha 值，因为 SDWebImage 不支持解压缩带 alpha 值的 PNG 图片。接着，我们再来看看解压缩 JPEG 图片的测试结果：&lt;center&gt;![](http://dzliving.com/decompress_jpeg_compare.png)&lt;/center&gt;相应的柱状图如下：&lt;center&gt;![](http://dzliving.com/decompress_jpeg.png)&lt;/center&gt;解压缩 JPEG 图片的性能最好，SDWebImage 和 FLAnimatedImage 并列第二。## 六、总结要理解 iOS 中图片的解压缩并不难，重点是要理解位图的概念。而图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程。了解这些知识，将有助于我们更好地处理图片，管理好它们所占用的内存。## 七、其他[飘金](https://www.jianshu.com/u/da7864faa1be) - [iOS 图片解码](https://www.jianshu.com/p/e9843d5b70a2)#### 7.1 图片的存储消耗1. 磁盘空间或者通过网络传输所消耗的空间2. 解压缩空间，通常是长 * 宽 * 高 * 4字节（RGBA）3. 当显示在一个 view 中时，view 本身也需要空间来存储 layer#### 7.2 图片加载时间1. 从磁盘上 alloc/initUIImage 的时间2. 解压缩的时间3. 将解压缩后的比特转换成 CGContext 的时间，通常需要改变尺寸、混合、抗锯齿工作。#### 7.3 小 Tips1. 如何把 GIF 动图保存到相册？ [ALAssetsLibrary writeImageDataToSavedPhotosAlbum:metadata:completionBlock]; // 图像会被强制转码为 PNG 格式 UIImageWriteToSavedPhotosAlbum(); ``` 将 UIImage 保存到磁盘，用什么方式最好？ 保存 UIImage 有三种方式： 直接用 NSKeyedArchiver 把 UIImage 序列化保存； 用 UIImagePNGRepresentation() 先把图片转为 PNG 保存； 用 UIImageJPEGRepresentation() 把图片压缩成 JPEG 保存。 实际上，NSKeyedArchiver 是调用了 UIImagePNGRepresentation 进行序列化的，用它来保存图片是消耗最大的。苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。所以如果图片不包含透明像素时，UIImageJPEGRepresentation(0.9) 是最佳的图片保存方式，其次是 UIImagePNGRepresentation()。 UIImage 缓存是怎么回事？ 通过 imageNamed: 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存。 在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在(待验证)。 用 imageWithData: 能不能避免缓存呢？ 不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 CGImageSourceCreateWithData() 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed: 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。 怎么能避免缓存? 手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。 把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。 我能直接取到图片解码后的数据，而不是通过画布取到吗？ CGImageSourceCreateWithData(data) 创建 ImageSource。 CGImageSourceCreateImageAtIndex(source) 创建一个未解码的 CGImage。 CGImageGetDataProvider(image) 获取这个图片的数据源。 CGDataProviderCopyData(provider) 从数据源获取直接解码的数据。 ImageIO 解码发生在最后一步，这样获得的数据是没有经过颜色类型转换的原生数据（比如灰度图像）。 如何判断一个文件的图片类型？ 通过读取文件或数据的头几个字节然后和对应图片格式标准进行比对。 怎样像浏览器那样边下载边显示图片？ baseline 逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。 interlaced 隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。 progressive 渐进式。JPEG 在保存时可以选择这种方式。 在下载图片时，首先用 CGImageSourceCreateIncremental(NULL) 创建一个空的图片源，随后在获得新数据时调用 CGImageSourceUpdateData(data, false) 来更新图片源，最后在用 CGImageSourceCreateImageAtIndex() 创建图片来显示。 可以用 PINRemoteImage 或者 YYWebImage 来实现这个效果。 文章雷纯锋的技术博客 - 谈谈 iOS 中图片的解压缩","tags":[]},{"title":"iOS 优化实例","date":"2019-11-05T13:43:13.701Z","path":"2019/11/05/iOS/iOS优化/iOS 优化实例/","text":"一、接口请求优化在工程项目中，多个一级界面包含状态，如：服务入口的动态配置，未读消息数量，图片文字等，因此产品设计要每次切换 tab 时都请求数据，及时的更新页面状态。在实际开发中，频繁的调用接口，频繁的刷新界面显然是影响用户体验的，所以需要进行优化，优化的思路有以下几点： 使用 loading + 默认灰色矩形视图； 每隔 15s 以上才请求一次，防止频繁触发请求 123456789101112131415161718@property (nonatomic, assign) CFTimeInterval lastTi;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; CFTimeInterval nowTi = CACurrentMediaTime(); if (self.lastTi &lt;= 0 || nowTi - self.lastTi &gt; 15) &#123; [self makeRequestAction]; self.lastTi = nowTi; &#125;&#125;- (void)makeRequestAction&#123; // 接口请求&#125; CACurrentMediaTime() 在退到后台、手动修改设备时间后没有影响。 对数据进行判断，数据没有更新不需要刷新界面。这里要注意，存储的是不是字符串，而是字符串的 hash 值，因为长度比较小。 123456789101112@property (nonatomic, assign) NSUInteger compareHash; // 判断列表数据是否更新&#123; NSUInteger hash = [data.mainTools componentsJoinedByString:@\"\"].hash; if (self.compareHash == hash) &#123; return; &#125; self.compareHash = hash; // 更新界面&#125; 这里的策略还是存在点问题： 不能处理好未读标识。比如当进入子界面详情时，这里需要更新未读状态，但因为 15s 的限制，而不能及时刷新； 二、界面优化 使用 Debug -&gt; View Debugging -&gt; Rendering 中的界面渲染选项，进行界面优化 cell 滚动停止时加载 三、资源加载优化 图片加载 imageNamed: 利用它可以方便加载资源图片。用 imageNamed 的方式加载时，会把图像数据根据它的名字缓存在系统内存中，以提高 imageNamed 方法获得相同图片的 image 对象的性能。即使生成的对象被 autoReleasePool 释放了，这份缓存也不释放。而且没有明确的释放方法。如果图像比较大，或者图像比较多，用这种方式会消耗很大的内存。 优点：加载图片速度快； 缺点：耗内存大，适用于小图片并且会被频繁读取的图片。 imageWithContentsOfFile: 加载的图片是不会缓存的。得到的对象时 autoRelease 的，当 autoReleasePool 释放时才释放。 优点：图片数据不缓存，节省内存； 缺点：加载图片速度相对慢，每次读取图片都要从路径下寻找并解析图片数据。适用于会用到的图片数据不大，且不经常用到的。 imageNamed: 加载会缓存在内存中，对于常用的图片可以放在 asset 里，不常用的图片放在 bundle 的路径下通过 imageWithContentsOfFile: 获取图片资源。 &gt; initWithContentsOfFile: 一般用在封面等图比较大的地方。适用于大图片，且不经常要用的图片。 123456dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; for (int i = 0; i &lt; 100000; i++) &#123; self.loadImageView.image = [UIImage imageNamed:@\"icon\"]; //self.loadImageView.image = [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"icon\" ofType:@\"png\"]]; &#125;&#125;); * imageNamed: &lt;center&gt; ![](http://dzliving.com/iOSimageNamed_0.png) ![](http://dzliving.com/iOSimageNamed_1.png) &lt;/center&gt; * imageWithContentsOfFile: &lt;center&gt; ![](http://dzliving.com/iOSimageFile_0.png) ![](http://dzliving.com/iOSimageFile_1.png) &lt;/center&gt; 在有缓存的情况下，即使运行 100000 次，也不会等待很久，而 imageWithContentsOfFile: 会等待很久，且内存持续增长。 UITableView 中使用 imageNamed: 加载图片，频繁上下滑动时 CPU 耗时不断增长。 原本期望 imageNamed: 创建了缓存的，不应该持续耗费 cpu 时间，结果却耗费了 6-700ms，多处合起来有几秒。 优化思路是自己使用 NSDictionary 或 NSCache 存储 images，使用时根据 key 来获取。 12345678910111213141516171819202122232425262728// .h 文件FOUNDATION_EXTERN NSString * kAPlaceholderImageKey;FOUNDATION_EXTERN NSString * kBPlaceholderImageKey;- (UIImage *)imageForKey:(NSString *)placeholderImageKey;// .m 文件NSString * kAPlaceholderImageKey = @\"APlaceholderImageKey\";NSString * kBPlaceholderImageKey = @\"BPlaceholderImageKey\";- (UIImage *)imageForKey:(NSString *)placeholderImageKey&#123; return [self.imageCache objectForKey:placeholderImageKey];&#125;/** * @brief 缓存 cell 中需要重复使用的图片 */- (NSCache *)imageCache&#123; if (_imageCache == nil) &#123; _imageCache = [[NSCache alloc] init]; [_imageCache setObject:[UIImage imageNamed:@\"1\"] forKey:kAPlaceholderImageKey]; [_imageCache setObject:[UIImage imageNamed:@\"2\"] forKey:kBPlaceholderImageKey]; &#125; return _imageCache;&#125;","tags":[]},{"title":"iOS 操作系统架构","date":"2019-11-05T07:11:27.306Z","path":"2019/11/05/iOS/iOS原理/iOS 操作系统架构/","text":"一、iOS 系统架构层次 在 iOS 中，框架是一个目录，包含了共享资源库，用于访问该资源库中储存的代码的头文件，以及图像、声音文件等其他资源。共享资源库定义应用程序可以调用的函数和方法。 iOS 为应用程序开发提供了许多可使用的框架，并构成 iOS 操作系统的层次架构，分为四层： Cocoa Touch 可触摸层 这一层为我们的应用程序开发提供了各种有用的框架，并且大部分与用户界面有关，本质上来说它负责用户在 iOS 设备上的触摸交互操作。 包括：Address Book UI Framework、Event Kit UI Framework、Game Kit Framework、iAd Framework、Map Kit Framework、Message UI Framework、UIKit Framework 等等，这一层基本都是基于 Objective-C 的接口。 Media 媒体层 通过它我们可以在应用程序中使用各种媒体文件，进行音频与视频的录制，图形的绘制，以及制作基础的动画效果。 包含 Core Graphics、Core Animation、OpenGL ES、Core Text、Image I/O、Assets Library Framework、Media Player Framework、AV Foundation、OpenAL、Core Audio Frameworks、Core Media 等等 Core Services 核心服务层 可以通过它来访问 iOS 的一些服务。 包含 Address Book Framework、CFNetwork Framework、Core Data Framework、Core Foundation Framework、Core Location Framework、Core Media Framework、Core Telephony Framework、Event Kit Framework、Foundation Framework、Mobile Core Services Framework、Quick Look Framework、Store Kit Framework、System Configuration Framework、Block Objects、Grand Central Dispatch 、In App Purchase、Location Services、SQLite、XML Support 等一些框架，也基本都是基于 c 语言的接口。 Core OS 是位于 iOS 系统架构最下面的一层是核心操作系统层 它包括内存管理、文件系统、电源管理以及一些其他的操作系统任务。它可以直接和硬件设备进行交互。作为app开发者不需要与这一层打交道。 包含 Accelerate Framework、External Accessory Framework、Security Framework、System 等几个框架，基本都是基于 c 语言的接口。 低层次框架提供 iOS 的基本服务和技术；高层次框架建立在低层次框架之上，用来提供更加复杂的服务和技术，较高级的框架向较低级的结构提供面向对象的抽象。 在开发应用时应尽可能使用较高级的框架。如果要开发的功能在高层框架中没有提供，也可以使用较低层框架和技术。 Foundation 和 UIKit 框架是应用编程用到的两个主要的框架，能够满足大多数应用程序的开发需求。 UIKit 框架提供的类，用于创建基于触摸的用户界面。所有 iOS 应用程序都是基于 UIKit，没有这个框架，就无法交付应用程序。UIKit 提供应用程序的基础架构，用于在屏幕上绘图、处理事件，以及创建通用用户界面及其中元素。UIKit 还通过管理屏幕上显示的内容，来组织应用程序。 Foundation 框架为所有应用程序提供基本的系统服务。应用程序以及 UIKit 和其他框架，都是建立在Foundation 框架的基础结构之上。Foundation 框架提供许多基本的对象类和数据类型，使其成为应用程序开发的基础。它还制定了一些约定（如用于取消分配等任务），使代码更加一致，可复用性更好。 二、Cocoa Touch Layer Cocoa Touch 层包含如下框架： 2.1 Address Book UI Framework地址本 UI 框架。 该框架提供一个面向对象的编程接口。用来显示标准的系统接口，来创建新的联系人和编辑和选择已存在的联系人。 2.2 Event Kit UI Framework月历事件 UI 框架。 该框架提供一个视图控制器来呈现标准的系统接口，来观察和编辑月历相关的事件。EventKit UI Framework 基于 Event Kit framework 框架。 2.3 Game Kit Framework游戏工具框架。 该框架实现对游戏中心的支持，让用户能够在线共享他们的游戏相关的信息。 2.4 iAd FrameworkiAD 框架。 该框架用来在应用中提供广告条。当你想要显示广告时，广告条与用户 UI 上的标准的视图进行合并。这些视图与苹果的 iAd 服务一起工作，自动处理、加载和呈现富媒体广告以及应答在那些广告条上的点击等所有相关的工作。 2.5 Map Kit Framewor地图工具框架。 MapKit 提供与应用的 UI 组合的一个可滚动的地图。 除了显示一个地图，你能使用该框架接口来定制地图的内容和外观，也能使用注解来标记感兴趣的点，也能使用定制的内容来与地图内容叠置。例如，你可以在地图上来画一条公交路线，或者使用注解来高亮显示附近的商店和餐馆。 除了显示地图，MapKit 框架还能与地图应用以及苹果的地图服务器集成来为用户指引方向。 地图应用能够给任意支持方向的应用提供方向的代理。如提供特定类型方向的应用，例如一个显示地铁路线的应用，能登记请求接收地图应用提供的方向。 应用也能向苹果的服务器请求步行或驾驶方向，并与他们定制的方向的路径信息混合来为用户提供完整的点到点体验。 2.6 Message UI Framework消息 UI 框架。 该框架用来在应用中提供编辑邮件和 sms 消息的支持。 编辑支持包括一个呈现到你的应用的视图控制器接口，并能设置这个视图控制器的一些区域，如接收人、主题、邮件主体和邮件想包括的任意附件。 在呈现视图控制器后，也能为用户提供一个在发送邮件之前可以编辑邮件的选项。 2.7 UIKit Framework该框架提供实现图形和事件驱动的应用的至关重要的基础。包括： 基本的应用管理和基础设施，包括应用的主循环； 用户接口管理，包括对 storyboards 和 nib 文件的支持； 一个用来封装用户 UI 内容的视图控制器模式； 标准系统视图和控制对象； 提供处理触摸和运动事件的支持； 支持包括与 iCloud 集成功能的文档模式； 图形和窗口支持，包括支持外部显示器； 多任务支持； 打印支持； 定制标准 UIKit 控制的外观； 支持文本和 web 内容； 剪切、复制、粘贴的支持； 支持动画 UI； 通过 url 语义和框架接口与系统提供的其它应用集成的能力； 对有障碍用户的可存取性的支持； 支持 ApplePush Notification 服务； 本地通知调度和提交； pdf 创建； 支持定制像系统键盘行为一样的用户输入视图； 支持创建与系统键盘交互的定制的文本视图； 支持通过 email，Twitter，Facebook和其它服务共享内容。 也支持一些设备特定功能的集成： 内建的摄像机； 用户的图片库； 设备名和模式信息； 电池状态信息； 接近传感器信息； 来自附件耳机的远程控制信息 三、MediaLayer 媒体层包含在应用中实现多媒体体验的图形、声音、视频技术和框架。使用这层的技术可以使你容易的建立更加好看和好听的应用。 3.1 图形技术高质量的图形是所有应用的重要的组成部分。iOS 提供了许多帮助你定制艺术和图形屏幕的技术。iOS 图形技术为其提供了广泛的支持，并可以与 UIKit 视图架构无缝工作。 你能使用标准的视图来快速提交高质量的接口，或者使用本层的图形技术创建你自己的定制视图来提交一个更加丰富的图形体验。 UIKit graphics UIKit 定义的绘制图像和 Bézier 路径，以及动画视图内容的高级别技术。 UIKit 视图提供快速和有效的方式来呈现图像和文本内容。 UIKIT 视图也能通过显示和使用 UIKitdynamics 技术进行动画，并为用户提供反馈，促进用户交互。 CoreGraphics 框架 CoreGraphics 也称作 Quartz，是对定制的 2D 向量和图像呈现提供支持的本地绘制引擎。 该框架提供的引擎虽然没有 OpenGLES 引擎速度快，但该框架能够很好地适合于呈现定制的 2D 图形和动态图像。 CoreAnimation 框架 CoreAnimation 也是 Quartz 核心框架的一部分，是优化应用动画体验的基础技术。 UIKit 视图基于 Core Animation 提供视图级别的动画支持。当你想对动画行为有更多控制时也能直接使用 CoreAnimation。 Core Image CoreImage 提供非破坏的方式操作视频和静态图像。 OpenGL ES 及 GLKit OpenGLES 使用硬件加速接口来处理先进的 2D 和 3D 呈现。OpenGLES 通常由游戏开发者或想实现沉浸式图像体验的开发者使用。 OpenGLES 框架提供对呈现过程的全部控制，以及提供创建平滑动画所需要的帧速。 GLKit 是一组 Objective-C 类，以便能够使用面向对象接口来提供 OpenGL ES 的强大能力。 Text Kit 和 CoreText Text Kit 是 UIKit 框架的家族，用来执行最好的排面和文本管理。如果你的应用实现先进的文本操作，Text Kit 提供与应用视图的无缝集成。 CoreText 是处理先进排面和布局的低级别的 C 语言框架。 Image I/O ImageI/O 提供读写大多数图像格式的接口。 Assets Library AssetsLibrary 框架让你存取用户的图片、视频和媒体。你想在应用中集成用户自己的内容时可以使用该框架。 3.2 声音技术声音技术工作于底层硬件之上，为用户提供更加丰富的声音体验。这些体验包括播放和记录高质量的声音、处理MIDI内容以及使用设备内建的声音 等能力 Media Player framework 该框架是一个高级别的框架， 用来为用户提供对 iTunes 库存取的容易方式，也提供对播放轨迹和播放列表的支持。 当你想快速在应用中集成声音以及不需要控制播放行为时可以使用该框架。 AV Foundation AVFoundation 是管理声音以及视频播放和记录的面向对象接口。在记录声音和想对声音播放过程有更好的控制时可以使用该框架。 OpenAL OpenAL 是一个提供位置音效的跨平台的工业标准技术和接口。游戏开发者经常使用该技术来提供高质量的声音。 Core Audio Core Audio 是一组简单和智能的接口来记录和播放声音以及 MIDI 内容。在需要对声音有更好控制时使用该框架。 3.3 视频技术视频技术提供管理应用中的静态视频内容或者播放来自 Internet 的视频流的支持。对于带有适当的记录硬件的设备，该框架还能够记录视频以及与应用进行集成。 UIImagePickerController UIImagePickerController 是一个选择用户媒体文件的 UIKit 视图控制器。 Media Player MediaPlayer 框架提供一组呈现视频内容的简单易用的接口，该框架支持全屏和小窗口视频播放，也为用户提供可选的播放控制。 AVFoundation AVFoundation 提供先进的视频播放和记录能力。 在需要对视频呈现和记录有更多的控制时使用该框架，例如在实时应用中分层显示实时视频和应用提供的其它内容。 CoreMedia CoreMedia 框架为操作媒体定义低级别的数据类型和接口。当你需要对视频内容有无比的控制时可以使用该框架。 3.4 AirPlay 技术AirPlay 让应用串流声音和视频内容到 Apple TV 或者串流声音内容到第三方扬声器和接收器。 AirPlay 内建于许多框架，包括 UIKit、Media Player、AVFoundation、Core Audio。因此在大多数情况你不需要为了支持它做任何事。 在使用那些框架时，当播放内容时自动获得 AirPlay 支持。当用户选择使用 AirPlay 播放内容时系统自动进行路由。 框架 服务内容 Assets Library AssetsLibrary.framework 提供对用户设备上图片应用管理的图片和视频的存取。使用该框架来存取用户保存的图片相册或导入到设备的任意相册中的图片，你也能保存新的图片和视频到用户的图片相册。 AV Foundation AVFoundation.framework 提供一组播放、记录和管理声音和视频内容的Objective-C 类。当你想在应用的 UI 接口无缝集成媒体能力时使用该框架。你也能使用它来进行更先进的媒体处理，例如同时播放多个声音或者控制播放和记录过程的多个方面。该框架提供的服务包括: 1. 声音会话管理，包括对系统声明你的应用声音能力；2. 对应用媒体资源的管理；3. 对编辑媒体内容的支持；4. 捕捉声音和视频的能力；5. 播放声音和视频的能力；6. 轨迹管理；7. 媒体元数据的管理；8. 立体拍摄；9. 声音之间的精确同步；10. 提供一个确定声音文件细节内容的 Objective-C 接口，例如数据格式，采样率，通道数； 11. 通过 AirPlay 串流内容。 Core Audio Core Audio 是一个对声音处理提供本地支持的框架家族。这些框架支持声音的产生、记录、混合和回放。你也能使用这些接口处理 MIDI 内容以及串流声音和 MIDI 内容到其它应用。Core Audio 框架包括如下框架：1. CoreAudio.framework：定义 Core Audio 框架使用的所有数据类型。2. AudioToolbox.framework：提供声音文件和声音流的播放和记录服务。也提供管理声音文件，播放系统警告声音，在某些设备上触发震动的支持。3. AudioUnit.framework：提供使用内建声音单元。也提供使你的应用的声音内容作为对其它应用可视的声音组件的支持。4. CoreMIDI.framework：提供与 MIDI 设备通讯的标准方式，包括硬件键盘和合成器。你使用这个框架来发送和接收 MIDI 消息以及与通过 dock 连接器或网络连接到 iOS 设备的 MIDI 外设交互。5. MediaToolbox.framework：提供对声音 tap 接口的存取。 Core Graphics CoreGraphics.framework 包含Quartz 2D 绘制 api。Quartz 是一个原先用在 OS X 的先进的、向量绘制引擎。Quartz 支持路径绘制，抗锯齿呈现，剃度、图像、颜色、坐标空间转换以及 pdf 内容创建、显示和分析等功能。虽然这个 api 是 C-based 接口，但它使用了面向对象抽象来表现基本的绘制对象，因此使它容易存储和重用图形内容。 Core Image CoreImage.framework 提供一组强大的内建过滤器来操作视频和静态图像。你能在触摸弹起、纠正图片以及面部和特征检测等许多方面使用这些内建的过滤器。这些过滤器的先进特点是它们操作在非破坏方式，即原先的图像不被改变。这些过滤器针对底层硬件进行了优化，因此它们是快速和有效的。 Core Text CoreText.framework 提供一个对文本进行布局和字体处理的简单的、高性能的 C-based 接口。该框架用在不使用 TextKit 但仍想获得在字处理应用中发现的先进文本处理能力。该框架提供了一个智能的文本布局引擎，包括在其它内容周围环绕文本的能力，它也支持使用多种字体和呈现属性的先进的文本风格。 Core Video CoreVideo.framework 为 Core Media 框架提供缓冲和缓冲池支持。多数应用从不直接使用该框架。 Game Controller GameController.framework 让你在应用中发现和配置针对 iPhone/iPod/iPad 设备的游戏控制器。游戏控制器可以是物理连接到 iOS 设备或者是通过蓝牙无线连接。GameController 框架当控制器可获得时通知你的应用让应用可以规定哪个控制器输入与你的应用相关。 GLKit GLKit.framework 包含一组简化创建 OpenGLES 应用的 Objective-C based 单元类。GLKit 支持应用开发的四个关键领域：1. GLKView 和 GLKViewController 类提供一个 OpenGLES 视图和其呈现循环的标准实现。OpenGLES 视图代表应用管理底层的 framebuffer 对象。应用只需在视图上绘制。2. GLKTextureLoader 类提供在你的应用中使用图像转换和加载线程，允许应用自动加载纹理图像到应用的上下文。能够异步或同步加载纹理。当异步加载纹理时，应用应提供一个完成处理块，该处理块在纹理加载进应用上下文时被调用。3. GLKit 框架提供向量、矩阵和 3D 旋转以及提供 OpenGLES 1.1 上的矩阵。4. GLKBaseEffect、GLKSkyboxEffect 和 GLKReflectionMapEffect 类实现给通用图形操作提供可配置的图形着色。尤其 GLKBaseEffect 类实现了 OpenGL ES 1.1 规范上的光亮和材质模式，简化了移植一个应用从 OpenGL ES 1.1 到 OpenGL ES 最后版本的努力。 Image I/O ImageIO.framework 提供输入和输出图像数据和图像元数据的接口。该框架利用 CoreGraphics 数据类型和功能，并支持在 iOS 上所有的可获得的标准的图像类型。你能使用这个框架存取 Exif 和 IPTC 元数据属性。 Media Accessibility MediaAccessibility.framework 管理媒体文件中 closed-caption 内容的呈现。该框架与新的设置配合工作可以让用户决定是否允许 closed-caption 显示。 Media Player MediaPlayer.framework 提供应用中播放声音和视频的高级别支持。能够使用该框架做如下工作：1. 播放视频到用户屏幕或通过 AirPlay 到另外的设备屏幕。能够全屏幕播放视频或以可改变视图大小的方式播放。2. 存取用户的 iTunes 音乐库。能够播放音乐轨迹和播放列表、搜索音乐、给用户提供一个媒体 picker 呈现接口。3. 配置和管理电影的回放。4. 在锁定屏幕和 app 切换窗口上显示 NowPlaying 信息。当内容通过 AirPlay 提交时还能显示到 AppleTV 上。5. 检测视频通过 AirPlay 被串流的时间。 OpenAL OpenAudio Library（OpenAL）接口是用来在应用中提供位置音效的跨平台的标准。能够使用该接口在游戏和其它需要位置音效输出的程序中实现高性能、高质量的声音。因为 OpenAL 是跨平台的标准，在 iOS 使用 OpenAL 编写的代码能够容易地移植到许多其它平台。 OpenGL ES OpenGLES.framework 提供绘制 2D 和 3D 内容的工具，它是一个 C-based 的框架。该框架以最接近设备硬件的方式为全屏沉浸式应用例如游戏提供细粒度的图形控制和高的帧率。你能够与 EAGL 配合使用这个框架，为 OpenGL ES 绘制调用和 UIKit 的本地窗口对象之间提供接口。该框架支持 OpenGLES 1.1，2.0，3.0 规范。2.0 规范增加了片段和顶点着色的支持，3.0 规范增加了更多的功能，包括多个呈现目标和变换反馈。 Quartz Core QuartzCore.framework 包含 Core Animation 接口。Core Animation 是一个先进的复合技术，使用它能容易创建快和有效的 view-based 的动画。复合引擎利用底层硬件来有效的实时操作视图内容。只需规定动画的起始点，CoreAnimation 做剩下的工作。因为 Core Animation 内嵌在UIView架构的底层，因此它总是可用的。 Sprite Kit SpriteKit.framework 框架为 2D 和 2.5D 游戏提供硬件加速的动画系统。SpriteKit 提供大多数游戏需要的基础，包括一个图形引擎和动画系统，声音播放支持，一个物理仿真引擎。使用 SpriteKit 不需你自己创建这些事情，使你聚焦在内容设计和内容的高级别的交互上。在 Sprite Kit 应用中内容组织为场景。一个场景包括纹理对象，视频，路径图形，核心图像过滤器和其它的特效。SpriteKit 利用这些对象，确定这些对象到屏幕上的最有效的方式。当在场景中到了动画内容的时刻，你能使用 SpriteKit 来显式规定你想执行的行动或使用物理仿真引擎来为那些对象定义物理行为（例如重力、引力或排拆力）。除了 SpriteKit 框架，也有其它 Xcode 工具来创建颗粒发射效果和纹理图。你能使用 Xcode 工具来管理应用资源和快速地更新 Sprite Kit 场景。 四、CoreServices Layer CoreServices Layer 包含应用需要的基础的系统服务。这些服务中的核心是 CoreFoundation 和 Foundation 框架，定义了所有应用使用的基本类型。 该层也包含独立的技术来支持一些其它功能，例如位置、iCloud、社交媒体和网络。 4.1 包含的高级功能 Peer-to-Peer Services 点到点服务。 Multipeer Connectivity 框架提供通过蓝牙进行 p2p 连接的能力。 你能使用 p2p 连接来启动与附近设备的通讯会话。虽然 p2p 连接主要用在游戏中，你也能在其它类型的应用中使用这个功能。 iCloud Storage 云存储。 iCloud 存储让应用把用户文档和数据写到一个中心位置，用户然后能从他们的计算机和 iOS 设备存取这些数据。 使用 iCloud 可以使用户文档无所不在，意味着用户能从任何设备阅读或编辑那些文档，而不需要显式的同步或文件传输。存储文档到用户的 iCloud 账户也为用户提供了一层安全。即使用户的设备丢失，那些设备上的文档如果已经保存到 iCloud 就不会丢失。 应用能以两种方式使用 iCloud 存储，每一种有不同的使用意图： iCloud 文档存储。 可以使用这个功能在用户的 iCloud 账户存储用户文档和数据。 iCloud 键值存储。 使用这个功能在应用之间共享数据。 大多数应用使用 iCloud 文档存储来共享来自用户账户的文档。使用 iCloud 文档存储用户关心的是文档能否能够在设备之间共享以及他们是否能够从一个给定设备查看和管理那些文档。 相对的，iCloud 键值存储是应用与应用的其它实例共享小量数据（几十k字节）的方式，应用应当用它存储非紧急的应用数据，例如设置。 Automatic Reference Counting 自动引用计数。 AutomaticReference Counting（ARC)是一个编译级别的功能，用它来简化 Objective-C 对象生命周期过程的管理，以此代替用户必须记住什么时候应该保持和释放对象。 ARC 评估对象的生命周期需求和自动在编译时间插入适当的方法调用。 ARC 用来代替 ios 的早期版本中存在的传统的管理内存的编程模式。 新创建的工程自动使用 ARC。Xcode 也提供了移植工具帮助你转换遗留的工程来使用 ARC. Block Objects 块对象。 BlockObjects 是一个能够与你的 C 或 Objective-C 代码集成的 C 语言的构造块。一个blockobject 本质上是一个异步功能和相关的数据。 在其它语言中有时也被称做 closure 或 lambda。 Blocks 尤其用作回调或放在你需要一种容易的组合执行代码和相关数据方式的地方。 在 iOS，通常在下面的场景使用 Blocks： 作为代理或代理方法的代替； 作为回调功能的代替； 为某个一次性操作实现其完成处理函数； 在一个集合中的所有项上执行一个任务； 与提交队列一起执行异步任务。 Data Protection 数据保护。 DataProtection 允许应用利用设备上已有的内建的加密方法来使用用户的敏感数据。 当应用指定一个特定的文件被保护时，系统在磁盘上以加密格式存储该文件。 当设备锁定时，该文件的内容不能被应用和任何潜在的侵入者存取。 可是当设备由用户解锁时，一个解密key被创建允许你的应用存取那个文件。 用户也可以使用其它级别的数据保护机制。 实现数据保护需要你考虑如何创建和管理你想保护的数据。应用必须设计在数据的创建时间加密数据，以及当用户锁定或解锁设备时为存取条件改变做好准备。 File-Sharing Support 文件共享支持。 File-SharingSupport 使用户数据文件在 iTunes 9.1 和以后上可被其它应用获得。 一个应用声明支持文件共享使它的 /Documents 目录下的内容对其它用户可获得。用户然后当需要时能够把文件从 iTunes 移进或移出应用的 Documents 目录。 这个特征不允许应用与相同设备上的其它应用共享应用，这需要粘贴板或一个文档交互控制器对象。 应用为了允许文件共享支持，需要做如下工作： 在应用的 Info.plist 文件中增加 UIFileSharingEnabled 键，并设置其值为 YES。 在你的应用的 Documents 中放你想共享的文件； 当设备插进用户的计算机时，iTunes 在选中设备的 Apps 标签下显式一个文件共享节； 用户然后能够增加文件到设备的文档目录或移动文件到桌面。 支持文件共享的应用应该能够识别文件什么时候增加到其Documents目录和做出适当的应答。例如应用可以使任意新文件的内容可以从它的接口获得。也应该从不把 Documents 目录的文件列表呈现给用户来请求用户决定对那些文件做什么。 Grand Central Dispatch GrandCentral Dispatch（GCD)是一个 BSD 技术，应用可以用来管理其任务的执行。 GCD 与高优化的核组合成一个异步编程模式，来提供方便和更有效的对线程的替代。GCD 也为许多低级别的任务提供一个方便的选择，例如读和写文件描述符，实现定时器和监视信号和处理事件。 In-App Purchase 应用内购买。 In-App Purchase 提供在应用中销售应用特定的内容和服务以及来自 iTunes 的内容的能力。 这个功能使用 StoreKit 框架实现，并提供使用用户的 iTunes 账号来处理金融方面的事务需要的基础。 应用处理全部用户体验和供购买的内容及可获得服务的呈现。作为可下载的内容，你能把可下载的内容放到你自己的服务器或使用苹果的服务器。 SQLite SQLite 库让你在你的应用中嵌入一个轻量级的 sql 数据库，而不需要运行一个分离的远程数据库服务进程。 从你的应用，你能创建本地数据库文件，管理数据库表和表中的数据记录。 SQLite 库为通用功能使用设计，但已经被优化来提供对数据记录更快速的存取。 XML Support Foundation 框架提供一个 NSXMLParser 类用来从一个 xml 文档中引出元素。 操作 xml 内容的额外的支持由 libxml2 库提供支持。libxml2 开源库让你快速地分析或写任意的 xml 数据和转换 xml 内容到 html. 框架 服务内容 Accounts Framework Accounts.framework 为确定的用户账号提供单点登录模式。单点登录通过消除用户分离的多个账号需要的多次登录提示，来增强用户体验。它也通过为应用管理账号认证过程来简化开发模式。该框架需要与 Social 框架配合使用。 Address Book Framework AddressBook.framework 提供可编程存取用户的联系人数据库的方式。如果应用使用联系人信息，你能使用该框架来存取和修改联系人信息。例如一个聊天应用可以使用该框架来引出可能的联系人列表，通过联系人列表来启动一个会话以及在特定视图显示那些联系人。重要提示：存取用户的联系人数据需要用户的明确的许可。应用因此必须准备好用户拒绝存取的情形。应用也鼓励提供Info.plist键来描述需要存取的原因。 Ad Support Framework AdSupport.framework 提供存取应用用于广告功能的一个标识。该框架也提供一个指示用户是否选择广告跟踪的标志。应用在试图存取广告标识前需要度和判断这个标志。 CFNetwork CFNetwork.framework 是高性能的使用面向对象对网络协议进行抽象的一组 C-based 接口。这些抽象提供对协议栈细节的控制，使它容易使用低级别的构造例如 BSDsockets。你能使用该框架简化与 ftp 或 http 服务器通讯或决定 dnshosts 的任务。使用 CFNetwork 框架，你能：1. 使用 BSD sockets。2. 使用 SSL 或 TLS 创建安全连接。3. 决定dnshosts。4. 与 HTTP 服务器、认证 HTTP 服务器、HTTPS 服务器交互。5. 与 FTP 服务器交互。6. 发布、解决和浏览 Bonjour 服务。CFNetwork 物理和理论上基于 BSD sockets。 Core Data CoreData.framework 框架是管理 MVC 应用中的数据模式的一种技术。CoreData 框架打算在数据模式是高结构化的应用中使用。代替编程定义数据结构，在 Xcode 中能够使用图形工具来建立一个表现你的数据模式的纲要。在运行时，你的数据模式实体的实例通过 CoreData 框架被创建、管理和获得。通过为你的应用管理其数据模式，CoreData 大大减少了必须书写的代码量。CoreData 也提供如下功能：1. 为优化性能在 SQLite 数据库中存储对象数据；2. 一个管理数据表视图结果的 NSFetchedResultsController 类；3. 对基本的文本编辑之外的 undo/redo 的管理；4. 支持属性值的校验；5. 支持传播改变确保对象之间的关系保持一致性；6. 支持分组、过滤和在内存中优化数据。如果你开始开发一个新应用或计划对已有应用进行大的更新，应该考虑使用 CoreData。 Core Foundation CoreFoundation.framework 是一组 C-based 接口，为 iOS 应用提供基本的数据管理和服务功能。该框架包括如下支持：1. 集合数据类型（数组、集合等等）；2. 应用打包 Bundles；3. 字符串管理；4. 日期和时间管理5. 原始数据块管理6. Preferences管理；7. URL 和流操作；8. 线程9. 端口和 socket 通讯。CoreFoundation 框架与 Foundation 框架紧密相关，为相同的基本功能提供 Objective-C 接口。当你需要混合使用 Foundation 对象和 Core Foundation 类型时，你能利用两个框架之间存在的“toll-freebridging”。toll-free bridging”意味着你能可交换地在两个框架的方法和功能中使用一些 CoreFoundation 和 Foundation 类型。这个支持对许多数据类型可用，包括集合和字符串数据类型。每个框架的类和类型描述声明一个对象是否是 toll-freebridged以及在是的情况下来标识它连接到什么对象。 Core Location CoreLocation.framework 为应用提供位置信息。该框架使用板上的 GPS、蜂窝、或者Wi-Fi来定位用户的当前经度和纬度。你可在你的应用中集成该技术为用户提供位置信息。例如，你可实现一个基于用户的当前位置搜索附近餐馆、商店或者银行的应用。CoreLocation 框架也提供如下能力：1. 在包括磁力计的 iOS 设备上存取罗盘信息；2. 基于地理位置或蓝牙 beacon 进行区域监视；3. 支持使用蜂窝基站的低耗电的位置监视；4. 与 MapKit 配合来增强在特定情景下的位置数据的质量，例如开车时。 Core Media Framework CoreMedia.framework 提供由 AV Foundation 框架使用的低级别的媒体类型。大多数应用从不需要使用该框架，但少数需要更精确控制音视频内容创建和呈现的开发者可以使用它。 Core Motion Framework CoreMotion.framework 提供一组接口来存取设备上可获得的运动数据。该框架支持使用一组新的 block-based 接口来存取原始和加工过的加速度计数据。对于带有陀螺仪的设备，你也能获得原始的陀螺仪数据和加工过的反应设备方向和旋转速度的数据。你能在游戏或其它使用运动作为输入或作为增强用户体验的方式的应用中使用加速度计和陀螺仪两种数据。对于带有计步硬件的设备，你能存取它的数据来跟踪健康相关的运动。 Core Telephony Framework CoreTelephony.framework 提供与蜂窝电话的通话相关的信息交互的接口。可以使用该框架来获得用户的蜂窝服务提供者的信息。对于对蜂窝 call 事件感兴趣的应用例如 VoIP 应用也能在那些事件出现时被通知。 Event Kit EventKit.framework 提供存取用户设备上的月历事件的接口。能够使用该框架来做如下事情：1. 获得用户月历上存在的事件和提示；2. 增加事件到用户月历；3. 为用户创建提示和使它们出现在提示应用中；4. 为月历事件配置提示信号，包括设置提示信号应该什么时候触发的规则。重要提示：存取用户的月历和提示数据需要用户的明确许可。应用因此必须准备好用户拒绝的情形，也鼓励应用在其 Info.plist 文件中提供一个描述需要存取原因的键。 Foundation Foundation.framework 提供 Core Foundation 框架提供的许多功能的 Objective-C 封装。该框架提供如下功能的支持：1. 集合数据类型（数组、集合等等）；2. 应用打包 Bundles；3. 字符串管理；4. 日期和时间管理5. 原始数据块管理6. Preferences 管理；7. URL 和流操作；8. 线程和运行环；9. Bonjour；10. 通讯端口管理；11. 国际化；12. 规则表达式匹配；13. Cache 支持。 JavaScriptCore JavaScriptCore.framework 为许多标准的 JavaScript 对象提供 Objective-C 语言的封装。使用该框架来执行 JavaScript 代码和分析 JSON 数据。 Mobile Core Services MobileCoreServices.framework 定义在通用类型标识符（UTIs）中使用的低级别类型。 Multipeer Connectivity Framework MultipeerConnectivity.framework 支持附近设备的发现，并与那些设备直接通讯（不需要Internet连接）。使用该框架能够与附近设备通讯、容易的创建多人会话、支持可靠地传输顺序和实时数据。该框架为发现和管理网络服务提供可编程和 UI-based 的选项。应用能在 UI 中集成 MCBrowserViewController 类来显示一个发现设备列表让用户选择。另外也能使用 MCNearbyServiceBrowser 类来可编程的查找和管理对方设备。 Newsstand Kit Newsstand 应用为用户提供了一个阅读杂志和报纸的中心位置。想通过 Newsstand 提供杂志和报纸内容的出版商能够使用 NewsstandKit 框架（NewsstandKit.framework）创建它们自己的 iOS 应用，让用户启动新杂志和报纸新闻的后台下载。在启动下载后，系统处理下载操作和当内容可获得时通知应用。 Pass Kit Passbook 应用为用户提供了一个存储订货单、登机卡、入场券和商业折扣卡的位置。代替物理携带这些东西，用户现在能在 iOS 设备上存储它们，并和过去一样的方式使用。Pass Kit 框架 (PassKit.framework)提供把这些功能集成到你的应用的 Objective-C 接口。你能与web 接口和文件格式信息组合使用该框架来创建和管理你们公司提供的电子入场券。电子入场券由你们公司的 web service创建并通过 email、Safari 或定制的应用提交到用户的设备。电子入场券本身使用特殊的文件格式，在提交之前被加密签名。文件格式标识关于提供服务的相关信息以及用户知道是什么服务的信息。电子入场券也可以包含一个对卡进行校验的条码或其它信息，以便它能被兑换或使用。 Quick Look QuickLook.framework 提供了一个预览应用不直接支持的文件内容的接口。该框架主要打算用于应用从网络下载文件或处理来自不知道来源的文件的工作。在得到文件后，你能使用该框架提供的视图控制器来直接显示文件的内容。 Safari Services SafariServices.framework 提供以可编程的方式增加 URLs 到用户的 Safari 的书签的支持。 Social Framework Social.framework 提供一个简单的接口来存取用户的社交媒体账号。该框架取代 Twitter 框架并增加了其它社交账号，包括 Facebook、Sina 微博以及其它。应用能使用该框架提交状态更新和图像到用户账号。该框架与 Accounts 框架一起为用户提供单点登录并确保存取的用户账号是经过准许的。 Store Kit StoreKit.framework 提供在 iOS 应用中购买内容和服务的支持，也被称作应用内购买。例如，你能使用该功能来允许用户去锁另外的应用功能。或者如果你是一名游戏开发者，你能使用它来提供另外的游戏级别。在这两种情况，StoreKit 框架处理事务的收入方面事务，包括通过用户的 iTunes 账号处理付费请求，给应用提供关于购买的信息。Store Kit聚集在事务的金融方面，确保事务正确和安全。你的应用处理事务的其它方面，包括购买接口的呈现和适当内容的下载（去锁）。工作的分工让你能够控制购买内容的用户体验。由你决定你想呈现给用户什么样的购买接口和什么时候那样做，你也决定你的应用最好的提交机制。 System Configuration Framework SystemConfiguration.framework 提供可达性接口，你能用它来确定设备的网络配置，也能使用该框架确定一个 Wi-Fi 或蜂窝连接是否在用以及一个特定的主机服务器是否能够存取。 五、Core OS Layer Core OS 是用 FreeBSD 和 Mach 所改写的 Darwin，是开源、符合 POSIX 标准的一个 Unix 核心。 CoreOS 层包含其它大多数技术建在其之上的低级别的功能。虽然应用不直接使用这些技术，它们被其它框架使用。在需要显而易见的处理安全或与外设通讯的情形，你也能使用该层提供的框架。 Accelerate 加速框架 Accelerate框架 (Accelerate.framework)包含执行数字信号处理、线性代数、图像处理计算的接口。使用该框架的优点是它们针对所有的ios设备上存在的硬件配置做了优化，因此你能写一次代码确保在所有设备上有效运行。 Core Bluetooth Framework（核心蓝牙框架） CoreBluetooth 框架 (CoreBluetooth.framework)允许开发者与蓝牙低耗电外设（LE）交互。 使用该框架的Objective-C接口能够完成如下工作： 扫描蓝牙外设，连接和断开发现的蓝牙外设； 声明应用的服务，转换 iOS 设备成其它蓝牙设备的外设； 从 iOS 设备广播 iBeacon 信息； 保存你的蓝牙连接的状态，当应用重新启动时恢复那些连接； 蓝牙外设可获得性变化时获得通知。 External Accessory Framework（外部附件框架） ExternalAccessory 框架(ExternalAccessory.framework)提供与连接到IOS设备的硬件附件通讯的支持。 附件能通过 30-pin 连接器或使用蓝牙无线与 iOS 设备进行连接。该框架给你提供了获得关于每一个可获得的附件信息和启动通讯会话的方式。然后，你可自由的使用附件支持的命令直接操作附件。 Generic Security Services Framework（通用安全服务框架） GenericSecurity Services 框架 (GSS.framework)给ios应用提供一组标准安全相关的服务。该框架的基本接口规定在IETFRFC2743 andRFC4401。除了提供标准的接口，IOS还包括一些没有在标准中规定但被许多应用需要的一些管理证书需要的额外东西。 Security Framework（安全框架） 除了内建的安全功能，IOS也提供了一个明确的安全框架（Security.framework)，你能用它来保证应用管理的数据的安全。 该框架提供管理证书、公有和私有key和信任策略的接口。支持产生加密安全伪随机码。它也支持在keychain（保存敏感用户数据的安全仓库）中保存证书和加密 key。 公共加密库提供对称加密、hash认证编码（HMACs）、数字签名等额外支持，数字签名功能本质上与iOS上没有的OpenSSL库兼容。 在你创建的多个应用之间共享keychain是可能的。共享使它容易在相同的一套应用之间更平滑的协作。例如，你能使用该功能来共享用户口令或其它元素，否则可能使每个应用都需要提示用户。 为了在应用之间共享数据，必须为每个应用的 Xcode 工程配置适当的权限。 System System 级包含 kernel 环境、驱动以及操作系统级别的 unix 接口。kernel 本身负责操作系统的每一个方面：如虚拟内存管理、线程、文件系统、网络和互联通信。 在该层的驱动也提供在可获得的硬件与系统框架之间的接口。为了安全，对 kernel 和驱动的存取被限制到一组有限的系统框架和应用。 iOS 提供一组存取许多操作系统低级别功能的接口。应用通过 LibSystem 库存取这些功能。 该 C-based 的接口提供如下功能的支持： 多任务（POSIX 线程和 GCD) 网络（BSDsockets） 文件系统存取 标准 I/O Bonjour 和 DNS 服务 位置信息 内存分配 数学计算 64-Bit Support iOS原先是为32-bit架构的设备设计的。自iOS 7，开始支持在64-bit进行编译、链接和调试。所有的系统库和框架是支持64位的，意味着它们能在32-bit和64-bit应用中使用。 当以 64-bit 运行时编译时，应用可能运行的更快，因为在64-bit模式可以获得额外的处理器资源。 iOS使用OS X和其它64-bitUNIX系统使用的LP64模式，意味着在这些系统移植时不会碰到太头疼的事。 文章不会游泳De鱼 - iOS操作系统的层次结构Mac OS 和 iOS 操作系统架构","tags":[]},{"title":"iOS网络层设计","date":"2019-11-04T07:25:26.589Z","path":"2019/11/04/iOS/iOS架构/iOS 网络层设计/","text":"谈谈 iOS 网络层设计集约型API调用方式和离散型API调用方式的选择？[casa大神的网络设计方案的评论之集约型API和离散型API的理解？]（https://www.jianshu.com/p/9a96d5c795f8）","tags":[]},{"title":"iOS 类簇","date":"2019-11-04T06:41:42.788Z","path":"2019/11/04/iOS/iOS原理/iOS 类簇/","text":"一、类簇类簇是 Foundation 框架广泛使用的设计模式。类簇在公共抽象超类下对多个私有的具体子类进行分组。以这种方式对类进行分组简化了面向对象框架的公共可见体系结构，而不会降低其功能丰富度。类簇是基于抽象工厂设计模式的。 二、抽象工厂抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。很多人会混淆抽象工厂模式和工厂模式。实际上，两种的差别还是比较明显的，如下表。 |抽象工厂模式|工厂模式||:—-:|:——:||通过对象组合创建抽象产品|通过类继承创建抽象产品||创建多系列产品|创建一种产品||必须修改父类的接口才能支持新的产品|子类化创建者并重载工厂方法以创建新产品| 点击查看子类的名称。 三、NSArray《Effective Objective-C 2.0》中有一段话： In the case of NSArray, when an instance is allocated, it’s an instance of another class that’s allocated (during a call to alloc), known as a placeholder array. This placeholder array is then converted to an instance of another class, which is a concrete subclass of NSArray. 在使用了 NSArray 的 alloc 方法来获取实例时，该方法首先会分类一个属于某类的实例，此实例充当“占位数组”。该数组稍后会转为另一个类的实例，而那个类则是 NSArray 的实体子类。 不管创建的是可变还是不可变的数组，在 alloc 之后得到的类都是 __NSPlaceholderArray。而当我们 init 一个不可变的空数组之后，得到的是 __NSArray0；如果有且只有一个元素，那就是 __NSSingleObjectArrayI；有多个元素的，叫做 __NSArrayI；init 出来一个可变数组的话，都是 __NSArrayM。 注意：当使用 + array.. 方法创建数组对象时，只有一个元素也是 __NSArrayI。 这里 __NSSingleObjectArrayI，需要说明它的用意。 四、__NSSingleObjectArrayI作为对比，__NSArrayI 必须要实现 count objectAtIndex: 两个方法，但是我们可以非常显而易见的看出来，当数组只有一个数字的时候，是完全不需要这两个方法的。再深入一点的说明一下，__NSSingleObjectArrayI 是不需要去记录字符串长度的。它会比 __NSArrayI 少 8 个字节的长度。苹果可能是为了优化性能考虑，从而在 iOS8 之后推出这个新的子类。 另外需要说明的是，实际上，__NSArrayM 本身只有 7 个方法，分别是： count objectAtIndex: insertObject:atIndex: removeObjectAtIndex: addObject: removeLastObject replaceObjectAtIndex:withObject: 所有其它高等级的抽象建立在它们的基础之上。例如 - removeAllObjects 方法简单地往回迭代，一个个地调用 - removeObjectAtIndex:。 五、NSDictionaryNSDictionary 与 NSArray 类似，不管创建的是可变还是不可变的字典，在 alloc 之后得到的类都是 __NSPlaceholderDictionary。而 init 一个不可变的空数组之后，得到的是 __NSDictionary0；如果有且只有一个元素，那就是 __NSSingleEntryDictionaryI；有多个元素的，叫做 __NSDictionaryI；init 出来一个可变数组的话，都是 __NSDictionaryM。还有一个子类，__NSFrozenDictionaryM。 1234567NSDictionary * dict = [[NSDictionary alloc] initWithObjectsAndKeys:@\"Tom\", @\"name\", nil];NSDictionary * copyDict = dict.copy;NSLog(@\"copyDict : %@ %p %@\", copyDict, copyDict, [copyDict class]);copyMDict : &#123; name = Tom;&#125; 0x60000363cb60 __NSFrozenDictionaryM 这个子类没什么特殊的作用，它仍然会被视为不可变字典。也就是说，对它进行改变的操作，会导致程序崩溃。崩溃信息如下： 12-[__NSFrozenDictionaryM setObject:forKey:]: unrecognized selector sent to instance 0x600000490860*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSFrozenDictionaryM setObject:forKey:]: unrecognized selector sent to instance 0x600000490860' 其实在在 NSArray 中也有个对应的 __NSFrozenArrayM。 六、NSSetNSSet 的子类不过是 NSDictionary 换了个名字而已，不做细讲。 这里说明一下，__NSSingleObjectSetI 不需要打扰实际的哈希表，因为只有一个对象需要担心。类似的方法 containsObject: 不需要遍历任何东西或查找任何东西，它可以简单地将参数与 set/array/dictionary 表示的单个对象进行比较。 七、NSString当测试创建 NSString 对象的时候，通过创建 NSString 不同的对象，并利用 object_getClassName 方法打印对象。 1234567891011NSString * str1 = @\"1234567890\";NSLog(@\"str1: %@\", [str1 class]); // str1: __NSCFConstantString NSString * str2 = @\"123456789\";NSLog(@\"str2: %@\", [str2 class]); //str2: __NSCFConstantString NSString * str3 = [NSString stringWithFormat:@\"123456789\"];NSLog(@\"str3: %@\", [str3 class]); // str3: NSTaggedPointerString NSString * str4 = [NSString stringWithFormat:@\"1234567890\"];NSLog(@\"str4: %@\", [str4 class]); // str4: __NSCFString 这里出现了三个子类： __NSCFConstantString __NSCFString NSTaggedPointerString __NSCFConstantString 它是一个字符串常量。它的引用计数非常大，是 4294967295。它的意思是：这个属性，怎么都不会被释放。相同的对象，内存地址是相同的，可以直接使用 == 方法（但是，这个对象的指针的地址依然不同，还是两个不同的对象）。它在编译时就决定的，不能在运行时创建。 更详细的可以查看这篇博客。 __NSCFString 这个就是可变的 NSString 所属的子类。 NSTaggedPointerString 要从 iPhone5s 开始说起，iPhone5s 开始采用了 64 位处理器。在 32 位时代，一个指针大小是 32 位（4字节），而在 64 位时代翻倍，一个指针的大小变成了 64 位（8字节）。这样子，在处理某些小一点，短一点的 NSString、NSNumber、NSDate 对象的时候，会显得过于浪费效率。这个时候，苹果推出了 Tagged Pointer 技术。 苹果将一个对象的指针拆分成了两部分，一部分直接保存数据，另一部分作为特殊标记（tag），表示这个是一个特别的指针。这样呢，就会将节省很多的时间，因为它不再需要正常创建对象的申请和创建空间，处理引用计数，以及直接读取（在 objc_msgSend 当中，Tagged Pointer 会被识别出来，直接从指针中读取）。 苹果之前说过： 使用 Tagged Pointer 技术之后，在内存上读取的速度快了 3 倍，创建时的速度比以前快了 106 倍。 当然，这么做其实也是会有问题的，因为它并不是一个真正的对象，当你想要想其他普通的对象一样获取指针的时候，编译器直接就会报错（因为它也是在编译时创建的，而且压根没有 isa 指针）。 编译器会告诉你正确的方法：改为使用 object_getClass()。 八、总结类簇的优点： 可以将抽象基类背后的复杂细节隐藏起来 程序员不会需要记住各种创建对象的具体类实现，简化了开发成本，提高了开发效率 便于进行封装和组件化 减少了 if-else 这样缺乏扩展性的代码 增加新功能支持不影响其他代码 类簇的缺点： 已有的类簇非常不好扩展 我们了解类簇的好处： 出现 bug 时，可以通过崩溃报告中的类簇关键字，快速定位 bug 位置。 在实现一些固定且并不需要经常修改的事物时，可以高效的选择类簇去实现。 举个例子：针对不同版本，不同机型往往需要不同的设置，这时可以选择使用类簇； app 的设置页面这种并不需要经常修改的页面，可以使用类簇去创建大量重复的布局代码。 九、文章伯陽 - iOS中类簇的使用Friday Q&amp;A 2015-07-31: Tagged Pointer StringsNSString特性分析学习","tags":[]},{"title":"iOS OCR","date":"2019-11-04T05:31:51.742Z","path":"2019/11/04/iOS/iOS原理/iOS OCR/","text":"身份证识别，又称 OCR 技术。OCR 技术是光学字符识别的缩写，是通过扫描等光学输入方式将各种票据、报刊、书籍、文稿及其它印刷品的文字转化为图像信息，再利用文字识别技术将图像信息转化为可以使用的计算机输入技术。 实现原理及步骤 灰度化处理 将指定图片每个像素点的 RGB 三个分量通过一定的算法计算出该像素点的灰度值，使图像只含亮度而不含色彩信息。 二值化 将经过灰度化处理的图片转换为只包含黑色和白色两种颜色的图像，他们之间没有其他灰度的变化。在二值图中用 255 便是白色，0 表示黑色 腐蚀 将得到的二值图中的黑色块进行放大。即连接图片中相邻黑色像素点的元素。通过腐蚀可以把身份证上的身份证号码连接在一起形成一个矩形区域。 轮廊检测 图片经过腐蚀操作后相邻点会连接在一起形成一个大的区域，这个时候通过轮廊检测就可以把每个大的区域找出来，这样就可以定位到身份证上面号码的区域。 图像文字识别 将图像信息转化为可以使用的计算机输入技术。 开源库 OpenCV OpenCV 是一个开源的跨平台计算机视觉和机器学习库，通俗点的说，就是它给计算机提供了一双眼睛，一双可以从图片中获取信息的眼镜，从而完成人脸识别、身份证识别、去红眼、追踪移动物体等等的图像相关的功能 TesseractOCRiOS Tesseract 是目前可用的最准确的开源 OCR 引擎，可以读取各种格式的图片并将他们转换成各种语言文本。而 TesseractOCRiOS 则是针对 iOS 平台封装的 Tesseract 引擎库。 文章LYSNote - iOS OCR(身份证号码识别)","tags":[]},{"title":"iOS IM","date":"2019-11-04T02:17:57.382Z","path":"2019/11/04/iOS/iOS原理/iOS IM/","text":"发送图片、语音等有人知道语音留言聊天等大文件或大数据量的主流实现方式吗？ A：移动网络因为网络不稳定的客观因素存在，不适合实时发送较大的2进制文件（像电脑上的实时文件发送的那种），因为这涉及3方：客户端A、服务端、客户端B，任何两方的通讯因网络的不稳定而导致的重传等，都是个很不好处理的事情。 现在多数情况下都是通过http先上传到中转文件服务器，成功后再通知接收方，这种情况下，因上传的过程只限于客户端A和服务端，只涉及两方，网络的不稳定，也只影响了发送者（而不涉及接收者，因为对方还不知道你正在发送文件呢），所以无论是从可靠性、复杂性，还是用户体验的处理上，这种方式都要简单的多。而这么多年的移动应用也证明，这种云中转暂存的方式是比较适合于当前的移动网络和移动应用体验的。 Q：如果使用中转服务器，就有一个问题，， 就是收到音频信息后是直接显示那条音频消息，还是下载完再显示音频，如果直接显示音频，那用户点击的时候可能没有下载完成，点击没有声音。如果 下载完音频再显示消息的话，那么在下载过程中可能收到普通消息，普通消息不需要下载直接显示，这时候音频下载完成后显示在普通消息的后面的话顺序就乱了，显示在普通消息之前的话会有界面跳动的情况，用户体验不太好，这个问题怎么解决。 A：应该是发送方把语音文件上传到服务器成功后，同时发一条语音消息（只是一个包含了音频下载地址信息，可能是个文件名或url）发给接收方，接收方只在点击时才下载。 这就完全不存在你说的会乱序的问题。而且你仔细体验一下微信或其它主流im，都是这么玩的。你如果做过技术研究，就可以知道，微信最长 60 秒的语音留言大约 50KB 左右，你自已实现的话也差不多可以到90KB，而通常情况下没有人会说这么长的话，通常都是15秒左右，10 几 20kb 的文件大小，上传或下载都是非常轻松和快速的事情，所以，实际情况下的实用性，不需要怀疑。你可以去体验下 RainbowChat，即使是在很差的网络，比如在地铁行驶时使用，也同样体验很好。 A2：发送图片、录音、录像的思路是：先通过 http 上传图片，录音，录像到服务端，然后要求服务端返回图片录音录像的地址到客户端，然后客户端发送 json，发送图片地址录音录像的地址给 IM，IM 通过推送给另外的客户端，客户端收到以后，通过解析 json，然后通过 http 下载视频图片、语音，图片的话要进行缩放，录音的华，要有特定的图标标示，录像的话，下载以后截取第一帧的图片，不过建议这样，在展示图片的时候，缩放，在展示录像录音的时候，直接用图标替代展示的录像录音，然后通过用户点击图标通过http下载录音视频得到这种效果，此类功能需要一个ftp服务器，进行处理","tags":[]},{"title":"iOS 推送","date":"2019-10-30T12:57:54.251Z","path":"2019/10/30/iOS/iOS原理/iOS 推送/","text":"一、推送原理当用户打开应用程序的通知中心之后，苹果远程推送服务器就能把消息推送到装有该应用的设备上，具有强制性、实时性的特点，并且用户无需打开应用都能收到推送的消息。 1.1 名词介绍 Provider：消息提供者，一般是我们的后台服务器或者第三方推送服务器后台 APNs(Apple Push Notification service)：苹果推送通知服务。 APNs Server(Apple Push Notification service Server)：苹果推送通知服务的服务器。 notification：需要推送给 iOS 客户端(iPhone或者是iPad)上的消息 Client App：客户端 App,一般是安装在iPhone或者是iPad上的应用程序(App) deviceToken：是由 APNs 根据设备和App来生成的唯一的一串数据。deviceToken 在以下三种情况下会发生改变： 同一个设备上重新安装同一款应用 同一个应用安装在不同的设备上 设备重新安装了系统，同一个应用对应的 deviceToken 也会改变 1.2 推送原理 从图中可以很清楚的看出来推送的原理主要分为以下几步： 由 App 向 iOS 设备发送一个注册通知，用户需要同意系统发送推送； iOS 向 APNs 远程推送服务器发送 App 的 Bundle Id 和设备的 UDID； APNs 根据设备的 UDID 和 App 的 Bundle Id 生成 deviceToken 再发回给 App； App 再将 deviceToken 发送给远程推送服务器(自己的服务器), 由服务器保存在数据库中。 当自己的服务器想发送推送时，在远程推送服务器中输入要发送的消息并选择发给哪些用户的deviceToken，由远程推送服务器发送给 APNs。 APNs 根据 deviceToken 发送给对应的用户。 详细流程： 在今日头条 App 的 AppDelegate 的 didFinishLaunchingWithOptions 方法中注册远程推送通知，此时只要 iOS 设备正常联网能够访问到外网，iOS 设备默认就会和 APNs 服务器维持一个基于 TCP 的长连接，就会把 iOS 设备的 UDID(Unique Device Identifier:唯一设备标识码，用来标识唯一一台苹果设备)和 App 的 Bundle Identifier 通过长连接发送给 APNs 服务器，然后苹果通过这两个的值根据一定的加密算法得出 deviceToken，并将 deviceToken 返回给 iOS 设备。(注：APNs服务器会留有 UDID+Bundle Identifier+deviceToken 的映射表) 实现 UIApplicationDelegate 代理中的有关于注册远程通知的相关方法，包括注册成功、注册失败、对接收到通知的处理等。 如果注册成功，实现注册成功的代理方法，就能够接收到 deviceToken，并将 deviceToken 发送给 App 服务器，App 服务器将此 deviceToken 存储在数据库中(一般如果是及时通讯类应用那么还会与用户的账号进行映射)。 如果注册失败，那么实现注册失败的协议方法，处理失败后的事情。 app 服务器接收到 deviceToken 之后，就可以根据这些 deviceToken 向 APNs 发送推送消息。 APNs 接收到 deviceToken 和消息之后，根据 deviceToken 查找映射表找到对应的 UDID 和 Bundle Identifier，根据 UDID 找到唯一一台苹果设备，再在找到的苹果设备上根据 Bundle Identifier 找到唯一的应用，然后推送消息。 当设备接收到消息的时候，如果 App 在前台，那么不会在设备上方弹出横幅（如果使用了音效，还会触发音效的播放），直接调用我们实现的 UIApplicationDelegate 中的接收消息的方法；如果 App 在后台或者未运行时就会在设备的上方弹出横幅（如果使用了音效，还会触发音效的播放），点击横幅才会触发调用我们实现的 UIApplicationDelegate 中的接收消息的方法，这个时候你直接点击应用图标进来是不会调用的。 二、信息包信息包结构图： 上图显示的这个消息体就是我们的应用服务器（Provider）发送给 APNs 服务器的消息结构，APNs 验证这个结构正确并提取其中的信息后，再将消息推送到指定的 iOS 设备。 这个结构体包括五个部分 第一部分是命令标示符 第二部分是 devicetoken 的长度 第三部分是 devicetoken 字符串 第四部分是推送消息体（Payload）的长度 最后一部分也就是真正的消息内容了，里面包含了推送消息的基本信息，比如消息内容，应用 Icon 右上角显示多少数字以及推送消息到达时所播放的声音等 Payload（消息体）的结构: 1234567&#123; “aps”:&#123; “alert”:“CSDN给您发送了新消息”, “badge”:1, “sound”:“default” &#125;,&#125; 这其实就是个 JSON 结构体，alert 标签的内容就是会显示在用户手机上的推送信息，badge 显示的数量（注意是整型）是会在应用 Icon 右上角显示的数量，提示有多少条未读消息等，sound 就是当推送信息送达是手机播放的声音，传 defalut 就标明使用系统默认声音。 三、证书 应用的调试证书、描述文件 iOS- 最全的真机测试教程 应用的发布证书、描述文件 iOS-最全的App上架教程 推送的调试证书和发布证书 四、后台接收通知 开启推送。 当推送信息中包含 content-available 字段，并且等于 1 1234567891011&#123; \"_j_business\" = 1; \"_j_msgid\" = 29273432613945685; \"_j_uid\" = 31254343846; aps = &#123; alert = 11111; badge = 1; \"content-available\" = 1; sound = default; &#125;;&#125; app 即使在后台也能在 appDelegate 中触发代理回调 123456- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfofetchCompletionHandler: (void (^)(UIBackgroundFetchResult))completionHandler &#123;&#125; 五、Notification ExtensioniOS10推送通知进阶(Notification Extension） UNNotificationContentExtension（通知内容扩展）给通知创建一个自定义的用户界面； UNNotificationServiceExtension（通知服务扩展）是在收到通知后，展示通知前，做一些事情的。比如：增加附件，网络请求等。 5.1 UNNotificationServiceExtension - 通知服务扩展如果经常使用 iMessage 的朋友们，就会经常收到一些信息，附带了一些照片或者视频，所以推送中能附带这些多媒体是非常重要的。如果推送中包含了这些多媒体信息，可以使用户不用打开 app，不用下载就可以快速浏览到内容。众所周知，推送通知中带了 push payload，即使去年苹果已经把 payload 的 size 提升到了 4k bites，但是这么小的容量也无法使用户能发送一张高清的图片，甚至把这张图的缩略图包含在推送通知里面，也不一定放的下去。在 iOS X 中，我们可以使用新特性来解决这个问题。我们可以通过新的 service extensions 来解决这个问题。 iOS10 给通知添加附件有两种情况：本地通知和远程通知。 本地推送通知 只需给 content.attachments 设置 UNNotificationAttachment 附件对象 远程推送通知 需要实现 UNNotificationServiceExtension（通知服务扩展），在回调方法中处理 推送内容时设置 request.content.attachments（请求内容的附件）属性，之后调用 contentHandler 方法即可。 UNNotificationServiceExtension 提供在远程推送将要被 push 出来前，处理推送显示内容的机会。此时可以对通知的 request.content 进行内容添加，如添加附件、userInfo 等。下图显示了Notification Service Extension 的流程： 处理的细节如下： 为了能在 service extension 里面的 attachment，必须给 apns 增加 &quot;mutable-content&quot;:1 字段，使你的推送通知是动态可变的。 12345678&#123; \"aps\":&#123; \"alert\":\"Testing.. (34)\", \"badge\":1, \"sound\":\"default\", \"mutable-content\":1 &#125;&#125; 给项目新建一个 Notification Service Extension 的扩展。自动生成下列文件。 在 -didReceiveNotificationRequest:withContentHandler: 方法中处理request.content，用来给通知的内容做修改。如下面代码示例了收到通知后，给通知增加图片附件： 1234567891011121314151617181920212223242526272829303132- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123; self.contentHandler = contentHandler; self.bestAttemptContent = [request.content mutableCopy]; self.bestAttemptContent.title = [NSString stringWithFormat:@\"%@ [modified]\", self.bestAttemptContent.title]; //1. 下载 NSURL *url = [NSURL URLWithString:@\"http://img1.gtimg.com/sports/pics/hv1/194/44/2136/138904814.jpg\"]; NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:config]; NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; if (!error) &#123; //2. 保存数据 NSString *path = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@\"download/image.jpg\"]; UIImage *image = [UIImage imageWithData:data]; NSError *err = nil; [UIImageJPEGRepresentation(image, 1) writeToFile:path options:NSAtomicWrite error:&amp;err]; //3. 添加附件 UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:@\"remote-atta1\" URL:[NSURL fileURLWithPath:path] options:nil error:&amp;err]; if (attachment) &#123; self.bestAttemptContent.attachments = @[attachment]; &#125; &#125; //4. 返回新的通知内容 self.contentHandler(self.bestAttemptContent); &#125;]; [task resume];&#125; 使用 UNNotificationServiceExtension，你有 30 秒的时间处理这个通知，可以同步下载图像和视频到本地，然后包装为一个 UNNotificationAttachment 扔给通知，这样就能展示用服务器获取的图像或者视频了。 注意：如果数据处理失败、超时，extension 会报一个崩溃信息，但是通知会用默认的形式展示出来，app不会崩溃。 附件通知所带的附件格式大小都是有限的，并不能做所有事情，视频的前几帧作为一个通知的附件是个不错的选择。 UNNotificationAttachment：attachment 支持 音频 5M（kUTTypeWaveformAudio/kUTTypeMP3/kUTTypeMPEG4Audio/kUTTypeAudioInterchangeFileFormat） 图片10M（kUTTypeJPEG/kUTTypeGIF/kUTTypePNG） 视频50M（kUTTypeMPEG/kUTTypeMPEG2Video/kUTTypeMPEG4/kUTTypeAVIMovie） 5.2 UNNotificationContentExtension - 通知内容扩展要想创建一个自定义的用户界面，需要用到 Notification Content Extension（通知内容扩展）。 Notification Content Extension（通知内容扩展）允许开发者加入自定义的界面，在这个界面里面，你可以绘制任何你想要的东西。但是有一个最重要的限制就是，这个自定义的界面没有交互。它们不能接受点击事件，用户并不能点击它们。但是推送通知还是可以继续与用户进行交互，因为用户可以使用 notificaiton 的 actions。 注意：extension 也可以处理这些 actions。 推送界面的组成 header 的 UI 是系统提供的一套标准的 UI。这套 UI 会提供给所有的推送通知。 header 下面的 custom content 是自定义的内容，就是 Notification Content Extension。在这里，就可以显示任何你想绘制的内容了。你可以展示任何额外的有用的信息给用户。 default content 是系统的界面。这也就是 iOS 9 之前的推送的样子。 notification action 用户可以触发一些操作。并且这些操作还会相应的反映到上面的自定义的推送界面 content extension 中。 创建 Notification Content Extension 创建一个新的 Notification Content 的 target。Xcode 自动生成一个新的模板以及下列文件。 然后打开这里的 ViewController。 12345678910111213141516171819202122#import \"NotificationViewController.h\"#import &lt;UserNotifications/UserNotifications.h&gt;#import &lt;UserNotificationsUI/UserNotificationsUI.h&gt;@interface NotificationViewController () &lt;UNNotificationContentExtension&gt;@property IBOutlet UILabel *label;@end@implementation NotificationViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any required interface initialization here.&#125;- (void)didReceiveNotification:(UNNotification *)notification &#123; self.label.text = notification.request.content.body;&#125;@end 发现这里的 ViewController 就是一个普通的 UIViewController, 但是它实现了 UNNotificationContentExtension 协议。 UNNotificationContentExtension 协议有一个 required方法 didReceiveNotification:。当收到指定 categroy 的推送时，didReceiveNotification: 方法会随着 ViewController 的生命周期方法，一起被调用，这样就能接受 notification object，更新UI。 5.3 配置category接下来就是要让推送到达后，系统怎样找到自定义的 UI。这时候就需要配置 extension 的 info.plist 文件。 这里和我们给 notification actions 注册 category 一样，给这个通知扩展指定相应的 category。在 UNNotificationExtensionCategory 字段里写入相应的 category id。值得提到的一点是，这里对应的 category 是可以为一个数组的，里面可以为多个 category，这样做的目的是多个 category 共用同一套 UI。 上图中 category id 为 myNotificationCategory1 和 myNotificationCategory2 的通知就共用了一套 UI。 设置了 category 后，只要在通知里面增加 category 字段，值是上面在 extension 的 plist 里面配置的 category id，收到的通知就会通过自定义的样式显示。 远程通知在 apns 里面增加 category 字段。 12345678&#123; \"aps\":&#123; \"alert\":\"Testing.. (34)\", \"badge\":1, \"sound\":\"default\", \"category\":\"myNotificationCategory1\" &#125;&#125; 5.4 自定义UI然后开始写自定义UI。 123456- (void)didReceiveNotification:(UNNotification *)notification &#123; self.label.text = [NSString stringWithFormat:@\"%@ [modified]\", notification.request.content.title]; self.subLabel.text = [NSString stringWithFormat:@\"%@ [modified]\", notification.request.content.body]; self.imageView.image = [UIImage imageNamed:@\"hong.png\"];&#125; 可以在 ViewController 中增加一些 Label 和 ImageView，收到通知的时候，提取想要的内容，或者添加额外的内容，设置到我们自定义的 View 上。 5.5 优化 发现是自定义界面的大小很不美观 这时候可以通过设置 ViewController 的 preferredContentSize大小，控制自定义视图的大小。也可以通过约束，控制自定义视图的大小。 12345- (void)viewDidLoad &#123; [super viewDidLoad]; self.preferredContentSize = CGSizeMake(CGRectGetWidth(self.view.frame), 100);&#125; 视图恢复成正确的尺寸前，先展示有一大片空白的样子，然后变成正确的样子。当通知展示出来之后，它的大小并不是正常的我们想要的尺寸。iOS 系统会去做一个动画来 Resize 它的大小。这样体验很差。 会出现上面这张图的原因是，在推送送达的那一刻，iOS 系统需要知道我们推送界面的最终大小。但是我们自定义的extension在系统打算展示推送通知的那一刻，并还没有启动。所以这个时候，在我们代码都还没有跑起来之前，我们需要告诉iOS系统，我们的View最终要展示的大小。 为了解决这个问题，我们需要在 extension 的 info.plist 里设置一个 content size ratio。增加字段 UNNotificationExtensionInitialContentSizeRatio。 这个属性定义了宽和高的比例。当然设置了这个比例以后，也并不是万能的。因为你并不知道你会接受到多长的content。当你仅仅只设置比例，还是不能完整的展示所有的内容。有些时候如果我们可以知道最终的尺寸，那么我们固定尺寸会更好。 这时候我们发现我们自定义的界面显示的内容(custom content)和系统默认的内容(default content)重复了。 可以在 extension 的 info.plist 里设置，把系统默认的样式隐藏。增加字段UNNotificationExtensionDefaultContentHidden。 将系统内容隐藏后效果如下： 5.6 自定义操作iOS8 开始引入的 action 的工作原理： 默认系统的 Action 的处理是：当用户点击的按钮，就把 action 传递给 app，与此同时，推送通知会立即消失。这种做法很方便。 但是有的情况是，希望用户点击 action 按钮后，效果及时响应在我们自定义的 UI 上。这个时候，用户点击完按钮，我们把这个 action 直接传递给 extension，而不是传递给 app。当 actions 传递给 extension 时，它可以延迟推送通知的消失时间。在这段延迟的时间之内，我们就可以处理用户点击按钮的事件了，并且更新 UI，一切都处理完成之后，我们再去让推送通知消失掉。 这里我们可以运用 UNNotificationContentExtension 协议的第二个方法，这方法是 Optional 12345678910111213141516171819- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion&#123; if ([response.actionIdentifier isEqualToString:@\"action-like\"]) &#123; self.label.text = @\"点赞成功~\"; &#125; else if ([response.actionIdentifier isEqualToString:@\"action-collect\"])&#123; self.label.text = @\"收藏成功~\"; &#125; else if ([response.actionIdentifier isEqualToString:@\"action-comment\"])&#123; self.label.text = [(UNTextInputNotificationResponse *)response userText]; &#125; //这里如果点击的action类型为UNNotificationActionOptionForeground， //则即使completion设置成Dismiss的，通知也不能消失 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; completion(UNNotificationContentExtensionResponseOptionDismiss); &#125;);&#125; 在这个方法里判断所有的 action，更新界面，并延迟 1.5 秒后让通知消失。真实情况可能是，点击“赞”按钮后，发送请求给服务器，根据服务器返回结果，展示不同的UI效果在通知界面上，然后消失。如果是评论，则将评论内容更新到界面上。 如果还想把这个 action 传递给 app，最后消失的参数应该这样： 1completion(UNNotificationContentExtensionResponseOptionDismissAndForwardAction); 但是我实际运行遇见这种情况，如果点击的 action 类型为 UNNotificationActionOptionForeground，则即使 completion 设置成 Dismiss 的，通知也不能消失，也没有启动 app。 5.7 自定义输入型操作action 有 2 种类型： UNNotificationAction 普通按钮样式 UNTextInputNotificationAction 输入框样式 UNTextInputNotificationAction 的样式如下： 系统的输入样式的 action，只有在点击发送按钮时，才能接受到 action 的响应回调。（比如上面的didReceiveNotificationResponse:completionHandler: 方法）。但有的时候系统的样式或者功能不能满足需求，这时候可以自定义键盘上面的 inputAccessoryView。 首先，重写ViewController的下面两个方法： 123456789- (BOOL)canBecomeFirstResponder&#123; return YES;&#125;- (UIView *)inputAccessoryView&#123; return self.customInputView;&#125; 自定义 inputAccessoryView，以绘制自定义的输入样式。 12345678910111213- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion&#123; ... &#125; else if ([response.actionIdentifier isEqualToString:@\"action-comment\"])&#123; self.label.text = [(UNTextInputNotificationResponse *)response userText]; [self becomeFirstResponder]; [self.textField becomeFirstResponder]; self.completion = completion; &#125;&#125; 实现了点击评论按钮，ViewController 成为第一响应者，使自定义的输入样式显示出来。然后，让textField成为第一响应者，使键盘弹出。 这里将操作的completion保存，以便在需要的时候调用。比如，可以在点击键盘右下的send按钮时，调用completion，使通知消失。 123456789- (BOOL)textFieldShouldReturn:(UITextField *)textField&#123; [textField resignFirstResponder]; self.label.text = textField.text; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; self.completion(UNNotificationContentExtensionResponseOptionDismiss); &#125;); return YES;&#125; 实现效果如下： 5.8 结合使用两个扩展可以在 content extension 里面绘制界面时，通过 notification.request.content.attachments 获取附件放到自定义控件里面。 1234567891011121314- (void)didReceiveNotification:(UNNotification *)notification &#123; ... UNNotificationAttachment * attachment = notification.request.content.attachments.firstObject; if (attachment) &#123; if ([attachment.URL startAccessingSecurityScopedResource]) &#123; self.imageView.image = [UIImage imageWithContentsOfFile:attachment.URL.path]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [attachment.URL stopAccessingSecurityScopedResource]; &#125;); &#125; &#125;&#125; 我们可以提取 content 的 attachments。前文提到过，attachment 是由系统管理的，系统会把它们单独的管理，这意味着它们存储在我们 sandbox 之外。所以这里我们要使用 attachment 之前，我们需要告诉 iOS 系统，我们需要使用它，并且在使用完毕之后告诉系统我们使用完毕了。对应上述代码就是 -startAccessingSecurityScopedResource和-stopAccessingSecurityScopedResource 的操作。当我们获取到了 attachment 的使用权之后，我们就可以使用那个文件获取我们想要的信息了。 5.9 关于调试很多人在开发 iOS extension 时遇到了调试的问题，可以看这里的解决方法，如果还不能有效解决您的问题，欢迎评论留言。 Demo【WWDC2016 Session】iOS 10 推送Notification新特性iOS- 实现APP前台、后台、甚至杀死进程下收到通知后进行语音播报（金额）。 文章官方文档：Local and Remote Notification Programming GuideiOS中使用本地通知为你的APP添加提示用户功能iOS远程推送之(一)：APNs原理和基本配置iOS远程推送之(二)：角标applicationIconNumber设置iOS远程推送之(三)：点击通知横幅启动应用iOS 远程消息推送 APNS推送原理和一步一步开发详解篇SmartPushiOS远程推送原理及实现过程iOS 推送通知及通知扩展iOS10 推送通知 UserNotificationsiOS 推送全解析，你不可不知的所有 Tips！","tags":[]},{"title":"iOS 性能优化点","date":"2019-10-30T08:00:18.240Z","path":"2019/10/30/iOS/iOS优化/iOS 性能优化点/","text":"用 ARC 管理内存 在正确的地方使用 reuseIdentifier 尽量把 views 设置为完全不透明 如果你有透明的 Views 你应该设置它们的 opaque(不透明)属性为 YES。例如一个黑色半透明的可以设置为一个灰色不透明的 View 替代。原因是这会使系统用一个最优的方式渲染这些 views。这个简单的属性在 IB 或者代码里都可以设定。 Apple的文档对于为图片设置透明属性的描述是： (opaque)这个属性给渲染系统提供了一个如何处理这个 view 的提示。如果设为YES， 渲染系统就认为这个 view 是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能；如果设置为 NO，渲染系统正常地和其它内容组成这个 View。默认值是 YES。 在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个 view 嵌在 scroll view 里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响 app 的性能。 换种说法，大家可能更好理解： 只要一个视图的不透明度小于 1，就会导致 blending。blending 操作在 iOS 的图形处理器（GPU）中完成的，blending 主要指的是混合像素颜色的计算。举个例子，我们把两个图层叠加在一起,如果第一个图层的有透明效果，则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。 为什么 Blending 会导致性能的损失？ 原因是很直观的，如果一个图层是完全不透明的，则系统直接显示该图层的颜色即可。而如果图层是带透明效果的，则会引入更多的计算，因为需要把下面的图层也包括进来，进行混合后颜色的计算。 避免过于庞大的 xib iOS5 中加入的 Storyboards(分镜)正在快速取代 XIB。然而 XIB 在一些场景中仍然很有用。比如你的 app 需要适应 iOS5 之前的设备，或者你有一个自定义的可重用的 view,你就不可避免地要用到他们。 如果你不得不 xib 的话，使他们尽量简单。尝试为每个 Controller 配置一个单独的 xib，尽可能把一个 View Controller 的 view 层次结构分散到单独的 xib 中去。 需要注意的是，当你加载一个 xib 的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的 view，你这就是在浪费宝贵的内存资源了。Storyboards 就是另一码事儿了，storyboard 仅在需要时实例化一个 view controller。 当你加载一个引用了图片或者声音资源的 nib 时，nib 加载代码会把图片和声音文件写进内存。在 OS X 中，图片和声音资源被缓存在 named cache 中以便将来用到时获取。在 iOS 中，仅图片资源会被存进 named caches。取决于你所在的平台，使用 NSImage 或 UIImage 的 imageNamed: 方法来获取图片资源。 不要阻塞主线程 永远不要使主线程承担过多。因为 UIKit 在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。一直使用主线程的风险就是如果你的代码真的 block 了主线程，你的 app 会失去反应。 大部分阻碍主进程的情形是你的 app 在做一些牵涉到读写外部资源的 I/O 操作，比如存储或者网络。或者使用像 AFNetworking 这样的框架来异步地做这些操作。 如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者 NSOperation 和 NSOperationQueues. 你可以使用 NSURLConnection 异步地做网络操作: 1+ (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler 在 Image Views 中调整图片大小 如果要在 UIImageView 中显示一个来自 bundle 的图片，你应保证图片的大小和 UIImageView 的大小相同。在运行中缩放图片是很耗费资源的，特别是 UIImageView 嵌套在 UIScrollView 中的情况下。 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用 background thread，缩放一次，然后在 UIImageView 中使用缩放后的图片。 选择正确的 Collection 学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理 collections 时这句话尤其正确。 Apple 有一个 Collections Programming Topics 的文档详尽介绍了可用的 classes 间的差别和你该在哪些场景中使用它们。这对于任何使用 collections 的人来说是一个必读的文档。 Arrays：有序的一组值。使用 index 来 lookup 很快，使用 value lookup 很慢，插入/删除很慢。 Dictionaries：存储键值对。用键来查找比较快。 Sets：无序的一组值。用值来查找很快，插入/删除很快。 打开 gzip 压缩 大量 app 依赖于远端资源和第三方 API，你可能会开发一个需要从远端下载 XML、JSON、HTML 或者其它格式的 app。 问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在 edge 网络，下一分钟可能就切换到了 3G。不论什么场景，你肯定不想让你的用户等太长时间。 减小文档的一个方式就是在服务端和你的 app 中打开 gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。好消息是，iOS 已经在 NSURLConnection 中默认支持了 gzip 压缩，当然 AFNetworking 这些基于它的框架亦然。像 Google App Engine 这些云服务提供者也已经支持了压缩输出。 重用和延迟加载(lazy load) Views 更多的 view 意味着更多的渲染，也就是更多的 CPU 和内存消耗，对于那种嵌套了很多 view 在UIScrollView 里边的 app 更是如此。 这里我们用到的技巧就是模仿 UITableView 和 UICollectionView 的操作：不要一次创建所有的 subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。 这样的话你就只需要在滚动发生时创建你的 views，避免了不划算的内存分配。 创建 views 的能效问题也适用于你 app 的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个 view 的场景。有两种实现方法： 创建并隐藏这个 view 当这个 screen 加载的时候，当需要时显示它； 当需要时才创建并展示。 每个方案都有其优缺点。 用第一种方案的话因为你需要一开始就创建一个 view 并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的 app 操作更敏感因为当用户点击按钮的时候它只需要改变一下这个 view 的可见性。 第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。 Cache 一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。 我们能缓存些什么呢？一些选项是：远端服务器的响应、图片，甚至计算结果，比如 UITableView 的行高。 NSURLConnection 默认会缓存资源在内存或者存储中根据它所加载的 HTTP Headers。你甚至可以手动创建一个 NSURLRequest 然后使它只加载缓存的值。 下面是一个可用的代码段，你可以用它去为一个基本不会改变的图片创建一个 NSURLRequest 并缓存它： 1234567891011+ (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url &#123; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:url]; request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@\"image/*\" forHTTPHeaderField:@\"Accept\"]; return request; &#125; 注意你可以通过 NSURLConnection 获取一个 URL request，AFNetworking 也一样的。这样你就不必为采用这条 tip 而改变所有的 Networking 代码了。 如果你需要缓存其它不是 HTTP Request 的东西，你可以用 NSCache。 NSCache 和 NSDictionary 类似，不同的是系统回收内存的时候它会自动删掉它的内容。 权衡渲染方法 在 iOS 中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，uozhe 可以用CALayer， CoreGraphics甚至OpenGL来画它们。 当然每个不同的解决方法都有不同的复杂程度和相应的性能。有一篇 Apple UIKit team中的一员Andy Matuschak推荐过的很棒的关于graphic性能的帖子很值得一读。 简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积 – 这就是使用可变大小的图片更好的地方了: 你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。 处理内存警告 一旦系统内存过低，iOS 会通知所有运行中 app。在官方文档中是这样记述: 如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references. 幸运的是，UIKit 提供了几种收集低内存警告的方法: 在app delegate中使用applicationDidReceiveMemoryWarning: 的方法 在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning 注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知 一旦收到这类通知，你就需要释放任何不必要的内存使用。 例如，UIViewController 的默认行为是移除一些不可见的 view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。 这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。 然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。 重用大开销对象 一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。 想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。 注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。 下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例： 12345678910111213// in your .h or inside a class extension@property (nonatomic, strong) NSDateFormatter * formatter; // inside the implementation (.m)// When you need, just use self.formatter- (NSDateFormatter *)formatter &#123; if(! _formatter) &#123; _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @\"EEE MMM dd HH:mm:ss Z yyyy\";// twitter date format &#125; return _formatter;&#125; 还需要注意的是，其实设置一个 NSDateFormatter 的速度差不多是和创建新的一样慢的！所以如果你的 app 需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。 使用 Sprite Sheets 你是一个游戏开发者吗，那么Sprite sheets一定是一个你的最好的朋友了。Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。 我们有两个很好的关于Sprite的教程： How To Use Animations and Sprite Sheets in Cocos2D How to Create and Optimize Sprite Sheets in Cocos2D with Texture Packer and Pixel Formats 第二个教程涵盖了可能在很大程度上影响你游戏性能的pixel格式的细节。 如果你对于spirte sheet还不是很熟悉，可以看下这两个(youtube)视频SpriteSheets – The Movie, Part 1 和Part 2。视频的作者是创建Sprite sheet很流行的工具之一Texture Packer的作者Andreas Löw。 除了使用Sprite sheets，其它写在这里的建议当然也可以用于游戏开发中。比如你需要很多的Sprite sheets，像敌人，导弹之类的动作类必备元素，你可以重用这些sprites而不用每次都要重新创建。 避免反复处理数据 许多应用需要从服务器加载功能所需的常为 JSON 或者 XML 格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。 比如你需要数据来展示一个 table view，最好直接从服务器取 array 结构的数据以避免额外的中间数据结构改变。 类似的，如果需要从特定 key 中取数据，那么就使用键值对的 dictionary。 选择正确的数据格式 从 app 和网络服务间传输数据有很多方案，最常见的就是 JSON 和 XML。你需要选择对你的 app 来说最合适的一个。 解析 JSON 会比 XML 更快一些，JSON 也通常更小更便于传输。从 iOS5 起有了官方内建的 JSON deserialization 就更加方便使用了。 但是 XML 也有 XML 的好处，比如使用 SAX 来解析 XML 就像解析本地文件一样，你不需像解析 json 一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。 正确设定背景图片 在 View 里放背景图片就像很多其它 iOS 编程一样有很多方法: 使用UIColor的 colorWithPatternImage 来设置背景色； 在 view 中添加 一个UIImageView 作为一个子 View。 如果你使用全画幅的背景图，你就必须使用 UIImageView，因为 UIColor 的colorWithPatternImage 是用来创建小的重复的图片作为背景的。这种情形下使用 UIImageView 可以节约不少的内存： 123// You could also achieve the same result in Interface BuilderUIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"background\"]];[self.view addSubview:backgroundView]; 如果你用小图平铺来创建背景，你就需要用 UIColor 的 colorWithPatternImage 来做了，它会更快地渲染也不会花费很多内存： 1self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@\"background\"]]; 减少使用Web特性 UIWebView 很有用，用它来展示网页内容或者创建 UIKit 很难做到的动画效果是很简单的一件事。 但是你可能有注意到 UIWebView 并不像驱动 Safari 的那么快。这是由于以 JIT compilation 为特色的 Webkit 的 Nitro Engine 的限制。 所以想要更高的性能你就要调整下你的 HTML 了。第一件要做的事就是尽可能移除不必要的 javascript，避免使用过大的框架。能只用原生 js 就更好了。 另外，尽可能异步加载例如用户行为统计 script 这种不影响页面表达的 javascript。 最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用 Sprite sheet 提高加载速度和节约内存。 更多相关信息可以看下 WWDC 2012 session #601 – Optimizing Web Content in UIWebViews and Websites on iOS 设定 Shadow Path 如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择： 123456789#import &lt;QuartzCore/QuartzCore.h&gt; // Somewhere later ...UIView *view = [[UIView alloc] init]; // Setup the shadow ...view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f);view.layer.shadowRadius = 5.0f;view.layer.shadowOpacity = 0.6; 看起来很简单，对吧。 可是，坏消息是使用这个方法也有它的问题… Core Animation 不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。 使用 shadowPath 的话就避免了这个问题： 1view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath]; 使用 shadow path 的话 iOS 就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算 path 的话可能在某些 View 中比较困难，且每当 view 的 frame 变化的时候你都需要去 update shadow path. 优化 Table View Table view 需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。 为了保证 table view 平滑滚动，确保你采取了以下的措施: 正确使用 reuseIdentifier 来重用 cells 尽量使所有的 view opaque = YES，包括 cell 自身 避免渐变，图片缩放，后台渲染 缓存行高 如果 cell 内显示的内容来自 web，使用异步加载，缓存请求结果 使用 shadowPath 来画阴影 减少 subviews 的数量 尽量不使用 cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 尽量使用 rowHeight，sectionFooterHeight 和 sectionHeaderHeight 来设定固定的高，不要请求 delegate 选择正确的数据存储选项 当做本地数据存储时你会怎么做？ 你有很多选择，比如： 使用 NSUerDefaults 使用 XML，JSON 或者 plist 使用 NSCoding 存档 使用类似 SQLite 的本地 SQL 数据库 使用 Core Data NSUserDefaults 的问题是什么？虽然它很 nice 也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了 XML 这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用 SAX 又是一个很麻烦的事情。 NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。 当存储大块数据时，以上的方法都不适用. 在这种应用场景下，使用 SQLite 或者 Core Data 比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。 在性能层面来讲，SQLite 和 Core Data 是很相似的。他们的不同在于具体使用方法。Core Data 代表一个对象的 graph model，但 SQLite 就是一个 DBMS。Apple 在一般情况下建议使用 Core Data，但是如果你有理由不使用它，那么就去使用更加底层的 SQLite 吧。 加速启动时间 快速打开 app 是很重要的，特别是用户第一次打开它时。 你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。 还是那句话，避免过于庞大的 xib，因为他们是在主线程上加载的。所以尽量使用没有这个问题的 Storyboards 吧！ 注意，用 Xcode debug 时 watchdog 并不运行，一定要把设备从 Xcode 断开来测试启动速度 使用 Autorelease Pool NSAutoreleasePool 负责释放 block 中的 autoreleased objects。一般情况下它会自动被 UIKit 调用。但是有些状况下你也需要手动去创建它。 假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被 release 的时候。这是因为只有当 UIKit 用光了 autorelease pool 的时候 memory 才会被释放。 好消息是你可以在你自己的 @autoreleasepool 里创建临时的对象来避免这个行为： 12345678910NSArray * urls = &lt;# An array of file URLs #&gt;;for(NSURL *url in urls) &#123; @autoreleasepool &#123; NSError * error; NSString * fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ &#125;&#125; 这段代码在每次遍历后释放所有 autorelease 对象。 选择是否缓存图片 常见的从 bundle 中加载图片的方式有两种，一个是用 imageNamed，二是用 imageWithContentsOfFile，第一种比较常见一点。 既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？ imageNamed 的优点是当加载时会缓存图片。imageNamed 的文档中这么说: 这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。 相反的，imageWithContentsOfFile 仅加载图片。 下面的代码说明了这两种方法的用法: 123UIImage *img = [UIImage imageNamed:@\"myImage\"];// caching// orUIImage *img = [UIImage imageWithContentsOfFile:@\"myImage\"];// no caching 那么我们应该如何选择呢？ 如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用 imageWithContentsOfFile 足矣，这样不会浪费内存来缓存它。 然而，在图片反复重用的情况下 imageNamed 是一个好得多的选择。 避免日期格式转换 如果你要用 NSDateFormatter 来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用 NSDateFormatters 都是一个好的实践。 然而，如果你需要更多速度，那么直接用 C 是一个好的方案。Sam Soffes 有一个不错的帖子(http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析 ISO-8601 日期字符串的代码，简单重写一下就可以拿来用了。 嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！ 如果你可以控制你所处理的日期格式，尽量选择 Unix 时间戳。你可以方便地从时间戳转换到 NSDate: 1234- (NSDate *)dateFromUnixTimestamp:(NSTimeInterval)timestamp&#123; return [NSDate dateWithTimeIntervalSince1970:timestamp];&#125; 这样会比用 C 来解析日期字符串还快！ 需要注意的是，许多 web API 会以微秒的形式返回时间戳，因为这种格式在 javascript 中更方便使用。记住用 dateFromUnixTimestamp 之前除以 1000 就好了。 文章iOS最全性能优化(上)iOS最全性能优化(中)iOS最全性能优化(下)","tags":[]},{"title":"iOS图片加载速度极限优化","date":"2019-10-30T07:24:40.728Z","path":"2019/10/30/iOS/iOS优化/iOS 图片加载速度极限优化/","text":"FastImageCache 是 Path 团队开发的一个开源库，用于提升图片的加载和渲染速度，让基于图片的列表滑动起来更顺畅，来看看它是怎么做的。 一、优化点iOS 从磁盘加载一张图片，使用 UIImageVIew 显示在屏幕上，需要经过以下步骤： 从磁盘拷贝数据到内核缓冲区 从内核缓冲区复制数据到用户空间 生成 UIImageView，把图像数据赋值给 UIImageView 如果图像数据为未解码的 PNG/JPG，解码为位图数据 CATransaction 捕获到 UIImageView layer 树的变化 主线程 Runloop 提交 CATransaction，开始进行图像渲染 如果数据没有字节对齐，Core Animation 会再拷贝一份数据，进行字节对齐。 GPU 处理位图数据，进行渲染。 FastImageCache 分别优化了 2、4、6(1) 三个步骤： 使用 mmap 内存映射，省去了上述第 2 步数据从内核空间拷贝到用户空间的操作。 缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第 4 步解码的操作。 生成字节对齐的数据，防止上述第 6(1) 步 CoreAnimation 在渲染时再拷贝一份数据。 接下来具体介绍这三个优化点以及它的实现。 二、内存映射平常我们读取磁盘上的一个文件，上层 API 调用到最后会使用系统方法 read() 读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。 FastImageCache 采用了另一种读写文件的方法，就是用 mmap 把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。 三、解码图像一般我们使用的图像是 JPG/PNG，这些图像数据不是位图，而是是经过编码压缩后的数据，使用它渲染到屏幕之前需要进行解码转成位图数据，这个解码操作是比较耗时的，并且没有 GPU 硬解码，只能通过 CPU，iOS 默认会在主线程对图像进行解码。很多库都解决了图像解码的问题，不过由于解码后的图像太大，一般不会缓存到磁盘，SDWebImage 的做法是把解码操作从主线程移到子线程，让耗时的解码操作不占用主线程的时间。 FastImageCache 也是在子线程解码图像，不同的是它会缓存解码后的图像到磁盘。因为解码后的图像体积很大，FastImageCache 对这些图像数据做了系列缓存管理，详见下文实现部分。另外缓存的图像体积大也是使用内存映射读取文件的原因，小文件使用内存映射无优势，内存拷贝的量少，拷贝后占用用户内存也不高，文件越大内存映射优势越大。 四、字节对齐Core Animation 在图像数据非字节对齐的情况下渲染前会先拷贝一份图像数据，官方文档没有对这次拷贝行为作说明，模拟器和 Instrument 里有高亮显示“copied images”的功能，但似乎它有 bug，即使某张图片没有被高亮显示出渲染时被 copy，从调用堆栈上也还是能看到调用了 CA::Render::copy_image 方法： 那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前 CoreAnimation 要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel 是图像像素数据，data 是内存里其他数据) 块的大小应该是跟 CPU cache line 有关，ARMv7 是 32byte，A9 是 64byte，在 A9 下 CoreAnimation 应该是按 64byte 作为一块数据去读取和渲染，让图像数据对齐 64byte 就可以避免 CoreAnimation 再拷贝一份数据进行修补。FastImageCache 做的字节对齐就是这个事情。 五、实现FastImageCache 把同个类型和尺寸的图像都放在一个文件里，根据文件偏移取单张图片，类似 web 的 css 雪碧图，这里称为 ImageTable。这样做主要是为了方便统一管理图片缓存，控制缓存的大小，整个 FastImageCache 就是在管理一个个 ImageTable 的数据。整体实现的数据结构如图： 一些补充和说明： 5.1 ImageTable一个 ImageFormat 对应一个 ImageTable，ImageFormat 指定了 ImageTable 里图像渲染格式/大小等信息，ImageTable 里的图像数据都由 ImageFormat 规定了统一的尺寸，每张图像大小都是一样的。 一个 ImageTable 一个实体文件，并有另一个文件保存这个 ImageTable 的 meta 信息。 图像使用 entityUUID作为唯一标示符，由用户定义，通常是图像url的hash值。ImageTable Meta的indexMap记录了entityUUID-&gt;entryIndex的映射，通过indexMap就可以用图像的entityUUID找到缓存数据在ImageTable对应的位置。 5.2 ImageTableEntryImageTable的实体数据是ImageTableEntry，每个entry有两部分数据，一部分是对齐后的图像数据，另一部分是meta信息，meta保存这张图像的UUID和原图UUID，用于校验图像数据的正确性。 Entry数据是按内存分页大小对齐的，数据大小是内存分页大小的整数倍，这样可以保证虚拟内存缺页加载时使用最少的内存页加载一张图像。 图像数据做了字节对齐处理，CoreAnimation使用时无需再处理拷贝。具体做法是CGBitmapContextCreate创建位图画布时bytesPerRow参数传64倍数。 5.3 ChunkImageTable和实体数据Entry间多了层Chunk，Chunk是逻辑上的数据划分，N个Entry作为一个Chunk，内存映射mmap操作是以chunk为单位的，每一个chunk执行一次mmap把这个chunk的内容映射到虚拟内存。为什么要多一层chunk呢，按我的理解，这样做是为了灵活控制mmap的大小和调用次数，若对整个ImageTable执行mmap，载入虚拟内存的文件过大，若对每个Entry做mmap，调用次数会太多。 5.4 缓存管理用户可以定义整个ImageTable里最大缓存的图像数量，在有新图像需要缓存时，如果缓存没有超过限制，会以chunk为单位扩展文件大小，顺序写下去。如果已超过最大缓存限制，会把最少使用的缓存替换掉，实现方法是每次使用图像都会把UUID插入到MRUEntries数组的开头，MRUEntries按最近使用顺序排列了图像UUID，数组里最后一个图像就是最少使用的。被替换掉的图片下次需要再使用时，再走一次取原图—解压—存储的流程。 六、使用FastImageCache 适合用于 tableView 里缓存每个 cell 上同样规格的图像，优点是能极大加快第一次从磁盘加载这些图像的速度。但它有两个明显的缺点： 占空间大。因为缓存了解码后的位图到磁盘，位图是很大的，宽高 100*100 的图像在 2x 的高清屏设备下就需要 200*200*4byte/pixel = 156KB，这也是为什么 FastImageCache 要大费周章限制缓存大小。 接口不友好，需预定义好缓存的图像尺寸。FastImageCache 无法像 SDWebImage 那样无缝接入UIImageView，使用它需要配置 ImageTable，定义好尺寸，手动提供的原图，每种实体图像要定义一个 FICEntity 模型，使逻辑变复杂。 FastImageCache 已经属于极限优化，做图像加载/渲染优化时应该优先考虑一些低代价高回报的优化点，例如 CALayer 代替 UIImageVIew，减少 GPU 计算（去透明/像素对齐），图像子线程解码，避免 Offscreen-Render 等。在其他优化都做到位，图像的渲染还是有性能问题的前提下才考虑使用 FastImageCache 进一步提升首次加载的性能，不过字节对齐的优化倒是可以脱离 FastImageCache 直接运用在项目上，只需要在解码图像时 bitmap 画布的 bytesPerRow 设为 64 的倍数即可。 文章iOS图片加载速度极限优化—FastImageCache解析","tags":[]},{"title":"macro","date":"2019-10-30T06:09:24.820Z","path":"2019/10/30/IT/macro/","text":"Hello, 宏定义魔法世界 宏定义和全局变量的区别 宏会在预处理阶段被替换，而全局变量是在运行时； 宏定义不分配内存，全局变量定义需要分配内存； 宏不区分数据类型，它本质上是一段字符，在预处理的时候被替换到引用的位置，而全局变量区分数据类型； 宏定义之后值是不能改变的，全局变量的值是可以改变的； 宏定义只有在定义所在文件，或引用所在文件的其它文件中使用。 而全局变量可以在工程所有文件中使用，只需在使用前加一个声明。","tags":[]},{"title":"iOS hash","date":"2019-10-30T05:57:45.930Z","path":"2019/10/30/iOS/iOS原理/iOS hash/","text":"一、iOS hash下图列出 Hash 在 iOS 中的应用分析整理 知乎上的一句话： 算法、数据结构、通信协议、文件系统、驱动等，虽然自己不写那些东西，但是了解其原理对于排错、优化自己的代码有很大帮助，就好比虽然你不设计制造汽车，但如果你了解发动机、变速器、安全气囊等几项原理，对于你驾车如何省油、延长使用寿命、保证自身安全有很大好处，学而不思则罔、思而不学则殆，开发人员就是个随波而进的行业，无论何时何地，保持学习的深度和广度对于自身发展是很重要的，谁都不想 60 岁退休了还停留在增删查改的层面。 1.1 关联对象的实现原理关联对象采用的是 HashMap 嵌套 HashMap 的结构存储数据的，简单来说就是根据对象从第一个 HashMap 中取出存储对象所有关联对象的第二个 HashMap，然后根据属性名从第二个 HashMap 中取出属性对应的值和策略。 设计关联对象的初衷：通过传入对象 + 属性名字，就可以找到属性值。方案设计实现好后，查找一个对象的关联对象的基本步骤： 已知条件一：对象，因此引出第一个 HashMap（AssociationsHashMap），用一个能唯一代表对象的值作为 key，用存储对象的所有关联对象的结构（名字：值+策略）作为 value 已知条件二：属性名字，因此引出第二个 HashMap（ObjectAssociationMap），用属性名字作为key，用属性名字对应的结构体（值+策略）作为 value。 参考资料： iOS底层原理总结 - 关联对象实现原理关联对象 AssociatedObject 完全解析 1.2 weak 的实现原理weak 采用的是一个全局的 HashMap 嵌套数组的结构存储数据的，销毁对象（weak 指针指向的对象）的时候，根据对象从 HashMap 中找到存放所有指向该对象的 weak 指针的数组，然后将数组中的所有元素都置为 nil。 weak 的最大特点就是在对象销毁时，自动置 nil，减少访问野指针的风险，这也是设计 weak 的初衷。方案设计实现好后，weak 指针置 nil 的基本步骤： 对象 dealloc 的时候，从全局的 HashMap 中，根据一个唯一代表对象的值作为 key，找到存储所有指向该对象的 weak 指针的数组； 将数组中的所有元素都置为 nil。 参考资料： iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）weak实现原理 1.3 KVO 实现使用的基本数据结构一个对象可以被 n 个对象观察，一对象的 n 个属性又可以分别被 n 个对象观察。 详细参考： GNUstep KVC/KVO探索（二）：KVO的内部实现 1.4 iOS App 签名的原理一致性哈希算法 + 非对称加解密算法。 详细参考：iOS App 签名的原理 1.5 对象的引用计数存储的位置具体参考 ：苹果iOS系统源码思考：对象的引用计数存储在哪里？–从runtime源码得到的启示 123456789if 对象支持TaggedPointer &#123; return 直接将对象的指针值作为引用计数返回&#125; else if 设备是64位环境 &amp;&amp; Objective-C2.0 &#123; return 对象isa指针的一部分空间(bits_extra_rc)&#125;else &#123; return hash表&#125; 1.6 Runloop 与线程的存储关系线程和 RunLoop 之间是一一（子线程可以没有）对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 1.7 NSDictionary的原理参考文章：笔记-集合NSSet、字典NSDictionary的底层实现原理 二、哈希表2.1 哈希表定义哈希表（hash table，也叫散列表），是根据键（key）直接访问访问在内存储存位置的数据结构。 哈希表本质是一个数组，数组中的每一个元素成为一个箱子，箱子中存放的是键值对。根据下标 index 从数组中取 value。关键是如何获取 index，这就需要一个固定的函数（哈希函数），将 key 转换成 index。不论哈希函数设计的如何完美，都可能出现不同的 key 经过 hash 处理后得到相同的 hash 值，这时候就需要处理哈希冲突。 2.2 哈希表优缺点优点 哈希表可以提供快速的操作。 缺点 哈希表通常是基于数组的，数组创建后难于扩展。 没有一种简便的方法可以以任何一种顺序〔例如从小到大）遍历表中的数据项。 综上，如果不需要有序遍历数据，井且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。 2.3 哈希查找步骤 使用哈希函数将被查找的键映射（转换）为数组的索引，理想情况下（hash 函数设计合理）不同的键映射的数组下标也不同，所有的查找时间复杂度为 O(1)。但是实际情况下不是这样的，所以哈希查找的第二步就是处理哈希冲突。 处理哈希碰撞冲突。处理方法有很多，比如拉链法、线性探测法。 2.4 哈希表存储过程： 使用 hash 函数根据 key 得到哈希值 h 如果箱子的个数为 n，那么值应该存放在底(h%n)个箱子中。h%n 的值范围为 [0, n-1]。 如果该箱子非空（已经存放了一个值）即不同的 key 得到了相同的h产生了哈希冲突，此时需要使用拉链法或者开放定址线性探测法解决冲突。 2.5 常用哈希函数哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存 0~M 数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为 key 更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。 在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。 直接寻址法 数字分析法 平方取中法 折叠法 随机数法 除留余数法 要想设计一个优秀的哈希算法并不容易，根据经验，总结了需要满足的几点要求： 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）； 对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同； 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。 2.6 负载因子 负载因子 = 总键值对数/数组的个数 负载因子是哈希表的一个重要属性，用来衡量哈希表的空/满程度，一定程度也可以提现查询的效率。负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。所以当负载因子大于某个常数（一般是0.75）时，哈希表将自动扩容。哈希表扩容时，一般会创建两倍于原来的数组长度。因此即使 key 的哈希值没有变化，对数组个数取余的结果会随着数组个数的扩容发生变化，因此键值对的位置都有可能发生变化，这个过程也成为重哈希（rehash）。 2.7 哈希表扩容 在数组比较多的时候，需要重新哈希并移动数据，性能影响较大。 虽然能够使负载因子降低，但并不总是能有效提高哈希表的查询性能。比如哈希函数设计的不合理，导致所有的 key 计算出的哈希值都相同，那么即使扩容他们的位置还是在同一条链表上，变成了线性表，性能极低，查询的时候时间复杂度就变成了 O(n)。 2.8 哈希冲突的解决方法 拉链法 简单来说就是数组 + 链表。将键通过 hash 函数映射为大小为 M 的数组的下标索引，数组的每一个元素指向一个链表，链表中的每一个结点存储着 hash 出来的索引值为结点下标的键值对。 Java 8 解决哈希冲突采用的就是拉链法。在处理哈希函数设计不合理导致链表很长时（链表长度超过 8 切换为红黑树，小于 6 重新退化为链表）。将链表切换为红黑树能够保证插入和查找的效率，缺点是当哈希表比较大时，哈希表扩容会导致瞬时效率降低。 Redis 解决哈希冲突采用的也是拉链法。通过增量式扩容解决了 Java 8 中的瞬时扩容导致的瞬时效率降低的缺点，同时拉链法的实现方式（新插入的键值对放在链表头部）带来了两个好处： 头插法可以节省插入耗时。如果插到尾部，则需要时间复杂度为 O(n) 的操作找到链表尾部，或者需要额外的内存地址来保存尾部链表的位置。 头插法可以节省查找耗时。对于一个数据系统来说，最新插入的数据往往可能频繁的被查询。 开放定址线性探测法 使用两个大小为 N 的数组（一个存放 keys，另一个存放 values）。使用数组中的空位解决碰撞，当碰撞发生时（即一个键的 hash 值对应数组的下标被两外一个键占用）直接将下标索引加一（index += 1），这样会出现三种结果： 未命中（数组下标中的值为空，没有占用）。keys[index] = key，values[index] = value。 命中（数组下标中的值不为空，占用）。keys[index] == key，values[index] == value。 命中（数组下标中的值不为空，占用）。keys[index] != key，继续 index += 1，直到遇到结果 1 或 2 停止。 拉链法的优点 与开放定址线性探测发相比，拉链法有如下几个优点： 拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； 由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； 开放定址线性探测法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放定址线性探测发构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放定址线性探测发中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放定址线性探测发处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 拉链法的缺点 指针需要额外的空间，故当结点规模较小时，开放定址线性探测发较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址线性探测发中的冲突，从而提高平均查找速度。 开放定址线性探测法缺点 容易产生堆积问题； 不适于大规模的数据存储； 散列函数的设计对冲突会有很大的影响； 插入时可能会出现多次冲突的现象，删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂； 结点规模很大时会浪费很多空间； 2.9 Hash 表的平均查找长度Hash 表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。 查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数； 查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，再除以表长即为查找不成功时的平均查找长度。 例子： 给定一组数据{32，14，23，01，42，20，45，27，55，24，10，53}，假设散列表的长度为 13（最接近 n 的质数），散列函数为 H(k) = k。分别画出用 线性探测法 和 拉链法 解决冲突时构造的哈希表，并求出在等概率下情况，这两种方法查找成功和查找不成功的平均查找长度。 拉链法 查找成功时的平均查找长度：ASL = (1*6 + 2*4 + 3*1 + 4*1)/12 = 7/4 查找不成功时的平均查找长度：ASL = (4 + 2 + 2 + 1 + 2 + 1)/13 线性探测法 查找成功时查找次数 = 插入元素时的比较次数，查找成功的平均查找长度：ASL = (1 + 2 + 1 + 4 + 3 + 1 + 1 + 1 + 3 + 9 + 1 + 1 + 3)/12 = 2.5 查找不成功时的查找次数 = 第 n 个位置不成功时的比较次数为，第 n 个位置到第 1 个没有数据位置的距离：如第 0 个位置取值为 1，第 1个位置取值为 2。查找不成功时的平均查找长度：ASL = （ 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12/13 = 91/13 2.10 NSDictionary 版本一 是使用 NSMapTable 实现的，采用拉链法解决哈希冲突。 12345typedef struct &#123; NSMapTable *table; NSInteger i; struct _NSMapNode *j;&#125; NSMapEnumerator; 上述结构体描述了遍历一个 NSMapTable 时的一个指针对象，其中包含 table 对象自身的指针，计数值，和节点指针。 12345678typedef struct &#123; NSUInteger (*hash)(NSMapTable *table,const void *); BOOL (*isEqual)(NSMapTable *table,const void *,const void *); void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table,const void *); const void *notAKeyMarker;&#125; NSMapTableKeyCallBacks; 上述结构体中存放的是几个函数指针，用于计算 key 的 hash 值，判断 key 是否相等，retain，release 操作。 12345typedef struct &#123; void (*retain)(NSMapTable *table,const void *); void (*release)(NSMapTable *table,void *); NSString *(*describe)(NSMapTable *table, const void *);&#125; NSMapTableValueCallBacks; 上述存放的三个函数指针，定义在对 NSMapTable 插入一对 key、value 时，对 value 对象的操作。 1234567@interface NSMapTable : NSObject &#123; NSMapTableKeyCallBacks *keyCallBacks; NSMapTableValueCallBacks *valueCallBacks; NSUInteger count; NSUInteger nBuckets; struct _NSMapNode **buckets;&#125; 从上面的结构真的能看出 NSMapTable 是一个 哈希表 + 链表 的数据结构吗？在 NSMapTbale 中插入或者删除一个对象的寻找时间 = O(1) + O(m) ，m 为最坏时可能为 n。 O(1)：对 key 进行 hash 得到 bucket 的位置 O(m)：不同的 key 得到相同的 hash 值的 value 存放到链表中，遍历链表的时间 上面的结论和对应的解释似乎很合理？看看下面的分析再说也不迟！ 版本二 是对 _CFDictionary 的封装，解决哈希冲突使用的是开放定址线性探测法 123456789101112struct __CFDictionary &#123; CFRuntimeBase _base; CFIndex _count; CFIndex _capacity; CFIndex _bucketsNum; uintptr_t _marker; void *_context; CFIndex _deletes; CFOptionFlags _xflags; const void **_keys; const void **_values;&#125;; 从上面的数据结构可以看出 NSDictionary 内部使用了两个指针数组分别保存 keys 和 values。采用的是连续方式存储键值对。拉链法会将 key 和 value 包装成一个结果存储（链表结点），而 Dictionary 的结构拥有 keys 和 values 两个数组（开放寻址线性探测法解决哈希冲突的用的就是两个数组），说明两个数据是被分开存储的，不像是拉链法。 NSDictionary 使用开放定址线性探测法解决哈希冲突的原理： 可以看到，NSDictionary 设置的 key 和 value，key 值会根据特定的 hash 函数算出建立的空桶数组，keys 和 values 同样多，然后存储数据的时候，根据 hash 函数算出来的值，找到对应的 index 下标，如果下标已有数据，开放定址法后移动插入，如果空桶数组到达数据阀值，这个时候就会把空桶数组扩容，然后重新哈希插入。 这样把一些不连续的 key-value 值插入到了能建立起关系的 hash 表中，当我们查找的时候，key 根据哈希算法算出来索引，然后根据索引，直接 index 访问 hash 表 keys 和 hash 表 values，这样查询速度就可以和连续线性存储的数据一样接近 O(1) 了，只是占用空间有点大，性能就很强悍。 如果删除的时候，也会根据 _maker 标记逻辑上的删除，除非 NSDictionary（NSDictionary 本体的hash 值就是 count）内存被移除。 NSDictionary 之所以采用这种设计： 出于查询性能的考虑； NSDictionary 在使用过程中总是会很快的被释放，不会长期占用内存; 2.11 Apple方案选择解决哈希冲突的拉链法和开放定址线性探测法，Apple 都是用了。具体使用哪一种是根据存储数据的生命周期和特性决定的。 @synchronized 使用的是拉链法。拉链法多用于存储的数据是通用类型，能够被反复利用，就像@synchronized 存储的是锁是一种无关业务的实现结构，程序运行时多个对象使用同一个锁的概率相当高，有效的节省了内存。 weak 对象 associatedObject 采用的是开放定址线性探测法。开放定址线性探测法用于存储的数据是临时的，用完尽快释放，就像 associatedObject，weak。 2.12 NSDictionary 的存储过程iOS笔记：进一步认识 ==、isEqual、hash 通过方法 - (void)setObject:(id)anObject forKey:(id)aKey; 可以看出key必须遵循 NSCopy 协议，也就是说 NSDictionary 的 key 是 copy 一份新的，而 value 是浅拷贝的（如果想深拷贝可以使用 NSMapTable）。 key 还必须要继承 NSObject，并且重写 -(NSUInteger)hash; 和 -(BOOL)isEqual:(id)object; 两个方法。第一个函数用于计算 hash 值，第二个函数用来判断当哈希值相同的时候 value 是否相同（解决哈希冲突）。 文章浅谈算法和数据结构: 十一 哈希表NSDictionary和NSMutableArray底层原理（哈希表和环形缓冲区）Swift中字典的实现原理深入理解哈希表解读Objective-C的NSDictionaryiOS重做轮子，写一个NSDictionary（一）哈希表——线性探测法、链地址法、查找成功、查找不成功的平均长度哈希表、哈希算法、一致性哈希表细说@synchronized和dispatch_once","tags":[]},{"title":"isEqual","date":"2019-10-30T03:13:20.133Z","path":"2019/10/30/iOS/iOS原理/hash、isEqual/","text":"如何重写 hash 方法一个合理的 hash 方法要尽量让 hash 表中的元素均匀分布，来保证较高的查询性能。 如果两个对象可以被视为同一个对象，那么他们的 hash 值要一样。 mattt 在文章 Equality 中给出了一个普遍的算法: 12345- (NSUInteger)hash &#123; // 假设对象有三个属性，那么对这三个属性分别算出 hash 值，然后进行异或运算 return [self.property1 hash] ^ [self.property2 hash] ^ [self.property3 hash];&#125; Instagram 在开源 IGListKit 的同时，鼓励这么写 hash 方法： 123456789101112131415161718- (NSUInteger)hash&#123; NSUInteger subhashes[] = &#123;[self.property1 hash], [self.property2 hash], [self.property3 hash]&#125;; NSUInteger result = subhashes[0]; for (int ii = 1; ii &lt; 3; ++ii) &#123; unsigned long long base = (((unsigned long long)result) &lt;&lt; 32 | subhashes[ii]); base = (~base) + (base &lt;&lt; 18); base ^= (base &gt;&gt; 31); base *= 21; base ^= (base &gt;&gt; 11); base += (base &lt;&lt; 6); base ^= (base &gt;&gt; 22); result = base; &#125; return result;&#125; 示例： 12345678910111213141516171819202122232425262728293031@interface Person : NSObject @property (nonatomic, copy) NSString * name;@property (nonatomic, strong) NSDate * birthday; @end- (BOOL)isEqual:(id)object&#123; if (self == object) &#123; return YES; &#125; if (![object isKindOfClass:[Person class]]) &#123; return NO; &#125; return [self isEqualToPerson:(Person *)object];&#125; - (BOOL)isEqualToPerson:(Person *)person &#123; if (!person) &#123; return NO; &#125; BOOL haveEqualNames = (!self.name &amp;&amp; !person.name) || [self.name isEqualToString:person.name]; BOOL haveEqualBirthdays = (!self.birthday &amp;&amp; !person.birthday) || [self.birthday isEqualToDate:person.birthday]; return haveEqualNames &amp;&amp; haveEqualBirthdays;&#125; == 运算符判断是否是同一对象, 因为同一对象必然完全相同 判断是否是同一类型, 这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险 通过封装的 isEqualToPerson: 方法, 提高代码复用性 判断 person 是否是 nil，做参数有效性检查 对各个属性分别使用默认判等方法进行判断 返回所有属性判等的与结果 重写 isEqual 如何写一个合理高效的判等方法？ 首先对内存地址进行判断，地址相等 return YES; 进行判空处理，self == nil || object == nil ，return NO; 类型判断，![object isKindOfClass:[self class]] , return NO; 对对象的其他属性进行判断 根据这四个步骤，我们可以发现，我们都是先判断时间开销最少的属性。所以对于第 4 个步骤，如果对象有很多属性，我们也要依照这个原则来！ 比如 [self.array isEqual:other.array] &amp;&amp; self.intVal == other.intVal 这种写法是不合理的，因为 array 的判等会去遍历元素，时间开销大。如果 intVal 不相等的话就可以直接 return NO了，没必要进行数组的判等。应该这么写：self.intVal == other.intVal &amp;&amp; [self.array isEqual:other.array] 1234567891011121314- (BOOL)isEqual:(PersonModel *)object&#123; if (self == object) &#123; return YES; &#125; else if (self == nil || object == nil || ![object isKindOfClass:[self class]]) &#123; return NO; &#125; return (_property1 == object-&gt;_property1 ? YES : [_property1 isEqual:object-&gt;_property1]) &amp;&amp; (_property2 == object-&gt;_property2 ? YES : [_property2 isEqual:object-&gt;_property2]) &amp;&amp; (_property3 == object-&gt;_property3 ? YES : [_property3 isEqual:object-&gt;_property3]);&#125; hash 与判等的关系hash 方法主要是用于在 Hash Table 查询成员用的, 那么与 isEqual() 有什么关系呢? 为了优化判等的效率，基于 hash 的 NSSet 和 NSDictionary 在判断成员是否相等时，会这样做： 集成成员的 hash 值是否和目标 hash 值相等, 如果相同进入下一步，如果不等，直接判断不相等； hash 值相同的情况下，再进行对象判等，作为判等的结果 简单地说就是 hash值是对象判等的必要非充分条件 文章Equality","tags":[]},{"title":"Hash","date":"2019-10-30T02:00:51.603Z","path":"2019/10/30/数据结构/Hash/","text":"一、什么是 Hash 表先看一下 hash 表的结构图： 哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 123num = hash(key); // 把 Key 通过一个固定的算法函数（hash 函数）转换成一个整型数字num2 = num MOD n; // 用该数字对数组的长度进行取余array[num2] = value; // 取余结果就当作数组的下标，将 value 存储在数组的该下标处 当使用 hash 表查询时，就是使用 hash 函数将 key 转换成对应的数组下标，并定位到该下标的数组空间里获取 value，这样就充分利用到数组的定位性能进行数据定位。 index = F(key) hash 函数就是根据 key 计算出该存储地址的位置，hash 表就是基于 hash 函数建立的一种查找表。 二、Hash函数的构造方法 方法 方法有很多种，比如直接定址法、数字分析法、平方取中法、折叠法、随机数法、除留余数法等。 hash函数设计的考虑因素 计算 hash 地址所需时间 关键字的长度 表长 关键字分布是否均匀，是否有规律可循 尽量减少冲突 三、hash冲突3.1 什么是 hash 冲突对不同的关键字可能得到同一散列地址，即 k1≠k2，而 f(k1)=f(k2)，或 f(k1) MOD 容量 = f(k2) MOD 容量，这种现象称为碰撞，亦称冲突。 通过构造性能良好的 hash 函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是 hash 表的另一个关键问题。 创建和查找 hash 表都会遇到冲突，两种情况下解决冲突的方法应该一致。 3.2 解决 hash 冲突 开放定址法 也称再散列法，基本思想是： 当关键字 key 的 hash 地址 p = F(key) 出现冲突时，以 p 为基础，产生另一个 hash 地址 p1，如果 p1 仍然冲突，再以 p 为基础，再产生另一个 hash 地址 p2。。。直到找出一个不冲突的 hash 地址 pi，然后将元素存入其中。 通用的再散列函数的形式： H = (F(key) + di) MOD m i = 1，2，。。。，m-1 为碰撞次数 m 为表长 F(key) 为 hash 函数。 di 为增量序列，增量序列的取值方式不同，相应的再散列方式也不同。 1）线性探测再散列 di = 1，2，3，。。。，m-1 冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。 2）二次探测再散列 di = 12，-12，22，-22，…，k2，-k2 (k &lt;= m-1) 发生冲突时，在表的左右进行跳跃式探测，比较灵活。 3）伪随机数探测再散列 di = 伪随机序列 下面有个网上的示例： 现有一个长度为 11 的哈希表，已填有关键字分别为 17，60，29 的三条记录。其中采用的哈希函数为 f(key)= key MOD 11。现有第四个记录，关键字为 38。根据以上哈希算法，得出哈希地址为 5，跟关键字 60 的哈希地址一样，产生了冲突。根据增量 d 的取法的不同，有以下三种场景： 线性探测法：当发生冲突时，因为 f(key) + d，所以首先 5 + 1 = 6，得到下一个 hash 地址为 6，又冲突，依次类推，最后得到空闲的 hash 地址是 8，然后将数据填入 hash 地址为 8 的空闲区域。 二次探测法：当发生冲突时，因为 d = 12，所以 5 + 1 = 6，得到的下一个 hash 地址为 6，又冲突，因为 d = -12,所以 5 + (-1) = 4，得到下一个 hash 地址为 4，是空闲则将数据填入该区域。 伪随机数探测法：随机数法就是完全根据伪随机序列来决定的，如果根据一个随机数种子得到一个伪随机序列 {1，-2，2，。。。，k}，那么首先得到的地址为 6，第二个是 3，依次类推，空闲则将数据填入。 开放定址法在 iOS 中的应用还是有很多的，具体可参考笔记-集合 NSSet、字典NSDictionary的底层实现原理 链地址法（拉链法，位桶法） 将产生冲突的关键字的数据存储在冲突 hash 地址的一个线性链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。 四、负载因子（load factor）这里要提到两个参数：初始容量，加载因子，这两个参数是影响 hash 表性能的重要参数。 容量：表示 hash 表中数组的长度，初始容量是创建 hash 表时的容量。 加载因子：是 hash 表在其容量自动增加之前可以达到多满的一种尺度（存储元素的个数），它衡量的是一个散列表的空间的使用程度。 loadFactor = 加载因子 / 容量 一般情况下，当 loadFactor &lt;= 1 时，hash 表查找的期望复杂度为 O(1)。 对使用链表法的散列表来说，负载因子越大，对空间的利用更充分，然后后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为 0.75。 五、扩容当 hash 表中元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对数组进行扩容。而在数组扩容之后，最消耗性能的点就出现了，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是扩容。 什么时候进行扩容呢？ 当表中元素个数超过了容量 * loadFactor时，就会进行数组扩容。 用 OC 粗略的实现了一下扩容的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)resizeOfNewCapacity:(NSInteger)newCapacity &#123; NSInteger oldCapacity = _elementArray.count; if (oldCapacity == MAX_CAPACITY) &#123; // 扩容前的数组大小如果已经达到最大2^30 _threshold = oldCapacity - 1; // 修改阈值为int的最大值（2^30 - 1），这样以后就不会扩容了 return; &#125; // 初始化一个新的数组 NSMutableArray *newArray = [NSMutableArray arrayWithCapacity:newCapacity]; for (int i = 0; i &lt; newCapacity; i ++) &#123; [newArray addObject:@\"\"]; &#125; [self transferWithNewTable:newArray]; // 将数据转移到新的数组里 [_elementArray removeAllObjects]; [_elementArray addObjectsFromArray:newArray]; // hash表的数组引用新建的数组 _threshold = (NSInteger)_capacity * _loadFactor; // 修改阈值&#125;- (void)transferWithNewTable:(NSMutableArray *)array &#123; // 遍历旧数组，将元素转移到新数组中 for (int i = 0; i &lt; _elementArray.count; i ++) &#123; if ([[[_elementArray objectAtIndex:i] class] isEqual:[SingleLinkedNode class]]) &#123; SingleLinkedNode *node = _elementArray[i]; if (node != NULL) &#123; do &#123; [self insertElementToArrayWith:array andNode:node]; node = node.next; &#125; while (node != NULL); &#125; &#125; &#125;&#125;- (void)insertElementToArrayWith:(NSMutableArray *)array andNode:(SingleLinkedNode *)node &#123; NSInteger index = [node.key integerValue] % _capacity; // 计算每个元素在新数组中的位置 if (![[[array objectAtIndex:index] class] isEqual:[SingleLinkedNode class]]) &#123; [array replaceObjectAtIndex:index withObject:node]; &#125;else &#123; SingleLinkedNode *headNode = [array objectAtIndex:index]; while (headNode != NULL) &#123; headNode = headNode.next; &#125; // 直接把元素插入 headNode.next = node; &#125;&#125; 重哈希 哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。 哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。 哈希表的两个问题 如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。 如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。 六、如何重写 hash 方法一个合理的 hash 方法要尽量让 hash 表中的元素均匀分布，来保证较高的查询性能。 如果两个对象可以被视为同一个对象，那么他们的 hash 值要一样。 mattt 在文章 Equality 中给出了一个普遍的算法: 12345- (NSUInteger)hash &#123; // 假设对象有三个属性，那么对这三个属性分别算出 hash 值，然后进行异或运算 return [self.property1 hash] ^ [self.property2 hash] ^ [self.property3 hash];&#125; Instagram 在开源 IGListKit 的同时，鼓励这么写 hash 方法： 123456789101112131415161718- (NSUInteger)hash&#123; NSUInteger subhashes[] = &#123;[self.property1 hash], [self.property2 hash], [self.property3 hash]&#125;; NSUInteger result = subhashes[0]; for (int ii = 1; ii &lt; 3; ++ii) &#123; unsigned long long base = (((unsigned long long)result) &lt;&lt; 32 | subhashes[ii]); base = (~base) + (base &lt;&lt; 18); base ^= (base &gt;&gt; 31); base *= 21; base ^= (base &gt;&gt; 11); base += (base &lt;&lt; 6); base ^= (base &gt;&gt; 22); result = base; &#125; return result;&#125; 七、OC语言的实现构建 HashTable 对象 HashTable.h文件 123456789101112131415161718192021222324252627282930313233343536373839#import &lt;Foundation/Foundation.h&gt;@class SingleLinkedNode;NS_ASSUME_NONNULL_BEGIN@interface HashTable : NSObject@property (nonatomic, strong) NSMutableArray *elementArray;@property (nonatomic, assign) NSInteger capacity; // 容量 数组（hash表）长度@property (nonatomic, assign) NSInteger modCount; // 计数器，计算put的元素个数（不包括重复的元素）@property (nonatomic, assign) float threshold; // 阈值@property (nonatomic, assign) float loadFactor; // 加载因子/** 初始化Hash表 @param capacity 数组的长度 @return hash表 */- (instancetype)initWithCapacity:(NSInteger)capacity;/** 插入 @param newNode 存入的键值对newNode */- (void)insertElementByNode:(SingleLinkedNode *)newNode;/** 查询 @param key key值 @return 想要获取的value */- (NSString *)findElementByKey:(NSString *)key;@endNS_ASSUME_NONNULL_END HashTable.m 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#define MAX_CAPACITY pow(2, 30)#import \"HashTable.h\"#import \"SingleLinkedNode.h\"@implementation HashTable- (instancetype)initWithCapacity:(NSInteger)capacity &#123; self = [super init]; if (self) &#123; _capacity = capacity; _loadFactor = 0.75; _threshold = (NSInteger) _loadFactor * _capacity; _modCount = 0; // 直接初始化数组，这里为了方便理解hash，所以就直接给定capacity，java中默认是16 _elementArray = [NSMutableArray arrayWithCapacity:capacity]; for (int i = 0; i &lt; capacity; i ++) &#123; [_elementArray addObject:@\"\"]; &#125; &#125; return self;&#125;- (void)insertElementByNode:(SingleLinkedNode *)newNode &#123; if (newNode.key.length == 0) &#123; return; &#125; // 判断是否需要扩容 if (_threshold &lt; _modCount * _capacity) &#123; _capacity *= 2; [self resizeOfNewCapacity:_capacity]; &#125; // 计算存储位置 NSInteger keyValue = [newNode.key integerValue]; // F(x) = x; 得到hash值 NSInteger index = keyValue % _capacity; // hash值 MOD 容量 = 数组下标 newNode.hashValue = keyValue; // 如果插入的区域是空闲的，则直接把数据存入该空间区域 if (![[[_elementArray objectAtIndex:index] class] isEqual:[SingleLinkedNode class]]) &#123; [_elementArray replaceObjectAtIndex:index withObject:newNode]; _modCount++; &#125;else &#123; // 发生冲突，通过链表法解决冲突 SingleLinkedNode *headNode = [_elementArray objectAtIndex:index]; while (headNode != NULL) &#123; // 插入的key重复，则覆盖原来的元素 if ([headNode.key isEqualToString:newNode.key]) &#123; headNode.value = newNode.value; return; &#125; headNode = headNode.next; &#125; _modCount++; // 直接把元素插入 headNode.next = newNode; &#125;&#125;- (NSString *)findElementByKey:(NSString *)key &#123; if (key.length == 0) &#123; return nil; &#125; // 计算存储位置 NSInteger keyValue = [key integerValue]; NSInteger index = keyValue % _capacity; // hash函数keyValue % _capacity (0~9) if (index &gt;= _capacity) &#123; return nil; &#125; if (![[[_elementArray objectAtIndex:index] class] isEqual:[SingleLinkedNode class]]) &#123; return nil; &#125;else &#123; // 遍历链表，知道找到key值相等的node，然后返回value SingleLinkedNode *headNode = [_elementArray objectAtIndex:index]; while (headNode != NULL) &#123; if ([headNode.key isEqualToString:key]) &#123; return headNode.value; &#125; headNode = headNode.next; &#125; return nil; &#125;&#125;- (void)resizeOfNewCapacity:(NSInteger)newCapacity &#123; NSInteger oldCapacity = _elementArray.count; if (oldCapacity == MAX_CAPACITY) &#123; // 扩容前的数组大小如果已经达到最大2^30 _threshold = oldCapacity - 1; // 修改阈值为int的最大值（2^30 - 1），这样以后就不会扩容了 return; &#125; // 初始化一个新的数组 NSMutableArray *newArray = [NSMutableArray arrayWithCapacity:newCapacity]; for (int i = 0; i &lt; newCapacity; i ++) &#123; [newArray addObject:@\"\"]; &#125; [self transferWithNewTable:newArray]; // 将数据转移到新的数组里 [_elementArray removeAllObjects]; [_elementArray addObjectsFromArray:newArray]; // hash表的数组引用新建的数组 _threshold = (NSInteger)_capacity * _loadFactor; // 修改阈值&#125;- (void)transferWithNewTable:(NSMutableArray *)array &#123; // 遍历旧数组，将元素转移到新数组中 for (int i = 0; i &lt; _elementArray.count; i ++) &#123; if ([[[_elementArray objectAtIndex:i] class] isEqual:[SingleLinkedNode class]]) &#123; SingleLinkedNode *node = _elementArray[i]; if (node != NULL) &#123; do &#123; [self insertElementToArrayWith:array andNode:node]; node = node.next; &#125; while (node != NULL); &#125; &#125; &#125;&#125;- (void)insertElementToArrayWith:(NSMutableArray *)array andNode:(SingleLinkedNode *)node &#123;// 下面这个方法没有成功的获取到新数组中的位置// NSInteger index = [self indexForHashValue:node.hashValue andNewCapacity:array.count]; NSInteger index = [node.key integerValue] % _capacity; // 计算每个元素在新数组中的位置 if (![[[array objectAtIndex:index] class] isEqual:[SingleLinkedNode class]]) &#123; [array replaceObjectAtIndex:index withObject:node]; &#125;else &#123; SingleLinkedNode *headNode = [array objectAtIndex:index]; while (headNode != NULL) &#123; headNode = headNode.next; &#125; // 直接把元素插入 headNode.next = node; &#125;&#125;- (NSInteger)indexForHashValue:(NSInteger)hash andNewCapacity:(NSInteger)newCapacity &#123; return hash &amp; (newCapacity - 1);&#125;@end SingleLinkedNode.h文件： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface SingleLinkedNode : NSObject &lt;NSCopying&gt;@property (nonatomic, strong) NSString *key;@property (nonatomic, strong) NSString *value;@property (nonatomic, strong) SingleLinkedNode *next;@property (nonatomic, assign) NSInteger hashValue;- (instancetype)initWithKey:(NSString *)key value:(NSString *)value;@endNS_ASSUME_NONNULL_END SingleLinkedNode.m 文件： 12345678910111213#import \"SingleLinkedNode.h\"@implementation SingleLinkedNode- (instancetype)initWithKey:(NSString *)key value:(NSString *)value &#123; if (self = [super init]) &#123; _key = key; _value = value; &#125; return self;&#125;@end 文章佐笾 - 笔记-数据结构之 Hash（OC的粗略实现）","tags":[]},{"title":"iOS Crash","date":"2019-10-29T13:06:00.136Z","path":"2019/10/29/iOS/iOS优化/iOS Crash/","text":"Understanding and Analyzing Application Crash Reports","tags":[]},{"title":"iOS继承","date":"2019-10-29T13:00:54.502Z","path":"2019/10/29/iOS/iOS原理/iOS 继承/","text":"是否使用继承需要考虑三个点： 父类只是给子类提供服务，并不涉及子类的业务逻辑 层级关系明显，功能划分清晰，父类和子类各做各的。 父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求 万不得已不要用继承，优先考虑组合等方式。 如果只是共享接口，我们可以使用协议； 1234567891011121314151617181920212223242526272829@protocol ptc &lt;NSObject&gt;- (void)do;@end@interface A : NSObject &lt;ptc&gt;@end@implementation A - (void)do&#123;&#125;@end@interface B : NSObject &lt;ptc&gt;@end@implementation B- (void)do&#123;&#125;@end 如果希望共用一个方法的部分实现，但希望根据需要执行不同的其他行为，我们可以使用代理或者 AOP； 12345678910111213141516171819202122232425262728293031323334@protocol ptc &lt;NSObject&gt;- (void)do;@end@interface A : NSObject @property (nonatomic, weak) id&lt;ptc&gt; delegate;@end@implementation A- (void)func&#123; ... [self.delegate do]; ...&#125;@end@interface B : NSObject &lt;ptc&gt;@end@implementation B- (void)do&#123;&#125;@end 如果是添加方法，我们可以优先使用类别； 如果是为了使用一个类的很多方法，我们可以使用组合来实现。 12345678910111213141516171819202122232425262728293031323334353637383940@interface A : NSObject- (void)methodA;@end@interface B : NSObject -(void)methodB;@end// 定义 C 以及其需要的 methodA，methodB@interface C : NSObject &#123; A * __a; B * __b;&#125;- (id)initWithA:(A *)a b:(B *)b;- (void)methodA;- (void)methodB;@end @implementation ClassC- (id)initWithA:(A *)a b:(B *)b&#123; __a = [[A alloc] initWithA:a]; // [A copy]; __b = [[B alloc] initWithB:b]; // [B copy];&#125;- (void)methodA&#123; [__a methodA];&#125;- (void)methodB&#123; [__b methodB];&#125;@end 如果只是出于代码复用的目的而不区分类别和场景，就采用继承是不恰当的。当你发现你的继承超过 2 层的时候，你就要好好考虑是否这个继承的方案了，第三层继承正是滥用的开端。 跳出面向对象思想(一) 继承iOS架构师之路：慎用继承","tags":[]},{"title":"iOS 保持界面流畅的技巧","date":"2019-10-29T05:36:08.654Z","path":"2019/10/29/iOS/iOS优化/iOS 页面流畅技巧(2)/","text":"一、屏幕显示图像的原理 首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。 通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。 双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图： 为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。 那么目前主流的移动设备是什么情况呢？从网上查到的资料可以知道，iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。 二、卡顿产生的原因和解决方案 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。 从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。 2.1 CPU 资源消耗原因和解决方案 对象创建 对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。 尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 对象调整 对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 对象销毁 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 布局计算 视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。 不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。 Autolayout Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：http://pilky.me/36/。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。 文本计算 如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。 如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 文本渲染 屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 图片的解码 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 图像的绘制 图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）： 1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 2.2 GPU 资源消耗原因和解决方案相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 纹理的渲染 所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。 视图的混合 (Composing) 当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。 图形的生成 CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 三、AsyncDisplayKitAsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库，我从中学到了很多东西，所以下面我会花较大的篇幅来对其进行介绍和分析。 3.1 ASDK 的由来 ASDK 的作者是 Scott Goodson (Linkedin)，他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置以及 Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。 ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。 3.2 ASDK 的资料想要了解 ASDK 的原理和细节，最好从下面几个视频开始： 2014.10.15 NSLondon - Scott Goodson - Behind AsyncDisplayKit 2015.03.02 MCE 2015 - Scott Goodson - Effortless Responsiveness with AsyncDisplayKit 2015.10.25 AsyncDisplayKit 2.0: Intelligent User Interfaces - NSSpain 2015 前两个视频内容大同小异，都是介绍 ASDK 的基本原理，附带介绍 POP 等其他项目。后一个视频增加了 ASDK 2.0 的新特性的介绍。 除此之外，还可以到 Github Issues 里看一下 ASDK 相关的讨论，下面是几个比较重要的内容： 关于 Runloop Dispatch 关于 ComponentKit 和 ASDK 的区别 为什么不支持 Storyboard 和 Autolayout 如何评测界面的流畅度 之后，还可以到 Google Groups 来查看和讨论更多内容： https://groups.google.com/forum/#!forum/asyncdisplaykit 3.3 ASDK 的基本原理 ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。 为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装： 这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。 ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&gt;CALayer 相同的方式，实现了 ASNode-&gt;UIView 这样一个关系。 当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。 与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。 通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。 3.4 ASDK 的图层预合成 有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。 通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。 3.5 ASDK 异步并发操作 自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。 3.6 Runloop 任务分发Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章 深入理解RunLoop，里面对 ASDK 也有所提及。 iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。 Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。 ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：ASAsyncTransactionGroup。 通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。 3.7 其他ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0 添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。 四、微博 Demo 性能优化技巧我为了演示 YYKit 的功能，实现了微博和 Twitter 的 Demo，并为它们做了不少性能优化，下面就是优化时用到的一些技巧。 4.1 预排版当获取到 API JSON 数据后，我会把每条 Cell 需要的数据都在后台线程计算并封装为一个布局对象 CellLayout。CellLayout 包含所有文本的 CoreText 排版结果、Cell 内部每个控件的高度、Cell 的整体高度。每个 CellLayout 的内存占用并不多，所以当生成后，可以全部缓存到内存，以供稍后使用。这样，TableView 在请求各个高度函数时，不会消耗任何多余计算量；当把 CellLayout 设置到 Cell 内部时，Cell 内部也不用再计算布局了。 对于通常的 TableView 来说，提前在后台计算好布局结果是非常重要的一个性能优化点。为了达到最高性能，你可能需要牺牲一些开发速度，不要用 Autolayout 等技术，少用 UILabel 等文本控件。但如果你对性能的要求并不那么高，可以尝试用 TableView 的预估高度的功能，并把每个 Cell 高度缓存下来。这里有个来自百度知道团队的开源项目可以很方便的帮你实现这一点：FDTemplateLayoutCell。 4.2 预渲染微博的头像在某次改版中换成了圆形，所以我也跟进了一下。当头像下载下来后，我会在后台线程将头像预先渲染为圆形并单独保存到一个 ImageCache 中去。 对于 TableView 来说，Cell 内容的离屏渲染会带来较大的 GPU 消耗。在 Twitter Demo 中，我为了图省事儿用到了不少 layer 的圆角属性，你可以在低性能的设备（比如 iPad 3）上快速滑动一下这个列表，能感受到虽然列表并没有较大的卡顿，但是整体的平均帧数降了下来。用 Instument 查看时能够看到 GPU 已经满负荷运转，而 CPU 却比较清闲。为了避免离屏渲染，你应当尽量避免使用 layer 的 border、corner、shadow、mask 等技术，而尽量在后台线程预先绘制好对应内容。 4.3 异步绘制我只在显示文本的控件上用到了异步绘制的功能，但效果很不错。我参考 ASDK 的原理，实现了一个简单的异步绘制控件。这块代码我单独提取出来，放到了这里：YYAsyncLayer。YYAsyncLayer 是 CALayer 的子类，当它需要显示内容（比如调用了 [layer setNeedDisplay]）时，它会向 delegate，也就是 UIView 请求一个异步绘制的任务。在异步绘制时，Layer 会传递一个BOOL(^isCancelled)() 这样的 block，绘制代码可以随时调用该 block 判断绘制任务是否已经被取消。 当 TableView 快速滑动时，会有大量异步绘制任务提交到后台线程去执行。但是有时滑动速度过快时，绘制任务还没有完成就可能已经被取消了。如果这时仍然继续绘制，就会造成大量的 CPU 资源浪费，甚至阻塞线程并造成后续的绘制任务迟迟无法完成。我的做法是尽量快速、提前判断当前绘制任务是否已经被取消；在绘制每一行文本前，我都会调用 isCancelled() 来进行判断，保证被取消的任务能及时退出，不至于影响后续操作。 目前有些第三方微博客户端（比如 VVebo、墨客等），使用了一种方式来避免高速滑动时 Cell 的绘制过程，相关实现见这个项目：VVeboTableViewDemo。它的原理是，当滑动时，松开手指后，立刻计算出滑动停止时 Cell 的位置，并预先绘制那个位置附近的几个 Cell，而忽略当前滑动中的 Cell。这个方法比较有技巧性，并且对于滑动性能来说提升也很大，唯一的缺点就是快速滑动中会出现大量空白内容。如果你不想实现比较麻烦的异步绘制但又想保证滑动的流畅性，这个技巧是个不错的选择。 4.4 全局并发控制当我用 concurrent queue 来执行大量绘制任务时，偶尔会遇到这种问题： 大量的任务提交到后台队列时，某些任务会因为某些原因（此处是 CGFont 锁）被锁住导致线程休眠，或者被阻塞，concurrent queue 随后会创建新的线程来执行其他任务。当这种情况变多时，或者 App 中使用了大量 concurrent queue 来执行较多任务时，App 在同一时刻就会存在几十个线程同时运行、创建、销毁。CPU 是用时间片轮转来实现线程并发的，尽管 concurrent queue 能控制线程的优先级，但当大量线程同时创建运行销毁时，这些操作仍然会挤占掉主线程的 CPU 资源。ASDK 有个 Feed 列表的 Demo：SocialAppLayout，当列表内 Cell 过多，并且非常快速的滑动时，界面仍然会出现少量卡顿，我谨慎的猜测可能与这个问题有关。 使用 concurrent queue 时不可避免会遇到这种问题，但使用 serial queue 又不能充分利用多核 CPU 的资源。我写了一个简单的工具 YYDispatchQueuePool，为不同优先级创建和 CPU 数量相同的 serial queue，每次从 pool 中获取 queue 时，会轮询返回其中一个 queue。我把 App 内所有异步操作，包括图像解码、对象释放、异步绘制等，都按优先级不同放入了全局的 serial queue 中执行，这样尽量避免了过多线程导致的性能问题。 4.5 更高效的异步图片加载SDWebImage 在这个 Demo 里仍然会产生少量性能问题，并且有些地方不能满足我的需求，所以我自己实现了一个性能更高的图片加载库。在显示简单的单张图片时，利用 UIView.layer.contents 就足够了，没必要使用 UIImageView 带来额外的资源消耗，为此我在 CALayer 上添加了 setImageWithURL 等方法。除此之外，我还把图片解码等操作通过 YYDispatchQueuePool 进行管理，控制了 App 总线程数量。 4.6 其他可以改进的地方上面这些优化做完后，微博 Demo 已经非常流畅了，但在我的设想中，仍然有一些进一步优化的技巧，但限于时间和精力我并没有实现，下面简单列一下： 列表中有不少视觉元素并不需要触摸事件，这些元素可以用 ASDK 的图层合成技术预先绘制为一张图。 再进一步减少每个 Cell 内图层的数量，用 CALayer 替换掉 UIView。 目前每个 Cell 的类型都是相同的，但显示的内容却各不一样，比如有的 Cell 有图片，有的 Cell 里是卡片。把 Cell 按类型划分，进一步减少 Cell 内不必要的视图对象和操作，应该能有一些效果。 把需要放到主线程执行的任务划分为足够小的块，并通过 Runloop 来进行调度，在每个 Loop 里判断下一次 VSync 的时间，并在下次 VSync 到来前，把当前未执行完的任务延迟到下一个机会去。这个只是我的一个设想，并不一定能实现或起作用。 五、如何评测界面的流畅度最后还是要提一下，“过早的优化是万恶之源”，在需求未定，性能问题不明显时，没必要尝试做优化，而要尽量正确的实现功能。做性能优化时，也最好是走修改代码 -&gt; Profile -&gt; 修改代码这样一个流程，优先解决最值得优化的地方。 如果你需要一个明确的 FPS 指示器，可以尝试一下 KMCGeigerCounter。对于 CPU 的卡顿，它可以通过内置的 CADisplayLink 检测出来；对于 GPU 带来的卡顿，它用了一个 1x1 的 SKView 来进行监视。这个项目有两个小问题：SKView 虽然能监视到 GPU 的卡顿，但引入 SKView 本身就会对 CPU/GPU 带来额外的一点的资源消耗；这个项目在 iOS 9 下有一些兼容问题，需要稍作调整。 我自己也写了个简单的 FPS 指示器：FPSLabel 只有几十行代码，仅用到了 CADisplayLink 来监视 CPU 的卡顿问题。虽然不如上面这个工具完善，但日常使用没有太大问题。 最后，用 Instuments 的 GPU Driver 预设，能够实时查看到 CPU 和 GPU 的资源消耗。在这个预设内，你能查看到几乎所有与显示有关的数据，比如 Texture 数量、CA 提交的频率、GPU 消耗等，在定位界面卡顿的问题时，这是最好的工具。 六、文章ibireme - iOS 保持界面流畅的技巧","tags":[]},{"title":"贝塞尔曲线","date":"2019-10-28T14:09:48.201Z","path":"2019/10/28/iOS/iOS动画/贝塞尔曲线/","text":"一、贝塞尔曲线贝塞尔曲线，可以通过三个点，来确定一条平滑的曲线。 Bézier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线。 曲线定义：起始点、终止点(也称锚点)、控制点。 通过调整控制点，贝塞尔曲线的形状会发生变化。矢量绘制曲线。 公式：B(t)为时间 t 下点的坐标，P0 为起点，Pn 为终点，Pi 为控制点 一阶贝塞尔曲线(线段)：由 P0 至 P1 的连续点描述一条线段 二阶贝塞尔曲线(抛物线)： 由 P0 至 P1 的连续点 Q0 描述一条线段；由 P1 至 P2 的连续点 Q1 描述一条线段；由 Q0 至 Q1 的连续点 B(t) 描述一条二次贝塞尔曲线 三阶贝塞尔曲线： 通用公式： 四阶贝塞尔曲线： 五阶贝塞尔曲线： 二、使用 miterLimit 最大斜接长度（只有在使用 kCGLineJoinMiter 是才有效），边角的角度越小，斜接长度就会越大 为了避免斜接长度过长，使用 lineLimit 属性限制，如果斜接长度超过 miterLimit，边角就会以 KCALineJoinBevel 类型来显示。 1234/** * @brief 绘制三次贝塞尔曲线 */- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; 1- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; 贝塞尔曲线（UIBezierPath）属性、方法汇总 三、德卡斯特里奥算法(De Casteljau’s Algorithm)绘制贝塞尔曲线http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/de-casteljau.html 德卡斯特里奥算法可以计算贝塞尔曲线上的点 C(u)，u ∈ [0,1]。因此，通过给定一组 u 的值，便可以计算出贝塞尔曲线上的坐标序列，从而绘制出贝塞尔曲线。 德卡斯特里奥算法的基础就是在向量 AB 上选择一个点 C，使得 C 分向量 AB 为 u：1-u(也就是∣AC∣:∣AB∣= u)。给定点 A、B 的坐标以及 u(u ∈ [0,1]) 的值，点 C 的坐标便为：C = A + (B - A) u = (1 - u) A + B * u。 定义贝塞尔曲线的控制点 Pi 编号为 0i，其中 0 表示是第 0 次迭代，递推。 德卡斯特里奥算法的思想如下： 为了计算 n 次贝塞尔曲线上的点 C(u)，u ∈ [0,1]，首先将控制点连接形成一条折线 00-01-02…0(n - 1)-0n。利用上述方法，计算出折线中每条线段 0j-0(j+1) 上的一个点 1j，使得点 1j 分该线段的比为 u:1-u。然后在折线 10-11-…-1(n-1) 上递归调用该算法，以此类推。最终，求得最后一个点 n0。 德卡斯特里奥证明了，点 n0 一定是曲线上的点。 如上图，曲线控制点是 00、01、02、03、04、05。线段 00-01 上取点 10 分该线段的比为 u:1-u，类似的取点 11、12、13、14，然后第二次迭代在线段 10-11 上取点 20 分该线段的比为 u:1-u，类似地取点 21、22、23。然后进行下一次迭代，依次类推，直到最后在线段 40-41 上取点 50，50 是最终惟一的点，也是在曲线上的点。 上述直观的算法描述可以表达成一个计算方法 首先，将所有给定的控制点排列成一列，在上图中，即为最左边的一列。每一对相邻的控制点可以伸出两个箭头，分别指向右下方和右上方。在相邻箭头的交叉处，生成一个新的控制点。例如，控制点 ij 和 i(j +1) 生成新的控制点 (i + 1)j。指向右下方的箭头表示乘以 (1 - u)，指向右上方的箭头表示乘以 u。 因此，通过第 0 列，可以求出第 1 列，然后求出第 2 列…，最终，在 n 次迭代后，可以到达惟一的一个点 n0，这个点就是曲线上的点。 但是，直接通过递归方法计算 Pij 效率低下，其原因与通过递归方法计算斐波那契数列一样：递归方法有大量的重复计算。 德卡斯特里奥算法还有一个有趣的性质。对于同一列中的连续的一组控制点，对其应用德卡斯特里奥算法，那么由这些控制点确定的曲线上的点，就是以这组控制点为边的等边三角形中，与这些控制点相对的顶点。 例如：由控制点 02、03、04、05 确定的曲线上对应 u 的点是 32(蓝色的等边三角形)。同样，控制点 11、12、13 确定的曲线上对应 u 的点是 31(黄色三角形)。","tags":[]},{"title":"NSArray、NSDictionary","date":"2019-10-28T07:22:10.395Z","path":"2019/10/28/iOS/iOS原理/NSArray、NSDictionary/","text":"一、NSDictionary1.1 使用自定义对象 key Dictionaries manage pairs of keys and values. A key-value pair within a dictionary is called an entry. Each entry consists of one object that represents the key, and a second object which is that key’s value. Within a dictionary, the keys are unique—that is, no two keys in a single dictionary are equal (as determined by isEqual:). A key can be any object that adopts the NSCopying protocol and implements the hash and isEqual: methods. 字典管理着键值对。键是唯一的，同一个字典里面不会有相同的 key（由 isEqual: 确定），key 可以是遵守 NSCoping 协议并实现 hash 和 isEqual: 方法的任何对象。 1234- (instancetype)copyWithZone:(NSZone *)zone&#123; return self;&#125; 如果字典很少更改或大量更改，则应使用不可变的字典；否则使用可变字典。 Objects added as values to a dictionary are not copied (unless you pass YES as the argument to initWithDictionary:copyItems:). Rather, a strong reference to the object is added to the dictionary. 作为 value 添加到字典的对象不会被复制（除非调用 initWithDictionary:copyItems: 方法，并且参数传递 YES），而是将对对象的强引用添加到字典中。Copying Collections You can also add entries from another dictionary using the addEntriesFromDictionary: instance method. If both dictionaries contain the same key, the receiver’s previous value object for that key is released and the new object takes its place. 使用 addEntriesFromDictionary: 从一个已有的字典添加键值对时，相同 key 对应的 value 会被替换。 Keys must conform to the NSCopying protocol. Methods that add entries to dictionaries—whether as part of initialization (for all dictionaries) or during modification (for mutable dictionaries)— don’t add each key object to the dictionary directly. Instead, they copy each key argument and add the copy to the dictionary. After being copied into the dictionary, the dictionary-owned copies of the keys should not be modified. Keys must implement the hash and isEqual: methods because a dictionary uses a hash table to organize its storage and to quickly access contained objects. In addition, performance in a dictionary is heavily dependent on the hash function used. With a bad hash function, the decrease in performance can be severe. For more information on the hash and isEqual: methods see NSObject. 使用自定义对象 key 时，对象需要遵守 NSCoping 协议，存储数据时，字典会持有 key 的复制，复制到字典中后，不应修改字典拥有的键的副本。 键必须实现 hash 和 isEqual: 方法，因为字典使用哈希表来组织其存储并快速访问所包含的对象。此外，字典的性能在很大程度上取决于所使用的哈希函数。如果哈希函数不正确，性能下降可能会很严重。 注意：不要使用一个很大的对象作为 key，例如 NSImage 对象，这样会导致性能下降。 1.2 NSMapTableNSMapTable 允许针对特定情况（例如，当您需要高级内存管理选项时或想要保留特定类型的指针时）定制其他的存储选项。如图中的映射表配置为保存对其值对象的弱引用。 还可以指定是否要复制输入到数组中的对象。 The NSMapTable class also defines a number of convenience constructors for creating a map table with strong or weak references to its contents. For example, mapTableWithStrongToWeakObjects creates a map table that holds strong references to its keys and weak references to its values. These convenience constructors should only be used if you are storing objects. 使用 mapTableWithStrongToWeakObjects 可以强引用 key，弱引用 value。 为了能够使用任意的指针，请同时使用 NSPointerFunctionsOpaqueMemory 和 NSPointerFunctionsOpaquePersonality 值选项对其进行初始化。键和值的 options 不必相同。当使用映射表包含任意指针时，指针类型应该使用 c 语言的 void *。 12345678910NSPointerFunctionsOptions keyOptions = NSPointerFunctionsStrongMemory | NSPointerFunctionsObjectPersonality | NSPointerFunctionsCopyIn;NSPointerFunctionsOptions valueOptions = NSPointerFunctionsOpaqueMemory | NSPointerFunctionsOpaquePersonality; NSMapTable * mapTable = [NSMapTable mapTableWithKeyOptions:keyOptions valueOptions:valueOptions]; int i = 1;NSString * key = @\"Key\";NSMapInsert(mapTable, key, &amp;i);NSLog(@\"Key contains: %i\", *(int *) NSMapGet(mapTable, key)); 1.3 底层原理 Objective-C 中的字典 NSDictionary 底层其实是一个哈希表。 NSDictionary 使用 hash 表来实现 key 和 value 之间的映射和存储，hash 函数设计的好坏影响着数据的查找访问效率。数据在 hash 表中分布的越均匀，其访问效率越高。而在 Objective-C 中，通常都是利用 NSString 来作为键值，其内部使用的 hash 函数也是通过使用 NSString 对象作为键值来保证数据的各个节点在 hash 表中均匀分布。 字典每个条目存取是通过将字典的键(Key)计算出键的 hash 值，通过查 hash 表获取具体的 value。所以作为 NSDictionary 的键(Key)取值的时候，只要其 key 对象内容地址相同就可以取出相应的值。 二、数组2.1 NSPointArrayNSPointArray 类似 NSMutableArray，但它可以容纳 nil 值，同 count 值也包含 nil 的数量。它还允许你在定制特定的情况下设置额外的存储选项。 1234567891011NSPointerArray * arr = [NSPointerArray pointerArrayWithOptions:NSPointerFunctionsStrongMemory];[arr addPointer:nil];[arr addPointer:@\"sss\"];NSLog(@\"%lu\", arr.count);NSLog(@\"%@\", [arr pointerAtIndex:0]);NSLog(@\"%@\", [arr pointerAtIndex:1]); arr.count = 1;NSLog(@\"%@\", [arr pointerAtIndex:0]);NSLog(@\"%@\", [arr pointerAtIndex:1]); // 崩溃。-[NSConcretePointerArray pointerAtIndex:]: attempt to access pointer at index 1 beyond bounds 1' 当您想要使用弱引用的有序集合时，可以使用 NSPointerArray 对象。例如，假设您有一个包含一些对象的全局数组。因为从不收集全局对象，所以除非将其保持为弱状态，否则不能释放其所有内容。配置为弱保存对象的指针数组不拥有其内容。如果在此类指针数组中没有对对象的强引用，则可以释放这些对象。 为了使用任意的指针，可以同时使用 NSPointerFunctionsOpaqueMemory 和NSPointerFunctionsOpaquePersonality 选项对其进行初始化。 12345678NSPointerFunctionsOptions options = (NSPointerFunctionsOpaqueMemory | NSPointerFunctionsOpaquePersonality); NSPointerArray * ptrArray = [NSPointerArray pointerArrayWithOptions:options]; int i = 1;[ptrArray addPointer:&amp;i]; NSLog(@\" Index 0 contains: %i\", *(int *)[ptrArray pointerAtIndex:0]); 三、数据拷贝 The normal copy is a shallow copy that produces a new collection that shares ownership of the objects with the original. Deep copies create new objects from the originals and add those to the new collection. 通常情况是浅拷贝，它会生成一个新集合，该集合与原始对象共享对象的所有权。深拷贝从原始对象创建新对象，并将其添加到新集合中。 When you create a shallow copy, the objects in the original collection are sent a retain message and the pointers are copied to the new collection. 浅拷贝时，原始数据集合中的对象会发送 retain 消息，并将指针拷贝到新数据集合中。 You can use the collection’s equivalent of initWithArray:copyItems: with YES as the second parameter. If you create a deep copy of a collection in this way, each object in the collection is sent a copyWithZone: message. If the objects in the collection have adopted the NSCopying protocol, the objects are deeply copied to the new collection, which is then the sole owner of the copied objects. If the objects do not adopt the NSCopying protocol, attempting to copy them in such a way results in a runtime error. However, copyWithZone: produces a shallow copy. This kind of copy is only capable of producing a one-level-deep copy. 使用 copyItem:YES 方法时，会给集合中的每个对象发送 copyWithZone: 消息。如果对象实现了 NSCopying 协议，那么这些对象会被深拷贝到新的数据集合；如果没有实现协议，则会导致运行时错误。 然而 copyWithZone: 生成的是浅层的“深拷贝”，只是做了一层的深拷贝，如果数据是多层数组嵌套的话，则第二层、第三层…的数据没有进行深拷贝。 If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the NSCoding protocol. 如果想真正的深拷贝，只要内容全部符合 NSCoding 协议，则可以存档然后取消存档该集合。 12NSArray * trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData： [NSKeyedArchiver archivedDataWithRootObjectoldArray]]; 复制集合时，该集合或其包含的对象的可变性可能会受到影响。 copyWithZone: makes the surface level immutable. All deeper levels have the mutability they previously had. 第一层是可变的，其余深层还是以前的可变性。 initWithArray:copyItems: with NO as the second parameter gives the surface level the mutability of the class it is allocated as. All deeper levels have the mutability they previously had. 第一层保持分配时的可变性，其余深层还是以前的可变性 initWithArray:copyItems: with YES as the second parameter gives the surface level the mutability of the class it is allocated as. The next level is immutable, and all deeper levels have the mutability they previously had.Archiving and unarchiving the collection leaves the mutability of all levels as it was before. 第一层保持分配时的可变性，第二层是可变的，其余深层还是以前的可变性 四、文章Dictionaries: Collections of Keys and Values","tags":[]},{"title":"iOS开发安全","date":"2019-10-25T14:33:32.916Z","path":"2019/10/25/iOS/iOS安全/iOS开发安全/","text":"一、逆向分析通常来说分析有三种手段： 1.1 静态分析静态分析这一阶段主要会利用给各种工具，来帮助开发者分析目标软件，常用的工具有： Hopper IDA Keychain-Dumper Class-dump … 其中 IDA 是效果最好也是最贵的，代码还原度很高，基本上可以照着理清楚代码的逻辑了。 1.2 动态分析 动态分析是指在软件运行的过程中进行调试分析。 在 iOS 中 runtime 扮演了一个很重要的角色，我们在动态分析的过程中往往也是借助了 runtime 的强大能力来进行的，比如可以动态地更改代码的行为、可以获取到当前的视图层次等等。这一部分我们可以利用的工具有： Cycript Reveal LLDB … 1.3 网络分析流量分析是指利用像 Charles 这样的抓包分析工具，分析应用的流量信息，安全意识比较差的公司做的一些产品我们往往能从中得到一些敏感信息。 ​ 二、防护针对以上几点围绕着二进制安全、数据安全以及网络安全来讲述。 2.1 二进制安全攻击者会拿到我们的应用进行分析，然后可能会篡改我们的执行文件或者是资源文件，因此我们有必要采用一些手段来防止他们窥探以及对应用的行为进行修改： 防止调试器依附 通常黑客可能会通过 gdb 或者 lldb 来调试我们的应用以验证代码的行为，为后一步攻击做准备。而调试器之所以能够工作是因为 Ptrace 的存在，它为调试器提供了监控目标进程的机会。因此，通常情况下，我们在应用中禁用掉它。 越狱检测 当应用被安装在一台越狱后的设备之后，它所面临的安全风险就会相对来说大很多。而可能处于安全性的考虑，可能我们并不希望我们的应用运行在这样的环境下，因此我们可以通过一些检测来判断是否处在越狱的设备上。通常来说越狱设备上会安装 Cydia、MobileSubstrate 等。我们可以在代码中检测 Applications 下是否有相关应用存在，如果存在就可以给用户相应的提示并进行处理。 敏感字符串安全 编译之后的应用中对已经初始化的字符串依然是可见的，把应用丢到 IDA 或者 Hopper 中很容易就看到一些敏感字符串的值了。因此字符串的加密处理是很有必要的，比如我们可以用一些简单的加密算法加密特别敏感的字符串，这样初始化出来的字符串是一串不可读的问题，需要使用的时候再进行解密。 混淆 这一步主要是为了迷惑敌人的视线，提升分析难度。编译的时候可以通过脚本加入无意义的代码以及将正常的字符串替换为无意义的代码。但是这样的方式会给自己在维护的时候带来一定困难，比如你的代码通过混淆后发生了 crash，通过 dsym 符号表解析出来的崩溃信息也变得不可读了，还得对照混淆时候的映射表来查看，所以需要三思这个到底值不值得做。 除此之外，我们还可以混淆文件名。前几天想逆向看看滴滴的模块化是如何做的，无意发现了一张很有意思的图片，后缀表示是一个图片，但是实际上是个存有字符串的文件。我们可以用类似的方式伪装一些相对重要的文件。 敏感业务用更安全的语言 OC 是一门具有动态特性的语言，这给了攻击者很多机会去修改你原有代码的行为，甚至是加上新的代码。因此在核心部分可以使用更加安全的代码，比如我们可以使用 C 甚至汇编去写。往简单来说用 Swift 来写代码都比 OC 一定程度上来得安全。 自检 我们可以对二进制文件或者资源文件进行 md5，然后交给我们的 server 去比对是否来自一个合法的应用，这一定程度上也能够提供一些防护性。 2.2 数据安全我们的应用可能会在本地存储一系列的文件，包括用户数据，数据库文件，甚至在日益兴起的 Hybrid 开发或者是各种 Patch 方式中我们会下载的源码文件。我们应该尽可能地确保这些文件不会轻易被窃取到，即使窃取到了之后黑客也没办法使用。 数据保护 我们需要将类似用户密码这样的敏感数据存到 keychain 中。我们还会在本地存储多种类型的文件，其中可能会包含一些敏感信息。我们在使用的时候是可以设置其访问安全限制的。比如下面在使用FileManager 的时候使用 FileProtectionType.complete 用以保证文件只有在设备未被锁定时才可访问。同样在使用 Keychain 的时候也有类似的做法。 1try? FileManager.default.setAttributes([.protectionKey: FileProtectionType.complete], ofItemAtPath: \"your path \") 数据擦除 有些敏感数据我们希望用完就把它给干掉，不留一点痕迹。比如用户在输入密码进行登录的时候，我们的viewModel 上有一个叫做 password 的 property。登录完成之后，我们即使把这个属性置为空之后值都依然在内存当中，这个时候我们可能需要手动地把这些敏感内容给擦掉。 防止键盘缓存 键盘的自动更正机制会缓存用户的输入，如果在一台越狱设备上的话很可能被第三方应用轻易地读取到缓存中的数据。 简单来说我们可以把 UITextfield 的 autocorrectionType 属性设置为 NO 来关掉这个功能。在一些安全性要求较高的应用当中通常会自定义键盘，这样可以防止缓存被第三方应用读取到也能够防止被录屏（系统键盘按下有效果）。 2.3 网络安全 不传输明文 我们不应该在网络中明文传输敏感数据。否则即使在没越狱的手机上，很容易遭到中间人攻击，黑客可以轻而易举地获取到用户的敏感数据。 使用 https 苹果本来准备强制要求的，不知道为何搁浅了，重要性不言而喻。 使用更安全的协议 比如我们可以使用二进制协议或者是自定义协议来提高安全性。 Hybrid 应用安全 如今 React Native、Cordova 等应用得越来越广，安全性也变得越来越重要。 在这样的开发中，Mobile 扮演的角色就是一个浏览器，因此在前端开发中常用的防护手段也在此使用，比如 JS 代码混淆、XSS 防护、加密传输等。​ 2.4 非恶意攻击造成的安全问题以上大部分都是一些比较恶意的针对终端用户的攻击防护，还应该注意一些无意之间容易造成的安全问题。 应用退到后台 苹果会在应用退到后台的时候进行截屏，会将当户当前的状态截图保存下来，这可能会在无意之中造成用户数据的泄漏，因此我们可能需要主动地替换掉这张截图。 警惕 iCloud 备份 用户在开启 iCloud 的情况下，可能会自动对文件目录进行自动备份，我们需要指定包含敏感信息的文件不能进行备份。 注意 Touch ID 的变化 自从 iPhone 有 Touch ID 之后大大的方便了用户的使用，比如我们可以按一个手指就进行支付、登录等操作。我们在开发这样的业务逻辑的时候，应该考虑到这样的场景，会不会因为一些正常情况下手机借给朋友造成了信息或者财产的流逝。 防止类似 XcodeGhost 事件再次发生 早前发生的 XcodeGhost 事件掀起了一阵波澜，让我们意识到，即使是非越狱设备上也可能由于疏忽造成一些安全问题，因此我们需要警惕类似的事件再次发生。","tags":[]},{"title":"Autorelease","date":"2019-10-25T13:04:19.824Z","path":"2019/10/25/iOS/iOS原理/Autorelease/","text":"一、什么是自动释放池OC 中的一种内存自动回收机制，它可以延迟加入 AutoreleasePool 中的变量 release 的时机，即当我们创建了一个对象，并把它加入到了自动释放池中时，它不会立即被释放，会等到一次 runloop 结束或者作用域超出 {} 或者超出 [pool release] 之后再被释放。 二、自动释放池的创建与销毁时机 MRC： 1234567NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];Person * p = [[Person alloc] init];// 调 autorelease 方法将对象加入到自动释放池[person autorelease];// 手动释放自动释放池时，自动释放池会对加入池子中的对象做一次 release 操作[pool release]; 自动释放池销毁时机：[pool release] 代码执行完后。 ARC 12345@autoreleasepool &#123; // 在 &#123;&#125; 之内的变量默认被添加到自动释放池 Person * p = [[Person alloc] init];&#125;// 出了 &#123;&#125;，p 被释放 三、Autorelease实现原理12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 然后在终端中使用 clang -rewrite-objc main.m 命令将上述 OC 代码重写成 C++ 的实现。 12345int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 苹果通过声明一个 __AtAutoreleasePool 类型的局部变量，@autoreleasepool 被转换成 __AtAutoreleasePool 结构体类型 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 可以看到 __AtAutoreleasePool() 构造函数调用 objc_autoreleasePoolPush()，~__AtAutoreleasePool() 析构函数调用 objc_autoreleasePoolPop()。 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 是什么呢？ 在 NSObject.mm 文件中： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push(); &#125; void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt); &#125; 实际上是调用 AutoreleasePoolPage 的 push 和 pop 两个类方法。 class AutoreleasePoolPage { magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat; }; magic：用来校验 AutoreleasePoolPage 的结构是否完整； next：指向栈顶，也就是最新入栈的autorelease对象的下一个位置； thread：指向当前线程； parent：指向父节点 child：指向子节点 depth：表示链表的深度，也就是链表节点的个数 hiwat：表示high water mark（最高水位标记） 每一个 AutoreleasePoolPage 都是以双链表的形式连接起来的。 parent 指向前一个 page , child 指向下一个 page 3.1 push 一个 push 操作其实就是创建一个新的 autoreleasepool，对应 AutoreleasePoolPage 的具体实现就是往 AutoreleasePoolPage 中的 next 位置插入一个 POOL_SENTINEL，并且返回插入的 POOL_SENTINEL 的内存地址。 执行一个具体的插入操作时，分别对三种情况进行了不同的处理： 当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 next 指向的位置； 当前 page 存在且已满时，创建一个新的 page ，并将对象添加到新创建的 page 中； 当前 page 不存在时，即还没有 page 时，创建第一个 page ，并将对象添加到新创建的 page 中。 每调用一次 push 操作就会创建一个新的 AutoreleasePoolPage ，即往 AutoreleasePoolPage 中插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。 3.2 pop pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址即 pool token 。当执行 pop 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release 。直到 pool token 所在 page 的 next 指向 pool token 为止。 文章河西七夕 - ios 自动释放池","tags":[]},{"title":"","date":"2019-10-25T11:21:34.588Z","path":"2019/10/25/IT/LLVM/","text":"title: LLVMcategories: IT 一、什么是 LLVM？ The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. 简单来说，LLVM 项目是一系列分模块、可重用的编译工具链。它提供了一种代码编写良好的中间表示(IR)，可以作为多种语言的后端，还可以提供与变成语言无关的优化和针对多种 cpu 的代码生成功能。 先来看下LLVM架构的主要组成部分： 前端：前端用来获取源代码然后将它转变为某种中间表示，我们可以选择不同的编译器来作为LLVM的前端，如 gcc，clang。 Pass：通常翻译为“流程”，Pass 用来将程序的中间表示之间相互变换。一般情况下，Pass可以用来优化代码，这部分通常是我们关注的部分。 后端：后端用来生成实际的机器码。 虽然如今大多数编译器都采用的是这种架构，但是LLVM不同的就是对于不同的语言它都提供了同一种中间表示。 当编译器需要支持多种源代码和目标架构时，基于LLVM的架构，设计一门新的语言只需要去实现一个新的前端就行了，支持新的后端架构也只需要实现一个新的后端就行了。其它部分完成可以复用，就不用再重新设计一次了。 二、安装编译LLVM这里使用 clang 作为前端: 直接从官网下载：http://releases.llvm.org/download.html svn 获取 1234567svn co http://llvm.org/svn/llvm-project/llvm/trunk llvmcd llvm/toolssvn co http://llvm.org/svn/llvm-project/cfe/trunk clangcd ../projectssvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rtcd ../tools/clang/toolssvn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra git 获取 1234567$ git clone http://llvm.org/git/llvm.git$ cd llvm/tools$ git clone http://llvm.org/git/clang.git$ cd ../projects$ git clone http://llvm.org/git/compiler-rt.git$ cd ../tools/clang/tools$ git clone http://llvm.org/git/clang-tools-extra.git 最新的 LLVM 只支持 cmake 来编译了，首先安装 cmake。 1$ brew install cmake 编译 123$ mkdir build$ cmake /path/to/llvm/source$ cmake --build . 编译时间比较长，而且编译结果会生成 20G 左右的文件。编译完成后，就能在 build/bin/ 目录下面找到生成的工具了。 三、从源码到可执行文件我们在开发的时候的时候，如果想要生成一个可执行文件或应用，我们点击 run 就完事了，那么在点击 run 之后编译器背后又做了哪些事情呢？ 我们先来一个例子： 1234567891011121314#import &lt;Foundation/Foundation.h&gt;#define TEN 10int main()&#123; @autoreleasepool &#123; int numberOne = TEN; int numberTwo = 8; NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"]; int age = numberOne + numberTwo; NSLog(@\"Hello, %@, Age: %d\", name, age); &#125; return 0;&#125; 上面这个文件，我们可以通过命令行直接编译，然后链接： 12$ xcrun -sdk iphoneos clang -arch armv7 -F Foundation -fobjc-arc -c main.m -o main.o$ xcrun -sdk iphoneos clang main.o -arch armv7 -fobjc-arc -framework Foundation -o main 拷贝到手机运行： 123monkeyde-iPhone:/tmp root# ./main2016-12-19 17:16:34.654 main[2164:213100] Hello, AloneMonkey, Age: 18 下面继续深入剖析。 3.1 预处理 Preprocess这部分包括： macro 宏的展开 import/include 头文件的导入 #if 等处理。 可以通过执行以下命令，来告诉 clang 只执行到预处理这一步： 1$ clang -E main.m 执行完这个命令之后，我们会发现导入了很多的头文件内容。 可以看到上面的预处理已经把宏替换了，并且导入了头文件。但是这样的话会引入很多不会去改变的系统库比如 Foundation，所以有了 pch 预处理文件，可以在这里去引入一些通用的头文件。 后来 Xcode 新建的项目里面去掉了 pch 文件，引入了 moduels 的概念，把一些通用的库打成 modules 的形式，然后导入，默认会加上 -fmodules 参数。 1$ clang -E -fmodules main.m 这样的话，只需要 @import 一下就能导入对应库的 modules 模块了。 1234567891011@import Foundation; int main()&#123; @autoreleasepool &#123; int numberOne = 10; int numberTwo = 8; NSString* name = [[NSString alloc] initWithUTF8String:\"AloneMonkey\"]; int age = numberOne + numberTwo; NSLog(@\"Hello, %@, Age: %d\", name, age); &#125; return 0;&#125; 3.2 词法分析 Lexical Analysis在预处理之后，就要进行词法分析了，将预处理过的代码转化成一个个 Token，比如左括号、右括号、等于、字符串等等。 1$ clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 3.3 语法分析 Semantic Analysis根据当前语言的语法，验证语法是否正确，并将所有节点组合成抽象语法树(AST) 1clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 3.4 IR 代码生成 CodeGenCodeGen 负责将语法树从顶至下遍历，翻译成 LLVM IR，LLVM IR 是 Frontend 的输出，也是 LLVM Backerend 的输入，桥接前后端。 可以在中间代码层次去做一些优化工作，我们在 Xcode 的编译设置里面也可以设置优化级别 -O1，-O3，-Os。还可以去写一些自己的 Pass，这里需要解释一下什么是 Pass。 Pass 就是 LLVM 系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了 LLVM 整个系统的优化和转化。 1$ clang -S -fobjc-arc -emit-llvm main.m -o main.ll 3.5 生成字节码 LLVM Bitcode我们在 Xcode7 中默认生成 bitcode 就是这种的中间形式存在，开启了 bitcode，那么苹果后台拿到的就是这种中间代码，苹果可以对 bitcode 做一个进一步的优化，如果有新的后端架构，仍然可以用这份 bitcode 去生成。 1clang -emit-llvm -c main.m -o main.bc 3.6 生成相关汇编1clang -S -fobjc-arc main.m -o main.s 3.7 生成目标文件1clang -fmodules -c main.m -o main.o 3.8 生成可执行文件12clang main.o -o main./main 四、可以用 Clang 做什么？4.1 libclang 进行语法分析可以使用 libclang 里面提供的方法对源文件进行语法分析，分析它的语法树，遍历语法树上面的每一个节点。可以用于检查拼写错误，或者做字符串加密。 来看一段代码的使用： 12345678910111213141516171819202122232425262728293031323334void * hand = dlopen(\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib\",RTLD_LAZY); //初始化函数指针initlibfunclist(hand);CXIndex cxindex = myclang_createIndex(1, 1);const char *filename = \"/path/to/filename\";int index = 0;const char ** new_command = malloc(10240);NSMutableString *mus = [NSMutableString stringWithString:@\"/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch armv7 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk\"]; NSArray *arr = [mus componentsSeparatedByString:@\" \"];for (NSString *tmp in arr) &#123; new_command[index++] = [tmp UTF8String];&#125;nameArr = [[NSMutableArray alloc] initWithCapacity:10];TU = myclang_parseTranslationUnit(cxindex, filename, new_command, index, NULL, 0, myclang_defaultEditingTranslationUnitOptions());CXCursor rootCursor = myclang_getTranslationUnitCursor(TU);myclang_visitChildren(rootCursor, printVisitor, NULL);myclang_disposeTranslationUnit(TU);myclang_disposeIndex(cxindex);free(new_command);dlclose(hand); 然后我们就可以在 printVisitor 这个函数里面去遍历输入文件的语法树了。 我们也通过 python 去调用用 clang： 1$ pip install clang 那么基于语法树的分析，我们可以针对字符串做加密。 4.2 LibTooling对语法树有完全的控制权，可以作为一个单独的命令使用，如：clang-format 1$ clang-format main.m 我们也可以自己写一个这样的工具去遍历、访问、甚至修改语法树。 目录:llvm/tools/clang/tools 上面的代码通过遍历语法树，去修改里面的方法名和返回变量名： 123456789101112131415161718192021222324252627before:void do_math(int *x) &#123; *x += 5;&#125;int main(void) &#123; int result = -1, val = 4; do_math(&amp;val); return result;&#125;after:** Rewrote function def: do_math** Rewrote function call** Rewrote ReturnStmtFound 2 functions.void add5(int *x) &#123; *x += 5;&#125;int main(void) &#123; int result = -1, val = 4; add5(&amp;val); return val;&#125; 那么，我们看到 LibTooling 对代码的语法树有完全的控制，那么我们可以基于它去检查命名的规范，甚至做一个代码的转换，比如实现 OC 转 Swift。 4.3 ClangPlugin对语法树有完全的控制权，作为插件注入到编译流程中，可以影响 build 和决定编译过程。目录:llvm/tools/clang/examples 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include \"clang/Driver/Options.h\"#include \"clang/AST/AST.h\"#include \"clang/AST/ASTContext.h\"#include \"clang/AST/ASTConsumer.h\"#include \"clang/AST/RecursiveASTVisitor.h\"#include \"clang/Frontend/ASTConsumers.h\"#include \"clang/Frontend/FrontendActions.h\"#include \"clang/Frontend/CompilerInstance.h\"#include \"clang/Frontend/FrontendPluginRegistry.h\"#include \"clang/Rewrite/Core/Rewriter.h\"using namespace std;using namespace clang;using namespace llvm;Rewriter rewriter;int numFunctions = 0;class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; &#123;private: ASTContext *astContext; // used for getting additional AST infopublic: explicit ExampleVisitor(CompilerInstance *CI) : astContext(&amp;(CI-&gt;getASTContext())) // initialize private members &#123; rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts()); &#125; virtual bool VisitFunctionDecl(FunctionDecl *func) &#123; numFunctions++; string funcName = func-&gt;getNameInfo().getName().getAsString(); if (funcName == \"do_math\") &#123; rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), \"add5\"); errs() &lt;&lt; \"** Rewrote function def: \" &lt;&lt; funcName &lt;&lt; \"\\n\"; &#125; return true; &#125; virtual bool VisitStmt(Stmt *st) &#123; if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) &#123; rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, \"val\"); errs() &lt;&lt; \"** Rewrote ReturnStmt\\n\"; &#125; if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) &#123; rewriter.ReplaceText(call-&gt;getLocStart(), 7, \"add5\"); errs() &lt;&lt; \"** Rewrote function call\\n\"; &#125; return true; &#125;&#125;;class ExampleASTConsumer : public ASTConsumer &#123;private: ExampleVisitor *visitor; // doesn't have to be privatepublic: // override the constructor in order to pass CI explicit ExampleASTConsumer(CompilerInstance *CI): visitor(new ExampleVisitor(CI)) &#123; &#125; // initialize the visitor // override this to call our ExampleVisitor on the entire source file virtual void HandleTranslationUnit(ASTContext &amp;Context) &#123; /* we can use ASTContext to get the TranslationUnitDecl, which is a single Decl that collectively represents the entire source file */ visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl()); &#125;&#125;;class PluginExampleAction : public PluginASTAction &#123;protected: // this gets called by Clang when it invokes our Plugin // Note that unique pointer is used here. std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) &#123; return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI); &#125; // implement this function if you want to parse custom cmd-line args bool ParseArgs(const CompilerInstance &amp;CI, const vector&lt;string&gt; &amp;args) &#123; return true; &#125;&#125;;static FrontendPluginRegistry::Add&lt;PluginExampleAction&gt; X(\"-example-plugin\", \"simple Plugin example\"); 1234clang -Xclang -load -Xclang ../build/lib/PluginExample.dylib -Xclang -plugin -Xclang -example-plugin -c testPlugin.c** Rewrote function def: do_math** Rewrote function call** Rewrote ReturnStmt 我们可以基于 ClangPlugin 做些什么事情呢？我们可以用来定义一些编码规范，比如代码风格检查，命名检查等等。下面是我写的判断类名前两个字母是不是大写的例子，如果不是报错。(当然这只是一个例子而已。。。) 五、动手写 Pass5.1 一个简单的 Pass前面我们说到，Pass 就是 LLVM 系统转化和优化的工作的一个节点，当然我们也可以写一个这样的节点去做一些自己的优化工作或者其它的操作。下面我们来看一下一个简单 Pass 的编写流程： 创建头文件 1234$ cd llvm/include/llvm/Transforms/$ mkdir Obfuscation$ cd Obfuscation$ touch SimplePass.h 写入内容： 1234567891011121314#include \"llvm/IR/Function.h\"#include \"llvm/Pass.h\"#include \"llvm/Support/raw_ostream.h\"#include \"llvm/IR/Intrinsics.h\"#include \"llvm/IR/Instructions.h\"#include \"llvm/IR/LegacyPassManager.h\"#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"// Namespaceusing namespace std;namespace llvm &#123; Pass *createSimplePass(bool flag);&#125; 创建源文件 1234567$ cd llvm/lib/Transforms/$ mkdir Obfuscation$ cd Obfuscation$ touch CMakeLists.txt$ touch LLVMBuild.txt$ touch SimplePass.cpp CMakeLists.txt: 123456add_llvm_loadable_module(LLVMObfuscation SimplePass.cpp ) add_dependencies(LLVMObfuscation intrinsics_gen) LLVMBuild.txt: 12345[component_0]type = Libraryname = Obfuscationparent = Transformslibrary_name = Obfuscation SimplePass.cpp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include \"llvm/Transforms/Obfuscation/SimplePass.h\"using namespace llvm;namespace &#123; struct SimplePass : public FunctionPass &#123; static char ID; // Pass identification, replacement for typeid bool flag; SimplePass() : FunctionPass(ID) &#123;&#125; SimplePass(bool flag) : FunctionPass(ID) &#123; this-&gt;flag = flag; &#125; bool runOnFunction(Function &amp;F) override &#123; if(this-&gt;flag)&#123; Function *tmp = &amp;F; // 遍历函数中的所有基本块 for (Function::iterator bb = tmp-&gt;begin(); bb != tmp-&gt;end(); ++bb) &#123; // 遍历基本块中的每条指令 for (BasicBlock::iterator inst = bb-&gt;begin(); inst != bb-&gt;end(); ++inst) &#123; // 是否是add指令 if (inst-&gt;isBinaryOp()) &#123; if (inst-&gt;getOpcode() == Instruction::Add) &#123; ob_add(cast&lt;BinaryOperator&gt;(inst)); &#125; &#125; &#125; &#125; &#125; return false; &#125; // a+b === a-(-b) void ob_add(BinaryOperator *bo) &#123; BinaryOperator *op = NULL; if (bo-&gt;getOpcode() == Instruction::Add) &#123; // 生成 (－b) op = BinaryOperator::CreateNeg(bo-&gt;getOperand(1), \"\", bo); // 生成 a-(-b) op = BinaryOperator::Create(Instruction::Sub, bo-&gt;getOperand(0), op, \"\", bo); op-&gt;setHasNoSignedWrap(bo-&gt;hasNoSignedWrap()); op-&gt;setHasNoUnsignedWrap(bo-&gt;hasNoUnsignedWrap()); &#125; // 替换所有出现该指令的地方 bo-&gt;replaceAllUsesWith(op); &#125; &#125;;&#125; char SimplePass::ID = 0; // 注册pass 命令行选项显示为simplepassstatic RegisterPass&lt;SimplePass&gt; X(\"simplepass\", \"this is a Simple Pass\");Pass *llvm::createSimplePass() &#123; return new SimplePass(); &#125; 修改 `.../Transforms/LLVMBuild.txt`，加上刚刚写的模块 `Obfuscation` 1subdirectories = Coroutines IPO InstCombine Instrumentation Scalar Utils Vectorize ObjCARC Obfuscation 修改 `.../Transforms/CMakeLists.txt`，加上刚刚写的模块 `Obfuscation` 1add_subdirectory(Obfuscation) 编译生成：`LLVMSimplePass.dylib` 因为 Pass 是作用于中间代码，所以我们首先要生成一份中间代码： 1clang -emit-llvm -c test.c -o test.bc 然后加载 Pass 优化： 1../build/bin/opt -load ../build/lib/LLVMSimplePass.dylib -test &lt; test.bc &gt; after_test.bc 对比中间代码： 12llvm-dis test.bc -o test.llllvm-dis after_test.bc -o after_test.ll 12345678910111213141516171819test.ll......entry: %retval = alloca i32, align 4 %a = alloca i32, align 4 %b = alloca i32, align 4 %c = alloca i32, align 4 store i32 0, i32* %retval, align 4 store i32 3, i32* %a, align 4 store i32 4, i32* %b, align 4 %0 = load i32, i32* %a, align 4 %1 = load i32, i32* %b, align 4 %add = add nsw i32 %0, %1 store i32 %add, i32* %c, align 4 %2 = load i32, i32* %c, align 4 %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %2) ret i32 0&#125;...... 123456789101112131415161718192021after_test.ll......entry: %retval = alloca i32, align 4 %a = alloca i32, align 4 %b = alloca i32, align 4 %c = alloca i32, align 4 store i32 0, i32* %retval, align 4 store i32 3, i32* %a, align 4 store i32 4, i32* %b, align 4 %0 = load i32, i32* %a, align 4 %1 = load i32, i32* %b, align 4 %2 = sub i32 0, %1 %3 = sub nsw i32 %0, %2 %add = add nsw i32 %0, %1 store i32 %3, i32* %c, align 4 %4 = load i32, i32* %c, align 4 %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i32 0, i32 0), i32 %4) ret i32 0&#125;...... 这里写的 Pass 只是把 a+b 简单的替换成了 a-(-b)，只是一个演示，怎么去写自己的 Pass，并且作用于代码。 5.2 将 Pass 加入 PassManager 管理上面我们是单独去加载 Pass 动态库，这里我们将 Pass 加入 PassManager，这样我们就可以直接通过 clang 的参数去加载我们的 Pass 了。 首先在 llvm/lib/Transforms/IPO/PassManagerBuilder.cpp 添加头文件。 1#include \"llvm/Transforms/Obfuscation/SimplePass.h\" 然后添加如下语句： 12static cl::opt&lt;bool&gt; SimplePass(\"simplepass\", cl::init(false), cl::desc(\"Enable simple pass\")); 然后在 populateModulePassManager 这个函数中添加如下代码： 1MPM.add(createSimplePass(SimplePass)); 最后在 IPO 这个目录的 LLVMBuild.txt 中添加库的支持，否则在编译的时候会提示链接错误。具体内容如下： 1required_libraries = Analysis Core InstCombine IRReader Linker Object ProfileData Scalar Support TransformUtils Vectorize Obfuscation 修改 Pass 的 CMakeLists.txt 为静态库形式： 1234add_llvm_library(LLVMObfuscation SimplePass.cpp )add_dependencies(LLVMObfuscation intrinsics_gen) 最后再编译一次。 那么我们可以这么去调用： 1../build/bin/clang -mllvm -simplepass test.c -o after_test 基于 Pass，我们可以做什么？我们可以编写自己的 Pass 去混淆代码，以增加他人反编译的难度。 我们可以把代码左上角的样子，变成右下角的样子，甚至更加复杂~ 六、总结 LLVM 编译一个源文件的过程： 预处理 ↓ 词法分析 ↓ Token ↓ 语法分析 ↓ AST ↓ 代码生成 ↓ LLVM IR ↓ 优化 ↓ 生成汇编代码 ↓ Link ↓ 目标文件 基于LLVM，我们可以做什么？ 做语法树分析，实现语言转换：OC 转 Swift、JS or 其它语言 字符串加密 编写 ClangPlugin，命名规范，代码规范，扩展功能。 编写 Pass，代码混淆优化。 文章关于LLVM，这些东西你必须要知道","tags":[]},{"title":"clang","date":"2019-10-25T09:48:52.626Z","path":"2019/10/25/IT/Clang/","text":"一、编译器 为什么需要编译？ 计算机 CPU 只能读懂机器码（machine code，也就是由一堆 0 和 1 组成的编码），但程序员现在编写的代码并不是机器码，而是高级编程语言（Objective-C、Swift、Java、…），最终也可以被计算机所执行，这就需要编译了。在编译的过程中，编译器的作用便是把我们的高级编程语言通过一系列的操作转化成可被计算机执行的机器语言。 编译器是如何设计的？ 经典的三段式设计（three phase design）:前端(Frontend)-&gt;优化器(Optimizer)-&gt;后端(Backend) 前端负责分析源代码，可以检查语法级错误，并构建针对该语言的抽象语法树（AST） 抽象语法树可以进一步转换为优化，最终转为新的表示方式，然后再交给让优化器和后端处理 最终由后端生成可执行的机器码 为什么要使用三段式设计？优势在哪？ 首先解决了一个很大的问题：假如有 N 种语言（C、OC、C++、Swift…）的前端，同时也有 M 个架构（模拟器、arm64、x86…）的 Target，是否就需要 N × M 个编译器？ 三段式架构的价值就体现出来了，通过共享优化器的中转，很好的解决了这个问题。 假如你需要增加一种语言，只需要增加一种前端；假如你需要增加一种处理器架构，也只需要增加一种后端，而其他的地方都不需要改动。 编译源文件有哪些主要步骤？ 先列举一些整个编译过程的主要步骤，后面再详细介绍每个步骤都做了哪些事情。 主要编译步骤如下： 源代码（source code）↓预处理器（preprocessor）↓编译器（compiler）↓汇编程序（assembler）↓目标代码（object code）↓链接器（Linker）↓可执行文件（executables） 二、Xcode 编译器发展简史 Xcode 3 以前：GCC；Xcode 3：增加 LLVM，GCC(前端) + LLVM(后端)；Xcode 4.2：出现 Clang - LLVM 3.0 成为默认编译器；Xcode 4.6： LLVM 升级到 4.2 版本；Xcode 5： GCC 被废弃，新的编译器是 LLVM 5.0 为什么苹果的 Xcode 会使用 Clang+LLVM 取代 GCC？ GCC 是第三方开源的，不属于苹果维护也不能完全掌控其开发进程，Apple 为 Objective-C 增加许多新特性，但 GCC 开发者对这些支持却不友好；Apple 需要做模块化，GCC 开发者却拖着迟迟不实现。 随着 Apple 对其 IDE(也就是 Xcode)性能的要求越来越高，最终还是从零开发了一个 Clang 前端加 LLVM 后端的编译器，这个编译器的作者是大名鼎鼎的 Swift 之父 Chris Lattner。 Clang 比 GCC 优秀在哪些方面？ 传说新的 Clang 编译器编译 Objective-C 代码速度比 GCC 快 3 倍 提供了友好的代码提示 三、Clang 的简介 Clang: a C language family frontend for LLVM。LLVM 的 C 语言家族（C、C++、OC）前端。 上面是官网对于 Clang的一句话介绍，其实 Clang 就是上文所提到的编译器前端。 用途：输出代码对应的抽象语法树（Abstract Syntax Tree, AST），并将代码编译成 LLVM Bitcode。接着在后端（back-end）使用 LLVM 编译成平台相关的机器语言。 四、Clang 的编译过程4.1 预处理预处理顾名思义是预先处理。预处理的内容如下： import 头文件替换 在面向对象编程的思维下，写代码会经常用到其他类的属性或方法等，只需要导入头文件就可以用了，如： 12#import &lt;Foundation/Foundation.h&gt; // 这里将会在预处理时把 Foundation.h 文件的内容拷贝过来并替换 如果 A.h 文件引用 B.h，并且 B.h 也引用了 A.h，就会导致了循环引入。 解决办法是在头文件中使用 `@class A;` 代替 `#import &quot;A.h&quot;`。 这个意思是声明 A 是一个类，这样就可以使用 A 做类名，如果需要使用 A 的方法属性等，可以在 .m 实现文件中通过 `#import A.h` 的方式使用，这种方法不但可以解决互相引入的问题还可以优化编译速度。 macro 宏展开 无参宏。如： 1#define COUNT 3 * 带参宏。如： 1#define SUM(a, b) a + b 在宏定义的作用域内，输入了 COUNT、SUM()，在预处理过程中都会被替换。 处理其他的预编译指令 条件编译语句也是在预处理阶段完成，并且条件编译只允许编译源程序中满足条件的程序段，使生成的目标程序较短，从而减少了内存的开销并提高了程序的效率。如以下代码就只会保留一个 return 语句： 12345#if DEBUG return YES;#else return NO;#endif 简单来说，“#” 这个符号是编译器预处理的标志。 |预处理指令|说明||:——|:—–||#undef|取消已定义的宏||#if|如果给定条件为真，则编译以下代码||#ifdef|如果宏已经定义，则编译以下代码||#ifndef|如果宏没有定义，则编译以下代码||#elif|如果前面的 #if 的条件不为真，当前条件为真，则编译以下代码||#endif|结束一个 #if……#else 条件编译块| 4.2 Lexical Analysis - 词法分析（输出 token 流）词法分析其实是编译器开始工作真正意义上的第一个步骤，其所做的工作主要为将输入的代码转换为一系列符合特定语言的词法单元，这些词法单元类型包括了关键字、操作符、变量等等。 举个例子: Objective-C 语言包含了关键字 if、else、new 等，那么在词法分析步骤时，遇到 i与f 或 n与e与w 组合在一起的时候，需要将这几个字母组合为关键字 if 或 new 等词法单元。 词法分析，只需要将源代码以字符文本的形式转化成 Token 流的形式，不涉及校验语义，不需要递归，是线性的。 什么是 token 流？ 就是有“类型”，有“值”的一些小单元。 举个例子： 一个运算表达式：(28 + 78) * 2 只需要解析出 ( 是一个开括号，28 是数字整形，+ 是一个运算符号即可。 编译指令： $clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 里面的每一行都可以说是一个 token 流。一个表达式也会被逐个的解析。 4.3 Semantic Analysis - 语法分析（输出(AST)抽象语法树）编译指令：$clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 语法分析的最终产物是输出抽象语法树 语法分析在 Clang 中由 Parser 和 Sema 两个模块配合完成 校验语法是否正确 根据当前语言的语法，生成语意节点，并将所有节点组合成抽象语法树（AST） 这一步跟源码等价，可以反写出源码 Static Analysis 静态分析 通过语法树进行代码静态分析，找出非语法性错误 模拟代码执行路径，分析出 control-flow graph(CFG) 【MRC时代会分析出引用计数的错误】 预置了常用 Checker（检查器） 4.4 CodeGen - IR(Intermediate Representation)中间代码生成CodeGen 负责将语法树从顶至下遍历，翻译成 LLVM IR。 LLVM IR 是 Frontend 的输出，LLVM Backend 的输入，前后端的桥接语言 （Swift也是转成这个） 与 Objective-C Runtime 桥接 Class/Meta Class/Protocol/Category 内存结构生成，并存放在指定 section 中（如 Class：_DATA, _objc_classrefs） Method/lvar/Property 内存结构生成 组成 method_list/ivar_list/property_list 并填入 Class Non-Fragile ABI：为每个 Ivar 合成 OBJC_IVAR_$_ 偏移值常量 存取 Ivar 的语句（ivar = 123; int a = ivar;）转写成 base + OBJC_IVAR$_ 的形式 将语法树中的 ObjcMessageExpr 翻译成相应版本的 objc_msgSend，对 super 关键字的调用翻译成 objc_msgSendSuper 根据修饰符 strong/weak/copy/atomic 合成 @property 自动实现的 setter/getter 处理 @synthesize 生成 block_layout 的数据结构 变量的 capture(__block/__weak) 生成 _block_invoke 函数 ARC：分析对象引用关系，将 objc_storeStrong/objc_storeWeak 等 ARC 代码插入 将 ObjCAutoreleasePoolStmt 转译成 objc_autoreleasePoolPush/Pop 实现自动调用 [super dealloc] 为每个拥有 ivar 的 Class 合成 .cxx_destructor 方法来自动释放类的成员变量，代替 MRC 时代的“self.xxx = nil” 4.5 Optimize - 优化 IR递归优化成尾递归 4.6 LLVM Bitcode - 生成字节码4.7 Assemble - 生成 Target 相关汇编Assemble - 生成Target相关Object(Mach-O) 4.8 Link 生成 Executable五、问题 clang 编译错误: fatal error: ‘UIKit/UIKit.h’ file not found 1234fatal error: 'UIKit/UIKit.h' file not found#import &lt;UIKit/UIKit.h&gt; ^~~~~~~~~~~~~~~1 error generated. 解决 1： 1$ clang -rewrite-objc xx.m 替换成: 1$ clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk xx.m 这个命令很繁琐，可以采用 alias 来起一个别名来代替这个命令。 终端键入 $ vim ~/.bash_profile 编辑状态键入 $ alias rewriteoc=’clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk’ 键入完毕后, esc 退出编辑状态, 再键入 :wq 退出 vim 键入命令 source ~/.bash_profile 解决 2： 12345678# 模拟器$ xcrun -sdk iphonesimulator clang -rewrite-objc main.m# 真机$ xcrun -sdk iphoneos clang -rewrite-objc main.m# 带有版本的真机、模拟器$ xcrun -sdk iphonesimulator9.3 clang -rewrite-objc main.m 查看设备上都装哪些 SDK。 123456789101112131415161718192021222324$ xcodebuild -showsdks...iOS SDKs: iOS 12.1 -sdk iphoneos12.1iOS Simulator SDKs: Simulator - iOS 12.1 -sdk iphonesimulator12.1macOS SDKs: macOS 10.14 -sdk macosx10.14tvOS SDKs: tvOS 12.1 -sdk appletvos12.1tvOS Simulator SDKs: Simulator - tvOS 12.1 -sdk appletvsimulator12.1watchOS SDKs: watchOS 5.1 -sdk watchos5.1watchOS Simulator SDKs: Simulator - watchOS 5.1 -sdk watchsimulator5.1 六、Clang AttributesClang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 __attribute__(xxx) 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 NS_CLASS_AVAILABLE_IOS(9_0) 就是 __attribute__(availability(…)) 这个属性的简单写法。 objc_subclassing_restricted 使用这个属性可以定义一个 Final Class，不允许被继承。 123456__attribute__((objc_subclassing_restricted))@interface Eunuch : NSObject@end@interface Child : Eunuch // &lt;--- Compile Error@end objc_requires_super 标志子类继承这个方法时需要调用 super，否则给出编译警告 12345678910111213141516171819@interface Father : NSObject- (void)hailHydra __attribute__((objc_requires_super));@end@implementation Father- (void)hailHydra &#123; NSLog(@\"hail hydra!\");&#125;@end@interface Son : Father@end@implementation Son- (void)hailHydra &#123;&#125; // &lt;--- Warning missing [super hailHydra]@end objc_boxable Objective-C 中的 @(…) 语法糖可以将基本数据类型 box 成 NSNumber 对象，假如想 box 一个 struct 类型或是 union 类型成 NSValue 对象，可以使用这个属性： 123typedef struct __attribute__((objc_boxable)) &#123; CGFloat x, y, width, height;&#125; XXRect; 这样一来，XXRect 就具备被 box 的能力： 1234CGRect rect1 = &#123;1, 2, 3, 4&#125;;NSValue * value1 = @(rect1); // &lt;--- Compile ErrorXXRect rect2 = &#123;1, 2, 3, 4&#125;;NSValue * value2 = @(rect2); // √ constructor / destructor 顾名思义，构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load 和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行： 123456789101112131415__attribute__((constructor))static void beforeMain(void) &#123; NSLog(@\"beforeMain\");&#125;__attribute__((destructor))static void afterMain(void) &#123; NSLog(@\"afterMain\");&#125;int main(int argc, const char * argv[]) &#123; NSLog(@\"main\"); return 0;&#125;// Console:// \"beforeMain\" -&gt; \"main\" -&gt; \"afterMain\" constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。 所以 constructor 是一个干坏事的绝佳时机： 所有 Class 都已经加载完成 main 函数还未执行 无需像 +load 还得挂载在一个 Class 中 FDStackView 的 FDStackViewPatchEntry 方法便是使用的这个时机来实现偷天换日的伎俩。 PS：若有多个 constructor 且想控制优先级的话，可以写成 __attribute__((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。 enable_if 这个属性只能用在 C 函数上，可以用来实现参数的静态检查： 1234static void printValidAge(int age)__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, \"你丫火星人？\"))) &#123; printf(\"%d\", age);&#125; 它表示调用这个函数时必须满足 age &gt; 0 &amp;&amp; age &lt; 120 才被允许，于是乎： 123printValidAge(26); // √printValidAge(150); // &lt;--- Compile ErrorprintValidAge(-1); // &lt;--- Compile Error cleanup 声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit。 overloadable 用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型： 1234567891011121314__attribute__((overloadable)) void logAnything(id obj) &#123; NSLog(@\"%@\", obj);&#125;__attribute__((overloadable)) void logAnything(int number) &#123; NSLog(@\"%@\", @(number));&#125;__attribute__((overloadable)) void logAnything(CGRect rect) &#123; NSLog(@\"%@\", NSStringFromCGRect(rect));&#125;// TestslogAnything(@[@\"1\", @\"2\"]);logAnything(233);logAnything(CGRectMake(1, 2, 3, 4)); objc_runtime_name 用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个： 12345__attribute__((objc_runtime_name(\"SarkGay\")))@interface Sark : NSObject@endNSLog(@\"%@\", NSStringFromClass([Sark class])); // \"SarkGay\" 所有直接使用这个类名的地方都会被替换（唯一要注意的是这时用反射就不对了），最简单粗暴的用处就是去做个类名混淆： 123__attribute__((objc_runtime_name(\"40ea43d7629d01e4b8d6289a132482d0dd5df4fa\")))@interface SecretClass : NSObject@end 还能用数字开头，怕不怕 - -，假如写个脚本把每个类前加个随机生成的 objc\\_runtime\\_name，岂不是最最精简版的代码混淆就完成了。 它是我所了解的唯一一个对 objc 运行时类结构有影响的 attribute，通过编码类名可以在编译时注入一些信息，被带到运行时之后，再反解出来，这就相当于开设了一条秘密通道，打通了写码时和运行时。脑洞一下，假如把这个 attribute 定义成宏，以 annotation 的形式完成某些功能，比如： 123456// @singleton 包裹了 __attribute__((objc_runtime_name(...)))// 将类名改名成 \"SINGLETON_Sark_sharedInstance\"@singleton(Sark, sharedInstance)@interface Sark : NSObject+ (instancetype)sharedInstance;@end 在运行时用 \\_\\_attribute\\_\\_((constructor)) 获取入口时机，用 runtime 找到这个类，反解出 “sharedInstance” 这个 selector 信息，动态将 +alloc，-init 等方法替换，返回 +sharedInstance 单例。 unavailable 表明类不能被调用，编辑器会给出红色警告。 1+ (instancetype)new __attribute__((unavailable(\"Singleton2类只能初始化一次\"))); 七、文章Developer_Yancy - iOS底层探索(一) - 从零开始认识Clang与LLVMDeveloper_Yancy - iOS底层探索(二) - 从零开始认识Clang与LLVMhttp://clang.llvm.org/http://www.aosabook.org/en/llvm.htmlClangLLVMC预处理器The CompilerClang Attributes 黑魔法小记","tags":[]},{"title":"Xcode","date":"2019-10-24T01:06:24.338Z","path":"2019/10/24/iOS/iOS原理/Xcode/","text":"一、整行上下移动Xcode 自带的配置文件路径：/Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Versions/A/Resources/IDETextKeyBindingSet.plist，用文本编辑 IDETextKeyBindingSet.plist，并添加以下代码： 123456789101112131415&lt;key&gt;GDI Commands&lt;/key&gt;&lt;dict&gt; &lt;key&gt;GDI Duplicate Current Line&lt;/key&gt; &lt;string&gt;selectLine:, copy:, moveToEndOfLine:,insertNewline:, paste:, deleteBackward:&lt;/string&gt; &lt;key&gt;GDI Delete Current Line&lt;/key&gt; &lt;string&gt;moveToEndOfLine:, deleteToBeginningOfLine:,deleteBackward:,moveDown:,moveToEndOfLine:&lt;/string&gt; &lt;key&gt;GDI Move Current Line Up&lt;/key&gt; &lt;string&gt;selectLine:, cut:, moveUp:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt; &lt;key&gt;GDI Move Current Line Down&lt;/key&gt; &lt;string&gt;selectLine:, cut:, moveDown:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt; &lt;key&gt;GDI Insert Line Above&lt;/key&gt; &lt;string&gt;moveUp:, moveToEndOfLine:, insertNewline:&lt;/string&gt; &lt;key&gt;GDI Insert Line Below&lt;/key&gt; &lt;string&gt;moveToEndOfLine:, insertNewline:&lt;/string&gt; &lt;/dict&gt; 注意：Xcode.app 需要换成实际的应用名，如 Xcode10.1.app。详细文章：xcode 设置快捷键 整行上下移动## 二、Other linker flagsOther linker flags 用来填写 XCode 的链接器参数。从 C 代码到可执行文件经历的步骤是：&gt; 源代码 -&gt; 预处理器 -&gt; 编译器 -&gt; 汇编器 -&gt; 机器码 -&gt; 链接器 -> 可执行文件在最后一步需要把 .o 文件和 C 语言运行库链接起来，这时候需要用到 ld 命令。源文件经过一系列处理以后，会生成对应的 .obj 文件，然后一个项目必然会有许多 .obj 文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。Other linker flags 设置的值实际上就是 ld 命令执行时后面所加的参数。&gt; The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category.&gt;&gt; 运行时的异常是由于标准 XNIX 静态库、链接器与 OC 语言的动态的特性之间的问题，OC 语言并不是对每一个函数或者方法建立链接器符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不知道将核心类与分类之间的代码实现联系起来，这就导致最终的应用程序中的可执行文件缺失了分类中的代码，这样函数调用就失败了。常用参数：- －ObjC 链接器就会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中。 这样编译之后的 app 会变大，因为加载了很多不必要的文件而导致可执行文件变大。但是如果静态库中有类和 category 的话只有加入这个 flag 才行。但是 Objc 也不是万能的，当静态库中只有分类而没有类的时候，Objc 就失效了，这就需要使用 -all_load 或者 -force_load 了。 123456789101112131415161718@implementation MyStaticLib+ (void)test&#123; NSLog(@\"sssss\");&#125;@end@implementation MyStaticLib (Cate)/** * 重写方法 */+ (void)test&#123; NSLog(@\"哈哈哈\");&#125;@end 静态库中分类重写了方法，导入工程中，设置 -Objc 参数将打印：哈哈哈；不设置将打印：sssss。- －all_load 会让链接器把所有找到的目标文件都加载到可执行文件中，即使没有 objc 代码。但是这个参数也有一个弊端，假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到 ld: duplicate symbol 错误，因为不同的库文件里面可能会有相同的目标文件，有两种方法解决：1、用命令行进行拆包；2、使用 -force_load 参数。- -force_load 适用于 Xcode3.2+ 版本，它允许 finer 得到文档加载的控制，所做的事情跟 -all_load 其实是一样的，但是每一个 -force_load 操作必须跟着一个文档路径，文档中的每一个对象文件将会被加载，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。- -lstdc++ OC 和 C++ 混编时，在 Compile 阶段一切顺利，Clang 会根据后缀（.m .cpp）选择编译器进行编译，产物都是 Object File（.o 文件）。如果一个文件调用另一个文件的方法，编译出的 Object File 中会出现 undefined symbol 去代表这个方法。在链接阶段，Linker 通过把依赖的文件也加到最终的 executable 中 resolve undefined symbol。 Linker 没有主动的去 link stdc++ 库，解决方案 1：在 Other Linker Flags 中新增标志 -lstdc++；解决方案2：在 Linked Framework and Libraries 中添加 libstdc++.tbd。- 总结： 建议 -ObjC 与 -force_load 搭配使用比较好。 包含静态库时需要在 Target 的 Other linker flags 里面加上值：-objC、-all_load、-force_load 对于 64 位机器和 iPhone O S应用，解决方法是使用 -all_load 或者 -force_load。- 文章： Xcode 中 other linker flags 的作用 当我们在设置 Other Linker Flags -lstdc++时，我们到底在设置什么？## 三、Archive1. iOS App Store 保存到本地，准备上传 App Store 或者在越狱的 iOS 设备上使用，利用的是 Distribution 描述文件，关联 production 证书；2. Ad Hoc 保存到本地，准备在开发者账户下添加了 UDID 的设备上使用，利用的是 Distribution 描述文件，关联 production 证书； &gt; 官方解释：Ad Hoc 模式的包和将来发布到 App Store 的包在各种功能测试上是一样的，只要 Ad Hoc 模式下测试（推送、内购等）没有问题，发布到 App Store 也是没有问题的。3. Enterprise 主要针对企业级账户下准备本地服务器分发的 app。利用的是 Distribution 描述文件，关联 production 证书；4. Development 保存到本地，给添加了 UDID 的设备使用，开发者模式打包 ipa，通过 development 描述文件，关联 development 证书。 5. Rebuild from Bitcode 如果工程 Bitcode 为 NO，则不会有此选项。6. Strip Swift symbols 去除 swift 符号，勾选后会让 ipa 包内存小一些，对包进行了一个压缩。如果项目中未包含 swift 代码，则没有此选项。7. Include manifest for over-the-air installation 勾选后用户可以在 safari 中下载应用，而不必移步 App Store。8. Upload your app’s symbols to receive symbolicated reports from Apple 上传应用程序的符号以接收来自苹果的符号化报告。 9. 学习文章 Understanding and Analyzing Application Crash Reports## 四、armv7、armv7s、arm64#### 4.1 前言ARM 处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于 ARM，在嵌入式系统中应用广泛。armv6｜armv7｜armv7s｜arm64 都是 ARM 处理器的指令集，这些指令集都是向下兼容的，例如 armv7 指令集兼容 armv6，只是使用 armv6 的时候无法发挥出其性能，无法使用 armv7 的新特性，从而会导致程序执行效率没那么高。#### 4.2 介绍 armv7｜armv7s｜arm64 都是 ARM 处理器的指令集 i386｜x86_64 是 Mac 处理器的指令集|:————-:|:————-:|:—–:||arm64|iPhone6s | iphone6s plus | iPhone6 | iPhone6 plus | iPhone5S | iPad Air | iPad mini2 | 真机 64 位 ||armv7s|iPhone5 | iPhone5C | iPad4|真机 32 位||armv7|iPhone4|iPhone4S|iPad|iPad2|iPad3|iPad mini|iPod Touch 3G|iPod Touch4|真机 32 位||i386|针对 intel 通用微处理器 32 位处理器|模拟器 32 位||x86_64|是针对 x86 架构的 64 位处理器|模拟器 64 位|模拟器并不运行 arm 代码，软件会被编译成 x86 可以运行的指令。所以生成静态库时都是会先生成两个 .a，一个是 i386 的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个 .a 合并成一个。#### 4.3 Xcode 的指令集选项1. Architectures &gt; Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. 指定工程被编译成可支持哪些指令集类型。支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是 ipa 包会变大。2. Valid Architectures &gt; Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. 限制可能被支持的指令集的范围，也就是 Xcode 编译出来的二进制包类型最终从这些类型产生。而编译出哪种指令集的包，将由Architectures 与 Valid Architectures 的交集来确定。 ①、Valid Architectures 支持 arm 指令集版本设置为：armv7/armv7s/arm64，对应的 Architectures 支持 arm 指令集版本为：armv7s，这时 Xcode 只会生成一个 armv7s 指令集的二进制包。 ②、将 Architectures 支持 arm 指令集设置为：armv7/armv7s，对应的 Valid Architectures 的支持的指令集设置为：armv7s/arm64，那么此时，XCode 生成二进制包所支持的指令集只有 armv7s。3. Build Active Architecture Only 指定是否只对当前连接设备所支持的指令集编译。 debug 时设置成 YES 是为了编译速度更快，它只编译当前的 architecture 版本；而 release 时设置为 NO 会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如设置为 YES，用 iphone4 编译出来的是 armv7 版本的，iphone5 也可以运行，但是 armv6 的设备就不能运行。 所以，一般 debug 的时候可以选择设置为 YES，release 的时候要改为 NO，以适应不同设备。 如果你对 ipa 安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。 $(ARCHS_STANDARD) 默认值，以各版本实际的值为准。XCode5 中值为 armv7 armv7s，在 XCode5.1 时，强制加入了对 arm64 的编译，于是该值为 armv7,armv7s,arm64。当前 Xcode10.1 默认为 Standard architectures(armv7,arm64)。 $(ARCHS_STANDARD_32_BIT) Xcode5 和 5.1 都为 armv7,armv7s，旧一点的版本中应该对应的就只有 armv7。（待验证）* $(ARCHS_STANDARD_INCLUDING_64_BIT) XCode5 和 5.1 都为 armv7,armv7s,arm64使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有 32 位、64 位两份代码，在iPhone5s（64 位）下，会首选运行 64 位代码包。包含两种架构的代码包，只有运行在 iOS6、iOS7 系统上。而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有 32 位代码， iPhone5s 可以兼容 32 位代码，但是这会降低 iPhone5s 的性能。开启 arm64 支持后，不能开发 iOS 5.1.1 之前的版本，要强制将 deployment target 设置为 5.1.1 或之后。Xcode4.5 中移除了对 arm6 的支持。#### 4.4 查看 .a/framework 库支持的指令集通过 lipo 命令查看 .a 库所支持的指令集。12345678$ lipo -info AFNetworking$ lipo -info AFNetworking.framework/AFNetworkingNon-fat file: AFNetworking.framework/AFNetworking is architecture: x86_64$ lipo -info *.aArchitectures in the fat file: libPods-AFNetworking.a are: armv7 armv7sArchitectures in the fat file: libPods.a are: armv7 armv7s$ lipo -info libBloodTester.aArchitectures in the fat file: libBloodTester.a are: armv7 i386 x86_64 arm64#### 4.5 CocoaPods与Architecture出现问题 ld: library not found for -lAFNetworking，需要将 pods 的 Architectures 设置成与工程 targets 里的相同。#### 4.6 如何选择支持的指令集？如果你的软件对安装包大小非常敏感，你可以减少安装包中的指令集数据包，而且这能达到立竿见影的效果。很久前 xcode 支持的指令集是 armv7/armv7s，后来改成只支持 armv7 后，比原来小了 10MB 左右。目前 AppStore 上的一些知名应用，比如百度地图、腾讯地图通过反汇编工具查看后，也都只支持 armv7 指令集。（待验证） 根据向下兼容原则，armv7 指令集的应用是可以正常在支持 armv7s/arm64 指令集的机器上运行的。 五、Build Settings5.1 Generate Debug Symbols官方文档说明： Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the build ‘Level of Debug Symbols’ setting. 调试符号是在编译时生成的。在 Xcode 中查看构建过程，可以发现，当 Generate Debug Symbols 选项设置为 YES 时，每个源文件在编译成 .o 文件时，编译参数多了 -g 和 -gmodules 两项。但链接等其他的过程没有变化。 Clang 文档对 -g 的描述是： 1Generate complete debug info. 当 Generate Debug Symbols 设置为 YES 时，编译产生的 .o 文件会大一些，当然最终生成的可执行文件也大一些。 当 Generate Debug Symbols 设置为 NO 的时候，在 Xcode 中设置的断点不会中断。但是在程序中打印 [NSThread callStackSymbols]，依然可以看到类名和方法名，比如： 1** 0 Demo 0x00000001000667f4 -[ViewController viewDidLoad] + 100** 在程序崩溃时，也可以得到带有类名和方法名的函数调用栈。 5.2 Debug Information Level有两个选项：Compiler default、Line tables only。 官方文档的描述是： Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which can matter in some cases for large projects (such as when using LTO). 当把 Debug Information Level 设置为 Line tables only 的时候，然后构建 app，每个源文件在编译时，都多了一个编译参数：-gline-tables-only。 Clang的文档中这样解释 -gline-tables-only： Generate line number tables only.This kind of debug info allows to obtain stack traces with function names, file names and line numbers (by such tools as gdb or addr2line). It doesn’t contain any other data (e.g. description of local variables or function parameters). 这种类型的调试信息允许获得带有函数名、文件名和行号的函数调用栈，但是不包含其他数据（比如局部变量和函数参数）。 所以当 Debug Information Level 设置为 Line tables only 的时候，断点依然会中断，但是无法在调试器中查看局部变量的值。 5.3 Strip Linked Product当把这一设置选项改为 NO 的时候，最终构建生成的 app 大小没有任何变化。 原来，Strip Linked Product 也受到 Deployment Postprocessing 设置选项的影响。在 Build Settings 中可以看到，Strip Linked Product 是在 Deployment 这栏中的，而 Deployment Postprocessing 相当于是 Deployment 的总开关。 把 Deployment Postprocessing 设置为 YES，对比 Strip Linked Product 设为 YES 和 NO 的这两种情况，发现当 Strip Linked Product 设为 YES 的时候，app 的构建过程多了这样两步： 在 app 构建的开始，会生成一些 .hmap 辅助文件 在 app 构建的末尾，会执行 Strip 操作。 当 Strip Linked Product 设为 YES 的时候，运行 app，断点不会中断，在程序中打印 [NSThread callStackSymbols] 也无法看到类名和方法名： 1** 0 Demo 0x000000010001a7f4 XSQSymbolsDemo + 26612** 而在程序崩溃时，函数调用栈中也无法看到类名和方法名，注意右上角变成了 unnamed_function。 DEBUG 下设为 NO，RELEASE 下设为 YES，用于 RELEASE 模式下缩减 app 的大小。 5.4 Strip Style官方文档描述： Defines the level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target’s product type. [STRIP_STYLE] All Symbols - Completely strips the binary, removing the symbol table and relocation information. [all, -s]Non-Global Symbols - Strips non-global symbols, but saves external symbols. [non-global, -x]Debugging Symbols - Strips debugging symbols, but saves local and global symbols. [debugging, -S] 选择不同的 Strip Style 时，app 构建末尾的 Strip 操作会被带上对应的参数。 如果选择 debugging symbols 的话，函数调用栈中，类名和方法名还是可以看到的。 如果我们构建的不是一个 app，而是一个静态库，需要注意，静态库是不可以 strip all 的。这时构建会失败。想想符号在重定位时的作用，如果构建的静态库真的能剥离所有符号，那么它也就没法被链接了。 5.5 Strip Debug Symbols During Copy网上有很多文章，以为 Strip Debug Symbols During Copy 开启的时候，app 中的调试符号会被剥离掉。感觉他们混淆了 Strip Linked Product 和 Strip Debug Symbols During Copy 的用法。 文档上的描述是： Activating this setting causes binary files which are copied during the build (e.g., in a Copy Bundle Resources or Copy Files build phase) to be stripped of debugging symbols. It does not cause the linked product of a target to be stripped (use Strip Linked Product for that). Strip Debug Symbols During Copy 中的 During Copy 是什么意思呢？我觉得可能是 app 中引入的某些类型的库，在 app 的构建过程中需要被复制一次。虽然我暂时没找全究竟什么样的“库”需要在 app 构建时被复制，但是我发现，当 app 中包含 extension 或者 watch app 的时候，构建过程中会有 Copy 的步骤。 当将 app（而非 extension）的 Strip Debug Symbols During Copy 设置为 YES 之后，在这句 copy 的命令中会多出 -strip-debug-symbols 参数。 但是这里，strip 并不能成功，并且出现了 warning： 1warning: skipping copy phase strip, binary is code signed: /Users/xsq/Library/Developer/Xcode/DerivedData/XSQSymbolsDemo-cysszdsykroyyddkvvyffgboglvo/Build/Products/Debug-iphoneos/Today.appex/Today 这似乎是由于 app 中的 today extention 已经经过了 code sign，导致无法被篡改引起的警告。 那么如果略过 code sign 的过程，是否就能成功 strip 呢？我想使用模拟器调试可以略过 code sign过程，于是便在模拟器上试了试。果然这个 warning 消失了。 Strip Debug Symbols During Copy 设置为 YES 时，打开对应 .app 文件的“显式包内容”，可以看到，/PlugIns/Today.appex 文件的大小变小了。（不过这些只能在使用模拟器时奏效） Strip Debug Symbols During Copy 置为 YES 的时候，today extension 中的断点将不会中断，但是打印 [NSThread callStackSymbols] 时的类名和方法名还是可以看见的。 DEBUG 下设为 NO，RELEASE 下设为 YES。 5.6 Debug Information Format官方文档解释： This setting controls the format of debug information used by the developer tools. [DEBUG_INFORMATION_FORMAT] DWARF - Object files and linked products will use DWARF as the debug information format. [dwarf]DWARF with dSYM File - Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). [dwarf-with-dsym] 当 Debug Information Format 为 DWARF with dSYM File 的时候，构建过程中多了一步Generate dSYM File. 最终产出的文件也多了一个 dSYM 文件。 不过，既然这个设置叫做 Debug Information Format，所以首先得有调试信息。如果此时 Generate Debug Symbols 选择的是 NO 的话，是没法产出 dSYM 文件的。 dSYM 文件的生成，是在 Strip 等命令执行之前。所以无论 Strip Linked Product 是否开启，生成的 dSYM 文件都不会受影响。 不过正如文档中所说，无法为静态库生成 dSYM 文件。即便为给一个静态库的 Debug Information Format 设置为 DWARF with dSYM File，构建过程中依然不会有生成 dSYM 文件的步骤。 5.7 Dead Code Strippingyes - 确定 dead code（代码被定义但从未被调用）被剥离，去掉冗余的代码。 5.8 Optimization Level编译器优化级别。 比较早期的时候，硬件资源是比较缺乏的。为了提高性能，开发编译器的大师们，都会对编译器(从c到汇编的编译过程)加上一定的优化策略。优化后的代码效率比较高，但是可读性比较差，且编译时间更长。 优化是指编译器一级的措施，与机器指令比较接近，所以很可能会导致硬件不兼容，进而产生了你目前遇到的软件装不上的问题。 None：不优化。[-O0] 与此设置，编译器的目标是降低成本的编译和调试产生预期的结果。语句是独立的：如果你停止程序语句之间有一个断点,然后您可以指定一个新值的任何变量或任何其他声明改变程序计数器的功能和得到你期望的结果从源代码。 Fast：优化编译需要更多的时间，和更多的内存大的功能。[-O,O1] 与此设置，编译器试图减少代码大小和执行时间，没有执行任何优化,需要大量的编译时间。在苹果的编译器,严格的混叠,阻挡重新排序,并内嵌调度优化时默认是禁用的。 Faster：编译器执行几乎所有支持优化，不涉及 space-speed 权衡。[-O2]与此设置,编译器不执行循环展开或内联函数,或寄存器重命名。相比“快速”的设置,该设置增加编译时间和生成的代码的性能。 Fastest:打开“更快”指定的优化设置,也取决于函数内联和寄存器重命名选项。此设置可能会导致一个更大的二进制。 Fastest [-O3],最小的优化尺寸。这个设置允许所有“更快”的优化通常不增加代码大小。它还旨在减少代码的大小进行进一步的优化。 5.9 Symbols Hidden by Default会把所有符号都定义成”private extern”，设了后会减小体积。 5.10 Other C Flags -fembed-bitcode 让 framework 支持 bitcode。如果不进行以上操作。别人在集成你的 framework 时可以编译，亦可以真机测试。唯独在打包时会发出警告并打包失败：警告为 framework 不支持 bitcode！ 5.11 Other Warning Flags忽略整个工程中的指定类型的警告。例如填入 “-Wno-deprecated-declarations” 六、忽略警告1234567#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wdeprecated-declarations\"// 写在这个中间的代码，都不会被编译器提示 -Wdeprecated-declarations 类型的警告dispatch_queue_t currentQueue = dispatch_get_current_queue();#pragma clang diagnostic pop Xcode缩小ipa包大小及symbols设置等 七、@available、#availableSwift 2.0 中,引入了可用性的概念。对于函数、类、协议等，可以使用 @available 声明这些类型的生命周期依赖于特定的平台和操作系统版本。而 #available 用在判断语句中(if, guard, while等)，在不同的平台上做不同的逻辑。 1234@available(iOS 9, *) func myMethod() &#123; // do something &#125; iOS @available 和 #available 的用法Xcode 9.0中新增的API版本检查@available","tags":[]},{"title":"TCP连接与HTTP请求","date":"2019-10-24T01:06:24.306Z","path":"2019/10/24/计算机网络/TCP连接与HTTP请求/","text":"一道经典面试题： 从 URL 在浏览器被被输入到页面展现的过程中发生了什么？ 相信大多数准备过的同学都能回答出来，但是如果继续问：收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？ 一个 TCP 连接可以发多个 HTTP 请求？ 要搞懂这个问题，需要先解决下面五个问题： 现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 一个 TCP 连接可以对应几个 HTTP 请求？ 一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？ 为什么有的时候刷新页面不需要重新建立 SSL 连接？ 浏览器对同一 Host 建立 TCP 连接到数量有没有限制？ 一、现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是短时间内两次访问 https://www.github.com 的时间统计： 第一次访问，有初始化连接和 SSL 开销。 初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接。 持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。 所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。 二、一个 TCP 连接可以对应几个 HTTP 请求？了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。 三、一个 TCP 连接中 HTTP 请求发送可以一起发送吗？HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。 虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。 先来看一下 Pipelining 是什么，RFC 2616 中规定了： A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received. 一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。 至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。比如你向服务器发送了两个请求 GET/query?q=A 和 GET/query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。 Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题： 一些代理服务器不能正确的处理 HTTP Pipelining。 正确的流水线实现是复杂的。 Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。所以现代浏览器默认是不开启 HTTP Pipelining 的。 但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。 绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的 所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点： 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 四、为什么有的时候刷新页面不需要重新建立 SSL 连接？在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。 五、浏览器对同一 Host 建立 TCP 连接到数量有没有限制？假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。 所以答案是：有。Chrome 最多允许对同一个 Host 建立 6 个 TCP 连接。不同的浏览器有一些区别。 回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？ 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。 如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。 六、文章拖延症晚期 &amp; 一个 TCP 连接可以发多个 HTTP 请求？我竟然回答不上来…","tags":[]},{"title":"TCP/IP 协议","date":"2019-10-24T01:06:24.305Z","path":"2019/10/24/计算机网络/TCP:IP 协议/","text":"一、 计算机网络体系结构分层 不难看出，TCP/IP 与 OSI 在分层模块上稍有区别。 OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。 二、 TCP/IP 基础2.1 TCP/IP 的具体含义从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。 具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。 他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。 互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。 2.2 数据包 包、帧、数据包、段、消息 以上五个术语都是用来表述数据的单位，大致区分如下： 包可以说是全能性术语； 帧用于表示数据链路层中包的单位； 数据包是 IP 和 UDP 等网络层以上的分层中包的单位； 段则表示 TCP 数据流中的信息； 消息是指应用协议中数据的单位。 每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。 网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。 2.3 数据处理流程用户 a 向用户 b 发送邮件为例： 应用程序处理 首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能； 编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接，何时发送数据的管理功能，相当于 OSI 的会话层功能。 TCP 模块的处理 TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。 IP 模块的处理 IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。 网络接口（以太网驱动）的处理 从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。 网络接口（以太网驱动）的处理 主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。 IP 模块的处理 IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。 TCP 模块的处理 在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。 应用程序的处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。 三、传输层中的 TCP 和 UDPTCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。 TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。 UDP 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。 TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。 3.1 端口号数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。 根据端口号识别应用 一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。 通过 IP 地址、端口号、协议号进行通信识别 仅凭目标端口号识别某一个通信是远远不够的。 ① 和② 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。 ③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。 此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。 端口号的确定 标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。 时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。 端口号与协议 端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。 3.2 UDP UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。 此外，传输途中出现丢包，UDP 也不负责重发。 甚至当包的到达顺序出现乱序时也没有纠正的功能。 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。 UDP 常用于一下几个方面：1.包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。 3.3 TCP TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。 三次握手 TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。 下面来看看三次握手的流程图： 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。 四次挥手 四次挥手即终止 TCP 连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 下面来看看四次挥手的流程图： 中断连接端可以是客户端，也可以是服务器端。 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 LAST_ACK 状态。 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=N+1 后进入 TIME_WAIT 状态，如果 Server 端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。 上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况， 具体流程如下图： 通过序列号与确认应答提高可靠性 在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。 在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。 未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。 此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。 对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。 序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。 重发超时的确定 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。 TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。 在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。此外，数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。 以段为单位发送数据 在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。 TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。 MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。 利用窗口控制提高速度 TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。 为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示： 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。 滑动窗口控制 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。 窗口控制中的重发控制 在使用窗口控制中， 出现丢包一般分为两种情况： ①、确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图： ②、某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。 四、网络层中的 IP 协议 IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。 网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。 IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。 4.1 IP 地址 IP 地址概述 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。 IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下： IP 地址由网络和主机两部分标识组成 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。 IP 地址的分类 IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。 A 类 IP 地址是首位以 “0” 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。 B 类 IP 地址是前两位 “10” 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。 C 类 IP 地址是前三位为 “110” 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。 D 类 IP 地址是前四位为 “1110” 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。 广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。 IP 多播 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图： 多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。 子网掩码 现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。 对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下： &lt;center&gt; ![](http://dzliving.com/TCPIP_21.png) &lt;/center&gt; 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下： &lt;center&gt; ![](http://dzliving.com/TCPIP_22.png) &lt;/center&gt; 4.2 路由 发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。 IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。 IP 地址与路由控制 IP 地址的网络地址部分用于进行路由控制。 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。 4.3 IP 分包与组包 每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。 路径 MTU 发现 分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。 4.4 IPv6IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。 IPv6 的特点 IP 得知的扩大与路由控制表的聚合。 性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。 支持即插即用功能。即使没有DHCP服务器也可以实现自动分配 IP 地址。 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。 多播、Mobile IP 成为扩展功能。 IPv6 中 IP 地址的标记方法 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。 IPv6 地址的结构 IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。 全局单播地址 全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。太厉害了，终于有人能把TCP/IP 协议讲的明明白白了 链路本地单播地址 链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。 唯一本地地址 唯一本地地址是不进行互联网通信时所用的地址。 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。 L 通常被置为 1 全局 ID 的值随机决定 子网 ID 是指该域子网地址 接口 ID 即为接口的 ID IPv6 分段处理 IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。 IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。 IP 首部 4.5 IP 协议相关技术IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。 DNS 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。 ARP 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。 ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。 RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。 ICMP ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。 IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。 DHCP 如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。 DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。 NAT NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。 NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。 IP 隧道 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。 IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。 五、附录 六、文章技术往事：改变世界的 TCP/IP 协议涤生_Woo &amp; 一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）","tags":[]},{"title":"排序算法","date":"2019-10-24T01:06:24.304Z","path":"2019/10/24/算法/排序算法/","text":"一、冒泡排序1.1 简介冒泡排序是蛮力法在排序问题上的一个典型的应用场景。 对于一个给定长度为 n 的无序数组，由初始位置开始，比较数组相邻两个元素。如果是逆序排列的，就交换它们的位置，重复多次之后，最大数就“沉”到了数组最后的位置。第二次再从初始位置开始，将第二大的元素沉到倒数第二个位置。这样一直做 n-1 次，整个数组就是有序的了。 对于一个长度为 n 的数组，整个算法消耗的时间为：(n-1) + (n-2) + … + 1 = n(n-1)/2，那么它的时间复杂度为 O(n2)。同时，显而易见，整个算法只消耗一份数组的空间，所以空间复杂度为 O(1)。 另外，普及一下排序算法另一个重要的特性：稳定性。 所谓的稳定性，通俗地讲就是能保证两个相等的数在排序前后的顺序相同。 假定原数组有两个相同的元素 Ω，在数组的 a[i] 和 a[j] 位置。排序前 a[i] 在 a[j] 的前面，在排序之后，a[i] 仍然在 a[j] 的前面，那么就说这种排序方法具有稳定性。 冒泡排序是一种稳定排序。 蛮力法的应用有一个显著的特点，就是在经过适当的努力之后，可以对算法进行一定的改良，从而提高它的性能，但并不会减弱算法本身的时间复杂度。冒泡排序作为蛮力法的典型应用，自然也有这种特性。 1.2 改进 设定交换发生的标识位 对于待排序的数组，可以设定一个标志位，检查一次比较之后，是否有数据进行了交换，若是没有，那么整个数组就已经有序了，可以直接退出。极端情况下，如刚才提到的，对有序数组进行排序，只需要执行 n-1 次操作，就可以完成排序。 记录最后一次发生交换的位置 初始排序时，数组是在 [0, n] 区间遍历，那么下一轮的遍历是在 [0, n-1] 区间。 现在记录数组本轮遍历的最后一次交换发生在 lastSwapPos 位置，那么下一轮的遍历实际上是在 [0, lastSwapPos] 区间。 1.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142#define ARRAY_LENGTH 10void bubbleSort(int arr[])&#123; int lastSwapPos = ARRAY_LENGTH - 1; int lastSwapPosTemp = ARRAY_LENGTH - 1; int temp = 0; // ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; for (int j = 0; j &lt; ARRAY_LENGTH - i - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; // ② for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; lastSwapPos = lastSwapPosTemp; for (int j = 0; j &lt; lastSwapPos; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; lastSwapPosTemp = j; &#125; &#125; // 一次都未交换的情况 if (lastSwapPos == lastSwapPosTemp) &#123; break; &#125; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", arr[i]); &#125;&#125; 1.4 总结优点： 空间复杂度 T = O(1) 稳定排序 在排序过程中，整个数组趋向稳定 对于已经有序的数组，排序效率高 缺点： 效率低 交换次数多，交换效率低（每次交换只减少一组逆序对） 不能并发执行 二、选择排序2.1 简介选择排序是蛮力法的一种实际应用。 首先扫描整个数组，找到最小的元素，然后和第一个元素进行交换，如此一来就等同于将最小的元素放到它在有序表中最终的位置上。然后从第二个元素开始扫描整个表，找到剩余 n-1 个元素中最小的元素，与第二个元素交换位置。以此类推，在执行 n-1 遍之后，这个数组就自然有序了。（当然每次找最大的元素，与最后一个元素交换也是可行的） 选择排序有一个最明显的优于冒泡排序的：数据交换的次数。在完全逆序的情况下，冒泡排序需要最多的 n*(n-1)/2 次交换，而选择排序最多产生 n-1 次交换。 选择排序的时间复杂度是 O(n^2)，空间复杂度是 O(1)。 选择排序有一个很重要的特性——它是一种不稳定排序。假定一个数组：[5, 5, 6, 1, 8]，可以很清晰的发现，在选择排序结束之后，两个 5 并不能保持原来的顺序，第一个 5 在第四的位置，第二个 5 还在第二的位置。 2.2 改进每一次外循环的遍历，可以同时找到最小值（minIndex）和最大值（maxIndex），分别和头、尾两个元素进行交换。这样一来外循环只要执行原来一半的循环次数就可以了。 但是需要注意一点：每次循环要进行 2 次交换，第一次最小值交换结束之后，在进行最大值交换的时候要先判断最大值是不是在第一个位置，在第一次最小值交换的时候已经换到了后面。 如 [5, 4, 3, 2, 1] 第一次最小值交换后变成了 [1, 4, 3, 2, 5]，初始记录的 maxIndex = 0 就指向了 1，而不是 5。 2.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define ARRAY_LENGTH 10void selectSort(int arr[])&#123; // 数组内容合法性判断 int minIndex; int maxIndex; // 方式 ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; minIndex = i; for (int j = i; j &lt; ARRAY_LENGTH; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) &#123; swap(i, minIndex, arr); &#125; &#125; // 方式 ② for (int i = 0; i &lt; ARRAY_LENGTH / 2; i++) &#123; minIndex = i; maxIndex = i; for (int j = i; j &lt; ARRAY_LENGTH - i; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; if (arr[j] &gt; arr[maxIndex]) &#123; maxIndex = j; &#125; &#125; // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) &#123; swap(i, minIndex, arr); &#125; if (ARRAY_LENGTH - 1 - i != maxIndex) &#123; // 防止最大数在第一个，优先和最小数进行交换 swap(ARRAY_LENGTH - 1 - i, (i == maxIndex) ? minIndex : maxIndex, arr); &#125; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", arr[i]); &#125;&#125;void swap(int idx1, int idx2, int arr[]) &#123; int temp = arr[idx1]; arr[idx1] = array[idx2]; arr[idx2] = temp;&#125; 三、直接插入排序3.1 减治法（增量法） 减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。 增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。 减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。 很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式： 减去一个常量。（直接插入排序） 减去一个常量因子。（二分查找法） 减去的规模可变。（辗转相除法） 3.2 直接插入排序直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下： 对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。 考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n - 1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。 很显然，基于增量法的思想在解决这个问题上拥有更高的效率。 直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。 当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序） 直接插入排序的时间复杂度是 O(n2)，空间复杂度是 O(1)，同时也是稳定排序。 3.3 优化 设置哨兵位 仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。 不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：记录上一次插入的值和位置，与当前插入值比较。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。 二分查找法 优化直接插入排序的核心在于：快速定位当前数字待插入的位置。 在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。 这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会打破排序算法的稳定性，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？ 3.4 简单的性能比较 结论： 在某些特定场景下，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。 对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。 大规模数组，二分查找优化效率明显。 3.5 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define ARRAY_LENGTH 10void insertSort(int list[])&#123; // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int j = 0; int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置 // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位 for (j = i - 1; j &gt; -1 &amp;&amp; temp &lt; list[j]; j--) &#123; list[j + 1] = list[j]; &#125; list[j + 1] = temp; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", list[i]); &#125;&#125;// 根据上一次的位置，简化下一次定位static void optimized_1(int array[]) &#123; // 记录上一个插入值的位置和数值 int checkValue = array[0]; int checkIndex = 0; // 循环插入 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int cur = array[i]; int start = i - 1; int j = 0; // 根据上一个值，定位开始遍历的位置 if (cur &lt; checkValue) &#123; start = checkIndex; for (int j = i - 1; j &gt; start - 1; j--) &#123; array[j + 1] = array[j]; &#125; &#125; // 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的 // 循环判断 + 插入 for (j = start; j &gt; -1; j--) &#123; if (cur &lt; array[j]) &#123; array[j + 1] = array[j]; &#125; else &#123; break; &#125; &#125; array[j + 1] = cur; checkValue = cur; checkIndex = j + 1; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", array[i]); &#125;&#125; 四、希尔排序4.1 和直接插入排序的关系希尔排序 Shell sort 是直接插入排序的变种方式之一，更高效的改进版本。其基本思想如下： ①、记录按下标的一定增量分组，对每组进行直接插入排序。 ②、不断地缩小增量，对每组进行直接插入排序，直至增量为 1。 数组：a[33, 13, 44, 21, 88, 8, 17] 增量 d = 3 分组 [33, 21, 17]、[13, 88]、[44, 8] 排序结果：[17, 13, 8, 21, 88, 44, 33] 增量 d = 3/2 = 1 分组 [17, 13, 8, 21, 88, 44, 33] 排序结果：[8, 13, 17, 21, 33, 44, 88] 由上可知，希尔排序本质就是多次使用直接插入排序。其优于直接插入排序的原因在之前也提到过，就是：直接插入排序对于基本有序的数组，拥有较高的性能。 希尔排序的时间复杂度是 O(n2)（只是针对最坏情况而言，平均的效率要远远高出其他时间复杂度为 O(n2) 的排序算法），空间复杂度是 O(1)。 希尔排序在提供优秀性能的同时，打破了排序算法的稳定性。 4.2 希尔排序的实现希尔排序，又称为缩小增量排序，其重点显然在于初始增量 d 的选取，以及每次增量 d 缩小的额度。一般来说，初始增量设为数组长度的一半，同时每次增量减半，直至 d = 1，可以满足大多数的需求。 4.3 优化1、设置哨兵位优化各分组的直接插入排序 2、二分查找法优化各分组的直接插入排序 4.4 简单的性能比较 结论： 直接插入排序的优化手段，对希尔排序没有作用，反而是一种伤害。原因是直接插入排序的优化手段对于小规模的数组是有害的，而希尔排序的原理是将整个数组拆成若干个小数组，利用直接插入排序对基本有序的数组拥有良好的性能这一特性出发的。 同样是不稳定排序，对比直接插入排序的二分查找优化，无论数组规模的大小，希尔排序在性能上都有明显的优势。 五、堆排序堆排序 Heap Sort，是指将整个数组转化成 “堆” 这种数据结构，利用堆的性质，去简化排序的过程。堆排序，可以看做是“变治法”的一种实现。 From Wikipedia：https://en.wikipedia.org/wiki/Heapsort 5.1 堆堆是一个可以被看做一棵树的数组对象，但是堆总是需要满足以下两条性质： ①、堆是一棵完全二叉树。树的每一层都是满的，除了最后一层最右边的元素有可能出现缺位。 ②、父母优势。即堆中的所有子节点，总是不大于或不小于其父节点的值。 根据子节点与父节点的关系，可以将堆分为最大堆（大的值在上）和最小堆（小的值在上）两种情况。 5.2 堆的数组表现形式数组 [9, 7, 3, 5, 1, 2, 6, 0, 8, 4] 按照顺序逐层放置可以转化为以下二叉树结构。（目前不具备堆的性质） 5.3 堆的性质1、获取堆中某个节点的左节点、右节点、父节点 1234567891011121314- (int)leftNode:(int)node&#123; return (node &lt;&lt; 1) + 1; // 0 &lt;&lt; 1 = 0&#125;- (int)rightNode:(int)node&#123; return (node &lt;&lt; 1) + 2;&#125;- (int)parentNode:(int)node&#123; return (node - 1) &gt;&gt; 1;&#125; ①、把完全二叉树每层的节点个数看成二进制 1、2、4、8… ②、当前节点在层 n（从 0 开始）的位置为 m（从 0 开始），那么节点在数组的位置为 index = 2(n - 1) + 2(n - 2) + … + 20 + m 左边子节点就是 2n + 2(n - 1) + … + 20 + m 2 + 1 = index 2 + 1右边子节点就是 2n + 2(n - 1) + … + 20 + m 2 + 2 = index 2 + 2 2、保持最大堆/最小堆的性质 当二叉树中的某个子节点，其左子树和右子树都具备堆的性质，那么可以通过一系列的交换，将以该子节点为根节点的树，转化为堆的结构。 123456789101112131415161718192021222324252627/** * @param array 待排序数组 * @param node 当前节点 * @param lastNode 最后一个节点 */- (void)maxHeapSort:(NSMutableArray *)array node:(int)node lastNode:(int)lastNode&#123; int lNode = [self leftNode:node]; // 左子节点 int rNode = [self rightNode:node]; // 右子节点 int largestNode = node; // 最大值节点。初始为当前节点 // 如果左子节点没有超出范围 &amp;&amp; 左子节点数值比 largestNode 的大 if (lNode &lt;= lastNode &amp;&amp; [array[lNode] integerValue] &gt; [array[largestNode] integerValue]) &#123; largestNode = lNode; &#125; // 如果右子节点没有超出范围 &amp;&amp; 右子节点数值比 largestNode 的大 if (rNode &lt;= lastNode &amp;&amp; [array[rNode] integerValue] &gt; [array[largestNode] integerValue]) &#123; largestNode = rNode; &#125; // 如果当前节点不是最大值，发生交换 if (node != largestNode) &#123; [array exchangeObjectAtIndex:node withObjectAtIndex:largestNode]; [self maxHeapSort:array node:largestNode lastNode:lastNode]; &#125;&#125; 3、构造最大堆/最小堆 将一个不具备堆性质的数组，转化为堆的结构，一般都是自底向上开始的。 自二叉树的第一个非叶节点开始，自底向上，依次保持二叉树的堆的性质，直至根节点。 123456NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; for (int i = lastNonLeaf; i &gt; -1; --i) &#123; [self maxHeapSort:arr node:i lastNode:arr.count - 1];&#125; 5.4 堆排序①、将原数组转化为堆的形式。升序排列使用最大堆，降序排列使用最小堆。 ②、将数组最后一位与第一位交换，因为是最大堆的关系，第一位数字就是最大值，落在了最后一位上。 ③、剔除最后一位数字，将数组剩余部分，看作一颗新的二叉树。其中根节点的左子树和右子树都满足最大堆的性质，保持这棵新二叉树的最大堆性质。这里是通过自顶向下的方式直到最后一个叶子节点调整二叉树。 ④、循环 ②、③，直至根节点，整个数组即自然有序。 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; // 从第一个非叶子节点开始构造，即最后一个叶子节点的父节点。 // 数组 -&gt; 堆 -&gt; 最大堆 for (int i = lastNonLeaf; i &gt; -1; --i) &#123; [self maxHeapSort:arr node:i lastNode:(int)arr.count - 1];&#125;// 最大堆 -&gt; 第一个与最后一个交换for (int i = (int)arr.count - 1; i &gt; 0; --i) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:0]; [self maxHeapSort:arr node:0 lastNode:i - 1];&#125; 5.5 变治法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#define num 10int temp;void Description(int *a)&#123; for(int i = 0; i &lt; num; i++) &#123; printf(\"%d \", a[i]); &#125; printf(\"\\n\");&#125;/** * @brief 筛选算法。用于维护堆，保持最大堆的性质 * @param a 数组 * @param k 调整的结点 * @param n 堆的大小 */void MaxHeapify(int *a, int k, int n)&#123; int i = k, j; j = 2 * i + 1; // 置 i 为要筛的结点，j 为 i 的左孩子 while(j &lt; n) &#123; // j + 1 &lt; n 用于判断 i 是否有右孩子。a[j] &lt; a[j+1] 用于比较左右孩子的大小 if (j + 1 &lt; n &amp;&amp; a[j] &lt; a[j+1]) j++; if(a[i] &gt; a[j]) &#123; // i 节点大于左右孩子中的最大者 break; &#125; else &#123; temp = a[i]; a[i] = a[j]; a[j] = temp; i = j; j = 2 * i + 1; &#125; &#125;&#125;void HeapSort(int *a)&#123; int i; // 每建立一次堆，只能确定根节点是最大值，其他节点并没有按序排好，所以后面有重复建堆的过程，但是需要建堆的区间慢慢变少了 for(i = (num - 1)/2; i &gt;= 0; i--) &#123; MaxHeapify(a, i, num); // 初始建堆，其中一开始 i 表示的是最后一个元素的父节点 Description(a); &#125; printf(\"\\n\"); // 重复执行移走堆项及重建堆的操作 for (i = 1; i &lt; num; i++) &#123; // i 表示当前堆的大小，即等待排序的元素的个数 temp = a[0]; a[0] = a[num - i]; a[num - i] = temp; MaxHeapify(a, 0, num - i); //从根节点处继续调整建堆，0 ... n-i 是无序区 Description(a); &#125;&#125;int main()&#123; int a[num] = &#123;0, 1, 3, 5, 7, 9, 8, 6, 4, 2&#125;; HeapSort(a); Description(a); return 0;&#125;0 1 3 5 7 9 8 6 4 2 0 1 3 6 7 9 8 5 4 2 0 1 9 6 7 3 8 5 4 2 0 7 9 6 2 3 8 5 4 1 9 7 8 6 2 3 0 5 4 1 8 7 3 6 2 1 0 5 4 9 7 6 3 5 2 1 0 4 8 9 6 5 3 4 2 1 0 7 8 9 5 4 3 0 2 1 6 7 8 9 4 2 3 0 1 5 6 7 8 9 3 2 1 0 4 5 6 7 8 9 2 0 1 3 4 5 6 7 8 9 1 0 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 5.6 堆排序的时间复杂度堆排序由两部分组成： 构建最大堆 循环保持最大堆的性质 1、构建最大堆的时间复杂度 T = O(n) 构建最大堆的过程，是从第一个非叶节点开始的，即数组的 1/2 处。 考虑最坏情况： 二叉树的倒数第二行，总会与最后一行发生一次比较/交换。 二叉树的倒数第三行，总会与倒数第二行发生一次比较/交换，与最后一行发生一次比较/交换。 … 二叉树的第一行，总会与它下面的每一行都发生一次比较/交换，即交换次数为二叉树高度 d = log2n。 将这些比较/交换次数累加： 2、循环保持最大堆的性质的时间复杂度 T = O(n * log2n) 这一步的时间计算就相对比较明显了，在 n 次循环的内部，进行时间复杂度为 O(log2n) 的 maxHeapSort()。 所以总时间复杂度 T = O(n) + O(nlog2n) =O(nlog2n) 六、归并排序归并排序 Merge Sort，又称为二路归并排序，是指将一个数组一分为二，对每一个子数组递归排序，最后将排好的子数组合并为一个有序数组的过程。 归并排序，是 “分治法” 应用的完美实现。 From Wikipedia: https://en.wikipedia.org/wiki/Merge_sort 6.1 图示 6.2 流程通过图示可以发现归并排序一共只需要两个步骤： 分：将原数组分为 n 个子数组，每个子数组长度为 1。 合：依次将两个相邻的有序数组，合并成一个有序数组，重复操作直至剩下一个有序数组。 6.3 代码实现1、分成两个子数组，左右递归 123456789101112- (void)sort:(NSMutableArray *)arr left:(NSInteger)left right:(NSInteger)right&#123; if (left &lt; right) &#123; NSInteger mid = (left + right) &gt;&gt; 1; // ÷ 2 [self sort:arr left:left right:mid]; [self sort:arr left:(mid + 1) right:right]; // 将分开的两部分子数组合并 [self merge:arr left:left mid:mid right:right]; &#125;&#125; 2、合并两个有序数组，此时处理新数组的排序 123456789101112131415161718192021222324252627/** * @brief 合并 */- (void)merge:(NSMutableArray *)arr left:(NSInteger)left mid:(NSInteger)mid right:(NSInteger)right&#123; // 注意新数组的长度 NSMutableArray * newArr = [NSMutableArray arrayWithCapacity:right - left + 1]; NSInteger startIndex1 = left; NSInteger startIndex2 = mid + 1; for (int i = 0; i &lt; right - left + 1; ++i) &#123; // 左侧数组检索完毕 if (startIndex1 == mid + 1) &#123; newArr[i] = arr[startIndex2++]; &#125; // 右侧数组检索完毕 else if (startIndex2 == right + 1) &#123; newArr[i] = arr[startIndex1++]; &#125; else &#123; // 使用两个指针记录数组位置，依次比较指针位置的数字，将较小的数字放入新数组。这样可以在线性的时间内完成合并工作。 newArr[i] = [arr[startIndex1] integerValue] &lt; [arr[startIndex2] integerValue] ? arr[startIndex1++] : arr[startIndex2++]; &#125; &#125; [arr replaceObjectsInRange:NSMakeRange(left, newArr.count) withObjectsFromArray:newArr];&#125; 3、相似的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define max 1024int SR[max], TR[max];/** * @param SR 两个有序序列构成的序列 * @param TR 一个空数组，用来存放排序好之后的数字 * @param left 起始位置 * @param mid 两个序列的分解位置 * @param right 结束位置 */int merge(int SR[], int TR[], int left, int mid, int right)&#123; int i = left, j = mid + 1, k = left; // k 是 TR 当前存入数字的下标 while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(SR[i] &lt; SR[j]) &#123; TR[k++] = SR[i++]; &#125; else &#123; TR[k++] = SR[j++]; &#125; &#125; while(i &lt;= mid) &#123; TR[k++] = SR[i++]; // 当前面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 &#125; while(j &lt;= right) &#123; TR[k++] = SR[j++]; // 当后面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 &#125; return 0;&#125;void copy(int SR[], int TR[], int s, int t)&#123; for(int i = s; i &lt;= t; i++) &#123; SR[i] = TR[i]; // TR -》 SR，相当于 TR 所在的区间有序 &#125;&#125;int mergesort2(int SR[], int left, int right)&#123; if(left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; mergesort2(SR, left, mid); // 前一半序列继续进行归并排序 mergesort2(SR, mid+1, right); // 后一半序列同时进行归并排序 // 以上递归调用的结束条件是 left ≥ right，也就是分到只有一个数字进行归并排序的时候，一个序列只有一个数字，那么这个序列肯定是有序的 // 以上都是属于“分”的阶段，目的是获得两个有序的数列。 merge(SR, TR, left, mid, right); // 对这两个有序的数列，进行排序，变成一个同样大小但是有序的数列 copy(SR, TR, left, right); //将在TR中排序好的数列给SR，方便SR递归调用归并排序，因为每次两个归并排序的结果都是保存在TR中的，现在要进行下一步就必须在TR数列的基础上面=进行，所以我们把TR给SR &#125; else &#123; ; &#125; return 0;&#125;int main()&#123; int n = 10; int i = 0; for(; i &lt; n; i++) &#123; SR[i] = arc4random() % 100 + 1; printf(\"%d \", SR[i]); &#125; printf(\"\\n\"); mergesort2(SR, 0, n-1); // 升序排列 for(i = 0; i &lt; n; i++) &#123; printf(\"%d \",SR[i]); &#125; printf(\"\\n\"); return 0;&#125; 6.4 时间复杂度和空间复杂度显而易见，递归的次数为 m = log2n，合并操作的时间消耗是线性的，所以时间复杂度 T(n) 如下： 空间复杂度为 O(n)。 6.5 空间复杂度为 O(1) 的归并排序因为两个子数组已经有序，合并的步骤可以采取直接插入排序。 如此一来，可以将空间复杂度由 O(n) 降低至 O(1)，然而相对的时间复杂度则由 O(nlog2n) 升至 O(n2)。 6.6 性能分析及优化两种归并排序的算法，分别是采取了空间换时间，以及时间换空间的策略，性能各有优劣，但是通过分析可以得出以下特点： 计算机对于频繁开辟小数组空间的消耗，比开辟等价大的单个数组空间，代价要来的更大。 使用直接插入排序（从 1/2 处开始），由于拥有较小的最高次幂系数，其性能在长度 n 较小的时候，与 T(n) = O(log2n) 相差不大。 根据以上两个性质，可以在归并排序中，设置一个阈值。超过这个给定的阈值，则采取空间换时间的策略；反之，采用时间换空间的策略，从而提高归并排序的效率。 七、快速排序7.1 简介快速排序 Quick Sort，有时又称划分-交换排序（Partition-Exchange Sort）。 快速排序的主要思想是：选取一个数字，通过一次遍历，将这个数字放到其最终的位置，并且保证其最终位置的左侧都小于等于这个数字，其右侧都大于等于这个数字。 与归并排序相同，是“分治法”的又一个实现案例。快速排序中分治的思想体现在哪里呢？ ①、把大问题分解成很多子问题（分区操作可以每次使得一位元素有序） ②、解决子问题（进行分区操作，每次使得一位元素有序） ③、所有子问题解决了，那么最大的问题也解决了。 一个优秀的快速排序实现，能比其竞争对手（归并排序、堆排序，都是时间复杂度为 O(nlog2n) 的排序算法），快 2-3 倍。 From Wikipedia: https://en.wikipedia.org/wiki/Quicksort 7.2 快速排序的具体步骤快速排序的过程可以拆分成以下三个步骤： 从数组中选择一个数字。 根据这个数字，对整个数组进行一次划分，即：通过一系列的交换，将这个数字放到其最终位置，并且保证其左侧的数字都小于等于它，右侧的数字都大于等于它。 对两侧的子数组进行递归。 7.3 快速排序的基本代码12345678910111213int partition(int array[], int left, int right)&#123; // ...&#125;void sort(int array[], int left, int right)&#123; if (left &lt; right) &#123; int q = partition(array, left, right); sort(array, left, q - 1); sort(array, q + 1, right); &#125;&#125; 7.4 划分 - 挖坑取数快速排序的核心内容：如何对一个数组进行一次划分（partition）。 这里先介绍一种常见的划分算法，我（原作者Gerrard_Feng）称之为“挖坑取数”，具体过程如下： 将最左侧的数字作为待划分的数字，在快速排序中，称这个数字是划分的主元（pivot）。 从最右侧开始向前寻找，找到第一个比 pivot 小的数字（坑），交换 pivot。 此时“坑”的位置被交换到了最左侧，从最左侧的下一个位置开始向后寻找，找到第一个比 pivot 大的数字，交换 pivot。 循环从两侧“夹逼”找“坑”的步骤，直至 pivot 到它的最终位置。 123456789101112131415161718192021222324int partition(int array[], int left, int right)&#123; int pivot = array[left]; int i = left; int j = right + 1; bool forward = NO; while(i &lt; j) &#123; while(forward &amp;&amp; array[++i] &lt;= pivot &amp;&amp; i &lt; j); while(!forward &amp;&amp; array[--j] &gt;= pivot &amp;&amp; i &lt; j); // 交换 i、j 的内容 swap(array, i, j); forward = !forward; &#125; return j;&#125;void swap(int arr[], int one, int two)&#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp;&#125; 其中在“夹逼”过程中的最后一个判断 i &lt; j，是为了防止在夹逼的过程中出现左侧小于右侧的情况。 退出循环后 i = j，所以最后一次交换也不会影响结果。 7.5 划分 - 挖坑取数 - 演示步骤如果上面的说明过于抽象，这里演示一遍“挖坑取数”在数组 {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 3。 从最右侧 7 开始，向前寻找，找到第一个小于等于 3 的数字：2，交换两者位置，得到数组： {2, 5, 1, 9, 8, 6, 0, 3, 4, 7} 。 从最左侧的下一个数字 5 开始，向后寻找，找到第一个大于等于 3 的数字：5，交换两者位置，得到数组： {2, 3, 1, 9, 8, 6, 0, 5, 4, 7} 。 从最右侧的上一个数字 0 开始，向前寻找，找到第一个小于等于 3 的数字：0，交换两者位置，得到数组： {2, 0, 1, 9, 8, 6, 3, 5, 4, 7} 。 从最左侧的下一个数字 1 开始，向后寻找，找到第一个大于等于 3 的数字：9，交换两者位置，得到数组： {2, 0, 1, 3, 8, 6, 9, 5, 4, 7} 。 从最右侧的上一个数字 6 开始，向前寻找，找到第一个小于等于 3 的数字，没有找到，得到最终数组：{2, 0, 1, 3, 8, 6, 9, 5, 4, 7}。 此时，pivot = 3 的左侧数字全部小于等于 3，右侧数字全部大于等于 3，划分完成。 7.6 划分 - 快慢指针这里介绍另外一种划分算法，我（原作者）称之为“快慢指针”，具体过程如下： 将最右侧的数字作为主元。 使用两个指针 faster 和 slower，faster 初始指向第一个数字，slower 初始时指向 faster 上一个数字。 从第一个数字开始遍历数组，快指针随着数组遍历的过程增大。 遍历数组时，每当数字小于等于 pivot 时，慢指针前进一位，然后交换快慢指针的位置，即慢指针指向的数字，永远小于等于 pivot。 当遍历结束时，0-慢指针的最终位置，都保证小于等于 pivot。快指针的最终位置，为 pivot 的前一位。 慢指针向前移动一位（指向的数字保证大于等于 pivot，只有指向 pivot 时，等号成立），交换 pivot 与此时慢指针的位置。 123456789101112131415161718int partition(int array[], int left, int right)&#123; int pivot = array[right]; // 慢指针指向小于 pivot 的值的位置 int slower = left - 1; for (int faster = left; faster &lt; right; ++faster) &#123; if(array[faster] &lt;= pivot) &#123; // 因为发现一个小于 pivot 的值，慢指针向右移一位，用于交换 slower++; swap(array, slower, faster); &#125; &#125; // 最终，慢指针右侧即为 pivot 的位置 swap(array, slower + 1, right); return slower + 1;&#125; 7.7 划分 - 快慢指针 - 演示步骤同样地，演示一遍“快慢指针”在数组 A = {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 7，快指针初始位置指向 3，faster = 0，慢指针初始位置在快指针的前一个位置，slower = -1。 第一个数，3 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 0，faster = 1。 第二个数，5 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 1，faster = 2。 第三个数，1 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 3。 第四个数，9 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 4。 第五个数，8 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 5。 第六个数，6 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 8, 9, 0, 2, 4, 7}，slower = 3，faster = 6。 第七个数，0 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 9, 8, 2, 4, 7}，slower = 4，faster = 7。 第八个数，2 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 8, 9, 4, 7}，slower = 5，faster = 8。 第九个数，4 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 4, 9, 8, 7}，slower = 6，faster = 9。 此时，快指针 faster = 9，不满足小于 right = 9 的条件，退出循环，将主元 pivot = 7，与慢指针的后一个数字 A[7] = 9，做一次交换，得到最终数组：{3, 5, 1, 6, 0, 2, 4, 7, 8, 9}，划分完成。 7.8 快速排序的时间复杂度和稳定性 最坏情况时间复杂度 T(n) = O(n2)。 最好情况时间复杂度 T(n) = O(nlog2n)。 平均情况时间复杂度 T(n) = O(nlog2n)。 最坏情况空间复杂度 T(n) = O(n)。 最好情况空间复杂度 T(n) = O(log2n)。 快速排序，始终只使用原来的数组空间 O(1)，真正消耗的空间，是由递归的深度决定的。 无论哪一种快速排序排序的划分算法，都会打破快速排序的稳定性。 7.9 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define n 5int a[n];int temp;static int count = 0;void swap_t(int a[], int i, int j)&#123; temp = a[i]; a[i] = a[j]; a[j] = temp; count++;&#125;int par(int a[], int left, int right)&#123; int i = left; int x = a[left]; // 基准元素 for(int j = left + 1; j &lt;= right; j++) &#123; if(a[j] &lt;= x) &#123; // 比 x 小的换到左侧 i++; swap_t(a, i, j); &#125; &#125; swap_t(a, left, i); return i; // 轴位置&#125;void QuickSort(int a[],int left, int right)&#123; if(left &lt; right) &#123; int r = par(a, left, right); QuickSort(a, left, r - 1); QuickSort(a, r + 1, right); &#125;&#125;int main()&#123; int i = 0; for(;i &lt; n; i++) &#123; a[i] = arc4random() % 100 + 1; printf(\"%d \", a[i]); &#125; printf(\"\\n\"); QuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) &#123; printf(\"%d \", a[i]); &#125; printf(\"\\n\"); printf(\"交换了 %d 次\", count); return 0;&#125;87 71 39 75 61 39 61 71 75 87 交换了 8 次 随机选择元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define n 5int a[n];int temp;void swap_t(int a[], int i, int j)&#123; temp = a[i]; a[i] = a[j]; a[j] = temp;&#125;int par(int a[], int left, int right)&#123; int i = left; int x = a[left]; for(int j = left + 1; j &lt;= right; j++) &#123; if(a[j] &lt;= x) &#123; i++; swap_t(a, i, j); &#125; &#125; swap_t(a, left, i); return i;&#125;/// 生成随机的基准元素下标int Random(int left, int right)&#123; return arc4random() % (right - left + 1) + left;&#125;// 用随机的基准元素进行快速排序int Randomizedpar(int a[], int left, int right)&#123; int i = Random(left, right); swap_t(a, left, i); // 第一个和第 i 个交换，相当于有了一个随机基准元素 return par(a, left, right);&#125;void RandomizedQuickSort(int a[], int left, int right)&#123; if(left &lt; right) &#123; int r = Randomizedpar(a, left, right); printf(\"%d到%d之间的随机数：%d\\n\", left, right, r); RandomizedQuickSort(a, left, r - 1); RandomizedQuickSort(a, r + 1, right); &#125;&#125;int main()&#123; int i = 0; for(; i&lt; n; i++) &#123; a[i] = arc4random() % 100 + 1; printf(\"%2d \", a[i]); &#125; printf(\"\\n\"); RandomizedQuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) &#123; printf(\"%2d \", a[i]); &#125; printf(\"\\n\"); return 0;&#125; 7.10 快速排序的性能瓶颈与优化策略详情见：排序算法杂谈（五）关于快速排序的优化策略分析 八、学习文章Gerrard_Feng &amp; 排序算法(一) 冒泡排序Gerrard_Feng &amp; 排序算法(二) 选择排序常见排序算法导读(3)[简单选择排序]Gerrard_Feng &amp; 排序算法(三) 直接插入排序Gerrard_Feng &amp; 排序算法(四) 希尔排序Gerrard_Feng &amp; 排序算法（五）堆排序使用减治法求解堆排序堆排序原理及算法实现（最大堆）Gerrard_Feng &amp; 排序算法（六）归并排序Gerrard_Feng 排序算法（七）快速排序快速排序算法分析和实现","tags":[]},{"title":"iOS 编译过程原理(2)","date":"2019-10-24T01:06:24.302Z","path":"2019/10/24/iOS/iOS原理/iOS 编译过程原理(2)/","text":"一、前言《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚： Clang 和 LLVM 究竟是什么 源文件到机器码的细节 Linker 做了哪些工作 编译顺序如何确定 头文件是什么？XCode 是如何找到头文件的？ Clang Module 签名是什么？为什么要签名 为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。 二、编译器 把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做编译器。 大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swift，后端都是 LLVM。 三、LLVMLLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。 LLVM 的核心库提供了现代化的 source-target-independent 优化器和支持诸多流行 CPU 架构的代码生成器，这些核心代码是围绕着 LLVM IR（中间代码）建立的。 基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。 四、clangclang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程： 接下来，从代码层面看一下具体的转化过程，新建一个 main.c： 1234567891011#include &lt;stdio.h&gt;// 注释#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\n\");#else printf(\"hello world\\n\");#endif return 0;&#125; 五、预处理（preprocessor）预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。 #include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，这个过程是递归的：因为 stdio.h 也有可能包含其他头文件。 用 clang 查看预处理的结果： 1$ xcrun clang -E main.c 预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。 12345678910111213141516171819202122$ xcrun clang -E main.c......extern int \\_\\_vsnprintf\\_chk (char * restrict, size\\_t, int, size\\_t, const char * restrict, va_list);\\# 412 \"/usr/include/stdio.h\" 2 3 4\\# 10 \"main.c\" 2int main() &#123; printf(\"hello debug\\\\n\"); return 0;&#125; 可以看到，在预处理的时候，注释被删除，条件编译被处理。 六、词法分析（lexical anaysis）词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。 1$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 输出： 1234567891011121314151617181920212223242526$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.cannot\\_module\\_include '#include &lt;stdio.h&gt;// 一点注释#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\\\n\");#else printf' Loc=&lt;main.c:9:1&gt;int 'int' \\[StartOfLine\\] Loc=&lt;main.c:14:1&gt;identifier 'main' \\[LeadingSpace\\] Loc=&lt;main.c:14:5&gt;l_paren '(' Loc=&lt;main.c:14:9&gt;r_paren ')' Loc=&lt;main.c:14:10&gt;l_brace '&#123;' \\[LeadingSpace\\] Loc=&lt;main.c:14:12&gt;identifier 'printf' \\[StartOfLine\\] \\[LeadingSpace\\] Loc=&lt;main.c:16:5&gt;l_paren '(' Loc=&lt;main.c:16:11&gt;string_literal '\"hello debug\\\\n\"' Loc=&lt;main.c:16:12&gt;r_paren ')' Loc=&lt;main.c:16:27&gt;semi ';' Loc=&lt;main.c:16:28&gt;return 'return' \\[StartOfLine\\] \\[LeadingSpace\\] Loc=&lt;main.c:20:5&gt;numeric_constant '0' \\[LeadingSpace\\] Loc=&lt;main.c:20:12&gt;semi ';' Loc=&lt;main.c:20:13&gt;r_brace '&#125;' \\[StartOfLine\\] Loc=&lt;main.c:21:1&gt;eof '' Loc=&lt;main.c:21:2&gt; Loc=\\main.c:9:1\\ 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。 七、语法分析（semantic analysis）词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。 1$ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f main 函数 AST 的结构： 123456789101112131415[0;1;32mTranslationUnitDecl\u001b[0m\u001b[0;33m 0x7fd9a18166e8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816c60\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __int128_t\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816980\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816cd0\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __uint128_t\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a18169a0\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816fa8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __NSConstantString\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mRecordType\u001b[0m\u001b[0;33m 0x7fd9a1816db0\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;1;32mRecord\u001b[0m\u001b[0;33m 0x7fd9a1816d28\u001b[0m\u001b[0;1;36m '__NSConstantString_tag'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817040\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __builtin_ms_va_list\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mPointerType\u001b[0m\u001b[0;33m 0x7fd9a1817000\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816780\u001b[0m \u001b[0;32m'char'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817308\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit referenced\u001b[0;1;36m __builtin_va_list\u001b[0m \u001b[0;32m'struct __va_list_tag [1]'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mConstantArrayType\u001b[0m\u001b[0;33m 0x7fd9a18172b0\u001b[0m \u001b[0;32m'struct ... 有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。 AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST。 八、CodeGenCodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。 1xcrun clang -S -emit-llvm main.c -o main.ll main.ll 文件内容： 12345678910111213141516; ModuleID = 'main.c'source_filename = \"main.c\"target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"target triple = \"x86_64-apple-macosx10.13.0\"@.str = private unnamed_addr constant \\[13 x i8\\] c\"hello debug\\\\0A\\\\00\", align 1; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 &#123; %1 = alloca i32, align 4 store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds (\\[13 x i8\\], \\[13 x i8\\]* @.str, i32 0, i32 0)) ret i32 0&#125;... Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。 LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass。 九、生成汇编代码LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。 生成 arm 64 汇编： 1$ xcrun clang -S main.c -o main.s 查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：iOS汇编快速入门。 12345678910111213141516171819202122232425262728293031 .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp leaq L_.str(%rip), %rdi movl $0, -4(%rbp) movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz \"hello debugn\".subsections_via_symbols 十、汇编器汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 1$ xcrun clang -fmodules -c main.c -o main.o 还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号 123$ xcrun nm -nm main.o (undefined) external _printf0000000000000000 (\\_\\_TEXT,\\_\\_text) external _main _printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。 什么是符号（Symbols）? 符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。 十一、链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。 1$ xcrun clang main.o -o main 就得到了一个 mach o 格式的可执行文件 1234$ file mainmain: Mach-O 64-bit executable x86_64$ ./mainhello debug 再用 nm 命令，查看可执行文件的符号表： 12345$ nm -nm main (undefined) external _printf (from libSystem) (undefined) external dyld\\_stub\\_binder (from libSystem)0000000100000000 (\\_\\_TEXT,\\_\\_text) \\[referenced dynamically\\] external \\_\\_mh\\_execute_header0000000100000f60 (\\_\\_TEXT,\\_\\_text) external _main _printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。 十二、XCode 编译通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？ 新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志： 详细的步骤： 创建 Product.app 的文件夹 把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。 创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。 执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。 编译 .m 文件，生成 .o 文件。 链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。 编译 assets，编译 storyboard，链接 storyboard 拷贝动态库 Logger.framework，并且对其签名 执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework 对 Demo.App 签名，并验证（validate） 生成 Product.app 生成 dYSM 文件 Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。 十三、编译顺序编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？ 答案是：依赖关系。 还是以刚刚的 Demo 项目为例，整个依赖关系如下： 可以从 XCode 的 Report Navigator 看到 Target 的编译顺序： XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。 那么，XCode 又从哪里得到了这些依赖关系呢？ Target Dependencies - 显式声明的依赖关系 Linked Frameworks and Libraries - 隐式声明的依赖关系 Build Phase - 定义了编译一个 Target 的每一步 十四、增量编译日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？ 因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。 比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。 十五、头文件C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。 头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。 当只有声明，没有实现的时候，链接器就会报错。 12345Undefined symbols for architecture arm64:“_umimplementMethod”, referenced from:-\\[ClassA method\\] in ClassA.old: symbol(s) not found for architecture arm64clang: error: linker command failed with exit code 1 (use -v to see invocation) Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。 日常开发中，两种常见的头文件引入方式： 12#include \"CustomClass.h\" // 自定义#include &lt;Foundation/Foundation.h&gt; // 系统或者内部 framework 引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？ 回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志： 把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的： 12345678910111213141516171819#include \"...\" search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap) /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers #include &lt;...&gt; search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources /Users/.../Build/Products/Debug-iphoneos (framework directory) /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory) /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory) /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include $SDKROOT/usr/include $SDKROOT/System/Library/Frameworks (framework directory) End of search list. 这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。 可以通过一个辅助的小工具 hmap 查看 hmap 中的内容： 1234567$ ./hmap print Demo-project-headers.hmap AppDelegate.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.hDemo-Bridging-Header.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.hDummy.h -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.hFramework.h -&gt; Framework/Framework.hTestView.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.hViewController.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h 这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。 clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找： 12/Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/TestView.h/Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers/TestView.h 系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。 以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时： 首先查找 framework 是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework 如果 framework 存在，再在 headers 目录里查找头文件是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework/headers/Foundation.h 十六、Clang Module传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的： 大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。 文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。 边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。 clang module 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。 XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。 #import \\&lt;Foundation/NSString.h> 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。 那么，如何定义一个 module 呢？答案是：modulemap 文件，这个文件描述了一组头文件如何转换为一个 module，举个例子： 1234567891011framework module Foundation [extern_c] [system] &#123; umbrella header \"Foundation.h\" // 所有要暴露的头文件 export * module * &#123; export * &#125; explicit module NSDebug &#123; //submodule header \"NSDebug.h\" export * &#125; &#125; swift 是可以直接 import 一个 clang module 的，比如你有一些 C 库，需要在 Swift 中使用，就可以用 modulemap 的方式。 十七、Swift 编译现代化的语言几乎都抛弃了头文件，swift 也不例外。问题来了，swift 没有头文件又是怎么找到声明的呢？ 编译器干了这些脏活累活。编译一个 Swift 头文件，需要解析 module 中所有的 Swift 文件，找到对应的声明。 当开发中难免要有 Objective-C 和 Swift 相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？ Swift 引用 Objective-C Swift 的编译器内部使用了 clang，所以 swift 可以直接使用 clang module，从而支持直接 import Objective-C 编写的framework。 swift 编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类： Bridging-Header.h 中暴露给 swfit 的头文件 framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。 XCode 提供了宏定义 NS_SWIFT_NAME 来让开发者定义 Objective-C =&gt; Swift的符号映射，可以通过 Related Items -&gt; Generate Interface 来查看转换后的结果： Objective-C 引用 swift xcode 会以 module 为单位，为 swift 自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-Swift.h。 swift 提供了关键词 @objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。 1@objc public class MyClass 十八、深入理解 Linker 链接器会把编译器编译生成的多个文件，链接成一个可执行文件。链接并不会产生新的代码，只是在现有代码的基础上做移动和补丁。 链接器的输入可能是以下几种文件： object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。 动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载 静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。 tbd，只包含符号的库文件 这里提到了一个概念：符号（Symbols），那么符号是什么呢？ 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。 以一段代码为例，看看链接时究竟发生了什么？ 源代码： 1234- (void)log&#123; printf(\"hello world\\n\");&#125; .o 文件： 12345678#代码adrp x0, l_.str@PAGEadd x0, x0, l_.str@PAGEOFFbl _printf#字符串符号l_.str: ; @.str .asciz \"hello world\\\\n\" 在 .o 文件中，字符串 “hello world\\n” 作为一个符号（l_.str）被引用，汇编代码读取的时候按照 l_.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决： l_.str 在可执行文件的哪个位置？ printf 函数来自哪里？ 再来看看链接之后的 mach o 文件： 链接器如何解决这两个问题呢？ 链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。 链接后，不再是调用符号 _printf，而是在 DATA 段上创建了一个函数指针 _printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 _printf 地址。更多细节，可以参考这篇文章：深入理解iOS App的启动过程。 Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。 十九、理解签名 非对称加密 在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。 数字签名 数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。 数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。 Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。 但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。 有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。 二十、iOS App 签名为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。 除此之外，Apple 要严格控制 App 的分发： App 来自 Apple 信任的开发者 安装的设备是 Apple 允许的设备 20.1 证书通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。 20.2 Provisioning ProfileiOS App 安装到设备的途径（非越狱）有以下几种： 开发包（插线，或者 archive 导出 develop 包） Ad Hoc App Store 企业证书 开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。 可以通过以下命令来查看 Provisioning Profile 中的内容： 12security cms -D -i embedded.mobileprovision &gt; result.plistopen result.plist 本质上就是一个编码过后的 plist。 20.3 iOS 签名生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。 创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名 1234567891011121314151617&lt;key&gt;Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nib&lt;/key&gt;&lt;data&gt;T2g5jlq7EVFHNzL/ip3fSoXKoOI=&lt;/data&gt;&lt;key&gt;Info.plist&lt;/key&gt;&lt;data&gt;5aVg/3m4y30m+GSB8LkZNNU3mug=&lt;/data&gt;&lt;key&gt;PkgInfo&lt;/key&gt;&lt;data&gt;n57qDP4tZfLD1rCS43W0B4LQjzE=&lt;/data&gt;&lt;key&gt;embedded.mobileprovision&lt;/key&gt;&lt;data&gt;tm/I1g+0u2Cx9qrPJeC0zgyuVUE=&lt;/data&gt;... 代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名： 20.4 验证安装 App 的时候 从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者 证书验证通过后，从证书中取出 Leo 的公钥 读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确 文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证） 验证通过后，安装 App 启动 App 的时候 验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致 判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证 如果是企业证书，验证用户是否信任企业证书 App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。 以上都验证通过，App 才能正常启动 二十一、文章黄文臣 &amp; 深入浅出iOS编译","tags":[]},{"title":"Block","date":"2019-10-24T01:06:24.300Z","path":"2019/10/24/iOS/iOS原理/block/","text":"一、什么是闭包在 wikipedia 上，闭包的定义是: In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. 翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。 block 实际上就是 Objective-C 语言对于闭包的实现。 block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程，《使用GCD》。 本文主要介绍 Objective-C 语言的 block 在编译器中的实现方式。主要包括： block 的内部实现数据结构介绍 block 的三种类型及其相关的内存管理方式 block 如何通过 capture 变量来达到访问函数外的变量 二、实现方式 block 本身也是一个 OC 对象，它里面也有 isa 指针 block 是封装了函数调用（存储函数调用地址，函数访问变量）和函数调用环境的 OC 对象 在 main.m 中写入一个 block： 123456789101112int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int a = 15; void (^ block)(int, int) = ^ (int b, int c) &#123; NSLog(@\"%d\", a); &#125;; block(10, 10); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 终端进到项目 main.m 的目录下通过反编译成 c++ 文件： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian.cpp 得到 main.cpp，找到这个 block 对象的底层结构： 123456789int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int a = 15; void (* block)(int, int) = ((void (*)(int, int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); ((void (*)(__block_impl *, int, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, 10, 10); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 实际上 block 在底层对应的就是 __main_block_impl_0： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 里面存储着 __block_impl 的结构体 impl，以及 __main_block_desc_0 的结构体指针 Desc. 搜索对象的内容我们可以找到: 1234567891011struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 这里可以看到 __block_impl 包含着 isa 指针，以及 FuncPtr。FuncPtr 就是 block 的调用地址，是在声明 block 的时候初始化传递进来的。以及 __main_block_desc_0 包含着的 Block_size 为 block 的内存大小。还有 int a 也封装到了Block 内部，我们知道 OC 对象的特征就是 isa 指针，所以，block 就是封装了函数调用、以及函数调用环境的 OC 对象。 反编译成 C 文件： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.c block 的数据结构定义如下： 对应的结构体定义如下： 123456789101112131415struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *); &#125;; struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, …); struct Block_descriptor *descriptor; /* Imported variables. */ &#125;; 通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成： isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。 三、Capture (捕获)对于局部变量：值传递，Block 只是把局部变量的值捕获存储在了 block 的结构体内存储。 123456int a = 10;void (^block)(void) = ^&#123; NSLog(@\"%d\", a);&#125;;a = 20;block(); // 输出 10 对于 Static：指针传递，Block 把 static 的变量的指针存储在 block 的结构体内，所以取值的话就是取对应最后的赋值。 123456static int a = 10;void (^block)(void) = ^&#123; NSLog(@\"%d\", a);&#125;;a = 20;block(); // 输出 20 全局变量：直接访问 12345678910111213141516static int a = 20;int b = 15;int main(int argc, const char * argv\\[\\]) &#123; @autoreleasepool &#123; void (^block)(void) = ^&#123; NSLog(@\"%d\", a); NSLog(@\"%d\", b); &#125;; a = 25; b = 10; block(); // 输出 25 10 &#125; return 0;&#125; 四、block 的类型block 分为 3 种类型，但是最终都是继承自 NSObject。 _NSConcreteGlobalBlock 全局的静态 block，内部没有访问 auto 变量，不会访问任何外部变量。 _NSConcreteStackBlock 保存在栈中的 block，内部访问了 auto 变量，当函数返回时会被销毁。 _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。 stack block 存放在栈内存，如果 block 存放在函数内，一旦函数作用域结束，则 block 内容则会被清除，如果存放在堆内存（调用 copy），就会变成 malloc block，则不会自动清除，这也是为什么 block 需要用 copy 修饰的原因。 4.1 NSConcreteGlobalBlock12345678#include &lt;stdio.h&gt;int main() &#123; ^&#123; printf(\"Hello, World!\\\\n\"); &#125; (); return 0; &#125; 在终端命令行中输入 1$ clang -rewrite-objc block.cpp(文件名) 即可在目录中看到 clang 输出了一个名为 block.cpp 的文件。该文件就是 block 在 c 语言实现，将 block.cpp 中一些无关的代码去掉，将关键代码引用如下： 1234567891011121314151617181920212223242526272829303132struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr; &#125;; struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"Hello, World!\\n\"); &#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; &#125;__main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;; int main() &#123; (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA) (); return 0; &#125; 具体看一下是如何实现的。__main_block_impl_0 就是该 block 的实现，从中可以看出： 一个 block 实际是一个对象，它主要由一个 isa 和一个 impl 和一个 descriptor 组成。 在本例中，isa 指向 _NSConcreteGlobalBlock，主要是为了实现对象的所有特性，在此我们就不展开讨论了。 impl 是实际的函数指针，本例中，它指向 __main_block_func_0。这里的 impl 相当于之前提到的 invoke 变量，只是clang 编译器对变量的命名不一样而已。 descriptor 是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。在该例子中我们还看不到相关 capture 的代码，后面将会看到。 4.2 NSConcreteStackBlock123456789101112#include &lt;stdio.h&gt; int main()&#123; int a = 100; void (^block)(void) = ^&#123; printf(\"%d\\n\", a); &#125;; block(); return 0; &#125; 反编译之后： 1234567891011121314151617181920212223242526272829struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int a; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy printf(\"%d\\n\", a); &#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; int main() &#123; int a = 100; void (*block)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0; &#125; 在本例中，我们可以看到： 本例中，isa 指向 _NSConcreteStackBlock，说明这是一个分配在栈上的实例。 main_block_impl_0 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 main_block_impl_0 结构体中的那个变量 a。因为这样，我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a。 main_block_impl_0 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 main_block_desc_0 中。 4.3 NSConcreteMallocBlockNSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。以下是一个 block 被 copy 时的示例代码（来自这里），可以看到，在第 8 步，目标的 block 类型被修改为 _NSConcreteMallocBlock。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void *_Block_copy_internal(const void *arg, const int flags) &#123; struct Block_layout *aBlock; const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE; // 1 if (!arg) return NULL; // 2 aBlock = (struct Block_layout *)arg; // 3 if (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123; // latches on high latching_incr_int(&amp;aBlock-&gt;flags); return aBlock; &#125; // 4 else if (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123; return aBlock; &#125; // 5 struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return (void *)0; // 6 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first // 7 result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK); // XXX not needed result-&gt;flags |= BLOCK_NEEDS_FREE | 1; // 8 result-&gt;isa = _NSConcreteMallocBlock; // 9 if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) &#123; (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup &#125; return result;&#125; 五、变量的复制block 内部默认是无法修改 auto 变量的，因为在 block 底部的话执行 block、声明局部变量 a（main 函数）的地方分别是两个不同的函数，并没有办法从一个函数去修改另一个函数的局部变量，而如果使用 static 或者使用全局变量是可以的，因为block 在底层存储 static 变量是存储它的指针地址，全局变量就全部都可以访问。 如果要修改 auto 变量的话，则需要使用 __block。 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的： 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的： 修改上面的源码，在变量前面增加 __block 关键字： 123456789101112#include &lt;stdio.h&gt; int main() &#123; __block int i = 1024; void (^block)(void) = ^&#123; printf(\"%d\\n\", i); i = 1023; &#125;; block(); return 0; &#125; 生成的关键代码如下，可以看到，差异相当大： 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct __Block_byref_a_0 &#123; void *__isa;__Block_byref_a_0 *__forwarding; int __flags; int __size; int a;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref printf(\"%dn\", (a-&gt;__forwarding-&gt;a)); (a-&gt;__forwarding-&gt;a) = 1023; &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1024&#125;; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return UIApplicationMain(argc, argv, __null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AppDelegate\"), sel_registerName(\"class\")))); &#125;&#125; 从代码中可以看到： 源码中增加一个名为 __Block_byref_i_0 的结构体，用来保存我们要 capture 并且修改的变量 a。 main_block_impl_0 中引用的是 Block_byref_i_0 的结构体指针，这样就可以达到修改外部变量的作用。 __Block_byref_i_0 结构体中带有 isa、a以及 __forwarding（指向自己的指针）等其他信息，它也是一个对象。 我们需要负责 Block_byref_i_0 结构体相关的内存管理，所以 main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。 12__attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 1024&#125;;void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); 这里声明了一个 __Block_byref_a_0 的对象，并把 &amp;a 传递给了 __forwarding，10 传递给了 a。 1234567static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref printf(\"%dn\", (a-&gt;__forwarding-&gt;a)); (a-&gt;__forwarding-&gt;a) = 1023; &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; 这里执行 block 时，取出了 __Block_byref_a_0 所存储的 &amp;a（__forwarding：__Block_byref_a_0 的指针地址），再取出 a，最后进行修改/使用。 六、ARC 对 block 类型的影响在 ARC 开启的情况下，将只会有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。 原本的 NSConcreteStackBlock 的 block 会被 NSConcreteMallocBlock 类型的 block 替代。在苹果的官方文档中也提到，当把栈中的 block 返回时，不需要调用 copy 方法了。 123456789101112int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; int i = 1024; void (^block)(void) = ^&#123; printf(\"%d\\n\", i); &#125;; block(); NSLog(@\"%@\", block); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。 七、Block 循环引用问题7.1 RetainCircle 的由来当 A 对象里面强引用了 B 对象，B 对象又强引用了 A 对象，这样两者的 retainCount 值一直都无法为 0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。 这是 2 个对象之间的，相应的，这种循环还能存在于 3、4 … n 个对象之间，只要相互形成环，就会导致 Retain Cicle 的问题。 当然也存在自身引用自身的。当一个对象内部的一个 obj，强引用的自身，也会导致循环引用的问题出现。常见的就是 block 里面引用的问题。 7.2 __weak、__strong 的实现原理在 ARC 环境下，id 类型和对象类型、C 语言其他类型不同，类型前必须加上所有权的修饰符。 所有权修饰符总共有 4 种： __strong 修饰符 __weak 修饰符 __unsafe_unretained 修饰符 __autoreleasing 修饰符 一般我们如果不写，默认的修饰符是 __strong。 要想弄清楚 __strong、__weak 的实现原理，我们就需要研究研究 clang(LLVM编译器)和 objc4 Objective-C runtime 库了。 关于 clang 有一份关于ARC详细的文档，有兴趣的可以仔细研究一下文档里面的说明和例子，很有帮助。 以下的讲解，也会来自于上述文档中的函数说明。 __strong 的实现原理 ①、对象持有自己 首先我们先来看看生成的对象持有自己的情况，利用 alloc/new/copy/mutableCopy 生成对象。 当我们声明了一个 __strong 对象 123&#123; id __strong obj = [[NSObject alloc] init];&#125; LLVM 编译器会把上述代码转换成下面的样子 1id __attribute__((objc_ownership(strong))) obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSObject\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); 相应的会调用 12345id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj,selector(init));objc_release(obj); 上述这些方法都好理解。在 ARC 有效的时候就会自动插入 release 代码，在作用域结束的时候自动释放。 &gt; ②、对象不持有自己 生成对象的时候不用 alloc/new/copy/mutableCopy 等方法。 123&#123; id __strong obj = [NSMutableArray array]; &#125; LLVM 编译器会把上述代码转换成下面的样子 1id __attribute__((objc_ownership(strong))) array = ((NSMutableArray *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"NSMutableArray\"), sel_registerName(\"array\")); 查看 LLVM 文档，其实是下述的过程，相应的会调用 12345id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleasedReturnValue(obj);objc_release(obj); 与之前对象会持有自己的情况不同，这里多了一个 objc\\_retainAutoreleasedReturnValue 函数。 这里有 3 个函数需要说明： 1、[id objc_retainAutoreleaseReturnValue(id value);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id69) &gt;\\_Precondition:\\_ value is null or a pointer to a valid object. &gt; &gt;If value is null, this call has no effect. Otherwise, it performs a retain operation followed by the operation described in [objc_autoreleaseReturnValue](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue). &gt; &gt;Equivalent to the following code: &gt; &gt;id objc\\_retainAutoreleaseReturnValue(id value) { &gt; &gt;return objc\\_autoreleaseReturnValue(objc\\_retain(value)); &gt; &gt;} &gt; &gt;Always returns value 1234567891011121314151617181920212223242526 2、[id objc_retainAutoreleasedReturnValue(id value);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id70) &gt;\\_Precondition:\\_ value is null or a pointer to a valid object. &gt; &gt;If value is null, this call has no effect. Otherwise, it attempts to accept a hand off of a retain count from a call to [objc_autoreleaseReturnValue](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue) on value in a recently-called function or something it calls. If that fails, it performs a retain operation exactly like [objc_retain](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain). &gt; &gt;Always returns value 3、[id objc_autoreleaseReturnValue(id value);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id59) &gt;\\_Precondition:\\_ value is null or a pointer to a valid object. &gt; &gt;If value is null, this call has no effect. Otherwise, it makes a best effort to hand off ownership of a retain count on the object to a call to[objc_retainAutoreleasedReturnValue](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasedreturnvalue) for the same object in an enclosing call frame. If this is not possible, the object is autoreleased as above. &gt; &gt;Always returns value 这 3 个函数其实都是在描述一件事情：it makes a best effort to hand off ownership of a retain count on the object to a call to objc_retainAutoreleasedReturnValue for the same object in an enclosing call frame。 这属于 LLVM 编译器的一个优化。objc\\_retainAutoreleasedReturnValue 函数是用于自己持有(retain)对象的函数，它持有的对象应为返回注册在 autoreleasepool 中对象的方法或者是函数的返回值。 在 ARC 中原本对象生成之后是要注册到 autoreleasepool 中，但是调用了objc\\_autoreleasedReturnValue 之后，紧接着调用了 objc\\_retainAutoreleasedReturnValue，objc\\_autoreleasedReturnValue 函数会去检查该函数方法或者函数调用方的执行命令列表，如果里面有objc\\_retainAutoreleasedReturnValue() 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 autoreleasepool 中，也可以返回拿到相应的对象。2. \\_\\_weak 的实现原理 声明一个 \\_\\_weak 对象 { id __weak obj = strongObj; // 假设这里的 strongObj 是一个已经声明好了的对象。 } 12LLVM 转换成对应的代码 id __attribute__((objc_ownership(none))) obj1 = strongObj; 12相应的会调用 id obj ; objc_initWeak(&amp;obj,strongObj); objc_destoryWeak(&amp;obj); 1234567891011121314151617181920看看文档描述&gt;[id objc\\_initWeak(id *object, id value);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id62)&gt;&gt;\\_Precondition:\\_ object is a valid pointer which has not been registered as a \\_\\_weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object is registered as a \\_\\_weak object pointing to value&gt;&gt;Equivalent to the following code:&gt;&gt;id objc\\_initWeak(id \\_object, id value) &#123; \\_&gt;&gt;object = nil;&gt;&gt;return objc_storeWeak(object, value);&gt;&gt;&#125;&gt;&gt;Returns the value of object after the call.Does not need to be atomic with respect to calls to objc\\_storeWeak on objectobjc_initWeak 的实现其实是这样的： id objc_initWeak(id * object, id value) { *object = nil; return objc_storeWeak(object, value); } 123456789101112131415161718会把传入的 object 变成 0 或者 nil，然后执行 objc\\_storeWeak 函数。那么 objc\\_destoryWeak 函数是干什么的呢？&gt;[void objc_destroyWeak(id *object);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id61)&gt;&gt;\\_Precondition:\\_ object is a valid pointer which either contains a null pointer or has been registered as a \\_\\_weak object. object is unregistered as a weak object, if it ever was. The current value of object is left unspecified; otherwise, equivalent to the following code:&gt;&gt;void objc\\_destroyWeak(id * object) &#123;&gt;&gt;objc\\_storeWeak(object, nil);&gt;&gt;&#125;&gt;&gt;Does not need to be atomic with respect to calls to objc_storeWeak on objectobjc\\_destoryWeak 函数的实现： void objc_destroyWeak(id * object) { objc_storeWeak(object, nil); } 123456789101112131415161718192021222324252627282930 也是会去调用 objc\\_storeWeak 函数。objc\\_initWeak 和 objc\\_destroyWeak 函数都会去调用 objc\\_storeWeak 函数，唯一不同的是调用的入参不同，一个是 value，一个是 nil。 那么重点就都落在 objc\\_storeWeak 函数上了。 &gt;[id objc_storeWeak(id *object, id value);](http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id73) &gt; &gt;\\_Precondition:\\_ object is a valid pointer which either contains a null pointer or has been registered as a \\_\\_weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is assigned null and unregistered as a \\_\\_weak object. Otherwise, object is registered as a \\_\\_weak object or has its registration updated to point to value &gt; &gt;Returns the value of object after the call. objc\\_storeWeak 函数的用途就很明显了。由于 weak 表也是用 Hash table 实现的，所以objc\\_storeWeak 函数就把第一个入参的变量地址注册到 weak 表中，然后根据第二个入参来决定是否移除。如果第二个参数为 0，那么就把 \\_\\_weak 变量从 weak 表中删除记录，并从引用计数表中删除对应的键值记录。 所以如果 \\_\\_weak 引用的原对象如果被释放了，那么对应的 \\_\\_weak 对象就会被指为 nil。原来就是通过 objc\\_storeWeak 函数这些函数来实现的。 以上就是 ARC 中 \\_\\_strong 和 \\_\\_weak 的简单的实现原理，更加详细的还请大家去看看这一章开头提到的那个 LLVM 文档，里面说明的很详细。 &lt;center&gt; ![](http://www.dzliving.com/wp-content/uploads/2018/02/Block2.png) &lt;/center&gt;#### 7,3 weakSelf、strongSelf 的用途在提 weakSelf、strongSelf 之前，我们先引入一个 Retain Cicle 的例子。假设自定义的一个 student 类例子 1：**Student.h 文件** #import &lt;Foundation/Foundation.h&gt; typedef void(^ Study)(); @interface Student : NSObject @property (nonatomic, copy) NSString * name;@property (nonatomic, copy) Study study; @end12**ViewController.m 文件** #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad{ [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @”Hello World”; student.study = ^{ NSLog(@&quot;my name is = %@&quot;, student.name); }; }1234567891011121314151617181920到这里，大家应该看出来了，这里肯定出现了循环引用了。student 的 study 的 Block 里面强引用了 student 自身。根据[上篇文章](http://www.jianshu.com/p/ee9756f3d5f6)的分析，可以知道，\\_NSConcreteMallocBlock 捕获了外部的对象，会在内部持有它。retainCount 值会加一。我们用 Instruments 来观察一下。添加 Leak 观察器。当程序运行起来之后，在 Leak Checks观察器里面应该可以看到红色的❌，点击它就会看到内存 leak 了。有 2 个泄露的对象。Block 和 Student 相互循环引用了。&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block3.jpeg)&lt;/center&gt;打开 Cycles &amp; Roots 观察一下循环的环。&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block4.jpg)&lt;/center&gt;这里形成环的原因 block 里面持有 student 本身，student 本身又持有 block。那再看一个例子 2： #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad{ [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @”Hello World”; student.study = ^(NSString * name){ NSLog(@&quot;my name is = %@&quot;,name); }; student.study(student.name); }123456789101112我把 block 新传入一个参数，传入的是 student.name。这个时候会引起循环引用么？答案肯定是不会。&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block5.jpeg)&lt;/center&gt;如上图，并不会出现内存泄露。原因是因为，student 是作为形参传递进 block 的，block 并不会捕获形参到 block 内部进行持有。所以肯定不会造成循环引用。再改一下。看例子 3： #import “ViewController.h” #import “Student.h” @interface ViewController () @property (nonatomic, copy) NSString name;@property (nonatomic, strong) Student stu; @end @implementation ViewController (void)viewDidLoad{ [super viewDidLoad]; Student * student = [[Student alloc] init]; self.name = @”halfrost”; self.stu = student; student.study = ^{ NSLog(@&quot;my name is = %@&quot;, self.name); }; student.study();} 12345678910111213141516这样会形成循环引用么？&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block6.jpg)&lt;/center&gt;答案也是会的(ARC 环境)。vc → student → block → vc 已经成环。这里即使是 self.name 也是循环引用了，因为 block 不可能说去单独的强持有某个实例的变量，这不符合内存管理规则(交叉管理了)，但是 instruments 检测不出来。(原文写着没有循环引用，我在 ARC 环境测试时，dealloc 不会被调用，说明还被引用着。可以自行验证)。那遇到循环引用我们改如何处理呢？？类比平时我们经常写的 delegate，可以知道，只要有一边是 \\_\\_weak 就可以打破循环。先说一种做法，利用 __block 解决循环的做法。例子 4： #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad{ [super viewDidLoad]; Student * student = [[Student alloc] init]; __block Student * stu = student; student.name = @”Hello World”; student.study = ^{ NSLog(@&quot;my name is = %@&quot;, stu.name); stu = nil; };} 123456789101112这样写会循环么？看上去应该不会。但是实际上却是会的。&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block7.jpg)&lt;/center&gt;由于没有执行 study 这个 block，现在 student 持有该 block，block 持有 \\_\\_block 变量，\\_\\_block 变量又持有 student 对象。3 者形成了环，导致了循环引用了。想打破环就需要破坏掉其中一个引用。\\_\\_block 不持有 student 即可。只需要执行一下 block 即可。例子 5： student.study();12345678910111213141516171819202122232425262728293031323334这样就不会循环引用了。&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/02/Block8.png)&lt;/center&gt;使用 \\_\\_block 解决循环引用虽然可以控制对象持有时间，在 block 中还能动态的控制 \\_\\_block 变量的值，可以赋值 nil，也可以赋值其他的值，但是有一个唯一的缺点就是需要执行一次 block 才行。否则还是会造成循环引用。**值得注意的是，在 ARC 下 \\_\\_block** **会导****致对象被 retain，有可能导致循环引用。而在 MRC 下，则不会 retain 这个对象，也不会导致循环引用。**接下来可以正式开始讲讲 weakSelf 和 strongSelf 的用法了。1. weakSelf 说道 weakSelf，需要先来区分几种写法。 ①、\\_\\_weak \\_\\_typeof(self)weakSelf = self; // 这是 AFN 里面的写法。。 ②、#define WEAKSELF typeof(self) __weak weakSelf = self; &gt; 先区分 __typeof() 和 typeof() AFNetWorking 的库里面的代码都很整洁，里面各方面的代码都可以当做代码范本来阅读。遇到不懂疑惑的，都要深究，肯定会有收获。这里就是一处，平时我们的写法是不带 \\_\\_ 的，AFN 里面用这种写法有什么特殊的用途么？ 在 SOF 上能找到相关的[答案](http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c)： &gt;\\_\\_typeof\\_\\_() and \\_\\_typeof() are compiler-specific extensions to the C language, because standard C does not include such an operator. Standard C requires compilers to prefix language extensions with a double-underscore (which is also why you should never do so for your own functions, variables, etc.) &gt;typeof() is exactly the same, but throws the underscores out the window with the understanding that every modern compiler supports it. (Actually, now that I think about it, Visual C++ might not. It does support decltype() though, which generally provides the same behaviour as typeof().) &gt;All three mean the same thing, but none are standard C so a conforming compiler may choose to make any mean something different. 其实两者都是一样的东西，只不过是 C 里面不同的标准，兼容性不同罢了。更加详细的[官方说明](http://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html#Alternate-Keywords) 那么抽象出来就是这 2 种写法。 #define WEAKSELF __weak typeof(self)weakSelf = self; #define WEAKSELF typeof(self) __weak weakSelf = self; 1234这样子看就清楚了，两种写法就是完全一样的。我们可以用 WEAKSELF 来解决循环引用的问题。例子 6： #import &quot;ViewController.h&quot; #import &quot;Student.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc]init]; student.name = @&quot;Hello World&quot;; __weak typeof(student) weakSelf = student; student.study = ^{ NSLog(@&quot;my name is = %@&quot;,weakSelf.name); }; student.study(); } 12345678这样就解决了循环引用的问题了。解决循环应用的问题一定要分析清楚哪里出现了循环引用，只需要把其中一环加上 weakSelf 这类似的宏，就可以解决循环引用。如果分析不清楚，就只能无脑添加 weakSelf、strongSelf，这样的做法不可取。在上面的例子 3 中，就完全不存在循环引用，要是无脑加 weakSelf、strongSelf 是不对的。在例子 6 中，也只需要加一个 weakSelf 就可以了，也不需要加 strongSelf。曾经在 segmentfault 也看到过这样一个问题，问：[为什么 iOS 的 Masonry 中的 self 不会循环引用?](https://segmentfault.com/q/1010000004343510) UIButton * testButton = [[UIButton alloc] init]; [self.view addSubview:testButton]; testButton.backgroundColor = [UIColor redColor]; [testButton mas_makeConstraints:^(MASConstraintMaker * make) { make.width.equalTo(@100); make.height.equalTo(@100); make.left.equalTo(self.view.mas_left); make.top.equalTo(self.view.mas_top); }]; [testButton bk_addEventHandler:^(id sender) { [self dismissViewControllerAnimated:YES completion:nil]; } forControlEvents:UIControlEventTouchUpInside]; 1234如果我用 blocksKit 的 bk\\_addEventHandler方法，其中使用 strong self，该 viewController 就无法 dealloc，我理解是因为 self → self.view → testButton → self。 但是如果只用 Mansonry 的 mas\\_makeConstraints方法，同样使用 strong self，该 viewController 却能正常 dealloc，请问为什么 Masonry 没有导致循环引用？看到这里，读者应该就应该能回答这个问题了。 - (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block { self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker * maker = [[MASConstraintMaker alloc] initWithView:self]; block(maker); return [maker install]; } 12345678 关于 Masonry，它捕获了变量 self，然后对其执行了 setTranslatesAutoresizingMaskIntoConstraints: 方法。但是，因为执行完毕后，block 会被销毁，没有形成环。所以，没有引起循环依赖。2. strongSelf 上面介绍完了 weakSelf，既然 weakSelf 能完美解决 Retain Circle 的问题了，那为何还需要strongSelf 呢？ 还是先从 AFN 经典说起，以下是 AFN 其中的一段代码： #pragma mark - NSOperation - (void)setCompletionBlock:(void (^)(void))block { [self.lock lock]; if (!block) { [super setCompletionBlock:nil]; } else { __weak __typeof(self)weakSelf = self; [super setCompletionBlock:^ { __strong __typeof(weakSelf)strongSelf = weakSelf; #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group(); dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue(); #pragma clang diagnostic pop dispatch_group_async(group, queue, ^{ block(); }); dispatch_group_notify(group, url_request_operation_completion_queue(), ^{ [strongSelf setCompletionBlock:nil]; }); }]; } [self.lock unlock]; } 12如果 block 里面不加 \\_\\_strong \\_\\_typeof(weakSelf)strongSelf = weakSelf 会如何呢？ #import &quot;ViewController.h&quot; #import &quot;Student.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc]init]; student.name = @&quot;Hello World&quot;; __weak typeof(student) weakSelf = student; student.study = ^{ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;my name is = %@&quot;,weakSelf.name); }); }; student.study(); } 12输出： my name is = (null) 12345678910为什么输出是这样的呢？重点就在 dispatch\\_after 这个函数里面。在 study() 的 block 结束之后，student 被自动释放了。又由于 dispatch_after 里面捕获的 \\_\\_weak 的 student，根据第二章讲过的 \\_\\_weak 的实现原理，在原对象释放之后 \\_\\_weak 对象就会变成 null，防止野指针。所以就输出了 null了。那么我们怎么才能在 weakSelf 之后，block里面还能继续使用 weakSelf 之后的对象呢？究其根本原因就是 weakSelf 之后，无法控制什么时候会被释放，为了保证在 block 内不会被释放，需要添加 \\_\\_strong。在 block 里面使用的 \\_\\_strong 修饰的 weakSelf 是为了在函数生命周期中防止 self 提前释放。strongSelf 是一个自动变量当 block 执行完毕就会释放自动变量 strongSelf 不会对 self 进行一直进行强引用。 #import &quot;ViewController.h&quot; #import &quot;Student.h&quot; @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @&quot;Hello World&quot;; __weak typeof(student) weakSelf = student; student.study = ^{ __strong typeof(student) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@&quot;my name is = %@&quot;,strongSelf.name); }); }; student.study(); } 12输出 my name is = Hello World 123456789101112 至此，我们就明白了 weakSelf、strongSelf 的用途了。 weakSelf 是为了 block 不持有 self，避免 Retain Circle 循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。 strongSelf 的目的是因为一旦进入 block 执行，假设不允许 self 在这个执行过程中释放，就需要加入 strongSelf。block 执行完后这个 strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。 关于 Retain Circle 最后总结一下，有 3 种方式可以解决循环引用。 结合《Effective Objective-C 2.0》(编写高质量 iOS 与 OS X 代码的 52 个有效方法)这本书的例子，来总结一下。**EOCNetworkFetcher.h 文件** typedef void (^ EOCNetworkFetcherCompletionHandler)(NSData * data); @interface EOCNetworkFetcher : NSObject @property (nonatomic, strong, readonly) NSURL * url; (id)initWithURL:(NSURL *)url; (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion; @end12**EOCNetworkFetcher.m 文件** @interface EOCNetworkFetcher () @property (nonatomic, strong, readwrite) NSURL url;@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;@property (nonatomic, strong) NSData downloadData; @end @implementation EOCNetworkFetcher (id)initWithURL:(NSURL *)url{ if (self = [super init]) { _url = url; } return self;} (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion{ self.completionHandler = completion; // 开始网络请求 dispatch_async(dispatch_get_global_queue(0, 0), ^{ _downloadData = [[NSData alloc] initWithContentsOfURL:_url]; dispatch_async(dispatch_get_main_queue(), ^{ // 网络请求完成 [self p_requestCompleted]; }); });} (void)p_requestCompleted{ if(_completionHandler) { _completionHandler(_downloadData); }} @end12**EOCClass.m 文件** @implementation EOCClass{ NSData _fetchedData; EOCNetworkFetcher _networkFetcher;} (void)downloadData{ NSURL * url = [NSURL URLWithString:@”http://www.baidu.com&quot;]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { _fetchedData = data; }];} @end12345678910在这个例子中，存在 3 者之间形成环①、completion handler 的 block 因为要设置 \\_fetchedData 实例变量的值，所以它必须捕获 self 变量，也就是说 handler 块保留了 EOCClass 实例；②、EOCClass 实例通过 strong 实例变量保留了 EOCNetworkFetcher，最后EOCNetworkFetcher 实例对象也会保留了 handler 的 block。书上说的 3 种方法来打破循环。1. 手动释放 EOCNetworkFetcher 使用之后持有的 \\_networkFetcher，这样可以打破循环引用 - (void)downloadData { NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { _fetchedData = data; _networkFetcher = nil; // 加上此行，打破循环引用 }]; } 122. 直接释放 block。因为在使用完对象之后需要人为手动释放，如果忘记释放就会造成循环引用了。如果使用完 completion handler 之后直接释放 block 即可。打破循环引用 - (void)p_requestCompleted { if(_completionHandler) { _completionHandler(_downloadData); } self.completionHandler = nil; // 加上此行，打破循环引用 } 123. 使用 weakSelf、strongSelf - (void)downloadData { __weak __typeof(self) weakSelf = self; NSURL * url = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { __typeof(&amp;*weakSelf) strongSelf = weakSelf; if (strongSelf) { strongSelf.fetchedData = data; } }]; } 123456789101112&lt;center&gt;![](http://www.dzliving.com/wp-content/uploads/2018/11/1194012-59b08429238b088d.png)&lt;/center&gt;#### 7.4 @weakify、@strongify 实现原理上面讲完了 weakSelf、strongSelf 之后，接下来再讲讲 @weakify、@strongify，这两个关键字是 RAC 中避免 Block 循环引用而开发的 2 个宏，这 2 个宏的实现过程很牛，值得我们学习。@weakify、@strongify 的作用和 weakSelf、strongSelf 对应的一样。这里我们具体看看大神是怎么实现这 2 个宏的。直接从源码看起来。 #define weakify(…) \\rac_keywordify \\metamacro_foreach_cxt(rac_weakify_,, weak, VA_ARGS__) #define strongify(…) \\rac_keywordify \\_Pragma(“clang diagnostic push”) \\_Pragma(“clang diagnostic ignored “-Wshadow””) \\metamacro_foreach(rac_strongify_,, VA_ARGS) \\_Pragma(“clang diagnostic pop”)123456看到这种宏定义，咋一看什么都不知道。那就只能一层层的往下看。1. weakify 先从 weakify(...) 开始。 #if DEBUG #define rac_keywordify autoreleasepool {} #else #define rac_keywordify try {} @catch (...) {} #endif 12这里在 debug 模式下使用 @autoreleasepool 是为了维持编译器的分析能力，而使用 @try/@catch 是为了防止插入一些不必要的 autoreleasepool。rac\\_keywordify 实际上就是autoreleasepool &#123;&#125;的宏替换。因为有了 autoreleasepool &#123;&#125;的宏替换，所以 weakify 要加上 @，形成 @autoreleasepool &#123;&#125;。 #define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, ...) \\ metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__) 1234\\_\\_VA\\_ARGS\\_\\_：总体来说就是将左边宏中 ... 的内容原样抄写在右边 \\_\\_VA\\_ARGS\\_\\_ 所在的位置。它是一个可变参数的宏，是新的 C99 规范中新增的，目前似乎只有 gcc支持(VC 从 VC2005 开始支持)。那么我们使用 @weakify(self) 传入进去。\\_\\_VA\\_ARGS\\_\\_ 相当于 self。此时我们可以把最新开始的 weakify 套下来。于是就变成了这样： rac_weakify_,, __weak, __VA_ARGS__ 整体替换 MACRO, SEP, CONTEXT, ... 1234这里需要注意的是，源码中就是给的两个\",\"逗号是连着的，所以我们也要等效替换参数，相当于 SEP 是空值。替换完成之后就是下面这个样子： autoreleasepool {} metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self))(rac_weakify_, , __weak, self) 1234现在我们需要弄懂的就是 metamacro\\_concat 和 metamacro\\_argcount 是干什么用的。继续看看 metamacro_concat 的实现 #define metamacro_concat(A, B) \\ metamacro_concat_(A, B) #define metamacro_concat_(A, B) A ## B 12345\\#\\# 是宏连接符。举个例子：假设宏定义为 #define XNAME(n) x##n，代码为：XNAME(4)，则在预编译时，宏发现XNAME(4) 与 XNAME(n) 匹配，则令 n 为 4，然后将右边的 n 的内容也变为 4，然后将整个XNAME(4) 替换为 x##n，亦即 x4，故最终结果为 XNAME(4) 变为 x4。所以 A##B 就是 AB。**metamacro_argcount 的实现** #define metamacro_argcount(...) \\ metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) #define metamacro_at(N, ...) \\ metamacro_concat(metamacro_at, N)(__VA_ARGS__) 12metamacro\\_concat 是上面讲过的连接符，那么 metamacro\\_at，N = metamacro\\_atN，由于 N = 20，于是 metamacro\\_atN = metamacro\\_at20。 #define metamacro_at0(...) metamacro_head(__VA_ARGS__) #define metamacro_at1(_0, ...) metamacro_head(__VA_ARGS__) #define metamacro_at2(_0, _1, ...) metamacro_head(__VA_ARGS__) #define metamacro_at3(_0, _1, _2, ...) metamacro_head(__VA_ARGS__) #define metamacro_at4(_0, _1, _2, _3, ...) metamacro_head(__VA_ARGS__) #define metamacro_at5(_0, _1, _2, _3, _4, ...) metamacro_head(__VA_ARGS__) #define metamacro_at6(_0, _1, _2, _3, _4, _5, ...) metamacro_head(__VA_ARGS__) #define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, ...) metamacro_head(__VA_ARGS__) #define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, ...) metamacro_head(__VA_ARGS__) #define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, ...) metamacro_head(__VA_ARGS__) #define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) metamacro_head(__VA_ARGS__) #define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, ...) metamacro_head(__VA_ARGS__) #define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, ...) metamacro_head(__VA_ARGS__) #define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, ...) metamacro_head(__VA_ARGS__) #define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, ...) metamacro_head(__VA_ARGS__) #define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, ...) metamacro_head(__VA_ARGS__) #define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, ...) metamacro_head(__VA_ARGS__) #define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, ...) metamacro_head(__VA_ARGS__) #define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, ...) metamacro_head(__VA_ARGS__) #define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, ...) metamacro_head(__VA_ARGS__) #define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__) 12metamacro\\_at20 的作用就是截取前 20 个参数，剩下的参数传入 metamacro\\_head。 #define metamacro_head(...) \\ metamacro_head_(__VA_ARGS__, 0) #define metamacro_head_(FIRST, ...) FIRST 12metamacro\\_head 的作用返回第一个参数。返回到上一级 metamacro\\_at20，如果我们从最源头的 @weakify(self)，传递进来，那么 metamacro\\_at20(self, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)，截取前 20 个参数，最后一个留给metamacro\\_head\\_(1)，那么就应该返回 1。 metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self)) = metamacro_concat(metamacro_foreach_cxt, 1) 1234最终可以替换成 metamacro\\_foreach\\_cxt1。在源码中继续搜寻。 // metamacro_foreach_cxt expansions #define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT) #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) #define metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \\ metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) \\ SEP \\ MACRO(1, CONTEXT, _1) #define metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \\ metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \\ SEP \\ MACRO(2, CONTEXT, _2) #define metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \\ metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \\ SEP \\ MACRO(3, CONTEXT, _3) #define metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \\ metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \\ SEP \\ MACRO(4, CONTEXT, _4) #define metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \\ metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \\ SEP \\ MACRO(5, CONTEXT, _5) #define metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \\ metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \\ SEP \\ MACRO(6, CONTEXT, _6) #define metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \\ metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \\ SEP \\ MACRO(7, CONTEXT, _7) #define metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \\ metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \\ SEP \\ MACRO(8, CONTEXT, _8) #define metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \\ metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \\ SEP \\ MACRO(9, CONTEXT, _9) #define metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \\ metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \\ SEP \\ MACRO(10, CONTEXT, _10) #define metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \\ metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \\ SEP \\ MACRO(11, CONTEXT, _11) #define metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \\ metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \\ SEP \\ MACRO(12, CONTEXT, _12) #define metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \\ metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \\ SEP \\ MACRO(13, CONTEXT, _13) #define metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \\ metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \\ SEP \\ MACRO(14, CONTEXT, _14) #define metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \\ metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \\ SEP \\ MACRO(15, CONTEXT, _15) #define metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \\ metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \\ SEP \\ MACRO(16, CONTEXT, _16) #define metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \\ metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \\ SEP \\ MACRO(17, CONTEXT, _17) #define metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \\ metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \\ SEP \\ MACRO(18, CONTEXT, _18) #define metamacro_foreach_cxt20(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \\ metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \\ SEP \\ MACRO(19, CONTEXT, _19) 12metamacro\\_foreach\\_cxt 这个宏定义有点像递归，这里可以看到 N 最大就是 20，于是metamacro\\_foreach\\_cxt19 就是最大，metamacro\\_foreach\\_cxt19 会生成rac\\_weakify\\_(0,\\_\\_weak,\\_18)，然后再把前 18 个数传入 metamacro\\_foreach\\_cxt18，并生成rac\\_weakify\\_(0,\\_\\_weak,\\_17)，依次类推，一直递推到 metamacro\\_foreach\\_cxt0。 #define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT) 1234metamacro\\_foreach\\_cxt0 就是终止条件，不做任何操作了。于是最初的 @weakify 就被替换成 autoreleasepool {} metamacro_foreach_cxt1(rac_weakify_, , __weak, self) #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) 12代入参数 autoreleasepool {} rac_weakify_（0,__weak,self） 12最终需要解析的就是 rac\\_weakify\\_ #define rac_weakify_(INDEX, CONTEXT, VAR) \\ CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR); 12把 (0,__weak,self) 的参数替换进来 (INDEX, CONTEXT, VAR)。 INDEX = 0， CONTEXT = __weak，VAR = self， 12于是 CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR); 12等效替换为 __weak __typeof__(self) self_weak_ = self; 12345678 最终 @weakify(self) = \\_\\_weak \\_\\_typeof\\_\\_(self) self\\_weak\\_ = self; 这里的 self\\_weak\\_ 就完全等价于我们之前写的 weakSelf。2. strongify 再继续分析 strongify(...) rac_keywordify 还是和 weakify 一样，是 autoreleasepool &#123;&#125;，只为了前面能加上 @ _Pragma(&quot;clang diagnostic push&quot;) \\ _Pragma(&quot;clang diagnostic ignored &quot;-Wshadow&quot;&quot;) \\ _Pragma(&quot;clang diagnostic pop&quot;) 123456strongify 比 weakify 多了这些 _Pragma 语句。关键字 _Pragma 是 C99 里面引入的。_Pragma 比 #pragma(在设计上)更加合理，因而功能也有所增强。上面的等效替换 #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wshadow&quot; #pragma clang diagnostic pop 1234这里的 clang 语句的作用：忽略当一个局部变量或类型声明遮盖另一个变量的警告。最初的 #define strongify(...) \\ rac_keywordify \\ _Pragma(&quot;clang diagnostic push&quot;) \\ _Pragma(&quot;clang diagnostic ignored &quot;-Wshadow&quot;&quot;) \\ metamacro_foreach(rac_strongify_,, __VA_ARGS__) \\ _Pragma(&quot;clang diagnostic pop&quot;) 12strongify 里面需要弄清楚的就是 metamacro\\_foreach 和 rac\\_strongify\\_。 #define metamacro_foreach(MACRO, SEP, ...) \\ metamacro_foreach_cxt(metamacro_foreach_iter, SEP, MACRO, __VA_ARGS__) #define rac_strongify_(INDEX, VAR) \\ __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); 12我们先替换一次，SEP = 空 ， MACRO = rac\\_strongify\\_ ， \\_\\_VA\\_ARGS\\_\\_ , 于是替换成这样。 metamacro_foreach_cxt(metamacro_foreach_iter,,rac_strongify_,self) 1234根据之前分析，metamacro\\_foreach\\_cxt 再次等效替换，metamacro\\_foreach\\_cxt##1(metamacro\\_foreach\\_iter,,rac\\_strongify\\_,self)根据 #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) 1234再次替换成 metamacro\\_foreach\\_iter(0, rac\\_strongify\\_, self)继续看看 metamacro\\_foreach\\_iter 的实现 #define metamacro_foreach_iter(INDEX, MACRO, ARG) MACRO(INDEX, ARG) 12最终替换成 rac\\_strongify\\_(0,self) #define rac_strongify_(INDEX, VAR) \\ __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); 12INDEX = 0, VAR = self, 于是 @strongify(self) 就等价于 __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); 12等价于 __strong __typeof__(self) self = self_weak_; 1234注意 @strongify(self) 只能使用在 block 中，如果用在 block 外面，会报错，因为这里会提示你 ``Redefinition of 'self'``。**实例** #ifndef weakify #if DEBUG // 判断当前代码运行模式 #if __has_feature(objc_arc) // 判断 ARC 环境 #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object; // ## 为连接符 #else #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object; #endif // 结束 if _has_feature() #else #if __has_feature(objc_arc) #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object; #endif // 结束 if _has_feature() #endif // 结束 if DEBUG #endif // 结束 ifndef weakify #ifndef strongify #if DEBUG #if __has_feature(objc_arc) #define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object; #else #define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object; #endif #else #if __has_feature(objc_arc) #define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object; #else #define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object;、#endif #endif #endif 123. 总结 @weakify(self) = @autoreleasepool{} __weak __typeof__ (self) self_weak_ = self; @strongify(self) = @autoreleasepool{} __strong __typeof__(self) self = self_weak_; 1234567891011121314 经过分析以后，其实 @weakify(self) 和 @strongify(self) 就是比我们日常写的 weakSelf、strongSelf 多了一个 @autoreleasepool&#123;&#125; 而已，至于为何要用这些复杂的宏定义来做，目前我还没有理解。如果有大神指导其中的原因，还请多多指点。## 八、问题1. block 原理是什么？本质是什么？ **封装了函数调用以及调用环境的 OC 对象。**2. Block 属性的修饰词为什么是 copy？\\_\\_block 的作用是什么？有什么注意的点？ 一旦没有进行 copy 操作，block 就不会在堆上。\\_\\_block 能够修改自动变量的值。注意循环引用。3. block 修改 NSMutableArray 时，是否需要添加 \\_\\_block？ { NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:@&quot;a&quot;, @&quot;b&quot;, @&quot;abc&quot;, nil]; NSMutableArray * mArr2 = [NSMutableArray arrayWithCapacity:mArr1.count]; [mArr1 enumerateObjectsUsingBlock: ^(NSString * obj, NSUInteger idx, BOOL *stop){ [mArr2 addObject:@(obj.length)]; }]; NSLog(@&quot;%@&quot;, mArr2); } 2018-12-03 00:24:41.754700+0800 Demo[13081:1899280] ( 1, 1, 3 ) ``` 这里确实没有修改 mArr2 这个局部变量。mArr2 是一个指针，指向一个可变长度的数组。在 block 里面，并没有修改这个指针，而是修改了这个指针指向的数组。换句话说，mArr2 保存的是一块内存区域的地址，在 block 里，并没有改变这个地址，而是读取出这个地址，然后去操作这块地址空间的内容。 因为声明 block 的时候实际上是把当时的临时变量又复制了一份，在 block 里即使修改了这些复制的变量，也不影响外面的原始变量。即所谓的闭包。 但是当变量是一个指针的时候，block 里只是复制了一份这个指针，两个指针指向同一个地址。所以，在 block 里面对指针指向内容做的修改，在 block 外面也一样生效。 九、学习文章宁夏灼雪__ &amp; iOS底层day6 - 探索blockhttp://blog.csdn.net/qq_30513483/article/details/52587551","tags":[]},{"title":"Category","date":"2019-10-24T01:06:24.298Z","path":"2019/10/24/iOS/iOS原理/Category/","text":"分类可以拓展类的属性、方法、协议等信息 一、底层结构在 objc-4 的源码中，搜索 category_t 可以看到: 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。 在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： objc-os.mm _objc_init() map_images() map_images_nolock() objc-runtime-new.mm _read_images() remethodizeClass() attachCategories() attachLists() realloc、memmove、memcpy 最终可以找到这个方法 attachCategories 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); // 判断是否元类 bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /* 方法数组 @[ @[method_t, method_t], @[method_t .....] ] */ method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); /* 属性数组 @[ @[property_t, property_t], @[property_t .....] ] */ property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); /* 协议数组 @[ @[peotocol_t, peotocol_t], @[peotocol_t .....] ] */ protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[I]; // 将所有分类的对象方法，附加到类对象列表中 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 将所有分类的属性，附加到类属性列表中 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 将所有分类的协议，附加到类协议列表中 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。 二、Category和Class Extension 的区别123456Class Extension:@interface Person ()@property (nonatomic, assign) int sex;- (void)isBig;@end 将属性、方法等封装在 .m 文件里面，类似 private 的应用。 区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。 三、+ Load 和 +initialize 方法的区别Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次） 四、objc_msgSend() 方法实现在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的 12345678910111213141516171819202122232425262728/******************************************************************** * * id objc_msgSend(id self, SEL _cmd, ...); * IMP objc_msgLookup(id self, SEL _cmd, ...); * * objc_msgLookup ABI: * IMP returned in x17 * x16 reserved for our use but not used * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class 但是可以大概猜出它的实现思路: 由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断； 通过 isa 寻找类/元类对象，寻找方法调用； 如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。 五、文章宁夏灼雪__ &amp; iOS底层day4 - 探索Category的实现","tags":[]},{"title":"Bitcode","date":"2019-10-24T01:06:24.297Z","path":"2019/10/24/iOS/iOS原理/Bitcode/","text":"一、前言苹果在 WWDC2015 大会上引入了 bitcode，随后在 Xcode7 中添加了在二进制中嵌入 bitcode(Enable Bitcode) 的功能，并且默认设置为开启状态。 在 What is app thinning? (iOS, tvOS, watchOS) 一节中有以下定义： Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store. bitcode 是被编译程序的一种中间形式的代码。包含 bitcode 配置的程序将会在 iTunes Connect 上被编译和链接。bitcode 允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到 store 上。 Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary. 当提交程序到 App Store 上时，Xcode 会将程序编译为一个中间表现形式(bitcode)。然后 App Store 会再将这个 bitcode 编译为可执行的 64 位或 32 位程序。 来个直观图就可以明白了： 这样可以减少包的大小。 二、什么是 BitcodeBitcode 是由 LLVM 引入的一种中间代码(Intermediate Representation，简称 IR)，它是源代码被编译为二进制机器码过程中的中间表示形态，它既不是源代码，也不是机器码。从代码组织结构上看它比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。 LLVM 是一套优秀的编译器框架，目前 NDK/Xcode 均采用 LLVM 作为默认的编译器。LLVM 的编译过程可以简单分为 3 个部分: 前端(Frontend)负责把各种类型的源代码编译为中间表示，也就是 Bitcode。在 LLVM 体系内，不同的语言有不同的编译器前端，最常见的如 clang 负责 c/c++/oc 的编译，flang 负责 fortran 的编译，swiftc 负责 swift 的编译等等; 优化(Optimizer)负责对 Bitcode 进行各种类型的优化，将 bitcode 代码进行一些逻辑等价的转换，使得代码的执行效率更高，体积更小，比如 DeadStrip/SimplifyCFG。 后端(Backend)也叫 CodeGenerator，负责把优化后的 bitcode 编译为指定目标架构的机器码，比如 X86Backend 负责把 bitcode 编译为 x86 指令集的机器码。 在这个体系中，不同语言的源代码将会被转化为统一的 bitcode 格式，三个模块可以充分复用，防止重复造轮子。如果要开发一门新的语言 x，只需要造一个 x 语言的前端，将 x 语言的源代码编译为 bitcode，优化和后端的事情完全不用管。同理，如果新的芯片架构问世，则只需要基于 LLVM 重新写一套目标平台的后端，非常方便。 三、Bitcode 配置 You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64 要么让所有引入的第三方库都支持 bitcode，要么关闭 target 的 bitcode 选项。 在最新的 Xcode 中，新建项目默认就打开了 bitcode 设置，这导致在不知情的情况下出现项目编译失败，而这些因为 bitcode 而编译失败的的项目都链接了第三方二进制的库或者框架(.a、.framework)，而编译失败的原因就是，这些框架或者库恰好没有设置 bitcode。所以每当遇到这个情况时候大部分人都是直接设置 Xcode 关闭 bitcode 功能，全部不生成 bitcode。 |平台|bitcode||:——-:|:——:||iOS|可选的||watchOS|必须的||Mac OS|不支持| 四、苹果的要求 为什么苹果默认要求 watchOS 和 tvOS 的 App 要上传 bitcode？ 因为把 bitcode 上传到苹果的中心服务器后，它可以为目标安装 App 的设备进行优化二进制，减小安装包的下载大小。当然 iOS 开发者也可以上传多个版本而不是打包到单个包里，但这样会占用更多的存储空间。最重要的是允许苹果可以在后台服务器对应用程序进行签名，而不用导出任何密钥到终端开发者那。 上传到服务器的 bitcode 给苹果带来更好处是：以后新设计了新指令集的新 CPU，可以继续从这份 bitcode 开始编译出新 CPU 上执行的可执行文件，以供用户下载安装。 bitcode 给开发者带来的不便之处：没用 bitcode 之前，当应用程序崩溃后，开发者可以根据获取的的崩溃日志再配上上传到苹果服务器的二进制文件的调试符号表信息，还原程序运行过程到崩溃时后调用栈信息，对问题进行定位排查。但用了 bitcode 之后，用户安装的二进制不是开发者这边生成的，而是苹果服务器经过优化后生成的，其对应的调试符号信息丢失了，也就无法进行前面说的还原崩溃现场找原因了。 打开 BitCode 时，在iTunes Connect 里”我的App”-&gt;项目-&gt;活动-&gt;所有构建版本-&gt;具体版本的”综合信息”下”包含符号”那里可以下载到 dSYM 文件。（待验证） 相当于在编译的时候加一个标记：embed-bitcode-marker(调试构建) embed-bitcode(打包/真机构建)。这个在 clang 编译器的参数是 -fembed-bitcode，swift 编译器的参数是 -embed-bitcode。 五、拓展知识目前苹果采用的编译器工具链是 LLVM，Bitcode 是 LLVM 编译器的中间代码的一种编码。LLVM 的前端可以理解为 C/C++/OC/Swift 等编程语言，后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据，那么 BitCode 就是位于这两者之间的中间码。 LLVM 的编译工作原理是前端负责把项目程序源代码翻译成 Bitcode 中间码，然后再根据不同目标机器芯片平台转换为相应的汇编指令以及翻译为机器码。这样设计就可以让 LLVM 成为了一个编译器架构，可以轻而易举的在 LLVM 架构之上发明新的语言(前端)，以及在 LLVM 架构下面支持新的 CPU(后端)指令输出。虽然 Bitcode 仅仅只是一个中间码，不能在任何平台上运行，但是它可以转化为任何被支持的 CPU 架构，包括还未被发明的 CPU 架构，也就是说现在打开 Bitcode 功能提交一个 App 到应用商店，如果以后苹果使用全新设计的 CPU，在苹果后台服务器一样可以从这个 App 的 Bitcode 开始编译转化为新 CPU 上的可执行程序，可供新手机用户下载运行这个 App。 在 iPhone 出来之前，苹果主要的编译器技术是用经过稍微改进的 GCC 工具链来把 Objective-C 语言编写的代码编译出所指定的机器处理器上原生的可执行程序。编译器产生的可执行程序叫做”Fat Binaries”–类似于 Windows 中 PE 格式的 exe 和 Linux 下的 ELF 格式的二进制。 区别是，一个”Fat Binary”可以包含同一个程序的很多版本，所以同一个可执行文件可以在不同的处理器上运行。主要就是这个技术让苹果的硬件很容易的从 PowerPC 迁移到 PowerPC64 的处理器，以及后来再迁移到 Intel 和 Intel64 处理器。这个方案带来的负面影响就是同一个文件中存了多份可执行代码，除了当前机器可执行的那一份之外其他都是无用的，这个在市场上被称为”Universal Binary”。在苹果从 PowerPC 迁移到 Intel 处理器的事情开始存在的(一个二进制文件包含一份 PowerPC 版本和一份 Intel 版本)。慢慢的后来又支持同时包含 Intel 32bit 和 Intel 64bit。 在一个 Fat binary 中，有操作系统运行时根据处理器类型动态选择正确的二进制版本来运行，但是应用程序要支持不同平台的处理器的话，应用程序本身要多占用一些空间。当然也有一些瘦身的工具，比如 lipo，可以用来移除那些当前机器中不被支持的或者多余的可执行代码达到瘦身目的，lipo不会改变程序执行逻辑，仅仅只是文件的大小瘦身。 随着移动设备移动互联网的深入发展，程序大小变得越来越重要了。主要是因为移动设备中不会有电脑上那么大的硬盘驱动器，还有就是苹果早就从原始的 ARM 处理器迁移到自家设计的 A4、A5、A5X、A6、A7、A8、A8X、A9、A9X 以及后续的 A10 处理器，它们的指令集已经发生了改变和原始 ARM 设计的有所区别，iOS 操作系统底层以及 Xcode/LLVM 编译工具一定程度上透明了这些变化，编译出来的程序会包含很多执行代码版本。面对这个问题，苹果投入大量成本迁移到 LLVM 编译器架构并使用 bitcode 的必要性越来越大。从最开始的把 OPENGL 编译为特定的 GPU 指令到把 Clang 编译器(LLCM的C/OC编译前端)支持 Objective-C 的改进并作为 Xcode 的默认编译器。 LLVM 提供了一个虚拟指令集机制，它可以翻译出指定的所支持的处理器架构的执行代码(机器码)。这个就使得为 iOS 应用程序的编译开发一个完全基于 LLVM 架构的工具链成为可能。而 LLVM 的这个虚拟的通用的指令集可以用很多种表示格式： 叫做 IR 的文本表示的汇编格式（像汇编语言） 转换为二进制数据表示的格式（像目标代码），这个二进制格式就是我们所说的 bitcode。 Bitcode 和传统的可执行指令集不同，它维护的是函数功能的类型和签名。比如，传统可执行指令集中，一系列(&lt;=8)的布尔值可以压缩存储到单个字节中，但是在 bitcode 中它们是各自独自表示的；此外，逻辑运算操作(比如寄存器清零操作)也有它们对应的逻辑表示方法($R=0)，当这些 BitCode 要转换为特定机器平台的指令集时，它可以用经过针对特定机器平台优化过的汇编指令来代替：xor eax, eax。（这个汇编指令同样是寄存器清零操作）。然而 bitcode 也不是完全独立于处理器平台和调用约定的，寄存器的大小在指令集中是一个相当重要的特性。众所周知，64bit 寄存器可以比 32bit 寄存器存储更多的数据，生成 64bit 平台的 bitcode 和 32bit 平台的是明显不同的；还有，调用约定可以根据函数定义或者函数调用来定义，这些可以确定函数的参数传递是传寄存器值还是压栈。一些编程语言还有如 sizeof(long) 这样的预处理指令，这些将在 bitcode 生成之前前被翻译。一般情况下，对于支持 fastcc(fast calling convention)调用的 64bit 平台会生成与其一致的 bitcode 代码。## 六、初探既然 bitcode 是代码的一种表示形式，因此它也会有自己的一套独立的语法，可以通过一个简单的例子来一探究竟，这里以 clang 为例，swift 的操作和结果可能稍有不同。1. 先编写一段 c 语言代码(test.c)： 123456#include &lt;stdio.h&gt;int main(void)&#123; printf(\"hello, world.\\\\n\"); return 0;&#125;2. 通过以下命令可以将源代码编译为 object 文件。 123$ clang -c test.c -o test.o$ file test.otest.o: Mach-O 64-bit object x86_64 这个命令同时完成了前端、优化、后端，可以通过 -emit-llvm -c 将前端这一步单独拆出来，这样就可以看到 bitcode 了。 12345678910111213$ clang -emit-llvm -c test.c -o test.bc # 将源代码编译为 bitcode$ clang -c test.bc -o test.bc.o # 将 bitcode 编译为 object$ clang -emit-llvm -c test.c -o test.bc$ file test.bctest.bc: LLVM bitcode, wrapper x86_64$ clang -c test.bc -o test.bc.o$ file test.bc.otest.bc.o: Mach-O 64-bit object x86_64$ md5 test.bc.o test.oMD5 (test.bc.o) = 9b90026b9c1d3fa0211e106ff921e9bdMD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bd bitcode 文件使用后缀名 .bc 表示。可以看到，将 bitcode 文件作为 clang 的输入，编出的 object 文件跟直接编源代码是相同的。3. 查看 bitcode 文件。 1234567891011$ hexdump -C test.bc | head00000000 de c0 17 0b 00 00 00 00 14 00 00 00 90 09 00 00 |................|00000010 07 00 00 01 42 43 c0 de 35 14 00 00 07 00 00 00 |....BC..5.......|00000020 62 0c 30 24 94 96 a6 a5 f7 d7 7f 4f d3 3e ed df |b.0$.......O.&gt;..|00000030 bd 6f ff b4 10 05 c8 14 00 00 00 00 21 0c 00 00 |.o..........!...|00000040 58 02 00 00 0b 82 20 00 02 00 00 00 13 00 00 00 |X..... .........|00000050 07 81 23 91 41 c8 04 49 06 10 32 39 92 01 84 0c |..#.A..I..29....|00000060 25 05 08 19 1e 04 8b 62 80 10 45 02 42 92 0b 42 |%......b..E.B..B|00000070 84 10 32 14 38 08 18 4b 0a 32 42 88 48 90 14 20 |..2.8..K.2B.H.. |00000080 43 46 88 a5 00 19 32 42 e4 48 0e 90 11 22 c4 50 |CF....2B.H...\".P|00000090 41 51 81 8c e1 83 e5 8a 04 21 46 06 51 18 00 00 |AQ.......!F.Q...| 通过 hexdump 可以看出它并非文本文件，全是乱码，这样的文件是很难分析的。其实 LLVM 提供了 llvm-dis/llvm-as 两个工具，用于将 bitcode 在二进制格式和可读的文本格式之间进行相互的转化，但遗憾的是 Xcode 的编译器工具链中并没有附带这个命令，因此需要另寻他法。4. 我们知道通过编译器的 -S 参数可以将源代码编译为文本的 assembly 代码，不进行最后一步 assembly 到机器码的翻译工作，而 assembly 和机器码是等价的两种表示形式，bitcode 同样也是有文本和二进制(bitcode)两种等价表示形式，clang 也为 bitcode 保留了这一特性，可以通过 -emit-llvm -S 将源代码编译为文本格式的 bitcode， 也叫做 LLVM Assembly Language，一般后缀名使用 .ll。 1$ clang -emit-llvm -S test.c -o test.ll \\# 将源代码编译为 LLVM Assembly test.ll 可用文本编辑器打开，全部内容： 12345678910111213141516171819202122232425; ModuleID = 'test.c'source_filename = \"test.c\"target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"target triple = \"x86_64-apple-macosx10.13.0\"@.str = private unnamed_addr constant \\[15 x i8\\] c\"hello, world.\\\\0A\\\\00\", align 1; Function Attrs: noinline nounwind ssp uwtabledefine i32 @main() #0 &#123; %1 = alloca i32, align 4 store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds (\\[15 x i8\\], \\[15 x i8\\]* @.str, i32 0, i32 0)) ret i32 0&#125;declare i32 @printf(i8*, ...) #1attributes #0 = &#123; noinline nounwind ssp uwtable \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"penryn\" \"target-features\"=\"+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" &#125;attributes #1 = &#123; \"correctly-rounded-divide-sqrt-fp-math\"=\"false\" \"disable-tail-calls\"=\"false\" \"less-precise-fpmad\"=\"false\" \"no-frame-pointer-elim\"=\"true\" \"no-frame-pointer-elim-non-leaf\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"false\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"penryn\" \"target-features\"=\"+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" &#125;!llvm.module.flags = !&#123;!0&#125;!llvm.ident = !&#123;!1&#125;!0 = !&#123;i32 1, !\"PIC Level\", i32 2&#125;!1 = !&#123;!\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"&#125; 这样看上去就很清晰明了了，我们重点关注下函数定义这部分，加了一些注释方便理解。 123456789101112; 定义全局常量 @.str, 内容初始化为 'hello, world.\\\\n\\\\0'@.str = private unnamed_addr constant \\[15 x i8\\] c\"hello, world.\\\\0A\\\\00\", align 1; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 &#123; ; 定义函数 @main，返回值为i32类型 %1 = alloca i32, align 4 ; 声明变量 %1 = 分配i32的内存空间 store i32 0, i32* %1, align 4 ; 将 0 存入 %1 的内存空间 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds (\\[15 x i8\\], \\[15 x i8\\]* @.str, i32 0, i32 0)) ; 调用 @printf 函数，并将 @.str 的地址作为参数 ret i32 0 ; 返回 0&#125;declare i32 @printf(i8*, ...) #1 ; 声明一个外部函数 @printf 这段代码不难阅读， 其含义和逻辑与我们所写的源代码基本一致，只是用了另外一种语法表示出来。因为没有经过优化，函数中的前两条语句其实是多余的，这在之后的优化阶段会被消除(dead_strip)。bitcode 的具体语法在此不做展开，虽然这个例子看起来非常简单易懂，但真实场景中，bitcode 的语法远比这个复杂，有兴趣的同学可以直接阅读 LLVM Language Reference Manual。## 七、代码验证1. 在 Objective-C 代码中实现 c 方法 1234567891011121314151617@implementation Testvoid Greeting(void)&#123; NSLog(@\"hello world!\");&#125;@end@implementation Demovoid Demo(void)&#123; NSLog(@\"demo func!\");&#125;@end2. 用 Clang 编译成 ARM64 格式且带 bitcode 的目标文件 Test.o Demo.o。 1xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c Test.m Demo.m3. 把两个目标文件打包为一个静态库文件。 1xcrun -sdk iphoneos ar-r libTest.a Test.o Demo.o4. 用 Shell 命令 otool 查看静态库文件是否包含 bitcode 段。 1otool -l Test.o | grep bitcode 或 otool -l libTest.a | grep bitcode 如果输出了 2 行 sectname __bitcode，就是说明这个静态库中的两个目标文件包含了 bitcode。5. 用下面的命令把 Demo.m 的 C 代码转换为 ARM64 汇编语言格式 demo.s。 1xcrun -sdk iphoneos clang -arch arm64 -S Demo.m6. 删除 Demo.m，仅留下 Test.m 和 Demo.s。 1rm Demo.m 或者手动在目录中删除7. 把 Test.m 和 Dmeo.s 这个汇编源代码来一起带着 -fembed-bitcode 参数来生成目标代码并打包为一个静态库。 123xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c Test.m Demo.sxcrun -sdk iphoneos ar -r libTest.a Test.o Demo.o8. 再运行 otool 工具来检查这个新的静态库中包含的 2 个目标文件是否都带有 bitcode 段。 1otool -l libTest.a | grep bitcode 从上可以看到，包含 Test.o、Demo.o 的静态库有两行 sectname __bitcode 输出，包含 Test.o、Demo.s 的静态库只有一行输出。这就说明从 ARM64 汇编语言编译过来的目标文件 Demo.s 不带有 bitcode 段，哪怕在编译的时候指定了参数 -fembed-bitcode 也没有用。结论： bitcode 的生成是由汇编语言以上的上层语言编译而来，它是上层语言与汇编语言(机器语言)之间的一个中间码。 目前日常的 iOS 应用开发中，一般不会需要用到汇编层面去优化的代码，所以我们主要关注第三方(开源)C代码，尤其是音视频编码解码这些计算密集型项目代码，关键计算的代码针对特定平台都有对应平台的汇编版本实现，当然也有 C 的实现，但是默认编译一般都是用的汇编版本，这样就会导致我们在编译这个开源代码的时候哪怕你带了 -fembed-bitcode 参数也仅仅只是让项目中的部分 C 代码的目标文件带了 bitcode 段，而那少数的汇编代码的目标文件一样不带 bitcode 段，这样编译出这个库交给上层开发者使用的时候，就会出现在打包上传或者真机调试的时候因为 Xcode 默认开了 bitcode 功能而链接失败，导致不能真机调试或者不能上传应用到 AppStore。（需要再研究） .s 也是支持 -fembed-bitcode 的，只是并非真正带了 bitcode(通过 .s 无法编译出 bitcode)，只是在 .o 里做了标记以兼容 bitcode 模式。 八、Enable Bitcode在对 bitcode 有了一个直观的认识之后，再来看一下 Apple 围绕 bitcode 做了什么。Xcode 中对 Enable Bitcode 这个配置的解释是 Xcode Help： Enable Bitcode (ENABLE_BITCODE) Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode. 具体展开一下： 开启此设置将会在支持的平台和架构中开启 bitcode 当前支持的平台主要是 iPhoneOS(armv7/arm64)，watchOS 等； 注意不包括 iPhoneSimulator(i386/x86_64) 和 macos，也就是说模拟器架构下不会编出 bitcode。这个限制只是 Xcode 自身的限制，并非编译器的限制，我们使用编译器提供的命令行工具自行操作仍然可以编译出这些架构下的bitcode，本文中的示例就是基于 macos 平台/x86_64 架构。 进行 Archive 时，bitcode 会被嵌入到链接后的二进制文件中，用于提交给 App Store Enable Bitcode 设置为 YES 时，从编译日志中可以看出，Archive 时多了一个编译参数 -fembed-bitcode 进行其他类型的 Build(非 Archive)时，编译器只会检查是否满足开启 bitcode 的条件，但并不会真正生成 bitcode 非 Archive 编译时，Enable Bitcode 将会增加编译参数 -fembed-bitcode-marker， 只是在 object 文件中做了标记，表明可以有 bitcode，但是现在暂时没有带上它。因为本地编译调试时并不需要 bitcode，只有 AppStore 需要这玩意儿，去掉这个不必要的步骤，会加快编译速度。 这就是为什么有的同学在开发 SDK 时，明明开启了 Enable Bitcode，交给客户后客户却说：你的 sdk 里没有bitcode，因为你没有使用 Archive 方式打包。 当然，你可以将 Enable Bitcode 设置为 NO， 然后在 Other Compiler Flags 和 Other Linker Flags 中手动为真机架构添加 -fembed-bitcode 参数，这样任何类型的 Build 都会带上 bitcode。 接下来看一下 Enable Bitcode 之后，编译出的文件发生了什么变化， 直接在 clang 的参数中添加 -fembed-bitcode 即可。 1$ clang -fembed-bitcode -c test.c -o test_bitcode.o 编译之后可以通过 otool 工具查看 object 文件的结构，此时你需要对 Mach-O 文件有一些基本的了解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374otool -l test_bitcode.otest_bitcode.o:Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 1 4 672 0x00002000Load command 0 cmd LC\\_SEGMENT\\_64 cmdsize 552 segname vmaddr 0x0000000000000000 vmsize 0x0000000000000a88 fileoff 704 filesize 2696 maxprot 0x00000007 initprot 0x00000007 nsects 6 flags 0x0Section sectname __bitcode segname __LLVM addr 0x0000000000000040 size 0x00000000000009a0 offset 768 align 2^4 (16) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Section sectname __cmdline segname __LLVM addr 0x00000000000009e0 size 0x0000000000000042 offset 3232 align 2^4 (16) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Load command 1 cmd LC\\_VERSION\\_MIN_MACOSX cmdsize 16 version 10.13 sdk n/aLoad command 2 cmd LC_SYMTAB cmdsize 24 symoff 3424 nsyms 4 stroff 3488 strsize 56Load command 3 cmd LC_DYSYMTAB cmdsize 80 ilocalsym 0 nlocalsym 2 iextdefsym 2 nextdefsym 1 iundefsym 3 nundefsym 1 tocoff 0 ntoc 0 modtaboff 0 nmodtab 0 extrefsymoff 0 nextrefsyms 0 indirectsymoff 0 nindirectsyms 0 extreloff 0 nextrel 0 locreloff 0 nlocrel 0 或者使用 MachOView 软件。 可以发现生成的 object 文件中多了两个 Section，分别是 __LLVM,__bitcode 和 __LLVM,__cmdline，并且 otool 的输出中给出了这两个 section 在 object 文件中的偏移和大小，通过 dd 命令可以很方便地将这两个 Section 提取出来（待验证） 123$ dd bs=1 skip=768 count=0x00000000000009a0 if=test_bitcode.o of=test_bitcode.o.bc$ dd bs=1 skip=3608 count=0x0000000000000042 if=test_bitcode.o of=test_bitcode.o.cmdline 还有一种更便捷的方式，Xcode 提供的 segedit 命令可以直接将指定的 Section 导出，只需要给定 Section 的名字，和上面的命令效果是一样的，并且更为方便。 12345$ segedit -extract __LLVM __bitcode test_bitcode.o.bc -extract __LLVM __cmdline test_bitcode.o.cmdline test_bitcode.o$ segedit -extract __LLVM __bitcode test_bitcode.o.bc &gt; -extract __LLVM __cmdline test_bitcode.o.cmdline &gt; test_bitcode.o 观察导出的文件： 1234567$ file test_bitcode.o.bctest_bitcode.o.bc: LLVM bitcode, wrapper x86_64$ cat test_bitcode.o.cmdline | tr '0' ' '-triple x86_64-apple-macosx10.13.0 -emit-obj -disable-llvm-passes$ md5 test.bc test_bitcode.o.bcMD5 (test.bc) = 718d88a109ba9e1a75119b04eac566f8MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828 不难得出结论： object 文件中嵌入的 __LLVM,__bitcode 正是完整的，未经任何加密或者压缩的 bitcode 文件，通过 -fembed-bitcode 参数，clang 把对应的 bitcode 文件整个嵌入到了 object 文件中。 __LLVM,__cmdline 是编译这个文件所用到的参数，如果要通过导出的 bitcode 重新编译这个 object 文件，必须带上这些参数 导出的参数是 cc1 也就是 clang 中真正”前端”部分的参数(clang 命令其实是整合了各个环节，所以 clang 一个命令可以从源代码编出可执行文件)，所以编译时要带上 -cc1 导出的 bitcode 文件似乎和直接编译的 bitcode 不一样，先留个疑问，后面再研究。 首先， 来测试一下导出的 bitcode 文件结合 cmdline 能否编译出正常的 object： 12345678$ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes test_bitcode.o.bc -o test_rebuild.owarning: overriding the module target triple with x86_64-apple-macosx10.14.01 warning generated.$ file test_rebuild.otest_rebuild.o: Mach-O 64-bit object x86_64$ md5 test.o test_rebuild.oMD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bdMD5 (test_rebuild.o) = d647be2f0a5cd4ff96b815aef8af5943 没有任何问题，并且通过内嵌的 bitcode 编译出的 object 文件与直接从源代码编译出来的 object 完全一样！ 回到遗留的问题：为什么导出的 bitcode 文件和直接编译的 bitcode 会不一样？明明编出的 object 都是一模一样的！ 这是因为二进制的 bitcode 文件中还保存了一些与实际代码无关的 meta 信息。如果能将 bitcode 转换为文本格式，将能更直观地进行对比。前面已经提到，xcode 中并没有附带转换工具，但是我们依然可以通过 clang 来完成这一操作，还记得前面用过的 -emit-llvm -S 吗？ 1$ clang -emit-llvm -S test_bitcode.o.bc -o test_bitcode.o.ll 神奇吧？输入虽然已经是 bitcode 了，并非源代码，但是 clang 也能”编译”出 LLVM Assembly。其实 clang 内部是先将输入的文件转换成 Module 对象，然后再执行对应的处理： 如果输入是源代码，会先进行前端编译，得到一个 Module； 如果输入是 bitcode 或者 LLVM Assembly，那么直接进行 parse 操作，即可得到 Module 对象； 如果输出类型是 LLVM Assembly，将 Module 对象序列化为文本格式； 如果输出类型是 bitcode，则将 Module 对象序列化为二进制格式 所以完全可以通过 clang 进行 bitcode 和 LLVM Assembly 的相互转换。 现在，可以对比一下前后两次生成的.ll文件：（待验证） 1234567$ diff test_bitcode.o.ll test.ll$ diff /Users/cykj/Desktop/Chart/Chart/test_bitcode.o.ll /Users/cykj/Desktop/Chart/Chart/test.ll 1c1&lt; ; ModuleID = 'test_bitcode.o.bc'---&gt; ; ModuleID = 'test.c' 除了 ModuleID，也就是来源的文件名以外，其余部分完全相同，这也就解决了前面的疑虑。 再来回顾一下，前文提到非 Archive 类型的 build，比如直接 ⌘ + B，即使开启了 bitcode，也不会编出 bitcode，那么会产生什么样的文件呢？通过观察编译日志可以看出 xcode 在此时使用了 -fembed-bitcode-marker 这样一个参数，试一下： 1234567891011121314151617181920212223242526272829303132$ clang -fembed-bitcode-marker -c test.c -o test_bitcode_marker.o$ otool -l test_bitcode_marker.oSection sectname __bitcode segname __LLVM addr 0x0000000000000039 size 0x0000000000000001 offset 761 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Section sectname __cmdline segname __LLVM addr 0x000000000000003a size 0x0000000000000001 offset 762 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0$ objdump -s -section=__bitcode test_bitcode_marker.otest_bitcode_marker.o: file format Mach-O 64-bit x86-64Contents of section __bitcode: 0039 00 这样的方式编译出的文件结构与 -fembed-bitcode 的结果是一样的，唯一的区别就是 __LLVM,__bitcode 和 __LLVM,__cmdline 的内容并没有将实际的 bitcode 文件和编译参数嵌入进来，取而代之的一个字节的占位符 0x00。 九、Bitcode Bundle已经搞清楚了 bitcode 是如何嵌入在 object 文件里的，但是 object 只是编译过程的中间产物，真正运行的代码是多个 object文件经过链接之后的可执行文件，接下来要分析下 object 中嵌入的 bitcode 是如何被链接的： 1234567891011121314151617181920212223$ clang test.o -o test # 链接原始 object$ clang -fembed-bitcode test_bitcode.o -o test_bitcode # 链接带 bitcode 的object$ clang test.o -o test$ ./testhello, world.$ clang -fembed-bitcode test_bitcode.o -o test_bitcode$ ./test_bitcodehello, world.$ otool -l test_bitcodeSection sectname __bundle segname __LLVM addr 0x0000000100002000 size 0x0000000000001264 offset 8192 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0 object 中的 __LLVM,__bitcode 和 __LLVM,__cmdline不见了，取而代之的是一个 __LLVM,__bundle 的 Section， 通过名字可以基本推断出 object 中的 bitcode 被打包在了一起，把它从可执行文件中 dump 出来一探究竟： 123$ segedit -extract __LLVM __bundle bundle test_bitcode$ file bundlebundle: xar archive version 1, SHA-1 checksum 这个 bundle 文件是一个 xar 格式的压缩包，xar 格式包含了一个 xml 格式的文件头(TOC)，里面用于存放各种文件的基本属性以及一些附加附加信息，可以通过 xar 命令查看并解压： 1234567891011121314$ xar -d toc.xml -f bundle # 导出文件头$ xar -x -C bundle.extract -f bundle # 解压文件$ xar -d toc.xml -f bundle$ mkdir bundle.extract$ xar -x -C bundle.extract -f bundle$ ls bundle.extract1$ file bundle.extract/1bundle.extract/1: LLVM bitcode, wrapper x86_64$ md5 bundle.extract/1 test_bitcode.o.bcMD5 (bundle.extract/1) = 1b3bd72eb7f380cfd6c6528674d90828MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828 查看导出的 toc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xar&gt; &lt;subdoc subdoc_name=\"Ld\"&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;architecture&gt;x86_64&lt;/architecture&gt; &lt;platform&gt;MacOSX&lt;/platform&gt; &lt;sdkversion&gt;10.13.0&lt;/sdkversion&gt; &lt;dylibs&gt; &lt;lib&gt;&#123;SDKPATH&#125;/usr/lib/libSystem.B.dylib&lt;/lib&gt; &lt;/dylibs&gt; &lt;link-options&gt; &lt;option&gt;-execute&lt;/option&gt; &lt;option&gt;-macosx_version_min&lt;/option&gt; &lt;option&gt;10.13.0&lt;/option&gt; &lt;option&gt;-e&lt;/option&gt; &lt;option&gt;_main&lt;/option&gt; &lt;option&gt;-executable_path&lt;/option&gt; &lt;option&gt;test_bitcode&lt;/option&gt; &lt;/link-options&gt; &lt;/subdoc&gt; &lt;toc&gt; &lt;checksum style=\"sha1\"&gt; &lt;size&gt;20&lt;/size&gt; &lt;offset&gt;0&lt;/offset&gt; &lt;/checksum&gt; &lt;creation-time&gt;2019-01-11T10:21:54&lt;/creation-time&gt; &lt;file id=\"1\"&gt; &lt;name&gt;1&lt;/name&gt; &lt;type&gt;file&lt;/type&gt; &lt;data&gt; &lt;archived-checksum style=\"sha1\"&gt;d64be6fc7a9551555ccb4e8a78a87864cbef40b7&lt;/archived-checksum&gt; &lt;extracted-checksum style=\"sha1\"&gt;d64be6fc7a9551555ccb4e8a78a87864cbef40b7&lt;/extracted-checksum&gt; &lt;size&gt;2464&lt;/size&gt; &lt;offset&gt;20&lt;/offset&gt; &lt;encoding style=\"application/octet-stream\"/&gt; &lt;length&gt;2464&lt;/length&gt; &lt;/data&gt; &lt;file-type&gt;Bitcode&lt;/file-type&gt; &lt;clang&gt; &lt;cmd&gt;-triple&lt;/cmd&gt; &lt;cmd&gt;x86_64-apple-macosx10.13.0&lt;/cmd&gt; &lt;cmd&gt;-emit-obj&lt;/cmd&gt; &lt;cmd&gt;-disable-llvm-passes&lt;/cmd&gt; &lt;/clang&gt; &lt;/file&gt; &lt;/toc&gt;&lt;/xar&gt; header 的结构非常清晰，内容基本包含这些： ld 的基本参数，我们链接时使用的是 clang，实际上 clang 内部调用了 ld，这里记录的是 ld的参数 version: bitcode bundle 的版本号 architecture: 目标架构 platform: 目标平台 sdkversion: sdk版本 dylibs: 链接的动态库 link-options: 其他链接参数 文件目录 checksum类型 创建时间 每个文件的信息 文件名，这里并非原始文件名，而是按照链接时输入的顺序被重命名为数字序号 基本属性，包括 checksum、偏移、大小等 文件类型，一般是 Bitcode，还有两种特殊类型，Object 以及 Bundle 编译器类型(clang/swift)及编译参数，这部分就是 object 文件中 __LLVM,__cmdline 的内容 下一个文件的信息(如有) 重复 从 bundle 中解压出来的文件，就是 object 中嵌入的 bitcode，通过 MD5 对比可以看出链接时对 bitcode 文件自身没有做任何处理。可以注意到，用于编译各个 bitcode 文件的参数(cmdline)被放进了 TOC 中文件描述的区域，而 TOC 中多出了一个部分用于存放链接时所需要的信息和必要的参数，有了这些信息， 我们不难通过 bitcode 重新编译，并链接出一个新的可执行文件： 12345678910111213141516171819202122# 首先根据文件目录，将解压出的每一个bitcode文件编译为object$ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes bundle.extract/1 -o bundle.extract/1.o -x ir# 由于解压出的文件没有后缀名，clang无法判断输入文件的格式，因此使用 -x ir 强制指定输入文件为ir格式# 也可以将其重命名为1.bc，这样就不用指定-x ir# 根据toc.xml中提供的链接参数，将所有object文件链接为可执行文件，本例中只有一个文件$ ld -arch x86_64 `# architecture` -syslibroot `xcrun --show-sdk-path --sdk macosx` `# platform` -sdk_version 10.14.0 `# sdkversion` -lSystem `# dylibs` -execute `# link-options` -macosx_version_min 10.14.0 `# link-options` -e _main `# link-options` -executable_path test `# link-options` -o test_rebuild `# 输出文件` bundle.extract/1.o `# 输入文件`$ ./test_rebuildhello, world.$ md5 test_rebuild testMD5 (test_rebuild) = f4786288582decf2b8a1accb1aaa4a3cMD5 (test) = f4786288582decf2b8a1accb1aaa4a3c 看！我们成功利用 bitcode 重新编了一份一模一样的可执行文件出来。 现在可以理解，为什么苹果要强推 bitcode 了吧？开发者把 bitcode 提交到 iTunes Connect 之后，如果苹果发布了使用新芯片的 iPhone，支持更高效的指令，开发者不需要做任何操作，iTunes Connect 自己就可以编译出针对新产品优化过的 app 并通过 App Store 分发给用户，不需要开发者自己重新打包上架，这样一来苹果的商店生态就不需要依赖开发者的积极性了。 十、使用 Bitcode 导出 ipa前面已经提到，如果要以 bitcode 方式上传 app，必须在开启 bitcode 的状态下，进行 Archive 打包，才会得到带有 bitcode 的 app。大部分 app 都会依赖一堆第三方 sdk，如果此时项目里依赖的某一个或者几个 sdk 没有开启 bitcode，那么很遗憾，Xcode 会拒绝编译并给出类似这样的提示： ld: ‘name_of_the_library_or_framework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. ld: bitcode bundle could not be generated because ‘name_of_the_library_or_framework’ was built without full bitcode. 第一种提示表示这个第三方库完全没有开启 bitcode，而第二种提示表示它只有 bitcode-marker，也就是说它的开发者虽然在工程配置中设置了 Enable Bitcode 为 YES，但并没有以 Archive 方式编译，可能只是 ⌘ + B，然后顺手把 Products 拷贝出来交付了。 遇到这种问题，也需要分两种情况来看： 如果这个库是在本地编译的， 比如自己项目里或者子项目里的 target，或者通过 Pods 引入了源代码，那么这个 target 一定没有开启 bitcode，在工程中找到这个 target 的 Build Settings 把 Enable Bitcode 置为 YES 即可； 但如果是第三方提供的二进制库文件，则需要联系 sdk 的提供方确认是否能提供带 bitcode 的版本，否则只能关闭自己项目中的 bitcode。这也是 bitcode 时至今日都没有得到大面积应用的最大障阻碍。 当使用 Archive 方式打包出带有 bitcode 的包时，你会发现这个包里的二进制文件比没有开启 bitcode 时大出了许多，多出来的其实就是 bitcode 的体积，并且 bitcode 的体积，一般要比二进制文件本身还要大出许多。 1234567$ ls -al test.o test_bitcode.o test.bc-rw-r--r-- 1 xelz staff 2848 12 19 18:42 test.bc-rw-r--r--@ 1 xelz staff 784 12 19 18:24 test.o-rw-r--r--@ 1 xelz staff 3920 12 19 18:59 test_bitcode.o$ ls -al test test_bitcode-rwxr-xr-x@ 1 xelz staff 8432 12 19 21:38 test-rwxr-xr-x@ 1 xelz staff 16624 12 19 20:50 test_bitcode 当然，这部分内容并不会导致用户下载到的 APP 变大，因为用户下载到的代码中只会有机器码，不会包含 bitcode。有的项目开启 bitcode 之后会发现二进制的体积增大到超出了苹果对二进制体积的限制，但是完全不用担心，苹果的限制只是针对 __TEXT 段，而嵌入的 bitcode 是存储在单独的 __LLVM 段，不在苹果的限制范围内。 打包出带有 bitcode 的 xcarchive 之后，可以导出 Development IPA 进行上线前的最终测试，或者上传到 App Store Connect进行提审上架。进行此类操作时会发现 Xcode Organizer 中多出了 bitcode 相关的选项： 导出 Development 版本时，可以勾选 Rebuild from Bitcode，这时导出会变的很慢，因为 Xcode 在后台通过 bitcode 重新编译代码，这样导出的 ipa 最接近最终用户从 AppStore 下载的版本，为什么说是接近呢，因为苹果使用的编译器版本很可能和本地 Xcode 不一样，并且苹果可能在编译时增加额外的优化步骤，这些都会导致苹果编译后的二进制文件跟本地编译的版本产生差异。而如果不勾选此选项，则会直接使用 Archive 时编译出的二进制代码，并把 bitcode 从二进制中去除以减小体积。 导出 Store 版本或者直接进行上传时，默认会勾选 Include bitcode for iOS content，如果不勾选，则跟前面类似，将会去除内嵌的 bitcode，直接使用本地编译的二进制代码。 勾选后生成的 ipa 中将会只包含 bitcode，这个 ipa 是无法重签后安装到设备上进行测试的，因为里面没有任何可执行代码： __TEXT 和 __DATA 等跟已编译好的二进制相关的内容会被全部去除，但是会保留 __LINKEDIT 中的部分信息，其中最重要的就是 LC_UUID，用于在重编之后能跟原始的符号文件对应起来，如果用户下载经过 AppStore 重编之后的 app 发生了Crash，得到的 backtrace 地址是跟本地编译的版本对应不起来的，需要结合 UUID 和从 App Store Connect 下载的dSYM 文件才能得到符号化的 crash 信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem\\_kernel.dylib 0x23269c84 \\_\\_pthread_kill + 81 libsystem\\_pthread.dylib 0x2330bb46 pthread\\_kill + 622 libsystem_c.dylib 0x232000c4 abort + 1083 libc++abi.dylib 0x22d7a7dc \\_\\_cxa\\_bad_cast + 04 libc++abi.dylib 0x22d936a0 default\\_unexpected\\_handler() + 05 libobjc.A.dylib 0x22d9f098 \\_objc\\_terminate() + 1926 libc++abi.dylib 0x22d90e16 std::__terminate(void (*)()) + 787 libc++abi.dylib 0x22d905f4 \\_\\_cxxabiv1::exception\\_cleanup\\_func(\\_Unwind\\_Reason\\_Code, \\_Unwind\\_Exception*) + 08 libobjc.A.dylib 0x22d9eed2 objc\\_exception\\_throw + 2509 CoreFoundation 0x234e831e -\\[__NSArrayI objectAtIndex:\\] + 18610 test 0x000791f2 \\_\\_hidden#5\\_ (\\_\\_hidden#43\\_:35)11 libdispatch.dylib 0x2316fdd6 \\_dispatch\\_call\\_block\\_and_release + 1012 libdispatch.dylib 0x231794e6 \\_dispatch\\_after\\_timer\\_callback + 6613 libdispatch.dylib 0x2316fdc2 \\_dispatch\\_client_callout + 2214 libdispatch.dylib 0x231826d2 \\_dispatch\\_source\\_latch\\_and_call + 204215 libdispatch.dylib 0x23171d16 \\_dispatch\\_source_invoke + 73816 libdispatch.dylib 0x231741fe \\_dispatch\\_main\\_queue\\_callback_4CF + 39417 CoreFoundation 0x23594fc4 \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_ + 818 CoreFoundation 0x235934be __CFRunLoopRun + 159019 CoreFoundation 0x234e5bb8 CFRunLoopRunSpecific + 51620 CoreFoundation 0x234e59ac CFRunLoopRunInMode + 10821 GraphicsServices 0x2475faf8 GSEventRunModal + 16022 UIKit 0x277d1fb4 UIApplicationMain + 14423 test 0x000797de main (\\_\\_hidden#317\\_:14)24 libdyld.dylib 0x23198872 start + 2\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- File: /Users/Breeze/Desktop/crash/test.app.dSYM/Contents/Resources/DWARF/test (armv7)\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-.debug_info contents:0x00000000: Compile Unit: length = 0x00000073 version = 0x0002 abbr\\_offset = 0x00000000 addr\\_size = 0x04 (next CU at 0x00000077)0x0000000b: TAG\\_compile\\_unit \\[1\\] * AT\\_producer( \"\\_\\_hidden#30_\" ) AT\\_language( DW\\_LANG_ObjC ) AT\\_name( \"\\_\\_hidden#43_\" ) AT\\_stmt\\_list( 0x00000000 ) AT\\_comp\\_dir( \"\\_\\_hidden#41\\_\" ) AT\\_APPLE\\_optimized( 0x01 ) AT\\_APPLE\\_major\\_runtime\\_vers( 0x02 ) AT\\_low\\_pc( 0x0000a0b0 ) AT\\_high\\_pc( 0x0000a206 )0x00000028: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a0b0 ) AT\\_high\\_pc( 0x0000a154 ) AT\\_name( \"\\_\\_hidden#45_\" )0x00000035: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a154 ) AT\\_high\\_pc( 0x0000a166 ) AT\\_name( \"\\_\\_hidden#1_\" )0x00000042: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a168 ) AT\\_high\\_pc( 0x0000a16e ) AT\\_name( \"\\_\\_hidden#2_\" )0x0000004f: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a170 ) AT\\_high\\_pc( 0x0000a176 ) AT\\_name( \"\\_\\_hidden#3_\" )0x0000005c: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a178 ) AT\\_high\\_pc( 0x0000a1a4 ) AT\\_name( \"\\_\\_hidden#44_\" )0x00000069: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a1a4 ) AT\\_high\\_pc( 0x0000a206 ) AT\\_name( \"\\_\\_hidden#42_\" )0x00000076: NULL0x00000077: Compile Unit: length = 0x000000db version = 0x0002 abbr\\_offset = 0x00000000 addr\\_size = 0x04 (next CU at 0x00000156)0x00000082: TAG\\_compile\\_unit \\[1\\] * AT\\_producer( \"\\_\\_hidden#30_\" ) AT\\_language( DW\\_LANG_ObjC ) AT\\_name( \"\\_\\_hidden#301_\" ) AT\\_stmt\\_list( 0x000000bf ) AT\\_comp\\_dir( \"\\_\\_hidden#41\\_\" ) AT\\_APPLE\\_optimized( 0x01 ) AT\\_APPLE\\_major\\_runtime\\_vers( 0x02 ) AT\\_low\\_pc( 0x0000a208 ) AT\\_high\\_pc( 0x0000a796 )0x0000009f: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a208 ) AT\\_high\\_pc( 0x0000a20c ) AT\\_name( \"\\_\\_hidden#315_\" )0x000000ac: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a20c ) AT\\_high\\_pc( 0x0000a20e ) AT\\_name( \"\\_\\_hidden#314_\" )0x000000b9: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a210 ) AT\\_high\\_pc( 0x0000a212 ) AT\\_name( \"\\_\\_hidden#313_\" )0x000000c6: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a214 ) AT\\_high\\_pc( 0x0000a216 ) AT\\_name( \"\\_\\_hidden#312_\" )0x000000d3: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a218 ) AT\\_high\\_pc( 0x0000a21a ) AT\\_name( \"\\_\\_hidden#311_\" )0x000000e0: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a21c ) AT\\_high\\_pc( 0x0000a22c ) AT\\_name( \"\\_\\_hidden#310_\" )0x000000ed: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a22c ) AT\\_high\\_pc( 0x0000a2a2 ) AT\\_name( \"\\_\\_hidden#309_\" )0x000000fa: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a2a4 ) AT\\_high\\_pc( 0x0000a372 ) AT\\_name( \"\\_\\_hidden#308_\" )0x00000107: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a374 ) AT\\_high\\_pc( 0x0000a5b6 ) AT\\_name( \"\\_\\_hidden#307_\" )0x00000114: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a5b8 ) AT\\_high\\_pc( 0x0000a65c ) AT\\_name( \"\\_\\_hidden#306_\" )0x00000121: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a65c ) AT\\_high\\_pc( 0x0000a702 ) AT\\_name( \"\\_\\_hidden#305_\" )0x0000012e: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a704 ) AT\\_high\\_pc( 0x0000a714 ) AT\\_name( \"\\_\\_hidden#304_\" )0x0000013b: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a714 ) AT\\_high\\_pc( 0x0000a73a ) AT\\_name( \"\\_\\_hidden#302_\" )0x00000148: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a73c ) AT\\_high\\_pc( 0x0000a796 ) AT\\_name( \"\\_\\_hidden#300_\" )0x00000155: NULL0x00000156: Compile Unit: length = 0x00000032 version = 0x0002 abbr\\_offset = 0x00000000 addr\\_size = 0x04 (next CU at 0x0000018c)0x00000161: TAG\\_compile\\_unit \\[1\\] * AT\\_producer( \"\\_\\_hidden#30_\" ) AT\\_language( DW\\_LANG_ObjC ) AT\\_name( \"\\_\\_hidden#317_\" ) AT\\_stmt\\_list( 0x00000320 ) AT\\_comp\\_dir( \"\\_\\_hidden#41\\_\" ) AT\\_APPLE\\_optimized( 0x01 ) AT\\_APPLE\\_major\\_runtime\\_vers( 0x02 ) AT\\_low\\_pc( 0x0000a798 ) AT\\_high\\_pc( 0x0000a7f4 )0x0000017e: TAG_subprogram \\[2\\] AT\\_low\\_pc( 0x0000a798 ) AT\\_high\\_pc( 0x0000a7f4 ) AT\\_name( \"\\_\\_hidden#316_\" )0x0000018b: NULL 十一、bitcode 不是 bytecodebitcode 不能翻译为字节码(bytecode)，显然从字面上看这两个词代表的含义并不等同：字节码是按照字节存取的，一般其控制代码的最小宽度是一个字节(也即 8 个bits)，而 bitcode 是按位(bit)存取，最大化利用空间。比如用 bitcode 中使用 6-bit characters来编码只包含字母/数字的字符串。 12345'a' .. 'z' --- 0 .. 25 ---&gt; 00 0000 .. 01 1001'A' .. 'Z' --- 26 .. 51 ---&gt; 01 1010 .. 11 0011'0' .. '9' --- 52 .. 61 ---&gt; 11 0100 .. 11 1101 '.' \\-\\-\\- 62 ---&gt; 11 1110 '_' --- 63 ---&gt; 11 1111 在这种编码模式下，4 字节的字符串 abcd只用 3 个字节就可以表示 123 char: a | b | c | dbinary: 00 00 00|00|00 01|00 00|10|00 00 11 hex: 00 | 10 | 83 完整的编码格式可以参考官方文档LLVM Bitcode File Format 十二、bitcode 的兼容性bitcode 的格式目前是一直在变化的，且无法向前兼容，举例来说 Xcode8 的编译器无法读取并解析 xcode9 产生的 bitcode。 另外苹果的 bitcode 格式与社区版 LLVM 的 bitcode 有一定差异，但苹果并不会及时开源 Xcode 最新版编译器的代码，所以如果你使用第三方基于社区版 LLVM 制作的编译器进行开发，不要尝试开启并提交 bitcode 到 App Store Connect，否则会因为App Store Connect 解析不了你的 bitcode 而被拒。 十三、bitcode 不是架构无关代码如果一个 app 同时要支持 armv7 和 arm64 两种架构，那么同一个源代码文件将会被编译出两份 bitcode，也就是说，在一开始介绍 LLVM 的那张图中，并不是代表同一份 bitcode 代码可以直接被编译为不同目标机器的机器码。 LLVM 只是统一了中间语言的结构和语法格式，但不能像 Java 那样，Compile Once &amp; Run Everywhere。 十四、如何判断是否开启 bitcode可以通过 otool 检查二进制文件，网上有很多类似这样的方法： 1otool -arch armv7 -l xxxx.a | grep __LLVM | wc -l 通过判断是否包含 __LLVM 或者关键字来判断是否支持 bitcode，其实这种方式是完全错误的，通过前面的测试可以知道，这种方式区分不了 bitcode 和 bitcode-marker，确定是否包含 bitcode，还需要检查 otool 输出中 __LLVM Segment 的长度，如果长度只有 1 个字节，则并不能代表真正开启了 bitcode： 123456$ otool -l test\\_bitcode.o | grep -A 2 \\_\\_LLVM | grep size size 0x0000000000000b10 size 0x0000000000000042$ otool -l test\\_bitcode\\_marker.o | grep -A 2 __LLVM | grep size size 0x0000000000000001 size 0x0000000000000001 十五、bitcode 是否能反编译出源代码从科学严谨的角度来说，无法给出确定的答案，但是这个问题跟”二进制文件是否能反编译出源代码”是一样的道理。编译是一个将源代码一层一层不断低级化的过程，每一层都可能会丢失一些特性，产生不可逆的转换，把源代码编译为 bitcode 或是二进制机器码是五十步之于百步的关系。在通常情况下，反编译 bitcode 跟反编译二进制文件比要相对容易一些，但通过 bitcode 反编译出和源代码语义完全相同的代码，也是几乎不可能的。 另外，从安全的角度考虑，Xcode 引入了 Symbol Hiding 和 Debug info Striping 机制，在链接时，bitcode 中所有非导出符号均被隐藏，取而代之的是 __hidden#0_ 或者 __ir_hidden#1_ 这样的形式，debug 信息也只保留了 line-table，所有跟文件路径、标识符、导出符号等相关的信息全部都从 bitcode 中移除，相当于做了一层混淆，防止源代码级别的信息泄露，可谓是煞费苦心。 十六、参考文章lansekuangtu &amp; 《理解Bitcode：一种中间代码》戴维营教育 &amp; 《深入理解iOS开发中的BitCode功能》LLVM 官方文档介绍的 bitcode 文件的格式：LLVM Bitcode File FormatUnderstanding and Analyzing Application Crash ReportsTroubleshooting App Thinning and Bitcode Build Failureshttp://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/iOS 打包上线 bitcode问题","tags":[]},{"title":"App Thinning","date":"2019-10-24T01:06:24.296Z","path":"2019/10/24/iOS/iOS原理/App Thinning/","text":"当前 iOS App 的编译打包方式是把适配兼容多个设备的执行文件及资源文件合并一个文件，上传和下载的文件则包含了所有的这些文件，导致占用较多的存储空间。 App Thinning 是一个关于节省 iOS 设备存储空间的功能，它可以让 App Store 和操作系统在安装、更新及运行 iOS 或者 watchOS 的 App 等场景时，通过一系列的优化，尽可能减少安装包的大小，仅下载所需的资源，减少 App 的占用空间，从而节省设备的存储空间。这个过程包括了三个过程：slicing、bitcode、on-demand resources。 一、slicingApp Slicing 在节省应用所需资源中发挥着最重要的作用。 很多应用需要在不同尺寸的设备上运行，针对这些不同的设备，它们内含不同的独立资源，而大部分是用户设备不需要的。所以，开发者把 App 安装包上传到 AppStore 后，Apple 服务会自动将安装包切割为不同的应用变体(App variant)，或者称 App Store 会针对不同的设备制作不同的”简化版 App”，当你下载 app 时，系统会根据设备型号下载安装不同的”简化版 app”。（iOS9.0.2 以上支持） iOS app 为了后向兼容，现在都同时包含了 32 bit 和 64 bit 两个 slice。另外在图片资源方面，更是 2x、3x 的图像一应俱全。而用户使用 app 时，因为设备是特定的，其实只需要其中的一套资源。但是现在在购买和下载的时候却是把整个 app 包都下载了。Apple 在 iOS 9 中终于可以仅选择需要的内容 (Slicing) 下载了。对于开发者来说，并没有太多要做的事情，只需要使用 asset catalog 来管理素材标记 2x 3x 就可以了。 比如用户使用的是 iPhone 5c，它运行的是 32 位 CPU 和 GPU，并不支持 Metal API。但如果用户下载的是一款最新的通用游戏应用，它的二进制中含有 64 位代码，iPad 和”@3x”iPhone 6 Plus 资源以及 Metal API 代码，这些都是你的设备用不上的。它只需要 32 位代码，”@2x”iPhone 尺寸资源以及 OpenGL 图形代码。 Note : Sliced apps are supported on devices running 9.0 and later; Slicing 的主要的工作流程如下： 在 Xcode 中选择好目标设备并且使用 asset catalog 提供多分辨率的图片资源；只有使用 asset catalog 才能正确使 Slicing 作用于资源文件。 在模拟器或者设备上编译并运行 app； Xcode 会自动构建针对你运行设备的”简化版 app”，同时也是为了减少编译时间和进行本地的测试； 打包 app（为了及时发现不同目标设备的配置错误，可以在本地为目标设备导出”简化版 app”，测试无误后再打包) 上传打包好的 app 到 iTunes connect。App Store 将会为上传的 app 归档创建不同的”简化版 app”。 在 iTunes Connect 中，发布一个预览版给合格的测试者进行测试； 测试者通过 TestFlight 下载预览版。TestFlight 会自动根据测试者的设备下载合适的”简化版 app”。 最终苹果下载资源的效果如下： 二、Bitcode (iOS, watchOS)开启 Bitcode 编译后，可以使得开发者上传 App 时只需上传 Intermediate Representation(中间件)，而非最终的可执行二进制文件。在用户下载 App 之前，AppStore 会自动编译中间件，产生设备所需的执行文件供用户下载安装。也就是当我们提交程序到 App Store 上时， Xcode 会将程序编译为一个中间表现形式( bitcode )。然后 App store 会再将这个 Bitcode 编译为可执行的 64 位或 32 位程序。苹果会根据下载应用的用户的手机指令集类型生成只有该指令集的二进制，进行下发。从而达到精简安装包体积的目的。 Bitcode 是 LLVM 编译器的中间代码的一种编码，LLVM 的前端可以理解为 C/C++/OC/Swift 等编程语言，LLVM 的后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据，那么，BitCode 就是位于这两者之间的中间码。LLVM 的编译工作原理是前端负责把项目程序源代码翻译成 Bitcode 中间码，然后再根据不同目标机器芯片平台转换为相应的汇编指令以及翻译为机器码。这样设计就可以让 LLVM 成为了一个编译器架构，可以轻而易举的在 LLVM 架构之上发明新的语言(前端)，以及在 LLVM 架构下面支持新的 CPU(后端)指令输出。 虽然 Bitcode 仅仅只是一个中间码不能在任何平台上运行，但是它可以转化为任何被支持的 CPU 架构，包括现在还没被发明的 CPU 架构，也就是说现在打开 Bitcode 功能提交一个 App 到应用商店，对于 Apple 未来进行硬件升级的措施，此机制可以保证在开发者不重新发布版本的情况下而兼容新的设备。比如以后如果苹果新出了一款手机并 CPU 架构也是全新设计的，在苹果后台服务器一样可以从这个 App 的 Bitcode 开始编译转化为新 CPU 上的可执行程序，可供新手机用户下载运行这个 App。 在文档里可看到 In fact, app slicing handles the majority of the app thinning process. ‘App Slicing’ feature finally switched on in iOS 9.0.2 说明 slicing 才是主要处理 app thinning 的，而且该功能需要在 iOS9.0.2 以上才支持（iOS9.0 中被关闭了，因为一个 iCloud 的 bug）。实际上 Bitcode，做的事情是指令集优化。根据你设备的状态去做编译优化，进而提升性能。所以 Bitcode 对包的大小优化起不到什么本质上的作用。 Bitcode 注意点 Xcode 7 默认开启 Bitcode，如果应用开启 Bitcode，那么其集成的其他第三方库也需要是 Bitcode 编译的包才能真正进行 Bitcode 编译 开启 Bitcode 编译后，编译产生的 .app 体积会变大(中间代码，不是用户下载的包)，且 .dSYM 文件不能用来崩溃日志的符号化(用户下载的包是 Apple 服务重新编译产生的，有产生新的符号文件) 通过 Archive 方式上传 AppStore 的包，可以在 Xcode 的 Organizer 工具中下载对应安装包的新的符号文件 三、On-Demand Resources (iOS)ODR（on-demand resources 随需应变资源)是 iOS 减少应用资源消耗的另外一种方法。比如多级游戏，用户需要的通常都是他们当前的级数以及下一级。ODR 意味着用户可以下载他们需要的几级游戏。随着你的级数不断增加，应用再下载其他级数，并将用户成功过关的级数删掉。 当用户点击应用内容的时候，就会动态从 App Store 上进行下载，也就是说用户只会在需要的时候占用存储空间。这项功能有趣之处还在于当将这些内容在后台进行下载之后，当存储空间紧张的时候会自动进行删除。 On-Demand Resources 可以是除了可执行代码外的任意类型。 在开发过程中，你可以通过分配一个或多个 tag 来识别 On-Demand Resources。你可以使用 tag 的别名来确定什么时候将它加载到你的 App 中。 好处： Smaller app size. app 体积更小。 Lazy loading of app resources. 懒加载应用资源。 Remote storage of rarely used resources. 远端存储较少使用的资源。 Remote storage of in-app purchase resources. 远端存储内购资源。 下图展示了一个在 App 中保持最小资源占用的例子。 可以给资源设置优先级，比如当 App 从 AppStore 安装后就立即加载。 A _tag_ is a string identifier you create. Apps request tags, not individual resources. 3.1 On-Demand Resources 的生命周期 App 向操作系统请求资源。操作系统将请求发送给包含所有所需资源的 asset packs。 asset packs 检查请求的资源本地是否存在。如果存在，则直接提供 App 使用。 如果请求的资源本地不存在，则它们被保存在 App Store。 操作系统开始下载本地不存在的资源 远程资源下载完毕 当资源下载成功或监测到资源包已经被下载，资源包内存计数将会被 ＋1，并通知 App 此资源可用。 当请求的资源可用，App 使用资源标签对应的资源。 操作系统在本地释放资源标签 操作系统在本地清除资源缓存。当一个缓存资源不与任何请求相关联时，操作系统会在一定时间后将它释放掉。 完整的生命周期如下图所示： 四、实际处理方法 iOS9 以后 Xcode 默认开启 On-Demand Resources 功能，可以在下图所示位置进行设置。 在 App 中创建 Tags 给文件设置 tag 给图片设置 tag 给 tag 设置加载的优先级 4.1 加载优先级 Initial install tags.资源和 App 同时下载。在 App Store 中，App 的大小计算已经包含了这部分资源。当没有NSBundleResourceRequest 对象访问它们时，它们将会从设备上清除。 Prefetch tag order. 在 App 安装后开始下载，按照预加载列表中的顺序依次下载。 Dowloaded only on demand. 只有在 App 中发出请求时才会下载。 4.2 资源大小限制 五、学习文章What is app thinning? (iOS, tvOS, watchOS)On-Demand Resources EssentialsApp ThinningApp Thinning","tags":[]},{"title":"Crash","date":"2019-10-24T01:06:24.294Z","path":"2019/10/24/iOS/iOS优化/Crash/","text":"一、Crash类型crash 一般产生自 iOS 的微内核 Mach，然后在 BSD 层转换成 UNIX SIGABRT 信号，以标准 POSIX 信号的形式提供给用户。NSException 是使用者在处理 App 逻辑时，用编程的方法抛出。 iOS 端的 crash 分为三类： Mach 异常：EXC_CRASH UNIX 信号：SIGABRT 系统崩溃而引起的程序 NSException 异常退出 常见的 iOS 崩溃类型有： EXC_BAD_ACCESS 在访问一个已经释放的对象或向它发送消息时，就会出现 EXC_BAD_ACCESS。 造成 EXC_BAD_ACCESS 最常见的原因，是在初始化变量时用错了所有权修饰符，这会导致对象过早地被释放。例如，一个 NSArray 属性的所有权修饰符设成了 assign 而不是 strong。 这个崩溃发生时，查看崩溃日志，往往得不到有用的栈信息。可以通过 NSZombieEnabled 来解决。 NSZombieEnabled 是一个环境变量，用来调试与内存相关的问题，跟踪对象的释放过程。启用之后，它会在对象调用 dealloc 时，也就是在引用计数降到 0，用一个僵尸实现将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。 所以，当在应用中启用 NSZombie 而不是让应用直接崩溃时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接收到的消息，然后跳入调试器，这样就可以查看到底哪里出了问题。 启用如图所示： SIGSEGV 段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。 当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。 当要读取保存在 RAM 中的数据，而该位置的 RAM 硬件有问题时，会收到 SIGSEGV，这种情况并不常见。下面两种情况更多出现： 当应用中的某个指针指向代码页并试图修改指向位置的值； 当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值 SIGSEGV 错误调试起来更困难，而导致 SIGSEGV 的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到 SIGSEGV。 SIGBUS 总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。 也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV 和 SIGBUS 都 EXC_BAD_ACCESS 的子类型。 SIGTRAP SIGTRAP 代表陷阱信号。 它并不是一个真正的崩溃信号。它会在处理器执行 trap 指令发送。LLDB 调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的 SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。 EXC_ARITHETIC 当要作除零运算时，应用会收到 EXC_ARITHMETIC 信号。 这个错误应该很容易解决。 SIGILL SIGILL 代表 signal illegal instruction(非法指令信号)。 当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是 EXC_BAD_INSTRUCTION 而不是SIGILL，虽然它们是一回事，不过 EXC_* 等同于此信号不依赖体系结构。 SIGABRT SIGABRT 代表 SIGNAL ABORT（中止信号）。 当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d 或 UIKit 等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用 C 函数 abort（由它来发送此信号）。 当 SIGABRT 出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在 LLDB 控制台上键入 bt 命令打印出回溯信息。 看门狗超时 这种崩溃通常比较容易分辨，因为错误码是固定的 0x8badf00d。（程序员幽默的把它读作 Ate Bad Food。）在 iOS 上，它经常出现在执行一个同步网络调用而阻塞主线程的情况。因此，永远不要进行同步网络调用。 二、Crash捕获日常开发中，可以使用的 crash 收集方式有： 第三方平台：Fabric、友盟、腾讯 Bugly、Flurry、Crashlytics 等，数据会上传到这些平台 第三方工具：KSCrash、plcrashreporter 等，可自行处理收集的 crash 自定义捕获 + 堆栈符号化 本文主要讨论自定义捕获。 1.1 Mach 异常捕获如果想要做 mach 异常捕获，需要注册一个异常端口，这个异常端口会对当前任务的所有线程有效，如果想要针对单个线程，可以通过 thread_set_exception_ports 注册自己的异常端口，发生异常时，首先会将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，当我们捕获异常时，就可以做一些自己的工作，比如，当前堆栈收集等。 1.2 NSException 异常捕获 NSException 异常是 OC 代码导致的 crash。 NSException 异常和 Signal 信号异常，这两类都可以通过注册相关函数来捕获。 123456789101112// 保存注册的 exception 捕获方法NSUncaughtExceptionHandler * oldExceptionHandler;// 自定义的 exception 异常处理void ExceptionHandler(NSException * exception);void RegisterExceptionHandler() &#123; if(NSGetUncaughtExceptionHandler() != ExceptionHandler) &#123; oldExceptionHandler = NSGetUncaughtExceptionHandler(); &#125; NSSetUncaughtExceptionHandler(ExceptionHandler);&#125; NSSetUncaughtExceptionHandler 用来做异常处理，功能非常有限。引起崩溃的大多数原因如：内存访问错误、重复释放等错误，它就无能为力了，因为这种错误它抛出的是 Signal。 同时值得注意 如果一个应用中注册了多个 crash 收集组件，必然会存在冲突问题。 这个时候，我们需要在注册之前判断是否已经注册过 handler，如果有注册过，需要把之前注册的 handler函数指针保存，待处理完 crash 后，再把对应的 handler 抛出去。 123456789101112131415161718192021222324252627282930/** * @brief exception 崩溃处理 */void ExceptionHandler(NSException * exception)&#123; // 使 UncaughtExceptionCount 递增 int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount); // 超出允许捕获错误的次数 if (exceptionCount &gt; UncaughtExceptionMaximum) &#123; return; &#125; // 获取调用堆栈 NSMutableDictionary * userInfo = [NSMutableDictionary dictionaryWithDictionary:[exception userInfo]]; userInfo[kUncaughtCallStackKey] = [exception callStackSymbols]; NSException * exp = [NSException exceptionWithName:exception.name reason:exception.reason userInfo:userInfo]; // 在主线程中执行方法 [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:@selector(dealException:) withObject:exp waitUntilDone:YES]; // 调用保存的 handler if (oldExceptionHandler) &#123; oldExceptionHandler(exception); &#125;&#125; 1.3 Signal 信号捕获 Signal 信号是由 iOS 底层 mach 信号异常转换后以 signal 信号抛出的异常。 既然是兼容 posix 标准的异常，我们同样可以通过 sigaction 函数注册对应的信号。 因为 signal 信号有很多，有些信号在 iOS 应用中也不会产生，我们只需要注册常见的几类信号： 信号 值 介绍 场景 SIGILL 4 非法指令 1. 执行了非法指令. 2. 通常是因为可执行文件本身出现错误或者试图执行数据段. 3. 堆栈溢出时也有可能产生这个信号. SIGABRT 6 调用abort 程序自己发现错误并调用 abort 时产生，一些 C 库函数（如：strlen） SIGSFPE 8 浮点运算错误 如：除 0 操作 SIGSEGV 11 段非法错误 1. 试图访问未分配给自己的内存2. 或试图往没有写权限的内存地址写数据3. 空指针4. 数组越界5. 栈溢出等 下面注册一个 SIGABRT 信号，在注册 handler 之前，需要保存之前注册的 hander: 12345678910111213141516171819202122232425262728293031323334typedef void (* SignalHandlerClass)(int, struct __siginfo *, void *);// 已注册的 singal 捕获方法SignalHandlerClass oldSignalHandler;static void MySignalHandler(int signal, siginfo_t* info, void* context) &#123; // do something。。。 if (signal == SIGABRT) &#123; if (oldSignalHandler) &#123; oldSignalHandler(signal, info, context); &#125; &#125;&#125;void registerSignalHandler()&#123; // 获取已注册的 handler struct sigaction old_action; sigaction(SIGABRT, NULL, &amp;old_action); if (old_action.sa_flags &amp; SA_SIGINFO) &#123; SignalHandlerClass handler = old_action.sa_sigaction; if (handler != MySignalHandler) &#123; oldSignalHandler = handler; &#125; &#125; struct sigaction action; action.sa_sigaction = MySignalHandler; action.sa_flags = SA_NODEFER | SA_SIGINFO; sigemptyset(&amp;action.sa_mask); sigaction(signal, &amp;action, 0);&#125; 三、收集调用堆栈调用堆栈的收集我们可以利用系统 api，也可以参考 PLCrashRepoter 等第三方实现获取所有线程堆栈。使用系统 api 关键代码如下: 123456789101112131415161718192021222324+ (NSArray *)backtrace&#123; /* 指针列表。 ①、backtrace 用来获取当前线程的调用堆栈，获取的信息存放在这里的 callstack 中 ②、128 用来指定当前的 buffer 中可以保存多少个 void* 元素 */ void * callstack[128]; // 返回值是实际获取的指针个数 int frames = backtrace(callstack, 128); // backtrace_symbols 将从 backtrace 函数获取的信息转化为一个字符串数组，每个字符串包含了一个相对于 callstack 中对应元素的可打印信息，包括函数名、偏移地址、实际返回地址。 // 返回一个指向字符串数组的指针 char **strs = backtrace_symbols(callstack, frames); NSMutableArray * backtrace = [NSMutableArray arrayWithCapacity:frames]; for (int i = 0; i &lt; frames; i++) &#123; [backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); return backtrace;&#125; 四、堆栈符号化通过系统 api 获取的堆栈信息可能只是一串内存地址，很难从中获取有用的信息协助排查问题，因此，需要对堆栈信息符号化。 1234567891011121314151617// 未符号化前Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libobjc.A.dylib 0x000000018b816f30 0x18b7fc000 + 110384 (objc_msgSend + 16)1 UIKit 0x0000000192e0a79c 0x192c05000 + 2119580 (&lt;redacted&gt; + 72)2 UIKit 0x0000000192c4db48 0x192c05000 + 297800 (&lt;redacted&gt; + 312)3 UIKit 0x0000000192c4d988 0x192c05000 + 297352 (&lt;redacted&gt; + 160)4 QuartzCore 0x00000001900d6404 0x18ffc5000 + 1119236 (&lt;redacted&gt; + 260)// 符号化后Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libobjc.A.dylib 0x000000018b816f30 objc_msgSend + 161 UIKit 0x0000000192e0a79c -[UISearchDisplayController _sendDelegateDidBeginDidEndSearch] + 722 UIKit 0x0000000192c4db48 -[UIViewAnimationState sendDelegateAnimationDidStop:finished:] + 3123 UIKit 0x0000000192c4d988 -[UIViewAnimationState animationDidStop:finished:] + 1604 QuartzCore 0x00000001900d6404 CA::Layer::run_animation_callbacks(void*) + 260 符号化的思路是找到当前应用对于的 dsym 符号表文件，利用 symbolicatecrash（Xcode 的 Organizer 内置了）、dwarfdump，atos 等工具还原 crash 堆栈内存地址对应的符号名。需要注意，如果应用中使用了自己或第三方的动态库，应用崩溃在动态库 Image 而不是主程序 Image 中，我们需要有对应动态库的 dsym 符号表才能符号化。 思路明确之后，接下来面临的是两个问题。一个问题是如何把当前 crash 的应用和 dsym 符号表对应上。另一个问题是如何通过内存地址符号化。在解决这两个问题之前，我们需要先了解可执行文件的二进制格式和加载过程。 4.1 Mach-O文件格式不同操作系统都会定义不同的可执行文件格式。如 Linux平台的 ELF 格式，Windows 平台的 PE 格式，iOS 的可执行文件格式被称作 Mach-O。可执行文件、动态库、dsym 文件都是这种文件格式。 下图是官方的 Mach-O 格式结构： 可以看到，Mach-O 文件分为三部分。 header hander 定义了文件的基本信息，包括文件大小、文件类型、使用的平台等信息。我们可以从 loader.h 头文件中找到相关定义： 1234567891011121314/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; load commands 这一部分定义了详细的加载指令，指明如何加载到内存。 从头文件定义可以看到，基础的 load_command 结构体只包含了 cmd 以及 cmdsize。通过 cmd 类型，可以转义成不同类型的 load command 结构体： 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 数据部分 包括了代码段、数据段、符号表等具体的二进制数据。 我们可以用 otool 查看二进制文件的具体内容，更直观的，可以用 Mach-O View 来浏览可执行文件的具体内容。 下图是一个可执行文件与其所对应的符号表文件。可执行文件的 load command 比较多，里面包含了有代码段、数据段、函数入口、加载动态库等指令。其中的 LC_UUID 字段和符号表中的 LC_UUID 是完全对应的，也就是说，可以通过 UUID 字段匹配可执行文件和 dsym 符号表。 4.2 可执行文件加载过程一个 iOS 应用的加载过程是这样的： 首先，由内核加载可执行文件（Mach-O），并从中获得 dyld 的路径。 然后加载 dyld，由 dyld 接管动态库加载，符号绑定等工作，runtime 的初始化工作也在这一阶段进行。 最后 dyld 调用 main 函数，这样便来到了 main 函数入口。 在这个过程中，操作系统为了安全考虑，使用了 ASLR 技术。地址空间布局随机化(Address space layout randomization)，就是每次应用加载时，使用随机的一个地址空间，这样能有效防止被攻击。 VM Address 是编译后 Image 的起始位置，Load Address 是在运行时加载到虚拟内存的起始位置，Slide 是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同，有下面公式： Load Address = VM Address + Slide 由于 dsym 符号表是编译时生成的地址，crash 堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash 日志里的符号地址被称为 Stack Address，而编译后的符号地址被称为 Symbol Address，他们之间的关系如下： Stack Address = Symbol Address + Slide 符号化就是通过 Symbol Address 到 dsym 文件中寻找对应符号信息的过程。 4.3 获取 Binary Images 信息当前采集到的 crash 日志，报错地址 Stack Address 位于 0x1046eea14，相对 Load Address 0x1046e8000 偏移了 27156。这里的 27156 并不是 ASLR 的随机偏移Slide，而是符号相对位置offset（Symbol Address - VM Address）： 再观察 crash 日志最后有一栏 Binary Images，记录了所有加载 image 的 UUID 和加载的 Load Address： 根据前文提到的 UUID 对应关系以及 Load Address 和 Symbol Address 的转换关系，只要能获取 Binary Images 信息，就可以实现符号化。 UUID 存放在 Mach-O 的 load command 中，对应 uuid_command 结构体的 uuid 字段，可以通过遍历所有 load command 获取。 Slide 偏移可以通过 image_dyld_get_image_vmaddr_slide 方法遍历所有 Image 获取。 VM Address 也存放在 load command 中，对应 segment_command 结构体的 vmaddr 字段，需要注意 segment_command 存在多种类型以及需要区分32位和64位应用的细微差别。 解析代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152for (uint32_t i = 0; i &lt; _dyld_image_count(); i++) &#123; uint64_t vmbase = 0; uint64_t vmslide = 0; uint64_t vmsize = 0; uint64_t loadAddress = 0; uint64_t loadEndAddress = 0; NSString *imageName = @\"\"; NSString *uuid; const struct mach_header *header = _dyld_get_image_header(i); const char *name = _dyld_get_image_name(i); vmslide = (i); imageName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding]; BOOL is64bit = header-&gt;magic == MH_MAGIC_64 || header-&gt;magic == MH_CIGAM_64; uintptr_t cursor = (uintptr_t)header + (is64bit ? sizeof(struct mach_header_64) : sizeof(struct mach_header)); struct load_command *loadCommand = NULL; for (uint32_t i = 0; i &lt; header-&gt;ncmds; i++, cursor += loadCommand-&gt;cmdsize) &#123; loadCommand = (struct load_command *)cursor; if(loadCommand-&gt;cmd == LC_SEGMENT) &#123; const struct segment_command* segmentCommand = (struct segment_command*)loadCommand; if (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == 0) &#123; vmsize = segmentCommand-&gt;vmsize; vmbase = segmentCommand-&gt;vmaddr; &#125; &#125; else if(loadCommand-&gt;cmd == LC_SEGMENT_64) &#123; const struct segment_command_64* segmentCommand = (struct segment_command_64*)loadCommand; if (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == 0) &#123; vmsize = segmentCommand-&gt;vmsize; vmbase = (uintptr_t)(segmentCommand-&gt;vmaddr); &#125; &#125; else if (loadCommand-&gt;cmd == LC_UUID) &#123; const struct uuid_command *uuidCommand = (const struct uuid_command *)loadCommand; NSString *uuidString = [[[NSUUID alloc] initWithUUIDBytes:uuidCommand-&gt;uuid] UUIDString]; uuid = [[uuidString stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"] lowercaseString]; &#125; &#125; loadAddress = vmbase + vmslide; loadEndAddress = loadAddress + vmsize - 1; &#125; // do something...``` #### 4.4 符号化通过上述代码，我们可以采集到和系统一样的 crash 日志。接下来，可以使用 dwarfdump 和 atos 进行符号化。1. dwarfdump 拿到 crash 日志后，我们要先确定 dsym 文件是否匹配。可以使用 dwarfdump --uuid 命令查看 dsym 文件所有架构的 UUID： $ dwarfdump --uuid mytest.app.dSYM UUID: B4217D5B-0349-3D9F-9D70-BC7DD60DA121 (armv7) mytest.app.dSYM/Contents/Resources/DWARF/mytest UUID: A52E3452-C2EF-3291-AE37-9392EDCCE572 (arm64) mytest.app.dSYM/Contents/Resources/DWARF/mytest 12345678可以看到 dsym 文件的 arm64 架构中包含的 A52E3452-C2EF-3291-AE37-9392EDCCE572 和 Binary Images 中的 UUID 是相匹配的。&lt;center&gt;![UUID](http://dzliving.com/Crash_3.png)&lt;/center&gt;下面就可以用 dwarfdump --lookup 命令对报错堆栈符号化，格式如下： dwarfdump --arch [arch type] --lookup [Symbol Address] [dsym file path] 12对于报错堆栈的 Stack Address 0x1046eea14，需要进行一个转换。已知 VM Address 为0x100000000，Load Address 为 0x1046e8000，可以得到 Slide 为 0x46e8000。通过公式Symbol Address = Stack Address - Slider 求得 Symbol Address 为 0x100006a14，输入命令： $ dwarfdump --arch arm64 --lookup 0x100006a14 mytest.app.dSYM ---------------------------------------------------------------------- File: mytest.app.dSYM/Contents/Resources/DWARF/mytest (arm64) ---------------------------------------------------------------------- Looking up address: 0x0000000100006a14 in .debug_info... found! 0x0003ebb7: Compile Unit: length = 0x000000d4 version = 0x0004 abbr_offset = 0x00000000 addr_size = 0x08 (next CU at 0x0003ec8f) 0x0003ebc2: TAG_compile_unit [120] * AT_producer( &quot;Apple LLVM version 9.1.0 (clang-902.0.39.2)&quot; ) AT_language( DW_LANG_ObjC ) AT_name( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; ) AT_stmt_list( 0x00009151 ) AT_comp_dir( &quot;/Users/worthyzhang/Desktop/mytest&quot; ) AT_APPLE_optimized( true ) AT_APPLE_major_runtime_vers( 0x02 ) AT_low_pc( 0x00000001000069bc ) AT_high_pc( 0x000000a4 ) 0x0003ebf9: TAG_subprogram [122] * AT_low_pc( 0x00000001000069bc ) AT_high_pc( 0x00000070 ) AT_frame_base( reg29 ) AT_object_pointer( {0x0003ec12} ) AT_name( &quot;-[ViewController viewDidLoad]&quot; ) AT_decl_file( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; ) AT_decl_line( 17 ) AT_prototyped( true ) AT_APPLE_optimized( true ) Line table dir : &apos;/Users/worthyzhang/Desktop/mytest/mytest&apos; Line table file: &apos;ViewController.m&apos; line 25, column 1 with start address 0x0000000100006a14 Looking up address: 0x0000000100006a14 in .debug_frame... not found. 123456 可以定位到报错所在的函数名 [ViewController viewDidLoad] 以及文件名、行号等信息。2. atos 如果只是简单的获取符号名，可以用 atos 来符号化，命令格式如下： atos -o [dsym file path] -l [Load Address] -arch [arch type] [Stack Address] 12需要注意这里的 dsym file path 是 dsym 文件而不是 .dSYM 结尾的文件夹，输入命令： $ atos -o mytest.app.dSYM/Contents/Resources/DWARF/mytest -l 0x1046e8000 --arch arm64 0x1046eea14 -[ViewController viewDidLoad] (in mytest) (ViewController.m:25) ``` 得到结果和dwarfdump是一致的。 4.5 常见错误标识 Exception codes 0x8badf00d 错误码：Watchdog 超时，意为“ate bad food”。 0xdeadfa11 错误码：用户强制退出，意为“dead fall”。 0xbaaaaaad 错误码：用户按住 Home 键和音量键，获取当前内存状态，不代表崩溃。 0xbad22222 错误码：VoIP应用（因为太频繁？）被iOS干掉。 0xc00010ff 错误码：因为太烫了被干掉，意为“cool off”。 0xdead10cc 错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock”。 Exception types SIGSEGV（Segmentation Violation，段违例）：表明内存操作不当，比如访问一个没有权限的内存地址。当我们收到 SIGSEGV 信号时，可以往以下几个方面考虑： 访问无效内存地址，比如访问Zombie对象； 尝试往只读区域写数据； 解引用空指针； 使用未初始化的指针； 栈溢出； SIGABRT：收到 Abort 信号，可能自身调用 abort() 或者收到外部发送过来的信号； SIGBUS：总线错误。与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址（比如虚存映射不到物理内存），而 SIGBUS 访问的是有效地址，但总线访问异常（比如地址对齐问题）； SIGILL：尝试执行非法的指令，可能不被识别或者没有权限； SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作； SIGPIPE：管道另一端没有进程接手数据； 五、问题 Debug 环境正常，Release 环境崩溃 属性内存语义错误，如 NSArray 使用 assign 修饰，导致访问了释放掉的内存地址。 闪退 数据库损坏：在日常使用异常退出、断电或者错误的操作 文件损坏：处理文件时如果没有 @try…catch，损坏文件会抛出 NSException 导致 crash 网络返回数据异常：数据类型不对，或返回破损的 Tar 包，在解压失败导致 crash。 代码 bug：当必 crash 的代码出现在启动关键路径中，就会导致连续闪退。 解决： 通过工具修复数据库，或者删除 DB。 删除文件来进行修复 具体地分析 crash 案例，通过 JSPatch 来进行修复。 数组越界，nil 值初始化导致的崩溃。 对字典插入 nil 值，或者读取 NSNULL 导致的崩溃。 字符串的截取越界导致的崩溃。 doesNotRecognizeSelector 导致的崩溃。 子线程初始化 UIView 导致的崩溃。 KVO的重复添加、删除，或者忘了删除导致的崩溃。 六、文章悟行Worthy &amp; iOS实现Crash捕获与堆栈符号化Mach-O ExecutablesMach-O Programming TopicsiOS崩溃堆栈信息的符号化解析oncezou &amp; iOS Crash的捕获知识iOS 崩溃处理（拦截和捕获）iOS开发：Crash异常总结与捕获","tags":[]},{"title":"OpenSSL演示RSA加密解密","date":"2019-10-24T01:05:29.626Z","path":"2019/10/24/IT/OpenSSL演示RSA加密解密/","text":"原文：OXHO - iOS—利用OpenSSL演示RSA加密解密，PEM。 链接：来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 主要命令： genrsa 生成并输入一个 RSA 密钥； rsautl 使用 RSA 密钥进行加密、解密、签名和验证等运算； rsa 处理 RSA 密钥的格式转换等问题。 演示步骤： 生成一个私钥 private.pem 文件 1$ openssl genrsa -out private.pem 1024 1024 代表位数，默认是 2048，也可以是 512 的。 提取公钥 public.pem 1$ openssl rsa -in private.pem -pubout -out public.pem cat 命令查看 private.pem 文件 12345678910111213141516$ cat private.pem-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDAXb5xgXWKdGizJ6lFp61U8Mk6TdBP0HgP38ZeiwEysgNfnPS1T8Lf0+OXbkWRdTdLAxCEG6IXp/gwBfqA2yab1GNbtsJSch/KxCqmHlxqbNB54dZH6TvibZLIXVbGysIc/keqkBW0Q+BZ2/bqgsRqDHByVtb5wE8o7AEbv+OD7QIDAQABAoGAH4J7gn4xMbe1urrhaE55/vLeE1XRrHE6aWc/SBc+3/32vX+pOdXR1vYPTqu6a4QmxXvABdO87mEOL1ebW+YJ4a3ktg31AjmCeYBbLUpx2V54kPS3g144zq2VgW2OUJW6+QPBpD7fxeHc9IVU4ecgqPaT25srT43bZ/oo8f4B5UUCQQDjYlg1J5ZiN+m/ELUsT8aOwEPWUt2dfZWmHECDTgTLWyu1lZumrZsND5SRvgvTxFDBTAPSUSrC9uJ9isfbRotnAkEA2JM46HrYttHYCJc4Fz9qUQItw2Nczf4kLozZ9MwD+1vP20rrP3JuHnKQoN+UitWmCMGCT2q5hes5x2oK8gq1iwJAS3yxpevfi/nd+tVUIELXuzpvCu71rbwseznz3OOAyfYZe64QP3Rw/hQHEZ9TE9mfqZxPxHm3xYPqyxzQnqY7zwJBAIugfvQDH2zeZTVEqPjz/Ys0qGRrzw1PZ+xLCsn0Li0DyEJNTtWc5LnkirHs80t+6oiCmYyx9eINATc7essJdHkCQQC2qQfycn7Z43PmYtETznFNZV4NjenQ/EVvVSC0VCCrb4UT4rUcQriUsBBv1gGHP6kzAl3ttXxsoO2W59CDdf7A-----END RSA PRIVATE KEY----- 可以看出就是 base64 编码。 把 private.pem 转成明文 1$ openssl rsa -in private.pem -text -out private.txt 总结：OpenSSL 使用 PEM 文件格式存储证书和密钥。 通过公钥来加密数据 创建一个文本文件 a.txt，写入想要加密的数据 12$ touch a.txt$ vim a.txt &lt;center&gt; ![](http://dzliving.com/openSSL_aTxt.png?imageView2/0/w/350) &lt;/center&gt; * 利用公钥加密 a.txt，输出一个 enc.txt 文件 1openssl rsautl -encrypt -in a.txt -inkey public.pem -pubin -out enc.txt 其中 `-encrypt` 代表加密（和私钥有差异，记得对比） * 公钥加密的 enc 文件，利用私钥解密，生成 dec.txt 文件 1$ openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt &lt;center&gt; ![](http://dzliving.com/openSSL_dec.png?imageView2/0/w/350) &lt;/center&gt; 通过私钥来签名（加密）数据 利用私钥 private.pem 签名 a.txt 1$ openssl rsautl -sign -in a.txt -inkey private.pem -out enc.bin 其中 `-sign` 代表签名，公钥是 `-encrypt` 加密。 利用 “xxd enc.bin” 命令查看 bin 文件加密之后的信息： 123456789$ xxd enc.bin00000000: 6d83 6157 cc0a 27f9 e961 365a 265e 21cc m.aW..'..a6Z&amp;^!.00000010: 38f0 6e12 d824 f66a 484e 70b4 ccdf 62a9 8.n..$.jHNp...b.00000020: 563f 5806 c34d 81bb 6bfb 3ba0 5114 6fe4 V?X..M..k.;.Q.o.00000030: 960c 14d5 91e6 7d0a 4e8f ec76 a8db 1bc4 ......&#125;.N..v....00000040: ac55 5c16 2084 f4f7 bbd6 2795 c4c6 43ff .U\\. .....'...C.00000050: 217d d2ef e790 6980 6843 334c ee76 3315 !&#125;....i.hC3L.v3.00000060: 4933 22e0 4b0b 9524 9fd9 358e 34b2 549c I3\".K..$..5.4.T.00000070: 0db4 2b6e 51c4 bbef 12e1 a899 fca3 30c4 ..+nQ.........0. * 利用公钥 public.pem 解密 enc.bin 1$ openssl rsautl -verify -in enc.bin -inkey public.pem -pubin -out dec.txt","tags":[]},{"title":"SSH","date":"2019-10-23T13:23:39.106Z","path":"2019/10/23/IT/SSH/","text":"一、SSH SSH 是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。 传统的网络服务程序，如：ftp、pop 和 telnet 在本质上都是不安全的，因为它们在网络上用明文传送口令和数据。 SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。既能防止中间人攻击，也能够防止 DNS 欺骗和 IP 欺骗。使用 SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。 SSH 是一个协议标准，其具体的实现有很多，既有开源实现的 OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现 OpenSSH。 SSH 主要由三部分组成： 传输层协议 [SSH-TRANS] 提供了服务器认证，保密性及完整性。此外它有时还提供压缩功能。 SSH-TRANS 通常运行在 TCP/IP 连接上，也可能用于其它可靠数据流上。 SSH-TRANS 提供了强力的加密技术、密码主机认证及完整性保护。该协议中的认证基于主机，并且该协议不执行用户认证。更高层的用户认证协议可以设计为在此协议之上。 用户认证协议 [SSH-USERAUTH] 用于向服务器提供客户端用户鉴别功能。它运行在传输层协议 SSH-TRANS 上面。当 SSH-USERAUTH 开始后，它从低层协议那里接收会话标识符（从第一次密钥交换中的交换哈希 H）。会话标识符唯一标识此会话并且适用于标记以证明私钥的所有权。 SSH-USERAUTH 也需要知道低层协议是否提供保密性保护。 连接协议 [SSH-CONNECT] 将多个加密隧道分成逻辑通道。它运行在用户认证协议上。它提供了交互式登录话路、远程命令执行、转发 TCP/IP 连接和转发 X11 连接。 二、SSH 工作原理在讨论 SSH 的原理和使用前，我们需要分析一个问题：为什么需要 SSH？ SSH 和 telnet、ftp 等协议主要的区别在于安全性。这就引出下一个问题： 如何实现数据的安全呢？ 首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种： 对称加密（也称为秘钥加密） 非对称加密（也称公钥加密） 所谓对称加密，指加密解密使用同一套秘钥。如下图所示： 对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题： 密钥本身存在安全因素，密钥本身存在泄密可能性。如何安全的保存密钥呢？ 尤其是考虑到数量庞大的 Client 端，很难保证密钥不被泄露。一旦一个 Client 端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。 两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。 下面看下使用非对称加密方案的登录流程： 远程 Server 收到 Client 端用户 TopGun 的登录请求，Server 把自己的公钥发给用户。 Client 使用这个公钥，将密码进行加密。 Client 将加密的密码发送给 Server 端。 远程 Server 用自己的私钥，解密登录密码，然后验证其合法性。 若验证结果，给 Client 相应的响应。 私钥是 Server 端独有，这就保证了 Client 的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。 这样就一定安全了吗？ 上述流程会有一个问题：Client 端如何保证接受到的公钥就是目标 Server 端的？如果一个攻击者中途拦截 Client 的登录请求，向其发送自己的公钥，Client 端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了 Client 的登录信息了吗？这就是所谓的中间人攻击。 SSH中是如何解决这个问题的？ 2.1 基于口令的认证从上面的描述可以看出，问题就在于如何对 Server 的公钥进行认证？在 https 中可以通过 CA 来进行公证，可是 SSH 的 publish key 和 private key 都是自己生成的，没法公证。只能通过 Client 端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息： 123The authenticity of host 'ssh-server.example.com (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 上面的信息说的是：无法确认主机 ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？ 之所以用 fingerprint 代替 key，主要是 key 过于长（RSA算法生成的公钥有 1024 位），很难直接比较。所以，对公钥进行 hash 生成一个 128 位的指纹，这样就方便比较了。 如果输入 yes 后，会出现下面信息： 12Warning: Permanently added 'ssh-server.example.com,12.18.429.21' (RSA) to the list of known hosts. Password: (enter password) 该 host 已被确认，并被追加到文件 known_hosts 中，然后就需要输入密码，之后的流程就正常进行。 2.2 基于公钥认证在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH 提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下： Client 将自己的公钥存放在 Server 上，追加在文件 authorized_keys 中。 Server 端接收到 Client 的连接请求后，会在 authorized_keys 中匹配到 Client 的公钥 pubKey，并生成随机数 R，用 Client 的公钥对该随机数进行加密得到 pubKey(R)，然后将加密后信息发送给 Client。 Client 端通过私钥进行解密得到随机数 R，然后对随机数 R 和本次会话的 SessionKey 利用 MD5 生成摘要 Digest1，发送给 Server 端。 Server 端会也会对 R 和 SessionKey 利用同样摘要算法生成 Digest2。 Server 端会最后比较 Digest1 和 Digest2 是否相同，完成认证过程。 在步骤 1 中，Client 将自己的公钥存放在 Server 上。需要用户手动将公钥 copy 到 server 上。这就是在配置 ssh 的时候进程进行的操作。下图是 GitHub 上 SSH keys 设置视图： Server 端根据什么信息在 authorized_keys 中进行查找的呢？主要是根据 Client 在认证的开始会发送一个 KeyID 给Server，这个 KeyID 是唯一对应 Client 的一个 PublicKey，Server 就是通过该 KeyID 在 authorized_keys 进行查找对应的 PublicKey。 三、密钥协商算法通过 Diffie-Hellman 算法来实现，具体过程： 服务端和客户端共同选定一个大素数，叫做种子值； 服务端和客户端各自独立选择另外一个只有自己才知道的素数 双方使用相同的加密算法(AES)，由种子值和各自私有的素数生成一个密钥值，并将这个值发送给对方 在收到密钥后，服务端和客户端根据种子值和自己的私有素数，计算出一个最终的密钥 双方使用上一步得到的结果作为密钥来加密和解密通信内容 四、SSH 实践 生成密钥操作 经过上面的原理分析，下面三行命令的含义应该很容易理解了： 123$ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys ssh-keygen 是用于生产密钥的工具。 -t：指定生成密钥类型（rsa、dsa、ecdsa 等） -P：指定 passphrase，用于确保私钥的安全 -f：指定存放密钥的文件（公钥、私钥文件默认在同目录下，但存放公钥的文件名需要加上后缀 .pub） 首先看下面 ~/.ssh 中的四个文件： id_rsa：保存私钥 id_rsa.pub：保存公钥 authorized_keys：保存已授权的客户端公钥 known_hosts：保存已认证的远程主机 ID 四个角色的关系如下图所示： 注意：一台主机可能既是 Client，也是 Server。所以会同时拥有 authorized_keys 和 known_hosts。 登录操作 12345678# 以用户名 user，登录远程主机 host$ ssh user@host# 本地用户和远程用户相同，则用户名可省去$ ssh host# SSH 默认端口 22，可以用参数 p 修改端口$ ssh -p 2017 user@host 五、known_hosts机制 known_hosts 中存储的内容是什么？ known_hosts 中存储是已认证的远程主机 host key，每个 SSH Server 都有一个 secret, unique ID, called a host key。 host key 何时加入 known_hosts 的？ 当我们第一次通过 SSH 登录远程主机的时候，Client 端会有如下提示： 12Host key not found from the list of known hosts.Are you sure you want to continue connecting (yes/no)? 此时，如果我们选择 yes，那么该 host key 就会被加入到 Client 的 known_hosts 中，格式如下： 12# domain name+encryption algorithm+host keyexample.hostname.com ssh-rsa AAAAB4NzaC1yc2EAAAABIwAAAQEA... 为什么需要 known_hosts？ 这个文件主要是通过 Client 和 Server 的双向认证，从而避免中间人攻击，每次 Client 向 Server 发起连接的时候，不仅仅 Server 要验证 Client 的合法性，Client 同样也需要验证 Server 的身份，SSH client 就是通过 known_hosts 中的 host key 来验证 Server 的身份的。 这种方案足够安全吗？当然不，比如第一次连接一个未知 Server 的时候，known_hosts 还没有该 Server 的 host key，这不也可能遭到中间人攻击吗？这可能只是安全性和可操作性之间的折中吧。 六、问题 如果 client 生成多个密钥对，把对应的公钥全部传到 server 端，这时候 server 端如何决定用哪个公钥对随机数进行加密？ 多密钥场景下，需要在 ~/.ssh/config 下进行配置，显示指定主机和 key 的对应关系，格式如下： 1234567891011Host server01HostName example1.comPort 1000IdentityFile ~/.ssh/id_rsa_xxxUser user01Host server02HostName example2.comPort 1000IdentityFile ~/.ssh/id_rsa_zzzUser user02 七、文章TopGun_Viper - 图解SSH原理SSHLinux ssh命令详解","tags":[]},{"title":"Git","date":"2019-10-22T11:15:56.481Z","path":"2019/10/22/IT/Git/","text":"一、Git 工作流程 Workspace：工作区 Index / Stage：暂存区（和 git stash 命令暂存的地方不一样） Repository：仓库区（或本地仓库） Remote：远程仓库 1.1 工作区程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 1.2 暂存区.git 目录下的 index 文件，暂存区会记录 git add 添加文件的相关信息(文件名、大小、timestamp，…)，不保存文件实体，通过 id 指向每个文件实体。可以使用 git status 查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被 git 管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过 git add 先提交到暂存区，被 git 管理。 1.3 本地仓库保存了对象被提交过的各个版本，比起工作区和暂存区的内容，它要更旧一些。 git commit 后同步 index 的目录树到本地仓库，方便从下一步通过 git push 同步本地仓库与远程仓库的同步。 1.4 远程仓库远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 1.5 小结 任何对象都是在工作区中诞生和被修改； 任何修改都是从进入 index 区才开始被版本控制； 只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹； 与协作者分享本地的修改，可以把它们push到远程仓库来共享。 下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用的 Git 命令 2.1 HEAD HEAD 始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD 就会跟着改变。 2.2 add add 主要实现将工作区修改的内容提交到暂存区，交由 git 管理。 |命令|描述||:—-|:—–||git add .|添加当前目录的所有文件到暂存区||git add \\&lt;dir>|添加指定目录到暂存区，包括子目录||git add \\&lt;file1>|添加指定文件到暂存区| 2.3 commit commit 主要实现将暂存区的内容提交到本地仓库，并使得当前分支的 HEAD 向后移动一个提交点。 |命令|描述||:———-|:———||git commit -m \\&lt;message>|提交暂存区到本地仓库，message 代表说明信息||git commit -m \\&lt;message>|提交暂存区的指定文件到本地仓库||git commit –amend -m \\&lt;message>|使用一次新的 commit，替代上一次提交| 2.4 branch 涉及到协作，自然会涉及到分支。关于分支，大概有四种操作： 展示分支 切换分支 创建分支 删除分支 分支是用来标记特定代码的提交，每一个分支通过 SHA1sum 值来标识，所以对分支的操作是轻量级的，你改变的仅仅是 SHA1sum 值。 |命令|描述||:——–|:———||git branch|列出所有本地分支||git branch -r|列出所有远程分支||git branch -a|列出所有本地分支和远程分支||git branch \\&lt;branch-name>|新建一个分支，但依然停留在当前分支||git checkout -b \\&lt;branch-name>|新建一个分支，并切换到该分支||git branch –track \\&lt;branch>\\&lt;remote-branch>|新建一个分支，与指定的远程分支建立追踪关系||git checkout \\&lt;branch-name>|切换到指定分支，并更新工作区||git branch -d \\&lt;branch-name>|删除分支||git push origin –delete \\&lt;branch-name>|删除远程分支| 2.5 fetch 命令 描述 git fetch &lt;远程主机名&gt; 将某个远程主机的更新全部取回本地 git fetch &lt;远程主机名&gt; &lt;分支名&gt; 取回特定分支的更新 git fetch origin master 取回 origin 主机的 master 分支 取回更新后，会返回一个 FETCH_HEAD，指的是某个 branch 在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1$ git log -p FETCH_HEAD 2.6 merge merge 命令把不同的分支合并起来。如上图，在实际开放中，我们可能从 master 分支中切出一个分支，然后进行开发完成需求，中间经过 R3、R4、R5 的 commit 记录，最后开发完成需要合入 master 中，这便用到了 merge。 |命令|描述||:——–|:——-||git fetch \\&lt;remote>|merge 之前先拉一下远程仓库最新代码||git merge \\&lt;branch>|合并指定分支到当前分支| 一般在 merge 之后，会出现 conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。 中断合并 1git merge --abort 撤销合并 撤销合并时采用 git reset/revert 操作。 2.7 rebase rebase 又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于 new 分支上，执行 git rebase dev，那么 new 分支上新的 commit 都在master 分支上重演一遍，最后 checkout 切换回到 new 分支。这一点与 merge 是一样的，合并前后所处的分支并没有改变。 git rebase dev，通俗的解释就是 new 分支想站在 dev 的肩膀上继续下去。rebase也需要手动解决冲突。 rebase 与 merge 的区别 现在我们有这样的两个分支：test 和 master，提交如下： 123 D---E test /A---B---C---F master 在 master 执行 git merge test，然后会得到如下结果： 123 D--------E / \\A---B---C---F----G test, master 在 master 执行 git rebase test，然后得到如下结果： 1A---B---D---E---C'---F' test, master 可以看到，merge 操作会&lt;font color=#cc0000&gt;生成一个新的节点&lt;/font&gt;，之前的提交分开显示。而 rebase 操作&lt;font color=#cc0000&gt;不会生成新的节点&lt;/font&gt;，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有 merge commit 的线性历史树，那么你应该选择 git rebase；如果你想保留完整的历史记录，并且想要避免重写 commit history 的风险，你应该选择使用 git merge。 2.8 reset reset 命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 |命令|描述||:——|:——-||git reset —soft \\&lt;commit>|只改变提交点，暂存区和工作目录的内容都不改变||git reset —mixed \\&lt;commit>|改变提交点，同时改变暂存区的内容||git reset —hard \\&lt;commit>|暂存区、工作区的内容都会被修改到与提交点完全一致的状态||git reset –hard HEAD|让工作区回到上次提交时的状态| 2.9 revert git revert 用一个新提交来消除一个历史提交所做的任何修改。 revert 与 reset 的区别 git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别。因为 git revert 是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，导致这部分改变不会再次出现，减少冲突。但是 git reset 是之间把某些 commit 在某个 branch 上删除，因而和老的branch 再次 merge 时，这些被回滚的 commit 应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。 2.10 push上传本地仓库分支到远程仓库分支，实现同步。 |命令|描述||:——–|:——-||git push \\&lt;remote>\\&lt;branch>|上传本地指定分支到远程仓库||git push \\&lt;remote> –force|强行推送当前分支到远程仓库，即使有冲突||git push \\&lt;remote> –all|推送所有分支到远程仓库| 2.11 pullgit pull 的过程可以理解为： 12git fetch origin master // 从远程主机的 master 分支拉取最新内容 git merge FETCH_HEAD // 将拉取下来的最新内容合并到当前所在的分支中 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为： 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略： 1$ git pull origin next 2.12 stash 命令 描述 git stash save “xx” 执行存储，并添加备注，只执行 git stash 也是可以的，但查找时不方便识别 git stash list 查看 stash 了哪些存储 git stash show 显示做了哪些修改，默认 show 第一个存储，如果要显示其他存储，后面加stash@{$num}，比如第二个 git stash show stash@{1} git stash show -p 显示第一个存储的改动，如果想显示其他存储，加上 stash@{$num}，比如第二个：git stash show stash@{1} -p git stash apply 应用某个存储，但不会把存储从存储列表中删除，默认使用第一个存储，即 stash@{0}，如果要使用其他的，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} git stash pop 命令恢复之前缓存的工作目录，将缓存堆栈中的对应 stash 删除，并将对应修改应用到当前的工作目录下，默认为第一个 stash，即 stash@{0}，如果要应用并删除其他 stash，命令：git stash pop stash@{$num}，比如应用并删除第二个：git stash pop stash@{1} git stash drop stash@{$num} 丢弃 stash@{$num} 存储，从列表中删除这个存储 git stash clear 删除所有缓存的stash 注意：没有在 git 版本控制中的文件，是不能被 git stash 存起来的。 如果新增了一个文件，直接执行 git stash 是不会存起来的，可以先执行 git add，再执行 git stash。 这个时候，想切分支就再也不会报错有改动未提交了。 如果要应用这些 stash，直接使用 git stash apply 或者 git stash pop 就可以再次导出来了。 总结 git add 只是把文件加到 git 版本控制里，并不等于就被 stash 起来了，git add 和 git stash 没有必然的关系，但是执行 git stash 能正确存储的前提是文件必须在 git 版本控制中才行。 常规 git stash 的一个限制是它会一下暂存所有的文件。有时，只备份某些文件更为方便，让另外一些与代码库保持一致。一个非常有用的技巧，用来备份部分文件： add 那些你不想备份的文件 调用 git stash –keep-index。只会备份那些没有被 add 的文件。 调用 git reset 取消已经 add 的文件的备份，继续自己的工作。 2.13 其他命令|命令|描述||:——|:——-||git status|显示有变更的文件||git log|显示当前分支的版本历史||git diff|显示暂存区和工作区的差异||git diff HEAD|显示工作区与当前分支最新 commit 之间的差异||git cherry-pick \\&lt;commit>|选择一个 commit，合并进当前分支| 三、Git Reset 三种模式使用 Git 时有可能 commit 提交代码后，发现这一次 commit 的内容是有错误的，那么有两种处理方法： 修改错误内容，再次 commit一次 使用 git reset 命令撤销这一次错误的 commit 第一种方法多一条 commit 记录；第二种方法，错误的 commit 不会被保留下来。 git reset：Reset current HEAD to the specified state。让 HEAD 指针指向其他的地方。 例如我们有一次 commit 不是很满意，需要回到上一次的 Commit 里面。那么这个时候就需要通过 reset，把 HEAD 指针指向上一次的 commit 的点。 它有三种模式：soft、mixed、hard。 这三个模式理解了，对于使用这个命令很有帮助。在理解这三个模式之前，需要略微知道一点 Git 的基本流程。 简单叙述一下把文件存入 Repository 流程： 刚开始 working tree、index 与 repository(HEAD) 里面的内容都是一致的。 当 git 管理的文件夹里面的内容出现改动后，此时 working tree 的内容就会跟 index 及 repository(HEAD) 的不一致，而 Git 知道是哪些文件(Tracked File)被改动过，直接将文件状态设置为 modified (Unstaged files)。 当我们执行 git add 后，会将这些改变的文件内容加入 index 中 (Staged files)，所以此时working tree 跟 index 的内容是一致的，但与 repository(HEAD) 内容不一致。 接着执行 git commit 后，将 Git 索引中所有改变的文件内容提交至 Repository 中，建立出新的 commit 节点(HEAD)后， working tree、index 与 repository(HEAD) 区域的内容 又会保持一致。 3.1 reset –hard reset –hard 会在重置 HEAD 和 branch 的同时，重置 stage 区和工作目录里的内容。 当你在 reset 后面加了 –hard 参数时，你的 stage 区和工作目录里的内容会被完全重置为和 HEAD 的新位置相同的内容。换句话说，就是你的没有 commit 的修改会被全部擦掉。 然后，你执行了 reset 并附上了 –hard 参数： 1git reset --hard 你的 HEAD 和当前 branch 切到上一条 commit 的同时，你工作目录里的新改动和已经 add 到 stage 区的新改动也一起全都消失了： 可以看到，在 reset –hard 后，所有的改动都被擦掉了。 3.2 reset –soft reset –soft 会在重置 HEAD 和 branch 时，保留工作目录和暂存区中的内容，并把重置 HEAD 所带来的新的差异放进暂存区。 什么是「重置 HEAD 所带来的新的差异」？就是这里： 由于 HEAD 从 4 移动到了 3，而且在 reset 的过程中工作目录和暂存区的内容没有被清理掉，所以 4 中的改动在 reset 后就也成了工作目录新增的「工作目录和 HEAD 的差异」。这就是上面一段中所说的「重置 HEAD 所带来的差异」。 此模式下会保留 working tree 工作目录的内容，不会改变到目前所有的 git 管理的文件夹的内容；也会保留 index 暂存区的内容，让 index 暂存区与 working tree 工作目录的内容是一致的。就只有 repository 中的内容的更变需要与 reset 目标节点一致，因此原始节点与 reset 节点之间的差异变更集合会存在与 index 暂存区中(Staged files)，所以我们可以直接执行 git commit 将 index 暂存区中的内容提交至 repository 中。当我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录（可能是阶段性地频繁提交）时，可以考虑使用 Soft Reset 来让 commit 演进线图较为清晰点。 修改后的 AppDelegate.h 文件 add 到 stage 区，修改后的 AppDelegate.m 保留在工作目录 查看当前最新的 commit 记录 1git show --stat &lt;center&gt; ![](http://dzliving.com/Git_Reset_9.png) &lt;/center&gt; 执行 git reset –soft HEAD^ 那么除了 HEAD 和它所指向的 branch1 被移动到 HEAD^ 之外，原先 HEAD 处 commit 的改动（README.md 文件）也会被放进暂存区。 这就是 –soft 和 –hard 的区别：–hard 会清空工作目录和暂存区的改动，而 –soft 则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。 3.3 reset –mixed reset 如果不加参数，那么默认使用 –mixed 参数。它的行为是：保留工作目录，并且清空暂存区。也就是说，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。 以上面的情况为例： 工作目录的内容和 –soft 一样会被保留，但和 –soft 的区别在于，它会把暂存区清空，并把原节点和 reset 节点的差异的文件放在工作目录。总而言之就是，工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。 3.4 总结 reset 的本质：移动 HEAD 以及它所指向的 branch。 实质上，reset 这个指令虽然可以用来撤销 commit，但它的实质行为并不是撤销，而是移动 HEAD ，并且「捎带」上 HEAD 所指向的 branch（如果有的话）。也就是说，reset 这个指令的行为其实和它的字面意思“重置”十分相符：它是用来重置 HEAD 以及它所指向的 branch 的位置的。 而 reset –hard HEAD^ 之所以起到了撤销 commit 的效果，是因为它把 HEAD 和它所指向的 branch 一起移动到了当前 commit 的父 commit 上，从而起到了「撤销」的效果： Git 的历史只能往回看，不能向未来看，所以把 HEAD 和 branch 往回移动，就能起到撤回 commit 的效果。 所以同理，reset –hard 不仅可以撤销提交，还可以用来把 HEAD 和 branch 移动到其他的任何地方。 1git reset --hard branch2 3.5 reset 三种模式区别和使用场景 区别 –hard：重置位置的同时，直接将 working Tree工作目录、index 暂存区及 repository 都重置成目标 Reset 节点的内容，所以效果看起来等同于清空暂存区和工作区。 –soft：重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中(Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。 –mixed（默认）：重置位置的同时，只保留 Working Tree 工作目录的内容，但会将 Index 暂存区和 Repository 中的内容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。 使用场景 –hard： 要放弃目前本地的所有改变时，即去掉所有 add 到暂存区的文件和工作区的文件，可以执行 git reset -hard HEAD 来强制恢复 git 管理的文件夹的内容及状态； 真的想抛弃目标节点后的所有 commit（可能觉得目标节点到原节点之间的 commit 提交都是错了，之前所有的 commit 有问题）。 –soft 原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中(Staged files)，所以假如我们之前工作目录没有改过任何文件，也没 add 到暂存区，那么使用 reset –soft 后，我们可以直接执行 git commit 将 index 暂存区中的内容提交至 repository 中。为什么要这样呢？这样做的使用场景是：假如我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录(可能是阶段性地频繁提交,就是开发一个功能的时候，改或者增加一个文件的时候就commit，这样做导致一个完整的功能可能会好多个commit点，这时假如你需要把这些commit整合成一个commit的时候)时，可以考虑使用reset –soft来让 commit 演进线图较为清晰。总而言之，可以使用 –soft 合并 commit 节点。 –mixed（默认） 使用完reset –mixed 后，我們可以直接执行 git add 将這些改变果的文件内容加入 index 暂存区中，再执行 git commit 将 Index暂存区 中的内容提交至Repository中，这样一样可以达到合并commit节点的效果（与上面–soft合并commit节点差不多，只是多了git add添加到暂存区的操作）； 移除所有Index暂存区中准备要提交的文件(Staged files)，我们可以执行 git reset HEAD 来 Unstage 所有已列入 Index暂存区 的待提交的文件。(有时候发现add错文件到暂存区，就可以使用命令)。 commit提交某些错误代码，或者没有必要的文件也被commit上去，不想再修改错误再commit（因为会留下一个错误commit点），可以回退到正确的commit点上，然后所有原节点和reset节点之间差异会返回工作目录，假如有个没必要的文件的话就可以直接删除了，再 commit 上去就 OK 了。 四、文章GitRuheng - 一篇文章，教你学会Gitcarway - Git Reset 三种模式Git回滚MergeGit远程操作详解","tags":[]},{"title":"GLSL之变量和数据类型","date":"2019-10-21T13:12:34.682Z","path":"2019/10/21/GLSL/GLSL之变量和数据类型/","text":"原文：OpenGL ES着色器语言之变量和数据类型 所有变量和函数在使用前必须声明。变量和函数名是标识符。 没有默认类型，所有变量和函数声明必须包含一个声明类型以及可选的修饰符。变量在声明的时候首先要标明类型，后边可以跟多个变量，之间用逗号隔开。很多情况下，变量在声明的时候可以使用等号“=”进行初始化。 用户定义类型可以使用 struct，在结构体中所有变量类型都必须是 OpenGL ES 着色器语言定义的关键字。 OpenGL ES 着色语言是类型安全的，因此不支持隐式类型转换。 一、基本数据类型|Type|Meaning||:—-|:—–||void|for functions that do not return a value or for an empty parameter list||bool|a conditional type, taking on values of true or false||int|a signed integer||float|a single floating-point scalar||vec2|a two component floating-point vector||vec3|a three component floating-point vector||vec4|a four component floating-point vector||bvec2|a two component Boolean vector||bvec3|a three component Boolean vector||bvec4|a four component Boolean vector||ivec2|a two component integer vector||ivec3|a three component integer vector||ivec4|a four component integer vector||mat2|a 2x2 floating-point matrix||mat3|a 3x3 floating-point matrix||mat4|a 4x4 floating-point matrix||sampler2D|a handle for accessing a 2D texture||samplerCube|a handle for accessing a cube mapped texture| void 函数没有返回值必须声明为void，没有默认的函数返回值。关键字void不能用于其他声明，除了空形参列表外。 Booleans 布尔值，只有两个取值 true 或 false。 1bool success, done = false; Integers 整型主要作为编程的援助角色。在硬件级别上，真正地整数帮助有效的实现循环和数组索引，纹理单元索引。然而，着色语言没必要将整型数映射到硬件级别的整数。我们并不赞成底层硬件充分支持范围广泛的整数操作。OpenGL ES 着色语言会把整数转化成浮点数进行操作。整型数可以使用十进制（非 0 开头数字），八进制（0 开头数组）和十六进制表示（0x 开头数字）。 1int i, j = 42; Floats 浮点型用于广泛的标量计算。可以如下定义一个浮点数： 1float a, b = 1.5; Vectors OpenGL ES 着色语言包含像 2-，3-，4- 浮点数、整数、booleans 型向量的泛型表示法。浮点型向量可以保存各种有用的图形数据，如颜色，位置，纹理坐标。 12345vec2 texCoord1, texCoord2;vec3 position;vec4 rgba;ivec2 textureLookup;bvec3 lessThan; 向量的初始化工作可以放在构造函数中完成。 Matrices 矩阵是另一个在计算机图形中非常有用的数据类型，OpenGL ES着色语言支持22， 33, 4*4浮点数矩阵。 123mat2 mat2D;mat3 optMatrix;mat4 view, projection; 矩阵的初始化工作可以放在构造函数中完成。 Sampler 采样器类型（如 sampler2D）实际上是纹理的不透明句柄。 它们用在内建的纹理函数来指明要访问哪一个纹理。它们只能被声明为函数参数或 uniforms。除了纹理查找函数参数， 数组索引， 结构体字段选择和圆括号外，取样器不允许出现在表达式中。取样器不能作为左值，也不能作为函数的 out 或 inout 参数。这些限制同样适用于包含取样器的的结构体。作为 uniforms 时，它们通过 OpenGL ES API 初始化。作为函数参数，仅能传入匹配的采样器类型。这样可以在着色器运行之前进行着色器纹理访问和 OpenGL ES 纹理状态的一致性检查。 Structures 通过结构体用户可以创建自己的数据类型。 1234struct light &#123; float intensity; vec3 position;&#125; lightVar; 结构体不支持内部匿名结构体对象，也不支持内部嵌入结构体，但可以声明另一个结构体的变量。 Arrays 同种类型的变量可以放在一个数组中保存和管理。数组长度必须是大于 0 的常整型数。用负数或大于等于数组程度的索引值索引数组是不合法的。数组作为函数形参必须同时指明数组长度。仅支持一维数组，基本数据类型和结构体类型都可以作为数组元素。 12345float frequencies[3];uniform vec4 lightPosition[4];const int numLights = 2;light lights[bumLights]; 不能在着色器中，声明数组的同时进行初始化。 二、Scopes声明的范围决定了变量的可见性。GLSL ES 使用了静态嵌套范围，允许在着色器内重定义一个变量。 2.1 术语的定义术语 scope 说明程序的一个特定的区域，在这个区域定义的变量时可见的。 2.2 范围类型1234567891011121314151617181920212223242526E.g. int x = 1; &#123; int x = 2 /* 2nd x visible here */, y = x; // y is initialized to 2 &#125; E.g. int x = 1; &#123; int x = 2, y = x; // y is initialized to '2' int z = z; // error if z not previously defined. &#125; &#123; int x = x; // x is initalized to '1' &#125;E.g. struct T &#123; int x; int y; &#125;; &#123; T t = T(0, 0); // 't' is only visible as a struct and constructor t; // 't' is now visible only as a variable &#125; 2.3 重声明变量在一个编译单元，具有相同名字的变量不能重声明在同一个范围。可以在不同的范围内声明同名的变量，但没有办法访问外层范围的同名变量。 2.4 共享全局变量共享全局变量是指可以在多个编译单元访问的变量。在 GLSL ES 中仅 uniform 变量可以作为全局共享变量。varying 变量不能作为全局共享变量因为在片元着色器能读取它们之前必须通过光栅化传递。 共享全局变量必须有相同的名字，存储和精度修饰符。它们必须有如下相同等价的规则：必须具有相同的精度，基本类型和尺寸。标量必须有一样的类型名称和类型定义，而且字段名称必须为相同类型。 三、存储修饰符|Qualifier|Meaning||:—-:|:—-||&lt;none：default&gt;|local read/write memory, or an input parameter to a function||const|a compile-time constant, or a function parameter that is read-only||attribute|linkage between a vertex shader and OpenGL ES for per-vertex data||uniform|value does not change across the primitive being processed, uniforms form the linkage between a shader, OpenGL ES, and the application||varying|linkage between a vertex shader and a fragment shader for interpolated data| 本地变量只能使用存储修饰符 const。 函数参数只能用const。函数返回值类型和结构体字段不要使用const。 从一个运行时着色器到下一个运行时着色器之间进行数据类型通信是不存在的。这阻止了同一个着色器在多个顶点和片元之间同时执行。 没有存储修饰符或仅仅使用 const 修饰符的全局变量，可能在 main() 执行前进行初始化。Uniforms， attributes 和 varyings 可能没有初始化器。 3.1 默认存储修饰符如果在全局变量前没有修饰符，那么它们就与应用程序和其他处理器上的着色器没有关联。对于全局或本地的无修饰符变量，声明都会在其所属的那个处理器上分配内存。这个变量将提供对分配的内存的读写访问。 3.2 常量修饰符 命名的编译时常量可以用 const 声明。 任何使用 const 声明的变量在其所属的着色器中均是只读的。 将变量声明为常量可以减少使用硬连线的数字常数。 const 可以用来修饰任何基本数据类型。 通常 const 变量在声明的同时要进行初始化： 1const vec3 zAxis = vec3 (0.0, 0.0, 1.0); 结构体字段不能使用 const 修饰吗，但是变量可以，并通过构造器进行初始化。包含数组的数组和结构体不能声明为常量，因为它们不能被初始化。 3.3 Attribute attribute 修饰符用于声明通过 OpenGL ES 应用程序传递到顶点着色器中的变量值。 在其它任何非顶点着色器的着色器中声明 attribute 变量是错误的。 在顶点着色器被程序使用之前，attribute 变量是只读的。attribute 变量的值通过 OpenGL ES 顶点 API 或者作为顶点数组的一部分被传进顶点着色器。它们传递顶点属性值到顶点着色器，并且在每一个运行的顶点着色器中都会改变。 attribute 修饰符只能修饰 float、vec2、vec3、vec4、mat2、mat3、mat4。 attribute 变量不能声明为数组或结构体。 如： 123attribute vec4 position;attribute vec3 normal;attribute vec2 texCoord; 大家可能希望图形硬件有极少量的固定位置来传递顶点属性。所以，OpenGL ES 为每一个非矩阵变量赋予了升级到 4 个浮点数值的空间，如 vec4。 在 OpenGL ES 中，可以使用的属性变量个数是有限制的，如果超过这个限制，将会引起链接错误。（声明了但没有使用的属性变量不会受到这个限制。）一个浮点数属性也要受到这个限制，所以你应该尽量将四个毫不相关的 float 变量打包成一个 pack，以优化底层硬件的兼容性。一个 mat4 和使用 4 个 vec4 变量是一致的，同理，一个 mat3 和使用 3 个 vec3 变量是一致的，一个 mat2 和使用 2 个 vec2 变量是一致的。 着色语言和 API 隐藏了到底这些空间是如何被矩阵使用的。属性变量需要被声明为全局变量。 3.4 Uniform uniform 修饰符用来修饰那些在整个图元被处理的过程中保持不变的全局变量。 所有的 uniform 变量都是只读的，可以通过应用程序调用 API 命令初始化，或者通过 OpenGL ES 间接初始化。 1uniform vec4 lightPosition; uniform 修饰符可以和任意基本数据类型一起使用，或者包含基本数据类型元素的数组和结构体。 每种类型的着色器的 uniform 变量的存储数量是有限制的，如果超过这个限制，将会引起编译时或链接时错误。声明了但是没有被静态使用的 uniform 变量不会受到这个限制。 静态使用（static use）是指着色器包含变量在预处理以后的一个引用。 用户定义的 uniform 变量和着色器中被静态使用的内建 uniform 变量将共同决定有没有超出可用uniform 存储范围。 当顶点着色器和片元着色器被链接到一起，它们将共享同一个名称空间。这就意味着，所有被连接到同一个可执行程序的着色器中的同名变量必须也同时具有相同的类型和精度。 3.5 Varyingvarying 变量提供了顶点着色器、片元着色器和二者通讯控制模块之间的接口。顶点着色器计算每个顶点的值（如颜色，纹理坐标等）并将它们写到 varying 变量中。顶点着色器也会从 varying 变量中读值，获取和它写入相同的值。如果从顶点着色器中读取一个尚未被写入的 varying 变量，将返回未定义值。 通过定义，每个顶点的 varying 变量以一种透视校正的方式被插入到正在渲染的图元上。如果是单采样，插值为片元中心；如果是多采样，插值可以是像素中的任何地方，包括片元中心或者其中一个片元采样。 片元着色器会读取 varying 变量的值，并且被读取的值将会作为插值器，作为图元中片元位置的一个功能信息。varying 变量对于片元着色器来说是只读的。 在顶点和片元着色器中都有声明的同名 varying 变量的类型必须匹配，否则将引起链接错误。 下表总结了顶点和片元着色器匹配的规则： 术语“静态使用”意思是在预处理之后，着色器至少包含一个访问 varying 变量的语句，即使这个语句没有真正执行过。 1varying vec3 normal; varying 修饰符只能用在 float、vec2、vec3、vec4、mat2、mat3、mat4 和包含这些类型元素的数组上，不能用于修饰结构体。 varying 变量需要声明为全局变量。 四、参数修饰符函数参数修饰符有如下几种： \\&lt;none: default>，默认情况下，是 in in，作为函数的传入参数 out，作为函数的传出参数 inout，即作为传入参数，又作为传出参数 五、精度和精度修饰符5.1 范围和精度用于存储和展示浮点数、整数变量的范围和精度依赖于数值的源（varying，uniform，纹理查找，等等），是不是顶点或者片元着色器，还有其他一些底层实现的细节。最低存储需要通过精度修饰符来声明。典型地，精度操作必须要保留变量包含的精度存储。仅有的例外是需要大量复杂计算的内建函数，如 atan()，返回值的精度低于声明的精度。 强烈建议顶点语言提供一种匹配 IEEE 单精度浮点数或更高精度的浮点数的浮点范围和精度。这就需要顶点语言提供浮点变量的范围至少是(-2^62, 2^62)，精度至少是 65536。 顶点语言必须提供一种至少16位，加上一个符号位的整数精度。 片元语言提供与顶点着色器相同的浮点数范围和精度是很有必要的，但不是必须的。这就需要片元语言提供的浮点数的范围至少是（-16384，+16384），精度至少是 1024。 片元语言必须提供一种至少 10 位，加上一个符号位的整数精度。 5.2 精度修饰符任何浮点数或者整数声明前面都可以添加如下精度修饰符： 1234lowp float color;varying mediump vec2 Coord;lowp ivec2 foo(lowp mat3);highp mat4 m; 精度修饰符声明了底层实现存储这些变量必须要使用的最小范围和精度。 实现可能会使用比要求更大的范围和精度，但绝对不会比要求少。 以下是精度修饰符要求的最低范围和精度： Qualifier Floating Point Range Floating Point Magnitude Range Floating Point Precision Integer Range highp (-262, 262) (2-62, 262) Relative:2-16 (-216, 216) mediump (-214, 214) (2-14, 214) Relative:2-10 (-210, 210) lowp (-2, 2) (2-8, 2) Absolute:2-8 (-28, 28) Floating Point Magnitude Range 是非零值量级的范围。 对于 Floating Point Precision，relative 意思是任何度量的值的精度都是相对于这个值的。 对于所有的精度级别，0 必须被精确的表示出来。 任何不能提供着色器存储变量所声明的精度的实现都会引起一个编译或链接错误。 对于高精度和中级精度，整型范围必须可以准确地转化成相应的相同精度修饰符所表示的 float 型。这样的话，highp int 可以被转换成 highp float，mediump int 可以被转换成 mediump float，但是 lowp int 不能转换成相应的 lowp float。 顶点语言要求编译和链接任何 lowp、mediump 和 highp 应用都不能出现错误。 片元语言要求编译和链接任何 lowp、mediump 应用都不能出现错误。但是 highp 支持是可选的。 字符常量和布尔型没有精度修饰符 当浮点数和整数构造器不含带有精度修饰符的参数时也不需要精度修饰符。 在这段文档中，操作包含运算符，内建函数和构造器，操作数包含函数参数和构造器参数。 对于精度没有定义的常量表达式或子表达式,评估的精度结果是所有操作数中的最高精度（mediump或者highp) 。带评估的常量表达式必须是固定不变的，并且在编译期进行。 另外，对于没有精度修饰符的操作数，精度将来自于其他操作数。如果所有的操作数都没有精度，那么接着看使用计算结果的其他表达式。这个操作是递归的，直到找到一个有精度的操作符为止。如果必要，这个操作也包含赋值运算的左值，初始化声明的变量，函数形参、函数返回值.如果这样依然不能决定精度,如果组成表达式的所有操作数都没有精度,如果结果没有被赋值,也没有当作参数传进函数,那么将使用默认或更大的类型.当这种情况出现在片元着色器中,默认的精度必须被定义. 比如: 123456789101112uniform highp float h1;highp float h2 = 2.3*4.7; // 操作和结果都是高精度mediump float m;m = 3.7*h1*h2; // 所有操作都是高精度h2 = m * h1; // 操作是高精度m = h2 - h1; // 操作是高精度h2 = m + m; // 加法和结果都是 mediump 精度void f(highp p);f(3.3); // 3.3 将作为高精度值传入函数 5.3 默认精度修饰符 precision precision-qualifier type; precision 可以用来确定默认精度修饰符。 type 可以是 int 或 float 或采样器类型 precision-qualifier 可以是 lowp，mediump 或者 highp。 任何其他类型和修饰符都会引起错误。 如果 type 是 float 类型，那么该精度（precision-qualifier）将适用于所有无精度修饰符的浮点数声明（标量，向量，矩阵）。 如果 type 是 int 类型，那么该精度（precision-qualifier）将适用于所有无精度修饰符的整型数声明（标量，向量）。包括全局变量声明，函数返回值声明，函数参数声明，和本地变量声明等。没有声明精度修饰符的变量将使用和它最近的 precision 语句中的精度。 在顶点语言中有如下预定义的全局默认精度语句： 1234precision highp float;precision highp int;precision lowp sampler2D;precision lowp samplerCube; 在片元语言中有如下预定义的全局默认精度语句： 123precision mediump int;precision lowp sampler2D;precision lowp samplerCube; 片元语言没有默认的浮点数精度修饰符。因此，对于浮点数、浮点数向量和矩阵变量声明，要么声明必须包含一个精度修饰符，要不默认的精度修饰符在之前已经被声明过了。 5.4 可用的精度修饰符内建宏 GL_FRAGMENT_PRECISION_HIGH 在支持 highp 精度的片元语言中是定义过的，但在不支持的系统中是未定义的。一旦定义以后，在顶点和片元语言中都可以使用。 1#defien GL_FRAGMENT_PRECISION_HIGH 1; 六、变异和 invariant 修饰符在这部分中，变异是指在不同的着色器中的相同语句返回不同的值的可能性。 举个例子，两个顶点着色器都使用相同的表达式来设置 gl_Position，并且当着色器执行时传进表达式的值也是一样的。完全有可能，由于两个着色器独立的编译环境，当着色器运行时赋给 gl_Position 的值不一定会相同。在这个例子中，会引起多路算法的几何对齐问题。 通常，着色器之间的这种变异是允许的。如果想避免这种变异的发生，变量可以使用 invariant 来声明。 6.1 invariant修饰符为确保一个特定的输出变量是不变的，可以使用 invariant 修饰符。它可以修饰之前已经定义过的变量,如: 1invariant gl_Position; 也可以用在变量的声明当中: 1invariant varying mediump vec3 Color; 仅如下变量可以声明为 invariant: 顶点着色器中内建的特定输出变量 顶点着色器中输出varying变量 片元着色器中特定的输入变量 片元着色器中的输入varying变量 片元着色器中内建的输出变量 invariant 后面还可以跟一个用逗号隔开的之前声明的标识符列表。 为了确保两个着色器中特定的输出变量不发生变异，还应遵循以下规则: 顶点和片元着色器中的输出变量都声明为invariant 相同的值必须输入到赋给输出变量的表达式或控制流的所有着色器输入变量. 输出变量上的任何纹理函数调用在使用纹理格式,纹理像素值和纹理过滤时都需要设置成相同的方式. 所有的输入变量都以相同的方式操作. 初始时，默认的所有输出变量被允许变异。如果想强制所有输出变量都不可变，那么在着色器所有的变量声明之前使用 1#pragma STDGL invariant(all) 6.2 着色器中的不变体当一个值被存到一个变量中，我们通常假设它是一个常量，除非显示的去更改它的值。然而，在优化处理期间，编译期可能会重新计算一个值而不是将它存到寄存器中。因为操作的精度没有被完全指定（如：低精度的操作会被转成中等精度或高精度），重新计算的值有可能就和原来的值不一致。 在着色器中变体是允许的。如果要避免变体，可以使用 invariant 修饰符或 invariant pragma。 123456789101112precision mediump;vec4 col;vec2 a = ...;........col = texture2D(tex, a); // 此时 a 的值假设为 a1..............col = texture2D(tex, a); // 此时 a 的值假设为 a2，但是有可能 a1 不等于 a2 如果强制成常量，可以使用： 1#pragma STDGL invariant(all) 例子二: 1234vec2 m = ...;vec2 n = ...;vec2 a = m + n;vec2 b = m + n; // 没法保证 a 和 b 完全相等 6.3 常量表达式的不变体常量表达式必须要保证是不变体。一个特定的表达式在相同的还是不同的着色器中都必须有相同的结果。这包括同一个表达式出现在同一个顶点和片元着色器中，或出现在不同的顶点和片元着色器中。 如果满足以下条件，常量表达式必须得出相同的值： 表达式的输入值相同 执行的操作相同并且顺序也相同 所有操作均以相同的精度执行 6.4 不变体和链接装置在顶点和片元着色器中声明的不变体 varying 变量必须要匹配。对于内建的特定变量，当且仅当gl_Position 被声明为 invariant 时，gl_FragCoord 才可以被声明为 invariant。同样的，当且仅当 gl_PositionSize 被声明为 invariant 时，gl_PointCoord 才可以被声明为 invariant。将 gl_FrontFacing声明为invariant是错误的。gl_FrontFacing的不变体和gl_Position的不变体是一样的。 七、修饰顺序当需要使用多个修饰时,它们必须遵循严格的顺序: invariant-qualifier storage-qualifier precision-qualifier storage-qualifier parameter-qualifier precision-qualifier","tags":[]},{"title":"iOS点击事件和手势","date":"2019-10-18T10:22:46.083Z","path":"2019/10/18/iOS/iOS原理/iOS 点击事件和手势/","text":"一、场景再现工程 IM 界面使用 UITableView 作为展示视图，不同的 cell 展示不同的业务类型数据，有的 cell 可以点击跳转，有的则是纯文本。 图中蓝色是 cell，红色是 UIControl 点击区域。 为了实现点击界面空白区域收起键盘等操作，给 controller.view 添加 UITapGestureRecognizer 手势，响应后处理底部的视图位置。 问题出在添加手势之后，UIControl 的点击事件失效了，tableView 的 didSelectRowAtIndexPath 也没有反应。 二、iOS 中的事件分发苹果文档： 上图解释了 UIResponder 事件处理链的关系，而其事件分发过程，可以参看官方文档中的 “Determining Which Responder Contained a Touch Event” 部分。 简单的说，当点击事件发生时，系统从顶层 View 开始（通常是应用的顶层 UIWindow），通过判断点击坐标是否落在视图的 frame 之中来决定是否将该点击事件交由该视图处理，而这个过程将会从顶层视图递归向下找到最内部的子视图，这个过程/方法也就是 hitTest 的过程。找到最底层视图之后，则会尝试让其处理这个事件（UIControl 的各种事件、UIGestureRecognizer 等），若其无法处理，则沿着图中的响应链一步步再向上寻找。 从上可知，只要子视图有处理事件的能力，那么自然会覆盖掉父视图的处理逻辑。 但如果真是这样，怎么会有子视图点击事件不响应的问题呢? 三、手势识别stack overflow 上的一篇回答，看到之后我其实是崩溃的，意思是我想写个通用的基于UITableView的组件，还得在每个有UIGestureRecognizer的视图中加入delegate来规避手势冲突😨。 尽管千百个不愿意，但正是这个在ParentView上的tap手势，导致了我的tableView手势识别的异常，所以只好通过实现 func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -&gt; Bool来解决这个冲突。 随后，我又在官方文档中找到了如下内容：(文档直接贴上来有点长，大致意义如下) 苹果官方又把文档给删了 在 UIGestureRecognizer 的文档中，有这么一段话： A window delivers touch events to a gesture recognizer before it delivers them to the hit-tested view attached to the gesture recognizer.(Blah..Blah..Blah..) If a gesture recognizer recognizes its gesture, the remaining touches for the view are cancelled. 也就是说： 默认情况下，识别一个触摸事件的时候，手势识别将优先于UIResponder响应链式机制，而具体体现为：1.手势识别开始、变化的过程，gestureRecognizer与touchesBegan,touchesMoved同时处理响应事件。 2.但是，只有在gestureRecognizer判定失败的时候(譬如一个tapGestureRegcognizer遇到了一个swipe手势)，系统才会触发UIResponder响应链中的touchesEnded，否则，会触发touchesCancelled。 也就是说，一个手势是否能完整地从UIResponder响应链中传递完成，主要取决于gestrueRecognizer是否”愿意”这么做。 也就是说，手势识别器拥有更高的优先级，只有自己玩剩下的才传给UIResponder响应链处理，当然，也可以通过设置cancelsTouchesInView来强制使触摸流程执行响应链流程，但这仍改变不了手势识别器拥有更高优先级的事实。 接下来验证一下通过文档总结出的结论，看看这个Demo: 其中青蓝色的背景是ParentView，我为它添加了一个UITapGestureRecognizer，而TableView是它的子视图，我重写了touchesBegan/touchesMoved等共四个相应的触摸响应函数用来做控制台输出。 接下来我对着TableView进行如下三个操作： 1.单击，就如同我打算正常的选中某一行一样，对应控制台输出： EventHandlingTest[5386:361029] Background Tap2.短按，即按住一小会儿后松开： EventHandlingTest[5386:361029] touches beganEventHandlingTest[5386:361029] Background TapEventHandlingTest[5386:361029] touches cancelled3.长按再松开： EventHandlingTest[5386:361029] touches beganEventHandlingTest[5386:361029] touches endedUIControl的魔力经过上面的“研究”，我们已经明白，UIGestureRecognizer并不按套路出牌，View的父子关系不影响其事件处理，但为什么我的UIButton就可以正常工作呢？ 以上表述仅适用于子视图没有相同的手势识别器的情况，若ParentView和Subview同时有一个相同的UIGestureRecognizer子类，则Subview响应事件会覆盖ParentView 我又在官方文档找到了如下内容： When a control-specific event occurs, the control calls any associated action methods right away. Action methods are dispatched through the current UIApplication object, which finds an appropriate object to handle the message, following the responder chain if needed. 也就是说，一个UIControl子类(UIButton/UISwitch)方法，其响应事件的方式不同于普通的UIView，它们的事件处理由UIApplication单例直接控制！尽管文档中提到其事件处理部分仍可能使用UIResponder响应链逻辑，但其事件分发与普通的UIView完全不同。 我们再看一个Demo: 和前面的Demo类似，不过此处加入了一个橙色的UIButton,此处TableView和Button是同层级的，均为青蓝色ParentView的子视图，同样，我重写了Button的touchesBegan等一系列方法。 与前一个TableView Demo不同，我单击Button后，便立刻来到了touchesBegan中(而不是短按)，此时，对比一下进入touchesBegan的时候的Button和TableView的调用栈： Button: TableView: 可以清楚地看到，Button的事件直接就由UIApplication传递过来了，而TableView走的是正常的响应链，经过了数次的消息转发。注意TableView调用栈红框底部外的第一条调用:_UIGestureEnvironmentSortAndSendDelayedTouches ()，从命名上我们可以看出，TableView的点击事件是被延迟发送的。 理清头绪经过上面的探索，我们了解到，对于一个普通的UIView来说，想处理一个触摸事件还真是难呀！接下来，我对着Demo又进行了一番折腾，不负责任的有了以下的总结： 1.当触摸事件开始后，系统会先尝试分发事件，对整个 Window递归调用 hitTest 2.系统判别返回的 UIView是不是 UIControl的子类，如果是的话，直接将整个触摸事件交付 UIControl实例完成 3.如果返回的是普通 UIView,且此时有相应的 UIGestureRecognizer，将事件交由该 recognizer处理，并同步走 touchesBegan以及 touchesMovde流程，最终由相应的 recognizer决定调用 touchesEnded还是 touchesCancelled 4.尽管在 UIGestureRecognizer中有 .delaysTouchesBegan这一变量，且默认设置为 false，但在我的Demo中( UITableView与 Tap的冲突)，点击事件必须是轻按才会触发 UITableView的 touchesBegan，而点击并不会触发，并且 touchesBegan和 hitTest调用的间隔明显较长，而Demo中的 UIButton则可以在点击后立刻进入 touchesBegan，且其调用与 hitTest时间间隔明显短一些，结合前文TableView的调用栈，感觉这与文档中所提到的 touchesBegan/ touchesMoved与 gestureRecognizer状态更新同步略有出入 解决链接：didSelectRowAtIndexPath失效 以上两个场景问题。都已经有解决方案了。但是，底层到底是为什么会有点击事件的响应冲突呢？ 这一切的原因都是因为：对于UITapGestureRecognizer认识不够深刻。 先写下几个结论，后面慢慢解释：（此处只讨论单击tap事件） 1、手势响应是大哥，点击事件响应链是小弟。单击手势优先于UIView的事件响应。大部分冲突，都是因为优先级没有搞清楚。 2、单击事件优先传递给手势响应大哥，如果大哥识别成功，就会直接取消事件的响应链传递。 识别成功时候，手势响应大哥拥有垄断权力。（在斗地主里面叫做：吃肉淘汤。） 如果大哥识别失败了，触摸事件会继续走传递链，传递给响应链小弟处理。 3、手势识别是需要时间的。 手势识别有一个状态机的变化。在possible状态的时候，单击事件也可能已经传递给响应链小弟了。 2、关于事件的几个概念在具体讲解上面三个结论之前。先简要的介绍一下 iOS 里面与事件相关的几个概念 。为了方便理解，我用了比喻的方法。 1、 UITouch —— 一指禅当你用一根手指触摸屏幕时, 会创建一个与之关联的UITouch对象, 一个手指第一次点击屏幕，就会生成一个UITouch对象，到手指离开时销毁。 一个UITouch对象对应一根手指. 。所以可以直接，想象成是神功——一指禅。 2、UIEvent —— 如来神掌 （多个手指）一个UIEvent 事件定义为:第一个手指开始触摸屏幕到最后一个手指离开屏幕。 一个UIEvent对象实际上对应多个UITouch对象。所以，一个UIEvent事件，可以简单的想象成是神功：如来神掌。（只是形象表示多个手指而已，不必要5个UITouch事件组合。） 3、 UIResponder — 响应对象在iOS中不是任何对象都能处理事件, 只有继承了UIResponder的对象才能接收并处理事件,我们称为响应者对象。 UIApplication,UIViewController,UIView都继承自UIResponder,因此他们都是响应者对象, 都能够接收并处理事件。 也就是说iOS中 所有的UIView一旦成为响应者对象，都是可以响应单击的触摸事件的。 本文不详细介绍响应链传递及响应的知识了。 重点放在——单击事件，手势识别和响应链之间的纠缠。 4、手势识别 UIGestureRecognizer手势是Apple提供的更高级的事件处理技术，可以完成更多更复杂的触摸事件，比如旋转、滑动、长按等。基类是UIGestureRecognizer。 UIGestureRecognizer同UIResponder一样也有四个方法 //UIGestureRecognizer (void)touchesBegan:(NSSet )touches withEvent: (nullable UIEvent )event; (void)touchesMoved:(NSSet )touches withEvent:(nullable UIEvent )event; (void)touchesEnded:(NSSet )touches withEvent:(nullable UIEvent )event; (void)touchesCancelled:(NSSet )touches withEvent:(nullable UIEvent )event;需要注意的是UIGestureRecognizer，是有状态的变化的。同一个手势是有具有多个状态的变化的，会形成一个有限状态机。 如下图： 手势状态机.png左侧是非连续手势(比如单击)的状态机，右侧是连续手势(比如滑动)的状态机。 所有的手势的开始状态都是UIGestureRecognizerStatePossible。 非连续的手势要么识别成功(UIGestureRecognizerStateRecognized)，要么识别失败(UIGestureRecognizerStateFailed)。 连续的手势识别到第一个手势时，变成UIGestureRecognizerStateBegan，然后变成UIGestureRecognizerStateChanged，并且不断地在这个状态下循环，当用户最后一个手指离开view时，变成UIGestureRecognizerStateEnded， 当然如果手势不再符合它的模式的时候，状态也可能变成UIGestureRecognizerStateCancelled。 3、手势识别与事件响应混用重点来了。 iOS处理触屏事件，分为两种方式： 高级事件处理：利用UIKit提供的各种用户控件或者手势识别器来处理事件。 低级事件处理：在UIView的子类中重写触屏回调方法，直接处理触屏事件。 这两种方式会在，单击触摸事件的时候得到使用。 触摸事件可以通过响应链来传递与处理，也可以被绑定在view上的手势识别和处理。那么这两个一起用会出现什么问题？ 如果回答了这个问题，就可以说清楚，开篇的两个问题了。 此处的DEMO例子参考。iOS点击事件和手势冲突 下面开始例子的讲解。Demo链接：testTap图片： demo.png图中baseView 有两个subView，分别是testView和testBtn。我们在baseView和testView都重载touchsBegan:withEvent、touchsEnded:withEvent、touchsMoved:withEvent、touchsCancelled:withEvent方法，并且在baseView上添加单击手势，action名为tapAction，给testBtn绑定action名为testBtnClicked。主要代码如下： //baseView (void)viewDidLoad { [super viewDidLoad]; UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapAction)]; [self.view addGestureRecognizer:tap]; … [_testBtn addTarget:self action:@selector(testBtnClicked) forControlEvents:UIControlEventTouchUpInside];｝ (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; base view touchs Began”);} (void)touchesMoved:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; base view touchs Moved”);} (void)touchesEnded:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; base view touchs Ended”);} (void)touchesCancelled:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; base view touchs Cancelled”);} (void)tapAction { NSLog(@”=========&gt; single Tapped”);} (void)testBtnClicked { NSLog(@”=========&gt; click testbtn”);}//test view (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; test view touchs Began”);} (void)touchesMoved:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; test view touchs Moved”);} (void)touchesEnded:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; test view touchs Ended”);} (void)touchesCancelled:(NSSet )touches withEvent:(UIEvent )event { NSLog(@”=========&gt; test view touchs Cancelled”);}情景A ：单击baseView，输出结果为： =========&gt; base view touchs Began=========&gt; single Tapped=========&gt; base view touchs Cancelled情景B ：单击testView，输出结果为： =========&gt; test view touchs Began=========&gt; single Tapped=========&gt; test view touchs Cancelled情景C ：单击testBtn, 输出结果为： =========&gt; click testbtn情景D ：按住testView，过5秒后或更久释放，输出结果为： =========&gt; test view touchs Began=========&gt; test view touchs Ended1、情景A和B情景A和B，都是在单击之后，既响应了手势的tap 事件，也让响应链方法执行了。为什么两个响应都执行了呢？ 看看开发文档，就应该可以理解了。 Gesture Recognizers Get the First Opportunity to Recognize a Touch. A window delays the delivery of touch objects to the view so that the gesture recognizer can analyze the touch first. During the delay, if the gesture recognizer recognizes a touch gesture, then the window never delivers the touch object to the view, and also cancels any touch objects it previously sent to the view that were part of that recognized sequence. Google翻译： 手势识别器获得识别触摸的第一个机会。 一个窗口延迟将触摸对象传递到视图，使得手势识别器可以首先分析触摸。 在延迟期间，如果手势识别器识别出触摸手势，则窗口不会将触摸对象传递到视图，并且还将先前发送到作为识别的序列的一部分的视图的任何触摸对象取消。 图片： 手势图片.png触摸事件首先传递到手势上，如果手势识别成功，就会取消事件的继续传递，否则，事件还是会被响应链处理。具体地，系统维持了与响应链关联的所有手势，事件首先发给这些手势，然后再发给响应链。 这样可以解释情景A和B了。 首先，我们的单击事件，是有有手势识别这个大哥来优先获取。只不过，手势识别是需要一点时间的。在手势还是Possible 状态的时候，事件传递给了响应链的第一个响应对象（baseView 或者 testView）。 这样自然就去调用了，响应链UIResponder的touchsBegan:withEvent方法，之后手势识别成功了，就会去cancel之前传递到的所有响应对象，于是就会调用它们的touchsCancelled:withEvent:方法。 2、情境C好了，情景A和B都可以解释明白了。但是，请注意，按这样的解释为什么情景C没有触发响应链的方法呢？ 这里可以说是事件响应的一个特例。 iOS 开发文档里这样说： In iOS 6.0 and later, default control actions prevent overlapping gesture recognizer behavior. For example, the default action for a button is a single tap. If you have a single tap gesture recognizer attached to a button’s parent view, and the user taps the button, then the button’s action method receives the touch event instead of the gesture recognizer. This applies only to gesture recognition that overlaps the default action for a control, which includes: A single finger single tap on a UIButton, UISwitch, UISegmentedControl, UIStepper,and UIPageControl.A single finger swipe on the knob of a UISlider, in a direction parallel to the slider.A single finger pan gesture on the knob of a UISwitch, in a direction parallel to the switch. Google 翻译为： 在iOS 6.0及更高版本中，默认控制操作可防止重叠的手势识别器行为。 例如，按钮的默认操作是单击。 如果您有一个单击手势识别器附加到按钮的父视图，并且用户点击按钮，则按钮的动作方法接收触摸事件而不是手势识别器。 这仅适用于与控件的默认操作重叠的手势识别，其中包括： 单个手指单击UIButton，UISwitch，UISegmentedControl，UIStepper和UIPageControl. 单个手指在UISlider的旋钮上滑动，在平行于滑块的方向上。在UISwitch的旋钮上的单个手指平移手势 与开关平行的方向。 所以呢，在情境C，里面testBtn的 默认action，获取了事件响应，不会把事件传递给父视图baseView，自然就不会触发，baseView的tap 事件了。 3、情境D在情景D中，由于长按住testView不释放，tap手势就会识别失败，因为长按就已经不是单击事件了。手势识别失败之后，就可以继续正常传递给testView处理。 所以，只有响应链的方法触发了。 4、实际开发遇到的问题解决基本的开发目标，不让父视图的手势识别干扰子视图UIView的点击事件响应或者说响应链的正常传递。 一般都会是重写UIGestureRecognizerDelegate中的- (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch方法。 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch{ // 若为UITableViewCellContentView（即点击了tableViewCell）， if ([NSStringFromClass([touch.view class]) isEqualToString:@”UITableViewCellContentView”]) { // cell 不需要响应 父视图的手势，保证didselect 可以正常return NO; } //默认都需要响应 return YES;}1、iOS开发中让子视图不响应父视图的手势识别器 2、iOS单击响应，UIControl 3、didSelectRowAtIndexPath失效 4、以上例子的Demo链接：testTap; 小结复习一下结论： （此处只讨论单击tap事件） 1、手势响应是大哥，点击事件响应链是小弟。单击手势优先于UIView的事件响应。大部分冲突，都是因为优先级没有搞清楚。 2、单击事件优先传递给手势响应大哥，如果大哥识别成功，就会直接取消事件的响应链传递。 识别成功时候，手势响应大哥拥有垄断权力。（在斗地主里面叫做：吃肉淘汤。） 如果大哥识别失败了，触摸事件会继续走传递链，传递给响应链小弟处理。 3、手势识别是需要时间的。手势识别有一个状态机的变化。在possible状态的时候，单击事件也可能已经传递给响应链小弟了。 待处理https://www.jianshu.com/p/68889f14be4bhttps://www.jianshu.com/p/33a28bb14749https://help.apple.com/xcode/mac/current/#/dev7ccaf4d3chttps://blog.gocy.tech/2016/11/19/iOS-touch-handling/https://www.jianshu.com/p/53e03e558cbdhttps://blog.csdn.net/u012218309/article/details/81669227","tags":[]},{"title":"","date":"2019-10-14T01:28:18.820Z","path":"2019/10/14/OpenGL/OpenGLES/","text":"一、核心模式与立即渲染模式早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。 随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。 二、状态机OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改 OpenGL 状态：设置选项、操作缓冲。最后，我们使用当前OpenGL上下文来渲染。 三、对象在 OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。 顶点数组对象：Vertex Array Object（VAO) 顶点缓冲对象：Vertex Buffer Object（VBO） 索引缓冲对象：Element Buffer Object（EBO）或 Index Buffer Object（IBO） 四、图形渲染管线在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。 图形渲染管线可以被划分为两个主要部分：第一部分把你的 3D 坐标转换为 2D 坐标；第二部分是把 2D 坐标转变为实际的有颜色的像素。 2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。 图形渲染管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。 顶点着色器(Vertex Shader) 它把一个单独的顶点作为输入。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。 图元装配(Primitive Assembly) 该阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并将所有的点装配成指定图元的形状。 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给 OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 几何着色器(Geometry Shader) 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。 光栅化阶段(Rasterization Stage) 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。 片段着色器 OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 片段插值(Fragment Interpolation)：片段着色器基于光栅化阶段的位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是 30%蓝 + 70%绿。 Alpha测试和混合(Blending)阶段 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。 在现代 OpenGL 中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。 五、着色器图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。 它们运行在GPU上，可以给我们节约宝贵的CPU时间。 顶点着色器 顶点着色器会在 GPU 上创建内存用于储存我们的顶点数据，还要配置 OpenGL 如何解释这些内存，并且指定其如何发送给显卡，我们通过顶点缓冲对象（VBO）管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上。 预定义的 gl_Position 变量设置的值，会成为该顶点着色器的输出。 片段着色器 片段着色器所做的是计算像素最后的颜色输出。 片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用out关键字声明输出变量，这里我们命名为 FragColor（OpenGLES 中有预定义的 gl_FragColor 变量） 六着色器程序 着色器程序对象（Shader Program Object）是多个着色器合并之后并最终链接完成的版本。 如果要使用刚才编译的着色器我们必须把它们链接（Link）为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。 七、数据以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)。 一个顶点(Vertex)是一个 3D 坐标的数据的集合，顶点数据是一系列顶点的集合。 顶点属性(Vertex Attribute) 顶点数据是用顶点属性（Vertex Attribute）表示的，它可以包含任何我们想用的数据。 每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用 glVertexAttribPointer 时绑定到 GL_ARRAY_BUFFER 的 VBO 决定的。由于在调用 glVertexAttribPointer 之前绑定的是先前定义的 VBO 对象，顶点属性 0 现在会链接到它的顶点数据。 我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有 16 个包含 4 分量的顶点属性可用， 顶点缓冲数据(VBO) 顶点缓冲数据(VBO)会被解析为下面这样子： 位置数据被储存为 32 位（4字节）浮点值。 每个位置包含 3 个这样的值。 在这 3 个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。 数据中第一个值在缓冲开始的位置。 顶点数组对象 顶点数组对象(VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO 中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray 和 glDisableVertexAttribArray 的调用。 通过 glVertexAttribPointer 设置的顶点属性配置。 通过 glVertexAttribPointer 调用与顶点属性关联的顶点缓冲对象。 当你打算绘制多个物体时，你首先要生成/配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO。 索引缓存对象 为了解决存储重复的顶点信息，索引缓冲对象能够达到只储存不同的顶点，并设定绘制这些顶点的顺序。 注意：索引从 0 开始! 1234unsigned int indices[] = &#123; // 注意索引从0开始! 0, 1, 3, // 第一个三角形1, 2, 3 // 第二个三角形&#125;; 用 `glDrawElements` 来替换 `glDrawArrays` 函数，来指明我们从索引缓冲渲染。 八、标准化设备坐标(Normalized Device Coordinates, NDC)一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 -1.0 ~ 1.0 的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)： 与通常的屏幕坐标不同，y 轴正方向为向上，(0, 0) 坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。 你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。 向量(Vector) 在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 vec.x、vec.y、vec.z 和 vec.w 来获取。 注意 vec.w 分量不是用作表达空间中的位置的（我们处理的是 3D 不是 4D），而是用在所谓透视除法（Perspective Division）上。 九、纹理纹理（Texture）是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节。 为了能够把纹理映射（Map）到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标（Texture Coordinate），用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值（Fragment Interpolation）。 纹理坐标在 x 和 y 轴上，范围为 0 ~ 1 之间（注意我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于 (0, 0)，也就是纹理图片的左下角，终于 (1, 1)，即纹理图片的右上角。 给顶点着色器传递三个纹理坐标，然后片段着色器会为每个片段进行纹理坐标的插值。 9.1 纹理环绕方式 环绕方式 描述 GL_REPEAT 对纹理的默认行为。重复纹理图像。 GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的。 GL_CLAMP_TO_EDGE 纹理坐标会被约束在 0 到 1 之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 9.2 纹理过滤纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以 OpenGL 需要知道怎样将纹理像素（Texture Pixel，也叫 Texel）映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。 纹理过滤(Texture Filtering)的选项：GL_NEAREST 和 GL_LINEAR。 Texture Pixel 也叫 Texel，你可以想象你打开一张 .jpg 格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL 以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是 OpenGL 默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）： 9.3 多级渐远纹理假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL 从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL 使用一种叫做多级渐远纹理（Mipmap）的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单： 距观察者的距离超过一定的阈值，OpenGL 会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。 让我们看一下多级渐远纹理是什么样子的： 9.4 纹理单元 一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是 0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。 我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。 12glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元glBindTexture(GL_TEXTURE_2D, texture); 激活纹理单元之后，接下来的 glBindTexture 函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元 GL_TEXTURE0默认总是被激活。 OpenGL 至少保证有 16 个纹理单元供你使用，也就是说你可以激活从 GL_TEXTURE0 到 GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过 GL_TEXTURE0 + 8 的方式获得 GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。 十、坐标系统 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。 接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换（Viewport Transform）的过程。视口变换将位于 -1.0 到 1.0 范围的坐标变换到由 glViewport 函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。 10.1 局部空间局部空间是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。 我们一直使用的那个箱子的顶点是被设定在 -0.5 到 0.5 的坐标范围中，(0, 0) 是它的原点。这些都是局部坐标。 10.2 世界空间如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点 (0, 0, 0) 上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 10.3 观察空间观察空间经常被人们称之 OpenGL 的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。 10.4 裁剪空间在一个顶点着色器运行的最后，OpenGL 期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间 (Clip Space)名字的由来。 因为将所有可见的坐标都指定在 -1.0 到 1.0 的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像 OpenGL 期望的那样。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的 -1000 到 1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围 (-1.0, 1.0)。所有在范围外的坐标不会被映射到在 -1.0 到 1.0 的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于 1.0 的标准化设备坐标，所以被裁剪掉了。 由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到 2D 观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将 3D 坐标投影(Project)到很容易映射到 2D 的标准化设备坐标系中。 一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的 x，y，z 分量分别除以向量的齐次 w 分量；透视除法是将 4D 裁剪空间坐标变换为 3D 标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。 在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。 将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。 正射投影 正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器： 上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的 w 分量都没有进行改变；如果 w 分量等于 1.0，透视除法则不会改变这个坐标。 透视投影 离你越远的东西看起来更小。 这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的 w 值，从而使得离观察者越远的顶点坐标 w 分量越大。被变换到裁剪空间的坐标都会在 -w 到 w 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL 要求所有可见的坐标都落在 -1.0 到 1.0 范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上： 顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是 w 分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。 10.5 Z 缓冲OpenGL 存储它的所有深度信息于一个 Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW 会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的 z 值），当片段想要输出它的颜色时，OpenGL 会将它的深度值和 z 缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由 OpenGL 自动完成的。 然而，如果我们想要确定 OpenGL 真的执行了深度测试，首先我们要告诉 OpenGL 我们想要启用深度测试；它默认是关闭的。我们可以通过 glEnable 函数来开启深度测试。glEnable 和 glDisable 函数允许我们启用或禁用某个 OpenGL 功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启 GL_DEPTH_TEST： 1glEnable(GL_DEPTH_TEST); 因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在 glClear 函数中指定 DEPTH_BUFFER_BIT 位来清除深度缓冲： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 十一、代码12unsigned int VBO;glGenBuffers(1, &amp;VBO); 使用glGenBuffers函数和一个缓冲ID生成一个VBO对象。 1glBindBuffer(GL_ARRAY_BUFFER, VBO); 把新创建的缓冲绑定到GL_ARRAY_BUFFER目标。 1234567891011/** * @param 参数1：目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。 * @param 参数2：指定传输数据的大小(以字节为单位)；用一个简单的 sizeof 计算出顶点数据大小就行。 * @param 参数3：希望发送的实际数据。 * @param 参数4：指定了我们希望显卡如何管理给定的数据 GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 */glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 把之前定义的顶点数据复制到缓冲的内存。 12unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER); 创建着色器 12345678/** * @param 参数1：要编译的着色器对象。 * @param 参数2：指定了传递的源码字符串数量 * @param 参数3：顶点着色器真正的源码 * @param 参数4：先设置为 NULL。 */glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader); 把着色器源码附加到着色器对象上，然后编译它 12unsigned int shaderProgram;shaderProgram = glCreateProgram(); 创建一个着色器程序对象 123glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 将编译的着色器附加到程序对象上，然后用 glLinkProgram 链接它们 12345678910/** * @param 参数1：指定我们要配置的顶点属性。还记得在顶点着色器中使用 layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为 0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。 * @param 参数2：指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。 * @param 参数3：指定数据的类型，这里是 GL_FLOAT（GLSL中 vec* 都是由浮点数值组成的）。 * @param 参数4：定义我们是否希望数据被标准化(Normalize)。如果我们设置为 GL_TRUE，所有数据都会被映射到0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为 GL_FALSE。 * @param 参数5：步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float 之后，我们把步长设置为 3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。 * @param 参数6：类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是 0。 */glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 设置顶点属性指针 12unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 创建顶点数组对象 1glBindVertexArray(VAO); 绑定 VAO 12345678910111213unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);/** * @param 参数1：指定了我们绘制的模式，这个和glDrawArrays的一样 * @param 参数2：打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点 * @param 参数3：索引的类型，这里是 GL_UNSIGNED_INT * @param 参数4：指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候，但是我们会在这里填写 0） */glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 123int nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);NSLog(@\"能声明的顶点属性个数：%d\", nrAttributes); 获取能声明的顶点属性个数 十二、摄像机/观察空间当我们讨论摄像机/观察空间（Camera/View Space）的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。 要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右测的向量以及一个指向它上方的向量。我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。 摄像机位置 获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。 1GLKVector3 cameraPosition = GLKVector3Make(0.0, 0.0, 3.0); 不要忘记正 z 轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着 z 轴的正方向移动。 摄像机方向 下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向 z 轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的 z 轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正 z 轴方向的向量： 12GLKVector3 cameraTarget = GLKVector3Make(0.0, 0.0, 0.0);GLKVector3 cameraDirection = GLKVector3Normalize(GLKVector3Subtract(cameraPosition, cameraTarget)); 方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向。 右轴 我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的 x 轴的正方向。为获取右向量我们需要先使用一个小技巧： 先定义一个上向量(Up Vector)。 接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向 x 轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向 x 轴负方向的向量）： 123GLKVector3 up = GLKVector3Make(0.0, 1.0, 0.0);// 右向量，它代表摄像机空间的 x 轴的正方向。把上向量和第二步得到的方向向量进行叉乘GLKVector3 cameraRight = GLKVector3Normalize(GLKVector3CrossProduct(up, cameraDirection)); 上轴 现在我们已经有了 x 轴向量和 z 轴向量，获取一个指向摄像机的正 y 轴向量就相对简单了：我们把右向量和方向向量进行叉乘： 1GLKVector3 cameraUp = GLKVector3CrossProduct(cameraDirection, cameraRight); 在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做格拉姆—施密特正交化(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个 LookAt 矩阵了，它在创建摄像机的时候非常有用。 LookAt 把这个 LookAt 矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt 矩阵就像它的名字表达的那样：它会创建一个看着（Look at）给定目标的观察矩阵。 自由移动 1234567891011121314void processInput(GLFWwindow *window)&#123; ... float cameraSpeed = 0.05f; // adjust accordingly if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;&#125; 当我们按下 WASD 键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个右向量(Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的横移(Strafe)效果。 注意，我们对右向量进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据 cameraFront 变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。 移动速度 图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以 deltaTime 值。结果就是，如果我们的 deltaTime 很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。 欧拉角 欧拉角(Euler Angle)是可以表示 3D 空间中任何旋转的 3 个值。 一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义： 俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算 3D 空间中任何的旋转向量了。 鼠标输入 偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。 十三、词汇表 OpenGL：一个定义了函数布局和输出的图形 API 的正式规范。 视口(Viewport)： 我们需要渲染的窗口。 图形管线(Graphics Pipeline)：一个顶点在呈现为像素之前经过的全部过程。 着色器(Shader)：一个运行在显卡上的小型程序。很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能。 标准化设备坐标(Normalized Device Coordinates, NDC)：顶点，通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在 NDC 下 -1.0 到 1.0 的顶点将不会被丢弃并且可见。 顶点缓冲对象(Vertex Buffer Object)： 一个调用显存并存储所有顶点数据供显卡使用的缓冲对象。 顶点数组对象(Vertex Array Object)： 存储缓冲区和顶点属性状态。 索引缓冲对象(Element Buffer Object)： 一个存储索引供索引化绘制使用的缓冲对象。 Uniform： 一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次。 纹理(Texture)： 一种包裹着物体的特殊类型图像，给物体精细的视觉效果。 纹理缠绕(Texture Wrapping)： 定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式。 纹理过滤(Texture Filtering)： 定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生。 多级渐远纹理(Mipmaps)： 被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小。 纹理单元(Texture Units)： 通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染。 向量(Vector)： 一个定义了在空间中方向和/或位置的数学实体。 矩阵(Matrix)： 一个矩形阵列的数学表达式。 GLM： 一个为OpenGL打造的数学库。 局部空间(Local Space)： 一个物体的初始空间。所有的坐标都是相对于物体的原点的。 世界空间(World Space)： 所有的坐标都相对于全局原点。 观察空间(View Space)： 所有的坐标都是从摄像机的视角观察的。 裁剪空间(Clip Space)： 所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪/透视除法）。 屏幕空间(Screen Space)： 所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽/高。 LookAt矩阵： 一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移。 欧拉角(Euler Angles)： 被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通过这三个值构造任何3D方向。","tags":[]},{"title":"iOS 内存分配与分区","date":"2019-10-10T10:44:48.820Z","path":"2019/10/10/iOS/iOS原理/iOS 内存分配与分区/","text":"RAM ROM RAM：运行内存，不能掉电存储。 ROM：存储性内存，可以掉电存储，例如内存卡、Flash。 由于 RAM 类型不具备掉电存储能力（即一掉电数据消失），所以 app 程序一般存放于 ROM 中。RAM 的访问速度要远高于 ROM，价格也要高。 App程序启动 App 程序启动，系统会把开启的那个 App 程序从 Flash 或 ROM 里面拷贝到内存（RAM），然后从内存里面执行代码。 另一个原因是 CPU 不能直接从内存卡里面读取指令（需要 Flash 驱动等等）。 内存分区： 栈区（stack） 存放的局部变量、先进后出、一旦出了作用域就会被销毁； 函数跳转地址，现场保护等； 程序员不需要管理栈区变量的内存； 栈区地址从高到低分配； 堆区（heap） 堆区的内存分配使用的是 alloc； 需要程序员管理内存； ARC 的内存的管理，是编译器再便宜的时候自动添加 retain、release、autorelease； 堆区的地址是从低到高分配 全局区／静态区（static） 包括两个部分：未初始化 、已初始化； 全局区/静态区，在内存中是放在一起的，已初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域； 常量区常量字符串就是放在这里。 代码区存放 App 代码。 如下图所示：代码区存放于低地址，栈区存放于高地址。区与区之间并不是连续的。 注意事项 在 iOS 中，堆区的内存是应用程序共享的，堆中的内存分配是系统负责的； 系统使用一个链表来维护所有已经分配的内存空间（系统仅仅纪录，并不管理具体的内容）； 变量使用结束后，需要释放内存，OC 中是根据引用计数来判断； 当一个 app 启动后，代码区、常量区、全局区大小已固定，因此指向这些区的指针不会产生崩溃性的错误。而堆区和栈区是时时刻刻变化的（堆的创建销毁，栈的弹入弹出），所以当使用一个指针指向这两个区里面的内存时，一定要注意内存是否已经被释放，否则会产生程序崩溃（也即是野指针报错）。 其它操作系统 iOS 是基于 UNIX、Android 是基于 Linux 的，在 Linux 和 unix 系统中，内存管理的方式基本相同； Android 应用程序的内存分配也是如此。除此以外，这些应用层的程序使用的都是虚拟内存，它们都是建立在操作系统之上的，只有开发底层驱动或板级支持包时才会接触到物理内存， 在嵌入式 Linux 中，实际的物理地址只有 64M 甚至更小，但是虚拟内存却可以高达 4G;","tags":[]},{"title":"进程、线程","date":"2019-10-10T09:41:59.512Z","path":"2019/10/10/iOS/iOS多线程/进程、线程/","text":"一、进程 进程就是一个正在运行的一个应用程序; 每一个进度都是独立的，每一个进程均在专门且手保护的内存空间内; 在 linux 系统中，想要新开启一个进程是一件非常简单的事情只需要一句话：fork()，在 fork() 之后就会包含两个进程，此时可以根据返回的 PID 来判断是子进程还是父进程； iOS 是一个非常封闭的系统，每一个 App（一个进程）都有自己独特的内存和磁盘空间，别的 App（进程）是不允许访问的（越狱不在讨论范围）； 二、线程 线程是 CPU 调度的最小单元； 线程的作用：执行 app 的代码； 一个进程（App）至少有一个线程，这个进程叫做主线程； 三、线程和进程的关系 进程为应用程序开辟内存空间； 线程执行应用程序的代码； 进程是由线程组成的，一个进程至少有一个主线程，理论上可以有很多个线程。 四、为什么要使用多线程 方便的通信和数据交换 多进程程序结构和多线程程序结构有很大的不同; 对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。 更高效的利用 CPU 大多数操作系统是根据时间片轮转调度，在 Linux/Unix 中，CPU 的调度时间是 100ms；而线程是 CPU 最小的调度单元，也就是说当开启一个新线程时，CPU 在自己的调度链表中去循环调度这个线程；如果一个线程没有，那么 CPU 就会休息；所以说，多线程能够适当提高 CPU 的利用率！当然 CPU 调用时并非这么简单，其中会包含调度的优先级、中断等来保证 CPU 调度是优化的！ 所以，在讨论为什么要使用多线程时，如果不说针对多进程而言是那就是没有了参考对象。 当然，程序中并非开启越多的线程越好，首先线程需要消耗内存，主线程 1M、子线程是 512K； 其次，线程越多，CPU 的线程链表就越长，执行效率会变慢！适当的利用多线程！在 iOS 中，苹果公司也为我们封装一个类 NSOperation。","tags":[]},{"title":"linux 中的页缓存和文件 IO","date":"2019-10-10T09:19:34.422Z","path":"2019/10/10/IT/linux 中的页缓存和文件 IO/","text":"本文所述是针对 linux 引入了虚拟内存管理机制以后所涉及的知识点。linux 中页缓存的本质就是对于磁盘中的部分数据在内存中保留一定的副本，使得应用程序能够快速的读取到磁盘中相应的数据，并实现不同进程之间的数据共享。 因此，linux 中页缓存的引入主要是为了解决两类重要的问题： 磁盘读写速度较慢（ms 级别); 实现不同进程之间或者同一进程的前后不同部分之间对于数据的共享； 如果没有进程之间的共享机制，那么对于系统中所启动的所有进程，在打开文件的时候都要将需要的数据从磁盘加载进物理内存空间，这样不仅导致加载速度变慢，而且造成了物理内存的浪费。为了解决以上问题，linux 操作系统使用了缓存机制。 在虚拟内存机制出现以前，操作系统使用块缓存机制，但是在虚拟内存出现以后，操作系统管理 IO 的粒度更大，因此采用了页缓存机制。此后，和后备存储的数据交互普遍以页为单位。 页缓存是基于页的、面向文件的一种缓存机制。 以上只是对页缓存的重要性做了介绍。但是，还有三个问题还没有解释： 页缓存究竟是如何实现，其和文件系统是如何关联的？ 页缓存、内存以及文件 IO 之间的关系是怎样的？ 页缓存中的数据如何实现和后备存储之间的同步？ 一、页缓存的实现既然页缓存是以页为单位进行数据管理的，那么必须在内核中标识该物理页。其实每个真正存放数据的物理页帧都对应一个管理结构体，称之为 struct page，其结构体如下。 12345678910struct page &#123; unsigned long flags; atomic_t _count; atomic_t _mapcount; unsigned long private; struct address_space *mapping; pgoff_t index; struct list_head lru; void* virtual;&#125;; |成员|描述||:—:|:—-:||flags|描述 page 当前的状态和其他信息，如当前的 page 是否是脏页 PG_dirty；是否是最新的已经同步到后备存储的页 PG_uptodate; 是否处于 lru 链表上等||_count|引用计数，标识内核中引用该 page 的次数。如果要操作该 page，引用计数会 +1，操作完成之后 -1。当该值为 0 时，表示没有引用该 page 的位置，所以该 page 可以被解除映射，这在内存回收的时候是有用的。||_mapcount|页表被映射的次数。也就是说 page 同时被多少个进程所共享，初始值为 -1，如果只被一个进程的页表映射了，该值为 0。||private|私有数据指针||mapping|它有三种含义：1. 如果 mapping = 0，说明该 page 属于交换缓存（swap cache); 当需要地址空间时会指定交换分区的地址空间 swapper_space;2. 如果 mapping != 0, bit[0] = 0, 说明该 page 属于页缓存或者文件映射，mapping指向文件的地址空间address_space；3. 如果mapping != 0, bit[0] != 0 说明该 page 为匿名映射，mapping 指向 struct anon_vma 对象；|index|在映射的虚拟空间（vma_area)内的偏移；一个文件可能只是映射了一部分，假设映射了 1M 的空间，那么 index 指的是 1M 空间内的偏移，而不是在整个文件内的偏移||lru|当 page 被用户态使用或者是当做页缓存使用的时候，将该 page 连入 zone 中的 lru 链表，供内存回收使用| 注意区分 _count 和 _mapcount。_mapcount 表示的是被映射的次数，而 _count 表示的是被使用的次数；被映射了不一定被使用，但是被使用之前肯定要先被映射。 页缓存就是将一个文件在内存中的所有物理页所组成的一种树形结构，我们称之为基数树，用于管理属于同一个文件在内存中的缓存内容。 如上所述，一个文件在内存中对应的所有物理页组成了一棵基数树。而一个文件在内存中具有唯一的 inode 结构标识，inode 结构中有该文件所属的设备及其标识符，因而，根据一个 inode 能够确定其对应的后备设备。 为了将文件在物理内存中的页缓存和文件及其后备设备关联起来，linux 内核引入了 address_space 结构体。可以说 address_space 结构体是将页缓存和文件系统关联起来的桥梁，其组成如下： 123456789101112131415161718struct address_space &#123; struct inode* host; /*指向与该address_space相关联的inode节点*/ struct radix_tree_root page_tree; /*所有页形成的基数树根节点*/ spinlock_t tree_lock; /*保护page_tree的自旋锁*/ unsigned int i_map_writable; /*VM_SHARED的计数*/ struct prio_tree_root i_map; struct list_head i_map_nonlinear; spinlock_t i_map_lock; /*保护i_map的自旋锁*/ atomic_t truncate_count; /*截断计数*/ unsigned long nrpages; /*页总数*/ pgoff_t writeback_index; /*回写的起始位置*/ struct address_space_operation* a_ops; /*操作表*/ unsigned long flags; /*gfp_mask掩码与错误标识*/ struct backing_dev_info* backing_dev_info; /*预读信息*/ spinlock_t private_lock; /*私有address_space锁*/ struct list_head private_list; /*私有address_space链表*/ struct address_space* assoc_mapping; /*相关的缓冲*/&#125; |成员|描述||:—:|:—:||host|指向与该 address_space 相关联的 inode 节点，inode 节点与 address_space 之间是一一对应关系||struct radix_tree_root|指向的 host 文件在该内存中映射的所有物理页形成的基数树的根节点，参考博客||struct prio_tree_root|与该地址空间相关联的所有进程的虚拟地址区间 vm_area_struct 所对应的整个进程地址空间 mm_struct 形成的优先查找树的根节点；vm_area_struct 中如果有后备存储，则存在 prio_tree_node 结构体，通过该 prio_tree_node 和 prio_tree_root 结构体，构成了所有与该 address_space 相关联的进程的一棵优先查找树，便于查找所有与该 address_space 相关联的进程| 下面列出 struct prio_tree_root 和 struct prio_tree_node的结构体。 123456789101112struct prio_tree_root &#123; struct prio_tree_node* prio_tree_root; unsigned short index_bits;&#125;;struct prio_tree_node &#123; struct prio_tree_node* left; struct prio_tree_node* right; struct prio_tree_node* parent; unsigned long start; unsigned long last;&#125;; 为了便于形成页缓存、文件和进程之间关系的清晰思路，如图。 从上可以看出，address_space 成为构建页缓存和文件、页缓存和共享该文件的所有进程之间的桥梁。 每个进程的地址空间使用 mm_struct 结构体标识，该结构体中包含一系列的由 vm_area_struct 结构体组成的连续地址空间链表。每个 vm_area_struct 中存在 struct file* vm_file 用于指向该连续地址空间中所打开的文件，而 vm_file 通过 struct file 中的 struct path 与 struct dentry 相关联。 struct dentry 中通过 inode 指针指向 inode，inode 与 address_space 一一对应，至此形成了页缓存与文件系统之间的关联。 为了便于查找与某个文件相关联的所有进程，address_space 中的 prio_tree_root 指向了所有与该页缓存相关联的进程所形成的优先查找树的根节点。 这里需要说明的一点是：linux 中的文件系统，内核为每个进程在其地址空间中都维护了结构体 struct* fd_array[] 用于维护该进程地址空间中打开的文件的指针；同时内核为所有被打开的文件还维护了系统级的一个文件描述符表用以记录该系统打开的所有文件，供所有进程之间共享；每个被打开的文件都由一个对应的inode结构体表示，由系统级的文件描述符表指向。所以，进程通过自己地址空间中的打开文件描述符表可以找到系统级的文件描述符表，进而找到文件。 二、页缓存、内存、文件 IO 之间的关系关于文件 IO 我们常说的两句话“普通文件 IO 需要复制两次，内存映射文件 mmap 只需要复制一次”。 下面对普通文件 IO 做详细的解释。文章对页缓存和文件 IO 做了详细的介绍，不过都是英文的。 2.1 读假设系统中现在存在一个名为 render 的进程，该进程打开了文件 scene.dat，并且每次读取其中的 512B(一个扇区的大小)，将读取的文件数据放入到堆分配的块中（每个进程自己的地址空间对应的物理内存）。先以普通 IO 为例介绍一下读取数据的过程，如图（来源于该文章）。 进程发起读请求的过程如下： 进程调用库函数 read() 向内核发起读文件的请求； 内核通过检查进程的文件描述符定位到虚拟文件系统已经打开的文件列表项，调用该文件系统对 VFS 的 read() 调用提供的接口； 通过文件表项链接到目录项模块，根据传入的文件路径在目录项中检索，找到该文件的 inode； inode中，通过文件内容偏移量计算出要读取的页； 通过该 inode 的 i_mapping 指针找到对应的 address_space 页缓存树（基数树），查找对应的页缓存节点； 如果页缓存节点命中，那么直接返回文件内容； 如果页缓存缺失，那么产生一个缺页异常，首先创建一个新的空的物理页框，通过该 inode 找到文件中该页的磁盘地址，读取相应的页填充该页缓存（DMA 的方式将数据读取到页缓存），更新页表项；重新进行第 5 步的查找页缓存的过程； 文件内容读取成功； 也就是说，所有的文件内容的读取（无论一开始是命中页缓存还是没有命中页缓存）最终都是直接来源于页缓存。 当将数据从磁盘复制到页缓存之后，还要将页缓存的数据通过 CPU 复制到 read 调用提供的缓冲区中，这就是普通文件 IO 需要的两次复制数据复制过程。其中第一次是通过 DMA 的方式将数据从磁盘复制到页缓存中，本次过程只需要 CPU 在一开始的时候让出总线、结束之后处理 DMA 中断即可，中间不需要 CPU 的直接干预，CPU 可以去做别的事情；第二次是将数据从页缓存复制到进程自己的的地址空间对应的物理内存中，这个过程中需要 CPU 的全程干预，浪费 CPU 的时间和额外的物理内存空间。 假如读取了 12KB 的数据之后，那么 render 进程的堆地址空间和相关的地址空间如图所示。 看起来该过程很简单，但是这其中存在着很多的知识点 首先，render 使用了常规的 read() 系统调用读取了 12KB 的数据，现在 scene.dat 中三个大小为 4KB 的页也存在于页缓存中，就像先前所说的所有的文件 IO 都是通过页缓存进行的。在 X86 架构的 linux 体系中，内核以 4KB 大小的页为单位组织文件中的数据，所以即使你从一个文件中仅仅读取几个字节的数据，那么包含这些字节的整个页的数据都会从硬盘读入页缓存中。这对于提高硬盘的吞吐量很有帮助，并且用户通常每次读取的数据不仅仅是只有几个字节而已。页缓存记录了每个 4KB 中的页在文件中的位置，如图中的 #0，#1 等。 然而，在一次文件读取的过程中，必须将文件的内容从页缓存拷贝到用户的空间。这个过程和缺页异常（通过 DMA 调入需要的页）不一样，这个拷贝过程需要通过 CPU 进行，因此浪费了 CPU 的时间。另一个弊端就是浪费了物理内存，因为需要为同样的数据在内存中维护两个副本，如上图 render 进程的 heap 所对应的堆中的数据和页缓存中的数据存在重复，并且如果系统中有多个这样的进程的话，那么需要为每个进程维护同样的一份数据副本，严重浪费了 CPU 的时间和物理内存空间。 好在，通过内存映射 IO—mmap，进程不但可以直接操作文件对应的物理内存，减少从内核空间到用户空间的数据复制过程，同时可以和别的进程共享页缓存中的数据，达到节约内存的作用。 当映射一个文件到内存中的时候，内核将虚拟地址直接映射到页缓存中。当映射一个文件的时候，如果文件的内容不在物理内存中，操作系统不会将所映射的文件部分的全部内容直接拷贝到物理内存中，而是在使用虚拟地址访问物理内存的时候通过缺页异常将所需要的数据调入内存中。如果文件本身已经存在于页缓存中，则不再通过磁盘 IO 调入内存。如果采用共享映射的方式，那么数据在内存中的布局如图所示。 2.2 写由于页缓存的架构，当一个进程调用 write 系统调用的时候，对于文件的更新仅仅是被写到了文件的页缓存中，相应的页被标记为 dirty。具体过程如下： 前面 5 步和读文件是一致的，在 address_space 中查询对应页的页缓存是否存在； 如果页缓存命中，直接把文件内容修改写在页缓存的页中。写文件就结束了。这时候文件修改位于页缓存，并没有写回到磁盘文件中去。 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过 inode 找到该文件页的磁盘地址，读取相应的页填充页缓存。此时缓存页命中，进行第 2 步。 普通的 IO 操作需要将写的数据从自己的进程地址空间复制到页缓存中，完成对页缓存的写入；但是 mmap 通过虚拟地址（指针）可以直接完成对页缓存的写入，减少了从用户空间到页缓存的复制。 由于写操作只是写到了页缓存中，因此进程并没有被阻塞到磁盘 IO 发生，因此当计算机崩溃的时候，写操作所引起的改变可能并没有发生在磁盘上。所以，对于一些要求严格的写操作，比如数据库系统，就需要调用 fsync 等操作及时将数据同步到磁盘上（虽然这中间也可能存在磁盘的驱动程序崩溃的情况）。读操作与写不同，一般会阻塞到进程读取到数据（除非调用非阻塞 IO，即使使用 IO 多路复用技术也是将进程阻塞在多个监听描述符上，本质上还是阻塞的）。为了减轻读操作的这种延迟，linux 操作系统的内核使用了“预读”技术，也就是当从磁盘中读取你所需要的数据的时候，内核将会多读取一些页到页缓存中。 普通文件 IO 中所有的文件内容的读取（无论一开始是命中页缓存还是没有命中页缓存）最终都是直接来源于页缓存。当将数据通过缺页中断从磁盘复制到页缓存之后，还要将页缓冲的数据通过 CPU 复制到 read 调用提供的缓冲区中。这样，必须通过两次数据拷贝过程，才能完成用户进程对文件内容的获取任务。写操作也是一样的，待写入的 buffer 在用户空间，必须将其先拷贝到内核空间对应的主存中，再写回到磁盘中，也是需要两次数据拷贝。mmap 的使用减少了数据从用户空间到页缓存的复制过程，提高了 IO 的效率，尤其是对于大文件而言；对于比较小的文件而言，由于 mmap 执行了更多的内核操作，因此其效率可能比普通的文件 IO 更差。 在专门介绍 mmap 的博客中，我们说文件映射分为私有映射（private）和共享映射（shared）两种，二者之间的区别就是一个进程对文件所做的改变能否被其他的进程所看到，且能否同步到后备的存储介质中。那么，如果一个进程仅仅是读取文件中的内容的话，那么共享映射和私有映射对应的物理内存布局如图5所示。但是，如果采用私有映射的方式，且一个进程对文件内容作出了改变，那么会发生怎样的情况呢？内核采用了写时复制技术完成私有映射下对文件内容的改动，下面举例说明。 假设系统中存在两个进程分别为 render 和 render3d，它们都私有映射同一个文件 scene.dat 到内存中，然后 render 进程对映射的文件做出了写操作，如图所示。 图上的“只读”标志不是说映射的内容是只读的，这仅仅是内核为了节省物理内存而采用的对于物理内存的一种“欺骗手段”而已。如果两个进程只是读取文件中的内容，不做任何的改动，那么文件只在物理内存中保留一份；但是如果有一个进程，如 render，要对文件中的内容做出改动，那么会触发缺页中断，内核采用写时复制技术，为要改动的内容对应的页重新分配一个物理页框，将并将被改动的内容对应的物理页框中的数据复制到新分配的物理页框中，再进行改动。此时新分配的物理页框对于 render 而言是它自己“私有的”，别的进程是看不到的，也不会被同步到后备的存储中。但是如果是共享映射，所有的进程都是共享同一块页缓存的，此时被映射的文件的数据在内存中只保留一份。任何一个进程对映射区进行读或者写，都不会导致对页缓冲数据的复制。 mmap 的系统调用函数原型为 1void* mmap(void* addr, size_t len, int prot, int flag, int fd, off_t off) 其中，flag 指定了是私有映射还是共享映射，私有映射的写会引发缺页中断，然后复制对应的物理页框到新分配的页框中。prot 指定了被映射的文件是可读、可写、可执行还是不可访问。如果 prot 指定的是可读，但是却对映射文件执行写操作，则此时却缺页中断会引起段错误，而不是进行写时复制。 那么此时存在另一个问题就是，当最后一个 render 进程退出之后，存储 scene.dat 的页缓存是不是会被马上释放掉？当然不是！在一个进程中打开一个文件使用完之后该进程退出，然后在另一个进程中使用该文件这种情况通常是很常见的，页缓存的管理中必须考虑到这种情况。况且从页缓存中读取数据的时间是 ns 级别，但是从硬盘中读取数据的时间是 ms 级别，因此如果能够在使用数据的时候命中页缓存，那么对于系统的性能将非常有帮助。那么，问题来了，什么时候该文件对应的页缓存要被换出内存呢?就是系统中的内存紧张，必须要换出一部分物理页到硬盘中或者交换区中，以腾出更多的空间给即将要使用的数据的时候。所以只要系统中存在空闲的内存，那么页缓存就不会被换出，直到到达页缓存的上限为止。是否换出某一页缓存不是由某一个进程决定的，而是由操作系统在整个系统空间中的资源分配决定的。毕竟，从页缓存中读取数据要比从硬盘上读取数据要快的多了。 内存映射的一个典型应用就是动态共享库的加载。图8展示了两个同一份程序的两个实例使用动态共享库时，进程的虚拟地址空间及对应的物理内存空间的布局。 三、页缓存中数据如何实现和后备存储之间的同步？普通文件 IO，都是将数据直接写在页缓存上，那么页缓存中的数据何时写回后备存储？怎么写回？ 3.1 何时写回 空闲内存的值低于一个指定的阈值的时候，内核必须将脏页写回到后备存储以释放内存。因为只有干净的内存页才可以回收。当脏页被写回之后就变为 PG_uptodate 标志，变为干净的页，内核就可以将其所占的内存回收； 当脏页在内存中驻留的时间超过一个指定的阈值之后，内核必须将该脏页写回到后备存储，以确定脏页不会在内存中无限期的停留； 当用户进程显式的调用 fsync、fdatasync 或者 sync 的时候，内核按照要求执行回写操作。 3.2 由谁写回为了能够不阻塞写操作，并且将脏页及时的写回后备存储。linux 在当前的内核版本中使用了 flusher 线程负责将脏页回写。 为了满足第一个何时回写的条件，内核在可用内存低于一个阈值的时候唤醒一个或者多个 flusher 线程，将脏页回写； 为了满足第二个条件，内核将通过定时器定时唤醒flusher线程，将所有驻留时间超时的脏页回写。 四、附录 五、文章孤独剑0001 &amp; linux中的页缓存和文件IO孤独剑0001 &amp; linux进程空间、页缓存和虚拟文件系统图","tags":[]},{"title":"mmap","date":"2019-10-10T07:56:21.198Z","path":"2019/10/10/iOS/iOS原理/iOS mmap/","text":"一、常规文件操作常规文件操作（read/write）有那几个重要步骤： 进程发起读文件请求 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode inode 在 address_space 上查找要请求的文件页是否已经缓存在内核页高速缓冲中。如果存在，则直接返回这片文件页的内容 如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到内核页高速缓冲。之后再次发起读页面过程，进而将内核页高速缓冲中的数据发给用户进程 需要注意的几点： 常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。由于页缓存处在内核空间，不能被用户进程直接寻址，所以需要将页缓存中数据页再次拷贝到内存对应的用户空间中 read/write 是系统调用很耗时，如下图，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，实际上完成了两次数据拷贝 如果两个进程都对磁盘中的一个文件内容进行访问，那么这个内容在物理内存中有三份：进程 A 的地址空间 + 进程 B 的地址空间 + 内核页高速缓冲空间 写操作也是一样，待写入的 buffer 在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝 Linux 内核剖析 二、mmap内存映射2.1 mmap 介绍在日常开发中偶尔会遇到 mmap，它最常用到的场景是 MMKV，其次用到的是日志打印。虽然都已经被封装好，但也需要了解下 mmap 的基本原理和过程。 进程是 App 运行的基本单位，进程之间相对独立。iOS 系统中 App 运行的内存空间地址是虚拟空间地址，存储数据是在各自的沙盒。 当我们在 App 中去读写沙盒中的文件时，我们会使用 NSFileManager 去查找文件，然后可以使用 NSData 去加载二进制数据。文件操作的更底层实现过程，是使用 linux 的 read()、write() 函数直接操作文件句柄（也叫文件描述符、fd）。 在操作系统层面，当 App 读取一个文件时，实际是有两步： 将文件从磁盘读取到物理内存； 从系统空间拷贝到用户空间（可以认为是复制到系统给 App 统一分配的内存）。 iOS 系统使用页缓存机制，通过 MMU（Memory Management Unit）将虚拟内存地址和物理地址进行映射，并且由于进程的地址空间和系统的地址空间不一样，所以还需要多一次拷贝。 而 mmap 将磁盘上文件的地址信息与进程用的虚拟逻辑地址进行映射，建立映射的过程与普通的内存读取不同：正常的是将文件拷贝到内存，mmap 只是建立映射而不会将文件加载到内存中。 在内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存，具体到代码，就是建立并初始化了相关的数据结构（struct address_space），这个过程由系统调用 mmap() 实现，所以建立内存映射的效率很高。 既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。 mmap() 会返回一个指针 ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用 read 或 write 对文件进行读写，而只需要通过 ptr 就能够操作文件。但是 ptr 所指向的是一个逻辑地址，要操作其中的数据，必须通过 MMU 将逻辑地址转换成物理地址，如上图中过程 2 所示。这个过程与内存映射无关。 前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU 在地址映射表中是无法找到与 ptr 相对应的物理地址的，也就是 MMU 失败，将产生一个缺页中断，缺页中断的中断响应函数会在 swap 中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过 mmap() 建立的映射关系，从硬盘上将文件读取到物理内存中，如上图中过程 3 所示。这个过程与内存映射无关。 如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。 mmap 内存映射的实现过程，总的来说可以分为三个阶段： 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域 调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝 认真分析mmap：是什么 为什么 怎么用 2.2 适合的场景 有一个很大的文件，因为映射有额外的性能消耗，所以适用于频繁读操作的场景；（单次使用的场景不建议使用） 有一个小文件，它的内容您想要立即读入内存并经常访问。这种技术最适合那些大小不超过几个虚拟内存页的文件。（页是地址空间的最小单位，虚拟页和物理页的大小是一样的，通常为 4KB。） 需要在内存中缓存文件的特定部分。文件映射消除了缓存数据的需要，这使得系统磁盘缓存中的其他数据空间更大 当随机访问一个非常大的文件时，通常最好只映射文件的一小部分。映射大文件的问题是文件会消耗活动内存。如果文件足够大，系统可能会被迫将其他部分的内存分页以加载文件。将多个文件映射到内存中会使这个问题更加复杂。 2.3 不适合的场景 希望从开始到结束的顺序从头到尾读取一个文件 文件有几百兆字节或者更大。将大文件映射到内存中会快速地填充内存，并可能导致分页，这将抵消首先映射文件的好处。对于大型顺序读取操作，禁用磁盘缓存并将文件读入一个小内存缓冲区 该文件大于可用的连续虚拟内存地址空间。对于 64 位应用程序来说，这不是什么问题，但是对于 32 位应用程序来说，这是一个问题。32 位虚拟内存最大是 4GB，可以只映射部分。 因为每次操作内存会同步到磁盘，所以不适用于移动磁盘或者网络磁盘上的文件； 变长文件不适用； 三、iOS 中的 mmap以官网的 demo 为例，其他的代码很简明直接，核心就在于mmap函数。 12345678910111213141516/** * @param start 映射开始地址，设置 NULL 则让系统决定映射开始地址 * @param length 映射区域的长度，单位是 Byte * @param prot 映射内存的保护标志，主要是读写相关，是位运算标志；（记得与下面fd对应句柄打开的设置一致） * @param flags 映射类型，通常是文件和共享类型 * @param fd 文件句柄 * @param off_toffset 被映射对象的起点偏移 */void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);*outDataPtr = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_FILE|MAP_SHARED, fileDescriptor, 0); 用官网的代码做参考，写了一个读写的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#import \"ViewController.h\"#import &lt;sys/mman.h&gt;#import &lt;sys/stat.h&gt;int MapFile(const char * inPathName, void ** outDataPtr, size_t * outDataLength, size_t appendSize)&#123; int outError; int fileDescriptor; struct stat statInfo; // Return safe values on error. outError = 0; *outDataPtr = NULL; *outDataLength = 0; // Open the file. fileDescriptor = open( inPathName, O_RDWR, 0 ); if( fileDescriptor &lt; 0 ) &#123; outError = errno; &#125; else &#123; // We now know the file exists. Retrieve the file size. if( fstat( fileDescriptor, &amp;statInfo ) != 0 ) &#123; outError = errno; &#125; else &#123; ftruncate(fileDescriptor, statInfo.st_size + appendSize); fsync(fileDescriptor); *outDataPtr = mmap(NULL, statInfo.st_size + appendSize, PROT_READ|PROT_WRITE, MAP_FILE|MAP_SHARED, fileDescriptor, 0); if( *outDataPtr == MAP_FAILED ) &#123; outError = errno; &#125; else &#123; // On success, return the size of the mapped file. *outDataLength = statInfo.st_size; &#125; &#125; // Now close the file. The kernel doesn’t use our file descriptor. close( fileDescriptor ); &#125; return outError;&#125;void ProcessFile(const char * inPathName)&#123; size_t dataLength; void * dataPtr; char *appendStr = \" append_key\"; int appendSize = (int)strlen(appendStr); if( MapFile(inPathName, &amp;dataPtr, &amp;dataLength, appendSize) == 0) &#123; dataPtr = dataPtr + dataLength; memcpy(dataPtr, appendStr, appendSize); // Unmap files munmap(dataPtr, appendSize + dataLength); &#125;&#125;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSString * path = [NSHomeDirectory() stringByAppendingPathComponent:@\"test.data\"]; NSLog(@\"path: %@\", path); NSString *str = @\"test str\"; [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil]; ProcessFile(path.UTF8String); NSString *result = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; NSLog(@\"result:%@\", result);&#125; 在 iOS 的应用实例： MMKV–基于 mmap 的 iOS 高性能通用 key-value 组件 iOS图片加载速度极限优化—FastImageCache解析 FastImageCache 四、MMKV 和 mmapNSUserDefault 是常见的缓存工具，但是数据有时会同步不及时，比如说在 crash 前保存的值很容易出现保存失败的情况，在 App 重新启动之后读取不到保存的值。 MMKV 很好的解决了 NSUserDefault 的局限，具体的好处可以见官网。 但是同样由于其独特设计，在数据量较大、操作频繁的场景下，会产生性能问题。 这里的使用给出两个建议： 不要全部用 defaultMMKV，根据业务大的类型做聚合，避免某一个 MMKV 数据过大，特别是对于某些只会出现一次的新手引导、红点之类的逻辑，尽可能按业务聚合，使用多个 MMKV 的对象； 对于需要频繁读写的数据，可以在内存持有一份数据缓存，必要时再更新到 MMKV； 五、NSData 与 mmapNSData 有一个静态方法和 mmap 有关系。 123456789101112+ (id)dataWithContentsOfFile:(NSString *)path options:(NSDataReadingOptions)readOptionsMask error:(NSError **)errorPtr;typedef NS_OPTIONS(NSUInteger, NSDataReadingOptions) &#123; // Hint to map the file in if possible and safe. 在保证安全的前提下使用 mmap NSDataReadingMappedIfSafe = 1UL &lt;&lt; 0, // Hint to get the file not to be cached in the kernel. 不要缓存。如果该文件只会读取一次，这个设置可以提高性能 NSDataReadingUncached = 1UL &lt;&lt; 1, // Hint to map the file in if possible. This takes precedence over NSDataReadingMappedIfSafe if both are given. 总使用 mmap NSDataReadingMappedAlways API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0)) = 1UL &lt;&lt; 3, ...&#125;; Mapped 的意思是使用 mmap，那么 ifSafe 是什么意思呢？ NSDataReadingMappedIfSafe 和 NSDataReadingMappedAlways 有什么区别？ 如果使用 mmap，则在 NSData 的生命周期内，都不能删除对应的文件。 如果文件是在固定磁盘，非可移动磁盘、网络磁盘，则满足 NSDataReadingMappedIfSafe。对 iOS 而言，这个 NSDataReadingMappedIfSafe = NSDataReadingMappedAlways。 那什么情况下应该用对应的参数？ 如果文件很大，直接使用 dataWithContentsOfFile 方法，会导致 load 整个文件，出现内存占用过多的情况；此时用 NSDataReadingMappedIfSafe，则会使用 mmap 建立文件映射，减少内存的占用。 使用场景：视频加载。视频文件通常比较大，但是使用的过程中不会同时读取整个视频文件的内容，可以使用 mmap 优化。 六、总结 mmap 就是文件的内存映射。 通常读取文件是将文件读取到内存，会占用真正的物理内存；而 mmap 是用进程的内存虚拟地址空间去映射实际的文件中，这个过程由操作系统处理。mmap 不会为文件分配物理内存，而是相当于将内存地址指向文件的磁盘地址，后续对这些内存进行的读写操作，会由操作系统同步到磁盘上的文件。 iOS 中使用 mmap 可以用 c 方法的 mmap()，也可以使用 NSData 的接口带上NSDataReadingMappedIfSafe 参数。前者自由度更大，后者用于读取数据。 七、文章落影loyinglin &amp; iOS的文件内存映射——mmapmmap 苹果官方文档NSDataReadingMappedIfSafe小凉介 &amp; iOS内存映射mmap详解linux中的页缓存和文件IO从内核文件系统看文件读写过程linux内存映射mmap原理分析mmap实例及原理分析","tags":[]},{"title":"图片处理","date":"2019-09-16T01:18:32.131Z","path":"2019/09/16/iOS/iOS媒体/图片处理/","text":"一、ImageMagick使用 ImageMagick 对 png 图片做轻量压缩（基本没有减少体积），不损失图片质量，会改变图片文件 hash 值。方法： 安装 ImageMagick 1$ brew install imagemagick 压缩工程目录下所有 png 文件 1find . -iname \"*.png\" -exec echo &#123;&#125; \\; -exec convert &#123;&#125; &#123;&#125; \\; 其他用法： 1234567891011121314151617更改文件类型$ convert input.jpg output.png // 增加有色边$ convert -bordercolor red -border 25x25 image.jpg image.gif // 加亮或变暗图片边缘，以增强3D效果$ convert -raise 25 image.jpg image.gif // 在图片周围增加装饰性框架。$ convert -mattecolor gray -frame 25x25 image.jpg image.gif // 在图片边缘增加升、降斜角$ convert -mattecolor gray -frame 25x25+0+25 image.jpg image.gif$ convert -mattecolor gray -frame 25x25+25+0 image.jpg image.gif // 将 gif 文件分析为一系列的单个图片$ convert animation.gif frame%02d.gif // 创建一张空白图片$ convert -size 800x600 xc:\"#ddddff\" ltblue.ppm$ convert -size 800x600 null:white white.ppm$ convert in.png -threshold 100% black.ppm // 与 in.png 同大小 Mac：文件校验终端命令查看文件哈希值 12345678910`MD5`$ md5 文件路径`SHA1`$ shasum 文件路径 或者$ openssl dgst -sha1 文件路径`SHA256`$ openssl dgst -sha256 文件路径 二、文章iOS 马甲包（一）图片轻量级压缩改变 hash 值","tags":[]},{"title":"Premultiplied Alpha","date":"2019-09-16T01:18:32.130Z","path":"2019/09/16/iOS/iOS媒体/Premultiplied Alpha/","text":"Xcode 的工程选项里有一项 Compress PNG Files，会对 PNG 进行 Premultiplied Alpha。游戏开发中会更加关注这个格式，省一些运行时计算。 Premultiplied Alpha 是什么呢？ Alpha Blending: To Pre or Not To Pre 这篇文章其实说的很清楚。还有《Real Time Rendering》 一、Alpha Blending要搞清楚这个问题，先得理解 Alpha 通道的工作原理。 最常见的像素表示格式是 RGBA8888 即 （r, g, b, a），每个通道 8 位，0~255。例如红色 60% 透明度就是（255, 0, 0, 153），为了表示方便，alpha 通道一般记成正规化后的 0~1 的浮点数，也就是（255, 0, 0, 0.6）。而 Premultiplied Alpha 则是把 RGB 通道乘以透明度也就是（r a, g a, b * a, a），50% 透明红色就变成了（153, 0, 0, 0.6）。 透明通道在渲染的时候通过 Alpha Blending 产生作用，如果一个透明度为 as 的颜色 Cs 渲染到颜色 Cd 上，混合后的颜色通过以下公式计算： Co = asCs + (1 − as)Cd 以 60% 透明的红色渲染到白色背景为例： Co = (255, 0, 0) * 0.6 + (255, 255, 255) *(1 − 0.6) = (255, 102, 102) 也就是说，从视觉上（255, 0, 0, 0.6）渲染到白色背景上和（255, 102, 102）是同一个颜色。如果颜色以 Premultiplied Alpha 形式存储，也就是 Cs 已经乘以透明度了，所以混合公式变成了： Co = Cs′ + (1 − as)Cd 二、为什么要 Premultiplied Alpha？Premultiplied Alpha 后的像素格式变得不直观，因为在画图的时候都是先从调色板中选出一个 RGB 颜色，再单独设置透明度，如果 RGB 乘以透明度就搞不清楚原色是什么了。从前面的 Alpha Blending 公式可以看出，Premultiplied Alpha 之后，混合的时候可以少一次乘法，这可以提高一些效率，但这并不是最主要的原因。最主要的原因是： 没有 Premultiplied Alpha 的纹理无法进行 Texture Filtering（除非使用最近邻插值）。 以最常见的 filtering 方式线性插值为例，一个宽 2px 高 1px 的图片，左边的像素是红色，右边是绿色 10% 透明度，如果把这个图片缩放到 1x1 的大小，那么缩放后 1 像素的颜色就是左右两个像素线性插值的结果，也就是把两个像素各个通道加起来除以2。如果使用没有 Premultiplied Alpha 的颜色进行插值，那么结果就是： ((255, 0, 0, 1) + (0, 255, 0, 0.1)) * 0.5 = (127, 127, 0, 0.55) 如果绿色 Premultiplied Alpha，也就是（0, 255 * 0.1, 0, 0.1），和红色混合后： ((255, 0, 0, 1) + (0, 25, 0, 0.1)) * 0.5 = (127, 25, 0, 0.55) Premultiplied Alpha 最重要的意义是使得带透明度图片纹理可以正常的进行线性插值。这样旋转、缩放或者非整数的纹理坐标才能正常显示，否则就会像上面的例子一样，在透明像素边缘附近产生奇怪的颜色。 三、纹理处理我们使用的 PNG 图片纹理，一般是不会 Premultiplied Alpha 的。游戏引擎在载入 PNG 纹理后会手动处理，然后再 glTexImage2D 传给 GPU，比如 Cocos2D-x 中的 CCImage::premultipliedAlpha： 12345678void Image::premultipliedAlpha() &#123; unsigned int* fourBytes = (unsigned int*)_data; for (int i = 0; i &lt; _width * _height; i++) &#123; unsigned char* p = _data + i * 4; fourBytes[i] = CC_RGB_PREMULTIPLY_ALPHA(p[0], p[1], p[2], p[3]); &#125; _hasPremultipliedAlpha = true;&#125; 而 GPU 专用的纹理格式，比如 PVR、ETC 一般在生成纹理都是默认 Premultiplied Alpha 的，这些格式一般是 GPU 硬解码，引擎用 CPU 处理会很慢。 总之 glTexImage2D 传给 GPU 的纹理数据最好都是 Multiplied Alpha 的，要么在生成纹理时由纹理工具 Pre-multiplied，要么载入纹理后由游戏引擎或 UI 框架 Post-multiplied。 四、iOS 中的 Premultiplied AlphaCore Graphics 的 CGImage.h 对图像透明度信息有如下定义 12345678typedef CF_ENUM(uint32_t, CGImageAlphaInfo)&#123; // ... /* For example, premultiplied RGBA */ kCGImageAlphaPremultipliedLast, /* For example, premultiplied ARGB */ kCGImageAlphaPremultipliedFirst, // ...&#125;; 预乘透明度（Premultiplied Alpha）图像简单地说，即每个颜色分量都乘以 alpha 通道值作为结果值： color.rgb *= color.alpha 为什么关注预乘透明度图像？微信团队因 AR 抢红包场景的 OpenGL 混色结果出错引起注意。 Premultiplied alpha is better than conventional blending for several reasons: It works properly when filtering alpha cutouts _(see below)_ It works properly when doing image composition _(stay tuned for my next post)_ It is a superset of both conventional and additive blending. If you set alpha to zero while RGB is non zero, you get an additive blend. This can be handy for particle systems that want to smoothly transition from additive glowing sparks to dark pieces of soot as the particles age. It plays nice with DXT compression, which only supports transparent pixels with an RGB of zero. 摘自：Premultiplied alpha","tags":[]},{"title":"添加垃圾代码","date":"2019-09-16T01:18:32.129Z","path":"2019/09/16/iOS/iOS架构/垃圾代码/","text":"方式 1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python# _*_ coding:utf-8 _*_#第一步:首先生成一个500位的数组 驼峰类型的元素 用作文件名 eg:AsdfdfGsdimport randomimport os,sysimport stringfirst = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"second = \"abcdefghijklmnopqrstuvwxyz\"number = \"345\"index = 0array = [\\]for i in range(500): final=(random.choice(first)) index = random.randint(3, 5) for i in range(index): final+=(random.choice(second)) final += (random.choice(first)) for i in range(index): final+=(random.choice(second)) array.append(final)print (array)#第二步:#用上边生成的数组来创建对应的.h和.m文件# -*- coding: utf-8 -*-import randomimport osimport string#创建.h文件def text_createH(fileNmae,msg,msg1,propertyNumber,methodArray,msg3): full_path = sys.path[0] + '/ReplaceDemo/' + fileNmae + '.h' file = open(full_path, 'w') file.write('//\\n// '+fileNmae+'.h\\n// SajiaoShopping\\n\\n// Created by 某 波 bo on 15/10/23.\\n// Copyright © 2017年 阿里郎. All rights reserved.\\n//\\n\\n') file.write(msg) file.write(msg1) propryNameArray = [] for index in range(1,propertyNumber): propryNameArray.append(random.choice(array)) propryNameArray = list(set(propryNameArray)) for propertyName in propryNameArray: file.write('@property(nonatomic,strong)'+random.choice(classArray)+' * '+propertyName+';\\n') file.write('\\n\\n') for methodName in methodArray: file.write('- (void)pushTo'+methodName+'VC:(NSDictionary *)info;\\n') file.write(msg3) file.close() print('Done')#创建.m文件def text_createM(fileNmae,msg,msg1,methodArray,msg3): full_path = sys.path[0] + '/ReplaceDemo/' + fileNmae + '.m' file = open(full_path, 'w') file.write('//\\n// '+fileNmae+'.m\\n// SajiaoShopping\\n\\n// Created by 某 波 bo on 15/10/23.\\n// Copyright © 2017年 阿里郎. All rights reserved.\\n//\\n\\n') file.write(msg) file.write(msg1) for methodName in methodArray: file.write('- (void)pushTo'+methodName+'VC:(NSDictionary *)info\\n&#123;\\n\\n NSMutableArray *array = [NSMutableArray array];\\n') number = random.randint(3, 10) for i in range(1,number): file.write(' [array addObject:@\"'+random.choice(array)+'\"];\\n') file.write('\\n&#125;\\n\\n') file.write(msg3) file.close() print('Done')classArray = ['NSString','UILabel','NSDictionary','NSData','UIScrollView','UIView']array = ['HwxrFvrj', 'QnzduQbtdd', 'PvcrwLtqhf', 'UvdhDbjn', 'SuntmyTxvyzg', 'CvlxwBipbp', 'GzrdyzIbimvz', 'CqsjqMmgsp', 'OxaaeuWjhasc', 'NjiardRvwgbi', 'NcculmLtpljq', 'ApoqQrll', 'GkgokDyvjb', 'EblldkVouplj', 'KfdrFvnw', 'SfhyhObftc', 'SmruByoc', 'YzcccvXmpmit', 'OmqvaHpxat', 'XzytsUyvyd', 'MjforNnnyi', 'ZvjhuIdogs', 'BzfrxzSeahxc', 'PycycwFjtpny', 'XvngtoSedljr', 'DktiaCbucd', 'AqbplNuodc', 'MzkvgZuala', 'KdwzIoej', 'AaynatUpqcfd', 'IyvwhZvtjc', 'UmijGmsy', 'AoayndXxghym']array = list(set(array))for name in array: number = random.randint(3, 10) methodArray = [] for i in range(1,5): methodArray.append(random.choice(array)) methodArray = list(set(methodArray))#数组去重 text_createH(name+'ViewController', '#import &lt;UIKit/UIKit.h&gt;\\n','@interface '+name+ 'ViewController:'+ 'UIViewController\\n\\n',number,methodArray,'\\n\\n@end') text_createM(name+'ViewController', '#import \"'+name+'ViewController.h\"\\n\\n' '@interface '+ name+'ViewController()\\n\\n @end\\n\\n','@implementation '+name+'ViewController\\n\\n- (void)viewDidLoad &#123; \\n\\n [super viewDidLoad];\\n\\n&#125;\\n\\n',methodArray,'\\n\\n@end') full_path 代表垃圾文件生成路径，第一次 file.write 的是类的注释，包含工程名、类名、作者，这种方式生成的内容无意义，所以很可能过不了审核。脚本原文 方式 2： 使用 KLGenerateSpamCode 扫描工程中的代码，生成同等数量的 Category 文件，文件中即是同等方法数量的垃圾代码。 KLGenerateSpamCode 工程 -> Edit scheme -&gt; Run -&gt; Arguments Passed On Launch 添加。 Trash 是放垃圾代码的文件夹，trash 是分类名。 或者用终端执行命令 1./GenerateSpamCode /Users/CJ/Desktop/ReplaceDemo/ReplaceDemo -spamCodeOut /Users/CJ/Desktop/Trash trash 第一条路径是马甲包工程，第二条路径是存放垃圾代码目录路径。 两种方式都会自动在指定路径下生成 Trash 文件夹。","tags":[]},{"title":"pthread_rwlock_t","date":"2019-09-16T01:18:32.129Z","path":"2019/09/16/iOS/iOS多线程/pthread_rwlock_t/","text":"一、读写锁读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。 读操作可以共享，写操作是排他的，可以有多个在读（与 CPU 数相关），只能有唯一个在写，但不能同时既有读者又有写者。 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。 具有强读者同步和强写者同步两种形式： 强读者同步：当写者没有进行写操作，读者就可以访问； 强写者同步：当所有写者都写完之后，才能进行读操作。 在强写者情况，读者需要最新的信息，一些事实性较高的系统可能会用到该锁，比如定票之类的。 二、特性一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。 正因为这个特性，当读写锁是写加锁状态时，在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞。 当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁，它必须直到所有的线程释放锁。 通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞. 读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享，以写模式锁住时意味着独占，所以读写锁又叫共享-独占锁。 三、小结 互斥锁与读写锁的区别 当访问临界区资源时（访问的含义包括所有的操作：读和写），需要上互斥锁； 当对数据（互斥锁中的临界区资源）进行读取时，需要上读取锁，当对数据进行写入时，需要上写入锁。 读写锁的优点 对于读数据比修改数据频繁的应用，用读写锁代替互斥锁可以提高效率。因为使用互斥锁时，即使是读出数据（相当于操作临界区资源）都要上互斥锁，而采用读写锁，则可以在任一时刻允许多个读者存在，提供了更高的并发度，同时在某个写入者修改数据期间保护该数据，以免任何其它读出者或写入者的干扰。 读写锁描述： 获取一个读写锁用于读称为共享锁，获取一个读写锁用于写称为独占锁，因此这种对于某个给定资源的共享访问也称为共享-独占上锁。 四、使用读写锁配置读写锁的属性之后，即可初始化读写锁。以下函数用于初始化或销毁读写锁、锁定或解除锁定读写锁或尝试锁定读写锁。 初始化读写锁 使用 pthread_rwlock_init(3C) 通过 attr 所引用的属性初始化 rwlock 所引用的读写锁。 12345678910/** * @param attr 如果为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同 * * @return 如果成功，返回 0，否则将返回用于指明错误的错误号。 EINVAL : attr 或者 rwlock 指定的值无效 */int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 如果 attr 为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同。 初始化读写锁之后，该锁可以使用任意次数，而无需重新初始化。成功初始化之后，读写锁的状态会变为已初始化和未锁定。如果调用 pthread_rwlock_init() 来指定已初始化的读写锁，则结果是不确定的。如果读写锁在使用之前未初始化，则结果是不确定的。 如果缺省的读写锁属性适用，则 PTHREAD_RWLOCK_INITIALIZER 宏可初始化以静态方式分配的读写锁，其作用与通过调用pthread_rwlock_init() 并将参数 attr 指定为 NULL 进行动态初始化等效，区别在于不会执行错误检查。 如果 pthread_rwlock_init() 失败，将不会初始化 rwlock，并且 rwlock 的内容是不确定的。 获取读写锁中的读锁 pthread_rwlock_rdlock(3C) 可用来向 rwlock 所引用的读写锁应用读锁。 1234567#include &lt;pthread.h&gt;/** * @return 如果成功，返回 0。否则，将返回用于指明错误的错误号。 EINVAL : attr 或 rwlock 指定的值无效 * */int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 如果写入器未持有读锁，并且没有任何写入器基于该锁阻塞，则调用线程会获取读锁。如果写入器未持有读锁，但有多个写入器正在等待该锁时，调用线程是否能获取该锁是不确定的。如果某个写入器持有读锁，则调用线程无法获取该锁。如果调用线程未获取读锁，则它将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_rdlock() 返回。如果在进行调用时，调用线程持有 rwlock 中的写锁，则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 一个线程可以在 rwlock 中持有多个并发的读锁，该线程可以成功调用 pthread_rwlock_rdlock() n 次。该线程必须调用 pthread_rwlock_unlock() n 次才能执行匹配的解除锁定操作。 如果针对未初始化的读写锁调用 pthread_rwlock_rdlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行读取，就好像线程未中断一样。 读取非阻塞读写锁中的锁 pthread_rwlock_tryrdlock(3C)应用读锁的方式与 pthread_rwlock_rdlock() 类似，区别在于如果任何线程持有 rwlock 中的写锁或者写入器基于 rwlock 阻塞，则 pthread_rwlock_tryrdlock() 函数会失败。 123456789#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行读取的锁，返回 0。否则，返回用于指明错误的错误号 * * EBUSY : 无法获取读写锁以执行读取，因为写入器持有该锁或者基于该锁已阻塞 */int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); 写入读写锁中的锁 pthread_rwlock_wrlock(3C) 可用来向 rwlock 所引用的读写锁应用写锁。 1234567#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行写入的锁，返回 0。否则，返回指明错误的错误号 */int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 如果没有其他读取器线程或写入器线程持有读写锁 rwlock，则调用线程将获取写锁，否则，调用线程将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_wrlock() 调用返回。如果在进行调用时，调用线程持有读写锁（读锁或写锁），则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 如果针对未初始化的读写锁调用 pthread_rwlock_wrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 写入非阻塞读写锁中的锁 pthread_rwlock_trywrlock(3C)应用写锁的方式与 pthread_rwlock_wrlock() 类似，区别在于如果任何线程当前持有用于读取和写入的 rwlock，则pthread_rwlock_trywrlock() 函数会失败。 1234567#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 引用的读写锁对象中执行写入的锁，则返回 0，否则，返回用于指明错误的错误号 * EBUSY : 无法为写入获取读写锁，因为已为读取或写入锁定该读写锁 */int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 如果针对未初始化的读写锁调用 pthread_rwlock_trywrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 解除锁定读写锁 pthread_rwlock_unlock(3C) 可用来释放在 rwlock 引用的读写锁对象中持有的锁。 123456#include &lt;pthread.h&gt;/** * @return 如果成功返回 0，否则返回用于指明错误的错误号 */int pthread_rwlock_unlock (pthread_rwlock_t *rwlock); 如果调用线程未持有读写锁 rwlock，则结果是不确定的。 如果通过调用 pthread_rwlock_unlock() 来释放读写锁对象中的读锁，并且其他读锁当前由该锁对象持有，则该对象会保持读取锁定状态。如果 pthread_rwlock_unlock() 释放了调用线程在该读写锁对象中的最后一个读锁，则调用线程不再是该对象的属主。如果 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个读锁，则该读写锁对象将处于无属主、解除锁定状态。 如果通过调用 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个写锁，则该读写锁对象将处于无属主、解除锁定状态。 如果 pthread_rwlock_unlock() 解除锁定该读写锁对象，并且多个线程正在等待获取该对象以执行写入，则通过调度策略可确定获取该对象以执行写入的线程。如果多个线程正在等待获取读写锁对象以执行读取，则通过调度策略可确定等待线程获取该对象以执行写入的顺序。如果多个线程基于 rwlock 中的读锁和写锁阻塞，则无法确定读取器和写入器谁先获得该锁。 如果针对未初始化的读写锁调用 pthread_rwlock_unlock()，则结果是不确定的。 销毁读写锁 pthread_rwlock_destroy(3C) 可用来销毁 rwlock 引用的读写锁对象并释放该锁使用的任何资源。 12345678#include &lt;pthread.h&gt;/** * @return 如果成功，返回 0。否则，返回用于指明错误的错误号。EINVAL : attr 或者 rwlock 指定的值无效 */int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 再次调用 pthread_rwlock_init() 重新初始化该锁之前，使用该锁所产生的影响是不确定的。实现可能会导致 pthread_rwlock_destroy() 将 rwlock 所引用的对象设置为无效值。如果在任意线程持有 rwlock 时调用 pthread_rwlock_destroy()，则结果是不确定的。尝试销毁未初始化的读写锁会产生不确定的行为。已销毁的读写锁对象可以使用 pthread_rwlock_init() 来重新初始化。销毁读写锁对象之后，如果以其他方式引用该对象，则结果是不确定的。 五、文章百度百科","tags":[]},{"title":"GCD实现","date":"2019-09-16T01:18:32.128Z","path":"2019/09/16/iOS/iOS多线程/GCD实现/","text":"一、Dispatch Queue不难想象 GCD 的实现需要使用以下这些工具。 ①、用于管理追加的 Block 的 C 语言层实现的 FIFO 队列； ②、Atomic 函数中实现的用于排他控制的轻量级信号； ③、用于管理线程的 C 语言层实现的一些容器。 但如果只用了这些内容便可实现，那么就不需要内核级的实现了。官方说明： 通常，应用程序中编写的线程管理用的代码要在系统级实现。 在系统（iOS 和 OS X 的核心 XNU 内核）级上的实现。因此，无论编程人员如何努力编写管理线程的代码，在性能方面都不可能超过 XNU 内核级所实现的 GCD。 使用 GCD 不必编写线程的创建、销毁等管理代码，而可以在线程中集中实现处理内容。我们应该尽量多使用 GCD 或者使用了 Cocoa 框架 GCD 的 NSOperationQueue 类等 API。 用于实现 Dispatch Queue 而使用的软件组件。 编程人员所使用的 GCD 的 API 全部为包含在 libdispatch 库的 C 语言函数。Dispatch Queue 通过结构体和链表，被实现为 FIFO 队列。FIFO 队列管理通过 dispatch_async 等函数所追加的 block。 Block 并不直接加入 FIFO 队列，而是先加入 Dispatch Continuation 这一个 dispatch_continuation_t 类型结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记录 Block 所属的 Dispatch Group 和一些其他信息，相当于一般常说的上下文。 Dispatch Queue 可通过 dispatch_set_target_queue 函数设定执行该 Dispatch Queue 处理的 Dispatch Queue 为目标。该目标可像串珠子一样，设定多个连接在一起的 Dispatch Queue。但是在连接串的最后必须设定为 Main Dispatch Queue 或各种优先级的 Global Dispatch Queue，或者准备用于 Serial Dispatch Queue 的各种优先级的 Global Dispatch Queue。 Global Dispatch Queue 有 8 种： Global Dispatch Queue（High Priority） Global Dispatch Queue（Default Priority） Global Dispatch Queue（Low Priority） Global Dispatch Queue（Background Priority） Global Dispatch Queue（High Overcommit Priority） Global Dispatch Queue（Default Overcommit Priority） Global Dispatch Queue（Low Overcommit Priority） Global Dispatch Queue（Background Overcommit Priority） 优先级带有 Overcommit 的 Global Dispatch Queue 使用在 Serial Dispatch Queue 中。如 Overcommit 这个名称所示，不管系统状态如何，都会强制生成线程的 Dispatch Queue。 这 8 种 Global Dispatch Queue 各使用 1 个 pthread_workqueue。GCD 初始化时，使用 pthread_workqueue_create_np 函数生成 pthread_workqueue。 pthread_workqueue 包含在 Libc 提供的 pthreads API 中。其使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息。 XNU 内核持有 4 种 workqueue： WORKQUEUE_HIGH_PRIOQUEUE WORKQUEUE_DEFAULT_PRIOQUEUE WORKQUEUE_LOW_PRIOQUEUE WORKQUEUE_BG_PRIOQUEUE 该执行优先级和 Global Dispatch Queue 的 4 种优先级相同。 当在 Global Dispatch Queue 中执行 Block 时，libdispatch 从 Global Dispatch Queue 自身的 FIFO 队列取出 Dispatch Continuation，调用 pthread_workqueue_additem_np 函数，把该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数。 pthread_workqueue_additem_np 函数使用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目。根据该通知，XNU 内核基于系统状态判断是否要生成线程。如果是 Overcommit 优先级的 Global Dispatch Queue，workqueue 则始终生成线程。 该线程虽然与 iOS 和 OS X 中通常使用的线程大致相同，但是有一部分 pthread API 不能使用。详见苹果官方文档《并行编码指南》的“与 POSIX 线程的互换性”。 另外，因为 workqueue 生成的线程在实现用于 workqueue 的线程计划表中运行，所以与一般线程的上下文切换不同。 workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数。在该回调函数中执行加入到 Dispatch Continuation 的 Block。 Block 执行结束后，进行通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备执行加入到 Global Dispatch Queue 中的下一个 Block。 总结： ①、block、block 所属的 group、其他信息加入的 dispatch_continuation_t 结构体中； ②、将 dispatch_continuation_t 加入 FIFO 队列； ③、Dispatch_Queue 通过 dispatch_set_target_queue 设置目标 Queue； ④、GCD 初始化时，pthread_workqueue_create_np 生成 pthread_workqueue; ⑤、pthread_workqueue 使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息； ⑥、当在 Global Dispatch Queue 执行 Block 时 libdispatch 从 FIFO 队列中取出 Dispatch Continuation； ⑦、调用 pthread_workqueue_additem_np 函数，将该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数； ⑧、pthread_workqueue_additem_np 内部调用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目； ⑨、XNU 内核基于系统状态判断是否要生成线程； ⑩、workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数，在该回调函数中执行加入到 Dispatch Continuation 的 Block。Block 执行结束后，通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备下一个 Block 的执行。","tags":[]},{"title":"GCD","date":"2019-09-16T01:18:32.128Z","path":"2019/09/16/iOS/iOS多线程/GCD/","text":"一、GCD 简介 百度百科 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。在 Mac OSX 10.6 首次推出，也可在 iOS4 及以上版本使用。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。 使用 GCD 的好处： GCD 可用于多核的并行运算 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉 GCD 想要执行什么任务。 二、GCD 任务和队列GCD 中两个核心概念：任务和队列。 2.1 任务要执行的操作，也就是在线程中执行的那段代码。在 GCD 是放在 block 里。 执行任务有两种方式：同步执行（sync）和异步执行（async）。 主要区别：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。 同步执行 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。 只能在当前线程中执行任务，不具备开启新线程的能力。 异步执行： 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。 可以在新的线程中执行任务，具备开启新线程的能力。 注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程，这跟任务所指定的队列类型有关。 2.2 队列指执行任务的等待队列，即用来存放任务的队列。 队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图： 在 GCD 中有两种队列：串行队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue）。两者都符合 FIFO（先进先出）的原则。 两者的主要区别是：执行顺序不同，以及开启线程数不同。 串行队列： 每次只执行一个任务，任务一个接一个执行。（只开启一个线程） 并发队列： 多个任务可以并发（同时）执行。（可以开启多个线程，并且同时执行任务） 注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。 两者具体区别如下图： 三、GCD 的使用步骤GCD 的使用只有两步： 创建一个队列（串行队列或并发队列） 将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。 3.1 队列的创建方法/获取方法 使用 dispatch_queue_create 来创建队列。 12345678910/* 参数 1 : 表示队列的唯一标识符，用于 DEBUG，可以为空，推荐使用应用 BundleId 的逆序全程域名 参数 2 : 用于识别是串行队列、并发队列。DISPATCH_QUEUE_SERIAL:串行 DISPATCH_QUEUE_CONCURRENT:并发 */// 串行队列dispatch_queue_t queue = dispatch_queue_create(\"net.bujige.testQueue\", DISPATCH_QUEUE_SERIAL);// 并发队列dispatch_queue_t queue = dispatch_queue_create(\"net.bujige.testQueue\", DISPATCH_QUEUE_CONCURRENT); GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue） 所有放在主队列中的任务，都会放到主线程中执行。 可使用 dispatch_get_main_queue() 获得主队列。 12// 主队列dispatch\\_queue\\_t queue = dispatch\\_get\\_main_queue(); GCD 默认提供了全局并发队列（Global Dispatch Queue） 1234567/** * 全局并发队列 * * 参数 1 : 队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT * 参数 2 : 暂时没用，传 0 */dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 3.2 任务的创建方法GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async。 123456789// 同步dispatch_sync(queue, ^&#123; // do something&#125;);// 异步dispatch_async(queue, ^&#123; // do something&#125;); 虽然使用 GCD 只需两步，但是既然有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么就有了四种不同的组合方式。这四种不同的组合方式是： 同步执行 + 并发队列 异步执行 + 并发队列 同步执行 + 串行队列 异步执行 + 串行队列 还有两种特殊队列：全局并发队列、主队列。因为主队列特殊，所以就又多了两种组合方式。这样就有 6 种不同的组合方式了。 同步执行 + 主队列 异步执行 + 主队列 同步既然不会开辟新的线程，那同步阻塞的是当前线程还是当前队列？ 阻塞当前队列，造成线程死锁。#### 3.3 GCD 线程间的通信在 iOS 开发过程中，通常把一些耗时的操作放在其他线程，然后在主线程进行 UI 刷新。而当有时候在其他线程完成了耗时操作时，需要回到主线程，就用到了线程之间的通讯。1234567891011121314151617181920212223242526272829/** * 线程间通信 */- (void)communication&#123; // 获取全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 异步追加任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 dispatch_async(mainQueue, ^&#123; // 追加在主线程中执行的任务 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125;); &#125;);&#125;1---&lt;NSThread: 0x600000271940&gt;&#123;number = 3, name = (null)&#125;1---&lt;NSThread: 0x600000271940&gt;&#123;number = 3, name = (null)&#125;2---&lt;NSThread: 0x60000007bf80&gt;&#123;number = 1, name = main&#125;可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。#### 3.4 GCD 的其他方法##### 3.4.1 GCD 栅栏方法：dispatch_barrier_async有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样就需要有一个相当于栅栏一样的方法将两组异步执行的操作组（包含一个或多个任务）给分割开来。这就需要用到 dispatch_barrier_async 方法。dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列。然后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：12345678910111213141516171819202122232425262728293031 // 并行队列 dispatch_queue_t queue = dispatch_queue_create(\"com.dubinbin.Demo\", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; NSLog(@\"1111\"); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"2222\"); &#125;); dispatch_barrier_async(queue, ^&#123; NSLog(@\"barrier\"); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"3333\"); &#125;); dispatch_async(queue, ^&#123; NSLog(@\"4444\"); &#125;); NSLog(@\"end\");2019-03-19 14:47:01.584536+0800 Demo[45246:3034531] end2019-03-19 14:47:01.584562+0800 Demo[45246:3034564] 22222019-03-19 14:47:01.584566+0800 Demo[45246:3034562] 11112019-03-19 14:47:01.584676+0800 Demo[45246:3034562] barrier2019-03-19 14:47:01.584755+0800 Demo[45246:3034562] 33332019-03-19 14:47:01.584765+0800 Demo[45246:3034564] 4444dispatch_barrier_async 执行结果：在执行完栅栏前面的任务之后，才执行栅栏操作，最后再执行栅栏后边的任务。##### 3.4.2 GCD 延时执行方法：dispatch_after经常会遇到这样的需求：在指定时间（例如 3 秒）之后执行某个任务。可以用 GCD 的 dispatch_after 函数来实现。注意：dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 函数是很有效的。12345678 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@\"Delay in Thread : %@\", [NSThread currentThread]); &#125;); NSLog(@\"end\");14:52:01.582676+0800 end14:52:06.583078+0800 Delay in Thread : &lt;NSThread: 0x600001026940&gt;&#123;number = 1, name = main&#125;dispatch_after 执行结果：打印 end 之后大约 5.0 秒打印了 Delay in Thread。##### 3.4.3 GCD 一次性代码：dispatch_once在创建单例或者整个程序运行过程中只执行一次的代码时，就用到了 GCD 的 dispatch_once 函数。使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行 1 次，并且即使在多线程的环境下，dispatch_once 也可以保证线程安全。1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // code to be executed once&#125;);##### 3.4.4 GCD 快速迭代方法：dispatch_apply通常是用 for 循环遍历，但是 GCD 提供了快速迭代的函数 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。如果是在串行队列（单线程）中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行，体现不出快速迭代的意义。dispatch_apply 可以在多个线程中同时（异步）遍历多个数字。注意：无论是串行队列，还是异步队列，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait 方法。123456789101112 dispatch_apply(5, queue, ^(size_t index) &#123; NSLog(@\"%zd---%@\", index, [NSThread currentThread]); &#125;); NSLog(@\"end\");1---&lt;NSThread: 0x6000031499c0&gt;&#123;number = 3, name = (null)&#125;3---&lt;NSThread: 0x600003149a00&gt;&#123;number = 5, name = (null)&#125;0---&lt;NSThread: 0x600003126fc0&gt;&#123;number = 1, name = main&#125;2---&lt;NSThread: 0x6000031414c0&gt;&#123;number = 4, name = (null)&#125;4---&lt;NSThread: 0x6000031414c0&gt;&#123;number = 4, name = (null)&#125;end因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定，但是 end 一定在最后执行。##### 3.4.5 GCD 队列组：dispatch_group有时候会有这样的需求：分别异步执行 2 个耗时任务，然后当 2 个耗时任务都执行完毕后再回到主线程执行任务。这时候就可以用到 GCD 的队列组。 调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合来实现。 调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。dispatch_group_notify监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 并执行。12345678910111213141516171819202122232425262728293031 dispatch_queue_t queue = dispatch_queue_create(\"com.dubinbin.Demo\", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; NSLog(@\"1111\"); &#125;); dispatch_group_async(group, queue, ^ &#123; NSLog(@\"2222\"); &#125;); dispatch_group_notify(group, queue, ^&#123; NSLog(@\"group\"); &#125;); dispatch_group_async(group, queue, ^&#123; NSLog(@\"3333\"); &#125;); dispatch_group_async(group, queue, ^&#123; NSLog(@\"4444\"); &#125;); NSLog(@\"end\");2019-03-19 15:07:48.576680+0800 Demo[45472:3045696] end2019-03-19 15:07:48.576680+0800 Demo[45472:3045738] 22222019-03-19 15:07:48.576687+0800 Demo[45472:3045736] 11112019-03-19 15:07:48.576702+0800 Demo[45472:3045735] 44442019-03-19 15:07:51.580427+0800 Demo[45472:3045737] 33332019-03-19 15:07:51.580874+0800 Demo[45472:3045737] groupdispatch_group_notify 运行结果：当所有任务都执行完成之后，才执行 dispatch_group_notify block 中的任务。注意：barrier 和 group 的区别，barrier 只等待之前的任务执行完，group 需要等待加入到 group 中所有的任务执行完。dispatch_group_wait暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。12345678910111213141516171819202122232425262728293031323334 dispatch_queue_t queue = dispatch_queue_create(\"com.dubinbin.Demo\", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, queue, ^&#123; NSLog(@\"1111\"); &#125;); dispatch_group_async(group, queue, ^ &#123; NSLog(@\"2222\"); &#125;); dispatch_group_notify(group, queue, ^&#123; NSLog(@\"group\"); &#125;); dispatch_group_async(group, queue, ^&#123; NSLog(@\"3333\"); &#125;); dispatch_group_async(group, queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@\"4444\"); &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@\"end\");2019-03-19 15:14:18.051069+0800 Demo[45564:3049581] 22222019-03-19 15:14:18.051069+0800 Demo[45564:3049578] 11112019-03-19 15:14:18.051089+0800 Demo[45564:3049579] 33332019-03-19 15:14:23.055943+0800 Demo[45564:3049580] 44442019-03-19 15:14:23.056329+0800 Demo[45564:3049532] end2019-03-19 15:14:23.056329+0800 Demo[45564:3049580] groupdispatch_group_wait 运行结果：dispatch_group_wait 会阻塞当前线程，当所有任务执行完成再继续向下执行。dispatch_group_enter、dispatch_group_leavedispatch_group_enter 标志着一个任务追加到 group，相当于 group 中未执行完毕任务数 +1dispatch_group_leave 标志着一个任务离开了 group，相当于 group 中未执行完毕任务数 -1。当 group 中未执行完毕任务数为 0 时，才会使 dispatch_group_wait 解除阻塞，并执行追加到 dispatch_group_notify 中的任务。123456789101112131415161718192021222324252627282930313233343536373839404142 dispatch_queue_t queue = dispatch_queue_create(\"com.dubinbin.Demo\", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create(); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@\"1111\"); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@\"2222\"); dispatch_group_leave(group); &#125;); dispatch_group_notify(group, queue, ^&#123; NSLog(@\"group\"); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:5]; NSLog(@\"3333\"); dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; NSLog(@\"4444\"); dispatch_group_leave(group); &#125;); dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@\"end\");2019-03-19 15:45:32.294390+0800 Demo[45813:3061727] 11112019-03-19 15:45:32.294399+0800 Demo[45813:3061725] 22222019-03-19 15:45:32.294411+0800 Demo[45813:3061728] 44442019-03-19 15:45:37.299935+0800 Demo[45813:3061726] 33332019-03-19 15:45:37.300306+0800 Demo[45813:3061728] group2019-03-19 15:45:37.300309+0800 Demo[45813:3061668] enddispatch_group_enter、dispatch_group_leave 运行结果：这里的 dispatch_group_enter、dispatch_group_leave 组合等同于 dispatch_group_async。当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。##### 3.4.6 GCD 信号量：dispatch_semaphoreGCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为 0 时等待；计数 ≥ 1 时不等待。Dispatch Semaphore 提供了三个函数。 dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量 dispatch_semaphore_signal：发送一个信号，让信号总量 +1 dispatch_semaphore_wait：使总信号量 -1，当信号总量为 0 时一直等待（阻塞所在线程），否则正常执行。注意：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后才能使用信号量。Dispatch Semaphore 在实际开发中主要用于： 保持线程同步，将异步执行任务转换为同步执行任务* 保证线程安全，为线程加锁Dispatch Semaphore 线程同步在开发中会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于将异步执行任务转换为同步执行任务。比如 AFNetworking 中 AFURLSessionManager.m 的 tasksForKeyPath: 方法，通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。123456789101112131415161718192021222324252627282930- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray * tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^( NSArray * dataTasks, NSArray * uploadTasks, NSArray * downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@\"@unionOfArrays.self\"]; &#125; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125;下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。Dispatch Semaphore 线程安全和线程同步（为线程加锁）线程安全 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步 可以理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 3.4.7 dispatch_set_target_queue12345/** * 参数 1 : 要执行变更的队列（不能指定主队列和全局队列） * 参数 2 : 目标队列（指定全局队列） */dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue); dispatch_set_target_queue 函数有两个作用：①、变更队列的执行优先级；②、目标队列可以成为原队列的执行阶层。 12345678910111213141516171819202122232425262728293031323334353637 // 串行队列，默认优先级 dispatch_queue_t serialQueue = dispatch_queue_create(\"com.gcd.setTargetQueue.serialQueue\", NULL); // 串行队列（参照），默认优先级 dispatch_queue_t serialDefaultQueue = dispatch_queue_create(\"com.gcd.setTargetQueue.serialDefaultQueue\", NULL); // 1. 变更前 dispatch_async(serialQueue, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(serialDefaultQueue, ^&#123; NSLog(@\"2\"); &#125;); // 全局队列，后台优先级 dispatch_queue_t globalDefaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0); // 2. 变更优先级 dispatch_set_target_queue(serialQueue, globalDefaultQueue); // 3. 变更后 dispatch_async(serialQueue, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(serialDefaultQueue, ^&#123; NSLog(@\"2\"); &#125;);-------------------- 1 -------------------- 2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 22019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 12019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 22019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1-------------------- 2 -------------------- 2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 12019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 22019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 22019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1 变更优先级前，serialQueue、serialDefaultQueue 打印随机；变更后，serialDefaultQueue 必定先于 serialQueue 打印。 123456789101112131415161718192021222324252627 dispatch_queue_t serialQueue1 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue1\", NULL); dispatch_queue_t serialQueue2 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue2\", NULL); dispatch_queue_t serialQueue3 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue3\", NULL); dispatch_queue_t serialQueue4 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue4\", NULL); dispatch_queue_t serialQueue5 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue5\", NULL); dispatch_async(serialQueue1, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(serialQueue2, ^&#123; NSLog(@\"2\"); &#125;); dispatch_async(serialQueue3, ^&#123; NSLog(@\"3\"); &#125;); dispatch_async(serialQueue4, ^&#123; NSLog(@\"4\"); &#125;); dispatch_async(serialQueue5, ^&#123; NSLog(@\"5\"); &#125;);2019-03-19 23:31:27.856574+0800 Demo[41983:2736476] 12019-03-19 23:31:27.856583+0800 Demo[41983:2736474] 42019-03-19 23:31:27.856585+0800 Demo[41983:2736475] 22019-03-19 23:31:27.856586+0800 Demo[41983:2736477] 52019-03-19 23:31:27.856586+0800 Demo[41983:2736493] 3 未设置目标队列前，异步执行任务不阻塞，所以打印随机。 123456789101112131415161718192021222324252627282930313233343536 dispatch_queue_t serialQueue1 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue1\", NULL); dispatch_queue_t serialQueue2 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue2\", NULL); dispatch_queue_t serialQueue3 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue3\", NULL); dispatch_queue_t serialQueue4 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue4\", NULL); dispatch_queue_t serialQueue5 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue5\", NULL); dispatch_queue_t targetSerialQueue = dispatch_queue_create(\"com.gcd.setTargetQueue2.targetSerialQueue\", NULL); //设置执行阶层 dispatch_set_target_queue(serialQueue1, targetSerialQueue); dispatch_set_target_queue(serialQueue3, targetSerialQueue); dispatch_set_target_queue(serialQueue2, targetSerialQueue); dispatch_set_target_queue(serialQueue4, targetSerialQueue); dispatch_set_target_queue(serialQueue5, targetSerialQueue); dispatch_async(serialQueue1, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(serialQueue2, ^&#123; NSLog(@\"2\"); &#125;); dispatch_async(serialQueue3, ^&#123; NSLog(@\"3\"); &#125;); dispatch_async(serialQueue4, ^&#123; NSLog(@\"4\"); &#125;); dispatch_async(serialQueue5, ^&#123; NSLog(@\"5\"); &#125;);2019-03-19 23:34:04.912115+0800 Demo[42048:2739515] 12019-03-19 23:34:04.912432+0800 Demo[42048:2739515] 22019-03-19 23:34:04.912573+0800 Demo[42048:2739515] 32019-03-19 23:34:04.912692+0800 Demo[42048:2739515] 42019-03-19 23:34:04.912874+0800 Demo[42048:2739515] 5 情况一：先设置目标队列，后添加任务，按顺序执行。 123456789101112131415161718192021222324252627282930313233343536 dispatch_queue_t serialQueue1 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue1\", NULL); dispatch_queue_t serialQueue2 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue2\", NULL); dispatch_queue_t serialQueue3 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue3\", NULL); dispatch_queue_t serialQueue4 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue4\", NULL); dispatch_queue_t serialQueue5 = dispatch_queue_create(\"com.gcd.setTargetQueue2.serialQueue5\", NULL); dispatch_async(serialQueue1, ^&#123; NSLog(@\"1\"); &#125;); dispatch_async(serialQueue2, ^&#123; NSLog(@\"2\"); &#125;); dispatch_async(serialQueue3, ^&#123; NSLog(@\"3\"); &#125;); dispatch_async(serialQueue4, ^&#123; NSLog(@\"4\"); &#125;); dispatch_async(serialQueue5, ^&#123; NSLog(@\"5\"); &#125;); dispatch_queue_t targetSerialQueue = dispatch_queue_create(\"com.gcd.setTargetQueue2.targetSerialQueue\", NULL); //设置执行阶层 dispatch_set_target_queue(serialQueue1, targetSerialQueue); dispatch_set_target_queue(serialQueue2, targetSerialQueue); dispatch_set_target_queue(serialQueue3, targetSerialQueue); dispatch_set_target_queue(serialQueue4, targetSerialQueue); dispatch_set_target_queue(serialQueue5, targetSerialQueue);2019-03-19 23:36:07.791578+0800 Demo[42077:2741664] 12019-03-19 23:36:07.791620+0800 Demo[42077:2741665] 42019-03-19 23:36:07.791578+0800 Demo[42077:2741663] 32019-03-19 23:36:07.791578+0800 Demo[42077:2741666] 22019-03-19 23:36:07.791635+0800 Demo[42077:2741693] 5 情况二：先添加任务，后设置目标队列，乱序输出。 在必须将不可并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。 四、文章iOS多线程：『GCD』详尽总结iOS GCD之dispatch_semaphore（信号量）iOS多线程：『pthread、NSThread』详尽总结iOS多线程：『NSOperation』详尽总结iOS多线程：『RunLoop』详尽总结","tags":[]},{"title":"GCD深入","date":"2019-09-16T01:18:32.128Z","path":"2019/09/16/iOS/iOS多线程/GCD深入/","text":"一、知识储备阅读 GCD 源码之前，需要了解一些相关知识。 1.1 DISPATCH_DECLGCD 中对变量的定义大多遵循如下格式: 1#define DISPATCH_DECL(name) typedef struct name##_s *name##_t 如 DISPATCH_DECL(dispatch_queue); 的展开形式是：typedef struct dispatch_queue_s *dispatch_queue_t; 这行代码定义了一个 dispatch_queue_t 类型的指针，指向一个 dispatch_queue_s 类型的结构体。 1.2 TSDTSD（Thread-Specific Data）表示线程私有数据。在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。在不同线程中，虽然名字相同，但是获取到的数据随线程不同而不同。通常我们可以利用 POSIX 库提供的 API 来实现 TSD： 1int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *)) 此函数用来创建一个 key，在线程退出时会将 key 对应的数据传入 destr_function 函数中进行清理。我们分别使用 get/set 方法来访问/修改 key 对应的数据： 123int pthread_setspecific(pthread_key_t key, const void *pointer) void * pthread_getspecific(pthread_key_t key) 在 GCD 中定义了六个 key，根据名字大概能猜出各自的含义： 123456pthread_key_t dispatch_queue_key; pthread_key_t dispatch_sema4_key; pthread_key_t dispatch_cache_key; pthread_key_t dispatch_io_key; pthread_key_t dispatch_apply_key; pthread_key_t dispatch_bcounter_key; 1.3 fastpath &amp;&amp; slowpath这是定义在 internal.h 中的两个宏： 12#define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))#define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l)) 为了理解所谓的快路径和慢路径，需要先学习一点计算机基础知识。比如这段非常简单的代码： 1234if (x) return 1;else return 39; 由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是： 1234if (!x) return 39;else return 1; 然而对程序员来说，每次都做这样的判断非常烧脑，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect： 1long __builtin_expect (long EXP, long C) 它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写： 1234if (__builtin_expect(x, 0)) return 1;else return 39; 虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。 二、dispatch_queue_t以 dispatch_queue_create 的源码为例： 123456789101112131415161718192021dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123; // 省略 label 相关的操作 dispatch_queue_t dq; dq = _dispatch_alloc(DISPATCH_VTABLE(queue), sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE - DISPATCH_QUEUE_CACHELINE_PAD + label_len + 1); _dispatch_queue_init(dq); if (fastpath(!attr)) &#123; return dq; &#125; if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123; dq-&gt;dq_width = UINT32_MAX; dq-&gt;do_targetq = _dispatch_get_root_queue(0, false); &#125; else &#123; dispatch_debug_assert(!attr, \"Invalid attribute\"); &#125; return dq;&#125; 我们知道创建队列时， attr 属性有三个值可选，nil、DISPATCH_QUEUE_SERIAL（实际上就是 nil）或 DISPATCH_QUEUE_CONCURRENT。 第一个 if 判断中，苹果认为串行队列或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。 第二个判断中，参数几乎只可能是 DISPATCH_QUEUE_CONCURRENT，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断几乎不会为 0，依然与 fastpath 的作用一致。 _dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载（overcommit）。这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务（比如下文介绍的定时器），3 这个序列号暂时没有使用。队列 的 dq_width 被设置为 UINT32_MAX，表示这些队列不限制并发数。作为对比，在 _dispatch_queue_init 中，并发数限制为 1，也就是串行队列的默认设置： 123456static inline void _dispatch_queue_init(dispatch_queue_t dq) &#123; dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS; dq-&gt;do_targetq = _dispatch_get_root_queue(0, true); dq-&gt;dq_running = 0; dq-&gt;dq_width = 1;&#125; 注意这行代码：dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);，它涉及到 GCD 队列与 block 的一个重要模型，target_queue。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。借用 objc 的文章 中的图片来表示： 二、dispatch_async直接上函数实现： 123dispatch_async(dispatch_queue_t queue, dispatch_block_t block) &#123; dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release); &#125; 队列其实就是一个用来提交 block 的对象，当 block 提交到队列中后，将按照 “先入先出（FIFO）” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。block 参数的类型是 dispatch_block_t，它是一个没有参数，没有返回值的 block： 1typedef void (^dispatch_block_t)(void); dispatch_async 的函数很简单，它将 block 复制了一份，然后调用另一个函数 dispatch_async_f： 1dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work); work 参数是一个函数，在实际调用时，会把第二参数 context 作为参数传入，以 _dispatch_call_block_and_release 为例： 12345void _dispatch_call_block_and_release(void *block) &#123; void (^b)(void) = block; b(); Block_release(b);&#125; 省略各种分支后的 dispatch_async_f 函数实现如下： 12345678910111213void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123; dispatch_continuation_t dc; if (dq-&gt;dq_width == 1) &#123; return dispatch_barrier_async_f(dq, ctxt, func); &#125; dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT; dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; if (dq-&gt;do_targetq) &#123; return _dispatch_async_f2(dq, dc); &#125; _dispatch_queue_push(dq, dc);&#125; 可见如果是串行队列（dq_width = 1），会调用 dispatch_barrier_async_f 函数处理。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。这里的 dispatch_continuation_t 其实是对 block 的封装，然后调用 _dispatch_queue_push 这个宏将封装好的 block 放入队列中。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下: 1234567_dispatch_queue_push └──_dispatch_trace_queue_push └──_dispatch_queue_push └──_dispatch_queue_push_slow └──_dispatch_queue_push_list_slow2 └──_dispatch_wakeup └──dx_probe 队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法，调用栈如下 123_dispatch_queue_wakeup_global └──_dispatch_queue_wakeup_global2 └──_dispatch_queue_wakeup_global_slow 在 _dispatch_queue_wakeup_global_slow 我们见到了熟悉的老朋友 pthread 线程： 1234567891011121314static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) &#123; // 如果线程池已满，则直接调用 _dispatch_worker_thread // 否则创建线程池 pthread_t pthr; while ((r = pthread_create(&amp;pthr, NULL, _dispatch_worker_thread, dq))) &#123; if (r != EAGAIN) &#123; (void)dispatch_assume_zero(r); &#125; sleep(1); &#125; r = pthread_detach(pthr); (void)dispatch_assume_zero(r);&#125; 由此可见这里确实使用了线程池。创建线程后会执行 _dispatch_worker_thread 回调: 123_dispatch_worker_thread └──_dispatch_worker_thread4 └──_dispatch_continuation_pop 在 pop 函数中，我们拿到了最早加入的任务，然后执行： 12345678static inline void _dispatch_continuation_pop(dispatch_object_t dou) &#123; // ... _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func); if (dg) &#123; dispatch_group_leave(dg); _dispatch_release(dg); &#125; &#125; dispatch_async 的实现比较复杂，主要是因为其中的数据结构较多，分支流程控制比较复杂。但思路其实很简单，用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。如果熟悉了相关数据结构和调用流程，接下来研究 GCD 的其他 API 就比较轻松了。 三、dispatch_sync同步方法的实现相对来说和异步类似，而且更简单，调用栈如下: 1234dispatch_sync └──dispatch_sync_f └──_dispatch_sync_f2 └──_dispatch_sync_f_slow 1234567891011121314static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123; _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore(); struct dispatch_sync_slow_s &#123; DISPATCH_CONTINUATION_HEADER(sync_slow); &#125; dss = &#123; .do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT, .dc_ctxt = (void*)sema, &#125;; _dispatch_queue_push(dq, (void *)&amp;dss); _dispatch_thread_semaphore_wait(sema); _dispatch_put_thread_semaphore(sema); // ...&#125; 这里利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。 四、dispatch_semaphore关于信号量的 API 不多，主要是三个：create、wait 和 signal。信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value，一个是当前的 value，一个是记录初始 value。信号的 wait 和 signal 是互逆的两个操作。如果 value &gt; 0，前者将 value - 1，此时如果 value &lt; 0 就一直等待。初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。 4.1 dispatch_semaphore_wait首先从源码看起： 12345678long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123; long value = dispatch_atomic_dec2o(dsema, dsema_value); dispatch_atomic_acquire_barrier(); if (fastpath(value &gt;= 0)) &#123; return 0; &#125; return _dispatch_semaphore_wait_slow(dsema, timeout);&#125; 第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将 dsema 的值减 1，并把新的值赋给 value。如果减一后的 value ≥ 0 就立刻返回，没有任何操作，否则进入等待状态。_dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑： 123456case DISPATCH_TIME_NOW: while ((orig = dsema-&gt;dsema_value) &lt; 0) &#123; if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) &#123; return KERN_OPERATION_TIMED_OUT; &#125; &#125; 这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value + 1（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。实际上 while 判断一定会成立，因为如果 value 大于等于 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。 第二种情况是 DISPATCH_TIME_FOREVER 这个 case： 12345case DISPATCH_TIME_FOREVER: do &#123; kr = semaphore_wait(dsema-&gt;dsema_port); &#125; while (kr == KERN_ABORTED); break; 进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。整个函数的框架如下： 123456789101112131415static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123; again: while ((orig = dsema-&gt;dsema_sent_ksignals)) &#123; if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig, orig - 1)) &#123; return 0; &#125; &#125; switch (timeout) &#123; default: /* semaphore_timedwait */ case DISPATCH_TIME_NOW: /* KERN_OPERATION_TIMED_OUT */ case DISPATCH_TIME_FOREVER: /* semaphore_wait */ &#125; goto again;&#125; 可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。 4.2 dispatch_semaphore_signal这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下： 1234567long dispatch_semaphore_signal(dispatch_semaphore_t dsema) &#123; long value = dispatch_atomic_inc2o(dsema, dsema_value); if (fastpath(value &gt; 0)) &#123; return 0; &#125; return _dispatch_semaphore_signal_slow(dsema);&#125; 首先会调用原子方法让 value + 1，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow： 123456long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) &#123; (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals); _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port); kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port); return 1;&#125; 它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：“如果唤醒了线程，返回非 0，否则返回 0”。 五、dispatch_group有了上面的铺垫，group 是一个非常容易理解的概念，我们先看看如何创建 group： 12345dispatch_group_t dispatch_group_create(void) &#123; dispatch_group_t dg = _dispatch_alloc(DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s)); _dispatch_semaphore_init(LONG_MAX, dg); return dg;&#125; 没错，group 就是一个 value 为 LONG_MAX 的信号量。 5.1 dispatch_group_async它仅仅是 dispatch_group_async_f 的封装： 1234567891011void dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123; dispatch_continuation_t dc; dispatch_group_enter(dg); dc = _dispatch_continuation_alloc(); dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT); dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; dc-&gt;dc_data = dg; _dispatch_queue_push(dq, dc);&#125; 这个函数和 dispatch_async_f 的实现高度一致，主要的不同在于调用了 dispatch_group_enter 方法： 1234void dispatch_group_enter(dispatch_group_t dg) &#123; dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; (void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);&#125; 这个方法也没做什么，就是调用 wait 方法让信号量的 value 减一而已。 5.2 dispatch_group_wait这个方法用于等待 group 中所有任务执行完成，可以理解为信号量 wait 的封装： 12345678910long dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout) &#123; dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123; return 0; &#125; if (timeout == 0) &#123; return KERN_OPERATION_TIMED_OUT; &#125; return _dispatch_group_wait_slow(dsema, timeout);&#125; 如果当前 value 和原始 value 相同，表明任务已经全部完成，直接返回 0，如果 timeout 为 0 也会立刻返回，否则调用 _dispatch_group_wait_slow。这个方法的等待部分和 _dispatch_semaphore_signal_slow 几乎一致，区别在于等待结束后它不是 return，而是调用 _dispatch_group_wake 去唤醒这个 group。 123456static long _dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123; again: _dispatch_group_wake(dsema); switch (timeout) &#123;/* 三种情况分类 */&#125; goto again;&#125; 这里我们暂时跳过 _dispatch_group_wake，后面会有详细分析。只要知道这个函数在 group 中所有事件执行完后会被调用即可。 5.3 dispatch_group_notify这个函数仅仅是封装了 dispatch_group_notify_f： 123456789101112void dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, void (*func)(void *)) &#123; dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; struct dispatch_sema_notify_s *dsn, *prev; dsn-&gt;dsn_queue = dq; dsn-&gt;dsn_ctxt = ctxt; dsn-&gt;dsn_func = func; prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn); if (fastpath(prev)) &#123; prev-&gt;dsn_next = dsn; &#125; else &#123;/* ... */&#125;&#125; 这种结构的代码已经遇到多次了，它其实就是在链表的尾部续上新的元素。所以 notify 方法并没有做过多的处理，只是用链表把所有回调通知保存起来，等待调用。 5.4 dispatch_group_leave在介绍 dispatch_async 函数时，我们看到任务在被执行时，还会调用 dispatch_group_leave 函数： 1234567void dispatch_group_leave(dispatch_group_t dg) &#123; dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; long value = dispatch_atomic_inc2o(dsema, dsema_value); if (slowpath(value == dsema-&gt;dsema_orig)) &#123; (void)_dispatch_group_wake(dsema); &#125;&#125; 当 group 的 value 变为初始值时，表示所有任务都已执行完，开始调用 _dispatch_group_wake 处理回调。 5.5 dispatch_group_wake123456789101112131415161718192021222324252627282930static long _dispatch_group_wake(dispatch_semaphore_t dsema) &#123; struct dispatch_sema_notify_s *next, *head, *tail = NULL; long rval; head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL); if (head) &#123; tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, NULL); &#125; rval = dispatch_atomic_xchg2o(dsema, dsema_group_waiters, 0); if (rval) &#123; _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port); do &#123; kern_return_t kr = semaphore_signal(dsema-&gt;dsema_waiter_port); &#125; while (--rval); &#125; if (head) &#123; // async group notify blocks do &#123; dispatch_async_f(head-&gt;dsn_queue, head-&gt;dsn_ctxt, head-&gt;dsn_func); next = fastpath(head-&gt;dsn_next); if (!next &amp;&amp; head != tail) &#123; while (!(next = fastpath(head-&gt;dsn_next))) &#123; _dispatch_hardware_pause(); &#125; &#125; free(head); &#125; while ((head = next)); &#125; return 0;&#125; 这个函数主要分为两部分，首先循环调用 semaphore_signal 告知唤醒当初等待 group 的信号量，因此 dispatch_group_wait 函数得以返回。然后获取链表，依次调用 dispatch_async_f 异步执行在 notify 函数中注册的回调。 六、dispatch_oncedispatch_once 仅仅是一个包装，内部直接调用了 dispatch_once_f： 12345678910111213141516171819202122232425262728293031323334void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) &#123; struct _dispatch_once_waiter_s * volatile *vval = (struct _dispatch_once_waiter_s**)val; struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;; struct _dispatch_once_waiter_s *tail, *tmp; _dispatch_thread_semaphore_t sema; if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow)) &#123; _dispatch_client_callout(ctxt, func); tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE); tail = &amp;dow; while (tail != tmp) &#123; while (!tmp-&gt;dow_next) &#123; _dispatch_hardware_pause(); &#125; sema = tmp-&gt;dow_sema; tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next; _dispatch_thread_semaphore_signal(sema); &#125; &#125; else &#123; dow.dow_sema = _dispatch_get_thread_semaphore(); for (;;) &#123; tmp = *vval; if (tmp == DISPATCH_ONCE_DONE) &#123; break; &#125; dispatch_atomic_store_barrier(); if (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123; dow.dow_next = tmp; _dispatch_thread_semaphore_wait(dow.dow_sema); &#125; &#125; _dispatch_put_thread_semaphore(dow.dow_sema); &#125;&#125; 这段代码比较长，我们考虑三个场景： 第一次调用：此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。 首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。 同一线程第二次调用：由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。 由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。 多个线程同时调用：由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。 由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。 七、dispatch_barrier_async它调用了 dispatch_barrier_async_f 函数，实现原理也和 dispatch_async_f 类似： 12345678void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123; dispatch_continuation_t dc; dc = fastpath(_dispatch_continuation_alloc_cacheonly()); dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT); dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; _dispatch_queue_push(dq, dc);&#125; 区别在于 do_vtable 被设置了两个标志位，多了一个 DISPATCH_OBJ_BARRIER_BIT 标记。这个标记在从队列中取出任务时被用到： 12345678910111213141516static _dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_queue_t dq) &#123; while (dq-&gt;dq_items_tail) &#123; /* ... */ if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp; (long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123; if (dq-&gt;dq_running &gt; 1) &#123; goto out; &#125; &#125; else &#123; _dispatch_continuation_redirect(dq, dc); continue; &#125; &#125;out: /* 不完整的 drain，需要清理现场 */ return sema; // 返回空的信号量&#125; 这里原来是一个循环，会拿出所有的任务，依次调用 _dispatch_continuation_redirect，最终并行处理。一旦遇到 DISPATCH_OBJ_BARRIER_BIT 这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行： 12345678void _dispatch_queue_invoke(dispatch_queue_t dq) &#123; _dispatch_thread_semaphore_t sema = _dispatch_queue_drain(dq); if (sema) &#123; _dispatch_thread_semaphore_signal(sema); &#125; else if (tq) &#123; return _dispatch_queue_push(tq, dq); &#125;&#125; 因此 barrier 方法能等待此前所有任务执行完以后执行 _dispatch_queue_push，同时保证自己执行完以后才执行后续的操作。 八、dispatch_sourcesource 是一种资源，类似于生产者/消费者模式中的生产者，而队列则是消费者。当有新的资源（source）产生时，它们被放到对应的队列上被执行（消费）。dispatch_source 最常见的用途之一就是用来实现定时器，举一个小例子： 123456789dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 每 10 秒触发 timer，误差 1 秒dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 10*NSEC_PER_SEC, 1*NSEC_PER_SEC);dispatch_source_set_event_handler(timer, ^&#123; // 定时器触发时执行的 block&#125;);dispatch_resume(timer); 使用 GCD Timer 的好处在于不依赖 runloop，因此任何线程都可以使用。由于使用了 block，不会忘记避免循环引用。此外，定时器可以自由控制精度，随时修改间隔时间等。 8.1 dispatch_source_create下面从底层源码的角度来研究这几行代码的作用。首先是 dispatch_source_create 函数，它和之前见到的 create 函数都差不多，对 dispatch_source_t 对象做了一些初始化工作： 1234567dispatch_source_t ds = NULL; ds = _dispatch_alloc(DISPATCH_VTABLE(source), sizeof(struct dispatch_source_s)); _dispatch_queue_init((dispatch_queue_t)ds); ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL; ds-&gt;do_targetq = &amp;_dispatch_mgr_q; dispatch_set_target_queue(ds, q); return ds; 这里涉及到两个队列，其中 q 是用户指定的队列，表示事件触发的回调在哪个队列执行。而 _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写，也是上文提到的序列号为 2 的内部队列。 8.2 dispatch_source_set_timer在这个函数中，首先会有参数处理，过滤掉不符合要求的参数。随后创建了 dispatch_set_timer_params 类型的指针 params： 12345struct dispatch_set_timer_params &#123; dispatch_source_t ds; uintptr_t ident; struct dispatch_timer_source_s values;&#125;; 这个 params 负责绑定定时器对象与它的参数（存储在 values 属性中），最后调用： 1dispatch_barrier_async_f((dispatch_queue_t)ds, params, _dispatch_source_set_timer2); 这里是把 source 当做队列来使用，因此实际上是调用了 _dispatch_source_set_timer2(params) 方法： 1234567static void _dispatch_source_set_timer2(void *context) &#123; // Called on the source queue struct dispatch_set_timer_params *params = context; dispatch_suspend(params-&gt;ds); dispatch_barrier_async_f(&amp;_dispatch_mgr_q, params, _dispatch_source_set_timer3);&#125; 这里首先暂停了队列，避免了修改的过程中定时器被触发。然后在 manager 队列上执行 _dispatch_source_set_timer3(params)： 1234567static void _dispatch_source_set_timer3(void *context) &#123; struct dispatch_set_timer_params *params = context; dispatch_source_t ds = params-&gt;ds; // ... _dispatch_timer_list_update(ds); dispatch_resume(ds);&#125; _dispatch_timer_list_update 函数的作用是根据下一次触发时间将 timer 排序。接下来，当初分发到 manager 队列的 block 将要被执行，走到 _dispatch_mgr_invoke 函数，其中有如下代码： 12timeoutp = _dispatch_get_next_timer_fire(&amp;timeout); r = select(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, NULL, sel_timeoutp); 可见 GCD 的定时器是由系统的 select 方法实现的。当内层的 manager 队列被唤醒后，还会进一步唤醒外层的队列（当初用户指定的那个），并在队列上执行 timer 触发时的 block。 九、dispatch_resume/suspendGCD 对象的暂停和恢复由 do_suspend_cnt 决定，暂停时通过原子操作将该属性的值加 2，对应的在恢复时通过原子操作将该属性减 2。它有两个默认值： 12#define DISPATCH_OBJECT_SUSPEND_LOCK 1u#define DISPATCH_OBJECT_SUSPEND_INTERVAL 2u 在唤醒队列时有如下代码： 1234567void _dispatch_queue_invoke(dispatch_queue_t dq) &#123; if (!dispatch_atomic_sub2o(dq, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123; if (dq-&gt;dq_running == 0) &#123; _dispatch_wakeup(dq); // verify that the queue is idle &#125; &#125;&#125; 可见能够唤醒队列的前提是 dq-&gt;do_suspend_cnt - 1 = 0，也就是要求 do_suspend_cnt 的值就是 DISPATCH_OBJECT_SUSPEND_LOCK。观察 8 个全局队列和主队列的定义就会发现，他们的 do_suspend_cnt 值确实为 DISPATCH_OBJECT_SUSPEND_LOCK，因此默认处于启动状态。而 dispatch_source 的 create 方法中，do_suspend_cnt 的初始值为 DISPATCH_OBJECT_SUSPEND_INTERVAL，因此默认处于暂停状态，需要手动开启。 十、dispatch_afterdispatch_after 其实依赖于定时器的实现，函数内部调用了 dispatch_after_f： 12345678910111213141516171819202122232425void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *ctxt, dispatch_function_t func) &#123; uint64_t delta; struct _dispatch_after_time_s *datc = NULL; dispatch_source_t ds; // 如果延迟为 0，直接调用 dispatch_async delta = _dispatch_timeout(when); if (delta == 0) &#123; return dispatch_async_f(queue, ctxt, func); &#125; ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_assert(ds); datc = malloc(sizeof(*datc)); dispatch_assert(datc); datc-&gt;datc_ctxt = ctxt; datc-&gt;datc_func = func; datc-&gt;ds = ds; dispatch_set_context(ds, datc); dispatch_source_set_event_handler_f(ds, _dispatch_after_timer_callback); dispatch_source_set_timer(ds, when, DISPATCH_TIME_FOREVER, 0); dispatch_resume(ds);&#125; 首先将延迟执行的 block 封装在 _dispatch_after_time_s 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。到时以后，执行 _dispatch_after_timer_callback 回调，并取出上下文中的 block： 12345static void _dispatch_after_timer_callback(void *ctxt) &#123; struct _dispatch_after_time_s *datc = ctxt; _dispatch_client_callout(datc-&gt;datc_ctxt, datc-&gt;datc_func); // 清理工作&#125; 十一、总结本文主要整理了 GCD 中常见的 API 以及底层的实现原理。 对于队列来说，需要理解它的数据结构，转发机制，以及底层的线程池模型。 dispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。在 wakeup 方法中，从线程池里取出工作线程（如果没有就新建），然后在工作线程中取出链表头部指向的 block 并执行。 dispatch_sync 的实现略简单一些，它不涉及线程池（因此一般都在当前线程执行），而是利用与线程绑定的信号量来实现串行。分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性（表示在运行的任务数量）为 1，所以以下判断成立： 123if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) &#123; return _dispatch_barrier_sync_f_slow(dq, ctxt, func);&#125; 在 \\_dispatch\\_barrier\\_sync\\_f\\_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。如果向其它队列同步提交 block，最终进入 \\_dispatch\\_barrier\\_sync\\_f\\_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。 对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。在调用 signal 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。 dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。 dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。 dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。 dispatch_source 可以用来实现定时器。所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。随后找到最近触发的定时器，调用内核的 select 方法等待。等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。 GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。 dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。 十二、文章深入理解 GCDGCD 源码Why do we use _builtinexpect when a straightforward way is to use if-elsePosix线程编程指南(2) 线程私有数据选择 GCD 还是 NSTimer？从NSTimer的失效性谈起（二）：关于GCD Timer和libdispatch变态的libDispatch源码分析","tags":[]},{"title":"NSProxy","date":"2019-09-16T01:18:32.127Z","path":"2019/09/16/iOS/iOS原理/NSProxy/","text":"NSProxy 是一个实现了 NSObject 协议类似于 NSObject 的根类。 1234NS_ROOT_CLASS@interface NSProxy &lt;NSObject&gt;&#123; Class isa;&#125; 苹果的官方文档： Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information. 看了这些描述我们应该能对 NSProxy 有个初步印象，它仅仅是个转发消息的场所，至于如何转发，取决于派生类的具体实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了。甚至也可以不去创建这些对象，去做任何你想做的事情，但是必须要实现它的 forwardInvocation: 和 methodSignatureForSelector: 方法。 一、用途1.1 多继承大致过程就是让它持有要实现多继承的类的对象，然后用多个接口定义不同的行为，并让 Proxy 去实现这些接口，然后在转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。注意：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用 NSObject 类来实现。 NSObject 寻找方法顺序：本类 -> 父类 -> 动态方法解析 -> 备用对象 -> 消息转发； NSproxy 寻找方法顺序：本类-> 消息转发； 同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间。 首先新建两个基类如下： 12345678910111213@implementation classA-(void)infoA&#123; NSLog(@\"classA 卖水\"); &#125;@end@implementation classB-(void)infoB&#123; NSLog(@\"classB 卖饭\");&#125;@end 代理如下： 12345678@interface ClassProxy : NSProxy@property(nonatomic, strong, readonly) NSMutableArray * targetArray;-(void)target:(id)target;-(void)handleTargets:(NSArray *)targets;@end NSProxy 必须以子类的形式出现。 因为考虑到很可能还有其他的卖衣服的、卖鞋子的需要 ClassProxy 来代理，这边做了一个数组来存放需要代理的类。 12345@interface ClassProxy()@property (nonatomic, strong) NSMutableArray * targetArray; // 多个 targets 皆可代理@property (nonatomic, strong) NSMutableDictionary * methodDic;@property (nonatomic, strong) id target;@end 然后 target 和相对应的 method name 做了一个字典来存储，方便获取。 12345678910111213141516-(void)registMethodWithTarget:(id)target&#123; unsigned int countOfMethods = 0; Method *method_list = class_copyMethodList([target class], &amp;countOfMethods); for (int i = 0; i&lt;countOfMethods; i++) &#123; Method method = method_list[i]; //得到方法的符号 SEL sel = method_getName(method); //得到方法的符号字符串 const char *sel_name = sel_getName(sel); //得到方法的名字 NSString * method_name = [NSString stringWithUTF8String:sel_name]; self.methodDic[method_name] = target; &#125; free(method_list);&#125; 然后就是最主要的两个方法 1234567891011121314151617181920212223-(void)forwardInvocation:(NSInvocation *)invocation&#123; SEL sel = invocation.selector; NSString *methodName = NSStringFromSelector(sel); id target = self.methodDic[methodName]; if (target) &#123; [invocation invokeWithTarget:target]; &#125; &#125;-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; NSMethodSignature *Method; NSString *methodName = NSStringFromSelector(sel); id target = self.methodDic[methodName]; if (target) &#123; Method = [target methodSignatureForSelector:sel]; &#125; else&#123; Method = [super methodSignatureForSelector:sel]; &#125; return Method;&#125; methodSignatureForSelector: 得到对应的方法签名，通过 forwardInvocation: 转发。 调用和打印结果： 1234567891011121314151617181920212223- (void)viewDidLoad&#123; [super viewDidLoad]; [self classInheritance];&#125;/** * 多继承 */-(void)classInheritance&#123; classA * A = [[classA alloc]init]; classB * B = [[classB alloc]init]; ClassProxy * proxy = [ClassProxy alloc]; [proxy handleTargets:@[A, B]]; [proxy performSelector:@selector(infoA)]; [proxy performSelector:@selector(infoB)];&#125;2018-12-27 18:02:34.445 NSProxyStudy[18975:4587631] classA 卖水2018-12-27 18:02:34.446 NSProxyStudy[18975:4587631] classB 卖饭 以上就是利用 NSProxy 实现多继承。 1.2 避免循环应用举一个比较常见的例子 NSTimer。 由于苹果在 iOS10 以上给出了 timer 的 block 方式，已经可以解决循环引用的问题。所以这里只是说明利用 NSProxy 如何解决循环引用，实际情况可直接使用系统的方法。 首先因为 NSTimer 创建的时候需要传入一个 target，并且持有它，而 target 本身也会持有 timer 所以会造成循环引用。所以我们将 target 用 NSProxy 的子类代替。如下： 123456789101112131415-(void)viewDidLoad&#123; [super viewDidLoad]; self.timer = [NSTimer timerWithTimeInterval:1 target:[WeakProxy proxyWithTarget:self] selector:@selector(invoked:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;- (void)invoked:(NSTimer *)timer&#123; NSLog(@\"1\");&#125; 在 WeakProxy 中我们设定 target 为弱引用。 12345678910111213141516171819202122232425262728@interface WeakProxy ()@property (nonatomic, weak) id target;@end@implementation WeakProxy+(instancetype)proxyWithTarget:(id)target&#123; return [[self alloc] initWithTarget:target];&#125;-(instancetype)initWithTarget:(id)target&#123; self.target = target; return self;&#125;-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; return [self.target methodSignatureForSelector:sel];&#125;-(void)forwardInvocation:(NSInvocation *)invocation&#123; SEL sel = invocation.selector; if ([self.target respondsToSelector:sel]) &#123; [invocation invokeWithTarget:self.target]; &#125;&#125;@end 然后同样利用上述两个方法进行消息转发即可。 1.3 AOP要重点介绍的功能就是 AOP（Aspect Oriented Programming），它是可以通过预编译方式和运行时动态代理实现在不修改源代码的情况下给程序动态添加功能的一种技术。 iOS 中面向切片编程一般有两种方式 ，一种是直接基于 runtime 的 method-Swizzling 机制来实现方法替换从而达到 hook 的目的，另一种就是基于 NSProxy。 OC 的动态语言的核心部分应该就是 objc_msgSend 方法的调用了。该函数的声明大致如下： 1234567/** * 参数 1：接受消息的 target * 参数 2：要执行的 selector * 参数 3：要调用的方法 * 可变参数：若干个要传给 selector 的参数 */id objc_msgSend(id self, SEL _cmd, ...) 只要我们能够 Hook 到对某个对象的 objc_msgSend 的调用，并且可以修改其参数甚至于修改成任意其他 selector 的 IMP，我们就实现了 AOP。 123456789@interface MyProxy : NSProxy &#123; id _innerObject; // 在内部持有要 hook 的对象&#125;+(instancetype)proxyWithObj:(id)object;@end@interface Dog : NSObject-(NSString *)barking:(NSInteger)months;@end 实现部分： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@implementation MyProxy+(instancetype)proxyWithObj:(id)object&#123; MyProxy * proxy = [MyProxy alloc]; // 持有要 hook 的对象 proxy-&gt;_innerObject = object; // 注意返回的值是 Proxy 对象 return proxy;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; // 这里可以返回任何 NSMethodSignature 对象，也可以完全自己构造一个 return [_innerObject methodSignatureForSelector:sel];&#125;- (void)forwardInvocation:(NSInvocation *)invocation&#123; if([_innerObject respondsToSelector:invocation.selector])&#123; NSString *selectorName = NSStringFromSelector(invocation.selector); NSLog(@\"Before calling %@\",selectorName); [invocation retainArguments]; NSMethodSignature *sig = [invocation methodSignature]; // 获取参数个数，注意在本例里这里的值是 3，因为 objc_msgSend 隐含了 self、selector 参数 NSUInteger cnt = [sig numberOfArguments]; // 本例只是简单的将参数和返回值打印出来 for (int i = 0; i &lt; cnt; i++) &#123; // 参数类型 const char * type = [sig getArgumentTypeAtIndex:i]; if(strcmp(type, \"@\") == 0)&#123; NSObject *obj; [invocation getArgument:&amp;obj atIndex:i]; // 这里输出的是：\"parameter (0)'class is MyProxy\"，也证明了这是 objc_msgSend 的第一个参数 NSLog(@\"parameter (%d)'class is %@\", i, [obj class]); &#125; else if(strcmp(type, \":\") == 0)&#123; SEL sel; [invocation getArgument:&amp;sel atIndex:i]; // 这里输出的是:\"parameter (1) is barking:\"，也就是 objc_msgSend 的第二个参数 NSLog(@\"parameter (%d) is %@\", i, NSStringFromSelector(sel)); &#125; else if(strcmp(type, \"q\") == 0)&#123; int arg = 0; [invocation getArgument:&amp;arg atIndex:i]; // 这里输出的是:\"parameter (2) is int value is 4\"，稍后会看到我们在调用 barking 的时候传递的参数就是 4 NSLog(@\"parameter (%d) is int value is %d\", i, arg); &#125; &#125; // 消息转发 [invocation invokeWithTarget:_innerObject]; const char *retType = [sig methodReturnType]; if(strcmp(retType, \"@\") == 0)&#123; NSObject *ret; [invocation getReturnValue:&amp;ret]; //这里输出的是:\"return value is wang wang!\" NSLog(@\"return value is %@\", ret); &#125; NSLog(@\"After calling %@\", selectorName); &#125;&#125;@end@implementation Dog-(NSString *)barking:(NSInteger)months&#123; return months &gt; 3 ? @\"wang wang!\" : @\"eng eng!\";&#125;@end 函数的调用如下： 12Dog * dog = [MyProxy proxyWithObj:[Dog alloc]];[dog barking:4]; 上面的代码中，可以任意更改参数、调用的方法，甚至转发给其他类型的对象，这确实达到了 Hook 对象的目的，也就是可以实现 AOP 的功能了。 12345678typedef void(^proxyBlock)(id target,SEL selector);NS_ASSUME_NONNULL_BEGIN@interface AOPProxy : NSProxy+(instancetype)proxyWithTarget:(id)target;-(void)inspectSelector:(SEL)selector preSelTask:(proxyBlock)preTask endSelTask:(proxyBlock)endTask;@end 12345@interface AOPProxy ()@property (nonatomic, strong) id target;@property (nonatomic, strong) NSMutableDictionary * preSelTaskDic;@property (nonatomic, strong) NSMutableDictionary * endSelTaskDic;@end 1234567891011121314151617-(void)inspect&#123; NSMutableArray * targtArray = [AOPProxy proxyWithTarget:[NSMutableArray arrayWithCapacity:1]]; [(AOPProxy *)targtArray inspectSelector:@selector(addObject:) preSelTask:^(id target, SEL selector) &#123; [target addObject:@\"-------\"]; NSLog(@\"%@ 我加进来之前\", target); &#125; endSelTask:^(id target, SEL selector) &#123; [target addObject:@\"-------\"]; NSLog(@\"%@ 我加进来之后\", target); &#125;]; [targtArray addObject:@\"我是一个元素\"];&#125;( \"-------\" ) 我加进来之前( \"-------\", \"\\U6211\\U662f\\U4e00\\U4e2a\\U5143\\U7d20\", \"-------\" ) 我加进来之后 1.4 实现延迟初始化（Lazy Initialization）使用场景： 在 [SomeClass lazy] 之后调用 doSomthing，首先进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用 init 初始化对象，然后将消息转发给代理对象 _object； 在 [SomeClass lazy] 之后调用 initWithXXX:，首先进入 forwardingTargetForSelector 返回 nil，然后进入 methodSignatureForSelector: 和 forwardInvocation: 保存自定义初始化方法的调用，最后调用 doSomthing，进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用自定义初始化方法，然后将消息转发给代理对象 _object。 12345SomeClass *object = [SomeClass lazy];// other thing ...[object doSomething]; // 在这里 object 才会调用初始化方法，然后调用 doSomething","tags":[]},{"title":"组件化方案","date":"2019-09-10T09:56:58.453Z","path":"2019/09/10/iOS/iOS架构/iOS 组件化方案/","text":"大致讨论组件化的三种方案：url-block、protocol-class（和 url-controller 类似)、target-action，以及应用这三种组件化方案的时机、步骤、利弊等。 一、为什么需要组件化随着公司业务的不断发展，项目的功能越来越复杂，各个业务代码耦合越来越多，代码量急剧增加，传统的 MVC 或者 MVVM 架构已经无法高效的管理工程代码，因此需要用一种技术来更好地管理工程，而组件化是一种能够解决代码耦合的技术。项目经过组件化的拆分，不仅可以解决代码耦合的问题，还可以增强代码的复用性，工程的易管理性等。 二、什么时候做组件开发 项目管理：项目的业务线超过 2 条以上，需要独立拆分。随着业务的拆分，对应的业务组件也就很自然的独立出来。 人员管理：过多人对同一块代码的进行修改，产生 bug 的可能性上升，所以需要重新分配人员和其维护的功能。 测试维度：随着项目的业务量增大，很难做单元测试。每个小功能修改，都需要对 App 进行测试，严重增加测试工作量。 当 App 业务之间交叉耦合，bug 率难以下降，测试每天做大量重复工作。开发人员之间修改相互影响时，你需要考虑进行组件化。 组件化是项目架构层面的技术，不是所有项目都适合组件化，组件化一般针对的是大中型的项目，并且是多人开发。如果，项目比较小，开发人员比较少，确实不太适合组件化，因为这时的组件化可能带来的不是便捷，而是增加了开发的工作量。另外，组件化过程也要考虑团队的情况，总之，根据目前项目的情况作出最合适的技术选型。 三、组件化的过程3.1 url-block这是蘑菇街中使用的一种页面间调用的方式，通过在启动时注册组件提供的服务，把调用组件使用的 url 和组件提供的服务 block 对应起来，保存到内存中。在使用组件的服务时，通过 url 找到对应的 block，然后获取服务。 url-block 的架构图： 注册： 12345[MGJRouter registerURLPattern:@\"mgj://detail?id=:id\" toHandler:^(NSDictionary * routerParameters) &#123; NSNumber *id = routerParameters[@\"id\"]; // create view controller with id. push view controller&#125;]; 调用： 1[MGJRouter openURL:@\"mgj://detail?id=404\"] 蘑菇街为了统一 iOS 和 Android 的平台差异性，专门用后台来管理 url，然后针对不同的平台生成不同类型的文件。 使用 url-block 的方案的确可以组件间解耦，但是还是存在其它明显的问题，比如： 需要在内存中维护 url-block 的表，组件多了可能会有内存问题； url 的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如 UIImage、NSData 等类型； 没有区分本地调用和远程调用的情况，尤其是远程调用会因为 url 参数受限，导致一些功能受限； 组件本身依赖了中间件，且分散注册使的耦合较多 3.2 protocol-class针对方案 1 的问题，蘑菇街又提出了另一种组件化的方案，就是通过 protocol 定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把 protocol 和 class 做一个映射，同时在内存中保存一张映射表，使用的时就通过 protocol 找到对应的 class 来获取需要的服务。 protocol-class 的架构图： 注册： 1[ModuleManager registerClass:ClassA forProtocol:ProtocolA] 调用： 1[ModuleManager classForProtocol:ProtocolA] 蘑菇街的这种方案确实解决了方案 1 中无法传递非常规参数的问题，使得组件间的调用更为方便，但是它依然没有解决组件依赖中间件、内存中维护映射表、组件的分散调用的问题。设计思想和方案 1 类似，都是通过给组件加了一层 wrapper，然后给使用者调用。 3.3 url-controller这是 LDBusMediator 的组件化方案。它是通过组件实现公共协议的接口，来对外提供服务。 具体就是通过单例来维护 url-controller 的映射关系表，根据调用者的 url，以及提供的参数（字典类型，所以参数类型不受约束）来返回对应的 controller 来提供服务；同时，为了增强组件提供服务的多样性，又通过服务协议定义了其它的服务。整体来看，LDBusMediator 解决了蘑菇街的这两种组件化方案的不足，比如：通过注册封装件 connector 而不是 block 来降低了内存占用；通过字典传递参数，解决了 url 参数的限制性。但是，由于使用了 connector 来提供服务而不是组件本身，把 connector 作为组件的一部分，依然有组件依赖中间件的问题。 LDBusMediator 的架构图： 3.4 target-actiontarget-action 的方案是通过给组件包装一层 wrapper 来给外界提供服务，然后调用者通过依赖中间件来使用服务；其中，中间件是通过 runtime 来调用组件的服务，是真正意义上的解耦，也是该方案最核心的地方。具体实施过程是给组件封装一层 target 对象来对外提供服务，不会对原来组件造成入侵；然后，通过实现中间件的 category 来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。 target-action 的架构图： 1234567- (UIViewController *)CTMediator_viewControllerForDetail&#123; return [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@&#123; @\"key\" : @\"value\" &#125; shouldCacheTarget:NO];&#125; 但是 target-action 方案有个问题就是在中间件的 category 里有 hardcode，casa 的解释是在组件间调用时，最好是去 model 化，所以不可避免的引入了 hardcode，并且所有的 hardcode 只存在于分类中。 针对这个问题，有人提议把所有的 model 做成组件化下沉，然后让所有的组件都可以自由的访问 model。这种方案虽然解决了组件间传递 model 的依赖问题，但是为了解决这个问题，直接把整个 model 层组件化后暴露给所有组件，容易造成数据泄露，付出的代价有点大。 针对这个问题，经过和网友讨论，一致觉得组件间调用时用字典传递数据，组件内调用时用 model 传递数据，这样既减少组件间数据对 model 的耦合，又方便了组件内使用 model 传递数据的便捷性。 1234567- (UIViewController *)CTMediator_viewControllerForDetail:(NSDictionary *)dict&#123; return [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:dict shouldCacheTarget:NO];&#125; hardCode 官方解释：将可变变量用一个固定值来代替的方法。用这种方法编译后，如果以后需要更改此变量就非常困难了。 hard code 是指“硬编码”，即将数据直接写在代码中。也就是，在程序中直接给变量赋值。指的是在软件实现上，把输出或输入的相关参数（例如：路径、输出的形式、格式）直接硬编码在源代码中，而非在运行时期由外界指定的设置、资源、数据、或者格式做出适当回应。 hard code 的双重性： a. 直接将数据填写在源代码中，数据发生变化时，并不利于数据的修改，会造成程序的质量降低； b. 保护一些数据，直接赋值，避免其发生变化。 四、组件化实施的方式组件化可以利用 git 的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的 podspec 上传到私有仓库，在需要用到组件时，直接从仓库里面取。 壳工程 main AppDelegate 工程配置 Debug 页面 封装公共库和基础 UI 库 在具体的项目开发过程中，我们常会用到三方库和自己封装的 UI 库，我们可以把这些库封装成组件，然后在项目里用 pod 进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。 独立业务模块化 在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。 服务接口最小化 在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。 公共组件： 埋点组件 Common 组件（聚合工具类） 启动组件 性能监控组件 定位组件 图片处理组件 UIKit 封装和扩展组件 业务生命周期及通信组件 网络组件： 基于 AFNetworking 进行封装，提供 JSON 转 Model、缓存功能 DNS 加速组件 持久化组件 基于 FMDB 进行封装组件 第三方业务组件 * 分享组件 * 推送组件 基础业务组件 * User 组件，保存用户信息，登陆，登出状态 五、文章iOS 组件化方案的几种实现iOS 的组件化开发","tags":[]},{"title":"iOS 编译过程原理(1)","date":"2019-09-10T09:56:58.452Z","path":"2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/","text":"一、前言一般可以将编程语言分为两种，编译语言和直译式语言。 像 C++、Objective-C 都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率较高。 像 JavaScript、Python 都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为 CPU 可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。 iOS 开发目前的常用语言：Objective-C 和 Swift。二者都是编译语言，换句话说都是需要编译才能执行的。它们的编译都是依赖于 Clang(swift) + LLVM。本文只关注 Objective-C，原理上大同小异。 充分理解了编译的过程，会对你的开发大有帮助。本文的最后，会以以下几个例子，来讲解如何合理利用 XCode 和编译 __attribute__ Clang 警告处理 预处理 插入编译期脚本 提高项目编译速度 二、iOS 编译Objective-C 采用 Clang 作为前端，而 Swift 则采用 swift() 作为前端，都是 LLVM（Low level vritual machine）作为编译器后端。所以简单的编译过程如图： 其中，swift 的编译命令可以在这里找到 1/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift 可以通过 Clang，来查看一个文件的编译具体过程，新建 Demo.m 12345678#import &lt;Foundation/Foundation.h&gt; int main()&#123; @autoreleasepool &#123; NSLog(@\"%@\",@\"Hello Leo\"); &#125; return 0;&#125; 然后终端输入： 1234567891011~ $ cd /Users/dubin/Desktop/Demo/DemoDemo $ Demo $ clang -ccc-print-phases -framework Foundation Demo.m -o Demo 0: input, \"Foundation\", object1: input, \"Demo.m\", objective-c2: preprocessor, &#123;1&#125;, objective-c-cpp-output // 预处理3: compiler, &#123;2&#125;, ir // 编译生成 IR（中间代码）4: backend, &#123;3&#125;, assembler // 汇编器生成汇编代码5: assembler, &#123;4&#125;, object // 生成机器码6: linker, &#123;0, 5&#125;, image // 链接7: bind-arch, \"x86_64\", &#123;6&#125;, image // 生成 Image，也就是最后的可执行文件 在终端运行这个程序： 123Demo $ gcc -framework Foundation Demo.m -o Demo$ ./Demo2019-03-27 13:55:30.426 Demo[14155:5478670] Hello Leo 另一种终端运行 OC 程序的顺序： 123456Demo $ cc -c Demo.mDemo $ cc Demo.o -framework Foundationld: warning: text-based stub file /System/Library/Frameworks//Foundation.framework/Foundation.tbd and library file /System/Library/Frameworks//Foundation.framework/Foundation are out of sync. Falling back to library file for linking.ld: warning: text-based stub file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation.tbd and library file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation are out of sync. Falling back to library file for linking.Demo $ ./a.out2019-03-27 14:01:52.933 a.out[14413:5483194] Hello Leo cc -c tst.m 编译：生成 tst.o文件 cc -c man.m 编译： 生成 man.o 文件 cc tst.o man.o -framework Foundation 链接、合并：生成 a.out 可执行文件 ./a.out 运行 当然 OC 程序还可以混编 C 程序，格式为：cc -c x.m x.c，或者直接将编译和链接合在一起：cc x.m x.c 编译器前端 编译器前端的任务是：语法分析、语义分析、生成中间代码（intermediate representation）。在这个过程中会进行类型检查，如果发现错误或者警告会标注出来在哪一行。 编译器后端 编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS 的编译过程，后端的处理如下 ①、LVVM 优化器会进行 BitCode 的生成，链接期优化等等。 ②、LLVM 机器码生成器会针对不同的架构，比如 arm64 等生成不同的机器码。 三、执行一次 XCode build 的流程当你在 XCode 中，选择 build 的时候（快捷键 command+B），会执行如下过程 编译信息写入辅助文件，创建编译后的文件架构（name.app） 处理文件打包信息，例如在 debug 环境下 12345Entitlements:&#123; \"application-identifier\" = \"app的bundleid\"; \"aps-environment\" = development;&#125; 执行 CocoaPod 编译前脚本。例如对于使用 CocoaPod 的工程会执行 CheckPods Manifest.lock 编译各个 .m 文件，使用 CompileC 和 clang 命令。 1234CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compilerexport LANG=en_US.US-ASCIIexport PATH=\"...\"clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework -iquote 所需要的Framework ... -c ClassName.c -o ClassName.o 通过这个编译的命令，我们可以看到 1234567891011clang是实际的编译命令-x objective-c 指定了编译的语言-arch x86_64制定了编译的架构，类似还有arm7等-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本-I 把编译信息写入指定的辅助文件-F 链接所需要的Framework-c ClassName.c 编译文件-o ClassName.o 编译产物 链接需要的 Framework，例如 Foundation.framework、AFNetworking.framework、AliPay.framework 编译 xib 文件 拷贝 xib，图片等资源文件到结果目录 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝 Swift 标准库 创建 .app 文件和对其签名 四、ipa 包的内容例如，通过 iTunes Store 下载微信，获得 ipa 安装包，然后实际看看其安装包的内容。 右键 ipa，重命名为 .zip 双击 zip 文件，解压缩后会得到一个文件夹。所以，ipa 包就是一个普通的压缩包。 右键图中的 [WeChat[，选择显示包内容，然后就能够看到实际的 ipa 包内容了。 五、二进制文件的内容通过 XCode 的 Link Map File，我们可以窥探二进制文件中布局。在 XCode -&gt; Build Settings -&gt; 搜索 map -&gt; 开启Write Link Map File。 开启后，再编译，我们可以在对应的 Debug/Release 目录下看到对应的 link map 的 text 文件。 默认的目录： 1~/Library/Developer/Xcode/DerivedData/&lt;TARGET-NAME&gt;-对应ID/Build/Intermediates/&lt;TARGET-NAME&gt;.build/Debug-iphoneos/&lt;TARGET-NAME&gt;.build/ 例如 TargetName是 Demo 的目录： 1/Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build 这个映射文件的主要包含以下部分： Object files 这个部分包括的内容： .o 文文件，也就是上文提到的 .m 文件编译后的结果。 .a 文件 需要 link 的 framework 123456789101112# Arch: x86_64# Object files:[ 0] linker synthesized[ 1] dtrace[ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o[ 3] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/ViewController.o[ 4] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/Person.o[ 5] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyOperation.o[ 6] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/main.o[130] /Applications/Xcode10.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//CoreGraphics.framework/CoreGraphics.tbd 这个区域的存储内容比较简单：前面是文件的编号，后面是文件的路径。文件的编号在后续会用到。 Sections 这个区域提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小。这个区域完整的描述了可执行文件中的全部内容。其中，段分为两种： __TEXT 代码段 __DATA 数据段 从 Sections 区域可以看到，代码段的 __text 节的地址是 0x100001000，大小是 0x000A5FF9，而二者相加的下一个位置正好是 __stubs 的位置 0x1000A6FFA。 1234567891011121314151617181920212223242526272829303132333435# Sections: # 位置 大小 段 节 # Address Size Segment Section0x100001000 0x000A5FF9 __TEXT __text // 代码0x1000A6FFA 0x000003D8 __TEXT __stubs0x1000A73D4 0x00000678 __TEXT __stub_helper0x1000A7A4C 0x0000794A __TEXT __objc_methname // OC 方法名0x1000AF396 0x000079F4 __TEXT __cstring // 字符串0x1000B6D8A 0x0000092C __TEXT __objc_classname // OC 类名0x1000B76B6 0x00002293 __TEXT __objc_methtype // OC 方法类型0x1000B9950 0x000000E8 __TEXT __const // 常量0x1000B9A38 0x000043DC __TEXT __gcc_except_tab0x1000BDE14 0x0000004A __TEXT __ustring0x1000BDE5E 0x00000166 __TEXT __entitlements0x1000BDFC4 0x0000037B __TEXT __dof_RACSignal0x1000BE33F 0x000002E8 __TEXT __dof_RACCompou0x1000BE628 0x000009CC __TEXT __unwind_info0x1000BF000 0x00000010 __DATA __nl_symbol_ptr0x1000BF010 0x000001B8 __DATA __got0x1000BF1C8 0x00000520 __DATA __la_symbol_ptr0x1000BF6E8 0x00005D28 __DATA __const0x1000C5410 0x00002E80 __DATA __cfstring0x1000C8290 0x00000268 __DATA __objc_classlist // OC 方法列表0x1000C84F8 0x000001C0 __DATA __objc_catlist0x1000C86B8 0x00000098 __DATA __objc_protolist // OC 协议列表0x1000C8750 0x00000008 __DATA __objc_imageinfo0x1000C8758 0x0000F0C0 __DATA __objc_const // OC 常量0x1000D7818 0x00001B28 __DATA __objc_selrefs0x1000D9340 0x00000040 __DATA __objc_protorefs0x1000D9380 0x00000360 __DATA __objc_classrefs0x1000D96E0 0x00000170 __DATA __objc_superrefs // OC 父类引用0x1000D9850 0x00000610 __DATA __objc_ivar // OC ivar0x1000D9E60 0x00001810 __DATA __objc_data0x1000DB670 0x00000768 __DATA __data0x1000DBDD8 0x0000015F __DATA __bss Symbols Section 部分将二进制文件进行了一级划分。而 Symbols 对 Section 中的各个段进行了二级划分，例如，对于 __TEXT __text 表示代码段中的代码内容。 10x100001000 0x000A5FF9 __TEXT __text // 代码 而对应的 Symbols，起始地址也是 0x1000021B0。其中，文件编号和上文的编号对应 12340x100001000 0x000000A0 [ 2] +[MyProxy proxyWithObj:][ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o 具体内容： 1234567891011# Symbols:# 地址 大小 文件编号 方法名# Address Size File Name0x100001000 0x000000A0 [ 2] +[MyProxy proxyWithObj:]0x1000010A0 0x00000040 [ 2] -[MyProxy methodSignatureForSelector:]0x1000010E0 0x000003F0 [ 2] -[MyProxy forwardInvocation:]0x1000014D0 0x00000040 [ 2] -[MyProxy .cxx_destruct]0x100001510 0x00000048 [ 2] -[Dog barking:]0x100001560 0x00000060 [ 3] -[ViewController dealloc]0x1000015C0 0x000001C0 [ 3] -[ViewController drawImage:... 到这里，我们知道 OC 的方法是如何存储的，再来看看 ivar 是如何存储的。 首先找到数据栈中 __DATA __objc_ivar 10x1000D9850 0x00000610 __DATA __objc_ivar 然后，搜索这个地址 0x1000D9850，就能找到 ivar 的存储区域。 10x1000D9850 0x00000008 [ 2] _OBJC_IVAR_$_MyProxy.__innerObj 值得一提的是，对于 String，会显式的存储到数据段中，例如： 10x1000AF3F2 0x00000004 [ 3] literal string: http://www.baidu.com 所以，若果你的加密 Key 以明文的形式写在文件里，是一件很危险的事情。 六、dSYM 文件在每次编译过后，都会生成一个 dsym 文件。dsym 文件中，存储了 16 进制的函数地址映射。 在 App 实际执行的二进制文件中，是通过地址来调用方法的。在 App crash 的时候，第三方工具（Fabric、友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含 crash 地址的调用信息。然后通过 dSYM 文件，我们就可以由地址映射到具体的函数位置。 XCode 中选择 Window -&gt; Organizer 可以看到生成的 archier 文件。 然后 右键 -> 在 finder 中显示。 右键 -> 查看包内容。 关于如何用 dsym 文件来分析崩溃位置，查看另一篇博客：iOS 如何调试第三方统计到的崩溃报告 七、应用场景7.1 __attribute__或多或少都会在第三方库或者 iOS 的头文件中，见到过 __attribute__。比如 1__attribute__ ((warn_unused_result)) // 如果没有使用返回值，编译的时候给出警告 __attribtue__ 是一个高级的的编译器指令，它允许开发者指定更多的编译检查和一些高级的编译期优化。 分为三种： 函数属性（Function Attribute） 类型属性（Variable Attribute） 变量属性（Type Attribute） 语法结构 __attribute__ 语法格式为：__attribute__ ((attribute-list)) 放在声明分号 “;” 前面。 比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了。 1@property (nonatomic, strong) CLASSNAME * property __deprecated; 好处： 给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的 API，但是被 __deprecated 的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新 Pod 的时候，代码无法运行了。 __attribtue__ 的使用场景很多，本文只列举 iOS 开发中常用的几个： 1234567891011121314151617181920// 弃用 API，用作 API 更新#define __deprecated __attribute__((deprecated)) // 带描述信息的弃用#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))// 遇到 __unavailable 的变量/方法，编译器直接抛出 Error#define __unavailable __attribute__((unavailable))// 告诉编译器，即使这个变量/方法没被使用，也不要抛出警告#define __unused __attribute__((unused))// 和 __unused 相反#define __used __attribute__((used))// 如果不使用方法的返回值，进行警告#define __result_use_check __attribute__((__warn_unused_result__))// OC 方法在 Swift 中不可用#define __swift_unavailable(_msg) __attribute__((__availability__(swift, unavailable, message=_msg))) 7.2 Clang 警告处理你一定还见过如下代码： 1234#pragma clang diagnostic push#pragma clang diagnostic ignored \"-Wundeclared-selector\"/// 代码#pragma clang diagnostic pop 这段代码的作用是 对当前编译环境进行压栈 忽略 -Wundeclared-selector（未声明的）Selector 警告 编译代码 对编译环境进行出栈 通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。 在另一篇文章：iOS 合理利用 Clang 警告来提高代码质量，详细的介绍了 XCode 的警告相关内容。 7.3 预处理所谓预处理，就是在编译之前的处理。预处理能够让你定义编译器变量，实现条件编译。 比如，这样的代码很常见 12345#ifdef DEBUG//...#else//...#endif 我们同样也可以定义其他预处理变量，在 XCode -&gt; 选中 Target -&gt; build settings 中，搜索 preprocessor。可以分别为 Debug 和 Release 两种模式设置预处理宏。 比如加上：TESTMODE = 1，表示在这个宏中的代码运行在测试服务器。 然后，配合多个 Target（右键 Target，选择 Duplicate），单独一个 Target 负责测试服务器。这样就不用每次切换测试服务器都要修改代码了。 12345#ifdef TESTMODE// 测试服务器相关的代码#else// 生产服务器相关代码#endif 7.4 插入脚本通常，如果你使用 CocoaPod 来管理三方库，那么你的 Build Phase 是这样子的： 其中：[CP] 开头的就是 CocoaPod 插入的脚本。 Check Pods Manifest.lock，用来检查 cocoapod 管理的三方库是否需要更新 Embed Pods Framework，运行脚本来链接三方库的静态/动态库 Copy Pods Resources，运行脚本来拷贝三方库的资源文件 而这些配置信息都存储在这个文件（.xcodeproj）里。 到这里，CocoaPod 的原理也就大致搞清楚了，通过修改 xcodeproject，然后配置编译期脚本，来保证三方库能够正确的编译连接。 同样，我们也可以插入自己的脚本来做一些额外的事情。比如，每次进行 archive 的时候，我们都必须手动调整 target 的 build 版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。 123buildNumber=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;\")buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;\" 这段脚本其实很简单，读取当前 plist 的 build 版本号，然后对其 +1，重新写入。 使用起来也很简单： Xcode -&gt; 选中 Target -&gt; 选中 build phase 选择添加 Run Script Phase 然后把这段脚本拷贝进去，并且勾选 Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为 Auto Increase build number 然后，拖动这个脚本的到 Link Binary With Libraries 下面。 7.5 脚本编译打包脚本化编译打包对于 CI（持续集成）来说，十分有用。iOS 开发中，编译打包必备的两个命令是： 1234567// 编译成.appxcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDir// 打包xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa// 通过 info 命令，可以查看到详细的文档info xcodebuild 在本文最后的附录中，提供一个自动打包的脚本。 7.6 提高项目编译速度通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了 XCode 的编译过程后，我们可以从以下角度来优化编译速度。 查看编译时间 我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。 对于 XCode 8，关闭 XCode，终端输入以下指令 1$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 然后，重启 XCode，再编译，你会在这里看到编译时间。 &lt;center&gt; ![17](https://upload-images.jianshu.io/upload_images/5294842-699c09578e290bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) &lt;/center&gt; 代码层面的优化 forward declaration 所谓 forward declaration，就是 @class CLASSNAME，而不是 #import CLASSNAME.h。这样，编译器能大大提高 #import 的替换速度。 对常用的工具类进行打包（Framework/.a） 打包成 Framework 或者静态库，这样编译的时候这部分代码就不需要重新编译了。 常用头文件放到预编译文件里 pch 文件是预编译文件，这里的内容在执行 XCode build 之前就已经被预编译，并且引入到了每一个 .m 文件里。 编译器选项优化 Debug 模式下，不生成 dsym 文件 上文提到了，dysm 文件里存储了调试信息，在 Debug 模式下，我们可以借助 XCode 和 LLDB 进行调试。所以，不需要生成额外的 dsym 文件来降低编译速度。 Debug 开启 Build Active Architecture Only 在 XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为 YES。这样做，可以只编译当前的版本，比如 arm7/arm64 等等，记得只开启 Debug 模式。这个选项在高版本的 XCode 中自动开启了。 Debug 模式下，关闭编译器优化 八、附录自动编译打包脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758export LC_ALL=zh_CN.GB2312;export LANG=zh_CN.GB2312buildConfig=\"Release\" //这里是build模式projectName=[find . -name *.xcodeproj | awk -F \"[/.]\" '&#123;print $(NF-1)&#125;'[projectDir=[pwd[wwwIPADir=~/Desktop/$projectName-IPAisWorkSpace=trueecho \"~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~\"if [ -d \"$wwwIPADir\" ]; thenecho $wwwIPADirecho \"文件目录存在\"elseecho \"文件目录不存在\"mkdir -pv $wwwIPADirecho \"创建$&#123;wwwIPADir&#125;目录成功\"ficd $projectDirrm -rf ./buildbuildAppToDir=$projectDir/buildinfoPlist=\"$projectName/Info.plist\"bundleVersion=`/usr/libexec/PlistBuddy -c \"Print CFBundleShortVersionString\" $infoPlist`bundleIdentifier=`/usr/libexec/PlistBuddy -c \"Print CFBundleIdentifier\" $infoPlist`bundleBuildVersion=`/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" $infoPlist`if $isWorkSpace ; then #是否用CocoaPodecho \"开始编译workspace....\"xcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirelseecho \"开始编译target....\"xcodebuild -target $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirfiif test $? -eq 0thenecho \"~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~\"elseecho \"~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~\"exit 1fiipaName=[echo $projectName | tr \"[:upper:]\" \"[:lower:]\"[ #将项目名转小写findFolderName=[find . -name \"$buildConfig-*\" -type d |xargs basename[ #查找目录appDir=$buildAppToDir/$findFolderName/ #app所在路径echo \"开始打包$projectName.app成$projectName.ipa.....\"xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipaif [ -f \"$appDir/$ipaName.ipa\" ]thenecho \"打包$ipaName.ipa成功.\"elseecho \"打包$ipaName.ipa失败.\"exit 1fipath=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipacp -f -p $appDir/$ipaName.ipa $path #拷贝ipa文件echo \"复制$ipaName.ipa到$&#123;wwwIPADir&#125;成功\"echo \"~~~~~~~~~~~~~~~~~~~结束编译，处理成功~~~~~~~~~~~~~~~~~~~\" 九、文章iOS编译过程的原理和应用","tags":[]},{"title":"if-else、switch、while、for","date":"2019-09-10T09:56:58.451Z","path":"2019/09/10/C/if-else、switch、while、for/","text":"文章主要会涉及如下几个问题： if-else 和 switch-case 两者相比谁的效率会高些？在日常开发中该如何抉择？ 如何基于赫夫曼树结构减少 if-else 分支判断次数？ 如何巧妙的应用 do…while(0) 改善代码结构？ 哨兵是什么东西？如何利用哨兵提高有序数组查找效率？ 如何降低 for 循环嵌套的时间复杂度？ 如何利用策略模式替换繁琐的 if-else 分支？ 一、if-else 和 switch-case 效率问题switch-case 与 if-else 的根本区别： switch 会生成一个跳转表来指示实际的 case 分支的地址，而这个跳转表的索引号与 switch 变量的值是相等的。 所以 switch-case 不用像 if-else 那样遍历条件分支直到命中条件，只需访问对应索引号的表项从而到达定位分支。 具体地说，switch-case 会生成一份大小（表项数）为最大 case 常量 +1 的跳转表，程序首先判断 switch 变量是否大于最大 case 常量，若大于，则跳到 default 分支处理；否则取得索引号为 switch 变量大小的跳表项的地址（即跳表的起始地址+表项大小 * 索引号），程序接着跳到此地址执行，到此完成了分支的跳转。 123456789101112131415161718192021222324252627282930int main() &#123; unsigned int i, j; i = 3; switch (i) &#123; case 0: j = 0; break; case 1: j = 1; break; case 2: j = 2; break; case 3: j = 3; break; case 4: j = 4; break; default: j = 10; break; &#125;&#125; 用 gcc 编译器，生成汇编代码（不开编译器优化） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283_main: ## @mainLfunc_begin0: .loc 1 12 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:12:0 .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl $0, -4(%rbp)Ltmp0: .loc 1 14 7 prologue_end ## /Users/cykj/Desktop/Demo/Demo/MyC.c:14:7 movl $3, -8(%rbp) .loc 1 16 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:13 movl -8(%rbp), %eax movl %eax, %ecx movq %rcx, %rdx subq $4, %rdx .loc 1 16 5 is_stmt 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:5 movq %rcx, -24(%rbp) ## 8-byte Spill movq %rdx, -32(%rbp) ## 8-byte Spill ja LBB0_6## %bb.8: .loc 1 0 5 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:0:5 leaq LJTI0_0(%rip), %rax movq -24(%rbp), %rcx ## 8-byte Reload movslq (%rax,%rcx,4), %rdx addq %rax, %rdx jmpq *%rdxLBB0_1:Ltmp1: .loc 1 18 15 is_stmt 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:18:15 movl $0, -12(%rbp) .loc 1 19 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:19:13 jmp LBB0_7LBB0_2: .loc 1 22 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:22:15 movl $1, -12(%rbp) .loc 1 23 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:23:13 jmp LBB0_7LBB0_3: .loc 1 26 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:26:15 movl $2, -12(%rbp) .loc 1 27 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:27:13 jmp LBB0_7LBB0_4: .loc 1 30 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:30:15 movl $3, -12(%rbp) .loc 1 31 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:31:13 jmp LBB0_7LBB0_5: .loc 1 34 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:34:15 movl $4, -12(%rbp) .loc 1 35 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:35:13 jmp LBB0_7LBB0_6: .loc 1 38 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:38:15 movl $10, -12(%rbp)Ltmp2:LBB0_7: .loc 1 42 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:42:1 movl -4(%rbp), %eax popq %rbp retqLtmp3:Lfunc_end0: .cfi_endproc .p2align 2, 0x90 .data_region jt32L0_0_set_1 = LBB0_1-LJTI0_0L0_0_set_2 = LBB0_2-LJTI0_0L0_0_set_3 = LBB0_3-LJTI0_0L0_0_set_4 = LBB0_4-LJTI0_0L0_0_set_5 = LBB0_5-LJTI0_0LJTI0_0: .long L0_0_set_1 .long L0_0_set_2 .long L0_0_set_3 .long L0_0_set_4 .long L0_0_set_5 .end_data_region ## -- End function 由此看来，switch 有点以空间换时间的意思，而事实上也的确如此。 当分支较多时，当时用 switch 的效率是很高的。因为 switch 是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是 if-else 是遍历所有的可能值，直到找到符合条件的分支。 但不总是那么好，因为每次计算会有一个二次查表过程。 具体需要看应用场景，举个例子：对于网络层的协议分析，99% 可能都是 IP 协议，因此基本上会在第一个 if 时就命中，只有一次计算。 总结：对于分支较多或分布相对均匀的情况，使用 switch 可以提高效率；对于分支较少或分布不均匀的情况，使用 if-else 更好。 由上面的汇编代码可知道，switch-case 占用较多的代码空间，因为它要生成跳转表，特别是当 case 常量分布范围很大但实际有效值又比较少的情况，switch-case 的空间利用率将变得很低。 switch-case 只能处理 case 为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用 switch-case 来处理的。所以 if-else 能应用于更多的场合，比较灵活。 文章：switch 与 if-else 的效率问题 二、用 do-while(0) 改善代码结构先看一段代码，要重点注意代码中的注释。 1234567891011121314- (NSString *)handleString:(NSString *)str&#123; if (![str isKindOfClass:[NSString class]]) &#123; return nil; &#125; if(str.length &lt;= 0) &#123; return nil; &#125; // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1...code1 // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果)，无论判断是否通过都要执行 code2...code2&#125; 试问，怎样做才能巧妙的满足上述注释代码的需求，因为上述代码中存在 return nil，一旦执行到此处，逻辑一和逻辑二处的伪代码都不会再执行。为了满足上述要求，我们可以巧妙的利用 break 退出临时构造的代码块，但不退出整个函数。 123456789101112131415- (NSString *)handleString:(NSString *)str &#123; do &#123; if (![str isKindOfClass:[NSString class]]) &#123; break; &#125; if(str.length &lt;= 0) &#123; break; &#125; // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1...code2 &#125; while (0); // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果),无论判断是否通过都要执行 code2...code2&#125; 三、有序数组查找操作中的哨兵正常的查找处理。 123456NSArray *arr = @[@1, @2, @3, @4, @5];for (NSInteger i = 0; i &lt; arr.count; i++) &#123; if ([arr[i] integerValue] == 2) &#123; NSLog(@\"for 找到了\"); &#125;&#125; 利用哨兵进行查找处理。 123456789101112131415161718192021222324- (BOOL)search:(NSNumber *)key array:(NSMutableArray *)arr&#123; if (arr.count &lt;= 0) &#123; return NO; &#125; NSNumber * firstObj = (NSNumber *)arr[0]; if ([firstObj integerValue] == [key integerValue]) &#123; return YES; &#125; NSInteger i = arr.count - 1; NSLock * lock = [[NSLock alloc] init]; [lock lock]; arr[0] = key; // 同上面 for 循环相比，i &lt; arr.count 的判断，在处理大批量数据时候，对性能提升比较大 while ([arr[i] integerValue] != [key integerValue]) &#123; i--; &#125; arr[0] = firstObj; [lock unlock]; return (i != 0);&#125; 仔细观察上述两段代码，同样是在有序数组中查找目标为 2 的元素，第一段代码是常规迭代处理，第二段代码是将要查找的元素设置为哨兵。同第一段代码相比第二种方式少了 i &lt; arr.count 的判断，在小批量有序数组查询中对效率的提升并无明显影响，但是在处理大批量数据时候，对性能提升还是比较明显的。 四、多层 for 嵌套处理实际开发中应尽量避免使用双层 for 循环，客户端数据量比较小可能实际开发中并不是很注意这些。但是后端开发过程中，数据量比较大, 为了提升性能，有些公司后端开发中可能会直接规定避免使用多层 for 循环嵌套的形式。一般第二层或更深层的 for 循环可以使用字典替换。双层 for 循环嵌套的时间复杂度是 n 的二次方。但如果内部 for 循环用字典代替时间复杂度为 O(2n)（实际是 O(n)）。如：两个数组中有且只有一个相同元素，寻找该元素。其中一个数组就可以先用字典做保存，遍历第一个数组的时候，同字典中的数据做比较即可。 1234567891011121314NSArray *arr1 = @[@1, @2, @3, @4, @5];NSArray *arr2 = @[@5, @6, @7, @8];NSMutableDictionary * dict = [NSMutableDictionary dictionary];for (NSInteger i = 0; i &lt; arr2.count; i++) &#123; [dict setObject:arr2[i] forKey:[NSString stringWithFormat:@\"%ld\", i]];&#125;for (NSInteger i= 0 ; i &lt; arr1.count; i++) &#123; NSNumber * number = [dict objectForKey:[NSString stringWithFormat:@\"%ld\", i]]; if ([arr1[i] integerValue] == [number integerValue]) &#123; NSLog(@\"相同的数据为:%@\", number); break; &#125; &#125; 五、用策略模式替换 if-elsehttps://www.jianshu.com/p/98fa80eebc52 六、文章用if else,switch,while,for颠覆你的编程认知","tags":[]},{"title":"FOUNDATION_EXTERN","date":"2019-09-09T08:18:19.678Z","path":"2019/09/09/iOS/iOS原理/FOUNDATION_EXTERN/","text":"12345#if defined(__cplusplus)#define FOUNDATION_EXTERN extern \"C\"#else#define FOUNDATION_EXTERN extern#endif 由以上定义可以看出 FOUNDATION_EXTERN 是可以兼容 C++ 的 extern 的宏。 12345678910111213141516171819202122232425262728FOUNDATION_EXTERN NSString * Extern_S = @\"sss\";#define Define_S @\"sss\"&#123; NSString * s = @\"tt\"; CFTimeInterval begin = CACurrentMediaTime(); for (int i = 0; i &lt; 10000; i++) &#123; if ([s isEqualToString:Define_S]) &#123; &#125; &#125; NSLog(@\"%f\", CACurrentMediaTime() - begin); begin = CACurrentMediaTime(); for (int i = 0; i &lt; 10000; i++) &#123; if ([s isEqualToString:Extern_S]) &#123; &#125; &#125; NSLog(@\"%f\", CACurrentMediaTime() - begin);&#125;2019-09-09 16:06:04.849874+0800 Demo[86518:3255355] 0.0001482019-09-09 16:06:04.850170+0800 Demo[86518:3255355] 0.000137 extern 比宏在字符串上的比较速度要快一些，因为 extern 直接比较指针地址，而宏是比较字符串是否相等。","tags":[]},{"title":"NSPredicate","date":"2019-08-31T05:34:34.645Z","path":"2019/08/31/iOS/iOS原理/NSPredicate/","text":"官方的解释: The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering. NSPredicate 类是用来定义逻辑条件，用来有约束的获取内存中的对象或过滤搜索。 简而言之：只选取符合条件的对象。 一、基本语法使用谓词（NSPredicate）都需要为谓词定义谓词表达式，而这个表达式必须是一个返回 BOOL 的值。 谓词表达式由表达式、运算符和值构成。 1.1 比较运算符 =、==：判断两个表达式是否相等，在谓词中 = 和 == 是相同的意思，而没有赋值的概念。 123456789101112NSString * string = @&quot;1234&quot;;NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF = &apos;1234&apos;&quot;];// 验证对象是否符合条件。底层调用了 [xx compare:] 方法if ([predicate evaluateWithObject:string]) &#123; NSLog(@&quot;Evaluate Success!\\n&quot;);&#125;else &#123; NSLog(@&quot;Evaluate Fail!\\n&quot;);&#125;2019-08-31 11:53:35.305452+0800 Predicate[7069:1165684] Evaluate Success! 当传入数组对象时，报错：*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSArrayI compare:]: unrecognized selector sent to instance 0x600000234c00’。可以发现底层调用了 compare: 方法。 >=、=>：判断左边表达式的值是否大于或等于右边表达式的值 \\&lt;=、=\\&lt;：判断左边表达式的值是否小于或等于右边表达式的值 >：判断左边表达式的值是否大于右边表达式的值 \\&lt;：判断左边表达式的值是否小于右边表达式的值 !=、\\&lt;>：判断两个表达式是否不相等 1.2 逻辑运算符 AND、&amp;&amp;：逻辑与。两个表达式的值都为 YES 时，结果才为 YES。 OR、||：逻辑或。要求其中一个表达式为 YES 时，结果就是 YES。 NOT、!：逻辑非。对原有的表达式取反 1.3 关系运算符 ANY、SOME：集合中任意一个元素满足条件，就返回 YES。 123456789101112131415@interface Person : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age;@end&#123; NSArray * arr = @[ person1, person2, ... ]; predicate = [NSPredicate predicateWithFormat:@\"ANY name LIKE 'Tom*2'\"]; NSLog(@\"%@\", [arr filteredArrayUsingPredicate:predicate]);&#125;2019-08-31 13:33:03.764130+0800 Predicate[8478:1206451] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'The left hand side for an ALL or ANY operator must be either an NSArray or an NSSet.' 根据报错信息得知，谓词表达式中 ANY 的操作的主体需要是 NSArray 或者 NSSet。上面 filteredArrayUsingPredicate: 方法传入的是 Person 对象，所以报错，因此 ANY 操作的数据结构要是 @[ @[] ] 双层数组。 123456&#123; NSArray * arr = @[ @[ person1, person2, ... ] ]; predicate = [NSPredicate predicateWithFormat:@\"ANY name LIKE 'Tom*2'\"]; NSLog(@\"%@\", [arr filteredArrayUsingPredicate:predicate]);&#125; ALL：集合中所有元素都满足条件，才返回 YES。 NONE：集合中没有任何元素满足条件就返回 YES，等同于 not any。如: NONE person.age &lt; 18，表示 person 集合中所有元素的 age &gt;= 18 时，才返回 YES。 IN：等价于 SQL 语句中的 IN 运算符，只有当左边表达式或值出现在右边的集合中才会返回 YES 1234predicateString = @\"self.name IN &#123;'Tom','Jay'&#125; || self.age IN&#123;25,30&#125;\";predicate = [NSPredicate predicateWithFormat:predicateString]; NSLog(@\"%@ = %@\", predicateString, [self.persons filteredArrayUsingPredicate:predicate]); 1.4 范围运算符 BETWEEN：BETWEEN 表达式必须满足表达式 BETWEEN {下限，上限} 的格式，要求该表达式必须大于或等于下限，并小于或等于上限 1234567891011NSNumber * number = @(1234); predicate = [NSPredicate predicateWithFormat:@\"SELF BETWEEN &#123;1000, 2000&#125;\"]; if ([predicate evaluateWithObject:number]) &#123; NSLog(@\"Success!\"); &#125; else &#123; NSLog(@\"Fail!\"); &#125; 2019-08-31 13:06:59.443083+0800 Predicate[8050:1192540] Success! IN 1.5 字符串比较运算符 BEGINSWITH：检查某个字符串是否以指定的字符串开头 ENDSWITH：检查某个字符串是否以指定的字符串结尾 CONTAINS：检查某个字符串是否包含指定的字符串 LIKE：检查某个字符串是否匹配指定的字符串模板。其之后可以跟 ? 代表一个字符和 * 代表任意多个字符。比如 “name LIKE ‘*ac*‘“，这表示 name 的值中包含 ac 则返回 YES；”name LIKE ‘?ac*’”，表示 name 的第 2、3 个字符为 ac 时返回 YES。 MATCHES：检查某个字符串是否匹配指定的正则表达式。虽然正则表达式的执行效率是最低的，但其功能是最强大的，也是我们最常用的。 注意：字符串比较都是区分大小写和重音符号的。如：café 和 cafe 是不一样的，Cafe 和 cafe 也是不一样的。如果希望字符串比较运算不区分大小写和重音符号，请在这些运算符后使用 [c]、[d] 选项。其中 [c] 是不区分大小写，[d] 是不区分重音符号，其写在字符串比较运算符之后，比如：name LIKE[cd] ‘cafe’，那么不论 name 是cafe、Cafe 还是 café 上面的表达式都会返回 YES。 1.6 直接量在谓词表达式中可以使用如下直接量 FALSE、NO：代表逻辑假 TRUE、YES：代表逻辑真 NULL、NIL：代表空值 SELF：代表正在被判断的对象自身，不区分大小写，self 也可以。 “string” 或 ‘string’：代表字符串 数组：和 c 中的写法相同，如：{‘one’, ‘two’, ‘three’}。 数值：包括整数、小数和科学计数法表示的形式 十六进制数：0x开头的数字 八进制：0o开头的数字 二进制：0b开头的数字 1.7 数组操作 array[index]：指定数组中特定索引处的元素。 array[first]：指定第一个元素 array[last]：指定最后一个元素 array[size]：指定数组大小 1.8 保留字下列单词都是保留字（不区分大小写） AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSEPREDICATE 虽然大小写都可以，但是更推荐使用大写来表示这些保留字 二、谓词的用法2.1 数据校验1234567891011// MATCHES（正则表达式）NSString * phoneRegex = @\"^((13[0-9])|(15[^4,\\\\D])|(18[0,0-9]))\\\\d&#123;8&#125;$\";NSString * phoneNumber = @\"15180168516\";predicate = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", phoneRegex]; if ([predicate evaluateWithObject:phoneNumber]) &#123; NSLog(@\"%@ 是电话号码!\", phoneNumber);&#125;else &#123; NSLog(@\"%@ 不是电话号码!\", phoneNumber);&#125; evaluateWithObject: 方法返回的是一个 BOOL 值，如果符合条件就返回 YES，不符合就返回 NO。常见的有判断手机号码、邮编等等。 1234567// 检测字符串中是否有特殊字符- (BOOL)checkSpecialCharacter:(NSString *)string&#123; NSString *regex = @\"[`~!@#$^&amp;*()=|&#123;&#125;':;',\\\\[\\\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“'。，、？]+\"; NSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES %@\", regex]; return [pred evaluateWithObject:string];&#125; 2.2 过滤集合谓词本身就代表了一个逻辑条件，计算谓词之后返回的结果永远为 BOOL 类型的值。而谓词最常用的功能就是对集合进行过滤。当程序使用谓词对集合元素进行过滤时，程序会自动遍历其元素，并根据集合元素来计算谓词的值，当这个集合中的元素计算谓词并返回 YES 时，这个元素才会被保留下来。请注意程序会自动遍历其元素，它会将自动遍历过之后返回为YES的值重新组合成一个集合返回。 1234567891011121314151617181920/** * @brief NSArray * @return 使用指定的谓词过滤 NSArray 集合，返回符合条件的元素组成的新集合 */- (NSArray&lt;ObjectType&gt; *)filteredArrayUsingPredicate:(NSPredicate *)predicate;/** * @brief 使用指定的谓词过滤 NSMutableArray，剔除集合中不符合条件的元素 */- (void)filterUsingPredicate:(NSPredicate *)predicate;/** * @brief NSSet */- (NSSet&lt;ObjectType&gt; *)filteredSetUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);/** * @brief NSMutableSet */- (void)filterUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0); 使用谓词过滤不可变集合和可变集合的区别是：过滤不可变集合时，会返回符合条件的集合元素组成的新集合；过滤可变集合时，没有返回值，会直接剔除不符合条件的集合元素。 2.3 在谓词中使用占位符参数上面所有的例子中谓词总是固定的，然而我们在现实中处理变量时决定了谓词应该是可变的。 首先如果我们想在谓词表达式中使用变量，那么我们需要了解下列两种占位符： %K：用于动态传入属性名%@：用于动态设置属性值 相当于变量名与变量值。 除此之外，还可以在谓词表达式中使用动态改变的属性值，就像环境变量一样。 12345678NSPredicate * predicate1 = [NSPredicate predicateWithFormat:@\"%K CONTAINS %@\", key, value];NSArray * filterArray = [array filteredArrayUsingPredicate:predicate];// 包含 $VALUE 字符串NSPredicate * predicateTemp = [NSPredicate predicateWithFormat:@\"%K &gt; $VALUE\", @\"age\"];// 指定 $VALUE 的值为 25NSPredicate * predicate2 = [predicateTemp predicateWithSubstitutionVariables:@&#123; @\"VALUE\" : @25&#125; ];filterArray = [array filteredArrayUsingPredicate:predicate2]; 三、文章sunny_zl &amp; iOS中的谓词（NSPredicate）使用","tags":[]},{"title":"静态、动态 pod","date":"2019-08-30T07:20:43.836Z","path":"2019/08/30/iOS/iOS原理/静态、动态 Pod/","text":"一、静态和动态在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。 当在 podfile 中指定 use_frameworks! 时，子模块和第三方类库将被打包成 .framework 动态库，模块之间的代码不能直接引用，需要添加依赖； 反之（默认情况）将打包成 .a 静态库。 动态库和静态库的区别： 资源加载方式 包的大小 编译速度 1.1 资源加载方式 s.dependency ‘xx’ 静态方式中各模块的 podspec 文件不用设置依赖，就可以直接 #import 其他模块的类头文件。 ￼ 而动态方式则会报错。 s.resources 1234s.resources = ['Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt&#125;', 'Resource/**/*']``` 图片等资源是都放入 mainbundle，直接用 imageNamed: 访问，不用增加很多获取 bundle 的代码。 s.resource = ‘xx/xxx.bundle’ s.resource_bundles = { ‘xxx’ =&gt; [‘/Classes//*.{xib,storyboard,Bundle,png,gif,jpg,jpeg,txt}’, ‘Resource//*’] } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 这两种写法，资源都在模块自己的 bundle 里面，文件名为 xxx.bundle，工程中需要通过 ``bundleForClass`` 等获取资源路径。 #### 1.2 包的大小&lt;center&gt;![](http://dzliving.com/StaticModule2.png)&lt;/center&gt;在图中，上面的是使用 use\\_frameworks! 的动态包， 下面的是默认（或使用 use\\_modular\\_headers!）的静态包，几次验证，都是&lt;font color=#cc0000&gt;动态的更小&lt;/font&gt;。#### 1.3 编译速度这个未验证。#### 1.4 工程实例在项目开发中的场景是一个第三方类库 bongSDK.framework 引入了 Realm.framework 和 RealmSwift.framework，RealmSwift.framework 是通过 swift 语言写的，它的内部调用 Realm。最初静态方式的 pod 遇到了难以理解的报错，因为知识的欠缺和时间的紧迫，放弃了静态这条路，使用 use\\_frameworks! 动态 pod 的方式。动态方式在 pod install 阶段没有报错，但子模块需要添加依赖，更困难的是图片、xib、storyboard 等资源需要获取到模块的 bundle 才能加载，导致工程大面积的图片加载错误，页面跳转崩溃。因此不得不增加很多获取 bundle 路径的代码，修改的位置几百上千处。```oc+ (NSBundle *)bundleWithClassName:(Class)cls moduleName:(NSString*)module&#123; if (module == nil) &#123; return [NSBundle mainBundle]; &#125; NSBundle * bundle = [NSBundle bundleForClass:cls]; NSURL * bundleURL = [bundle URLForResource:module withExtension:@\"bundle\"]; if (bundleURL == nil) &#123; __block UINavigationController* nav; [[UIApplication sharedApplication].windows enumerateObjectsUsingBlock:^(__kindof UIWindow * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; UIViewController * windowVC = obj.rootViewController; if ([windowVC isKindOfClass:[UINavigationController class]]) &#123; nav = (UINavigationController *)windowVC; *stop = YES; &#125; &#125;]; if (nav != nil) &#123; Class callerCls = [nav.viewControllers.firstObject class]; bundle = [NSBundle bundleForClass:callerCls]; bundleURL = [bundle URLForResource:module withExtension:@\"bundle\"]; &#125; if (bundleURL == nil) &#123; return [NSBundle mainBundle]; &#125; &#125; return [NSBundle bundleWithURL:bundleURL];&#125; 图片加载则更加困难，因为很多图片是在 xib 中写的，通过断点发现，系统并没有调用 imageNamed: 方法，导致使用 runtime 替换方法实现图片位置修改的方式失败，通过查找资料，发现 xib 中的 UIButton、UIImageView 会调用 - initWithCoder: 方法，底层会调用 UINibDecoder 类的 decodeObjectForKey。 runtime 替换 decodeObjectForKey 方法后，打印输出发现，UIButton、UIImageView 控件加载的图片名称在 UIResourceName 字段。由此就有了如下的处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118+ (void)load&#123; _imageViewImageArray = [NSMutableArray arrayWithCapacity:2]; propKey = [CYKJXUtil stringByReversed:@&quot;emaNecruoseRIU&quot;]; btnKey = [CYKJXUtil stringByReversed:@&quot;tnetnoClufetatSnottuBIU&quot;]; // hook UINibDecoder - decodeObjectForKey: NSString* clsName = [NSString stringWithFormat:@&quot;redoce%@biNIU&quot;, @&quot;D&quot;]; clsName = [CYKJXUtil stringByReversed:clsName]; [HookTool exchangeInstanceMethod:NSClassFromString(clsName) originalSEL:@selector(decodeObjectForKey:) swizzledSEL:@selector(swizzle_decodeObjectForKey:)]; // hook UIImageView - initWithCoder: [HookTool exchangeInstanceMethod:UIImageView.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_imageView_initWithCoder:)]; // hook UIButton - initWithCoder: [HookTool exchangeInstanceMethod:UIButton.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_button_initWithCoder:)];&#125;- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); // 保存图片名称 if ([key isEqualToString:propKey]) &#123; [_imageViewImageArray addObject:value]; &#125; // 保存 button 状态数据 if ([key isEqualToString:btnKey]) &#123; if ([value isKindOfClass:[NSDictionary class]]) &#123; _buttonImageDictionary = value; &#125; &#125; return value;&#125;#pragma mark - UIImageView- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; // 设置 image if (_imageViewImageArray.count &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:_imageViewImageArray[0]]; if (normalImage) &#123; instance.image = normalImage; &#125; &#125; // 设置 highlightedImage if (_imageViewImageArray.count &gt; 1) &#123; UIImage * highlightedImage = [HookTool imageAfterSearch:_imageViewImageArray[1]]; if (highlightedImage) &#123; instance.highlightedImage = highlightedImage; &#125; &#125; return instance;&#125;#pragma mark - UIButton- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; _buttonImageDictionary = nil; UIButton * instance = (UIButton *)[self swizzle_button_initWithCoder:aDecoder]; @autoreleasepool &#123; [_buttonImageDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; if (_imageViewImageArray.count == 0) &#123; *stop = YES; &#125; else &#123; switch ([key integerValue]) &#123; case ButtonImageOrder_Normal: [HookTool setImageForButton:instance object:obj state:UIControlStateNormal]; break; case ButtonImageOrder_Highlighted: [HookTool setImageForButton:instance object:obj state:UIControlStateHighlighted]; break; case ButtonImageOrder_Selected: [HookTool setImageForButton:instance object:obj state:UIControlStateSelected]; break; case ButtonImageOrder_Disabled: [HookTool setImageForButton:instance object:obj state:UIControlStateDisabled]; break; &#125; &#125; &#125;]; &#125; return instance;&#125; 更详细的代码：ImageTool 如上可见，这种动态方式对于编码并不友好，资源必须要特定的 bundle，一旦资源路径出错，轻则图片未加载，重则程序崩溃。 所以需要研究下如果使用静态方式 pod 子模块代码。 首先将 use_frameworks! 删除，重新执行 pod install，等 Pod installation complete! 之后，运行工程，报错，一个一个的解决。 dyld: Library not loaded: @rpath/Realm.framework/Realm 现在不用 pod 导入 realm，而是将 realm.framework 拖入 basicModule 工程。这里找了官方最新的 realm.framework，它分为静态版和动态版，添加到工程的 Embedded Binaries，编译时报错 Unknown type name namespace。 不管通过修改 .h 为 .hpp，还是修改 build settings -&gt; Compile Sources As -&gt; Objectoive-C++ 都没有效果，无计可施之时想到了，可以将 use_frameworks! 时 cocoapods 生成 的 Realm.framework 拷贝一份，拖入工程死马等活马医。 编译运行，这个问题解决了~ Argument list too long: recursive header expansion failed Search Paths -&gt; Header Search Paths，去掉 $(PODS_ROOT)/**，去掉不必要的 recursive search。 其余的就是解决一些资源加载问题，资源重名问题，动态库的引用问题 #import “” 改为 #import &lt;&gt;。 二、文章关于Argument list too long的问题","tags":[]},{"title":"NSMutableArray","date":"2019-08-28T06:32:46.298Z","path":"2019/08/28/iOS/iOS原理/NSMutableArray/","text":"一、线程安全二、NSCoding三、NSCoping四、for-in 和 enumerate1234567891011121314151617181920212223 NSMutableArray * mArr = [NSMutableArray arrayWithCapacity:10000]; for (int i = 0; i &lt; 10000; i++) &#123; [mArr addObject:@\"1\"]; &#125; CFTimeInterval begin1 = CACurrentMediaTime(); for (NSString * s in mArr) &#123; &#125; CFTimeInterval end1 = CACurrentMediaTime(); NSLog(@\"1-----%f\", end1 - begin1); CFTimeInterval begin2 = CACurrentMediaTime(); [mArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; &#125;]; CFTimeInterval end2 = CACurrentMediaTime(); NSLog(@\"2-----%f\", end2 - begin2); 2019-08-30 09:39:39.174152+0800 Demo[51351:647357] 1-----0.0000402019-08-30 09:39:39.174740+0800 Demo[51351:647357] 2-----0.000488 当循环内不做任何操作时，两者相差一个指数级，但时间消耗对于 app 来说都可以忽略不计。 123456789101112131415161718 for (NSString * s in mArr) &#123; NSLog(@\"1\"); NSLog(@\"2\"); &#125; [mArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\"1\"); NSLog(@\"2\"); &#125;]; 2019-08-30 09:43:49.206158+0800 Demo[51419:650339] 1-----3.5162112019-08-30 09:43:53.465185+0800 Demo[51419:650339] 2-----4.2587982019-08-30 09:51:57.107924+0800 Demo[51596:657059] 1-----3.8450852019-08-30 09:52:01.496830+0800 Demo[51596:657059] 2-----4.3887712019-08-30 09:52:50.881513+0800 Demo[51611:657906] 1-----3.9005252019-08-30 09:52:55.382088+0800 Demo[51611:657906] 2-----4.500293 如上增加相同的简单操作后，两者的是时间相差 0.5 - 0.7 秒，这样的时间差较为客观。但要注意：当修改循环内的操作时，两者的时间消耗并不确定谁更高效。 12345678910111213141516 for (NSString * s in mArr) &#123; NSLog(@\"%@\", s); &#125; [mArr enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\"%@\", obj); &#125;]; 2019-08-30 09:54:10.254080+0800 Demo[51636:659160] 1-----1.8792322019-08-30 09:54:11.944881+0800 Demo[51636:659160] 2-----1.6906102019-08-30 09:56:28.683932+0800 Demo[51670:660681] 1-----1.9237752019-08-30 09:56:30.353526+0800 Demo[51670:660681] 2-----1.6694752019-08-30 09:57:50.068303+0800 Demo[51697:661763] 1-----2.1195582019-08-30 09:57:51.737062+0800 Demo[51697:661763] 2-----1.668615 五、Hash12345678&#123; NSArray * arr = [NSArray new]; NSArray * arr2 = @[ @\"1\", @\"2\" ]; NSLog(@\"%ld, %ld\", arr.hash, arr2.hash);&#125;0, 2 数组的 hash 函数返回的是元素数量。 六、componentsJoinedByString1234567&#123; NSArray * arr2 = @[ @\"1\", @(1), [ViewController alloc] ]; NSLog(@\"%@\", [arr2 componentsJoinedByString:@\"|\"]);&#125; 1|1|&lt;ViewController: 0x7ff690c183d0&gt; 不同类型的对象也可以拼接起来。","tags":[]},{"title":"编程思想","date":"2019-08-17T15:41:19.406Z","path":"2019/08/17/iOS/iOS原理/编程思想/","text":"一、链式编程 链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。 123456789101112- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void)two&#123; NSLog(@&quot;2&quot;);&#125;[[self one] two]; 在 Objective-C 中，没有传递参数的方法可以写成点语法的方式。 1self.one.two; 上面的写法会产生警告：Property access result unused - getters should not be used for side effects。这是因为 two 方法被当成 getter 方法，getter 方法会有返回值，self.one.two 没有使用该返回值。 Objective-C : 点语法 + 事务 12345678910111213141516171819202122232425262728293031323334@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.one.two(@&quot;3&quot;);&#125;- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void(^)(NSString *))two&#123; NSLog(@&quot;2&quot;); return ^ (NSString * s) &#123; NSLog(@&quot;%@&quot;, s); &#125;;&#125;2019-08-17 19:45:34.079059+0800 Demo[858:23949] 12019-08-17 19:45:34.079188+0800 Demo[858:23949] 22019-08-17 19:45:34.079271+0800 Demo[858:23949] 3@end 经典使用链式编程思想的开源代码：Masonry 二、函数式编程在数学中 y = f(x), y = f(f(x)) 都是函数，x 既可以是一个简单的参数，也可以是一个表达式。 在 OC 中，将 block 作为参数传递可实现灵活的函数封装。 12345678910111213141516- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void)two:(void (^)(NSString *))block&#123; NSLog(@&quot;2&quot;); block(@&quot;3&quot;);&#125;[self.one two:^(NSString * s) &#123; NSLog(@&quot;%@&quot;, s);&#125;]; 函数式编程（Functional Programming）相对于要理解「函数」，我们更需要理解的其实是「状态」。 2.1 状态说到状态，很容易会联想到变量、局部变量、全局变量、property、model，这些都可以成为状态，但变量和状态又不是一回事，要真正理解状态，得先理解下面一行代码： 1int i = 0 简单的一行代码，分析起来却有不少门道。 「i」就是变量，一个变量可以看做是一个实体，真实存在于内存空间的实体。 int 是它的类型信息，是对于它的一种约束。 0 是它被赋予的一个值。 变量是我们要分析的目标。它的类型信息、值信息虽然会约束变量的行为，但不是我们关注的重点，真正让变量变得危险的是中间的等号，= 是个赋值操作，意味着改变 i 的值，原本处于静态的 i，由于一个 = 发生了变化，它的值可以变为 1，或者 10000，或者其他任何值，我们可以说这个变量有了状态。 状态也是个相对的概念，变量都有其生命周期，一旦变量被回收，其所包含的状态也随之消失，所以状态所带来的影响是受限于变量的生命周期的。 12345- (int)do&#123; int i = 0; return i;&#125; i 是函数 do 方法内部的临时变量，分配在内存的栈上。在 do 函数内部这个空间范畴来说，i 是有状态的，i 被赋予了值 0。一旦 return，i 的生命周期也随之结束，其所对应的状态也消失了。所以一旦出了do，i 又变得没有状态了。代码虽然执行了 return i，但返回的其实是 i 所代表的值，i 将自己的值交出来之后，就完成了自己的使命。 所以 do 函数的使用者是感受不到 i 的存在的，do 的调用方可以认为 do 是无状态（stateless）的，无状态意味着静止，静止的事物都是安全的，飞驰而过的火车和静止的石块，当然是后者感觉更安全。 我们编写代码的时候会经常谈论状态，函数的状态、类的状态、App 的状态，归根结底，我们所讨论的是：在某个空间范畴内会发生变化的变量。 函数式编程当中的函数 f(x) 强调无状态，其实是强调将状态锁定在函数的内部。一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，前面说过变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量。下面两个函数，一个入参是传值，一个入参是传变量： 123456789- (void)do:(int)value // 传值&#123; &#125; - (void)do:(NSMutableArray *)arr // 传变量&#123;&#125; 第一个没状态，对调用方来说是安全的，对整个app来说也是安全的，既避免了依赖外部的状态，也不会修改外部的状态，即：不会产生 side effect，没有副作用。 第二个 do 函数，不但是传入了变量，还是可以变化的变量，是真正意义上的外部状态。很有可能在你遍历这个 arr 的时候，外部某个同时执行的线程正在尝试改变这个 arr 里的元素。 所以让我来总结函数式编程当中的函数，可以一句话归结为：隔绝一切外部状态，传入值，输出值。 再看看函数式编程当中的纯函数（Pure Function）的定义: In computer programming, a function) may be considered a pure function if both of the following statements about the function hold: The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or bet`ween different executions of the program, nor can it depend on any external input from I/O devices (usually—see below). Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below). 纯函数即为函数式编程所强调的函数，上述两点可翻译为： ①、不依赖外部状态②、不改变外部状态 所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解：时间和空间。 2.2 时间变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。 时间的武器是赋值，赋予变量新的值，在不可预知的未来埋下隐患。 123456- (void)setUserName:(NSString *)name&#123; //before assignment _userName = name; //after assignment&#125; 一旦有了赋值操作，时间就找到了空隙，可以对代码的执行产生影响。或许是现在，或许是明天，或许是在 appDidFinishLaunch，或许是在 didReceiveMemoryWarning。 变量会随着时间变化。有状态的函数也会随着时间的流动产生不同的输出，Pure Function 却是对时间免疫的，纯函数没有状态，无论怎样去执行一个纯函数，它所输出的结果永远不会变。 2.3 空间如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。(线程安全问题) Pure Function 同样是对空间免疫的。 多线程的 bug 调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。 2.4 离不开的状态函数式编程通过 Pure Function，使得我们的代码经得起时间和空间的考验。 我们可以把一个 App 的代码按照函数式编程的方式，拆分成一个个合格的 pure function，再通过某种方式串联起来，要方便的串联函数，需要能像使用变量一样方便的使用函数。 一个 Pure Function 可以是 stateless 的，但 App 可以变成 stateless 吗？显然不能。 离开了变量和状态，我们很难完整的描述业务。用户购物车里的商品总是会发生变化，今天或明天，我们总是需要在一个地方接收这种变化，保存这种变化，继而反应这种变化。所以，大多数时候，我们离不开状态，但我们能做的是，将一定会变化的状态，锁定在尽可能小的时间和空间跨度之内，通过改变代码的组织方式或架构，将必须改变的难以管教的状态，囚禁在特定的模块代码之中，让不可控变得尽量可控。 其实，即使不严格遵从函数式编程，我们同样可以写出带有 Functional Programming 精髓的代码，一切的一切，都是对于状态（state）的理解。 NSMutableArray 的 copy 也是颇具函数式编程精髓的。 2.5 一等公民当我们把函数改造成 pure function 之后，会产生一些奇妙的化学连锁反应，这些反应甚至会改变我们的编程习惯。 一旦我们有了绝对安全的纯函数，我们当然希望能尽最大可能的去发挥它的价值，增加它出现和被使用的场景。为了加大纯函数的使用率，我们需要在语言层面做一些改造或者增强，以提高纯函数传递性。怎么增强呢？答案是将函数变为一等公民。 何谓公民？有身份证才叫公民，有身份证还能自由迁徙的就叫一等公民。 当我们的变量可以指向函数时，这个变量就有了函数的身份。当我们把这个变量当做函数的参数传入，或者函数的返回值传出的时候，这个变量就有了自由迁徙的能力。 一个函数 A，可以接收另一个函数 B 作为参数，然后再返回第三个函数 C 作为返回值。类似下面的一段swift代码： 12345func funcA(funcB: @escaping (Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; return &#123; input in return funcB(input) &#125; //funcC&#125; 在 funcA 的定义里，funcB 是作为参数传入，funcC（匿名的）是作为返回值返回。funcB 和 funcC 在这个语境里就称之为 first class function。而 funcA 作为 funcB 和 funcC 的管理者，有个更高端的称谓：high order function。 有了 first class function 和 high order function，我们还会收获另一个成果：语言的表达力更灵活，更简洁，更强大了。举个例子，我们写一段代码来实现一个功能：参加 party 前选一件衣服。用传统的方式来写： 123456789101112func chooseColor(gender: Int) -&gt; Int &#123; return 0&#125;func dressup(dressColor: Int) -&gt; Int &#123; return 1&#125; //imperativelet dressColor = chooseColor(gender: 1)let dress = dressup(dressColor: dressColor)user.dress = dress 先定义函数，再分三步依次调用 chooseColor, dressup，然后赋值。 如果用 first class function 和 high order function 的方式来写就是： 1234567891011121314func gotoParty(dressup: @escaping (Int) -&gt; Int, chooseColor: @escaping (Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; return &#123; gender in let dressColor = chooseColor(gender) return dressup(dressColor) &#125;&#125; // declarativelet prepare = gotoParty(dressup: &#123; color in return 1&#125;, chooseColor: &#123; gender in return 0&#125;)user.dress = prepare(1) gotoParty 函数糅合了 dressup 和 chooseColor，gotoParty 成了一个 high order function，当我们读 gotoParty 的代码的时候，这单一一个函数就将我们的目的和结果都表明了。 这就是 high order function 的神奇之处，原先啰啰嗦嗦的几句话变成一句话就说清楚了，它更接近我们自然语言的表达方式，比如 gotoParty 可以这样阅读：我要挑选一件颜色适合的衣服去参加 party，这样的代码是不是语意更简洁更美呢？ 注意，functional programming 并不会减少我们的代码量，它改变的只是我们书写代码的方式。 这种更为强大的表达力我们也有个行话来称呼它：declarative programming。而我们传统的代码表达方式（OOP当中所使用的方式）则叫做：imperative programming。 imperative programming 更强调实现的步骤，而 declarative programming 则重在表达我们想要的结果。这句话理解起来可能有些抽象，实在理解不了也没啥关系，只要记住declarative programming 能更简洁精炼的表达我们想要的结果即可。 以上都是我们将function变为一等公民所产生的结果，这一改变还有更多的妙用，比如lazy evaluation。 上述代码中的dressup和chooseColor虽然都是function，但是他们在传入gotoParty的时候并不会立马执行（evaluation），而是等gotoParty被执行的时候再一起执行。这也很大程度上增强了我们的表达能力，dressup和chooseColor都具备了lazy evaluation的属性，可以被拼装，被delay，最后在某一时刻才被执行。 所以，functional programming改变了我们使用函数的方式，之前使用 OOP，我们对于怎么处理变量（定义变量，修改值，传递值，等）轻车熟路，到了函数式编程的世界，我们要学会如何同函数打交道了，要能像使用变量一样灵活自如的使用函数，这在刚开始的时候确实需要一段适应期。 三、响应式编程在网上流传一个非常经典的解释｀响应式编程的概念｀ 在程序开发中： a ＝ b ＋ c赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化。响应式编程的目标就是：如果 b 或者 c 的数值发生变化，a 的数值会同时发生变化。 什么是响应式编程？ 响应式编程是一种编程范例，它处理异步数据流和特定的变更传播，按照特定顺序对执行环境（上下文）进行修改。 使用响应式编程有哪些好处？ 提高系统性能：使用响应式编程能提高处理大量数据的反应速度。提升用户体验：使用响应式编程能提升系统的响应能力。简化修改和维护：代码更容易理解。 所有都应该是响应式的么？ 响应式编程可以作为应用的一部分集成到应用中，没必要将已经证明有效的编程模式全部推倒。如果只是简单的网站，肯定没有必要应用响应式编程；如果需要引入推荐系统，引入响应式编程处理来大数据、高负载就是个好办法。 什么时候使用响应式编程？ 响应式编程是高负载、多用户应用的优雅的解决方案，像社交应用、游戏、音视频应用；此外，应用有以下模块也适合应用：需要大量交互的服务端代码、代理服务器/负载均衡器、人工智能/机器学习、实时数据流处理。 四、文章suiling &amp; 简单点，理解iOS与函数式编程阳仔dynamics &amp; ReactiveCocoa学习笔记（三）：响应式和函数响应式编程Why Reactive(Cocoa)?吴启辉 &amp; 关于响应式编程的十个问题","tags":[]},{"title":"dyld","date":"2019-08-07T08:13:26.814Z","path":"2019/08/07/iOS/iOS原理/dyld/","text":"一、介绍在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。 dyld 全称 the dynamic link editor，即动态链接器，其本质是 Mach-O 文件，是专门用来加载动态库的库。 源码下载地址：https://opensource.apple.com/tarballs/dyld/ dyld 会将 App 依赖的动态库和 App 文件加载到内存以后执行，动态库不是可执行文件，无法独自执行。当点击 App 的时候，系统在内核态完成一些必要配置，从 App 的 MachO 文件解析出 dyld 的地址，这里会记录在 MachO 的 LC_LOAD_DYLINKER 命令中，内容参考如下： 123456789 cmd LC_LOAD_DYLINKER cmdsize 28 name /usr/lib/dyld (offset 12)Load command 8 cmd LC_UUID cmdsize 24 uuid DF0F9B2D-A4D7-37D0-BC6B-DB0297766CE8Load command 9 cmd LC_VERSION_MIN_IPHONEOS dyld 位于 /usr/lib/dyld，可以从越狱机或者 mac 电脑中找到。以 mac 为例，终端执行命令： 12$ cd /usr/lib$ file dyld dyld 是 Mach-O 类型的通用二进制文件，支持 x86_64 和 i386 两种架构。iPhone 真机对应的 dyld 支持的为 arm 系列架构。 二、otool otool 是专门用来查看 Mach-O 类型文件的工具 Mac OS X 下二进制可执行文件的动态链接库是 dylib 文件。 dylib 也就是 bsd 风格的动态库。基本可以认为等价于 windows 的 dll 和 linux 的so。mac 基于 bsd，所以也使用的是 dylib。 Linux 下用 ldd 查看，苹果系统用 otool。 2.1 查看 otool 地址电脑已安装 Xcode。终端输入： 12345678910111213141516171819202122232425262728293031323334$ otoolUsage: /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ... -f print the fat headers -a print the archive header -h print the mach header -l print the load commands -L print shared libraries used -D print shared library id name -t print the text section (disassemble with -v) -p &lt;routine name&gt; start dissassemble from routine name -s &lt;segname&gt; &lt;sectname&gt; print contents of section -d print the data section -o print the Objective-C segment -r print the relocation entries -S print the table of contents of a library (obsolete) -T print the table of contents of a dynamic shared library (obsolete) -M print the module table of a dynamic shared library (obsolete) -R print the reference table of a dynamic shared library (obsolete) -I print the indirect symbol table -H print the two-level hints table (obsolete) -G print the data in code table -v print verbosely (symbolically) when possible -V print disassembled operands symbolically -c print argument strings of a core file -X print no leading addresses or headers -m don't use archive(member) syntax -B force Thumb disassembly (ARM objects only) -q use llvm's disassembler (the default) -Q use otool(1)'s disassembler -mcpu=arg use `arg' as the cpu for disassembly -j print opcode bytes -P print the info plist section as strings -C print linker optimization hints --version print the version of /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 由上可知 otool 的地址：/Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 进入地址发现 otool 文件是一个替身（软连接）。 查看 otool 指向的软连接地址： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283$ cd /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/$$ ls -ltotal 223352-r-xr-xr-x 1 cykj staff 33920 10 20 2018 ar-r-xr-xr-x 1 cykj staff 28000 10 20 2018 as-rwxr-xr-x 1 cykj staff 18176 10 20 2018 asa-rwxr-xr-x 1 cykj staff 212208 10 20 2018 bison-r-xr-xr-x 1 cykj staff 150048 10 20 2018 bitcode_striplrwxr-xr-x 1 cykj staff 5 11 22 2018 c++ -&gt; clang-rwxr-xr-x 1 cykj staff 23152 10 20 2018 c89-rwxr-xr-x 1 cykj staff 23248 10 20 2018 c99lrwxr-xr-x 1 cykj staff 5 11 22 2018 cc -&gt; clang-rwxr-xr-x 1 cykj staff 78705232 10 20 2018 clanglrwxr-xr-x 1 cykj staff 5 11 22 2018 clang++ -&gt; clang-r-xr-xr-x 1 cykj staff 120064 10 20 2018 cmpdylib-r-xr-xr-x 1 cykj staff 145872 10 20 2018 codesign_allocatelrwxr-xr-x 1 cykj staff 17 11 22 2018 codesign_allocate-p -&gt; codesign_allocate-rwxr-xr-x 1 cykj staff 4937600 10 20 2018 coremlcompiler-rwxr-xr-x 1 cykj staff 3344 9 26 2018 cpp-rwxr-xr-x 1 cykj staff 27712 10 20 2018 ctags-r-xr-xr-x 1 cykj staff 145824 10 20 2018 ctf_insertlrwxr-xr-x 1 cykj staff 13 11 22 2018 dsymutil -&gt; llvm-dsymutil-rwxr-xr-x 1 cykj staff 1006032 10 20 2018 dwarfdump-rwxr-xr-x 1 cykj staff 219088 10 20 2018 dyldinfo-rwxr-xr-x 2 cykj staff 569056 10 20 2018 flex-rwxr-xr-x 2 cykj staff 569056 10 20 2018 flex++lrwxr-xr-x 1 cykj staff 8 11 22 2018 gcov -&gt; llvm-cov-rwxr-xr-x 2 cykj staff 142336 10 20 2018 gm4-rwxr-xr-x 1 cykj staff 90960 10 20 2018 gperf-rwxr-xr-x 1 cykj staff 65520 10 20 2018 indent-r-xr-xr-x 1 cykj staff 136784 10 20 2018 install_name_tool-rwxr-xr-x 1 cykj staff 2480704 10 20 2018 ld-rwxr-xr-x 1 cykj staff 230 9 26 2018 lex-r-xr-xr-x 1 cykj staff 154592 10 20 2018 libtool-r-xr-xr-x 1 cykj staff 66000 10 20 2018 lipo-rwxr-xr-x 1 cykj staff 3320816 10 20 2018 llvm-cov-rwxr-xr-x 1 cykj staff 29723968 10 20 2018 llvm-dsymutil-rwxr-xr-x 1 cykj staff 10591472 10 20 2018 llvm-nm-rwxr-xr-x 1 cykj staff 11899296 10 20 2018 llvm-objdump-r-xr-xr-x 1 cykj staff 32672 10 20 2018 llvm-otool-rwxr-xr-x 1 cykj staff 1272096 10 20 2018 llvm-profdata-rwxr-xr-x 1 cykj staff 2873440 10 20 2018 llvm-size-rwxr-xr-x 1 cykj staff 3567 9 26 2018 lorder-rwxr-xr-x 2 cykj staff 142336 10 20 2018 m4-rwxr-xr-x 1 cykj staff 24800 10 20 2018 metal-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-ar-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-as-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-link-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-opt-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metallib-rwxr-xr-x 1 cykj staff 7604 9 26 2018 miglrwxr-xr-x 1 cykj staff 7 11 22 2018 nm -&gt; llvm-nm-r-xr-xr-x 1 cykj staff 132896 10 20 2018 nm-classic-r-xr-xr-x 1 cykj staff 162720 10 20 2018 nmeditlrwxr-xr-x 1 cykj staff 12 11 22 2018 objdump -&gt; llvm-objdumplrwxr-xr-x 1 cykj staff 10 11 22 2018 otool -&gt; llvm-otool-r-xr-xr-x 1 cykj staff 648720 10 20 2018 otool-classic-r-xr-xr-x 1 cykj staff 132784 10 20 2018 pagestufflrwxr-xr-x 1 cykj staff 7 11 22 2018 ranlib -&gt; libtool-rwxr-xr-x 1 cykj staff 59344 10 20 2018 rebase-r-xr-xr-x 1 cykj staff 204960 10 20 2018 redo_prebinding-rwxr-xr-x 1 cykj staff 73664 10 20 2018 rpcgen-r-xr-xr-x 1 cykj staff 48864 10 20 2018 segeditlrwxr-xr-x 1 cykj staff 9 11 22 2018 size -&gt; llvm-size-r-xr-xr-x 1 cykj staff 120080 10 20 2018 size-classic-r-xr-xr-x 1 cykj staff 120400 10 20 2018 strings-r-xr-xr-x 1 cykj staff 189568 10 20 2018 strip-rwxr-xr-x 1 cykj staff 87671328 10 20 2018 swiftlrwxr-xr-x 1 cykj staff 5 11 22 2018 swift-autolink-extract -&gt; swift-rwxr-xr-x 1 cykj staff 5031520 10 20 2018 swift-build-rwxr-xr-x 1 cykj staff 384480 10 20 2018 swift-build-tool-rwxr-xr-x 1 cykj staff 461136 10 20 2018 swift-demangle-rwxr-xr-x 1 cykj staff 5031552 10 20 2018 swift-package-rwxr-xr-x 1 cykj staff 5031472 10 20 2018 swift-run-rwxr-xr-x 1 cykj staff 53024 10 20 2018 swift-stdlib-tool-rwxr-xr-x 1 cykj staff 5031504 10 20 2018 swift-testlrwxr-xr-x 1 cykj staff 5 11 22 2018 swiftc -&gt; swift-rwxr-xr-x 1 cykj staff 12042320 10 20 2018 tapi-rwxr-xr-x 1 cykj staff 32592 10 20 2018 unifdef-rwxr-xr-x 1 cykj staff 2946 9 26 2018 unifdefall-rwxr-xr-x 1 cykj staff 59776 10 20 2018 unwinddump-rwxr-xr-x 1 cykj staff 135 9 26 2018 yacc 可以看到 otool 指向 llvm-otool，而 llvm-otool 和 otool 在同一个目录中。 另外，还可以发现，这个文件夹下面还有很多有用的文件，如 lipo。 2.2 otool -L 查看动态链接库 终端执行命令： 123456789$ cd /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-fpfdxjbemnwnqcfjimbqpbzpnpem/Build/Products/Debug-iphonesimulator/Demo.app/$$ otool -L DemoDemo: /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5) /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0) /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0) 查看动态库的依赖库： 12345678910111213$ otool -L /usr/lib/system/libdispatch.dylib/usr/lib/system/libdispatch.dylib: /usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 913.60.3) /usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 551.4.0) /usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 62.0.0) /usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 4570.71.8) /usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 161.50.1) /usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 301.50.1) /usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 140.50.6) /usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1244.50.9) /usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 67.0.0) /usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 35.3.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) 2.3 otool -ov 显示 Objective-C 类结构及其定义的方法。 终端执行命令： 123456789101112131415161718192021222324252627282930$ otool -ov DemoDemo:Contents of (__DATA,__objc_classlist) section00000001000041f0 0x100005080 _OBJC_CLASS_$_HookTool isa 0x1000050a8 _OBJC_METACLASS_$_HookTool superclass 0x0 _OBJC_CLASS_$_NSObject cache 0x0 __objc_empty_cache vtable 0x0 data 0x100004328 (struct class_ro_t *) flags 0x80 instanceStart 8 instanceSize 8 reserved 0x0 ivarLayout 0x0 name 0x100003555 HookTool baseMethods 0x1000042f0 (struct method_list_t *) entsize 24 count 2 name 0x1000028b3 swizzle_decodeObjectForKey: types 0x1000035c4 @24@0:8@16 imp 0x1000015f0 -[HookTool swizzle_decodeObjectForKey:] name 0x100002914 swizzle_button_initWithCoder: types 0x1000035c4 @24@0:8@16 imp 0x1000017c0 -[HookTool swizzle_button_initWithCoder:] baseProtocols 0x0 ivars 0x0 weakIvarLayout 0x0 baseProperties 0x0Meta Class ... 2.4 otool -tV [Mach-O] 查看 ARM 汇编码 1234567891011121314151617181920212223242526272829$ otool -tV DemoDemo:(__TEXT,__text) section+[HookTool load]:0000000100001400 pushq %rbp0000000100001401 movq %rsp, %rbp0000000100001404 subq $0x40, %rsp0000000100001408 movl $0x2, %eax000000010000140d movl %eax, %edx000000010000140f movq %rdi, -0x8(%rbp)0000000100001413 movq %rsi, -0x10(%rbp)0000000100001417 movq 0x3c1a(%rip), %rsi ## Objc class ref: _OBJC_CLASS_$_NSMutableArray000000010000141e movq 0x3b33(%rip), %rdi ## Objc selector ref: arrayWithCapacity:0000000100001425 movq %rdi, -0x20(%rbp)0000000100001429 movq %rsi, %rdi000000010000142c movq -0x20(%rbp), %rsi0000000100001430 callq *0x2bf2(%rip) ## Objc message: +[NSMutableArray arrayWithCapacity:]0000000100001436 movq %rax, %rdi0000000100001439 callq 0x10000265a ## symbol stub for: _objc_retainAutoreleasedReturnValue000000010000143e movq __imageViewImageArray(%rip), %rdx0000000100001445 movq %rax, __imageViewImageArray(%rip)000000010000144c movq %rdx, %rdi000000010000144f callq *0x2bdb(%rip) ## literal pool symbol address: _objc_release0000000100001455 leaq 0x2cb4(%rip), %rax ## Objc cfstring ref: @\"emaNecruoseRIU\"000000010000145c movq 0x3bdd(%rip), %rdx ## Objc class ref: HookTool0000000100001463 movq 0x3af6(%rip), %rsi ## Objc selector ref: stringByReversed:000000010000146a movq %rdx, %rdi ... 2.5 otool -h [Mach-O] 查看 Mach-O 头结构等 1234$ otool -h DemoMach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 2 21 3272 0x00200085 一个 Mach-O 的文件头结构为： 各字段的含义，可参看 /usr/include/mach-o/loader.h。 2.6 otool -l [Mach-O] | grep crypt1 查看 ipa 包是否加壳 12$ otool -l Demo | grep crypt1$ 没有进行过加壳处理。 123456 cryptoff 16384cryptsize 6651904 cryptid 0 cryptoff 16384cryptsize 6553600 cryptid 0123456 cryptid 代表是否加壳，1 - 加壳，0 - 已脱壳。 上面打印了两遍，其实代表着该可执行文件支持两种架构 armv7 和 arm64。 Mach-O 文件可以用 GUI 图形软件 MachOView 更加直观的查看相关信息。 三、dyld加载 动态库链接、load 方法执行都是在 main 函数执行之前的。 如图所示进行操作： 由上可知，load 的加载是从 __dyld_start 这个函数开始的。 3.1 __dyld_start系统内核在加载动态库前，会加载 dyld，然后调用去执行 __dyld_start（汇编语言实现）。该函数会执行 dyldbootstrap::start()，后者会执行 _main()函数，dyld 的加载动态库的代码就是从_main()开始执行的。这里可以查看 dyldStartup.s的部分内容（以x86_x64架构做参考)，其中标出了 _dyld_start() 与 dyldbootstrap 的 start 方法。 12345678910111213141516171819202122232425262728293031323334353637383940#if __x86_64__#if !TARGET_IPHONE_SIMULATOR .data .align 3__dyld_start_static: .quad __dyld_start#endif#if !TARGET_IPHONE_SIMULATOR .text .align 2,0x90 .globl __dyld_start__dyld_start: popq %rdi # param1 = mh of app pushq $0 # push a zero for debugger end of frames marker movq %rsp,%rbp # pointer to base of kernel frame andq $-16,%rsp # force SSE alignment subq $16,%rsp # room for local variables # call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) movl 8(%rbp),%esi # param2 = argc into %esi leaq 16(%rbp),%rdx # param3 = &amp;argv[0] into %rdx movq __dyld_start_static(%rip), %r8 leaq __dyld_start(%rip), %rcx subq %r8, %rcx # param4 = slide into %rcx leaq ___dso_handle(%rip),%r8 # param5 = dyldsMachHeader leaq -8(%rbp),%r9 call __ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm movq -8(%rbp),%rdi cmpq $0,%rdi jne Lnew # clean up stack and jump to \"start\" in main executable movq %rbp,%rsp # restore the unaligned stack pointer addq $8,%rsp # remove the mh argument, and debugger end frame marker movq $0,%rbp # restore ebp back to zero jmp *%rax # jump to the entry point # LC_MAIN case, set up stack for call to main() 3.2 dyldInitialization.cpp__dyld_start 内部调用 dyldbootstrap::start，位于 dyldInitialization.cpp。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// This is code to bootstrap dyld. This work in normally done for a program by dyld and crt.// In dyld we have to do this manually.//uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue)&#123; // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables // ①、获取 dyld 对应的 slide slide = slideOfMainExecutable(dyldsMachHeader); bool shouldRebase = slide != 0;#if __has_feature(ptrauth_calls) shouldRebase = true;#endif if ( shouldRebase ) &#123; // ②、通过 slide 对 dyld 进行 rebase rebaseDyld(dyldsMachHeader, slide); &#125; // allow dyld to use mach messaging // ③、mach 初始化 mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; // ④、栈溢出保护 while(*apple != NULL) &#123; ++apple; &#125; ++apple; // set up random value for stack canary __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);#endif // now that we are done bootstrapping dyld, call dyld's main // ⑤、获取应用的 slide（appsSlide） uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); // ⑥、调用 dyld 的 main 函数 return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);&#125; 3.3 slide、rebase由于 apple 采用了 ASLR（Address space layout randomization）技术，所以 Mach-O 每次加载到内存中的首地址是变化的，此时想找到代码在内存中对应的地址需要重定位 rebase。rebase 要用到 slide 值： 1234567891011121314151617181920212223242526272829//// The kernel may have slid a Position Independent Executable//static uintptr_t slideOfMainExecutable(const struct macho_header* mh)&#123; // Mach-O 文件中 load commands 数量 const uint32_t cmd_count = mh-&gt;ncmds; // 偏移地址到 load commands 的首地址 const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header)); const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; // 选中 cmd = LC_SEGMENT_COMMAND if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123; const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd; // 实际对应 LC_SEGMENT_COMMAND(_TEXT) if ( (segCmd-&gt;fileoff == 0) &amp;&amp; (segCmd-&gt;filesize != 0)) &#123; // Mach-O 文件首地址 - LC_SEGMENT_COMMAND(_TEXT).vmaddr return (uintptr_t)mh - segCmd-&gt;vmaddr; &#125; &#125; // 偏移 command 指针 cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; return 0;&#125; 应用本身的 Mach-O 及 dyld 采用的是 slideOfMainExecutable 的方式获取 slide。从上代码得知：side = Mach-O header 首地址 - Load Commands 中 __TEXT 段的 VM Address 的值。 1234567891011121314151617181920212223242526intptr_t _dyld_get_image_slide(const mach_header* mh)&#123; log_apis(\"_dyld_get_image_slide(%p)\\n\", mh); // 获取 Mach-O 文件加载对象 const MachOLoaded* mf = (MachOLoaded*)mh; // 如果 mach 文件头没有 magic 值 if ( !mf-&gt;hasMachOMagic() ) return 0; // 调用 MachOLoaded::getSlide() 方法 return mf-&gt;getSlide();&#125;intptr_t _dyld_get_image_vmaddr_slide(uint32_t imageIndex)&#123; log_apis(\"_dyld_get_image_vmaddr_slide(%d)\\n\", imageIndex); // 获取到 Mach-O 文件 const mach_header* mh = gAllImages.imageLoadAddressByIndex(imageIndex); if ( mh != nullptr ) // 调用上面的方法 return dyld3::_dyld_get_image_slide(mh); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435intptr_t MachOLoaded::getSlide() const&#123; // 诊断对象。 Diagnostics diag; __block intptr_t slide = 0; // 循环 load command forEachLoadCommand(diag, ^(const load_command* cmd, bool&amp; stop) &#123; // 64 位 if ( cmd-&gt;cmd == LC_SEGMENT_64 ) &#123; const segment_command_64* seg = (segment_command_64*)cmd; // LC_SEGMENT_64(__TEXT) if ( strcmp(seg-&gt;segname, \"__TEXT\") == 0 ) &#123; // mach-O 首地址 - LC_SEGMENT_64(__TEXT).vmaddr slide = (uintptr_t)(((uint64_t)this) - seg-&gt;vmaddr); stop = true; &#125; &#125; // 32 位 else if ( cmd-&gt;cmd == LC_SEGMENT ) &#123; const segment_command* seg = (segment_command*)cmd; // LC_SEGMENT(__TEXT) if ( strcmp(seg-&gt;segname, \"__TEXT\") == 0 ) &#123; // mach-O 首地址 - LC_SEGMENT(__TEXT).vmaddr slide = (uintptr_t)(((uint64_t)this) - seg-&gt;vmaddr); stop = true; &#125; &#125; &#125;); diag.assertNoError(); // any malformations in the file should have been caught by earlier validate() call return slide;&#125; 动态库加载采用的是 \\_dyld\\_get\\_image\\_vmaddr\\_slide 的方式获取 slide。 简单验证一下，以应用 Mach-O 为例： Load Commands __TEXT 段 VM Address 值。 VM Address 的地址为 4294967296（10进制）。 在 Demo 项目中 ViewController.m viewDidLoad 方法设置断点，触发后，在 lldb 执行 image list 应用 Mach-O 的地址为 0x00000001004f8000（16进制）。 计算 viewDidLoad 在应用 Mach-O 文件中的地址，symbol address = stack address - slide。 ①、用 Mach-O 的 VM Address 减去对应虚拟地址，得到的 5210112（10进制）为 slide 值； ②、获取 viewDidLoad 函数在当前内存中的地址； ③、用 viewDidLoad 内存地址减去 slide 得到它在 Mach-O 中对应的虚拟地址； ④、将 10 进制转化为 16 进制。 计算得到地址：0x00000001000022c0 在 Mach-O 文件中查看。 可以看到，通过计算得出的值 0x100001750 与 Mach-O 中看到的值一致。 当然，也可以通过命令行直接获取 slide 的值。 3.4 dyld::_main对 ASLR 有了基本认知后，接着看看位于 dyld.cpp 中的 _main 干了什么。 3.4.1 设置运行环境123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// Entry point for dyld. The kernel loads dyld and jumps to __dyld_start which// sets up some registers and call this function.//// Returns address of main() in target program which __dyld_start jumps to//uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123; launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (uint64_t)mainExecutableMH, 0, 0); &#125; // Grab the cdHash of the main executable from the environment uint8_t mainExecutableCDHashBuffer[20]; const uint8_t* mainExecutableCDHash = nullptr; if ( hexToBytes(_simple_getenv(apple, \"executable_cdhash\"), 40, mainExecutableCDHashBuffer) ) // 获取主程序 hash mainExecutableCDHash = mainExecutableCDHashBuffer; // Trace dyld's load // 告知 kernel，dyld 已加载 notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, \"dyld_file\"));#if !TARGET_IPHONE_SIMULATOR // Trace the main executable's load // 告知 kernel，主程序 Mach-O 已加载 notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, \"executable_file\"));#endif uintptr_t result = 0; // 赋值参数。 // mach_header 类型结构体，表示当前 App 的 Mach-O头部信息。有了头部信息，加载器就可以从头开始，遍历整个 Mach-O 文件的信息。 sMainExecutableMachHeader = mainExecutableMH; // long 类型数据，表示 ASLR 位移长度 sMainExecutableSlide = mainExecutableSlide;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if this is host dyld, check to see if iOS simulator is being run // 获取 dyld 路径 const char* rootPath = _simple_getenv(envp, \"DYLD_ROOT_PATH\"); if ( (rootPath != NULL) ) &#123; // look to see if simulator has its own dyld char simDyldPath[PATH_MAX]; strlcpy(simDyldPath, rootPath, PATH_MAX); strlcat(simDyldPath, \"/usr/lib/dyld_sim\", PATH_MAX); // 打开 dyld_sim 路径 int fd = my_open(simDyldPath, O_RDONLY, 0); // 成功 if ( fd != -1 ) &#123; // 如果是模拟器，并且正确加载`dyld_sim`，则直接返回主程序地址 const char* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result); if ( errMessage != NULL ) halt(errMessage); return result; &#125; &#125;#endif CRSetCrashLogMessage(\"dyld: launch started\"); // 设置一个全局链接上下文，包括一些回调函数、参数与标志设置信息，其中的 context 结构体实例、回调函数都是 dyld 自己的实现 setContext(mainExecutableMH, argc, argv, envp, apple); // Pickup the pointer to the exec path. // 获取主程序路径 sExecPath = _simple_getenv(apple, \"executable_path\"); // &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld if (!sExecPath) sExecPath = apple[0]; // 获取应用 Mach-O 文件的绝对路径 if ( sExecPath[0] != '/' ) &#123; // have relative path, use cwd to make absolute char cwdbuff[MAXPATHLEN]; if ( getcwd(cwdbuff, MAXPATHLEN) != NULL ) &#123; // maybe use static buffer to avoid calling malloc so early... char* s = new char[strlen(cwdbuff) + strlen(sExecPath) + 2]; strcpy(s, cwdbuff); strcat(s, \"/\"); strcat(s, sExecPath); sExecPath = s; &#125; &#125; // Remember short name of process for later logging // 设置进程名称 sExecShortName = ::strrchr(sExecPath, '/'); if ( sExecShortName != NULL ) ++sExecShortName; else sExecShortName = sExecPath; // 配置进程受限模式。根据当前进程是否受限，再次配置链接上下文以及其他环境参数 configureProcessRestrictions(mainExecutableMH); // 再次检测/设置上下文环境#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123; pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); &#125; else#endif &#123; checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); &#125;#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac) &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) &#123; gLinkContext.rootPaths = parseColonList(\"/System/iOSSupport\", NULL); gLinkContext.marzipan = true; if ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths ) sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths; if ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths ) sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths; &#125;#endif // 如果设置了DYLD_PRINT_OPTS，则打印参数 if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv); // 如果设置了DYLD_PRINT_ENV，则打印环境变量 if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); // 获取主程序架构信息 getHostInfo(mainExecutableMH, mainExecutableSlide); ... 从源码可以看到，在模拟器运行程序时，通过 dyld_sim 来进行后续加载工作的，与正常真机加载流程略有不同。 模拟器： 真机： 具体实现在 useSimulatorDyld 这个函数中，本文不做进一步解析。 这里还有一个知识点，环境变量 DYLD_PRINT_OPTS 与 DYLD_PRINT_ENV。在 processDyldEnvironmentVariable 方法中： 123456789 else if ( strcmp(key, \"DYLD_IMAGE_SUFFIX\") == 0 ) &#123; gLinkContext.imageSuffix = parseColonList(value, NULL); &#125; else if ( strcmp(key, \"DYLD_INSERT_LIBRARIES\") == 0 ) &#123; sEnv.DYLD_INSERT_LIBRARIES = parseColonList(value, NULL);#if SUPPORT_ACCELERATE_TABLES sDisableAcceleratorTables = true;#endif &#125; 在 secheme 添加这两个环境变量，对应的字段会被设置为 true，并不需要设置 value。 但是并非每个环境变量都不需要配置 value，如： 12345678910111213141516void processDyldEnvironmentVariable(const char* key, const char* value, const char* mainExecutableDir)&#123; if ( strcmp(key, \"DYLD_FRAMEWORK_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FRAMEWORK_PATH); &#125; else if ( strcmp(key, \"DYLD_FALLBACK_FRAMEWORK_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_FRAMEWORK_PATH); &#125; else if ( strcmp(key, \"DYLD_LIBRARY_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_LIBRARY_PATH); &#125; else if ( strcmp(key, \"DYLD_FALLBACK_LIBRARY_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_LIBRARY_PATH); &#125; ... 3.4.2 加载共享缓存dyld3 与 dyld 不同点在 _main 方法中可以看出。在 dyld 的 _main 方法中，完成第一步以后会初始化主 App，然后加载共享缓存。到了 dyld3，调整了顺序：加载缓存的步骤可以划分为 mapSharedCache 和 checkVersionedPaths，先执行 mapSharedCache，然后加载主 App，最后checkVersionedPaths。（苹果在 2017 年发布的 dyld3，视频链接） 对于共享缓存的理解：dyld 加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被 dyld 映射到内存中，之后，当任何 Mach-O 映像加载时，dyld 首先会检查该 Mach-O 映像及所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // load shared cache // 检查共享缓存是否可用 checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);#if TARGET_IPHONE_SIMULATOR // &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; // &lt;/HACK&gt;#endif // 非 Dont Use if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123; // 映射共享缓存到共享区 mapSharedCache(); &#125; // 缓存是否兼容（DyldSharedCache * loadAddress 为空 || 版本相同 -》YES） bool cacheCompatible = (sSharedCacheLoadInfo.loadAddress == nullptr) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion); // 设置了 DYLD_USE_CLOSURES || 在白名单 if ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) &#123; &#125; else &#123; if ( gLinkContext.verboseWarnings ) // 不使用closure，因为共享缓存格式版本与 dyld 不匹配 dyld::log(\"dyld: not using closure because shared cache format version does not match dyld's\\n\"); &#125; // could not use closure info, launch old way // install gdb notifier stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB); stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages); // make initial allocations large enough that it is unlikely to need to be re-alloced sImageRoots.reserve(16); sAddImageCallbacks.reserve(4); sRemoveImageCallbacks.reserve(4); sAddLoadImageCallbacks.reserve(4); sImageFilesNeedingTermination.reserve(16); sImageFilesNeedingDOFUnregistration.reserve(8); #if !TARGET_IPHONE_SIMULATOR#ifdef WAIT_FOR_SYSTEM_ORDER_HANDSHAKE // &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);#endif#endif try &#123; // add dyld itself to UUID list // 添加 dyld 的 UUID 到共享缓存 UUID 列表中 addDyldImageToUUIDList(); ...&#125; 检测共享缓存是否可用； 如果可用，映射共享缓存到共享区； 添加 dyld 的 UUID 到缓存列表。 其中，检测共享缓存是否可用的函数 checkSharedRegionDisable 中有两句注释： 123456789101112131415161718192021static void checkSharedRegionDisable(const dyld3::MachOLoaded* mainExecutableMH, uintptr_t mainExecutableSlide)&#123;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if main executable has segments that overlap the shared region, then disable using the shared region // 如果主程序 Mach-O 有 segments 与共享区重叠，那么共享区不可用。并且，iOS 不开启共享区无法运行。 // 检测两者是否重叠 if ( mainExecutableMH-&gt;intersectsRange(SHARED_REGION_BASE, SHARED_REGION_SIZE) ) &#123; gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion; if ( gLinkContext.verboseMapping ) dyld::warn(\"disabling shared region because main executable overlaps\\n\"); &#125;#if __i386__ if ( !gLinkContext.allowEnvVarsPath ) &#123; // &lt;rdar://problem/15280847&gt; use private or no shared region for suid processes gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; &#125;#endif#endif // iOS cannot run without shared region&#125; 具体检测代码： 123456789101112131415161718bool MachOLoaded::intersectsRange(uintptr_t start, uintptr_t length) const&#123; __block bool result = false; uintptr_t slide = getSlide(); forEachSegment(^(const SegmentInfo&amp; info, bool&amp; stop) &#123; /* ①、主程序 segment 中的虚拟地址 + 虚拟地址大小 + 偏移量 &gt;= 共享区起始地址 ②、主程序 segment 中的虚拟地址 + 偏移量 &lt; 共享区终止地址 ① 和 ② 同时 YES，那么认为主程序 Mach-O 有 segments 与共享区重叠，此时共享区不可用，从而动态库缓存不可用 疑问：地址是从高到低分配？ */ if ( (info.vmAddr+info.vmSize+slide &gt;= start) &amp;&amp; (info.vmAddr+slide &lt; start+length) ) result = true; &#125;); return result;&#125; 可以看到这段检测代码在满足重叠条件后，并没有设置 stop = true 停止 forEachLoadCommand 中的循环，这里值得深究和讨论。 加载共享缓存最核心的步骤在 mapSharedCache 中： 12345678910111213141516171819202122232425262728static void mapSharedCache()&#123; dyld3::SharedCacheOptions opts; opts.cacheDirOverride = sSharedCacheOverrideDir; opts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion); #if __x86_64__ &amp;&amp; !TARGET_IPHONE_SIMULATOR opts.useHaswell = sHaswell;#else opts.useHaswell = false;#endif opts.verbose = gLinkContext.verboseMapping; // 加载 dyld 缓存 loadDyldCache(opts, &amp;sSharedCacheLoadInfo); // update global state // 更新进程的全局状态信息 if ( sSharedCacheLoadInfo.loadAddress != nullptr ) &#123; gLinkContext.dyldCache = sSharedCacheLoadInfo.loadAddress; dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate; dyld::gProcessInfo-&gt;sharedCacheSlide = sSharedCacheLoadInfo.slide; dyld::gProcessInfo-&gt;sharedCacheBaseAddress = (unsigned long)sSharedCacheLoadInfo.loadAddress; sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID); dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (const uuid_t *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[0], &#123;0,0&#125;, &#123;&#123; 0, 0 &#125;&#125;, (const mach_header *)sSharedCacheLoadInfo.loadAddress); &#125;&#125; SharedCacheRuntime.cpp 文件： 1234567891011121314151617181920212223242526272829303132bool loadDyldCache(const SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)&#123; results-&gt;loadAddress = 0; results-&gt;slide = 0; results-&gt;errorMessage = nullptr; #if TARGET_IPHONE_SIMULATOR // simulator only supports mmap()ing cache privately into process // 模拟器只支持 mmap（内存映射） 缓存到当前进程 return mapCachePrivate(options, results);#else if ( options.forcePrivate ) &#123; // mmap cache into this process only // 只加载 mmap（内存映射） 缓存到当前进程 return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region bool hasError = false; // 已加载过的 if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; // 未加载过的 else &#123; // slow path: this is first process to load cache hasError = mapCacheSystemWide(options, results); &#125; return hasError; &#125;#endif&#125; 加载缓存分三种情况： ①、仅加载到当前进程。通过 mapCachePrivate() 加载并返回错误信息；②、已经加载过的。通过 reuseExistingCache() 加载并返回错误信息，同时返回是否加载过 BOOL 值；③、未加载过的。通过 mapCacheSystemWide() 加载缓存并映射，返回错误信息。 options.forcePrivate 的定义： 12345678910111213// dyld.cppopts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion) gLinkContext.sharedRegionMode = ImageLoader::kUseSharedRegion; // ImageLoader.hclass ImageLoader &#123;public: ... enum SharedRegionMode &#123; kUseSharedRegion, kUsePrivateSharedRegion, kDontUseSharedRegion, kSharedRegionIsSharedCache &#125;; ... &#125; gLinkContext.sharedRegionMode 在 setContext() 方法中设置默认值，默认值为 kUseSharedRegion，也就是之前检测共享区是否可用的标识值。 3.4.3 实例化主程序系统会对已经映射到进程空间的主程序（在 XNU 解析 MachO 阶段就完成了映射操作）创建一个ImageLoaderMachO，再将其加入到 master list 中（sAllImages）。如果加载的 MachO 的硬件架构与本设备相符，就执行 imageLoader 的创建和添加操作。其中主要实现是ImageLoaderMachO::instantiateMainExecutable方法，该方法将主 App 的 MachHeader、ASLR，文件路径和前面提到的链接上下文作为参数，做 imageLoader 的实例化操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... CRSetCrashLogMessage(sLoadingCrashMessage); // instantiate ImageLoader for main executable // 实例化主程序 sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); gLinkContext.mainExecutable = sMainExecutable; // 代码签名 gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH); #if TARGET_IPHONE_SIMULATOR // check main executable is not too new for this OS // 检测主程序是否支持当前设备版本 &#123; // 检查是否是模拟器二进制文件 if ( ! isSimulatorBinary((uint8_t*)mainExecutableMH, sExecPath) ) &#123; throwf(\"program was built for a platform that is not supported by this runtime\"); &#125; uint32_t mainMinOS = sMainExecutable-&gt;minOSVersion(); // dyld is always built for the current OS, so we can get the current OS version // from the load command in dyld itself. // 获取 dyld 中存储的当前 OS 版本 uint32_t dyldMinOS = ImageLoaderMachO::minOSVersion((const mach_header*)&amp;__dso_handle); // 应用 mach-O 文件的版本超过了当前模拟器设备的版本，抛出异常 if ( mainMinOS &gt; dyldMinOS ) &#123; #if TARGET_OS_WATCH throwf(\"app was built for watchOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #elif TARGET_OS_TV throwf(\"app was built for tvOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #else throwf(\"app was built for iOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #endif &#125; &#125;#endif #if __MAC_OS_X_VERSION_MIN_REQUIRED // &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries uint32_t mainSDK = sMainExecutable-&gt;sdkVersion(); gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures; #else // simulators, iOS, tvOS, and watchOS are always strict gLinkContext.strictMachORequired = true; #endif #if SUPPORT_ACCELERATE_TABLES sAllImages.reserve((sAllCacheImagesProxy != NULL) ? 16 : INITIAL_IMAGE_COUNT); #else sAllImages.reserve(INITIAL_IMAGE_COUNT); #endif // Now that shared cache is loaded, setup an versioned dylib overrides #if SUPPORT_VERSIONED_PATHS checkVersionedPaths(); // 设置加载的动态库版本。这里的动态库还没有包括经 DYLD_INSERT_LIBRARIES 插入的库。 #endif // dyld_all_image_infos image list does not contain dyld // add it as dyldPath field in dyld_all_image_infos // for simulator, dyld_sim is in image list, need host dyld added // dyld 加载的 image_infos 并不包含 dyld 本身，它被放到 dyld_all_image_infos 的 dyldPath 字段中去了。而对于模拟器，dyld 加载的 image_infos 是包含 dyld_sim 的。#if TARGET_IPHONE_SIMULATOR // get path of host dyld from table of syscall vectors in host dyld void* addressInDyld = gSyscallHelpers;#else // get path of dyld itself void* addressInDyld = (void*)&amp;__dso_handle;#endif // 获取 dyld 路径并与 gProcessInfo-&gt;dyldPath 对比 char dyldPathBuffer[MAXPATHLEN+1]; int len = proc_regionfilename(getpid(), (uint64_t)(long)addressInDyld, dyldPathBuffer, MAXPATHLEN); if ( len &gt; 0 ) &#123; dyldPathBuffer[len] = '\\0'; // proc_regionfilename() does not zero terminate returned string // 如果不同将获取到的路径复制给 gProcessInfo-&gt;dyldPath if ( strcmp(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != 0 ) gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer); &#125; ...&#125; dyld_all_image_infos 是个结构体，同样分为 32 位和 64 位两个版本，分别对应 dyld_all_image_infos_32 与 dyld_all_image_infos_64，由于获取 dyld_all_image_infos 需要用到一些未开源信息，这里为了方便，从侧面验证一下这条注释信息： 12345678910#import &lt;mach-o/dyld.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; for (uint32_t i = 0; i &lt; _dyld_image_count(); ++i) &#123; NSLog(@\"%s\", _dyld_get_image_name(i)); &#125;&#125; 模拟器： 真机： 可以看到：模拟器打印的 image 没有 dyld，第 0 个 image 是 dyld_sim，第一个 image 才是主程序；真机打印出的加载 image 中也没有 dyld，第 0 个 image 是主程序。 回到最核心的 instantiateFromLoadedImage 实例化主程序函数： 123456789101112131415161718// The kernel maps in main executable before dyld gets control. We need to // make an ImageLoader* for the already mapped in main executable.// kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化成 ImageLoader 加载到内存中交给 dyld 管理static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader // CPU 架构是否匹配 if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; // 实例化 ImageLoader 对象。参数：macho header、ASLR、执行路径、链接上下文 ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); // 分配主程序image的内存，更新。 addImage(image); return (ImageLoaderMachO*)image; &#125; throw \"main executable not a known format\";&#125; kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化ImageLoader 对象，加载到内存，返回交给 dyld 管理。 123456789101112131415161718192021222324252627282930// create image for main executableImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)&#123; //dyld::log(\"ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\\n\", // sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed)); bool compressed; unsigned int segCount; unsigned int libCount; const linkedit_data_command* codeSigCmd; const encryption_info_command* encryptCmd; // sniffLoadCommands 函数会对主程序 Mach-O进 行一系列的校验：对代码签名，MachO加密，动态库数量，段的数量相关信息的 loadCommand 做解析，提取出 command 数据。 /* case LC_DYLD_INFO: case LC_DYLD_INFO_ONLY: *compressed = true; */ sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd); // instantiate concrete class based on content of load commands // 已解密 if ( compressed ) // Compressed return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context); else#if SUPPORT_CLASSIC_MACHO // Classic return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);#else throw \"missing LC_DYLD_INFO load command\";#endif&#125; sniffLoadCommands 的校验并不包括对主程序 Mach-O 的解密操作，解密操作是由 xnu 完成的。 ImageLoaderMachOCompressed::instantiateMainExecutable、ImageLoaderMachOClassic::instantiateMainExecutable 两者内部的逻辑相同，只是返回类型一个是 ImageLoaderMachOCompressed 一个是 ImageLoaderMachOClassic。 以 ImageLoaderMachOCompressed 为例： 123456789101112131415161718192021222324252627282930313233343536// create image for main executableImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, unsigned int segCount, unsigned int libCount, const LinkContext&amp; context)&#123; // 初始化 image ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount); // set slide for PIE programs // 设置 image 偏移量 image-&gt;setSlide(slide); // for PIE record end of program, to know where to start loading dylibs if ( slide != 0 ) // 设置动态库起始地址 fgNextPIEDylibAddress = (uintptr_t)image-&gt;getEnd(); // 禁用段覆盖检测 image-&gt;disableCoverageCheck(); // 结束 image 上下文 image-&gt;instantiateFinish(context); // 设置 image 加载状态为 dyld_image_state_mapped image-&gt;setMapped(context); if ( context.verboseMapping ) &#123; dyld::log(\"dyld: Main executable mapped %s\\n\", path); for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123; const char* name = image-&gt;segName(i); if ( (strcmp(name, \"__PAGEZERO\") == 0) || (strcmp(name, \"__UNIXSTACK\") == 0) ) dyld::log(\"%18s at 0x%08lX-&gt;0x%08lX\\n\", name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i)); else dyld::log(\"%18s at 0x%08lX-&gt;0x%08lX\\n\", name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i)); &#125; &#125; return image;&#125; 12345void ImageLoader::setMapped(const LinkContext&amp; context)&#123; fState = dyld_image_state_mapped; context.notifySingle(dyld_image_state_mapped, this, NULL); // note: can throw exception&#125; instantiateFinish() 在内部解析 loadCmds、设置动态库连接信息、设置符号表相关信息等。setMapped() 内部调用 notifySingle 进行处理。 3.4.4 加载插入的动态库1234567891011121314151617181920uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // load any inserted libraries // 插入动态库 if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123; for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; // record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others. // 记录插入的动态库个数 sInsertedDylibCount = sAllImages.size()-1; ...&#125; 如果配置了 DYLD_INSERT_LIBRARIES 环境变量，通过loadInsertedDylib() 方法插入配置的动态库。对于越狱插件而言，其实就是通过添加 DYLD_INSERT_LIBRARIES 这个环境变量达到加载插件的目的。 123456789101112131415161718192021222324252627282930static void loadInsertedDylib(const char* path)&#123; ImageLoader* image = NULL; unsigned cacheIndex; try &#123; LoadContext context; context.useSearchPaths = false; context.useFallbackPaths = false; context.useLdLibraryPath = false; context.implicitRPath = false; context.matchByInstallName = false; context.dontLoad = false; context.mustBeBundle = false; context.mustBeDylib = true; context.canBePIE = false; context.enforceIOSMac = true; context.origin = NULL; // can't use @loader_path with DYLD_INSERT_LIBRARIES context.rpath = NULL; image = load(path, context, cacheIndex); &#125; catch (const char* msg) &#123; if ( gLinkContext.allowInsertFailures ) dyld::log(\"dyld: warning: could not load inserted library '%s' into hardened process because %s\\n\", path, msg); else halt(dyld::mkstringf(\"could not load inserted library '%s' because %s\\n\", path, msg)); &#125; catch (...) &#123; halt(dyld::mkstringf(\"could not load inserted library '%s'\\n\", path)); &#125;&#125; 内部构建 context 后调用 load() 函数生成 image。 1234567891011121314151617181920212223242526272829303132333435363738394041/*** @brief 做路径展开，搜索查找，排重，以及缓存查找工作。其中路径的展开和搜索分几个阶段（phase）*/ImageLoader* load(const char* path, const LoadContext&amp; context, unsigned&amp; cacheIndex)&#123; ... // 查找 image ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL); // 没有找到 if ( image != NULL ) &#123; // 继续查找 CRSetCrashLogMessage2(NULL); return image; &#125; // try all path permutations and try open() until first success std::vector&lt;const char*&gt; exceptions; image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);#if !TARGET_IPHONE_SIMULATOR // &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache // 在共享缓存中查找 if ( image == NULL) image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);#endif CRSetCrashLogMessage2(NULL); if ( image != NULL ) &#123; // &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables for (std::vector&lt;const char*&gt;::iterator it = exceptions.begin(); it != exceptions.end(); ++it) &#123; free((void*)(*it)); &#125; // if loaded image is not from cache, but original path is in cache // set gSharedCacheOverridden flag to disable some ObjC optimizations if ( !gSharedCacheOverridden &amp;&amp; !image-&gt;inSharedCache() &amp;&amp; image-&gt;isDylib() &amp;&amp; cacheablePath(path) &amp;&amp; inSharedCache(path) ) &#123; gSharedCacheOverridden = true; &#125; return image; &#125; ...&#125; load 方法不仅被 loadInsertedDylib 调用，也会被 dlopen 等运行时加载动态库的方法使用。 内部有一整套 loadPhase0~loadPhase6 的流程来查找及加载 image。如果在共享缓存中找到则直接调用 instantiateFromCache 实例化 image，否则通过 loadPhase5open 打开文件并调用loadPhase6，内部通过 instantiateFromFile 实例化 image，最后再调用 checkandAddImage 将image 加载进内存。 这些 phase 的搜索路径对应各个环境变量：DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。 ImageLoaderMachO 的 instantiateFromFile、instantiateFromCache 是 loader 将 MachO 文件解析映射到内存的核心方法，两个都会进入 Compressed 和 Classic 的分叉步骤。以 Compressed 下的 instantiateFromFile 来分析。 1234567891011121314151617181920212223242526272829303132333435363738// create image by mapping in a mach-o fileImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateFromFile(const char* path, int fd, const uint8_t* fileData, size_t lenFileData, uint64_t offsetInFat, uint64_t lenInFat, const struct stat&amp; info, unsigned int segCount, unsigned int libCount, const struct linkedit_data_command* codeSigCmd, const struct encryption_info_command* encryptCmd, const LinkContext&amp; context)&#123; ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart((macho_header*)fileData, path, segCount, libCount); try &#123; // record info about file image-&gt;setFileInfo(info.st_dev, info.st_ino, info.st_mtime); // if this image is code signed, let kernel validate signature before mapping any pages from image // ①、交给内核去验证动态库的代码签名 image-&gt;loadCodeSignature(codeSigCmd, fd, offsetInFat, context); // Validate that first data we read with pread actually matches with code signature // ②、映射到内存的 first page, （4k大小）与代码签名是否match。在这里会执行沙盒，签名认证 image-&gt;validateFirstPages(codeSigCmd, fd, fileData, lenFileData, offsetInFat, context); // mmap segments image-&gt;mapSegments(fd, offsetInFat, lenInFat, info.st_size, context); // if framework is FairPlay encrypted, register with kernel // 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据cryptid是否为1做了解密操作。 image-&gt;registerEncryption(encryptCmd, context); // probe to see if code signed correctly image-&gt;crashIfInvalidCodeSignature(); // finish construction image-&gt;instantiateFinish(context); ... &#125;&#125; 其中几个需要留意的步骤： 交给内核去验证动态库的代码签名 loadCodeSignature。 映射到内存的 first page（4k 大小）与代码签名是否 match。在这里会执行沙盒，签名认证，对于在线上运行时加载动态库的需求，可以重点研究这里。 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息 registerEncryption。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据 cryptid 是否为 1 做了解密操作。 如果走到 Phase6, 会调 xmap 函数将动态库从本地 mmap 到用户态内存空间。 根据上面的分析，主程序 imageLoader 在全局 image 表的首位，后面的是插入的动态库的 imageLoader，每个动态库对应一个 loader。 3.4.5 链接主程序链接所有动态库，进行符号修正绑定工作。 123456789101112131415161718192021222324uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // link main executable gLinkContext.linkingMainExecutable = true;#if SUPPORT_ACCELERATE_TABLES if ( mainExcutableAlreadyRebased ) &#123; // previous link() on main executable has already adjusted its internal pointers for ASLR // work around that by rebasing by inverse amount sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide); &#125;#endif // 链接主程序 link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) &#123; gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; &#125; ...&#125; 可以看到，主程序的链接是通过 link 这个函数完成的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)&#123; // add to list of known images. This did not happen at creation time for bundles // 添加到已知镜像列表中。这在创建 bundles 时没有处理。 if ( image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked() ) addImage(image); // we detect root images as those not linked in yet // 在根镜像中检测是否尚未链接 if ( !image-&gt;isLinked() ) addRootImage(image); // process images try &#123; const char* path = image-&gt;getPath();#if SUPPORT_ACCELERATE_TABLES if ( image == sAllCacheImagesProxy ) path = sAllCacheImagesProxy-&gt;getIndexedPath(cacheIndex);#endif // 调用 ImageLoader::link() 链接 image-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); &#125; catch (const char* msg) &#123; // 标记 image 为未使用，处理 garbageCollectImages(); throw; &#125;&#125; void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)&#123; //dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload); // clear error strings (*context.setErrorStrings)(0, NULL, NULL, NULL); // 起始时间。用于记录时间间隔 uint64_t t0 = mach_absolute_time(); // ①、递归加载主程序依赖的库，完成之后发送一个状态为 dyld_image_state_dependents_mapped的通知。 this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly); // we only do the loading step for preflights 只做预检的装载步骤 if ( preflightOnly ) return; uint64_t t1 = mach_absolute_time(); // 清空 image 层级关系 context.clearAllDepths(); // 递归更新 image 层级关系 this-&gt;recursiveUpdateDepth(context.imageCount()); __block uint64_t t2, t3, t4, t5; &#123; dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0); t2 = mach_absolute_time(); // ②、递归修正自己和依赖库的基地址，因为 ASLR 的原因，需要根据随机 slide 修正基地址。 this-&gt;recursiveRebase(context); context.notifyBatch(dyld_image_state_rebased, false); t3 = mach_absolute_time(); if ( !context.linkingMainExecutable ) // ③、递归绑定 noLazy 的符号表，lazy的符号会在运行时动态绑定（首次被调用才去绑定） this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) // ④、绑定弱符号表，比如未初始化的全局变量就是弱符号。 this-&gt;weakBind(context); t5 = mach_absolute_time(); &#125; if ( !context.linkingMainExecutable ) context.notifyBatch(dyld_image_state_bound, false); uint64_t t6 = mach_absolute_time(); std::vector&lt;DOFInfo&gt; dofs; // ⑤、递归获取/注册程序的 DOF 节区，dtrace 会用其动态跟踪。 this-&gt;recursiveGetDOFSections(context, dofs); // 注册 context.registerDOFs(dofs); uint64_t t7 = mach_absolute_time(); // interpose any dynamically loaded images if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123; dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0); // 递归应用插入的动态库 this-&gt;recursiveApplyInterposing(context); &#125; // clear error strings (*context.setErrorStrings)(0, NULL, NULL, NULL); // 计算出各种时间间隔 fgTotalLoadLibrariesTime += t1 - t0; fgTotalRebaseTime += t3 - t2; fgTotalBindTime += t4 - t3; fgTotalWeakBindTime += t5 - t4; fgTotalDOF += t7 - t6; // done with initial dylib loads fgNextPIEDylibAddress = 0;&#125; 内部加载动态库、rebase、绑定符号表、注册dofs信息等，同时还计算各步骤的耗时。如果想获取这些耗时，只需要在环境变量中添加 DYLD_PRINT_STATISTICS 就可以了，这个环境变量不需要 value。 在步骤 ① 里，递归加载主 App 在打包阶段就确定好的动态库的操作，会使用前面提到的 setContext 里的链接上下文，调用它的 loadLibrary 方法；然后优先去加载依赖的动态库。loadLibary 的实现在设置链接上下文的时候就已经赋值确定，即 libraryLocator，在这个方法里会用到上面提到的 load 方法。 在步骤 ③ 里，会有符号绑定的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041/*** @brief recursiveBind 完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，对于 DYLD_BIND_AT_LAUNCH 等特殊情况下的 non-lazy 符号才执行立即绑定。*/void ImageLoader::recursiveBind(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)&#123; // Normally just non-lazy pointers are bound immediately. // The exceptions are: // 1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately // 2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately if ( fState &lt; dyld_image_state_bound ) &#123; // break cycles fState = dyld_image_state_bound; try &#123; // bind lower level libraries first for(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload); &#125; // bind this image // 绑定。this 表示递归调用时，recursiveBind 方法的调用者 this-&gt;doBind(context, forceLazysBound); // mark if lazys are also bound if ( forceLazysBound || this-&gt;usablePrebinding(context) ) fAllLazyPointersBound = true; // mark as never-unload if requested if ( neverUnload ) this-&gt;setNeverUnload(); // 通知 context.notifySingle(dyld_image_state_bound, this, NULL); &#125; catch (const char* msg) &#123; // restore state fState = dyld_image_state_rebased; CRSetCrashLogMessage2(NULL); throw; &#125; &#125;&#125; 方法的核心是 ImageLoaderMach 的 doBind，读取 image 的动态链接信息的 bind_off 与 bind_size 来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用 bindAt 函数；调用 resolve 解析完符号表后，调用 bindLocation 完成最终的绑定操作，需要绑定的符号信息有三种： BIND_TYPE_POINTER：需要绑定的是一个指针。直接将计算好的新值屿值即可。 BIND_TYPE_TEXT_ABSOLUTE32：一个32位的值。取计算的值的低32位赋值过去。 BIND_TYPE_TEXT_PCREL32：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。 对延迟绑定的实现感兴趣的可以在Xcode中调试查看，或者参考这个。 3.4.6 链接插入的动态库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses // 链接其他被插入的动态库 if ( sInsertedDylibCount &gt; 0 ) &#123; // 循环处理 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; // 链接 link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); // 递归修改 image 的 fNeverUnload 属性 image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works // 只有插入可插入的库。在绑定所有插入的库后注册插入信息，以便链接工作 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); &#125; &#125; // &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES // 即使没有 DYLD_INSERT_LIBRARIES，dyld 也应该支持插入 for (long i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123; ImageLoader* image = sAllImages[i]; if ( image-&gt;inSharedCache() ) continue; image-&gt;registerInterposing(gLinkContext); &#125; #if SUPPORT_ACCELERATE_TABLES // !TARGET_IPHONE_SIMULATOR，非模拟器 if ( (sAllCacheImagesProxy != NULL) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123; // Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled // 加速键表不能与隐式插入一起使用，因此在禁用加速键表的情况下重新启动 ImageLoader::clearInterposingTuples(); // unmap all loaded dylibs (but not main executable) // 取消映射所有加载的 dylib 文件，除了主程序 for (long i=1; i &lt; sAllImages.size(); ++i) &#123; ImageLoader* image = sAllImages[i]; if ( image == sMainExecutable ) continue; if ( image == sAllCacheImagesProxy ) continue; image-&gt;setCanUnload(); ImageLoader::deleteImage(image); &#125; // note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table sAllImages.clear(); sImageRoots.clear(); sImageFilesNeedingTermination.clear(); sImageFilesNeedingDOFUnregistration.clear(); sAddImageCallbacks.clear(); sRemoveImageCallbacks.clear(); sAddLoadImageCallbacks.clear(); sDisableAcceleratorTables = true; sAllCacheImagesProxy = NULL; // 下次不再进入 sMappedRangesStart = NULL; mainExcutableAlreadyRebased = true; gLinkContext.linkingMainExecutable = false; resetAllImages(); // 跳转回上面的步骤，重新执行，加载所有的镜像 goto reloadAllImages; &#125; #endif // apply interposing to initial set of images for(int i=0; i &lt; sImageRoots.size(); ++i) &#123; // 是调用 ImageLoader::applyInterposing()，不是 ClosureWriter.cpp。内部递归，最终是执行 doInterpose() 方法 sImageRoots[i]-&gt;applyInterposing(gLinkContext); &#125; // 插入信息存入 dyld 缓存 ImageLoader::applyInterposingToDyldCache(gLinkContext); // 修改主程序插入标识 gLinkContext.linkingMainExecutable = false; // Bind and notify for the main executable now that interposing has been registered // 从主程序开始调用，递归执行绑定、通知（插入信息已经注册） uint64_t bindMainExecutableStartTime = mach_absolute_time(); // 内部执行 doBind()、notifySingle() sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); uint64_t bindMainExecutableEndTime = mach_absolute_time(); // 绑定和通知处理时间 ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime; gLinkContext.notifyBatch(dyld_image_state_bound, false); // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount &gt; 0 ) &#123; for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; // 绑定插入的动态库 image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); &#125; &#125; ...&#125; 这里参与链接的动态库根据第 4 步中加载的插入的动态库，从 sAllImages 的第二个 imageLoader 开始，取出 image，重复 link 操作进行连接。registerInterposing 内部会加载 loadCmds 并查找 __interpose 及 __DATA 段，读取段信息保存到 fgInterposingTuples 中，然后调用 applyInterposing，内部调用 recursiveApplyInterposing，通过这个函数调用到 doInterpose。 123456789101112131415161718192021222324252627void ImageLoaderMachOCompressed::doInterpose(const LinkContext&amp; context)&#123; if ( context.verboseInterposing ) dyld::log(\"dyld: interposing %lu tuples onto image: %s\\n\", fgInterposingTuples.size(), this-&gt;getPath()); // update prebound symbols。更新预绑定的符号 eachBind(context, ^(const LinkContext&amp; ctx, ImageLoaderMachOCompressed* image, uintptr_t addr, uint8_t type, const char* symbolName, uint8_t symbolFlags, intptr_t addend, long libraryOrdinal, ExtraBindData *extraBindData, const char* msg, LastLookup* last, bool runResolver) &#123; // 直接调用 interposeAt() return ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags, addend, libraryOrdinal, extraBindData, msg, last, runResolver); &#125;); eachLazyBind(context, ^(const LinkContext&amp; ctx, ImageLoaderMachOCompressed* image, uintptr_t addr, uint8_t type, const char* symbolName, uint8_t symbolFlags, intptr_t addend, long libraryOrdinal, ExtraBindData *extraBindData, const char* msg, LastLookup* last, bool runResolver) &#123; // 直接调用 interposeAt() return ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags, addend, libraryOrdinal, extraBindData, msg, last, runResolver); &#125;);&#125; interposeAt 通过 interposedAddress 在上文提到的 fgInterposingTuples 中找到需要替换的符号地址进行替换。 3.4.7 弱符号绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked // 弱符号绑定 sMainExecutable-&gt;weakBind(gLinkContext); ...&#125;void ImageLoader::weakBind(const LinkContext&amp; context)&#123; if ( context.verboseWeakBind ) dyld::log(\"dyld: weak bind start:\\n\"); uint64_t t1 = mach_absolute_time(); // get set of ImageLoaders that participate in coalecsing ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing]; unsigned imageIndexes[fgImagesRequiringCoalescing]; // 合并所有动态库的弱符号到列表中 int count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes); // count how many have not already had weakbinding done int countNotYetWeakBound = 0; int countOfImagesWithWeakDefinitionsNotInSharedCache = 0; for(int i=0; i &lt; count; ++i) &#123; if ( ! imagesNeedingCoalescing[i]-&gt;weakSymbolsBound(imageIndexes[i]) ) // 获取未进行绑定的弱符号的个数 ++countNotYetWeakBound; if ( ! imagesNeedingCoalescing[i]-&gt;inSharedCache() ) // 获取在共享缓存中已绑定的弱符号个数 ++countOfImagesWithWeakDefinitionsNotInSharedCache; &#125; // don't need to do any coalescing if only one image has overrides, or all have already been done if ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; 0) &amp;&amp; (countNotYetWeakBound &gt; 0) ) &#123; // make symbol iterators for each ImageLoader::CoalIterator iterators[count]; ImageLoader::CoalIterator* sortedIts[count]; for(int i=0; i &lt; count; ++i) &#123; // 对需要绑定的弱符号排序 imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i, imageIndexes[i]); sortedIts[i] = &amp;iterators[i]; if ( context.verboseWeakBind ) dyld::log(\"dyld: weak bind load order %d/%d for %s\\n\", i, count, imagesNeedingCoalescing[i]-&gt;getIndexedPath(imageIndexes[i])); &#125; // walk all symbols keeping iterators in sync by // only ever incrementing the iterator with the lowest symbol int doneCount = 0; while ( doneCount != count ) &#123; //for(int i=0; i &lt; count; ++i) // dyld::log(\"sym[%d]=%s \", sortedIts[i]-&gt;loadOrder, sortedIts[i]-&gt;symbolName); //dyld::log(\"\\n\"); // increment iterator with lowest symbol // 计算弱符号偏移量及大小，绑定弱符号 if ( sortedIts[0]-&gt;image-&gt;incrementCoalIterator(*sortedIts[0]) ) ++doneCount; ... &#125;&#125; 主要流程：合并所有动态库的弱符号到列表中 -&gt; 对需要绑定的弱符号排序 -&gt; 计算弱符号偏移量及大小，绑定弱符号 3.4.8 初始化主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... CRSetCrashLogMessage(\"dyld: launch, running initializers\"); #if SUPPORT_OLD_CRT_INITIALIZATION // Old way is to run initializers via a callback from crt1.o if ( ! gRunInitializersOldWay ) // 初始化主程序 initializeMainExecutable(); #else // run all initializers // 初始化主程序 initializeMainExecutable(); #endif // notify any montoring proccesses that this process is about to enter main() // 通知任何监视进程，此进程将要进入main（）。 if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123; dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); &#125; notifyMonitoringDyldMain(); ...&#125; void initializeMainExecutable()&#123; // record that we've reached this step。开始初始化标识 gLinkContext.startedInitializingMainExecutable = true; // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount &gt; 1 ) &#123; for(size_t i=1; i &lt; rootCount; ++i) &#123; // 初始化动态库 sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]); &#125; &#125; // run initializers for main executable and everything it brings up // 初始化主程序 sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); // register cxa_atexit() handler to run static terminators in all loaded images when this process exits if ( gLibSystemHelpers != NULL ) (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); // dump info if requested if ( sEnv.DYLD_PRINT_STATISTICS ) ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]); if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS ) ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);&#125; 先初始化动态库，然后初始化主程序。上文提到的 DYLD_PRINT_STATISTICS 环境变量在这里也出现了，除此之外还有个 detail 版的环境变量 DYLD_PRINT_STATISTICS_DETAILS。 1234567891011121314151617181920212223242526272829303132333435363738394041void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo)&#123; uint64_t t1 = mach_absolute_time(); // 获取线程 mach_port_t thisThread = mach_thread_self(); ImageLoader::UninitedUpwards up; up.count = 1; up.images[0] = this; // 在进程中初始化 processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); mach_port_deallocate(mach_task_self(), thisThread); uint64_t t2 = mach_absolute_time(); // 初始化耗时 fgTotalInitTime += (t2 - t1);&#125;// &lt;rdar://problem/14412057&gt; upward dylib initializers can be run too soon// To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs// have their initialization postponed until after the recursion through downward dylibs// has completed.void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread, InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)&#123; uint32_t maxImageCount = context.imageCount()+2; ImageLoader::UninitedUpwards upsBuffer[maxImageCount]; ImageLoader::UninitedUpwards&amp; ups = upsBuffer[0]; ups.count = 0; // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. for (uintptr_t i=0; i &lt; images.count; ++i) &#123; images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups); &#125; // If any upward dependencies remain, init them. if ( ups.count &gt; 0 ) // 递归调用 processInitializers(context, thisThread, timingInfo, ups);&#125; 动态库和主程序的初始化是调用 runInitializers，内部通过 processInitializers 调用 recursiveInitialization 递归初始化当前 image 所依赖的库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)&#123; // 递归锁 recursive_lock lock_info(this_thread); recursiveSpinLock(lock_info); if ( fState &lt; dyld_image_state_dependents_initialized-1 ) &#123; uint8_t oldState = fState; // break cycles // 退出递归循环 fState = dyld_image_state_dependents_initialized-1; try &#123; // initialize lower level libraries first // 先初始化低级别的库 for(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) &#123; // don't try to initialize stuff \"above\" me yet // 不要试图初始化级别高于我的 if ( libIsUpward(i) ) &#123; uninitUps.images[uninitUps.count] = dependentImage; uninitUps.count++; &#125; else if ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123; dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps); &#125; &#125; &#125; // record termination order. 记录终止命令 if ( this-&gt;needsTermination() ) context.terminationRecorder(this); // let objc know we are about to initialize this image uint64_t t1 = mach_absolute_time(); fState = dyld_image_state_dependents_initialized; oldState = fState; // context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo); // initialize this image // 真正初始化镜像 bool hasInitializers = this-&gt;doInitialization(context); // let anyone know we finished initializing this image fState = dyld_image_state_initialized; oldState = fState; context.notifySingle(dyld_image_state_initialized, this, NULL); if ( hasInitializers ) &#123; uint64_t t2 = mach_absolute_time(); timingInfo.addTime(this-&gt;getShortName(), t2-t1); &#125; &#125; catch (const char* msg) &#123; // this image is not initialized fState = oldState; recursiveSpinUnLock(); throw; &#125; &#125; recursiveSpinUnLock();&#125; 注意内部有个调用 context.notifySingle(dyld_image_state_initialized, this, NULL)，其实每次 image 状态改变都会调用 notifySingle 这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)&#123; //dyld::log(\"notifySingle(state=%d, image=%s)\\n\", state, image-&gt;getPath()); std::vector&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers); if ( handlers != NULL ) &#123; dyld_image_info info; info.imageLoadAddress = image-&gt;machHeader(); info.imageFilePath = image-&gt;getRealPath(); info.imageFileModDate = image-&gt;lastModified(); for (std::vector&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123; const char* result = (*it)(state, 1, &amp;info); if ( (result != NULL) &amp;&amp; (state == dyld_image_state_mapped) ) &#123; //fprintf(stderr, \" image rejected by handler=%p\\n\", *it); // make copy of thrown string so that later catch clauses can free it const char* str = strdup(result); throw str; &#125; &#125; &#125; if ( state == dyld_image_state_mapped ) &#123; // &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache if ( !image-&gt;inSharedCache() ) &#123; dyld_uuid_info info; if ( image-&gt;getUUID(info.imageUUID) ) &#123; info.imageLoadAddress = image-&gt;machHeader(); addNonSharedCacheImageUUID(info); &#125; &#125; &#125; if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) &#123; uint64_t t0 = mach_absolute_time(); dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); uint64_t t1 = mach_absolute_time(); uint64_t t2 = mach_absolute_time(); uint64_t timeInObjC = t1-t0; uint64_t emptyTime = (t2-t1)*100; if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != NULL) ) &#123; timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC); &#125; &#125; // mach message csdlc about dynamically unloaded images if ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123; notifyKernel(*image, false); const struct mach_header* loadAddress[] = &#123; image-&gt;machHeader() &#125;; const char* loadPath[] = &#123; image-&gt;getPath() &#125;; notifyMonitoringDyld(true, 1, loadAddress, loadPath); &#125;&#125; 当 state == dyld_image_state_mapped 时，将 image 对应的 UUID 存起来，当state == dyld_image_state_dependents_initialized 并且有 sNotifyObjCInit 回调时调用sNotifyObjCInit函数。 搜索回调函数赋值入口： 12345678910111213141516void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; // record functions to call sNotifyObjCMapped = mapped; sNotifyObjCInit = init; sNotifyObjCUnmapped = unmapped; ...&#125; void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125; 发现是通过 _dyld_objc_notify_register 这个函数注册回调的。 [NSObject load] 的堆栈： 1234567891011121314151617181920212223* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2 * frame #0: 0x000000010944f3b1 libobjc.A.dylib`+[NSObject load] frame #1: 0x000000010943d317 libobjc.A.dylib`call_load_methods + 691 frame #2: 0x000000010943e814 libobjc.A.dylib`load_images + 77 frame #3: 0x0000000108b73b97 dyld_sim`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 260 frame #4: 0x000000010b779bf3 libdyld.dylib`_dyld_objc_notify_register + 113 frame #5: 0x000000010944ca12 libobjc.A.dylib`_objc_init + 115 frame #6: 0x000000010b7015c0 libdispatch.dylib`_os_object_init + 13 frame #7: 0x000000010b70f4e5 libdispatch.dylib`libdispatch_init + 300 frame #8: 0x0000000109e05a78 libSystem.B.dylib`libSystem_initializer + 164 frame #9: 0x0000000108b82b96 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 506 frame #10: 0x0000000108b82d9c dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40 frame #11: 0x0000000108b7e3fc dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 324 frame #12: 0x0000000108b7e392 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 218 frame #13: 0x0000000108b7d5d3 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 133 frame #14: 0x0000000108b7d665 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 73 frame #15: 0x0000000108b71333 dyld_sim`dyld::initializeMainExecutable() + 129 frame #16: 0x0000000108b75434 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4384 frame #17: 0x0000000108b70630 dyld_sim`start_sim + 136 frame #18: 0x00000001155c1234 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2238 frame #19: 0x00000001155bf0ce dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 522 frame #20: 0x00000001155ba503 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1167 frame #21: 0x00000001155ba036 dyld`_dyld_start + 54 可以看到，_dyld_objc_notify_register 是在初始化 libobjc.A.dylib 这个动态库时调用的，然后 _objc_init 内部调用了 load_images，进而调用 call_load_methods，从而调用各个类中的load方法，Objc源码。 notifySingle 调用完毕后，开始真正初始化工作 doInitialization： 123456789101112bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; CRSetCrashLogMessage2(this-&gt;getPath()); // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); CRSetCrashLogMessage2(NULL); return (fHasDashInit || fHasInitializers);&#125; doImageInit 执行 LC_ROUTINES_COMMAND segment 中保存的函数，doModInitFunctions执行 __DATA,__mod_init_func section 中保存的函数。这个 section 中保存的是 C++ 的构造函数及带有 attribute((constructor)) 的 C 函数，简单验证一下： 12345678910111213141516171819202122232425262728// ViewController.mm class Test &#123;public: Test();&#125;; Test::Test()&#123; NSLog(@&quot;%s&quot;, __func__);&#125; Test test; __attribute__((constructor)) void testConstructor() &#123; NSLog(@&quot;%s&quot;, __func__);&#125; - (void)viewDidLoad &#123; [super viewDidLoad]; testConstructor(); Test * t = new Test();&#125; 2019-08-19 13:26:33.587051+0800 Demo[7105:314102] testConstructor2019-08-19 13:26:33.587109+0800 Demo[7105:314102] Test 通过 MachOView 可以看到： 显然，__mod_init_func 中的函数在类对应的 load 方法之后调用。 对于 dumpdcrypted 这一类注入方法实现功能的插件，他们添加的静态方法会在 doModInitFunctions方法中被解析出来，位置在 MachO 文件的 __DATA 段的 __mod_init_func section。C++ 的全局对象也会出现在这个section中。 在递归初始化 (recursiveInitialization）中，如果当前执行的是主程序 image，doInitialization 完毕后会执行 notifySingle 方法去通知观察者。在 doInitialization 方法前会发送 state 为 dyld_image_state_dependents_initialized 的通知，由这个通知，会调用 libobjc 的 load_images，最后去依次调用各个 OC 类的 load 方法以及分类的 load 方法。 Objective-C 的入口方法是 _objc_init，dyld 唤起它的执行路径是从 runInitializers -&gt; recursiveInitialization -&gt; doInitialization -&gt; doModInitFunctions -&gt;.. _objc_init。 12345678void _objc_init(void)&#123; // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_2_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; _objc_init 会在 dyld 中注册两个通知，对应的回调会分别执行将 OC 类加载到内存和调用 load 方法的操作。后面的就是 OC 类加载的经典方法 map_2_images 了。 从 recursiveInitialization 的以下代码片段可以看出 load 是在全局实例或者方法调用前被触发的。 1234567context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo);// initialize this imagebool hasInitializers = this-&gt;doInitialization(context);// let anyone know we finished initializing this imagefState = dyld_image_state_initialized;oldState = fState;context.notifySingle(dyld_image_state_initialized, this, NULL); 3.4.9 查找主程序入口函数指针并返回调用getEntryFromLC_MAIN 获取主程序 main 函数的地址，如果未找到则调用getEntryFromLC_UNIXTHREAD 获取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void* ImageLoaderMachO::getEntryFromLC_MAIN() const&#123; const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; if ( cmd-&gt;cmd == LC_MAIN ) &#123; entry_point_command* mainCmd = (entry_point_command*)cmd; void* entry = (void*)(mainCmd-&gt;entryoff + (char*)fMachOData); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; else throw \"LC_MAIN entryoff is out of range\"; &#125; cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; return NULL;&#125; void* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() const&#123; const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; if ( cmd-&gt;cmd == LC_UNIXTHREAD ) &#123; #if __i386__ const i386_thread_state_t* registers = (i386_thread_state_t*)(((char*)cmd) + 16); void* entry = (void*)(registers-&gt;eip + fSlide); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #elif __x86_64__ const x86_thread_state64_t* registers = (x86_thread_state64_t*)(((char*)cmd) + 16); void* entry = (void*)(registers-&gt;rip + fSlide); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #elif __arm64__ &amp;&amp; !__arm64e__ // temp support until &lt;rdar://39514191&gt; is fixed const uint64_t* regs64 = (uint64_t*)(((char*)cmd) + 16); void* entry = (void*)(regs64[32] + fSlide); // arm_thread_state64_t.__pc // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #endif &#125; cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; throw \"no valid entry point\";&#125; 可以看到，入口是在 load_command 的 LC_MAIN 或者 LC_UNIXTHREAD 中 LC_MAIN。 四、dyld 闭包在第 2 步和第 3 步之间有一个查找闭包并以其结果作为程序入口返回的代码，这里是 WWDC 2017 推出的 dyld3 中提出的一种优化 App 启动速度的技术。大致步骤如下： 如果满足条件：开启闭包（DYLD_USE_CLOSURES 环境变量为 1），App 的路径在白名单中（目前只有系统 Ap p享有使用闭包的特权），共享缓存加载地址不为空，则往下执行。 去内存中查找闭包数据，这里的方法是 findClosure。如果内存中不存在，再去 /private/var/staged_system_apps 路径下去查找硬盘数据，找到就返回结果。 如果没有闭包数据，就会调用 socket 通信走 RPC 去获取闭包数据，执行方法为 callClosureDaemon，感兴趣可以研究下。 如果闭包数据不为空，就会走核心方法：launchWithClosure，基于闭包去启动 App，并且返回该方法中获取的程序入口地址给外界。这个方法重复了上面的各个步骤。具体实现和内部的数据结构有待分析。 五、共享缓存机制在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个一个加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到 /System/Library/Caches/com.apple.dyld/ 目录下，按不同的架构保存分别保存着，原作者的 iPhone6 里面就有 dyld_shared_cache_armv7s 和 dyld_shared_cache_armv64 两个文件，如下图所示。 想要分析某个系统库，就需要从 dyld_shared_cache 里先将的原始二进制文件提取出来，这里从易到难提供 3 种方法： 5.1 dyld_cache_extract 提取dyld_cache_extract 是一个可视化的工具，使用极其简单，把 dyld_shared_cache 载入即可解析出来，如下图所示。 5.2 jtool 提取以提取 CFNetwork 为例，使用如下命令即可： 1$ jtool -extract CFNetwork ./dyld_shared_cache_arm64 5.3 dsc_extractor 提取在 dyld 源代码的 launch-cache 文件夹里面找到 dsc_extractor.cpp，将 653 行的“#if 0”修改为“#if 1”，然后用如下命令编译生成 dsc_extractor，并使用它提取所有缓存文件： 12$ clang++ dsc_extractor.cpp dsc_iterator.cpp -o dsc_extractor$ ./dsc_extractor ./dyld_shared_cache_arm64 ./ 六、总结每个 MachO 都会由一个 imageLoader 来处理加载和依赖管理的操作，这里是由 dyld 来安排。主程序 app 的 image 的加载是由内核来完成的。其他的动态库的加载细节可以参考上面提到的 link 方法实现，当一个 image 加载完毕，dyld 会发送 dyld_image_state_bound 通知；著名的 hook 工具 fishhook 的实现原理也是借助监听这个通知，在回调里完成 hook 操作的。 七、文章01_Jack &amp; dyld源码解读伊织__ &amp; Mac - otoolRemisKrlet &amp; App启动过程 - dyld加载动态库dyld详解","tags":[]},{"title":"终端","date":"2019-08-06T05:54:23.090Z","path":"2019/08/06/IT/终端/","text":"1、github clone 提速 在 IPAddress.com 网站中中分别查询 https://www.github.com 和 github.global.ssl.fastly.net 域名的 IP 地址。 打开的 hosts 文件 【Windows】 1C:\\Windows\\System32\\drivers\\etc\\host 【Mac】 1$ sudo vi /etc/hosts 更多阅读 2、重启 Finder 进程1~ $ killall Finder 3、修改图片1$ sips -s format png *.* --out pngs","tags":[]},{"title":"算法设计策略","date":"2019-08-05T16:07:52.660Z","path":"2019/08/06/算法/算法设计策略/","text":"一、分治1.1 基本思想 将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，分而治之。 能用分治法的基本特征： ①、问题缩小到一定规模容易解决 ②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想） ③、分解而成的小问题在解决之后要可以合并 ④、子问题是相互独立的，即子问题之间没有公共的子问题 第 ③ 条是能分治的关键。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。#### 1.2 分治步骤①、分解成很多子问题②、解决这些子问题③、将解决的子问题合并从而解决整个大问题化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。它的一般的算法设计模式如下：Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将 P 分解为较小的子问题 P1, P2, …, Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi6. T ← MERGE(y1,y2,…,yk) △ 合并子问题7. return(T)#### 1.3 分类根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形：1. 原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可；2. 原始问题的解需要由各个子问题的解再经过综合处理得到。#### 1.4 效果适当运用分治策略往往可以较快地缩小问题求解的范围，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好符合递归的特性。因此，计算机算法中的分治策略往往与递归联系在一起。#### 1.5 算法的典型应用 ①、MAXMIN问题 ②、二分搜索 ③、归并排序 ④、寻找第 K 小的元素 ⑤、大整数的乘法 ⑥、Strassen 矩阵乘法 ⑦、快速排序 ⑧、二叉树遍历 ⑨、棋盘覆盖 ⑩、线性时间选择最接近点对问题循环赛日程表汉诺塔。。。#### 1.6 依据分治法设计程序时的思维过程实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。①、一定是先找到最小问题规模时的求解方法；②、然后考虑随着问题规模增大时的求解方法；③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。文章：分治算法详解## 二、减治#### 2.1 基本思想减治技术利用了一种关系：一个问题给定实例的解和同样问题较小实例的解之间的关系。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡）有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫增量法。一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。#### 2.2 分类减治法有 3 种主要的变种：1. 减去一个常量2. 减去一个常数因子3. 减去的规模是可变的#### 2.3 减去一个常量每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。函数 f(n) = an 可以用一递归定义来计算f(n) = f(n-1) * a 如果 n &gt; 1 f(n) = a 如果 n = 1 虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！ 2.4 减去常量因子每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。 计算 an 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 an/2 的值；它们之间有着明显的关系： an = (an/2)2。 an = (an/2)2 n 是正偶数 an = (a(n-1)/2)2 * a n 是大于 1 的奇数，先提出一个 a 来再减半 an = a n = 1 上式递归根据所做的乘法次数来度量效率，该算法属于 O(log n); 因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。 2.5 减可变规模每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法 2.6 算法思想的典型应用减去一个常量： ①、插入排序 ③、深度优先查找 ④、广度优先查找 ⑤、拓扑排序（源删除法对无环有向图进行拓扑排序） ⑥、生成排列 ⑦、生成子集 减去常量因子： ①、折半查找 ②、假币问题 ③、俄式乘法 ④、约瑟夫斯问题 减可变规模 ①、插值查找、二叉查找树 ②、欧几里得算法，随着不断求余，n 越来越小 三、分治减治区别分治法：求解多个子问题（每个子问题都需要求解），合并子问题的解。 减治法：求解一个子问题（子问题只需要求解一次），扩展子问题的解。 求 an。 分治法：a(n/2) * a(n/2) 则左右两个 a(n/2) 均需要求解，所以时间复杂度为 O(n)。减治法：(a(n/2))2 则只需要求 a(n/2) 再平方即可，所以时间复杂度为 O(lgn)。 也就是说分治法是分解的部分需要进行分开的单独计算（需要计算两遍），而减治法则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量。 四、变治基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据对问题实例的变换方式，变治思想有 3 种主要类型： 变换为同样问题的一个更简单或者更方便的实例：实例化简； 变换为同样实例的不同表现：改变表现； 变换为另一个问题的实例， 这种问题的算法是已知的：问题化简。 基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。 4.1 实例化简①、检验数组中元素的唯一性（预排序） ②、模式计算（预排序） ③、AVL 树 4.2 改变表现①、2-3 树、2-3-4 树（二叉排序树） ②、堆和堆排序（利用最大/小堆总是找到最大/小值） ③、霍纳法则（多项式的计算） ④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组） 4.3 问题化简①、背包问题（线性规划） 五、动态规划将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往不是相互独立的。这种情况下若用分治法会对一些子问题进行多次求解，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。 动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质： 最优子结构性质 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。 子问题重叠性质 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。 用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法： ①、自底向上递归法 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。 ②、自顶向下递归法（即备忘录法） 利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。 当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。 文章：动态规划：从新手到专家 六、贪心当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单更直接效率更高的算法：贪心法。 贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。 贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质： 贪心选择性质 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。 最优子结构性质 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。 贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。 七、回溯回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。 回溯法通常的解题步骤如下： ①、定义问题的解空间。 ②、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。 ③、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。 用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h) 用回溯法解题时，常会遇到以下两类典型的解空间树： (1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 0-1背包问题 (2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 回溯法解旅行推销员问题 回溯法中的剪枝函数通常分为两类： (1)、用约束函数在指定节点处剪去不满足约束的子树，例如 0-1背包问题 (2)、用限界函数在指定节点处剪去得不到最优解的子树，例如回溯法解旅行推销员问题 八、分支限界回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。 分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。 九、学习文章姚来飞的博客 &amp; 常见的算法设计策略 算法设计之五大常用算法设计方法总结","tags":[]},{"title":"重构 AppDelegate","date":"2019-08-05T16:07:52.660Z","path":"2019/08/06/iOS/iOS架构/iOS 重构AppDelegate/","text":"一、Massive AppDelegate AppDelegate 是应用程序的根对象，它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互，通常被认为是每个 iOS 项目的核心。 随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。 在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的简洁和清晰对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。 AppDelegate 常见的业务代码如下： 日志埋点统计数据分析 初始化数据存储系统 配置 UIAppearance 管理 App Badge 数字 管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分 管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换 管理 UserDefaults：设置首先启动标志，保存和加载数据 管理后台任务 管理设备方向 更新位置信息 初始化第三方库（如分享、日志、第三方登陆、支付） 这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。 看看以下可能的解决方案，每个 Recipe（方案）遵循单一职责、易于扩展、易于测试原则。 二、命令模式 Command Design Pattern 命令模式是一种数据驱动的设计模式，属于行为型模式。 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。 可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。 123456789101112131415161718192021/// 命令协议@protocol Command &lt;NSObject&gt;- (void)execute;@end/// 初始化第三方库@interface InitializeThirdPartiesCommand : NSObject &lt;Command&gt;@end/// 初始化主视图@interface InitializeRootViewControllerCommand : NSObject &lt;Command&gt;@property (nonatomic, strong) UIWindow * keyWindow;@end/// 初始化视图全局配置@interface InitializeAppearanceCommand : NSObject &lt;Command&gt;@end/// ... 然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。 1234567891011@implementation StartupCommandsBuilder// 返回数组，元素为遵守 Command 协议的对象- (NSArray&lt;id&lt;Command&gt;&gt; *)build&#123; return @[ [InitializeAppearanceCommand new], [InitializeRootViewControllerCommand new], [InitializeThirdPartiesCommand new] ];&#125;@end 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(id&lt;Command&gt; _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj execute]; &#125;]; return YES;&#125; 如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。 三、组合设计模式 Composite Design Pattern 组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。 这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。 12345678910111213141516171819202122/// 组装类@interface CompositeAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;+ (instancetype)makeDefault;@end@implementation CompositeAppDelegate+ (instancetype)makeDefault&#123; // 这里要实现单例 return [[CompositeAppDelegate alloc] init];&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125;@end 实现执行具体职责的叶子类。 12345678910111213141516171819202122232425262728293031323334/// 叶子类。推送消息处理@interface PushNotificationAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end/// 叶子类。初始化第三方库@interface ThirdPartiesConfiguratorAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end@implementation PushNotificationAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"PushNotificationAppDelegate\"); return YES;&#125;@end@implementation ThirdPartiesConfiguratorAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"ThirdPartiesConfiguratorAppDelegate\"); return YES;&#125;@end 在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125; 它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。 四、中介者模式 Mediator Design Pattern 中介者模式是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。 让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface APPLifeCycleMediator : NSObject+ (instancetype)makeDefaultMediator;@end@implementation APPLifeCycleMediator&#123; @private NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; * _listeners;&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;- (instancetype)initWithListeners:(NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; *)listeners&#123; if (self = [super init]) &#123; _listeners = listeners; // 通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidEnterBackgroud) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidFinishLaunching) name:UIApplicationDidFinishLaunchingNotification object:nil]; &#125; return self;&#125;/// 定义好静态类方法，初始化所有监听者+ (instancetype)makeDefaultMediator&#123; static APPLifeCycleMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]]; &#125;); return mediator;&#125;- (void)onAppWillEnterForeground&#123; [_listeners[1] onAppWillEnterForeground];&#125;- (void)onAppDidEnterBackgroud&#123; [_listeners[0] onAppDidEnterBackgroud];&#125;- (void)onAppDidFinishLaunching&#123;&#125;@end 定义 AppLifecycleListener 协议，以及协议的的实现者。 123456789101112131415161718192021222324252627282930313233343536/// 监听协议@protocol AppLifeCycleListener &lt;NSObject&gt;@optional- (void)onAppWillEnterForeground;- (void)onAppDidEnterBackgroud;- (void)onAppDidFinishLaunching;@end@interface VideoListener : NSObject &lt;AppLifeCycleListener&gt;@end@interface SocketListener : NSObject &lt;AppLifeCycleListener&gt;@end@implementation VideoListener- (void)onAppDidEnterBackgroud&#123; NSLog(@\"停止视频播放\");&#125;@end@implementation SocketListener- (void)onAppWillEnterForeground&#123; NSLog(@\"开启长链接\");&#125;@end 加入到 AppDelegate 中 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [APPLifeCycleMediator makeDefaultMediator]; return YES;&#125; 这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。 五、总结大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。 通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。 这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。 六、学习文章最佳实践：重构AppDelegate Refactoring Massive App Delegate iOSTips OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》 Swift 设计模式：《Design_Patterns_by_Tutorials_v0.9.1》 重构：《重构改善既有代码的设计》","tags":[]},{"title":"第 k 小的数","date":"2019-08-05T16:07:52.659Z","path":"2019/08/06/算法/第 k 小的数/","text":"一、寻找两个有序数组的中位数1、问题描述给定两个大小为 m 和 n 的不同时为空的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 2、算法分析题目要求的时间复杂度是 O(log(m + n))，要产生这样级别的时间复杂度只有采用二分查找法，用分治递归的思路来考虑这个问题。 需要转换题目中求中位数的问题为求第 k 小数的问题。如果 m + n 是奇数，那么寻找第 k = (m + n)/2 + 1 小的数即可；如果长度和是偶数，那么我们还需要寻找第 (m + n)/2 小的数，然后计算两数的平均值。 在求解整个问题的过程中，我们始终需要考虑一个很重要的问题–数组索引越界问题。 下面将详细地分析整个递归流程。 ①、首先定义递归函数的作用：寻找两个有序数组 nums1 数组中 [L1, R1] 范围内和 nums2 数组 [L2, R2] 范围内第 k 小的数，k 从 1开始计数。 12345678/** * L1 nums1数组的寻找范围的左边界 * R1 nums1数组的寻找范围的右边界 * L2 nums2数组的寻找范围的左边界 * R2 nums2数组的寻找范围的右边界 * k 需要寻找第k小的元素 */int findKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k) ②、用 len1 = R1 - L1 + 1 来记录 nums1 数组中寻找范围的长度，用 len2 = R2 - L2 + 1 来记录 nums2 数组中寻找范围的长度。 ③、如果要寻找的 k &gt; len1 + len2，就像只有 3 个数字要找第 4 小的数一样，超出寻找区域，显然无法找到。 ④、递归的终止条件： 当 len1 = 0 时，说明只有 nums2 数组中有元素，直接取 nums2[L2 + k - 1] 位元素即可。 当 k = 1 时，说明要取的是两个有序数组中的最小值 MIN(nums1[L1], nums2[L2])。 ⑤、递归过程： 由于要求的是第 k 小的数，而且是在两个有序数组中求。划分两个数组时按照 k 值来分。取变量 i = MIN(len1, k/2)，之所以这么取，是为了防止 L1 + k/2 - 1 &gt; len1 导致从 nums1 取值越界。再取变量 j = MIN(len2, k/2)。 接下来比较 nums1[L1 + i - 1] 和 nums2[L2 + i - 1] 这两个值。 如果 nums1[L1 + i - 1] &lt;= nums2[L2 + j - 1]，显然 nums1 数组中索引为 L1 + i - 1 及之前的元素不可能是中位数，去除 nums1 数组中 [L1, L1 + i - 1] 范围内的元素，缩小了查找范围。我们递归调用该函数，此时在 nums1 中的查找范围变成了 nums1[L1 + i, R1]，此时要找的也不应该是第 k 小的元素，因为已经剔除了 i 个比 k 小的元素，因此我们要找的元素变成了第 k - i 小的元素。 如果 nums1[L1 + i - 1] &gt; nums2[L2 + j - 1]，同理，nums2 数组中索引为 L2 + j - 1 及之前的元素不可能是中位数，缩小查找范围，剔除了 j 个比 k 小的元素，因此我们要找的元素变成了第 k - j 小的元素。 因为 i + j = MIN(len1, k/2) + MIN(len2, k/2) &lt;= k，所以可以直接判断 [L1, L1 + i - 1] 或者 [L2, L2 + j -1] 区间的元素不可能是中位数。 总结：算法的思想是不断的剔除数据，逐渐逼近第 k 小的数。 3、时间复杂度假设数组长度足够长，每次剔除的元素都是 k/2(i 或者j)，显然我们需要 log(k) 次才能找到第 k 小数，这和二分查找法是同理的，而我们要找的 k 值要么是 (m + n)/2 + 1，要么额外再加上 (m + n)/2，因此时间复杂度是 O(log(m + n)) 级别的。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MIN(a, b) (a) &lt; (b) ? (a) : (b)int findKth(int* nums1, int left1, int right1, int* nums2, int left2, int right2, int k)&#123; int n1 = right1 - left1 + 1; int n2 = right2 - left2 + 1; // 递归退出条件 if(k &gt; n1 + n2) &#123; return 0; // 实际上 k 不会小于 n1 + n2 &#125; if(n1 == 0) &#123; return nums2[left2 + k - 1]; &#125; else if (n2 == 0) &#123; return nums1[left1 + k - 1]; &#125; if(k == 1) &#123; return MIN(nums1[left1], nums2[left2]); &#125; int i = MIN(n1, k / 2); int j = MIN(n2, k / 2); // 剔除比第 k 小的数还小的数，逐渐逼近 if(nums1[left1 + i - 1] &gt; nums2[left2 + j - 1]) &#123; return findKth(nums1, left1, right1, nums2, left2 + j, right2, k - j); &#125; else &#123; return findKth(nums1, left1 + i, right1, nums2, left2, right2, k - i); &#125;&#125;double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)&#123; // k = (nums1Size + nums2Size) /2 + 1，因为 k 从 1 开始计数 int mid1 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2 + 1); // 两个数组总长度是奇数 if((nums1Size + nums2Size) % 2 != 0) &#123; return mid1; &#125; // 两个数组总长度是偶数 else &#123; // 额外求 (nums1Size + nums2Size) / 2 的值 int mid2 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2); return (mid1 + mid2) / 2.0; &#125;&#125; 二、文章LeetCode004——两个排序数组的中位数","tags":[]},{"title":"简单算法","date":"2019-08-05T16:07:52.659Z","path":"2019/08/06/算法/简单算法/","text":"1、交换 A 和 B1234567891011121314151617181920212223// 1.中间变量void swap1(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;// 2.加法void swap2(int a, int b) &#123; a = a + b; b = a - b; a = a - b; &#125;// 3.异或（相同为0，不同为1）void swap3(int a, int b) &#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 2、求最大公约数123456789101112131415161718192021222324/** 1.直接遍历法 */int maxCommonDivisor(int a, int b) &#123; int max = 0; for (int i = 1; i &lt;= b; i++) &#123; if (a % i == 0 &amp;&amp; b % i == 0) &#123; max = i; &#125; &#125; return max;&#125;/** 2.辗转相除法 */int maxCommonDivisor(int a, int b) &#123; int r; while(a % b &gt; 0) &#123; r = a % b; a = b; b = r; &#125; return b;&#125;// 扩展：最小公倍数 = (a * b)/最大公约数 3、文章iOS开发_小迷糊 &amp; iOS面试题：算法与数据结构","tags":[]},{"title":"爬楼梯","date":"2019-08-05T16:07:52.658Z","path":"2019/08/06/算法/爬楼梯/","text":"原文：漫画：什么是动态规划？ 1、问题描述有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法。 2、算法分析从简单的分析，要到第 10 级台阶，有多少种方法？要么从 9 级跨 1 级，要么从 8 级跨 1 级。 记 10 级台阶的状态为 f(10)，9 级台阶的状态为 f(9)，8 级台阶的状态为 f(8)，那么 f(10) = f(9) + f(8)。 f(9) = f(8) + f(7)…f(2) = 2f(1) = 1 f(8)、f(9) 是 f(10) 的【最优子结构】；f(1)、f(2) 是【边界】；f(n) = f(n-1) + f(n-2) 是【状态转移方程】。 3、代码实现①、递归 123456int getClimbingWays(int n)&#123; if (n &lt; 3) return n; return getClimbingWays(n - 1) + getClimbingWays(n - 2);&#125; 递归调用的执行过程和一颗二叉树一样，所以它的时间复杂度就是叶子节点数。 时间复杂度：O(2n) ②、备忘录算法 递归方法中会重复计算相同的值，如图中的 f(n-3)。用缓存，先创建一个哈希表，每次把不同参数的计算结果存入哈希。当遇到相同参数时，再从哈希表里去除，避免重复计算。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int getClimbingWays(int n, int* hashMap)&#123; if (n &lt; 3) return n; // 没有缓存 if (hashMap[n] == 0) &#123; int value = getClimbingWays(n - 1, hashMap) + getClimbingWays(n - 2, hashMap); hashMap[n] = value; &#125; return hashMap[n];&#125;int main()&#123; int n = 10; int* hashMap = (int *)calloc(n, sizeof(int)); printf(\"%d\", getClimbingWays(n, hashMap)); return 0;&#125; 时间复杂度：O(n) 空间复杂度：O(n) ③、动态规划法 12345678910111213141516int getClimbingWays(int n)&#123; if (n &lt; 3) return n; int a = 1; int b = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) &#123; sum = a + b; a = b; b = sum; &#125; return sum;&#125; 时间复杂度：O(n) 空间复杂度：O(1)","tags":[]},{"title":"硬币问题","date":"2019-08-05T16:07:52.658Z","path":"2019/08/06/算法/硬币问题/","text":"1、问题描述假设有 1 元、3 元、5 元的硬币无限个，现在需要凑出 11 元，问如何组合才能使硬币的数量最少？ 2、算法分析有最小单位 1 的情况下，可以使用贪心算法： 123456789NSInteger count = m / 5;NSInteger mol = m % 5; if(mol/3 &gt; 0) &#123; count++; mol %= 3;&#125; count += mol; 但当硬币的种类改变，并且需要凑出的总价值变大时，很难靠简单的计算得出结果。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。 这里运用动态规划的思路解决该问题。动态规划中有三个重要的元素：最优子结构、边界、状态转移公式。按照一般思路，先从最基本的情况来一步一步地推导。 注意：动态规划的策略在于当前的硬币（或其他物品）是否能算进去。 先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量。 当 i = 0 时，很显然知道 d(0) = 0。 当 i = 1 时，因为有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = d(0) + 1。 当 i = 2 时，因为并没有 2 元的硬币，所以在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = d(1) + 1。 当 i = 3 时，需要 3 个 1 元硬币或者 1 个 3 元硬币，d(3) = min{ d(2)+1, d(3-3)+1 }; … 抽离出来 d(i) = min{ d(i-1)+1, d(i-vj)+1 }，其中 i - vj &gt;= 0，vj 表示第 j 个硬币的面值。 这里 d(i-1)+1 和 d(i-vj)+1 是 d(i) 的最优子结构；d(0) = 0 是边界；d(i) = min{ d(i-1)+1, d(i-vj)+1 } 是状态转移公式。其实我们根据边界 + 状态转移公式就能得到最终动态规划的结果。 3、算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Coins 3int dp(int n)&#123; // min 数组包含 d(0)~d(n)，所以数组长度是 n+1 n++; // 初始化数组 int* min = (int*)calloc(n, sizeof(int)); // 可选硬币种类 int v[Coins] = &#123; 1, 3, 5 &#125;; for (int i = 1; i &lt; n; i++) &#123; min[i] = min[i-1] + 1; for (int j = 0; j &lt; Coins; j++) &#123; // 装不下 if (v[j] &gt; i) &#123; break; &#125; // 装得下 if (min[i - v[j]] &lt; min[i - 1]) &#123; min[i] = min[i - v[j]] + 1; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d \", min[i]); &#125; return min[n - 1];&#125;int main()&#123; printf(\"\\n%d\", dp(101)); return 0;&#125; 4、拓展上面的问题中包含了最小单位 1 元的硬币，所以每次 i 增加时，都能 min[i] = min[i - 1] + 1（+1 是用了 1 元硬币），但如果硬币为 2 元、3 元、5 元呢？应该如何求出 11 元呢？ 来推算下： ①、n = 1，不存在 1 元硬币，且 2、3、5 &gt; 1，所以 f(1) = 0; ②、n = 2，存在 2 元硬币，所以 f(2) = 1; ③、n = 3，存在 3 元硬币，所以 f(3) = 1; ④、n = 4，不存在 4 元硬币，而 2 和3 &lt; 4，5 &gt; 4，其中 f(4-3) = f(1) = 0 说明在去除 3 元的情况下，不能获得剩下的 1 元； f(4-2) = f(2) = 1 说明在去除2 元的情况下，可以获得剩下的2 元，f(4) = f(2) + 1 = 2; 结合上面两种情况 f(4) = MIN{ f(4-2) + 1 } ⑤、n = 5，存在 5 元硬币，所以 f(5) = 1; ⑥、n = 6，不存在 6元硬币，而 2、3、5 &lt; 6，其中 f(6-5) = f(1) = 0 说明在去除 5 元的情况下，不能获得剩下的 1 元； f(6-3) = f(3) = 1 说明在去除 3 元的情况下，可以获得剩下的 3 元，f(6) = f(6-3) + 1 = 2; f(6-2) = f(4) = 2 说明在去除 2 元的情况下，可以获得剩下的 3 元，f(6) = f(6-4) + 1 = 3; 结合上面三种情况 f(6) = MIN{ f(6-3) + 1, f(6-2) + 1 } 【状态】是 f(n) 【边界】是 n = 2、3、5 时只有一种选择 【状态转移方程】是 f(n) = MIN{ f(n - ci) +1 }, 其中 n 表示当前的总额，ci 表示金币数额。 注意：因为是取最小值，所以是无法获得的总额时，如 f(1)，应该让 f(1)等于很大的值，这样就可以将它剔除出去。 下面的代码为了直观每次选币的过程，增加了结构体、打印代码，不需要时可以自行删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Coins 3#define MIN(a, b) (a) &lt; (b) ? (a) : (b)typedef struct CoinLog &#123; int minCoin; // 最少的硬币数 int coin[100]; // 所选硬币&#125; CoinLog;int dp(int n)&#123; n++; // result 数组包含 d(0)~d(n)，所以数组长度是 n+1 // 初始化数组// int* result = (int*)malloc(sizeof(int) * n);// for (int i = 0; i &lt; n; i++) &#123;// result[i] = n;// &#125; CoinLog* result = (CoinLog *)malloc(sizeof(CoinLog) * n); for (int i = 0; i &lt; n; i++) &#123; CoinLog log = &#123; n, &#123;0&#125; &#125;; result[i] = log; &#125; // 硬币种类 int v[Coins] = &#123; 2, 3, 5 &#125;; for (int i = 1; i &lt; n; i++) &#123; printf(\"%3d =\", i); for (int j = 0; j &lt; Coins; j++) &#123; // 硬币正好 if (v[j] == i) &#123; result[i].minCoin = 1; result[i].coin[0] = v[j]; &#125; // 硬币太大 else if (v[j] &gt; i) &#123; &#125; // 循环 Coins，找出最少的币数 else if (result[i - v[j]].minCoin &lt; result[i].minCoin) &#123; result[i].minCoin = result[i - v[j]].minCoin + 1; int k = 0; for (; k &lt; result[i - v[j]].minCoin; k++) &#123; result[i].coin[k] = result[i - v[j]].coin[k]; &#125; result[i].coin[k] = v[j]; &#125; &#125; if (result[i].minCoin &lt; n) &#123; // 显示每次怎么找的 for (int k = 0; k &lt; result[i].minCoin; k++) &#123; printf(\"%3d \", result[i].coin[k]); &#125; &#125; printf(\"\\n\"); &#125; // for (int i = 1; i &lt; n; i++) &#123;// printf(\"%d \", result[i]);// &#125; return result[n - 1].minCoin;&#125;int main()&#123; printf(\"\\n最少的币数 = %d\", dp(21)); return 0;&#125; 1 = 2 = 2 3 = 3 4 = 2 2 5 = 5 6 = 3 3 7 = 2 5 8 = 3 5 9 = 2 2 5 10 = 5 5 11 = 3 3 5 12 = 2 5 5 13 = 3 5 5 14 = 2 2 5 5 15 = 5 5 5 16 = 3 3 5 5 17 = 2 5 5 5 18 = 3 5 5 5 19 = 2 2 5 5 5 20 = 5 5 5 5 21 = 3 3 5 5 5 最少的币数 = 5","tags":[]},{"title":"汉诺塔","date":"2019-08-05T16:07:52.657Z","path":"2019/08/06/算法/汉诺塔/","text":"学习文章：汉诺塔 1、问题描述在三根柱子之间一次只能移动一个圆盘，在小圆盘上不能放大圆盘。 2、算法分析依据分治的策略，将问题化简为两个圆盘，三根柱子 A、B、C，首先解决倒数第二个圆盘的移动，将 n - 1（小盘） 从 A 移到 B，然后将 n（大盘） 从 A 移到 C，再将小盘从 B 移到 C。 子问题分别为：小盘和大盘的移动。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define num 5static int a[num] = &#123; 1, 2, 3, 4, 5 &#125;; // 1 - 最小的物品 5 - 最大的物品static int b[num] = &#123; 0 &#125;; // 0 - 为空static int c[num] = &#123; 0 &#125;; // 0 - 为空static int idxA = 0; // 当前有物品的下标static int idxB = num;static int idxC = num;/// 定义 move 函数，移动物品void move(char from, char to)&#123; int x = 0; printf(\"%c -&gt; %c\\n\", from, to); // 移出 if (from == 'A' &amp;&amp; idxA &gt; -1 &amp;&amp; idxA &lt; num) &#123; x = a[idxA]; a[idxA] = 0; idxA++; &#125; else if (from == 'B' &amp;&amp; idxB &gt; -1 &amp;&amp; idxB &lt; num) &#123; x = b[idxB]; b[idxB] = 0; idxB++; &#125; else if (from == 'C' &amp;&amp; idxC &gt; -1 &amp;&amp; idxC &lt; num) &#123; x = c[idxC]; c[idxC] = 0; idxC++; &#125; else &#123; printf(\"%c from 数组越界！\", from); return; &#125; // 存入 if (to == 'A' &amp;&amp; --idxA &gt; -1 &amp;&amp; idxA &lt; num) &#123; a[idxA] = x; &#125; else if (to == 'B' &amp;&amp; --idxB &gt; -1 &amp;&amp; idxB &lt; num) &#123; b[idxB] = x; &#125; else if (to == 'C' &amp;&amp; --idxC &gt; -1 &amp;&amp; idxC &lt; num)&#123; c[idxC] = x; &#125; else &#123; printf(\"%c to 数组越界！\", to); return; &#125; // 打印移动后结果 for (int i = 0; i &lt; num; i++) &#123; printf(\"%d %d %d\\n\", a[i], b[i], c[i]); &#125; printf(\"\\n\");&#125;/// 将 n 个物品从 one 座借助 two 座，移到 three 座void hanoi(int n, char one, char two, char three)&#123; if(n == 1) &#123; move(one, three); // 只有一个物品，直接移动 &#125; else &#123; hanoi(n-1, one, three, two); //首先把 n - 1 个从 one 移动到 two move(one, three); // 然后把最后一个 n 从 one 移动到 three hanoi(n-1, two, one, three); // 最后再把 n - 1 个从 two 移动到 three &#125;&#125;int main()&#123; hanoi(num, 'A', 'B', 'C'); return 0;&#125;A -&gt; C0 0 02 0 03 0 04 0 05 0 1A -&gt; B0 0 00 0 03 0 04 0 05 2 1C -&gt; B0 0 00 0 03 0 04 1 05 2 0A -&gt; C0 0 00 0 00 0 04 1 05 2 3B -&gt; A0 0 00 0 01 0 04 0 05 2 3B -&gt; C0 0 00 0 01 0 04 0 25 0 3A -&gt; C0 0 00 0 00 0 14 0 25 0 3A -&gt; B0 0 00 0 00 0 10 0 25 4 3C -&gt; B0 0 00 0 00 0 00 1 25 4 3C -&gt; A0 0 00 0 00 0 02 1 05 4 3B -&gt; A0 0 00 0 01 0 02 0 05 4 3C -&gt; B0 0 00 0 01 0 02 3 05 4 0A -&gt; C0 0 00 0 00 0 02 3 05 4 1A -&gt; B0 0 00 0 00 2 00 3 05 4 1C -&gt; B0 0 00 1 00 2 00 3 05 4 0A -&gt; C0 0 00 1 00 2 00 3 00 4 5B -&gt; A0 0 00 0 00 2 00 3 01 4 5B -&gt; C0 0 00 0 00 0 00 3 21 4 5A -&gt; C0 0 00 0 00 0 10 3 20 4 5B -&gt; A0 0 00 0 00 0 10 0 23 4 5C -&gt; B0 0 00 0 00 0 00 1 23 4 5C -&gt; A0 0 00 0 00 0 02 1 03 4 5B -&gt; A0 0 00 0 01 0 02 0 03 4 5B -&gt; C0 0 00 0 01 0 02 0 43 0 5A -&gt; C0 0 00 0 00 0 12 0 43 0 5A -&gt; B0 0 00 0 00 0 10 0 43 2 5C -&gt; B0 0 00 0 00 0 00 1 43 2 5A -&gt; C0 0 00 0 00 0 30 1 40 2 5B -&gt; A0 0 00 0 00 0 30 0 41 2 5B -&gt; C0 0 00 0 20 0 30 0 41 0 5A -&gt; C0 0 10 0 20 0 30 0 40 0 5","tags":[]},{"title":"消息转发","date":"2019-08-05T16:07:52.657Z","path":"2019/08/06/iOS/iOS原理/iOS 消息转发/","text":"一、前言在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现 unrecognized selector sent to instance，导致应用 crash 的情况。 针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 NullSafe。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。 消息转发的整个过程主要涉及的 3 个方法： 123+(BOOL)resolveInstanceMethod:(SEL)sel;-(id)forwardingTargetForSelector:(SEL)aSelector;-(void)forwardInvocation:(NSInvocation*)anInvocation; 其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。 二、消息转发过程首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。 下边分析消息转发的过程，以 [MyObjet Length] 为例： ①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。 ②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。 ③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。 三、结合 MyObject 中的代码对消息转发流程进一步分析①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下： 12345678910111213+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; printf(\"%s:%s \\n\", __func__ ,NSStringFromSelector(sel).UTF8String); if (sel == @selector(length)) &#123; BOOL success = class_addMethod([self class], sel, (IMP)(length), \"q@:\"); if (success) &#123; return success; &#125; &#125; return [super resolveInstanceMethod:sel];&#125; 传入的 “q@:” 分别代表： 123q : 返回值 long long@ : 调用方法的的实例为对象类型: : 表示方法 下图表示了编码类型。 ②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637static NSArray * respondClasses;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; printf(\"%s:%s \\n\", __func__ , NSStringFromSelector(aSelector).UTF8String); id forwardTarget = [super forwardingTargetForSelector:aSelector]; if (forwardTarget) &#123; return forwardTarget; &#125; Class someClass = [self myResponedClassForSelector:aSelector]; if (someClass) &#123; forwardTarget = [someClass new]; &#125; return forwardTarget;&#125;- (Class)myResponedClassForSelector:(SEL)selector&#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; +(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。 ③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。 -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。 摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。 相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; printf(\"%s:%s \\n\\n\\n\\n\", __func__ , NSStringFromSelector(anInvocation.selector).UTF8String); anInvocation.target = nil; [anInvocation invoke];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; Class responededClass = [self myResponedClassForSelector:selector]; if (responededClass) &#123; @try &#123; signature = [responededClass instanceMethodSignatureForSelector:selector]; &#125; @catch (NSException *exception) &#123; &#125;@finally &#123; &#125; &#125; &#125; return signature;&#125;- (Class)myResponedClassForSelector:(SEL)selector &#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; 这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。 12345678910111213141516171819202122232425262728293031323334353637&lt;NSMethodSignature: 0x6000030a17c0&gt; number of arguments = 2 frame size = 224 is special struct return? NO return value: -------- -------- -------- -------- type encoding (f) 'f' flags &#123;isFloat&#125; modifiers &#123;&#125; frame &#123;offset = 16, offset adjust = 0, size = 16, size adjust = -12&#125; memory &#123;offset = 0, size = 4&#125; argument 0: -------- -------- -------- -------- type encoding (@) '@' flags &#123;isObject&#125; modifiers &#123;&#125; frame &#123;offset = 0, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125; argument 1: -------- -------- -------- -------- type encoding (:) ':' flags &#123;&#125; modifiers &#123;&#125; frame &#123;offset = 8, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125;``` NSInvocation。仍然以`myObject`调用`length`方法为例。 \\- (void)forwardInvocation:(NSInvocation \\*)anInvocation中的 anInvocation 的信息如下：```objc&lt;NSInvocation: 0x6000025b8140&gt;return value: &#123;Q&#125; 0target: &#123;@&#125; 0x60000322c360selector: &#123;:&#125; length&gt; return value 指返回值，\"Q\" 表示返回值类型为 long long 类型；&gt; target 指的是消息的接收者，\"@\"标识对象类型；&gt; selector 指的是方法，\":\"表示是方法，后边的 length 为方法名。 更多内容可见下图 NSInvocation 的 types： 12345678910111213141516171819enum _NSObjCValueType &#123; NSObjCNoType = 0, NSObjCVoidType = 'v', NSObjCCharType = 'c', NSObjCShortType = 's', NSObjCLongType = 'l', NSObjCLonglongType = 'q', NSObjCFloatType = 'f', NSObjCDoubleType = 'd', NSObjCBoolType = 'B', NSObjCSelectorType = ':', NSObjCObjectType = '@', NSObjCStructType = '&#123;', NSObjCPointerType = '^', NSObjCStringType = '*', NSObjCArrayType = '[', NSObjCUnionType = '(', NSObjCBitfield = 'b'&#125; API_DEPRECATED(\"Not supported\", macos(10.0,10.5), ios(2.0,2.0), watchos(2.0,2.0), tvos(9.0,9.0)); 四、尚存疑点细心的读者可能会发现在首次消息转发的时候流程并不是 123+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length -[MyObject forwardInvocation:]:length 而是 12345+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length +[MyObject resolveInstanceMethod:]:length +[MyObject resolveInstanceMethod:]:_forwardStackInvocation: -[MyObject forwardInvocation:]:length 查看了开源源码 NSObject.mm 相关源码如下： 12345678910111213// Replaced by CF (returns an NSMethodSignature)- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; _objc_fatal(\"-[NSObject methodSignatureForSelector:] \" \"not available without CoreFoundation\");&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];&#125;// Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal(\"-[%s %s]: unrecognized selector sent to instance %p\", object_getClassName(self), sel_getName(sel), self);&#125; 五、NSNull+QiNullSafe.m根据 NullSafe 仿写的 NSNull+QiNullSafe.m。 NSNull+QiNullSafe.m 能够避免的问题有： NSNull *null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@”aaa”];[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];[null performSelector:@selector(valueForKey:) withObject:@”aaa”];[null performSelector:@selector(length) withObject:nil];[null performSelector:@selector(integerValue) withObject:nil];[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];[null performSelector:@selector(bytes) withObject:nil]; 六、NullSafe 是怎么处理 null 问题其实 NullSafe 处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。 不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。 注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。 七、单元测试1234567891011121314151617181920212223- (void)testStringValue&#123; id null = [NSNull null]; NSString * string = [null stringValue]; XCTAssertNil(string);&#125;- (void)testFloatValue&#123; id null = [NSNull null]; CGFloat f = [null floatValue]; XCTAssertEqualWithAccuracy(f, 0.0f, 0.0f);&#125;- (void)testPerformSelector&#123; NSNull * null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@\"aaa\"];&#125; 八、文章iOS 消息转发 Protocol 协议分发器","tags":[]},{"title":"构造子集","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/构造子集/","text":"1、问题描述构造出 0~n-1 的所有子集。 2、算法分析一次选出一个元素放入集合。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define ARRAY_LENGTH 10&#123; int A[ARRAY_LENGTH]; print_subset(ARRAY_LENGTH, A, 0);&#125;void print_subset(int n, int* A, int cur)&#123; // cur:当前位置 printf(\"cur = %d \", cur); // 确定当前元素的最小可能值 int s = cur ? A[cur-1] + 1 : 0; printf(\"s = %d \", s); // 打印当前子集元素。 for(int i = 0; i &lt; cur; i++) &#123; printf(\"%d \", A[i]); &#125; // 每次选出一个元素当子集的首元素, for(int i = s; i &lt; n; i++) &#123; A[cur] = i; // 打印加入元素后的数组 printf(\" after：\"); for(int j = 0; j &lt;= cur; j++) &#123; printf(\"%d \", A[j]); &#125; printf(\"\\n\"); print_subset(n, A, cur + 1); // 递归构造子集 &#125;&#125;cur = 0 s = 0 after：0 cur = 1 s = 1 0 after：0 1 cur = 2 s = 2 0 1 after：0 1 2 cur = 3 s = 3 0 1 2 after：0 1 2 3 cur = 4 s = 4 0 1 2 3 after：0 1 3 cur = 3 s = 4 0 1 3 after：0 2 cur = 2 s = 3 0 2 after：0 2 3 cur = 3 s = 4 0 2 3 after：0 3 cur = 2 s = 4 0 3 after：1 cur = 1 s = 2 1 after：1 2 cur = 2 s = 3 1 2 after：1 2 3 cur = 3 s = 4 1 2 3 after：1 3 cur = 2 s = 4 1 3 after：2 cur = 1 s = 3 2 after：2 3 cur = 2 s = 4 2 3 after：3 cur = 1 s = 4 3","tags":[]},{"title":"棋盘覆盖","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/棋盘覆盖/","text":"原文：棋盘覆盖问题、分治法之棋盘覆盖问题 1、问题描述在一个 2k * 2k（k ≥ 0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格，显然，特殊方格在棋盘中出现的位置有 4k 种情形，因而有 4k 种不同的棋盘。 2、算分分析用分治策略。 ①、当 k &gt; 0 时，将 2k * 2k 棋盘分割成 4 个 2k-1 * 2k-1 子棋盘，特殊方格必定只位于某个子棋盘中。 ②、用一个 L 型骨牌覆盖 3 个无特殊方格子棋盘的结合处，由原问题转化成 4 个较小规模的棋盘覆盖子问题。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt;#define max 1024int board[max][max]; // 最大棋盘static int tile = 0; // 覆盖标志位/** * （tr，tc） 棋盘左上角的方格坐标 * （dr，dc） 特殊方格所在的坐标 * size 是棋盘的行数和列数 */void ChessBoard(int tr,int tc,int dr,int dc,int size)&#123; if(size == 1) return; // 递归到棋盘大小为 1 时，则结束递归 int t = tile++; // L型骨牌号 int s = size / 2; // 分割棋盘，使得新得到的棋盘为原来棋盘大小的四分之一 // ①、左上角子棋盘 // 如果特殊方格在左上角，就对这个棋盘左上角的四分之一重新进行棋盘覆盖 if(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123; // 特殊方格在此棋盘中 ChessBoard(tr, tc, dr, dc, s); &#125; // 因为特殊方格不在左上角，所以要在左上角构造一个特殊方格 else &#123; // 用 t 号 L 型骨牌覆盖右下角 board[tr + s - 1][ tc + s - 1] = t; // 在构造完特殊方格之后，棋盘的左上角的四分之一又有了特殊方格，所以就对左上角棋盘的四分之一进行棋盘覆盖，直到棋盘大小为 1 * 1 ChessBoard(tr, tc, tr+s-1, tc+s-1, s); &#125; // ②、右上角子棋盘 if(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123; ChessBoard(tr, tc+s, dr, dc, s); &#125; else &#123; board[tr + s - 1][tc + s] = t; ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; // ③、左下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123; ChessBoard(tr + s, tc, dr, dc, s); &#125; else &#123; // 用 t 号 L 型骨牌覆盖右上角 board[tr + s][tc + s - 1] = t; ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); &#125; // ④、右下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123; ChessBoard(tr + s, tc + s, dr, dc, s); &#125; else &#123; // 用 t 号 L 型骨牌覆盖左上角 board[tr + s][tc + s] = t; ChessBoard(tr + s, tc + s, tr + s, tc + s, s); &#125;&#125;int main()&#123; int size = 8, dr = 0, dc = 0; printf(\"不可覆盖点的值为 -1！\\n\\n\"); board[dr][dc] = -1; ChessBoard(0, 0, dr, dc, size); for(int m = 0; m &lt; size; m++) &#123; printf(\"%2d\", board[m][0]); for(int n = 1; n &lt; size; n++) &#123; printf(\" %2d\", board[m][n]); &#125; printf(\"\\n\"); &#125; return 0;&#125;不可覆盖点的值为 -1！-1 2 3 3 7 7 8 8 2 2 1 3 7 6 6 8 4 1 1 5 9 9 6 10 4 4 5 5 0 9 10 1012 12 13 0 0 17 18 1812 11 13 13 17 17 16 1814 11 11 15 19 16 16 2014 14 15 15 19 19 20 20","tags":[]},{"title":"第 k 小/大元素","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/求第 k 小:大元素/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;void swap_t(int a[],int i,int j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t;&#125;int par(int a[],int p,int q)//p是轴,轴前面是比a[p]小的，后面是比a[p]大的&#123; int i=p,x=a[p]; for(int j=p+1;j&lt;=q;j++) &#123; if(a[j]&gt;=x) &#123; i++; swap_t(a,i,j); &#125; &#125; swap_t(a,p,i); return i;//返回轴位置&#125;int Random(int p,int q)//返回p，q之间的随机数&#123; return rand()%(q-p+1)+p;&#125;int Randomizedpar(int a[],int p,int q)&#123; int i=Random(p,q); swap_t(a,p,i);//第一个和第i个交换，相当于有了一个随机基准元素 return par(a,p,q);&#125;int RandomizedSelect(int a[],int p,int r,int k)&#123; if(p==r) return a[p]; int i=Randomizedpar(a,p,r); int j=i-p+1; printf(\"i=%d j=%d\\n\",i,j); if(k&lt;=j) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j);&#125;int main()&#123; int n; scanf(\"%d\",&amp;n); int a[n]; for(int i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; int x=RandomizedSelect(a,0,n-1,2); printf(\"%d\\n\",x);&#125;","tags":[]},{"title":"最长回文子串","date":"2019-08-05T16:07:52.655Z","path":"2019/08/06/算法/最长回文子串/","text":"1、问题描述给定一个字符串 s，找到 s 中最长的回文子串。 2、算法分析大多数问题都可以用暴力法解决。暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。 时间复杂度：O(n3)，假设 n 是输入字符串的长度，则 (n * (n−1))/2​ 为此类子字符串（不包括字符本身是回文的一般解法）的总数。因为验证每个子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n3)。 空间复杂度：O(1)。 为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。 我们给出 P(i,j) 的定义如下： 如果子串 Si...Sj ​是回文子串 p(i, j) = true 其他情况 p(i, j) = false 因此： P(i, j) = ( P(i+1, j-1) and Si​ == Sj​) 基本示例如下： P(i, i) = true P(i, i+1) = (Si ​== Si+1​) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推… 3、复杂度分析 时间复杂度：O(n2)，这里给出我们的运行时间复杂度为 O(n2)。 空间复杂度：O(n2)，该方法使用 O(n2) 的空间来存储表。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char * longestPalindrome(char* s)&#123; if (s == NULL || strlen(s) &lt; 1) &#123; return \"\"; &#125; int n = (int)strlen(s); // 初始化二维数组 int matrix[n][n]; for (int i = 0; i &lt; n; i++) for (int j = 0; j&lt; n; j++) matrix[i][j] = 0; int left = 0; int right = 0; // i 从倒数第二个开始，从右往左。标识子串的起始位置 for (int i = n - 2; i &gt;= 0; i--) &#123; matrix[i][i] = 1; // j 从 i 的下一位开始，从左往右。标识子串的结束位置 for (int j = i + 1; j &lt; n; j++) &#123; // ①、s[i] == s[j] ②、小于或等于 3 个字符 ③、内缩一位是回文子串 matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); // 获得最长的子串位置 if(matrix[i][j] &amp;&amp; right - left &lt; j - i) &#123; left = i; right = j; &#125; for (int m = 0; m &lt; n; m++) &#123; for (int k = 0; k &lt; n; k++) printf(\"%d \", matrix[m][k]); printf(\"\\n\\n\"); &#125; &#125; &#125; char* sub = (char *)malloc(sizeof(char) * (right - left + 1)); int i = 0; for (; i &lt; right - left + 1; i++) &#123; sub[i] = s[left + i]; //strncpy(sub, s+left, right+1); &#125; sub[i] = '\\0'; return sub;&#125;int main()&#123; printf(\"%s\", longestPalindrome(\"aaabaaaa\")); return 0;&#125; 关键代码： matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); 以及 i 和 j 的取值方向","tags":[]},{"title":"最长上升子序列","date":"2019-08-05T16:07:52.655Z","path":"2019/08/06/算法/最长上升子序列/","text":"1、问题描述给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, 3, 4, 8, 6, 7] 返回 4。 2、算法分析面对这个问题，首先要定义一个”状态“来代表它的子问题， 并且找到它的解。 注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。 假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。 这个 d(i) 就是我们要找的状态。 如果我们把 d(1) 到 d(N) 都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。 以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是： 5 3 4 8 6 7 根据上面找到的状态，可以得到： i = 1 的 LIS 长度 d(1) = 1, d[] = {5} i = 2 的 LIS 长度 d(2) = 1, d[] = {3} i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4} i = 4 的 LIS 长度 d(4) = max{ d(1), d(2), d(3) } + 1 = 3, d[] = {3, 4, 8} 状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到： d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A\\[j\\] &lt;= A\\[i\\] 想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。 分析完了，上图。 3、复杂度分析时间复杂度：O(n2) 空间复杂度：O(n) 4、代码实现1234567891011121314151617181920212223242526272829303132int lengthOfLIS(int* nums, int numsSize) &#123; if (numsSize == 0) return 0; int *d = (int *)malloc(sizeof(int) * numsSize); int len = 1; for(int i = 0; i &lt; numsSize; ++i)&#123; d[i] = 1; for(int j = 0; j &lt; i; ++j) // 如果当前的数值 A[i] 大于 它之前的数值 A[j] &amp;&amp; 最长的段 if(nums[j] &lt; nums[i] &amp;&amp; d[j] + 1 &gt; d[i]) d[i] = d[j] + 1; if(d[i] &gt; len) len = d[i]; &#125; free(d); return len;&#125;int main()&#123; int A[] = &#123; 5, 3, 4, 8, 6, 7 &#125;; printf(\"%d\", lengthOfLIS(A, 6)); return 0;&#125; 5、进阶：O(nlogn)算法假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。 定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。注意：B 的索引从 1 开始。 ①、把 d\\[0\\] 有序地放到 B 里，令 B\\[1\\] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。 ②、把 d\\[2\\] 有序地放到 B 里，令 B\\[1\\] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d\\[1\\] = 2 已经没用了，因为 2 &gt; 1。 ③、d\\[3\\] = 5，因为 d\\[3\\] &gt; B\\[1\\]，所以令 B\\[1+1\\] = B\\[2\\] = d\\[3\\] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B\\[\\] = { 1, 5 }。 ④、d\\[4\\] = 3，B\\[1\\] &lt; d\\[3\\] &lt; B\\[2\\]，放在 B\\[1\\] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B\\[\\] = { 1, 3 }。 ⑤、d\\[5\\] = 6，因为 d\\[5\\] &gt; B\\[2\\]，所以令 B\\[2+1\\] = B\\[3\\] = d\\[5\\] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B\\[\\] = { 1, 3, 6 }。 ⑥、d\\[6\\] = 4，3 &lt; d\\[6\\] &lt; 6，于是把 6 替换掉，这时 Len = 3, B\\[\\] = { 1, 3, 4 }。 ⑦、d\\[7\\] = 8，d\\[7\\] &gt; B\\[3\\]，将 8 追加到 B 数组末尾，这时 Len = 4, B\\[\\] = { 1, 3, 4, 8 }。 ⑧、d\\[8\\] = 9，d\\[8\\] &gt; B\\[4\\]，将 9 追加到 B 数组末尾，这时 Len = 5, B\\[\\] = { 1, 3, 4, 8, 9 }。 ⑨、d\\[9\\] = 7，B\\[3\\]=4 &lt; d\\[9\\] &lt; B\\[4\\]=8，所以最新的 B\\[4\\] = 7，这时 Len = 5, B\\[\\] = 1, 3, 4, 7, 9。 注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。 有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。 在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1int upper_bound(int B[], int left, int right, int key)&#123; int mid; // 将 key 插入到数组末尾 if (B[right] &lt; key) return right + 1; // num[left] ≤ key &lt; nums[right] 之后 left 将大于 right，循环结束 while (left &lt; right) &#123; mid = (left + right) / 2; if (B[mid] &lt; key) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125;int lengthOfLIS(int* nums, int numsSize)&#123; if (numsSize &lt; 2) return numsSize; int* B = (int *)malloc(sizeof(int) * (numsSize + 1)); B[0] = 0; // 无意义 B[1] = nums[0]; // 从 1 开始是为了让 len、pos 不需要 -1 或 +1 int len = 1; for (int i = 1; i &lt; numsSize; i++) &#123; // 找到插入位置 int pos = upper_bound(B, 1, len, nums[i]); B[pos] = nums[i]; // 打印 B 数组，看看每次循环的变化，B[0] 无意义 printf(\"%d \", pos); for (int k = 0; k &lt;= pos; k++) &#123; printf(\"%d\", B[k]); &#125; printf(\"\\n\"); if (len &lt; pos) &#123; len = pos; &#125; &#125; return len;&#125;int main()&#123; int A[] = &#123; 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 &#125;; printf(\"%d\", lengthOfLIS(A, 11)); return 0;&#125;","tags":[]},{"title":"整数划分","date":"2019-08-05T16:07:52.654Z","path":"2019/08/06/算法/整数划分/","text":"1、问题描述将一个正整数 n 写成如下形式 n = m1 + m2 + ... + mi; （其中 mi 为正整数，并且 1 &lt;= mi &lt;= n），则 {m1, m2, ..., mi} 为 n 的一个划分。 如果 { m1, m2, …, mi } 中的最大值不超过 m，即 max(m1, m2, …, mi) &lt;= m，则称它属于 n 的一个 m 划分。 算法分析这里记 n 的 m 划分的个数为 f(n, m); 例如当 n = 4 时，有 5 个划分 {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1}; 该问题是求出 n 的所有划分个数，即 f(n, n)。下面考虑求 f(n,m) 的方法。 ①、m = 1 || n = 1 只有一种划分情况，即 n 个 1 相加， 所以 f(n, m) = 1; ②、m = n &gt; 1 f(n, m) = f(n, n-1) + 1 加上的 1 代表 n + 0 = n 这个划分方案 ③、n &lt; m f(n, m) = f(n, n) 逻辑上不存在 m &gt; n 的情况 ④、n &gt; m f(n, m) = f(n, m-1) + f(n-m, m); f(n, m-1) 表示划分方案中没有 m 的情况，f(n-m, m) 表示划分方案中有 m 的情况。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;/** * @brief 整数划分问题，将一个整数划分为若干个数相加。例：整数 4，最大加数 4 4 =4 + 0 1+3=4 1+1+2=4 2+2=4 1+1+1+1=4 注意：1+3=4，3+1=4被认为是同一种划分方案 * @param n 需要划分的数字 * @param m 最大的加数 */int algorithm(int n, int m)&#123; if (n == 1 || m == 1) &#123; // 只要存在一个为 1，那么划分的方法数肯定只有一种，那就是 n 个 1 相加 return 1; &#125; else if (n == m &amp;&amp; n &gt; 1) &#123; // 等价于：q(n, n-1) + 1; 最后面 +1 代表的是：0+n，这个划分的方案 return algorithm(n, m - 1) + 1; &#125; else if (n &lt; m) &#123; // 如果 m &gt; n,那么令 m = n，因为最大加数在逻辑上不可能超过 n return algorithm(n, n); &#125; else if (n &gt; m) &#123; // 分为两种：划分方案没有 m 的情况 + 划分方案有 m 的情况 return algorithm(n, m - 1) + algorithm(n - m, m); &#125; return 0;&#125;int main()&#123; int r = algorithm(7, 7); printf(\"%d\\n\", r); return 0;&#125;","tags":[]},{"title":"循环赛日程表","date":"2019-08-05T16:07:52.653Z","path":"2019/08/06/算法/循环赛日程表/","text":"1、问题描述设有 n = 2k 个运动员要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表 ①、每个选手必须与其他 n-1 个选手各赛一场 ②、每个选手一天只能比赛一场 ③、循环赛一共进行 n-1 天 2、算法分析按此要求可将比赛日程表设计成 n 行 n-1 列的表，在表中第 i 行和第 j 列处填入第 i 个选手在第 j 天所遇到的对手。 按分治策略，可以将所有的选手分为两半，则 n 个选手的比赛日程表可以通过 n/2 个选手的比赛日程表来决定。递归地用一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单，这时只要让这两个选手进行比赛就可以了。 通过 k 增长来看算法实现步骤： ①、当 k = 1 时，n = 21 = 2 人，循环表为 **&lt;font color=#cc0000&gt;1&lt;/font&gt; &lt;font color=#008200&gt;2&lt;/font&gt;** **&lt;font color=#008200&gt;2&lt;/font&gt; &lt;font color=#cc0000&gt;1&lt;/font&gt;** ②、当 k = 2 时，n = 22 = 4 人，循环表为 **&lt;font color=#cc0000&gt;1 2&lt;/font&gt; &lt;font color=#008200&gt;3 4&lt;/font&gt;** **&lt;font color=#cc0000&gt;2 1&lt;/font&gt; &lt;font color=#008200&gt;4 3&lt;/font&gt;** **&lt;font color=#008200&gt;3 4&lt;/font&gt; &lt;font color=#cc0000&gt;1 2&lt;/font&gt;** **&lt;font color=#008200&gt;4 3&lt;/font&gt; &lt;font color=#cc0000&gt;2 1&lt;/font&gt;** ③、当 k = 3 时，n = 23 = 8 人，循环表为 **&lt;font color=#cc0000&gt;1 2 3 4&lt;/font&gt; &lt;font color=#008200&gt;5 6 7 8&lt;/font&gt;** **&lt;font color=#cc0000&gt;2 1 4 3&lt;/font&gt; &lt;font color=#008200&gt;6 5 8 7&lt;/font&gt;** **&lt;font color=#cc0000&gt;3 4 1 2&lt;/font&gt; &lt;font color=#008200&gt;7 8 5 6&lt;/font&gt;** **&lt;font color=#cc0000&gt;4 3 2 1&lt;/font&gt; &lt;font color=#008200&gt;8 7 6 5&lt;/font&gt;** **&lt;font color=#008200&gt;5 6 7 8&lt;/font&gt; &lt;font color=#cc0000&gt;1 2 3 4&lt;/font&gt;** **&lt;font color=#008200&gt;6 5 8 7&lt;/font&gt; &lt;font color=#cc0000&gt;2 1 4 3&lt;/font&gt;** **&lt;font color=#008200&gt;7 8 5 6&lt;/font&gt; &lt;font color=#cc0000&gt;3 4 1 2&lt;/font&gt;** **&lt;font color=#008200&gt;8 7 6 5&lt;/font&gt; &lt;font color=#cc0000&gt;4 3 2 1&lt;/font&gt;** 以此类推，可以用分治的方法实现，先自顶向下分解，直到分解到最简单的情况，即人数为 2 人，这时就可以两两比赛，表的填充为对角填充的方式，然后再自底向上填充表格，具体的看上面的 k = 1、k = 2、k = 3 时形成的循环表就很好理解了。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#define N 64void GameTable(int k, int a[][N])&#123; int n = 2; // 选手数 // 求解两个选手比赛日，得到左上角元素 a[0][0] = 1; a[0][1] = 2; a[1][0] = 2; a[1][1] = 1; int i, j, half; // 循环处理，依次处理 2^2 ... 2^k 个选手比赛日程 for (int t = 1; t &lt; k; t++) &#123; half = n; // 当前选手数的 1 / 2 n *= 2; // 当前选手数 // 左下角 for (i = half; i &lt; n; i++) // 行 for (j = 0; j &lt; half; j++) // 列 a[i][j] = a[i - half][j] + half; // 右上角 for (i = 0; i &lt; half; i++) for (j = half; j &lt; n; j++) a[i][j] = a[i + half][j - half]; // 右下角 for (i = half; i &lt; n; i++) for (j = half; j &lt; n; j++) a[i][j] = a[i - half][j - half]; &#125; printf(\"运动员编号\\t\"); for (i = 1; i &lt; n; i++) &#123; printf(\"第 %d 天\\t\", i); &#125; printf(\"\\n\\n\"); for (i = 0; i &lt; n; i++) &#123; printf(\" %d 号 \\t\", i + 1); for (j = 1; j &lt; n; j++) printf(\" %d\", a[i][j]); printf(\"\\n\"); &#125;&#125;int main()&#123; int a[N][N] = &#123; 0 &#125;; int k = 3; printf(\"******************************************\\n\"); printf(\"\\t\\t**\\t\\t循环赛日程表\\t\\t**\\n\"); printf(\"******************************************\\n\\n\"); GameTable(k, a); return 0;&#125;****************************************** ** 循环赛日程表 ********************************************运动员编号 第 1 天 第 2 天 第 3 天 第 4 天 第 5 天 第 6 天 第 7 天 1 号 2 3 4 5 6 7 8 2 号 1 4 3 6 5 8 7 3 号 4 1 2 7 8 5 6 4 号 3 2 1 8 7 6 5 5 号 6 7 8 1 2 3 4 6 号 5 8 7 2 1 4 3 7 号 8 5 6 3 4 1 2 8 号 7 6 5 4 3 2 1 4、学习文章算法之循环赛日程表","tags":[]},{"title":"挖金矿","date":"2019-08-05T16:07:52.653Z","path":"2019/08/06/算法/挖金矿/","text":"原文：https://juejin.im/post/5a29d52cf265da43333e4da7 1、问题描述有 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 2、算法分析w 表示总共人数，n 表示金矿数， ①、排列组合 每一座金矿都有挖与不挖两种选择，排列组合起来就有 2n 种选择。对所有可能性做遍历，剔除那些使用工人数超过 10 的选择，在剩下的选择里找出获得金币数最多的选择。 时间复杂度：O(2n)。 ②、递归 每个金矿存在”挖”、”不挖”两种情况，可以同时内部调用两次递归方法，表示”挖”和”不挖”。 12345678910void A()&#123; if (边界条件) return x; // 挖 A(); // 不挖 A();&#125; 时间复杂度：O(2n) 开辟空间：递归深度 O(n) ③、动态规划 这个问题与 0-1 背包问题相同，动态规划时的策略也是：当前金矿是否应该挖，挖与不挖的价值比较。整理出以下表格。 【状态】是 f(w)，【边界】是 f(w &lt; 3) = 0；状态方程 f(w) = max{ f(w - 1), f(w - i) + vi }, w &gt; i i 表示当前金矿需要的人数，vi 表示当前金矿的价值。 时间复杂度：O(n*w) 空间复杂度：O(n*w) 如果不保留挖金矿信息，只输出最高金币数，可以由上发现，每一层的数据只与上一层有关，那么就可以由上至下，只用一位数组保存状态，空间复杂度 O(w)。 ④、比较 当工人数 w -&gt; ∞ 时，动态规划的时间复杂度和空间复杂度与 w 成正比，所以增长较快；而递归算法与 w 无关，所以不增长，此时动态规划的效率就没有递归的好。 3、代码实现①、递归（自底向上） 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (a) &gt; (b) ? (a) : (b)typedef struct GoldMine &#123; int worker; int gold;&#125; GoldMine;/** * mineNum 金矿数 * workerNum 挖矿总人数 * curMine 当前金矿（从 0 开始） * curWorker 当前人数（从 0 开始） * max 当前最大金币数 */ int monerFinderAlgorithm(GoldMine* mines, int mineNum, int workerNum, int curMine, int curWorker, int max)&#123; GoldMine curGoldMine = mines[curMine]; // 金矿挖完了 || 人数不够了 if (curMine &gt;= mineNum || curWorker + curGoldMine.worker &gt; workerNum) return max; // 挖 int dig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker + curGoldMine.worker, max + curGoldMine.gold); // 不挖 int noDig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker, max); return MAX(dig, noDig);&#125;int main()&#123; GoldMine mines[5] = &#123; &#123;3, 200&#125;, &#123;4, 300&#125;, &#123;3, 350&#125;, &#123;5, 400&#125;, &#123;5, 500&#125; &#125;; printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 5, 10, 0, 0, 0)); //GoldMine mines[2] = &#123; &#123;4, 300&#125;, &#123;5, 500&#125; &#125;; //printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 2, 10, 0, 0, 0)); return 0;&#125; ②、动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (a) &gt; (b) ? (a) : (b)typedef struct GoldMine &#123; int worker; int gold;&#125; GoldMine;/// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker)&#123; if (worker == 0 || mineNum == 0) return 0; // i 列 j 行 int i = 0, j = 0; // 二维数组，从左向右，第一个 [ ] 是列，第二个 [ ] 是行 int goldMatrix[worker + 1][mineNum]; // 初始化并打印二维数组 for (; j &lt; mineNum; j++) &#123; for (i = 0; i &lt;= worker; i++) &#123; goldMatrix[i][j] = 0; printf(\"0 \"); // printf(\"%d \", goldMatrix[i][j]); &#125; printf(\"\\n\"); &#125; printf(\"\\n\"); GoldMine mine; for (i = 1; i &lt;= worker; i++) &#123; for (j = 0; j &lt; mineNum; j++) &#123; mine = mines[j]; // 挖矿人数不够 if (mine.worker &gt; i) &#123; // 第一个存储 0，非第一个存储前一个 j 的值 goldMatrix[i][j] = (j == 0) ? 0 : goldMatrix[i][j-1]; &#125; // 挖矿人数足够 else &#123; // 第一个直接存储，非第一个存储 MAX&#123; 不加入 j 的值， 加入 j 的值 &#125;，j -1 是因为剔除了当前 goldMatrix[i][j] = (j == 0) ? mine.gold : MAX(goldMatrix[i][j-1], goldMatrix[i-mine.worker][j-1] + mine.gold); &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; mineNum; j++) &#123; for (i = 1; i &lt;= worker; i++) printf(\"%d \", goldMatrix[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); // 挖哪些矿 int curWorker = worker; for (j = mineNum - 1; j &gt;= 0; j--) &#123; mine = mines[j]; if (curWorker == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (goldMatrix[curWorker][j] - goldMatrix[curWorker - mine.worker][j-1] == mine.gold) &#123; printf(\"%d \", mine.worker); curWorker -= mine.worker; &#125; &#125; return goldMatrix[worker][mineNum - 1];&#125;int main()&#123; GoldMine mines[5] = &#123; &#123;3, 200&#125;, &#123;4, 300&#125;, &#123;3, 350&#125;, &#123;5, 400&#125;, &#123;5, 500&#125; &#125;; printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 5, 10)); //GoldMine mines[2] = &#123; &#123;4, 300&#125;, &#123;5, 500&#125; &#125;; //printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 2, 10)); return 0;&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 200 200 200 200 200 200 200 200 0 0 200 300 300 300 500 500 500 500 0 0 350 350 350 550 650 650 650 850 0 0 350 350 400 550 650 750 750 850 0 0 350 350 500 550 650 850 850 900 5 5 900 空间复杂度 O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker)&#123; if (worker == 0 || mineNum == 0) return 0; int* preGoldMatrix = (int *)calloc(sizeof(int), worker); int* goldMatrix = (int *)calloc(sizeof(int), worker); GoldMine mine; for (int i = 0; i &lt; mineNum; i++) &#123; mine = mines[i]; // 从 1 开始计算 for (int j = 1; j &lt;= worker; j++) &#123; // 挖矿人数不够 if (j &lt; mine.worker) &#123; goldMatrix[j-1] = preGoldMatrix[j-1]; &#125; // 挖矿人数足够 else &#123; // 从上一层中 [j - mine.worker - 1] 和 [j - 1] 中获取最大值 goldMatrix[j-1] = MAX(preGoldMatrix[j-1], preGoldMatrix[j - mine.worker - 1] + mine.gold); &#125; printf(\"%d \", goldMatrix[j - 1]); &#125; printf(\"\\n\"); // 打印 preGoldMatrix、goldMatrix 数组的内容// for (int k = 0; k &lt; worker; k++) &#123;// printf(\"%d \", preGoldMatrix[k]);// &#125;// printf(\"\\n\");//// for (int k = 0; k &lt; worker; k++) &#123;// printf(\"%d \", goldMatrix[k]);// &#125;// printf(\"\\n\\n\"); for (int k = 0; k &lt; worker; k++) &#123; // 不能使用 preGoldMatrix = goldMatrix; 这是指针赋值，preGoldMatrix 与 goldMatrix 内存地址一样 preGoldMatrix[k] = goldMatrix[k]; &#125; //printf(\"%p %p\", preGoldMatrix, goldMatrix); // 打印数组的内存地址 &#125; return goldMatrix[worker - 1];&#125;","tags":[]},{"title":"寻找假币","date":"2019-08-05T16:07:52.652Z","path":"2019/08/06/算法/寻找假币/","text":"1、问题描述一个袋子里有若干硬币，其中一枚是假币，并且和假币和真币一模一样，目前只知道假币比真币轻一点。请问如何找到这枚假币？ 2、算法分析根据分治的策略，将硬币平分为两份（奇数个硬币取出中间的硬币后再平分），比较两边的重量之和的大小。左侧重，则假币在右半段，反之，假币在左半段（或者中间的假币），然后继续在有假币的半区查找，直到剩余两个硬币，比较大小后，返回假币的位置。 时间复杂度：O(logn)。 3、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#define MAXNUM 30int FalseCoin(int coin[], int low, int high)&#123; // 两个硬币的比较 if (low + 1 == high) &#123; if (coin[low] &lt; coin[high]) &#123; return low + 1; &#125; return high + 1; &#125; int sum1 = 0, sum2 = 0, sum3 = 0; int mid = (low + high) &gt;&gt; 1; int i; // 偶数个硬币 if ((high - low + 1) % 2 == 0 ) &#123; // 左半段 for (i = low; i &lt;= mid; i++) &#123; sum1 += coin[i]; &#125; // 右半段 for (i = mid + 1; i &lt;= high; i++) &#123; sum2 += coin[i]; &#125; // 左侧重，则假币在右半段 if (sum1 &gt; sum2) &#123; return FalseCoin(coin, mid + 1, high);; &#125; // 右侧重，则假币在左半段 else if (sum2 &gt; sum1)&#123; return FalseCoin(coin, low, mid);; &#125; else &#123; printf(\"没有假币。输入的硬币重量有误！\"); &#125; &#125; // 奇数个硬币 else &#123; // 左半段，除去中间的一个硬币 for (i = low; i &lt;= mid - 1; i++) &#123; sum1 += coin[i]; &#125; // 右半段，除去中间的一个硬币 for (int i = mid + 1; i &lt;= high; i++) &#123; sum2 += coin[i]; &#125; sum3 = coin[mid]; // 左侧重，则假币在右半段 if (sum1 &gt; sum2) &#123; return FalseCoin(coin, mid + 1, high); &#125; // 右侧重，则假币在左半段 else if (sum2 &gt; sum1)&#123; return FalseCoin(coin, low, mid - 1); &#125; else &#123; // 中间的是假币 if (coin[mid] != coin[low]) &#123; return mid + 1; &#125; else &#123; printf(\"没有假币。输入的硬币重量有误！\"); &#125; &#125; &#125; return -1;&#125;int main()&#123; int coin[] = &#123; 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 &#125;; int position = FalseCoin(coin, 0, 9); printf(\"假币在第 %d 个位置\", position); return 0;&#125;假币在第 4 个位置","tags":[]},{"title":"大整数相乘","date":"2019-08-05T16:07:52.652Z","path":"2019/08/06/算法/大整数相乘/","text":"学习文章：分治算法详解、分治法的经典问题——大整数相乘 1、问题描述计算两个很大整数的结果，例如：27392361983108271361039746313 * 37261038163103818366341087632113 2、算法分析先用一个简单的例子，如 234 * 456 = ？？？来考虑。在这里考虑将 456 拆分为 4、5、6，然后分别去乘以 234。 234 x 456 -------------------- 1404 1170 936 -------------------- 106704 这就是熟悉的竖式计算乘法的结构，看着每一步计算出来的结果，一层一层的，是否看起来像二维数组？我们就用二维数组来保存结果，数组的第一行保留 1404，第二行保留 11700，第三行保留 93600。由于不能直接存储，需要对存放的位置做一下计算：数组该有多少行，该有多少列？ 在这里我们需要知道，3 位 3 位，结果最多为 6 位数；2 位 6 位，结果最多为 2 + 6 = 8 位，所以这里数组该有 6 列，而对于行数，则由被乘数决定，所以这里为 3 行。 temp[3][6] = { 0 0 1 4 0 4 0 1 1 7 0 0 0 9 3 6 0 0 } 每列依次往下加 1 0 6 7 0 4; 所得刚好为我们要的答案。 3、代码实现时间复杂度 O(n2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#define num1 11#define num2 6void MultiOfLargeNumbers(int a1[], int a2[])&#123; int temp[num2][num1 + num2] = &#123; 0 &#125;; // 注意：二维数组列数的规律 int x, y; // x - 行数，y - 列数 uint isCarry = 0; // 进位值 // 打印二维数组 for (int i = 0; i &lt; num2; i++) &#123; // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(\"%d \", temp[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); for(int idx2 = num2 - 1; idx2 &gt;= 0; idx2--) &#123; // 乘数 x = num2 - idx2 - 1; y = num1 + idx2; for(int idx1 = num1 - 1; idx1 &gt;= 0; idx1--, y--) &#123; // 被乘数 // 加上进位数值 temp[x][y] = a1[idx1] * a2[idx2] + isCarry; isCarry = 0; // 当前计算结果需要进位，计算进位数值和结果数值 if(temp[x][y] &gt;= 10) &#123; isCarry = temp[x][y] / 10; temp[x][y] %= 10; &#125; &#125; if(isCarry) &#123; // 首位有进位 temp[x][y] += isCarry; isCarry = 0; &#125; &#125; // 合并 int temp_sum[num1 + num2] = &#123;0&#125;; // 将每一列的数组到最后的结果数组里面 for(int j = num2 + num1 - 1; j &gt;= 0; j--) &#123; // 列 for(int i = num2 - 1; i &gt;= 0; i--) &#123; // 行 temp_sum[j] += temp[i][j]; &#125; if (isCarry) &#123; temp_sum[j] += isCarry; isCarry = 0; &#125; if( temp_sum[j] &gt;= 10) &#123; isCarry = temp_sum[j] / 10; temp_sum[j] %= 10; &#125; &#125; // 打印二维数组 for (int i = 0; i &lt; num2; i++) &#123; // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(\"%d \", temp[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); // 打印相乘结果 for(int i = 0; i &lt; num2 + num1; i++) printf(\"%d\", temp_sum[i]);&#125;int main()&#123; //int a1[num1] = &#123; 2, 3, 4 &#125;; //int a2[num2] = &#123; 4, 5, 6 &#125;; // 2739236198310827136103974、37261038163103818366 int a1[num1] = &#123; 2, 7, 3, 9, 2, 3, 6, 1, 9, 8, 3 &#125;; int a2[num2] = &#123; 3, 7, 2, 6, 1, 0 &#125;; MultiOfLargeNumbers(a1, a2); return 0;&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 7 3 9 2 3 6 1 9 8 3 0 0 0 0 1 6 4 3 5 4 1 7 1 8 9 8 0 0 0 0 0 5 4 7 8 4 7 2 3 9 6 6 0 0 0 0 1 9 1 7 4 6 5 3 3 8 8 1 0 0 0 0 0 8 2 1 7 7 0 8 5 9 4 9 0 0 0 0 0 10206667998485630 4、分治法首先将 X 分为 A、B 和 Y 分成 C、D。注意：这里的 X、Y 假设位数相同。 此时将 X 和 Y 的乘积转化，把问题转化为求解式子的值。 分析一下：对这个式子，一共要进行 4 次 n/2 的乘法（AC 2 次， AD、BC 各 1 次）和 3 次加法，因而该算法的时间复杂度为 T(n) = 4 * T(n/2) + θ(n) 通过 master 定理可以求得 T(n) = θ(n2)，跟小学算法的时间复杂度没有区别。 但是我们再来看看，我们是否可以用加法来换取乘法？因为多一个加法操作，也是常数项，对时间复杂度没有影响，如果减少一个乘法则不同。 时间复杂度为： T(n) = 3 * T(n/2) + θ(n)，通过 master 定理求得 T(n) = O(nlog23) = O(n1.59)。","tags":[]},{"title":"图片设置圆角性能问题","date":"2019-08-05T16:07:52.651Z","path":"2019/08/06/iOS/iOS优化/iOS 图片圆角性能/","text":"通常设置圆角方式 12imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50; 这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。 注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。 一、设置圆角的方法①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。 ②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化 1234imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50;imageView.layer.shouldRasterize = YES; // 设置光栅化imageView.layer.rasterizationScale = [UIScreen mainScreen].scale; // UIImageView 不加这句会产生一点模糊 设置光栅化可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。 但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 ③、直接覆盖一张中间为圆形透明的图片（推荐使用） 这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。 这种圆片覆盖的方法一般只用在底色为纯色的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色） ④、UIImage drawInRect 绘制圆角 这种方式 GPU 损耗低内存占用大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface CornerImageView ()&#123; NSBlockOperation * _operation; // 任务 NSOperationQueue * _queue; UIImage * _cornerImage; // 圆角化的图片&#125;@end@implementation CornerImageView- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; _queue = [[NSOperationQueue alloc] init]; &#125; return self;&#125;/** * 重写设置方法。如果是 UIButton 可以换成 setImage:forState: */- (void)setImage:(UIImage *)image&#123; [super setImage:nil]; [self roundedImage:image];&#125;- (void)roundedImage:(UIImage *)image&#123; [_queue cancelAllOperations]; [_operation cancel]; _operation = nil; _operation = [NSBlockOperation blockOperationWithBlock:^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, [UIScreen mainScreen].scale); // Add a clip before drawing anything, in the shape of an rounded rect [[UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:self.bounds.size.height / 2] addClip]; [image drawInRect:self.bounds]; _cornerImage = UIGraphicsGetImageFromCurrentImageContext(); // Lets forget about that we were drawing UIGraphicsEndImageContext(); if (!_operation) &#123; return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [super setImage:_cornerImage]; &#125;); &#125;]; [_queue addOperation:_operation];&#125; 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。 问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？ ⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface UIImage (corner)+ (id)createRoundedRectImage:(UIImage *)image;@end@implementation UIImage (corner)static void addRoundedRectToPath(CGContextRef context, CGRect rect, float ovalWidth, float ovalHeight)&#123; float fw, fh; if (ovalWidth == 0 || ovalHeight == 0) &#123; CGContextAddRect(context, rect); return; &#125; CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); CGContextScaleCTM(context, ovalWidth, ovalHeight); fw = CGRectGetWidth(rect) / ovalWidth; fh = CGRectGetHeight(rect) / ovalHeight; // 使的圆角半径为 1 CGContextMoveToPoint(context, fw, fh/2); // Start at lower right corner CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1); // Top right corner CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1); // Top left corner CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1); // Lower left corner CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); // Back to lower right CGContextClosePath(context); CGContextRestoreGState(context);&#125;+ (id)createRoundedRectImage:(UIImage *)image&#123; CGFloat wh = MIN(MAX(image.size.width, image.size.height), 160); CGSize imageSize = CGSizeMake(wh, wh); CGfloat radius = wh / 2; CGContextRef context = CGBitmapContextCreate( NULL, wh, wh, 8, 4 * wh, CGColorSpaceCreateDeviceRGB(), kCGImageAlphaPremultipliedFirst ); // 绘制圆角 CGContextBeginPath(context); addRoundedRectToPath(context, CGRectMake(0, 0, wh, wh), radius, radius); CGContextClosePath(context); CGContextClip(context); CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); CGImageRef imageMasked = CGBitmapContextCreateImage(context); image = [UIImage imageWithCGImage:imageMasked]; CGContextRelease(context); CGImageRelease(imageMasked); return image;&#125; 以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。 123456/** * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 '(x1，y1)' 的直线相切，与 '(x1，y1)' 到 '(x2, y2)' 的直线相切。 */CG_EXTERN void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) CG_AVAILABLE_STARTING(10.0, 2.0); 二、使用 Instruments 的 Core Animation 查看性能 Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 用 Instruments 测试得： ①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。 ②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。 ③、添加圆形透明图片，无任何高亮，说明没离屏渲染。 ④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大） ⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法) 三、问题①、有提到还有一种 mask 方法。 这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考小心别让圆角成了你列表的帧数杀手。 ②、第四种比第一种更卡。 第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。 可以用 Instruments的 GPU Driver 进行测试： Renderer Utilization 如果这个值 &gt; 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization 如果这个值 &gt; 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。 第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。 帧率越接近 60 滑动越顺畅。 发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。 如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。 而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。 所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。 四、参考文章 内存恶鬼drawRect - 谈画图功能的内存优化 github 绘制圆角源码参考 NZCircularImageView、HJCornerRadius","tags":[]},{"title":"全排列","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/算法/全排列/","text":"1、问题描述有 n 个数或字符，有多少种排列方法。 2、算法分析采用分治法把大问题分解成很多的子问题。大问题是所有的排列方法，分解得到的小问题就是以 1 开头的排列，以 2 开头的排列，以 a 开头的排列，以 b 开头的排列…把这些问题继续分解，以 12 开头的排列，以 123 开头的排列…将余下的看成大问题，一直分解下去，直到分解成的子问题只有一个数字或字符的时候，不再分解。 因为 1 个数字或字符肯定只有一种排列方式，现在将每个解决了的小问题合并，合并成一个大点的问题，合并之后这个大点的问题也解决了，再将这些大点的问题合并成一个更大的问题，直到最大的问题解决为止。 先固定一个字符，然后将固定的字符与它后面的每一个进行交换，一直递归下去，直到固定的字符后面只有一个字符。 下图中，红色字符是被固定的字符，白色字符的没有被固定的字符。具体做法就是每次将没有固定的第一个字符与其他未固定的字符交换（第 1 个与第 1个交换，第 1 个与第 2 个交换，… 第 1 个与第 n 个交换），直到只剩下一个没有被固定的字符时，输出此时的字符排列，但是输出之后要将字符的位置还原。 全排列可以看做固定前 i 位，对第 i+1 位之后的再进行全排列，比如固定第一位，后面跟着 n-1 位的全排列。那么解决 n-1 位元素的全排列就能解决 n 位元素的全排列了。 3、代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;char temp;void swapChar(char a[], int i, int k)&#123; temp = a[i]; a[i] = a[k]; a[k] = temp;&#125;void algorithm(char a[], int start, unsigned long count)&#123; // 深度控制。此时只剩一个没有固定的字符，直接输出 if(start == count - 1) &#123; puts(a); return; &#125; for(int i = start; i &lt; count; i++) &#123; swapChar(a, i, start); // 交换 algorithm(a, start + 1, count); swapChar(a, i, start); // 复原 &#125;&#125;int main()&#123; char arr[100] = &#123; 'a', 'b', 'c' &#125;; // gets(a); algorithm(arr, 0, strlen(arr)); return 0;&#125;","tags":[]},{"title":"利用预渲染加速iOS设备的图像显示","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/iOS/iOS优化/iOS 预渲染加速图像显示/","text":"使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。 于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。 接着下面举个例子程序来验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;UIKit/UIKit.h&gt;@interface ImageView : UIView@property (nonatomic, strong) UIImage * image;@end#import \"ImageView.h\"#include &lt;mach/mach_time.h&gt;static const CGRect imageRect = &#123; &#123;0, 0&#125;, &#123;100, 100&#125;&#125;;@implementation ImageView- (void)awakeFromNib&#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; &#125; [superawakeFromNib];&#125; - (void)drawRect:(CGRect)rect&#123; if (CGRectContainsRect(rect, imageRect)) &#123; uint64_t start = getTickCount(); [self.image drawInRect:imageRect]; uint64_t drawTime = getTickCount() - start; NSLog(@\"%llu\", drawTime); // 打印时间间隔 &#125;&#125;// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。uint64_t getTickCount(void)&#123; static mach_timebase_info_data_t sTimebaseInfo; uint64_t machTime = mach_absolute_time(); // Convert to nanoseconds - if this is the first time we've run, get the timebase. if (sTimebaseInfo.denom == 0) &#123; (void)mach_timebase_info(&amp;sTimebaseInfo); &#125; uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom; // 纳秒 return millis;&#125;@end 测试用一张 1838 * 890 的图 2018-07-05 11:05:25.950978+0800 Demo[5831:113872] 31802012 接下来就是见证奇迹的时刻了，把这段代码加入程序： 12345678910111213141516static const CGSize imageSize = &#123;100, 100&#125;;- (void)awakeFromNib &#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; // 由于JPEG图像是不透明的，所以第二个参数就设为YES // 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了 UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0); // 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作 [image drawInRect:imageRect]; self.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); &#125;&#125; 值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。 时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] 127939，缩短了很多。 还能更快吗？让我们来试试 Core Graphics。 先定义一个全局的 CGImageRef 变量： 123456static CGImageRef imageRef;- (void)awakeFromNib&#123; imageRef = self.image.CGImage;&#125; 然后 12345- (void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawImage(context, imageRect, imageRef);&#125; 运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] 27425265，而且图像还上下颠倒了⋯ 这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正： 1234CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, 0, 100);CGContextScaleCTM(context, 1, -1);CGContextDrawImage(context, imageRect, imageRef); 这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] 34242146，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。","tags":[]},{"title":"iOS 图片加载和处理","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/iOS/iOS优化/iOS 图片加载和处理/","text":"一、图片显示图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。 以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。UIImage 持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。 当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。 解码是一个计算量较大且需要 CPU 来执行的任务；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 高 每个像素点的大小 = width height 4bytes。 图像解码操作会造成什么问题？ 以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于在主线程同时进行 IO 操作、解码操作等，会造成内存迅速增长和 CPU 负载瞬间提升。 并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。 1.1 优化一：降采样在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示： 我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。 思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？ 12345678910111213141516171819202122- (UIImage *)downsampleImageAt:(NSURL *)imageURL to:(CGSize)pointSize scale:(CGFloat)scale&#123; CFDictionaryRef imageSourceOptions = CFDictionaryCreate ( CFAllocatorGetDefault(), (void *)@[ (NSString *)kCGImageSourceShouldCache ], (void *)@[ @(YES) ], 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, imageSourceOptions); NSInteger maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale; CFDictionaryRef downsampleOptions = (__bridge CFDictionaryRef)@&#123; (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @(YES), (NSString *)kCGImageSourceShouldCacheImmediately : @(YES), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @(YES), (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;; CGImageRef downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions); return [UIImage imageWithCGImage:downsampledImage];&#125; 正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。 1.2 优化二：异步处理 从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以在 Prefetching 时把降采样放到子线程进行处理，因为降采样过程就包括解码操作。 Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。 需要特别注意，此处不能是并发队列，否则会造成线程爆炸，原因见总结部分。 123456789101112131415161718192021222324252627282930313233343536&#123; // 创建串行队列 _serialQueue = dispatch_queue_create(\"DecodeQueue\", DISPATCH_QUEUE_SERIAL);&#125;/** * @brief 获取单元格的图片 */- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAt:(NSArray&lt;NSIndexPath *&gt; *)indexPaths&#123; for (NSIndexPath * indexPath in indexPaths) &#123; dispatch_async(_serialQueue, ^&#123; UIImage * downsampledImage = [self downsample]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self updateAt:indexPath with:downsampledImage]; &#125;); &#125;); &#125;&#125;/** * @brief 降采样。自行实现。 */- (UIImage *)downsample&#123; return nil;&#125;/** * @brief 更新单元格的图片 */- (void)updateAt:(NSIndexPath *)indexPath with:(UIImage *)image&#123; &#125; 1.3 优化三：使用 Image Asset Catalogs苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。 WWDC Session。 二、总结应用上述的优化策略，已经能对图片加载有比较好的优化。 WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。 三、WWDC学习原作者的经验：落影loyinglin 先主观假设两个前提： 大部分苹果工程师对 iOS 系统内部实现都比我们要清楚； 能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。 所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，看我们的 iOS 知识体系是否存在缺陷；另外，WWDC 介绍的很多知识点同样免验证的加入自己的知识体系。 以上文提到的线程爆炸为例，看看这种方式的好处。 原文如下： Thread Explosion（线程爆炸） More images to decode than available CPUs（解码图像数量大于 CPU 数量）GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像） 从这个案例我们学习到如何避免图像解码的线程爆炸，我们分析苹果工程师的逻辑，然后扩散思维： 原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间 延伸出来的问题： GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？… 举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来： GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别； 串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。 接下来的表现是操作系统相关的知识： iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程； cpu 的时间是分为多个时间片，每个线程轮询执行； 线程切换执行有代价，但比进程切换小得多； 每个 cpu 核心在同一时刻只能执行一个线程。 至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现： 主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。 结合此案例，我们能回答相关问题： 现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？ GCD 的串行队列和并发队列的应用场景有何不同？ 四、文章iOS性能优化–图片加载和处理 WWDC2018-Image and Graphics Best Practices","tags":[]},{"title":"二分查找","date":"2019-08-05T16:07:52.649Z","path":"2019/08/06/算法/二分查找/","text":"1、问题描述在一个有序（升序）数组查找一个数 x 2、算法分析暴力的做法就是拿 x 跟数组里面每个数比较一下，然后返回找到的 x 的下标。这里明显可以使用分治的思想：可以把数组分成很多部分，在每个部分里面查找 x。如果所有部分都没有找到 x，那么把这些子问题合并起来后，表示整个数组里没有 x。 这很好的反应了分治的思想，先分解成很多小问题，解决这些小问题，把解决的小问题合并起来，大问题就解决了。 3、代码实现递归： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;/** * @param a 需要二分的升序数组 * @param x 需要查找的数字 * @param low 低位 * @param high 高位 */int binarysearch(int a[], int x, int low, int high)&#123; if(low &gt; high) &#123; return -1; // 没有找到 &#125; int mid = (low + high) &gt;&gt; 1; if(x == a[mid]) &#123; return mid; // 找到 x &#125; else if(x &gt; a[mid]) &#123; return binarysearch(a, x, mid + 1, high); // 在后半部分继续二分查找 &#125; else &#123; return binarysearch(a, x, low, mid - 1); // 在前半部分继续二分查找 &#125;&#125;int main()&#123; int a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; int idx = binarysearch(a, 2, 0, 9); if(idx == -1) &#123; printf(\"未查到！\\n\"); &#125; else &#123; printf(\"查到了！数组下标 = %d\\n\", idx); &#125; return 0;&#125; 非递归： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int BinarySearch(int a[], int n, int key)&#123; if (n == 0) return -1; int left = 0, mid, right = n - 1; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (a[mid] &lt; key) &#123; left = mid + 1; &#125; else if (a[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;int main()&#123; int a[] = &#123; 1, 3, 5, 8, 22, 45, 65, 78, 79, 102 &#125;; printf(\"%d\", BinarySearch(a, 10, 65)); return 0;&#125;","tags":[]},{"title":"依赖注入","date":"2019-08-05T16:07:52.649Z","path":"2019/08/06/iOS/iOS原理/依赖注入/","text":"一、简介依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。 初始化方法注入： 1- (instancetype)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2; 属性注入： 12@property (nonatomic, retain) Dependency1 * dependency1;@property (nonatomic, retain) Dependency2 * dependency2; 一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。 二、为什么使用依赖注入依赖注入的几个重要之处： ①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量； ②、使用构成。 即一直坚持的多构成少继承原则。它能提高代码的可重用性； ③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。 ④、明确的所有者。 ⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。 三、使用依赖注入3.1 注入类的类型首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。 简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。 复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。 分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。 3.2 在初始化时依赖分配原始代码： 12345678910111213141516@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)init&#123; if (self = [super init]) &#123; ... _engine = [[RCEngine alloc] init]; &#125; return self;&#125;@end 使用依赖注入改版后： 1234567891011121314151617@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine&#123; if (self = [super init]) &#123; ... _engine = engine; &#125; return self;&#125;@end 3.3 延迟初始化依赖通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子： 1234567891011@implementation RCRaceCar- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init]; [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。 工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。 下面，通过一个工厂，使用依赖注入创建一个灭火器。 1234567891011121314151617181920212223242526272829typedef RCFireExtinguisher *(^RCFireExtinguisherFactory)();@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@property (nonatomic, copy, readonly) RCFireExtinguisherFactory fireExtinguisherFactory;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory&#123; if (self = [super init]) &#123; ... _engine = engine; _fireExtinguisherFactory = [extFactory copy]; &#125; return self;&#125;- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = self.fireExtinguisherFactory(); [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下： 123456789101112131415161718@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;&#123; if (self = [super init]) &#123; _engine = engine; _transmission = transmission; _leftFrontWheel = wheelFactory(); _leftRearWheel = wheelFactory(); _rightFrontWheel = wheelFactory(); _rightRearWheel = wheelFactory(); // 保留轮子工厂，之后还需要一个备胎。 _wheelFactory = [wheelFactory copy]; &#125; return self;&#125;@end 四、避免多余的配置如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。 在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。 为了配置我们的对象，将从 4 个点来收集我们的依赖： ①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中； ②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值； ③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。 ④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。 下面是关于赛车的简单初便利构造器 12345678910111213+ (instancetype)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency&#123; RCEngine * engine = [[RCEngine alloc] init]; RCTransmission * transmission = [[RCTransmission alloc] init]; RCWheel *(^wheelFactory)() = ^&#123; return [[RCWheel alloc] init]; &#125;; return [[self alloc] initWithEngine:engine transmission:transmission pitRadioFrequency:frequency wheelFactory:wheelFactory];&#125; 便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。 五、系统单例在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。 这里建议避免在你的代码中创建全局的单例，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。 六、不可修改的构造函数有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码： 12345// 一个我们不能直接调用初始化方法的例子。RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];// 我们仍然可以使用属性来配置我们的赛车路径raceTrack.width = 10;raceTrack.numberOfHairpinTurns = 2; setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。 七、类注册“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码： 123456789101112131415161718192021NSArray * raceCarClasses = @[ [RCFastRaceCar class], [RCSlowRaceCar class] ];NSMutableArray *raceCars = [[NSMutableArray alloc] init];for (Class raceCarClass in raceCarClasses) &#123; // 所有赛车必须有相同的初始化方法 (在这个例子中是 \"init\" 方法). // 这里意味着我们不能自定义不同的子类 [raceCars addObject:[[raceCarClass alloc] init]];&#125;// 一个简单的替换方法是：使用工厂 block 来代替typedef RCRaceCar *(^RCRaceCarFactory)();NSArray * raceCarFactories = @[ ^&#123; return [[RCFastRaceCar alloc] initWithTopSpeed:200]; &#125;, ^&#123; return [[RCSlowRaceCar alloc] initWithLeatherPlushiness:11]; &#125; ];NSMutableArray * raceCars = [[NSMutableArray alloc] init];for (RCRaceCarFactory raceCarFactory in raceCarFactories) &#123; // 现在这样，我们就不用关心到底是那个初始化方法被调用了 [raceCars addObject:raceCarFactory()];&#125; 八、StoryboardsStoryboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。 解决方法是避免使用 storyboard。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。 九、公有和私有依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。 12345678910111213141516// In public ObjectA.h.@interface ObjectA// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件- (instancetype)initWithObjectB:(ObjectB *)objectB;@end@interface ObjectB// 这里也一样：需要暴露 ObjectC.h- (instancetype)initWithObjectC:(ObjectC *)objectC;@end@interface ObjectC- (instancetype)init;@end 对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。 12345678910@interface ObjectA- (instancetype)initWithObjectB:(id &lt;ObjectB&gt;)objectB;@end// 这个协议只暴露 ObjectA 需要原始的 ObjectB。// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 @protocol ObjectB- (void)methodNeededByObjectA;@end 十、一次高效的依赖注入10.1 问题场景如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的： 这里依赖路径有两条： ①、主项目依赖第三方 pods。 ②、组件依赖第三方 pods，主项目再依赖组件。 单向的依赖关系决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，组件却没有办法主动和主项目通讯。 可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。 10.2 依赖注入依赖注入有另外一个名字，叫做“控制反转”。 像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。 所以依赖注入有两个比较重要的点： ①、要实现这种反转控制的功能。 ②、要解耦。 不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。 出自这篇文章：理解依赖注入与控制反转 10.3 iOS 依赖注入调查iOS 平台实现依赖注入功能的开源项目有两个大头：objection、typhoon。 详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。 还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。 那有没有其他没那么方案呢？libextobjc libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点： ①、充分使用了 OC 动态语言的特性，不侵入项目 ②、高度自动化 ③、框架十分轻量（只有一个 .h 和 .m 文件） ④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。 10.4 EXTConcreteProtocol 实现原理有两个比较重要的概念需要提前明白才能继续往下讲。 ①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。 ②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。 如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。 10.4.1 EXTConcreteProtocol 的使用比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。 1234567891011121314151617181920@protocol ObjectProtocol&lt;NSObject&gt;+ (void)sayHello;- (int)age;@end@concreteprotocol(ObjectProtocol)+ (void)sayHello&#123; NSLog(@\"Hello\");&#125;- (int)age &#123; return 18;&#125;@end 之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。 123@interface Person : NSObject&lt;ObjectProtocol&gt;@end 我们接下来就可以对 Person 调用注入的方法。 12345678int main(int argc, char * argv[]) &#123; Person * p = [Person new]; NSLog(@\"%@\", [p age]); [p.class sayHello];&#125;18Hello 10.4.2 源码解析先来看一下头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define concreteprotocol(NAME) \\ /* * create a class used to contain all the methods used in this protocol */ \\ // 定义一个容器类 interface NAME ## _ProtocolMethodContainer : NSObject &lt; NAME &gt; &#123;&#125; \\ @end \\ \\ @implementation NAME ## _ProtocolMethodContainer \\ /* * when this class is loaded into the runtime, add the concrete protocol * into the list we have of them */ \\ // load 方法添加混合协议 + (void)load &#123; \\ /* * passes the actual protocol as the first parameter, then this class as * the second */ \\ if (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), self)) \\ fprintf(stderr, \"ERROR: Could not load concrete protocol %s\\n\", metamacro_stringify(NAME)); \\ &#125; \\ \\ /* * using the \"constructor\" function attribute, we can ensure that this * function is executed only AFTER all the Objective-C runtime setup (i.e., * after all +load methods have been executed) */ \\ // 在 load 之后，main 之前执行方法注入 __attribute__((constructor)) \\ static void ext_ ## NAME ## _inject (void) &#123; \\ /* * use this injection point to mark this concrete protocol as ready for * loading */ \\ ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \\ &#125;/*** implementation details follow ***/// load 方法添加混合协议BOOL ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);// load 之后，main 之前执行方法注入void ext_loadConcreteProtocol (Protocol *protocol); 可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。 然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// contains the information needed to reference a full special protocoltypedef struct &#123; // the actual protocol declaration (@protocol block) 用户定义的协议. __unsafe_unretained Protocol *protocol; // the injection block associated with this protocol // // this block is RETAINED and must eventually be released by transferring it // back to ARC // 在 __attribute__((constructor)) 时往指定类里注入方法的 block. void *injectionBlock; // whether this protocol is ready to be injected to its conforming classes // // this does NOT refer to a special protocol having been injected already // 对应的协议是否已经准备好注入. BOOL ready;&#125; EXTSpecialProtocol;BOOL ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123; return ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123; ext_injectConcreteProtocol(protocol, containerClass, destinationClass); &#125;);&#125;BOOL ext_loadSpecialProtocol (Protocol *protocol, void (^injectionBehavior)(Class destinationClass)) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); NSCParameterAssert(injectionBehavior != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return NO; &#125; // if we've hit the hard maximum for number of special protocols, we can't // continue if (specialProtocolCount == SIZE_MAX) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; // if the array has no more space, we will need to allocate additional // entries // specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols. if (specialProtocolCount &gt;= specialProtocolCapacity) &#123; size_t newCapacity; if (specialProtocolCapacity == 0) // if there are no entries, make space for just one newCapacity = 1; else &#123; // otherwise, double the current capacity newCapacity = specialProtocolCapacity &lt;&lt; 1; // if the new capacity is less than the current capacity, that's // unsigned integer overflow if (newCapacity &lt; specialProtocolCapacity) &#123; // set it to the maximum possible instead newCapacity = SIZE_MAX; // if the new capacity is still not greater than the current // (for instance, if it was already SIZE_MAX), we can't continue if (newCapacity &lt;= specialProtocolCapacity) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; &#125; &#125; // we have a new capacity, so resize the list of all special protocols // to add the new entries void * restrict ptr = realloc(specialProtocols, sizeof(*specialProtocols) * newCapacity); if (!ptr) &#123; // the allocation failed, abort pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; specialProtocols = ptr; specialProtocolCapacity = newCapacity; &#125; // at this point, there absolutely must be at least one empty entry in the // array assert(specialProtocolCount &lt; specialProtocolCapacity); // disable warning about \"leaking\" this block, which is released in // ext_injectSpecialProtocols() #ifndef __clang_analyzer__ ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior copy]; // construct a new EXTSpecialProtocol structure and add it to the first // empty space in the array // 将协议保存为一个 EXTSpecialProtocol 结构体。 specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123; .protocol = protocol, .injectionBlock = (__bridge_retained void *)copiedBlock, .ready = NO &#125;; #endif ++specialProtocolCount; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125; // success! return YES;&#125; ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。 ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static void ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class class) &#123; // get the full list of instance methods implemented by the concrete // protocol 获取容器类里所有的实例方法. unsigned imethodCount = 0; Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount); // get the full list of class methods implemented by the concrete // protocol 获取容器类里所有的类方法方法. unsigned cmethodCount = 0; Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount); // get the metaclass of this class (the object on which class // methods are implemented) 拿到要注入方法的类的元类. Class metaclass = object_getClass(class); // inject all instance methods in the concrete protocol 注入实例方法. for (unsigned methodIndex = 0;methodIndex &lt; imethodCount;++methodIndex) &#123; Method method = imethodList[methodIndex]; SEL selector = method_getName(method); // first, check to see if such an instance method already exists // (on this class or on a superclass) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(class, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this instance method to the class in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(class, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // inject all class methods in the concrete protocol 注入类方法. for (unsigned methodIndex = 0;methodIndex &lt; cmethodCount;++methodIndex) &#123; Method method = cmethodList[methodIndex]; SEL selector = method_getName(method); // +initialize is a special case that should never be copied // into a class, as it performs initialization for the concrete // protocol // +initialize 不能被注入. if (selector == @selector(initialize)) &#123; // so just continue looking through the rest of the methods continue; &#125; // first, check to see if a class method already exists (on this // class or on a superclass) // // since 'class' is considered to be an instance of 'metaclass', // this is actually checking for class methods (despite the // function name) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(metaclass, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this class method to the metaclass in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(metaclass, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // free the instance method list 管理内存 free(imethodList); imethodList = NULL; // free the class method list free(cmethodList); cmethodList = NULL; // use [containerClass class] and discard the result to call +initialize // on containerClass if it hasn't been called yet // // this is to allow the concrete protocol to perform custom initialization // 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行. (void)[containerClass class];&#125; 我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142void ext_specialProtocolReadyForInjection (Protocol *protocol) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return; &#125; // loop through all the special protocols in our list, trying to find the // one associated with 'protocol' // 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; if (specialProtocols[i].protocol == protocol) &#123; // found the matching special protocol, check to see if it's // already ready if (!specialProtocols[i].ready) &#123; // if it's not, mark it as being ready now specialProtocols[i].ready = YES; // since this special protocol was in our array, and it was not // loaded, the total number of protocols loaded must be less // than the total count at this point in time assert(specialProtocolsReady &lt; specialProtocolCount); // ... and then increment the total number of special protocols // loaded – if it now matches the total count of special // protocols, begin the injection process if (++specialProtocolsReady == specialProtocolCount) // 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入. ext_injectSpecialProtocols(); &#125; break; &#125; &#125; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125;&#125; 上面都是准备工作，接下来开始进入核心方法进行注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * This function actually performs the hard work of special protocol injection. * It obtains a full list of all classes registered with the Objective-C * runtime, finds those conforming to special protocols, and then runs the * injection blocks as appropriate. */static void ext_injectSpecialProtocols (void) &#123; /* * don't lock specialProtocolsLock in this function, as it is called only * from public functions which already perform the synchronization */ /* * This will sort special protocols in the order they should be loaded. If * a special protocol conforms to another special protocol, the former * will be prioritized above the latter. */ // 对协议进行排序. // 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的 load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现. // 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面. qsort_b(specialProtocols, specialProtocolCount, sizeof(EXTSpecialProtocol), ^(const void *a, const void *b)&#123; // if the pointers are equal, it must be the same protocol if (a == b) return 0; const EXTSpecialProtocol *protoA = a; const EXTSpecialProtocol *protoB = b; // A higher return value here means a higher priority int (^protocolInjectionPriority)(const EXTSpecialProtocol *) = ^(const EXTSpecialProtocol *specialProtocol)&#123; int runningTotal = 0; for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; // the pointer passed into this block is guaranteed to point // into the 'specialProtocols' array, so we can compare the // pointers directly for identity if (specialProtocol == specialProtocols + i) continue; if (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol)) runningTotal++; &#125; return runningTotal; &#125;; /* * This will return: * 0 if the protocols are equal in priority (such that load order does not matter) * &lt; 0 if A is more important than B * &gt; 0 if B is more important than A */ return protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA); &#125;); // 获取项目中所有的类 unsigned classCount = objc_getClassList(NULL, 0); if (!classCount) &#123; fprintf(stderr, \"ERROR: No classes registered with the runtime\\n\"); return; &#125; Class *allClasses = (Class *)malloc(sizeof(Class) * (classCount + 1)); if (!allClasses) &#123; fprintf(stderr, \"ERROR: Could not allocate space for %u classes\\n\", classCount); return; &#125; // use this instead of ext_copyClassList() to avoid sending +initialize to // classes that we don't plan to inject into (this avoids some SenTestingKit // timing issues) classCount = objc_getClassList(allClasses, classCount); /* * set up an autorelease pool in case any Cocoa classes get used during * the injection process or +initialize */ @autoreleasepool &#123; // loop through the special protocols, and apply each one to all the // classes in turn // // ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in // the order in which they appear in specialProtocols. Consider classes // X and Y that implement protocols A and B, respectively. B needs to get // its implementation into Y before A gets into X. // 遍历所有的要注入的协议结构体. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; Protocol *protocol = specialProtocols[i].protocol; // transfer ownership of the injection block to ARC and remove it // from the structure // 使用 __bridge_transfer 把对象的内存管理交给 ARC. ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer id)specialProtocols[i].injectionBlock; specialProtocols[i].injectionBlock = NULL; // loop through all classes 遍历所有的类 for (unsigned classIndex = 0;classIndex &lt; classCount;++classIndex) &#123; Class class = allClasses[classIndex]; // if this class doesn't conform to the protocol, continue to the // next class immediately // 如果这个类遵守了要注入的协议，那么就执行注入 // 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法. if (!class_conformsToProtocol(class, protocol)) continue; injectionBlock(class); &#125; &#125; &#125; // 管理内存. // free the allocated class list free(allClasses); // now that everything's injected, the special protocol list can also be // destroyed free(specialProtocols); specialProtocols = NULL; specialProtocolCount = 0; specialProtocolCapacity = 0; specialProtocolsReady = 0;&#125; 这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 10.4.3 问题在哪？接下来讨论 EXTConcreteProtocol 的缺点。 如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。 这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。 这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。 10.5 解决方案从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。 那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。 但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。 如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。 ①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。 ②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。 ③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。 ④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。 https://github.com/newyjp/BLMethodInjecting 十一、结语依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。 十二、文章依赖注入——让iOS代码更简洁 [iOS]一次高效的依赖注入","tags":[]},{"title":"n 次方","date":"2019-08-05T16:07:52.648Z","path":"2019/08/06/算法/n次方/","text":"1、问题描述计算 an 2、算法分析先将 n 变一变，寻找新的计算路径。预处理就是变治法的根本。 如果单纯循环执行 n 次相乘，那么时间复杂度为 O(n)。可以利用二进制幂大大改进效率。 主要思路是：将十进制的 n 转换成二进制的数组序列 b[]。二进制幂求解有两种方法：从左至右二进制幂和从右至左二进制幂。 ①、从左至右二进制幂 变换：an = a(b[n]2m + … + b[0]20) 先求 n 的二进制串，如：n = 5 =&gt; 1 0 1，那么 b[2] = 1, b[1] = 0, b[0] = 1 二进制求 n 的伪代码： Horner(b[0…n], x)k = b[n]for i = n-1 downto 0 do p = x*k + b[i]return p 那么 n 用作 a 的指数时意义是什么样的呢： ap = a1for i = n - 1 downto 0 do ap = a(2p+b[i]) ②、从右至左二进制幂 n 变换方法与上面相同，然后从 b[0] -&gt; b[n] 方向逐步求解。 时间复杂度：O(logn) 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/** * @brief 返回 x 的二进制串（数组） */int GetBinArray(int x, int arr[], int length)&#123; int idx = 0; while(x &gt; 0) &#123; // 获取末位的二进制 arr[idx++] = (x &amp; 1) ? 1 : 0; if (idx == length) break; // 右移两位 x = x &gt;&gt; 1; &#125; return idx;&#125;/** * @brief a^n = a^（b[n]2^n + ... + b[0]2^0）= a^（b[n]2^n）* ... * a^b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_RightToLeft(int number, int power)&#123; if (power == 0) return 1; int length = sizeof(int) * 8; // 32 int *pint = (int *)malloc(length); // 获取幂的二进制数组 length = GetBinArray(power, pint, length); int item = number; int ret = 1; for (int i = 0; i &lt; length; i++) &#123; // 二进制值为 1，计入结果 if (pint[i] == 1) ret *= item; item *= item; &#125; free(pint); return ret;&#125;/** * @brief a^n = a^（b[n]2^n + ... + b[0]2^0）=（（b[n]*2 + b[n-1]）*X + ....）2 + b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_LeftToRight(int number, int power)&#123; if (power == 0) return 1; int length = sizeof(int)*8; int *pint = (int *)malloc(length); length = GetBinArray(power, pint, length); int ret = number; for (int i = length - 1 - 1; i &gt;= 0; i--) &#123; ret *= ret; if(pint[i] == 1) ret *= number; &#125; free(pint); return ret;&#125;int main()&#123; int num = 8, power = 6; int ret1 = Pow_Bin_RightToLeft(num, power); int ret2 = Pow_Bin_LeftToRight(num, power); printf(\"Pow_Bin_RightToLeft: %d^%d == %d\\n\", num, power, ret1); printf(\"Pow_Bin_LeftToRight: %d^%d == %d\\n\", num, power, ret2); return 0;&#125;Pow_Bin_RightToLeft: 8^6 == 262144Pow_Bin_LeftToRight: 8^6 == 262144 文章：计算 n 次方–变治法","tags":[]},{"title":".pch","date":"2019-08-05T16:07:52.648Z","path":"2019/08/06/iOS/iOS原理/pch/","text":"Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的预编译头文件，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之后则需要手动创建。 一、作用①、定义全局性宏； ②、引用全局性头文件； ③、根据运行环境，自动打开或者关闭日志输出功能。 二、优点①、PCH 文件的内容能被项目中的其他所有文件共享和访问，其它地方可直接使用，不用再手动重复定义或引用； ②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而提高编译速度。 三、缺点①、把类中使用的框架等放到 PCH 中，依赖关系不明确，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。 ②、大量的共用性不高的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长； 四、思考①、PCH 的目的是：提高编译速度，而不是少敲几行 #import； ②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用； ③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。 ④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。 ⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。 ⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。 ⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。 五、文章PCH 文件的优缺点 PCH文件的新建和其缺点","tags":[]},{"title":"isa 和 Class","date":"2019-08-05T16:07:52.647Z","path":"2019/08/06/iOS/iOS原理/isa 和 Class/","text":"一、Runtime 简介Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要由运行时来决定了。 C 语言中，函数的调用在编译期就会决定调用哪个函数。而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。 Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。 Objc 在三种层面上与 Runtime 系统进行交互： 1、通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。 2、通过 Foundation 框架的 NSObject 类定义的方法 在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。 在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。 123456789101112131415161718192021222324/** * 返回对象的类 */- (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'anObject.dynamicType' instead\");/** * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类 */- (BOOL)isKindOfClass:(Class)aClass;/** * 检查对象是否是某个类的实例 */- (BOOL)isMemberOfClass:(Class)aClass;/** * 检查对象能否响应指定的消息 */- (BOOL)conformsToProtocol:(Protocol *)aProtocol;/** * 检查对象是否实现了指定协议类的方法 */- (BOOL)respondsToSelector:(SEL)aSelector; 在 NSObject 的类中还定义了一个方法 1234/** * 返回指定方法实现的地址 IMP */- (IMP)methodForSelector:(SEL)aSelector; 3、通过对 Runtime 库函数的直接调用 关于库函数可以在 Objective-C Runtime Reference 中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。 具体设置如下： 如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。 二、NSObject 起源与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自objc4-680 NSObject 的定义如下： 12345typedef struct objc_class *Class;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 在 Objc2.0 之前，objc_class 源码如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 指向成员变量列表的指针 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 指向方法列表指针的指针 struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif &#125; OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。 动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。 关于 Category，推荐 2 篇文章可以仔细研读：深入理解Objective-C：Category、结合 Category 工作原理分析 OC2.0 中的 runtime 然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 objc_private。 123456789101112131415161718192021222324252627typedef struct objc_class *Class;typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123;&#125; 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。 objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。 objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论： Objective-C 中类也是一个对象。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。 object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。 2.1 isa12345678910111213141516171819202122232425262728293031323334353637union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;# if __arm64__ struct &#123; uintptr_t indexed : 1; // 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化 uintptr_t has_assoc : 1; // 是否有设置过关联对象，如果没有，释放时会更快 uintptr_t has_cxx_dtor : 1; // 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被弱引用指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中 uintptr_t extra_rc : 19; // 里面存储的值是引用计数 - 1 &#125;;# elif __x86_64__ struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;# else# endif&#125; isa 详解 在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 64 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 What is a meta-class in Objective-C? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。 类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系： 实线是 super_class 指针，虚线是 isa 指针。 Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。 每个 Class 都有一个 isa 指针指向唯一的 Meta class Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。 每个 Meta class 的 isa 指针都指向 Root class（meta）。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 iOS 程序 main 函数之前发生了什么 2.1.1 isa_t 结构体的具体实现接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。 12345678910111213struct objc_object &#123;private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor); ...｝ 那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 objc_object。 1234567891011121314151617inline voidobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline voidobjc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)&#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。 1234567891011121314151617181920212223242526272829303132333435# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;; ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图： 参数的说明： index 代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。 在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer 的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：关于 Tagged Pointer 技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64 架构中有 33 位可以存储类指针。源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解 isa这篇文章里面的 shiftcls 分析。 magic判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。123456inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;关于 x86_64 的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。#### 2.2 cache_t 的具体实现继续看源码1234567891011121314151617struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; // 分配用来缓存 bucket 的总数 mask_t _occupied; // 表明实际占用的缓存 bucket 的个数&#125;typedef unsigned int uint32_t;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bitstypedef unsigned long uintptr_t;typedef uintptr_t cache_key_t;struct bucket_t &#123;private: cache_key_t _key; IMP _imp;&#125;根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。cache_t 中的 bucket_t _buckets 其实就是一个散列表，用来存储 Method 的链表。Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。#### 2.3 class_data_bits_t 的具体实现源码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;;在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。1class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags它为我们提供了便捷方法用于返回其中的 class_rw_t 指针：123class_rw_t *data() &#123; return bits.data();&#125;Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly在编译期，类的结构中的 class_data_bits_t data 指向的是一个 class_ro_t 指针：在运行时调用 realizeClass方法，会做以下 3 件事情：1. 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针2. 初始化一个 class_rw_t 结构体3. 设置结构体 ro 的值以及 flag最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。1234567891011121314struct method_t &#123; SEL name; // 方法名字 const char *types; // Type Encoding 类型编码 IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;;方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 Type Encoding。IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。整个运行时过程描述如下：更加详细的分析，请看@Draveness 的这篇文章深入解析 ObjC 中方法的结构到此，总结 objc_class 1.0 和 2.0 的差别。## 三、测试题1. [self class] 与 [super class]123456789101112@implementation Son : Father- (id)init&#123; if (self = [super init]) &#123; NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); &#125; return self;&#125;@endself 和 super 的区别： self 是类的一个隐藏参数，每个方法的实现的第一个参数即为 self。 super 并不是隐藏参数，它实际上只是一个“编译器标示符”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。在调用 [super class] 的时候，runtime 会去调用 objc_msgSendSuper 方法，而不是 objc_msgSend。1234567891011121314151617OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。objc_msgSendSuper 的工作原理应该是这样的：&gt; 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。那么 objc_msgSendSuper 最后就转变成1234567891011// 注意这里是从父类开始 msgSend，而不是从本类开始。objc_msgSend(objc_super-&gt;receiver, @selector(class))/// Specifies an instance of a class. 这是类的一个实例 __unsafe_unretained id receiver; // 由于是实例调用，所以是减号方法- (Class)class &#123; return object_getClass(self);&#125;由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。2. isKindOfClass 与 isMemberOfClass12345678910111213141516@interface Sark : NSObject@end@implementation Sark@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@\"%d %d %d %d\", res1, res2, res3, res4); &#125; return 0;&#125;先来分析一下源码这两个函数的对象实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;inline Class objc_object::getIsa() &#123; if (isTaggedPointer()) &#123; uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; &#125; return ISA();&#125;inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;首先题目中 NSObject 和 Sark 分别调用了 class 方法。+ (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去调用当前类的 obj-&gt;getIsa()，最后在 ISA() 方法中获得 meta class 的指针。接着在 isKindOfClass 中有一个循环，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。[NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。&gt; isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。3. Class 与内存地址下面的代码会？Compile Error / Runtime Crash / NSLog…?12345678910111213141516171819202122@interface Sark : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Sark- (void)speak &#123; NSLog(@\"my name's %@\", self.name);&#125;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak];&#125;@end这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？首先需要谈谈隐藏参数 self 和 _cmd 的问题。当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。难点一：能不能调用 speak 方法？12id cls = [Sark class]; void *obj = &amp;cls;答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。难点二：如果能调用 speak，会输出什么呢？很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。正确的答案会输出1my name is &lt;ViewController: 0x7ff6d9f31c50&gt;内存地址每次运行都不同，但是前面一定是 ViewController。why？我们把代码改变一下，打印更多的信息出来。12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj, &amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark, &amp;sark); [sark speak];&#125;我们把对象的指针地址都打印出来。输出结果：12345678ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8Sark class = Sark 地址 = 0x7fff543f5a88Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80my name is &lt;ViewController: 0x7fb570e2ad00&gt;Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78my name is (null)123// objc_msgSendSuper2() takes the current search class, not its superclass.OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);objc_msgSendSuper2 方法入参是一个 objc_super super。123456789101112131415/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;#endif所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。至此，Objc 中的对象到底是什么呢？实质：Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject，而对象的实例变量 void ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); NSString *myName = @\"halfrost\"; id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark,&amp;sark); [sark speak]; &#125;ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78Sark class = Sark 地址 = 0x7fff56a48a50Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48my name is halfrostSark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。 原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。 这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController： 1my name is &lt;ViewController: 0x7fb570e2ad00&gt; 其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？ obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。 LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示： x/ n、f、u 是可选的参数。 n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。 u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。 这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。 四、文章一缕殇流化隐半边冰霜 &amp; 神经病院Objective-C Runtime入院第一天–isa和Class","tags":[]},{"title":"iOS 页面流畅技巧","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS优化/iOS 页面流畅技巧(1)/","text":"一、屏幕显示图像原理首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。 二、卡顿产生的原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。 三、CPU 资源消耗的原因和解决方案3.1 对象的创建对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以： ①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适； ②、如果对象不涉及 UI 操作，尽量放到后台线程去创建； ③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用； ④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去； ⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 3.2 对象调整对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer： ①、CALayer 内部没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源； ②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改； ③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3.3 对象销毁当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了： 12345NSArray * tmp = self.arr_data;self.arr_data = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 3.4 对象布局在后台线程提前计算好视图布局、并对视图的布局进行缓存。 不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。 3.5 Autolayout这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但对于复杂视图来说常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。 3.6 文本计算如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。 3.7 文本渲染屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。 显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制，尽管麻烦但优势强大： ①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）； ②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。 3.8 图片解码用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。 解码过程是一个相当复杂的任务，需要消耗非常长的时间。解码后的图片将同样使用相当大的内存。 该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 用于加载的 CPU 时间相对于解码来说根据图片格式而不同。对于 PNG 图片来说，加载会比 JPEG 更长，因为文件可能更大，但是解码会相对较快，而且 Xcode 会把 PNG 图片进行解码优化之后引入工程。JPEG 图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为 JPEG 解压算法比基于 zip 的 PNG 算法更加复杂。 3.9 图像的绘制是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致） 123456789101112- (void)display&#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 四、GPU 资源消耗原因和解决方案GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。 4.1 纹理的渲染所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。 4.2 视图的混合（Composing）当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。 所以应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 也可以把多个视图预先渲染为一张图片来显示。 4.3 图形的生成CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。 当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。 对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。 最彻底的做法：把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 五、文章幸运的芳1990 &amp; 浅谈iOS页面流畅技巧","tags":[]},{"title":"iOS 响应链","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 响应链/","text":"一、UIResponder app 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。 UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。 响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。 有时候可能会通过 UIResponder 来查找控件的父视图。 1234567891011121314151617181920212223242526272829/** * 通过遍历 UIView 上的响应链来查找当前顶部 vc */- (UIViewController *)firstVC&#123; for (UIView * next = self; next; next = next.superview) &#123; UIResponder * nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125;/** * 通过遍历 button 上的响应链来查找 cell */- (MyCell *)buttonTaped:(UIButton *)button&#123; UIResponder * responder = button.nextResponder; while (responder) &#123; if ([responder isKindOfClass:[MyCell class]]) &#123; MyCell * cell = (MyCell *)responder; break; &#125; responder = responder.nextResponder; &#125;&#125; 二、事件的第一响应者事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。 Touch event 第一响应者是触摸事件产生的 view Press event 第一响应者是焦点响应者。 Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象 ⚠️注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。 控件直接与它相关的 target 对象使用 action 消息通信。 当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。 如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。 三、事件的分发和传递 当iOS程序中发生触摸事件后，系统会将事件加入到 UIApplication 管理的一个任务队列中； UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。 UIWindow 将事件向下分发，即 UIView。 UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。 遍历子控件，重复以上两步。 如果没有找到，那么自己就是事件处理者。 如果自己不能处理，那么不做任何处理。 其中 UIView 不接受事件处理的情况主要有以下三种 alpha &lt; 0.01 userInteractionEnabled = NO hidden ＝ YES 这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果父视图不接受事件处理，那么子视图也不能接收事件。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。 四、hitTest:withEvent:1234/** * @return 本次点击事件需要的最佳 View */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。 ⚠️注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。 当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。 把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。 如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢? 事件传递给窗口或控件的后，就调用 hitTest:withEvent: 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到找到最合适的 view 或者废弃事件。 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // ①、判断当前控件能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // ②、判断触摸点在不在当前控件内 if ([self pointInside:point withEvent:event] == NO) return nil; // ②、倒序遍历自己的子控件 NSInteger count = self.subviews.count; for (NSInteger i = count - 1; i &gt;= 0; i--) &#123; UIView * childView = self.subviews[i]; // 把当前控件上的坐标系转换成子控件上的坐标系 CGPoint childP = [self convertPoint:point toView:childView]; UIView * fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; return fitView; // 找到了最合适的 view &#125; &#125; // 循环结束，表示没有比自己更合适的 view return self; &#125; 所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。 从后往前遍历子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。 视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。 如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。 如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。 如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。 如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。 四、pointInside:withEvent:1、判断触摸点是否在视图内。 1234/** * @brief 判断一个点是否落在范围内 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢? 扩大响应范围。 12345678910- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; /* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and decrease its size by `(2*dx, 2*dy)'. CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10 */ bounds = CGRectInset(self.bounds, -10, -10); return CGRectContainsPoint(bounds, point);&#125; 不规则的点击区域 123456789101112131415/** * @brief 改变图片的点击范围 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 控件范围宽度 +40，高度 +40 CGRect bounds = CGRectInset(self.bounds, -20, -20); UIBezierPath * path1 = [UIBezierPath bezierPathWithRect:CGRectMake(-20, 0, 40, 120)]; UIBezierPath * path2 = [UIBezierPath bezierPathWithRect:CGRectMake(self.frame.size.width - 20, 0, 40, 120)]; if (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; CGRectContainsPoint(bounds, point))&#123; return YES; // 如果在 path 区域内返回 YES &#125; return NO;&#125; 可以看出： 在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。 不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。 在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。 五、响应者链响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。 在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。 1、改变响应链 可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。 UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。 UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。 -UIWindow 下一个响应者为 UIApplication 对象。 UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。 六、文章Using Responders and the Responder Chain to Handle EventsiOS开发 - 事件传递响应链iOS响应链（Responder Chain）","tags":[]},{"title":"iOS 单例","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 单例/","text":"一、单例介绍单例：该类在程序运行期间有且仅有一个实例。 1.1 单例模式的要点 该类有且只有一个实例； 该类必须能够自行创建这个实例； 该类必须能够自行向整个系统提供这个实例。 1.2 单例的主要优点 单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例； 因为类控制了实例化过程，所以类可以灵活更改实例化过程； 基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便； 可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。 1.3 单例的主要缺点 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。单例不能被继承，不能有子类； 不易被重写或扩展（可以使用分类） 单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放； 单例类的职责过重，在一定程度上违背了“单一职责原则”。 1.4 单例的生命周期下面的表格展示了程序中中不同的变量在手机存储器中的存储位置； 位置 存放的变量 栈 临时变量（由编译器管理自动创建/分配/释放的，栈中的内存被调用时处于存储空间中，调用完毕后由系统系统自动释放内存） 堆 通过 alloc、calloc、malloc 或 new 申请内存，由开发者手动在调用之后通过 free 或 delete 释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存，在ARC模式下，由系统自动管理。 全局区域 静态变量（编译时分配，APP 结束时由系统释放） 常量 常量（编译时分配，APP结束时由系统释放） 代码区 存放代码 在程序中，一个单例类在程序中只能初始化一次，为了保证在使用中始终都是存在的，所以单例是在存储器的全局区域，在编译时分配内存，只要程序还在运行就会一直占用内存，在 APP 结束后由系统释放这部分内存内存。 单例的静态变量被置为 nil，是否内存会得到释放？ 12345678910static Singletion * singleton;- (void)dealloc&#123; NSLog(@\"%s\", __func__);&#125;Singleton * s = [Singleton sharedSingleton];s = nil;singleton = nil; 将单例类实例对象赋值 nil 后，会触发单例的 dealloc 方法。 静态变量修饰的指针保存在了全局区域，不会被释放。但是指针保存的首地址关联的对象是保存在堆区的，是会被释放的。 二、单例的实现单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。 主要是做到以下几点： 防止调用 [[A alloc] init] 引起的错误 防止调用 new 引起的错误 防止调用 copy 引起的错误 防止调用 mutableCopy 引起的错误 2.1 实现方式一 把所有可能出现的初始化方法做了相应的处理来其保证安全性 1234567891011121314151617181920212223242526272829+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 不能再使用 alloc 方法 // 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法 _sharedSingleton = [[super allocWithZone:NULL] init]; &#125;); return _sharedSingleton;&#125;// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.- (id)copyWithZone:(nullable NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.- (id)mutableCopyWithZone:(nullable NSZone *)zone &#123; return [Singleton sharedSingleton];&#125; dispatch_once 主要是根据 onceToken 的值来决定怎么去执行代码。 当 onceToken = 0 时，线程执行 dispatch_once 的 block 中代码； 当 onceToken = -1 时，线程跳过 dispatch_once 的 block 中代码不执行； 当 onceToken 为其他值时，线程被阻塞，等待 onceToken 值改变。 当线程调用 shareInstance，此时 onceToken = 0，调用 block 中的代码，此时 onceToken 的值变为 140734537148864。当其他线程再调用 shareInstance 方法时，onceToken 的值已经是 140734537148864 了，线程阻塞。当 block 线程执行完 block 之后，onceToken 变为 -1，其他线程不再阻塞，跳过 block。下次再调用 shareInstance 时，block 已经为 -1，直接跳过 block。 2.2 实现方式二 不做处理的情况下禁止外部调用 一些成熟的第三方代码的单例中也有使用该方法的。 123456789101112131415161718.h 文件- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (id)copy NS_UNAVAILABLE;- (id)mutableCopy NS_UNAVAILABLE;.m 文件+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _sharedSingleton = [[self alloc] init]; // 要使用 self 来调用 &#125;); return _sharedSingleton;&#125; 当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。 三、单例的滥用3.1 全局状态大多数的开发者都认同使用全局可变的状态是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。 12345678910@implementation SPMath&#123; NSInteger _a; NSInteger _b;&#125; - (NSInteger)add&#123; return _a + _b;&#125; 在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题： add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。 当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。 把下面的代码和上面的例子做对比: 1234+ (NSUInteger)addOf:(NSUInteger)a plus:(NSUInteger)b&#123; return a + b;&#125; 这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为类方法，这样就显式的告诉了代码的阅读者：这个方法不会修改任何实例的状态。 那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“单例就是披着羊皮的全局状态” 。 一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。 12345678910111213141516171819202122232425262728@interface Singleton : NSObject+ (instancetype)sharedInstance;- (NSString *)name;- (void)setName:(NSString *)name;@end@implementation A - (void)a &#123; if ([[Singleton sharedInstance] name]) &#123; // ... &#125;&#125;@end@implementation B- (void)b&#123; [[Singleton sharedInstance] setName:\"\"];&#125;@end 在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的共享状态来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致隐式的在两个看起来完全不相关的模块之间建立了耦合。 来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。 想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器： 123456@interface URLCache+ (NSCache *)sharedURLCache;- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;@end 这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。 几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？ 原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。 持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。 3.2 对象的生命周期另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。 假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例： 1234567@interface ThumbnailCache : NSObject+ (instancetype)sharedThumbnailCache;- (void)cacheProfileImage:(NSData *)imageData forUserId:(NSString *)userId;- (NSData *)cachedProfileImageForUserId:(NSString *)userId;@end 继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。 当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。 问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例： 123456789101112131415static ThumbnailCache * sharedThumbnailCache;+ (instancetype)sharedThumbnailCache&#123; if (!sharedThumbnailCache) &#123; sharedThumbnailCache = [[self alloc] init]; &#125; return sharedThumbnailCache;&#125;+ (void)cleanUp&#123; // The SPThumbnailCache will clean up persistent states when deallocated sharedThumbnailCache = nil;&#125; 这是一个明显的对单例模式的滥用，但是它可以工作，对吧。 当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作： 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];&#125;); 需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。 由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。 分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。 举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。 这里我们得到的教训是：单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。 四、避免使用单例既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？ 重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。 123456789101112131415@interface User : NSObject@property (nonatomic, readonly) ThumbnailCache * thumbnailCache;@end @implementation User- (instancetype)init&#123; if ((self = [super init])) &#123; _thumbnailCache = [[ThumbnailCache alloc] init]; &#125; return self;&#125;@end 现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。 现在假设我们有一个 VC 来展现好友列表： 12345@interface FriendListVC : UIViewController- (instancetype)initWithUser:(User *)user; @end 我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，并且它有很多优点： ①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。 ②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];&#125;); 这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。 为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。 假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示： vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。 当用户登出后，清理 rootViewController 并且退出到登录页面： 这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。 使用依赖注入的对象图： 简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了简化 applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示： 这个对象图看起来和使用单例时很像。这有什么区别？ 关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互： 当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态： 五、结论在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。 这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。 六、文章避免滥用单例","tags":[]},{"title":"iOS 项目发布","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 项目发布/","text":"一、Apple开发者账号1.1 开发者账号类型 个人级 公司级 企业级 公司和企业的可多人协作。 在苹果的开发者平台登录后，可在 People 界面邀请其他人员协作开发，邀请的人需要注册一个 appleId 账号，并且可以设置开发人员的权限。 1.2 辨别账号类型 个人级 账户的 Apple Developer Program 下方只有 Certificates，identifiers &amp; Profiles 和 App Store Connect 两个图标。 公司级 账户的 Apple Developer Program 下方包含 People、Certificates，identifiers &amp; Profiles 和 App Store Connect 三个图标。 图标一：邀请其他开发人员的入口 图标二：开发者证书、App ID 和描述文件生成的入口 图标三：将 APP 上传到 App Store 的入口 企业级 账户的 Apple Developer Enterprise Program 下方有People、Certificates，identifiers &amp; Profiles 两个图标，第一个图标邀请其他开发人员的入口，第二个图标是开发者证书、App ID和描述文件生成的入口。 1.3 账号对比 个人（Individual） 99 美元/年 只能上架到 App Store 最大支持 100 台设备 1 人使用 “个人”开发者可以申请升级成“公司”，通过拨打苹果公司客服电话（400-6701-855）进行咨询办理。 公司（Company） 99美元/年 只能上架到 App Store 最大支持 100 台设备 多人协作 允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为 4 种级别的权限。 申请时需要填写公司的邓白氏码（DUNS Number）。 企业（Enterprise） 299美元/年 不能上架到 App Store，只能企业内部使用。通过 item-services 分发来下载 不限制设备数 多人协作 允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为4种级别的权限。 申请时需要填写公司的邓白氏码（DUNS Number）。 只能企业内部使用，否则有被封号的风险。 总结 个人级和公司级只能上架 App Store 供用户下载，企业级不能上架 App Store，只能放在自己的服务器或者三方平台； 个人/公司级账号可以将开发环境的包上传到自己的服务器，或者第三方平台。首先在开发者账号添加最多 100 个手机的 UUID，创建开发 developer 证书和描述文件，将它两下载到电脑上，双击安装，在 Xcode 选择开发证书打包。这种可调式（Debug）包的有效期也是一年，一年内需要重新创建证书，并更新 ipa 包，否则 APP 将闪退。注意：每次添加设备 UUID 需要重新生成描述文件。 企业级账号，每年至少重新打包 ipa 一次，更新 ipa 包中的证书信息，证书的有效期是一年，一年不更新，APP将闪退，无法进入。个人/公司级别的没有限制，只要成功上架到 App Store，如果没有特殊情况，理论可以放到苹果公司倒闭也不用去更新。 安装企业级账号分发的包后，需要去设置中信任 APP，系统级限制，无法跳过。个人/公司级没有该限制。 个人/公司必须经过苹果的人工审核才能在 App Store 上架，而企业级发布到自己服务器或者第三方平台是不需要审核的。 二、证书相关2.1 开发者证书总共有两种类型： Developer（开发证书） Distribution（发布证书） 不论是真机调试，还是上传到 appstore 都是需要的，是一个基证书，用来证明自己开发者身份的。 2.2 App ID 是一个 APP 的唯一标示，相当于人的身份证号 Description 是一个 App ID 的描述，可以随便 App ID Prefix 苹果自动填了，可以看出，它是一个团队的 ID Suffix App ID Suffix 有两个选项： Explicit App ID : 一个明确的 App ID，什么意思呢？可以这么来解释：我们做项目时的Bundle Identifier (Bundle ID)是用来标示我们的 app 的。我们的 App ID 也是用来标示我们的app 的。这两个有什么联系呢？Explicit App ID 就是要我们确定一个唯一的 Bundle ID，用来标示我们的 app，使它有一个固定的身份。可以发现，当提交应用到苹果时，如果我们一开始没写 Explicit App ID，苹果会自动帮我们生成一个与我们发布时填的一样的 Bundle ID 到我们的 App ID 中。填写 Explicit App ID 的格式为：com.xxx.yyy。 Wildcard App ID : 一个通配符的 App ID。这个 App ID 能够在所有能够匹配的应用中使用。填写 WildcardApp ID 的格式为：com.xxx.*。 手机安装 app 时，会先查找是否已有相同 App ID 的 app，如果没有，则直接进行安装；如果已有，则进行覆盖安装。 2.3 CSR 在苹果开发者中心生成证书时需要一个 CSR（证书签名请求）文件。 当创建 CSR 时，电脑系统实际上会生成公钥和私钥对。CSR 包含公钥。 Apple 使用该公钥来制作证书。证书或多或少是一种发布公钥的方式以及关于该密钥的一些相关信息，并且验证发布实体，表示该信息是有效的。 由于每个证书都有自己的公钥 - 私钥对，因此推送证书、开发发证书和发布证书都可以使用不同的 CSR，每个证书用于验证和保护该特定项目。 生成 CSR 文件步骤： 用户电子邮件地址随便填写，并不一定非要填写邮件格式，无实际作用 常用名字使用默认的就可以，也可以修改 选择存储到磁盘。 选择继续，保存到指定位置即可。最终得到一个 CertificateSigningRequest.certSigningRequest 文件，也就是 CSR 文件。该文件后缀名不要更改，文件名可自由指定。 CSR文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字。 2.4 .cer 在苹果开发者中心生成的证书，导出后就是 .cer 文件。.cer 证书仅包含公钥。 提交 CSR 文件后就会生成一个 cer 证书，有效期为一年。 证书不可轻易删除，可能会造成相应的 Provisioning Profiles 失效，尤其是企业级的发布证书，删除后已经安装在手机上的 APP 将会闪退。如果是一个团队大家都在用，把这个证书删除了，会导致别人的描述文件失效。 2.5 .p12 .p12证书可能既包含公钥也包含私钥。 双击安装下载后的 .cer 文件，都可以在钥匙串访问工具中导出 .p12 文件。 为什么要导出.p12文件？ 开发证书和发布证书是有数量限制的，当超过数量后再也申请不了。 多台电脑开发程序时，没必要生成很多的证书，导出证书生成的 .p12 文件，供给所有的 mac 设备使用，使新设备不需要在苹果开发者网站重新申请开发和发布证书，就能使用。 点击 .p12 文件加入钥匙串中，使我们的电脑具备开发的证明。 注意：一般 .p12 文件是给别人使用的，本机必须已经有一个带秘钥的证书才可以生成.p12文件。 2.6 描述文件 Profiles 将 App ID、开发者证书、硬件 Device 绑定到一块儿。 在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在描述文件中添加真机的 UDID。 2.7 邓白氏码 邓氏编码（D-U-N-S® Number，是 Data Universal Numbering System的缩写）。它是一个独一无二的 9 位数字全球编码系统，相当于企业的身份识别码，被广泛应用于企业识别、商业信息的组织及整理。可以帮助识别和迅速定位全球 2.4 亿家企业的信息。 2.8 crtcrt 文件，是用于从证书颁发机构签过名的文件。https 就需要这个文件，放在自己服务器上用于别人接收。是一个 base64 格式的。 1$ openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt -days 3650 代表有效期10年 -in rsacert.csr 传递一个文件 -signkey private.pem 代表用私钥 private.pem 文件进行签名 2.9 der1$ openssl x509 -outform der -in rsacert.crt -out rsacert.der der 文件主要包括就是公钥和一些信息。 2.10 生成文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 生成原始 RSA 私钥文件$ openssl genrsa -out private.pemGenerating RSA private key, 2048 bit long modulus.......................................................+++..................................+++e is 65537 (0x10001)$ openssl genrsa -out private.pem 1024Generating RSA private key, 1024 bit long modulus............................++++++.....++++++e is 65537 (0x10001)# 将原始 RSA 私钥转换为 pkcs8 格式$ openssl pkcs8 -topk8 -inform PEM -in private.pem -outform PEM -nocrypt -out rsa_private.pem # 提取公钥 public.pem$ openssl rsa -in private.pem -pubout -out public.pem# 查看公钥文件，base64 编码$ cat public.pem-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDAXb5xgXWKdGizJ6lFp61U8Mk6TdBP0HgP38ZeiwEysgNfnPS1T8Lf0+OXbkWRdTdLAxCEG6IXp/gwBfqA2yab1GNbtsJSch/KxCqmHlxqbNB54dZH6TvibZLIXVbGysIc/keqkBW0Q+BZ2/bqgsRqDHByVtb5wE8o7AEbv+OD7QIDAQAB-----END PUBLIC KEY-----# 把 private.pem 转成明文$ openssl rsa -in private.pem -text -out private.txtwriting RSA key # 提取 .csr 文件$ openssl req -new -key private.pem -out rsa_cert.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) []:CN #国家名称State or Province Name (full name) []:BeiJing #省名Locality Name (eg, city) []:BeiJing #城市名Organization Name (eg, company) []:CYKJ #公司名称Organizational Unit Name (eg, section) []:CYKJ.com #公司单元名称 Common Name (eg, fully qualified host name) []:www.cykj.cn #主机名Email Address []:dubinbin@ciyun.cn #邮箱 Please enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:123321 #密码# 签名，提取 .crt 文件$ openssl x509 -req -days 3650 -in rsa_cert.csr -signkey private.pem -out rsa_cert.crtSignature oksubject=/C=CN/ST=BeiJing/L=BeiJing/O=CYKJ/OU=CYK.com/CN=www.cykj.cn/emailAddress=dubinbin@ciyun.cnGetting Private key # 生成 .der 文件$ openssl x509 -outform der -in rsa_cert.crt -out rsa_cert.der # 生成 .p12 文件$ openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsa_cert.crtEnter Export Password:123321Verifying - Enter Export Password:123321 三、打包上传3.1 payload适用于开发阶段。操作步骤： 选中 target -&gt; edit Scheme，修改 run 操作的 Build Configuration 是 budeg/release。 真机运行工程，在左侧工程目录 -&gt; Products 找到 .app 文件，show in Finder。 桌面生成一个名为 Payload 的空文件夹，将 .app 文件拖入其中。 压缩 Payload 文件夹，修改后缀名为 .ipa，此时就可以将包上传 fir.im 网站，进行提测。 3.2 Archive 常规打包方式 运行设备选择 Generic iOS Device 或者真机，顶部 Xcode 导航栏 -&gt; Product -&gt; Archive。 命令行使用 xcodebuild 自动打包 ①、clean 工程 12345$ cd Desktop/CYKJ/CYKJMain/CYKJMain/$ xcodebuild clean -project CYKJMain.xcodeproj -scheme CC -configuration Release$ xcodebuild clean -workspace CYKJMain.xcworkspace -scheme CC -configuration Release 如果工程使用了 pod，选择 -workspace，否则使用 -project。 上面的命令中： -project CYKJMain.xcodeproj : 编译项目名称 -workspace CYKJMain.xcworkspace : 编译工作空间名称 -scheme CC : scheme 名称 -configuration Release : (Debug/Release) clean 成功： ②、archive 导出 .xcarchive 文件 123$ xcodebuild archive -project CYKJMain.xcodeproj -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive$ xcodebuild archive -workspace CYKJMain.xcworkspace -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive 上面的命令中： -archivePath /Users/cykj/Desktop/cc.xcarchive : 导出 .xcarchive 文件的目录以及文件名称 archive 成功： ③、导出 ipa 包 1$ xcodebuild -exportArchive -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc -exportFormat ipa -exportProvisioningProfile \"developmentProfile\" 上面的命令中: &gt; -archivePath /Users/cykj/Desktop/cc.xcarchive : 刚刚导出的 .xcarchive 文件的目录 &gt; &gt; -exportPath /Users/cykj/Desktop/cc : 将要导出的 ipa 文件的目录以及文件名 &gt; &gt; -exportFormat ipa : 导出为ipa文件 &gt; &gt; -exportProvisioningProfile &quot;developmentProfile&quot; : 工程配置的 profile 文件的名称 &lt;font color=#cc0000&gt;``xcodebuild: error: invalid option ‘-exportFormat’``&lt;/font&gt; 报错原因：Xcode8 之后，对之前的 exportFormat 方式不再支持。 解决方法：不使用 exportFormat ipa 引入 ``exportOptionsPlist``。 1$ xcodebuild -exportArchive -archivePath \"$&#123;ARCHIVEPATH&#125;/$&#123;TARGET_NAME&#125;.xcarchive\" -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125; 直接使用 xcodebuild -help 查看 exportOptionsPlist。 1234567891011121314151617181920212223242526272829303132333435363738394041Available keys for -exportOptionsPlist:compileBitcode : Bool For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.embedOnDemandResourcesAssetPacksInBundle : Bool For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.iCloudContainerEnvironment For non-App Store exports, if the app is using CloudKit, this configures the \"com.apple.developer.icloud-container-environment\" entitlement. Available options: Development and Production. Defaults to Development.manifest : Dictionary For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.method : String Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.onDemandResourcesAssetPacksBaseURL : String For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn't YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.teamID : String The Developer Portal team to use for this export. Defaults to the team used to build the archive.thinning : String For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. \"iPhone7,1\"). Defaults to &lt;none&gt;.uploadBitcode : Bool For App Store exports, should the package include bitcode? Defaults to YES.uploadSymbols : Bool For App Store exports, should the package include symbols? Defaults to YES. plist 格式： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;xxxx&lt;/string&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.xxx.yyy&lt;/key&gt; &lt;string&gt;&#123;iOS Provisioning Profiles Name&#125;&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 命令行： 1$ xcodebuild -exportArchive -exportOptionsPlist /Users/cykj/Desktop/cc.plist -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc 导出 ipa 成功： &lt;center&gt;![](http://dzliving.com/XCodeBuildIPA.png)&lt;/center&gt; &lt;font color=#cc0000&gt;``Error Domain=IDEProfileLocatorErrorDomain Code=4 &quot;No &quot;iOS App Development&quot;``&lt;/font&gt; 问题原因：plist 文件中提供的 mehtod 的 value 不对。 3.3 Application Loader当已经生成了 ipa 包时，可以通过 Application Loader 将包 upload 至 AppStore，操作步骤如下： 登录 Application Loader。路径：Xcode -&gt; Open Developer Tool -&gt; Application Loader 这里需要注意的是，密码不是与 Apple ID 对应的用于登录 AppStore 的密码，而是 App 专用密码，获取地址：https://appleid.apple.com/account/manage 上传 ipa 包 登录成功后，需要导入 ipa 包，经过 Application Loader 的检查之后，即可上传 AppStore。 报错 bundle = 209 的包已经在 itunes connect 上有了，新上传的包需要在此 bundle 号的基础上增加，然后重新 upload。 四、打包审核注意 检查 Version 修改 BundleID 修改 Build 号 修改 pch 文件及其他宏定义。可以处理成代码自动根据 BundleID 识别当前为开发环境/发布环境 修改证书及描述文件为发布环境 询问设计人员是否要更换启动图、应用图标、市场图 五、Apple Store Connect5.1 新建 APP 名称 套装 ID：即 Bundle ID，显示在开发者中心中创建好 App ID。 SKU：与 Bundle ID 一样即可 注意：这些信息在创建好 App 后是不能修改的，需要修改的话，只能新建一个 App 替代。点击更多阅读 5.2 添加 App 版本填写信息： 此版本的新增内容。如果当前是第一个上线版本，则没有这一项。 App 预览和屏幕快照。每个版本发布时，记得询问设计人员市场图是否有更新。 关键词。在市场中搜索时有用，可以做优化。 技术支持网址。可以填写公司官网地址。 描述。对 app 进行说明，可以包括公司概述、功能介绍、联系方式等。 版权 商务代表联系信息 App 审核信息。 5.3 导入此构建版本时出错upload 包后，在 itunes connect 中等待处理后，查看发现报错： 报错后，着急去排查工程里面是否有配置问题，排查一圈之后，准备重新打包 upload。就在这时，刷新 itunes connect 网页看一下状态，发现报错的已经正常了，直接用那个包提交，不用重新打包了。点击更多阅读 5.4 IDFA提交审核时，IDFA 选择“否”，报错： 百度查找文章发现原因 着手排查工程中是否使用了 IDFA 并引入 AdSupport.framework，如果有则移除。终端使用命令： 12$ cd 项目目录$ grep -r advertisingIdentifier . 用这条命令检测自己的工程，如果没有查到相关引用，那么就不要勾选使用 IDFA，如果查到了相关引用，并且这些文件是用于展现广告的用途，那么勾选使用了 IDFA。 log 显示极光中有使用。百度搜索“极光 IDFA”问题，跳转到极光社区，找到文章：iOS审核时需要勾选IDFA吗？ 根据官方人员的说明，使用不带用 advertisingIdentifier 字段的方法。兴致勃勃的重新打包，等待了 10-20 分钟左右的时间，重新提交审核，IDFA 选择“否”，依然报错。 已经删除了工程中导入的 AdSupport.framework，不应该啊。 再次进行排查。将 ipa 包导出到本地，修改后缀名为 .zip，解压后使用终端命令： 12$ cd ipa解压后的文件目录$ grep -r AdSupport.framework . log 显示百度统计 sdk 中导入了 AdSupport.framework，百度搜索后跳转官方网站：iOS SDK采集IDFA注意事项 百度官方的意思是设置 IDFA 为 YES 并勾选。 考虑到上线紧迫，最后决策：移除百度统计相关代码，打包 upload。 六、文章Benjamin丶 &amp; Apple开发者账号介绍及证书配置说明PersonChen_QJ &amp; iOS申请邓白氏编码图文流程用于创建开发人员或分发证书和推送证书的CSR（证书签名请求）文件是否必须相同？2019年最新苹果企业开发者账号创建证书完整流程MrCoderLin &amp; Payload文件压缩法打包ipa咖啡绿茶1991 &amp; iOS命令行自动打包(archive)iOS自动化打包Xcode9 xcodebuild 命令行打包遇到的坑与解决方案一键打包完整Shell脚本xcodebuild archiveiOS 如何填App Store Connect信息iOS提交审核：您的 App 正在使用广告标识符 (IDFA)","tags":[]},{"title":"iOS 内置图片瘦身","date":"2019-08-05T16:07:52.645Z","path":"2019/08/06/iOS/iOS优化/iOS 内置图片瘦身/","text":"一、iOS 内置资源的集中方式1.1 将图片存放在 bundle这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到隔离资源的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。 这种方式有比较明显的缺点： ①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。 ②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。 在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。 下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下： 以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。 1.2 使用 .ttf 字体文件替代图标使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。 使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。 字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。 123UILabel * iconLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];iconLabel.font = [UIFont fontWithName:@\"icomoon\" size:50];iconLabel.text = [NSString stringWithUTF8String:\"\\ue902\"]; 由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。 优点： ①、可以降低应用图片内置资源的体积。 ②、可以随意缩放和修改颜色。 缺点： ①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。 ②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。 任何一种需要大刀阔斧改革的优化都是一种不明智的行为。 1.3 图片存在 Assets.xcassets使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。 二、优化项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。 为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。 与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。.framework 中可以存放资源，但 .a 不可以，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。 优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。 先要抛出两个问题： &emsp;①、cocoapods 是否支持使用 Assets.xcassets。 &emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。 为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数： 1234567s.source_files ：源文件路径。s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。s.resources ：资源文件路径及文件类型。s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。 实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。 如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。 查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。 最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。 运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。 既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案： ①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。 ②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。 ③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。 ④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。 只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示： 看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。 为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如 很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。 123456789- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); return value;&#125; 打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。 在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。 这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息： 重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。 12345678910111213141516171819202122- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @\"emaNecruoseRIU\"; // 反转字符串 propKey = [XUtil stringByReversed:propKey]; if ([key isEqualToString:propKey]) &#123; if (normal_imageName) &#123; select_imageName = value; &#125; else &#123; normal_imageName = value; &#125; &#125; return value;&#125; hook UIImageView 的 initWithCoder: 12345678910111213141516171819202122- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; if (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[NSString class]] &amp;&amp; normal_imageName.length &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:normal_imageName]; // 赋值 if (normalImage) &#123; instance.image = normalImage; &#125; normal_imageName = nil; select_imageName = nil; &#125; return instance;&#125; 上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。 但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对增加了项目维护的难度。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。 hook method_exchangeImplementations 方法。 检测方法（字典写入时不要忘了加锁）。 这种方式不能区分 image 和 backgroundImage、normal 和 Selected。目前根据观察顺序应该是： 1234UIResourceName ： normal - image(前景图)UIResourceName ： normal - backgroundImage(背景图)UIResourceName ： selected - image(前景图)UIResourceName ： selected - backgroundImage(背景图)","tags":[]},{"title":"Category","date":"2019-08-05T16:07:52.644Z","path":"2019/08/06/iOS/iOS原理/iOS Category/","text":"分类可以拓展类的属性、方法、协议等信息 一、底层结构在 objc-4 的源码中，搜索 category_t 可以看到: 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。 在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： objc-os.mm _objc_init() map_images() map_images_nolock() objc-runtime-new.mm _read_images() remethodizeClass() attachCategories() attachLists() realloc、memmove、memcpy 最终可以找到这个方法 attachCategories 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); // 判断是否元类 bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /* 方法数组 @[ @[method_t, method_t], @[method_t .....] ] */ method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); /* 属性数组 @[ @[property_t, property_t], @[property_t .....] ] */ property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); /* 协议数组 @[ @[peotocol_t, peotocol_t], @[peotocol_t .....] ] */ protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[I]; // 将所有分类的对象方法，附加到类对象列表中 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 将所有分类的属性，附加到类属性列表中 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 将所有分类的协议，附加到类协议列表中 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。 二、Category和Class Extension 的区别Class Extension: 1234@interface Person ()@property (nonatomic, assign) int sex;- (void)isBig;@end 将属性、方法等封装在 .m 文件里面，类似 private 的应用。 区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。 三、+ Load 和 +initialize 方法的区别Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次） 四、objc_msgSend() 方法实现在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的 12345678910111213141516171819202122232425262728/******************************************************************** * * id objc_msgSend(id self, SEL _cmd, ...); * IMP objc_msgLookup(id self, SEL _cmd, ...); * * objc_msgLookup ABI: * IMP returned in x17 * x16 reserved for our use but not used * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class 但是可以大概猜出它的实现思路: 由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断； 通过 isa 寻找类/元类对象，寻找方法调用； 如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。 五、文章宁夏灼雪__ &amp; iOS底层day4 - 探索Category的实现","tags":[]},{"title":"UITableView优化","date":"2019-08-05T16:07:52.644Z","path":"2019/08/06/iOS/iOS优化/iOS UITableView优化/","text":"一、Cell 复用在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 解决方案：创建一个静态变量 reuseID，防止重复创建（提高性能），使用系统的缓存池功能。 123456789static NSString * CELL_RUID = @\"CELL\"; // 调用次数太多，static 保证只创建一次 reuseID，提高性能- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 缓存池中取已经创建的 cell UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID forIndexPath:indexPath]; return cell;&#125; 通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。 12- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 复用 Cell 时 不会调用 awakeFromNib。 获取方法的区别 dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示： 1reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard' dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示： 1failed to obtain a cell from its dataSource 判断 nil 后可以自己创建 cell。 123456&#123; MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@\"Cell\"]; if (cell == nil) &#123; cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@\"Cell\"]; &#125;&#125; 为什么需要 forIndexPath: 因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。 我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。 注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。 二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的。 好处： ①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（多个 Cell 不是更容易维护？） ②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。 既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。 尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。 三、提前计算并缓存 Cell 的高度3.1 固定高度的 cell1self.tableView.rowHeight = 88; 直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。 3.2 动态高度的 cell实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。 tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。 解决方案：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。 12345678910@interface Model : NSObject@property (nonatomic, assign) CGFloat cellHeight; // Cell 高度/** * @brief 计算高度 */ - (void)calculateCellHeight;@end 在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。 还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。 四、异步绘制（自定义 Cell 绘制）遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。详细整理：UITableView 优化技巧 123456789101112131415161718/** * @brief cell 添加 draw 方法 */- (void)draw&#123; // 异步绘制 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);&#125;/** * @brief 重写 drawRect: 方法 */- (void)drawRect:(CGRect)rect&#123; // 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。&#125; 绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。 五、滑动时，按需加载自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。 123456789101112131415161718192021222324252627282930313233343536- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (needLoadArr.count &gt; 0 &amp;&amp; [needLoadArr indexOfObject:indexPath] == NSNotFound) &#123; [cell clear]; // 清掉内容 &#125; return cell;&#125;// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath * ip = [self.tableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath * cip = [[self.tableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 8; // -8 &lt; 当前位置 - 目标位置 &lt; 8 if (labs(cip.row - ip.row) &gt; skipCount) &#123; // 目标区域的 cell 的 indexPaths NSArray * temp = [self.tableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.tableView.frame.size.width, self.tableView.frame.size.height)]; NSMutableArray * arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y &lt; 0) &#123; NSIndexPath * indexPath = [temp lastObject]; if (indexPath.row + 33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 3 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 2 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。 六、缓存 View当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。 七、尽量显示“大小刚好合适的”图片资源避免大量的图片缩放、颜色渐变等。 八、避免同步的从网络、文件获取数据Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。 九、渲染 减少 subviews 的个数和层级 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。 少用 subviews 的透明图层 渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。 背景色不要使用 clearColor 避免 CALayer 特效（shadowPath） 给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿： 1234view.layer.shadowColor = color.CGColor;view.layer.shadowOffset = offset;view.layer.shadowOpacity = 1;view.layer.shadowRadius = radius; 当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。 十、总结UITableView 的优化主要从四个方面入手： 提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法； 滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage； 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。 大概需要关注的： cell 复用 cell 高度的计算 渲染（混合问题） 减少视图的数目（重写 drawRect:） 减少多余的绘制操作 不要给 cell 动态添加 subView 异步化 UI，不要阻塞主线程 滑动时按需加载对应的内容 十一、资料图片加载优化官方 Demo：LazyTableImages 文章：提升 UITableView 性能-复杂页面的优化 代码：VVeboTableViewDemo 优化UITableViewCell高度计算的那些事UITableView+FDTemplateLayoutCell","tags":[]},{"title":"0-1 背包","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/算法/01-背包/","text":"01 背包问题是用来介绍动态规划算法最经典的例子。 一、解释 1①、状态方程 f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] } ( j &gt;= Wi ) f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。 决策：为了背包中物品总价值最大化，第 i 件物品应该放入背包中吗 ？ ②、实例 假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。 只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。 首先要明确这张表是至底向上，从左到右生成的。 用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。 对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。 同理 c2 = 0，b2 = 3，a2 = 6。 对于承重为 8 的背包，a8 = 15 是怎么得出的呢？ 根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。 f[i-1, j] 表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 Pi 指的是 a 物品的价值，即 6。 由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。 ③、代码 物品信息类 12345678910111213141516171819202122232425@interface PackageItem : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger weight;@property (nonatomic, assign) NSInteger value;- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;@end@implementation PackageItem- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value&#123; if (self = [super init]) &#123; self.name = name; self.weight = weight; self.value = value; &#125; return self;&#125;@end 非递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&#123; NSArray * nameArr = @[ @\"a\", @\"b\", @\"c\", @\"d\", @\"e\" ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]; for(int i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; &#125; [self packageAlgorithm:bagItems bagSize:10];&#125;/** * @brief 01 背包算法 */- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize&#123; if (bagSize == 0 || bagItems.count == 0) return; NSInteger bagMatrix[bagSize][bagItems.count]; // 是否选中数组 PackageItem * item; NSInteger i = 0; // 背包容量，列数 NSInteger j = 0; // 物品数量，行数 // 初始化数组 for (; i &lt;= bagSize; i++) &#123; for (j = 0; j &lt; bagItems.count; j++) bagMatrix[i][j] = 0; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(\"%ld \", (long)bagMatrix[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); for (i = 0; i &lt;= bagSize; i++) &#123; // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取 for (j = bagItems.count - 1; j &gt; -1; j--) &#123; item = bagItems[j]; // 装不下 if (item.weight &gt; i) &#123; // 价值总和为 0 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = 0; &#125; // 价值总和为之前项的和 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = bagMatrix[i][j+1]; &#125; &#125; // 能装下 else &#123; // 是第一个物品，保存起来 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = item.value; &#125; // 非第一个物品，求最大值 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value); &#125; &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(\"%ld \", (long)bagMatrix[i][j]); printf(\"\\n\"); &#125; NSInteger curSize = bagSize; // 当前能装的空间 NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]; // 以 a、b、c、d、e 的顺序获取 for (j = 0; j &lt; bagItems.count; j++) &#123; item = bagItems[j]; // 剩下能装的空间为 0 if (curSize == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123; [answer addObject:item.name]; curSize -= item.weight; &#125; &#125; NSLog(@\"%@\", answer);&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 9 9 12 12 15 15 15 0 0 3 3 6 6 9 9 9 10 11 0 0 0 0 6 6 6 6 6 10 11 0 0 0 0 6 6 6 6 6 10 10 0 0 0 0 6 6 6 6 6 6 6 2019-01-25 22:12:03.795695+0800 Demo[1750:32295] ( a, b, e) 二、解释 2①、状态方程 max.F(n,C,x). x∈0,1 展开公式： F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn x1∗w1 + x2∗w2 + … + xn∗wn ≤ C xi∈0,1 x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。 我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够自动组合 x 的取值使得 F(n,c,x) 达到最大。 再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。 如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。 B(n, C) = B(n−1, C); 没有多余的空间去放置最后一个物品 B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn }; 如果有多余的空间去放置，则考虑是否要放置 B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。 ②、实例 w = {1, 2} v = {1, 2} C = 2 解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。 拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2 不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。 然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2 ③、递归代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; NSArray * nameArr = @[ @\"a\", @\"b\", @\"c\", @\"d\", @\"e\" ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]; for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; // a、b、c、d、e selectedArray[i] = @(0); &#125; NSLog(@\"%ld\", (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]); [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123; if (obj.integerValue) &#123; NSLog(@\"%@ \", nameArr[idx]); &#125; &#125;];&#125;/** * @brief 01 背包算法。递归方式 */- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize&#123; if (bagItems.count == 0 || bagSize == 0 || bagNo == 0) return 0; PackageItem * item = bagItems[bagNo - 1]; // 装不下 if (bagSize &lt; item.weight) &#123; // 在剩余的物品中查找 return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; &#125; else &#123; NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value; if (more &lt; less) &#123; selectedArray[bagNo - 1] = @(1); // 拿 &#125; else &#123; selectedArray[bagNo - 1] = @(0); // 不拿 &#125; return MAX(more, less); &#125;&#125;2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 152019-01-26 00:11:13.897903+0800 Demo[3618:88346] a2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e 三、DP 优于递归的好处动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。 四、学习文章动态规划之 01 背包问题（最易理解的讲解）一文彻底搞懂01背包算法DP——01背包问题使用迭代和动态规划","tags":[]},{"title":"NSDateFormatter性能","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/iOS/iOS优化/iOS NSDateFormatter性能/","text":"一、探究123NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];NSString * current = [dateFormatter stringFromDate:[NSDate date]]; 关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。 1234567891011121314151617181920212223242526272829303132333435363738394041double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = nil;&#123; begin = CACurrentMediaTime(); for (int i = 0; i &lt; 1000; i++) &#123; formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter: %8.2f ms\", (end - begin) * 1000);&#125;&#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter once: %8.2f ms\", (end - begin) * 1000);&#125;-----------Xcode 10.1 iPhone 6s(10.0)----------2019-03-01 10:08:42.184 Demo[95118:1359994] NSDateFormatter: 48.73 ms2019-03-01 10:08:42.188 Demo[95118:1359994] NSDateFormatter once: 3.57 ms2019-03-01 10:11:18.871 Demo[95164:1361958] NSDateFormatter: 61.18 ms2019-03-01 10:11:18.875 Demo[95164:1361958] NSDateFormatter once: 3.85 ms2019-03-01 10:12:03.123 Demo[95178:1362677] NSDateFormatter: 79.80 ms2019-03-01 10:12:03.129 Demo[95178:1362677] NSDateFormatter once: 6.08 ms 上面可以看出两者之间消耗时间差距很大。创建单例很有必要。 那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？ 123456789101112131415161718192021222324252627282930313233343536373839NSDateFormatter * formatter = nil;double begin = 0.0;double end = 0.0;double a = 0, b = 0, c = 0;for (int i = 0; i &lt; 1000; i++) &#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; end = CACurrentMediaTime(); a += (end - begin); begin = CACurrentMediaTime(); [formatter setDateFormat:@\"yyyy-MM-dd\"]; end = CACurrentMediaTime(); b += (end - begin); begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); c += (end - begin);&#125;NSLog(@\"NSDateFormatter:alloc %8.2f ms\", a * 1000);NSLog(@\"NSDateFormatter:setFormat %8.2f ms\", b * 1000);NSLog(@\"NSDateFormatter:stringFromDate %8.2f ms\", c * 1000);-------------Xcode 10.1 iPhone 6s(10.0)-------------2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:alloc 7.01 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:setFormat 0.28 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:stringFromDate 55.98 ms2019-03-01 10:12:03.198 Demo[95178:1362677] NSDateFormatter:alloc 7.69 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:setFormat 0.25 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:stringFromDate 60.97 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:alloc 6.01 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:setFormat 0.20 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:stringFromDate 49.06 ms 从上面可以看出，实际最耗时的方法是 stringFromDate:/dateFromString:。再往下细究。 1234567891011121314151617181920212223242526272829303132double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); NSLog(@\"%8.2f ms\", (end - begin) * 1000);&#125;-------------Xcode 10.0 iPhone 6s(10.0)-------------2019-03-01 10:27:06.218 Demo[95456:1372764] 1.43 ms2019-03-01 10:27:06.218 Demo[95456:1372764] 0.03 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms 从上面可以看出，只有首次调用 stringFromDate:/dateFromString: 方法才会很耗时。再往下细究。 还有人说应该针对 format 格式创建对应的单例对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double begin = 0.0;double end = 0.0;// 不同的对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter1 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter2 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter3 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter4 = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter1 setDateFormat:@\"yyyy-MM-dd\"]; [formatter1 stringFromDate:[NSDate date]]; [formatter2 setDateFormat:@\"MM-dd-yyyy\"]; [formatter2 stringFromDate:[NSDate date]]; [formatter3 setDateFormat:@\"MM-dd\"]; [formatter3 stringFromDate:[NSDate date]]; [formatter4 setDateFormat:@\"MM-yyyy\"]; [formatter4 stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: different format %8.2f ms\\n\", (end - begin) * 1000);&#125;// 同一个对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd-yyyy\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-yyyy\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: %8.2f ms\\n\", (end - begin) * 1000);&#125;---------------Xcode 10.1 iPhone 6s(10.0)---------------NSDateFormatter: different format 23.26 msNSDateFormatter: 16.25 ms 如果不计 NSDateFormatter 对象的初始化时间，那么打印输出： 12NSDateFormatter:different format 23.81 msNSDateFormatter: 23.02 ms 两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。 二、文章NSDateFormatter 性能测试","tags":[]},{"title":"Runtime","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/iOS/iOS原理/Runtime/","text":"一、简介C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。函数标识与函数实现之间的关联可以动态修改。 OC 把一些决定工作从编译链接推迟到运行时，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。 Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事： 封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。 传递消息，找出方法的最终执行代码。 ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）； ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发） 动态加载：NSBundle类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。 1234[receiver message]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)[receiver message:(id)arg...]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...) Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。 当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。runtime源码，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。 二、作用Objc 与 Runtime 相关： ①、通过 Objective-C 源代码②、通过 Foundation 框架的 NSObject 类定义的方法③、通过对 Runtime 库函数的直接调用 2.1 Objective-C 源代码多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。 2.2 通过 Foundation 框架的 NSObject 类定义的方法Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类） NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。 一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如： -class 方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中 -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol: 检查对象是否实现了指定协议类的方法； -methodForSelector: 返回指定方法实现的地址。 2.3 通过对 Runtime 库函数的直接调用Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。 许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。 三、Runtime 相关的头文件ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件 12345678910111213141516171819List.hNSObjCRuntime.hNSObject.hObject.hProtocol.ha.txthashtable.hhashtable2.hmessage.hmodule.mapobjc-api.hobjc-auto.hobjc-class.hobjc-exception.hobjc-load.hobjc-runtime.hobjc-sync.hobjc.hruntime.h 都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括： 3.1 操作对象的类型的定义1234567891011121314151617181920212223242526272829/// An opaque type that represents a method in a class definition. 一个类型，代表着类定义中的一个方法typedef struct objc_method *Method;/// An opaque type that represents an instance variable. 代表实例(对象)的变量typedef struct objc_ivar *Ivar;/// An opaque type that represents a category. 代表一个分类typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property. 代表OC声明的属性typedef struct objc_property *objc_property_t;// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取： 1234Class cls = obj.class;// NSLog(@\"%s\", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLEconst char * clsName = class_getName(cls);NSLog(@\"%s\", clsName); 3.2 函数的定义 操作对象的方法一般以 object_ 开头操作类的方法一般以 class_ 开头操作类或对象的方法的方法一般以 method_ 开头操作成员变量的方法一般以 ivar_ 开头操作属性的方法一般以 property_ 开头操作协议的方法一般以 protocol_ 开头 以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。 根据以上的函数的前缀可以大致了解到层级关系。 123456789101112// 使用 runtime 对当前的应用中加载的类进行打印- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; unsigned int count = 0; Class * clsList = objc_copyClassList(&amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = class_getName(clsList[i]); NSLog(@\"%s\", clsName); &#125;&#125; 四、术语及其数据结构4.1 SEL它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度。它的数据结构是： 1typedef struct objc_selector *SEL; // An opaque type that represents a method selector. 可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。 注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 4.2 idid 是一个参数类型，它是指向某个类的实例的指针。定义如下： 12typedef struct objc_object *id;struct objc_object &#123; Class isa; &#125;; objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。 Direct access to Objective-C’s isa is deprecated in favor of object_getClass() KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。 4.3 Class1typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ /* 父类 */ Class _Nullable super_class OBJC2_UNAVAILABLE; /* 类名 */ const char * _Nonnull name OBJC2_UNAVAILABLE; /* 类的版本信息，默认为 0 */ long version OBJC2_UNAVAILABLE; /* 类信息，供运行时期使用的一些位标识。 如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量; CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; */ long info OBJC2_UNAVAILABLE; /* 实例变量大小（包括从父类继承下来的实例变量）*/ long instance_size OBJC2_UNAVAILABLE; /* 成员变量地址列表 */ struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; /* 方法地址列表，与 info 的一些标志位有关。 如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法; */ struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; /* 缓存最近使用的方法地址，用于提升效率 */ struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; /* 存储该类声明遵守的协议的列表 */ struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif&#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： 123456789101112131415161718192021// 成员变量列表struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。深入理解 Objective-C: Category。 objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。 值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。 实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）； 类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。 为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。 1[NSObject.class alloc]; // [NSObject alloc] 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。 最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。 4.4 Method代表类中某个方法的类型。 123456789101112131415161718192021222324252627282930typedef struct objc_method *Method;struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法名 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; ``` * method\\_name 类型为 SEL* method\\_types 是个 char 指针，存储方法的参数类型和返回值类型* method\\_imp 指向了方法的实现，本质是一个函数指针#### 4.5 Ivar表示成员变量的类型。```objctypedef struct objc_ivar *Ivar;struct objc_ivar &#123; char * _Nullable ivar_name OBJC2_UNAVAILABLE; char * _Nullable ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef __LP64__ int space OBJC2_UNAVAILABLE; // 占用空间#endif&#125; 4.6 IMPobjc.h 中定义如下： 12// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针typedef id (*IMP)(id, SEL, ...); 它就是一个由编译器生成的函数指针，指向方法实现的首地址。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。 如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。 你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。 4.7 Cacheruntime.h 中定义如下： 123456789101112131415typedef struct objc_cache *Cachestruct objc_cache &#123; /* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/ unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; /* 实际占用cache buckets的总数 */ unsigned int occupied OBJC2_UNAVAILABLE; /* 指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。 指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长 */ Method _Nullable buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。 Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。 4.8 Property12typedef struct objc_property *Property;typedef struct objc_property *objc_property_t; // 这个更常用 可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性： 12345678OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT objc_property_t _Nonnull * _Nullableprotocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。 property_getName() 用来查找属性的名称，返回 c 字符串。property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。 五、消息体会官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。 这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤： ①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数； ②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 ③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。 ④、如果 cache 找不到就找类的方法列表中是否有对应的方法。 ⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。 ⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。 在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。 5.1 方法中的隐藏参数 我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？ 其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。 当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数： self 当前方法的对象指针，接受消息的对象 _cmd 当前方法的 SEL 指针，方法选择器 因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。 这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体： 12345678910111213struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */&#125;; 这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现： 123NSLog(@\"%@\", NSStringFromClass([super class]));2018-11-05 11:30:25.082134+0800 Demo[22838:128408] ViewController // 当前类 5.2 获取方法地址NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP： 1234567891011121314151617181920212223242526272829&#123; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; [self fail:YES]; &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;- (void)fail:(BOOL)value&#123;&#125;2018-11-05 13:06:22.683838+0800 Demo[36187:211037] 4.104993&#123; void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(fail:)]; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; setter(self, @selector(fail:), YES); &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;2018-11-05 13:05:48.480498+0800 Demo[36095:209893] 3.751424 虽然是更高效的调用方法，但这种做法很少用，除非是需要持续大量重复调用某个方法的情况，才会选择使用，以免消息发送泛滥。 注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性 六、动态方法解析如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。 1@dynamic propertyName; 这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。 Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。 12345678910111213141516void dynamicIMP(id self, SEL _cmd) &#123; // implementation ....&#125;@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicIMP, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;@end 上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：Type Encoding 动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。 七、消息转发 ①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步； ②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步； ③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步； ④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。 7.1 重定向消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(xxx:))&#123; return otherObj; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。 7.2 转发当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑： 123456789101112131415161718- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; return [otherObj methodSignatureForSelector:aSelector];&#125;/** * @param anInvocation 封装了原始的消息和消息的参数 */- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 判断 otherObj 对象是否实现了方法 if ([otherObj respondsToSelector:[anInvocation selector]]) &#123; [anInvocation invokeWithTarget:otherObj]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。 参数 anInvocation 是从哪来的？ 在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。 forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。 forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。 7.3 转发和多继承转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。 在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 7.4 转发与继承虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。 如果判断上图中的 Warrior 对象是否能响应 negotiate 消息： 12if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... 尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。 如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。 如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。 八、应用场景8.1 获取属性/成员变量列表12345678910// 简单的定义了一个成员变量和两个属性@interface Person : NSObject&#123; @private CGFloat _height;&#125;@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age;@end 使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表： 1234567891011121314151617181920212223242526- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = NSClassFromString(@\"Person\"); // Class cls = Person.class; unsigned int count = 0; // 获取成员变量数组 Ivar * ivarList = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 获取成员变量名 const char * ivarName = ivar_getName(ivarList[i]); NSLog(@\"%s\", ivarName); &#125; // 获取属性数组 objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ptyName = property_getName(ptyList[i]); NSLog(@\"%s\", ptyName); &#125;&#125;2018-11-04 17:28:03.905326+0800 Demo[5894:1444503] _height2018-11-04 17:28:03.905486+0800 Demo[5894:1444503] _name2018-11-04 17:28:03.905616+0800 Demo[5894:1444503] _age2018-11-04 17:28:03.905745+0800 Demo[5894:1444503] name2018-11-04 17:28:03.905877+0800 Demo[5894:1444503] age 从这里就可以看出 @property 做了三件事： ①、生成一个带下划线的成员变量②、生成这个成员变量的 set 方法③、生成这个成员变量的 get 方法 因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。 1234567891011@property (nonatomic, copy, readonly) NSString * name; // 只读属性- (NSString *)name&#123; return @\"job\";&#125;2018-11-04 17:52:52.690815+0800 Demo[6025:1474196] _height2018-11-04 17:52:52.691025+0800 Demo[6025:1474196] _age2018-11-04 17:52:52.691159+0800 Demo[6025:1474196] name2018-11-04 17:52:52.691308+0800 Demo[6025:1474196] age 当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。 一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好? 大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。 在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？ 首先要了解 setValue:forKeyPath: 方法的底层实现： ①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]②、查找有没有成员变量 _XX，如果有 _XX = value；③、查找有没有成员变量 XX，如果有 XX = value；④、如果都没有找到，直接报错。 123Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key name.' 首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。 另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc； 使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。 要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。 12345678910111213141516@property (nonatomic, weak) NSTimer * timer;@property (nonatomic, strong) NSThread * thread;@property (nonatomic, strong, readonly) AModel * a; // 自定义对象&#123; unsigned int count = 0; objc_property_t * propertyList = class_copyPropertyList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSLog(@\"%s\", property_getAttributes(propertyList[i])); &#125;&#125;2018-11-05 15:09:37.839596+0800 Demo[39749:288880] T@\"NSTimer\",W,N,V_timer2018-11-05 15:09:37.839692+0800 Demo[39749:288880] T@\"NSThread\",&amp;,N,V_thread2018-11-05 15:09:37.839771+0800 Demo[39749:288880] T@\"AModel\",R,N,V_a 通过 property_getAttributes() 方法获取属性的参数。 8.2 KVC字典转模型获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。 为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程： ①、遍历字典里面的所有 key，取出 key；②、取出 key 的 value，即 dict[key]；③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。 因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。 因此使用逐一为属性赋值的方法进行 KVC： 12345678910111213141516171819- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = Person.class; unsigned int count = 0; Person * person = [[Person alloc] init]; NSDictionary * dict = @&#123; @\"name\" : @\"Tom\", @\"age\" : @19, @\"height\": @175 &#125;; Ivar * ivars = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:clsName]; NSString * key = [name substringFromIndex:1]; // 去掉'_' [person setValue:dict[key] forKey:key]; &#125;&#125;2018-11-04 19:42:16.964474+0800 Demo[6425:1574210] height:175.0000，name:Tom，age:19，time:(null) 使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。 但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。 setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。 解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。 runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。Type Encodings 123456789101112131415for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; const char * coding = ivar_getTypeEncoding(ivars[i]); // 获取类型 NSString * strCode = [NSString stringWithUTF8String:coding]; id value = dict[key]; if ([strCode isEqualToString:@\"f\"]) &#123; // 判断类型是否是 float value = @(0.0); &#125; [person setValue:value forKey:key];&#125; method_getTypeEncoding() 函数可以获取到方法类型编码 12345678&#123; Method m = class_getInstanceMethod(self.class, @selector(do:at:on:)); NSLog(@\"%s\", method_getTypeEncoding(m));&#125;- (BOOL)do:(NSString *)something at:(char)place on:(int)count;2018-11-05 14:42:30.891829+0800 Demo[38588:270099] B32@0:8@16c24i28 property_getAttributes() 函数可以获取到属性的参数。Declared Properties 8.3 NSCoding 归档和解档获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样： 123456789101112131415161718192021222324252627282930313233- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [self valueForKey:key]; // 取出 key 对应的 value [aCoder encodeObject:value forKey:key]; // 编码 &#125;&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [aDecoder decodeObjectForKey:key]; // 解码 [self setValue:value forKey:key]; // 设置 key 对应的 value &#125; &#125; return self; &#125; 8.4 交换方法实现交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。 1234567891011121314151617+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method orginalMethod = class_getClassMethod([UIImage class], @selector(imageNamed:)); Method swizzleMethod = class_getClassMethod([UIImage class], @selector(my_imageNamed:)); //方法交换 method_exchangeImplementations(orginalMethod, swizzleMethod); &#125;);&#125;+ (UIImage *)my_imageNamed:(NSString *)name&#123; return [self my_imageNamed:name];&#125; 需要注意的是 ①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。 任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。 8.5 类/对象的关联对象关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联 123456789101112131415/* 参数 1 : 关联到对象 参数 2 : 关联的 key，可以是任意类型 参数 3 : 被关联的对象 参数 4 : 关联引用的规则 enum &#123; OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403 &#125;;*/objc_setAssociatedObject(self, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);id value = objc_getAssociatedObject(self, key); 8.6 动态添加方法，拦截未实现的方法每个类都有继承自 NSObject 的两个类方法 12+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel; 一个适用于类方法，一个适用于对象方法。 在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。 123456789101112131415161718192021222324// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmdvoid method(id self, SEL _cmd) &#123;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if ([NSStringFromSelector(sel) isEqualToString:@\"doSomething\"]) &#123; /* 参数 4 : const char *types 方法的类型 要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。 如果想要再增加参数，就可以从实现的第三个参数算起： class_addMethod(self, sel, method, \"v@:@\"); // 多一个对象类型参数增加了 @ void method(id self, SEL _cmd, NSString * name) &#123; &#125; 返回值：YES if the method was found and added to the receiver, otherwise NO. */ class_addMethod(self, sel, method, \"v@:\"); // 为 sel 指定实现为 method &#125; return YES;&#125; 8.7 动态创建一个类动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;objc/message.h&gt;void sayFunction(id self, SEL _cmd, id param) &#123; NSLog(@\"%ld岁的%@在%@说%@\", [object_getIvar(self, class_getInstanceVariable([self class], \"_age\")) integerValue], object_getIvar(self, class_getInstanceVariable([self class], \"_name\")), object_getIvar(self, class_getInstanceVariable([self class], \"schoolName\")), param);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 创建 Student 类。参数 1 : 父类 参数 2 : 类名 参数 3 : 通常为 0 Class StudentClass = objc_allocateClassPair(NSObject.class, \"Student\", 0); // 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型 // 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用 if (class_addIvar(StudentClass, \"schoolName\", sizeof(NSString *), 0, \"@\")) &#123; NSLog(@\"添加成员变量成功\"); &#125; // 添加 NSString * _name 成员变量 class_addIvar(StudentClass, \"_name\", sizeof(NSString *), 0, @encode(NSString *)); // 添加 int _age 成员变量 class_addIvar(StudentClass, \"_age\", sizeof(int), 0, @encode(int)); // 为 Student 类添加方法 \"v@:\" 这种写法见参数类型连接 SEL sel = sel_registerName(\"sayFunction:\"); if (class_addMethod(StudentClass, sel, (IMP)sayFunction, \"v@:@\")) &#123; NSLog(@\"添加方法成功\"); &#125; // 注册这个类到 runtime 系统中就可以使用了 objc_registerClassPair(StudentClass); // 使用创建的类 id student = [[StudentClass alloc] init]; // 给刚刚添加的变量赋值 // object_setInstanceVariable(student, \"schoolName\", (void *)&amp;str);在ARC下不允许使用 [student setValue:@\"清华大学\" forKey:@\"schoolName\"]; // KVC 动态改变实例变量 [student setValue:@\"Tom\" forKey:@\"name\"]; // 从类中获取成员变量Ivar Ivar ageIvar = class_getInstanceVariable(StudentClass, \"_age\"); // 为peopleInstance的成员变量赋值 object_setIvar(StudentClass, ageIvar, @18); // 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息 objc_msgSend(student, \"sayFunction:\", @\"你好~\"); // [student performSelector:sel withObject:@\"你好~\"]; // 动态调用未显式在类中声明的方法 student = nil; StudentClass = nil;// objc_disposeClassPair(StudentClass);&#125; 直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO 九、健壮的实例变量(Non Fragile ivars)在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。 当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移： 上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了： 我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？ 在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。 需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。 十、文章Mike_zh &amp; iOS-Runtime知识点整理ian &amp; Objective-C Runtime 1小时入门教程iOS开发-Runtime 详解iOS RunTime 之数据结构iOS 模块分解—「Runtime面试、工作」Runtime 源码","tags":[]},{"title":"TCP 的断包、粘包","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/计算机网络/TCP 的断包和粘包/","text":"以太网中存在一个对于帧的有效数据大小的限制，即 MTU，以太网的 MTU 为 1500 字节。 一、断包 就是说发送端一次发送的消息长度过大，如果超过了 MTU，那么 ip 会对其进行分片。 在网络编程中，要避免出现 IP 分片。因为是 IP 层是没有超时重传机制的，如果 IP 层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP 分片会大大降低传输层传送数据的成功率，所以要避免 IP 分片。 对于 UDP 包，我们需要在应用层去限制每个包的大小，一般不要超过 1472 字节，即以太网 MTU（1500）- UDP 首部（8）- IP 首部（20）。 对于 TCP 数据，应用层就不需要考虑这个问题了，因为传输层已经做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），一般 MSS = MTU - IP 首部（20）- TCP 首部（20），每次发送的 TCP 数据都不会超过双方 MSS 的最小值，所以就保证了 IP 数据报不会超过 MTU，避免了 IP 分片。 而断包就是因为 MSS 的存在，当消息长度过大，例如超过了 1460 字节（因为 tcp 首部一般为 20 个字节，ip 首部为 20 个字节），那么 tcp 就会将其分片，然后每片被 tcp 封装，然后由 ip 封装，最后被传输到接收端，这样子当接收端接收到消息后，就会不清楚这是不是一个完整的消息。 二、粘包为了提高网络利用率，当传输层发现传输的数据长度太小时，会等待多个消息一起发送，这时候就会提高网络利用率，但是当接收端接收过以后，会不知道这是一个完整的消息，还是多个消息在一起。从而有可能将其作为一个消息来处理。nagle 算法就是实现的这个功能。 对于断包和粘包的通常处理方法为将消息封装为一定的格式，例如每个消息头部为 aa，尾部为 55，或者将整个消息的有效长度标明，这样子当接收端接收到消息之后，就可以以此来分辨消息是不是我完整的。","tags":[]},{"title":"心跳保活","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/计算机网络/心跳保活/","text":"一、前言TCP 协议自身有 KeepAlive 机制，为何基于它的通讯链接，仍然需要在应用层实现额外的心跳保活？本文将从移动端 IM 实践的角度说明，即使使用 TCP 协议，应用层的心跳保活仍旧必不可少。有关 TCP 协议的权威理论介绍，请参见《TCP/IP详解》。 移动端 IM 开发推荐文章：《新手入门一篇就够：从零开发移动端IM》 二、参考资料《TCP/IP详解-第11章·UDP：用户数据报协议》《TCP/IP详解-第17章·TCP：传输控制协议》《TCP/IP详解-第18章·TCP连接的建立与终止》《TCP/IP详解-第21章·TCP的超时与重传》《通俗易懂-深入理解TCP协议（上）：理论基础》《通俗易懂-深入理解TCP协议（下）：RTT、滑动窗口、拥塞处理》《理论经典：TCP协议的3次握手与4次挥手过程详解》《计算机网络通讯协议关系图（中文珍藏版）》《NAT详解：基本原理、穿越技术（P2P 打洞）、端口老化等》 三、心跳保活在使用 TCP 长连接的 IM 服务设计中，往往都会涉及到心跳。心跳一般是指某端（绝大多数情况下是客户端）每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。 有兴趣了解 IM/推送的心跳保活技术的文章，请参见： 《Android进程保活详解：一篇文章解决你的所有疑问》《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》《微信团队原创分享：Android版微信后台保活实战分享(进程保活篇)》《微信团队原创分享：Android版微信后台保活实战分享(网络保活篇)》《移动端IM实践：实现Android版微信的智能心跳机制》《移动端IM实践：WhatsApp、Line、微信的心跳策略分析》更多同类文章 …… 四、TCP 协议的 KeepAlive为什么需要在应用层做心跳，难道 TCP 不是个可靠连接吗？我们不能够依赖 TCP 做断线检测吗？比如使用 TCP 的 KeepAlive 机制来实现。应用层心跳是目前的最佳实践吗？怎么样的心跳才是最佳实践。很多做移动端 IM 的同行，以前确实没有仔细考虑过这些问题，潜意识里想当然的认为这仅仅只是个简单的心跳而已啊。事实并非这么简单。 五、IM 中保持有效长连接的重要性对于客户端而言，使用 TCP 长连接来实现业务的最大驱动力在于：在当前连接可用的情况下，每一次请求都只是简单的数据发送和接受，免去了 DNS 解析，连接建立等时间，大大加快了请求的速度，同时也有利于接受服务器的实时消息。但前提是连接可用。 如果连接无法很好地保持，每次请求就会变成撞大运：运气好，通过长连接发送请求并收到反馈。运气差，当前连接已失效，请求迟迟没有收到反馈直到超时，又需要一次连接建立的过程，其效率甚至还不如 HTTP。而连接保持的前提必然是检测连接的可用性，并在连接不可用时主动放弃当前连接并建立新的连接。 基于这个前提，必须要有一种机制用于检测连接可用性。同时移动网络的特殊性也要求客户端需要在空余时间发送一定的信令，避免连接被回收。详见微信和运营商的撕B（另一篇针对微信的信令风暴技术研究文章请见：《微信对网络影响的技术试验及分析》）。而对于服务器而言，能够及时获悉连接可用性也非常重要：一方面服务器需要及时清理无效连接以减轻负载，另一方面也是业务的需求，如游戏副本中服务器需要及时处理玩家掉线带来的问题。 六、TCP 的 KeepAlive 无法替代应用层心跳保活机制的原因说了保持连接的重要性，那么回到具体实现上。为什么我们需要使用应用层心跳来做检测，而不是直接使用 TCP 的特性呢？ TCP 是一个基于连接的协议，其连接状态是由一个状态机进行维护，连接完毕后，双方都会处于 established 状态，这之后的状态并不会主动进行变化。这意味着如果上层不进行任何调用，一直使 TCP 连接空闲，那么这个连接虽然没有任何数据，但仍是保持连接状态，一天、一星期，甚至一个月，即使在这期间中间路由崩溃重启无数次。举个现实中经常遇到的栗子：当我们 ssh 到自己的 VPS 上，然后不小心踢掉网线，此时的网络变化并不会被 TCP 检测出，当我们重新插回网线，仍旧可以正常使用 ssh，同时此时并没有发生任何 TCP 的重连。 有人会说 TCP 不是有 KeepAlive 机制么，通过这个机制来实现不就可以了吗？但是事实上，TCP KeepAlive 的机制其实并不适用于此。Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200s（详情请参见《TCP/IP详解》中第23章），失败后重试 10 次，每次超时时间 75s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。 因为 TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：检测通讯双方的存活状态。两者听起来似乎是一个意思，但实际上却大相径庭。 考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。 从上面可以知道，KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。 七、心跳保活机制的实现方案参考从上面可以得出结论，目前而言，应用层心跳的确是检测连接有效性，双方是否存活的最佳实践，那么剩下的问题就是怎么实现。 最简单粗暴做法当然是定时心跳，如每隔 30 秒心跳一次，15 秒内没有收到心跳回包则认为当前连接已失效，断开连接并进行重连。这种做法最直接，实现也简单。缺点是比较耗电和耗流量。以一个协议包 5 个字节计算，一天收发 2880 个心跳包，一个月就是 5 2 2880 * 30 = 0.8M 的流量，如果手机上多装几个 IM 软件，每个月只心跳就好几兆流量没了，更不用说频繁的心跳带来的电量损耗。 既然频繁心跳会带来耗电和耗流量的弊端，改进的方向自然是减少心跳频率，但也不能过于影响连接检测的实时性。基于这个需求，一般可以将心跳间隔根据程序状态进行调整，当程序在后台时（这里主要考虑安卓），尽量拉长心跳间隔，5 分钟、甚至 10 分钟都可以。 而当 App 在前台时则按照原来规则操作。连接可靠性的判断也可以放宽，避免一次心跳超时就认为连接无效的情况，使用错误积累，只在心跳超时 n 次后才判定当前连接不可用。当然还有一些小 trick 比如从收到的最后一个指令包进行心跳包周期计时而不是固定时间，这样也能够一定程度减少心跳次数。 八、文章JackJiang2011 &amp; 为什么说基于TCP的移动端IM仍然需要心跳保活？","tags":[]},{"title":"iOS 构建动态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 构建动态库/","text":"一、构建步骤 创建一个动态库 MyDynamicFramework 创建一个测试类 在 MyDynamicFramework.h（默认生成，可统一暴露头文件） 中 #import “Person.h” 1234567891011#import &lt;UIKit/UIKit.h&gt;//! Project version number for MyDynamicFramework.FOUNDATION_EXPORT double MyDynamicFrameworkVersionNumber;//! Project version string for MyDynamicFramework.FOUNDATION_EXPORT const unsigned char MyDynamicFrameworkVersionString[];// In this header, you should import all the public headers of your framework using statements like #import &lt;MyDynamicFramework/PublicHeader.h&gt;#import \"Person.h\" 点击工程 -&gt; Targets -&gt; Build Phases -&gt; Headers。 动态库中新建的文件会自动添加到 project 列表，MyDynamicFramework.h 文件是处于 Public 列表中。由于动态库外部使用者需要调用 Person.h 中的方法，所以也需要将 Person.h 拖拽到 Public 列表。 编译动态库 选择动态库对应的 Scheme，选择 Generic iOS Device 或真机编译出对应真机的动态库，Command + B 编译。在 Xcode 工程中的 Products（这个目录不是工程源文件目录，而是编译后生成对应的沙盒目录）找到 MyDynamicFramework.framework 文件，右键 show in finder。 利用 lipo -info 查看动态库所支持的 CPU 指令集。 新建工程后所编译出来的动态库所支持的 CPU 指令集是 arm 7、arm64。 需要注意： 1lipo -info [文件] 后面跟的是文件路径，而不是 .framework 路径。 指令集种类 armv7｜armv7s｜arm64 都是 ARM 处理器的指令集 i386｜x86_64 是 iOS 模拟器的指令集 理论上指令集是向下兼容的，比如连接设备为 arm64，那么是有可能编译出的动态库所支持的指令集为 armv7s 或者是 armv7。但是向下兼容并不是说一个 armv7s 的动态库可以用在 arm64 架构的设备上，如果连接的设备是 arm64 的，而导入的动态库是没有支持 arm64，那么在编译阶段即会报错。 Xcode 指令集的编译选项 打开 Target -&gt; Build Setting -&gt; Architectures Architectures：指明选定 Target 要求被编译生成的二进制包所支持的指令集 Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集，如果为 YES，那么只编译出连接设备所对应的指令集；如果为 NO，则编译出所有其它有效的指令集（由 Architectures 和 Valid Architectures决定） Valid Architectures：指明可能支持的指令集并非 Architectures 列表中指明的指令集都会被支持 编译产生的动态库所支持的指令集将由上面三个编译选项所影响，首先一个动态库要成功编译，则需要这三个编译选项的交集不为空。 制作支持各机型的动态库 Build Active Architecture Only 统一为 NO Architectures 和 Valid Architectures 都设置为 armv7、armv7s、arm64、arm64e 真机 Command + B 则生成支持 armv7、armv7s、arm64 的动态库，模拟器运行，则生成支持 i386、x86_64 的动态库。 合并模拟器和真机动态库 使用 lipo -create -output 命令合动态库，注意路径是文件路径，不是 .framework 的路径。 使用脚本合并 新建一个 target 脚本。 粘贴以下脚本内容到指定位置 1234567891011121314151617181920212223242526if [ \"$&#123;ACTION&#125;\" = \"build\" ]thenINSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.frameworkDEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.frameworkif [ -d \"$&#123;INSTALL_DIR&#125;\" ]thenrm -rf \"$&#123;INSTALL_DIR&#125;\"fimkdir -p \"$&#123;INSTALL_DIR&#125;\"cp -R \"$&#123;DEVICE_DIR&#125;/\" \"$&#123;INSTALL_DIR&#125;/\"#ditto \"$&#123;DEVICE_DIR&#125;/Headers\" \"$&#123;INSTALL_DIR&#125;/Headers\"# 使用lipo命令将其合并成一个通用framework # 最后将生成的通用framework放置在工程根目录下新建的Products目录下 lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;\"#open \"$&#123;DEVICE_DIR&#125;\"#open \"$&#123;SRCROOT&#125;/Products\"fi 编译新 target 编译完成后生成的 framework 位于工程源代码根目录下的 Products 文件夹下面，通过 lipo -info 可以看到动态库已经支持 i386、x86_64、armv7、armv7s、arm64。 注意：是工程目录，不是沙盒目录。 使用动态库 在新工程的 target -&gt; General -&gt; Embedded Binaries 中添加 MyDynamicFramework.framework。 二、动态使用2.1 使用别人提供的动态库遇到的坑①、第三方库所支持的 CPU 指令集不全。②、运行过程中出现 image not found 异常或者控制台没有异常输出。原因：没有往 Embedded Binaries 中添加 xxx.framework 2.2 动态库动态更新问题能否用动态库来动态更新 AppStore 上的版本呢？ framework 本来是苹果专属的内部提供的动态库文件格式，但是自从 2014 年 WWDC 之后，开发者也可以自定义创建framework 实现动态更新（绕过 apple store 审核，从服务器发布更新版本）的功能，这与苹果限定的上架的 app 必须经过apple store 的审核制度是冲突的，所以含有自定义的 framework 的 app 是无法在商店上架的，但是如果开发的是企业内部应用，就可以考虑尝试使用动态更新技术来将多个独立的 app 或者功能模块集成在一个 app 上面。 企业内部使用的 app，将企业官网中的板块开发成 4 个独立的 app，然后将其改造为 framework 文件最终集成在一款平台级的 app 当中进行使用，这样就可以在一款 app 上面使用原本 4 个 app 的全部功能。 使用自定义的动态库的方式来动态更新只能用在 in house（企业发布）和 develop 模式却但不能在使用到 AppStore，因为在上传打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有 Embedded 的动态库。因此，只要你修改了某个动态库的代码，并重新签名，那么 MD5 的哈希值就会不一样，在加载动态库的时候，苹果会检验这个 hash 值，当苹果监测到这个动态库非法时，就会造成 Crash。 2.3 iOS 如何使用 framework 来进行动态更新？重要参考文档：iOS 利用 Framework 进行动态更新 2.4 谈谈 Mach-O 在制作 framework 的时候需要选择这个 Mach-O Type，确定 static、dynamic 类型库. 为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码、动态库、内核转储的文件格式。作为 a.out 格式的替代，Mach-O 提供了更强的扩展性，并提升了符号表中信息的访问速度。 2.5 自己创建的动态库自建的动态库和系统的动态库有什么区别呢？ 我们创建的动态库是在自己应用的 .app 目录里面，只能自己的 App Extension 和 APP 使用。而系统的动态库是在系统目录里面，所有的程序都能使用。 可执行文件和自己创建的动态库位置： 一般我们得到的 iOS 程序包是 .ipa 文件。其实就是一个压缩包，解压缩 .ipa 后里面会有一个 payload 文件夹，文件夹里有一个 .app 文件，右键显示包内容，然后找到一个一般体积最大的、与 .app 同名的文件，那个文件就是可执行文件。 在模拟器上运行的时候用 [[NSBundle mainBundle] bundlePath]; 就能得到 .app 的路径。可执行文件就在 .app 里面。 而我们自己创建的动态库就在 .app 目录下的 Framework 文件夹里。 我们可以看一下可执行文件中对动态库的链接地址。用MachOView查看可执行文件。其中 @rpth 这个路径表示的位置可以查看Xcode 中的链接路径问题，而现在表示的其实就是 .app 下的 Framework 文件夹。 下图表示了静态库、自建的动态库和系统动态库： 三、文章iOS 动态库制作以及遇到的坑","tags":[]},{"title":"iOS 构建静态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 构建静态库/","text":"一、.a 文件静态库打包 打开 Xcode 创建一个新的 Static Library 工程，取名 MyStaticLibrary。 创建工程完毕后，系统自动创建了一个同名类，添加一个方法用于测试。 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject+ (void)test;@end@implementation MyStaticLibrary+ (void)test&#123; NSLog(@\"sssss\");&#125;@end Command + B 运行工程进行打包。运行完毕后，在工程中 Products 文件夹下的 libMyStaticLibrary.a 文件由红色变成了黑色。右键 show in finder 可以在其目录下找到它。这就是我们打包好的 .a 静态文件。 接下来公开些接口或者头文件供人调用。 公开接口头文件 targets -&gt; Build Phases -&gt; Copy Files -&gt; “+” 添加你需要公开的头文件。可以多添加几个类。 公开头文件后，Command + B 重新运行打包，我们会得到一个 include 文件夹和一个 .a 静态库。 新建一个可运行的工程，把这两个打包好的文件拖入项目测试。 选择 iPhone7 模拟器运行，运行程序，看到日志输出没有问题，即打包.a静态库大功告成。 别高兴的太早。当把模拟器切换成 iPhone5 运行时，编译直接不通过，报错如下： Undefined symbols for architecture i386 的意思是 libMyStaticLibrary.a 静态库不支持 i386 架构，即 32 位模拟器。 iPhone5 模拟器正好是 i386 架构，打包的静态库不支持。但是 iPhone7 模拟器运行却没有问题，这说明打包的静态库支持 iPhone7 模拟器的 cpu 架构 x86_64。如何查看静态库所支持的架构，请看下一步。 终端查看静态库所支持的架构 终端 -> cd 进入库文件路径 -&gt; lipo -info 库名 可以看到静态库仅支持 x86_64 架构，所以运行 iPhone5 模拟器时，编译会报错。 设置适配所有模拟器架构 project -&gt; buildSeting -&gt; Build Active Architecture Only 设为 NO，Valid Architectures 添加 arm7、arm7s 等架构，注意工程 iOS Deployment Target 设置为较低版本，如 8.0，不然不会有 i386。 设置完成后，重新 Command + B 运行打包静态库文件（这时你可随便选一个模拟器），按照上述第 6 步终端查看其支持的架构，我们可以看到终端输出的结果是同时支持 i386 和 x86_64，这也就意味着同时支持所有模拟器。 到这里打包 .a 静态库已经告一段落，但是按上述流程打包的只能在模拟器上跑，真机是不能运行的，因为 ios 真机设备跟模拟器的架构又不一样，继续处理。 打包支持真机架构的静态库 所有流程都跟上面的一样，只是我们运行打包时要选择真机运行，如下图你可以选择自己插上去的真机，也可以选择 Generic ios Devices。当然不要忘记了设置支持所有真机机型架构： Build Active Architecture Only 设为 NO。 看下打包出来的终端查看结果如下： 可以看到同时支持 armv7 和 arm64，也就是支持所有 ios 设备。好了到此打包 .a 静态库算是告一段落。 如果要同时支持模拟器和真机，请使用命令合成 .a 静态库： 1lipo -create \\[name1.a 所在路径\\] \\[name2.a 所在路径\\] -output \\[newname.a\\] ![14](https://upload-images.jianshu.io/upload_images/5294842-23c07761cdb71163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 二、.frameworke 文件静态库打包 Xcode 创建一个新的工程 MyFrameworkLib，选择工程如下： 创建完成后我们可以看到，工程本身自带一个 MyFrameworkLib.h 文件，这是类似一个主头文件一样的东西 创建需要测试的类。 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface MyFramework : NSObject+ (void)test;@end@implementation MyFramework+ (void)test&#123; NSLog(@\"sssss\");&#125;@end 设置支持所有模拟器架构或真机架构（和打包 .a 第 7 步骤一样） 公开头文件 target -&gt; Build Phases -&gt; Headers -&gt; 把需要公开的头文件从 project 拖入 Public。 设置打包的是静态库。 因为动态库也可以是以 framework 形式存在，所以需要设置，否则默认打出来的是动态库（注意：如果要上线 AppSotre，一定要改成静态库，否则审核通不过） target -&gt; BuildSetting -&gt; 搜索关键字 mach-&gt; Mach-o Type 设为 Static Library（这个默认选项是动态的） 选中真机或模拟器运行设备打包（与打包 .a 一样），完成后 Products 文件夹下的 MyFrameworkLib.framework 文件由红色变成了黑色，右键 show in finder 显示如下： MyFrameworkLib.framework 拖入项目便可直接使用。此外还要补充的一点是，打包静态库的时候还需注意打包的是测试版（Debug）还是发布版（Release），这个根据你自己的需求决定，而如何进行设置请下一步骤。 设置打包静态库的测试版和发布版（.a 和 .frameworke） product -&gt; scheme -&gt; Edit scheme -&gt; Run -&gt; 选择 Debug 或 Release。 如果要同时支持多种架构，和 .a 类似，需要设置 Build Activ Architecture Only = NO 和 iOS Deployment Target。 如果要同时支持模拟器和真机，和 .a 类似，使用命令合成 framework 库：lipo -create [.framework/] [.framework/] -output newname 将生成的 MyLib 替换掉任何一个里面的 MyFrameworkLib 文件。","tags":[]},{"title":"iOS 静态库和动态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 静态库和动态库/","text":"一、库1.1 什么是库？库就是程序代码的集合，将 N 个文件组织起来，是共享程序代码的一种方式。从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。 1.2 库的分类根据程序代码的开源情况，库可以分为两类 开源库 源代码是公开的，你可以看到具体实现。比如知名的第三方框架：AFNetworking、SDWebImage。 闭源库 不公开源代码，只公开调用的接口，看不到具体的实现，是一个编译后的二进制文件。这种常见于一些公司的 SDK 包，比如高德地图 SDK、环信即时通讯 SDK 等。而闭源库又分为两类：静态库和动态库。 1.3 从源代码到 app当我们点击了 build 之后，做了什么事情呢？ 预处理（Pre-process）：把宏替换、删除注释、展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对 .o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 1.4 iOS 设备的 CPU 架构模拟器： 4s-5: i386 5s-iPhone X（包括 iPhone SE）: x86_64 真机（iOS设备）： armv6：iPhone、iPhone 2、iPhone 3G、iPod Touch（第一代）、iPod Touch（第二代） armv7：iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2 armv7s：iPhone 5、iPhone 5c（静态库只要支持了 armv7，就可以在 armv7s 的架构上运行，向下兼容） arm64：iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3、iPhone 7、iPhone 7 Plus、iPhone 8、iPhone 8 Plus、iPhone X 二、静态库和动态库静态和动态是相对编译期和运行期而言的： 静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库；动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入。 存在形式： 静态库 以 “.a” 或者 “.framework” 为文件后缀名。 &lt;font color=#cc0000&gt;.a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件&lt;/font&gt;。.a 要有 .h 文件以及资源文件配合，.framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用 .framework 的形式。 动态库 以 “.dylib” 或者 “.framework” 为文件后缀名（Xcode7 之后 .tbd 代替了 .dylib） 使用区别： 静态库链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中。 它的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用。而且系统只加载一次，多个程序共用，节省内存。 相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 各自优点： 静态库： ①、模块化，分工合作，提高了代码的复用及核心技术的保密程度 ②、避免少量改动经常导致大量的重复编译连接 ③、也可以重用，注意不是共享使用 动态库： ①、可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小②、多个应用程序共享内存中得同一份库文件，节省资源③、可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的④、应用插件化⑤、软件版本实时模块升级⑥、在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。 在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，苹果系统专属的 framework 是共享的（如 UIKit），使用 Cocoa Touch Framework 制作的动态库在打包和提交 app 时会被放到 app main bundle 的根目录中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 三、静态库的处理方式 对于一个静态库而言，其实已经是编译好的了（类似一个 .o 的集合），这里并没有连接。在 build 的过程中只会参与链接的过程，而这个链接的过程简单的讲就是合并，并且链接器只会将静态库中被使用的部分合并到可执行文件中去。相比较于动态库，静态库的处理起来要简单的多，具体如下图： 链接器会将所有 .o 用到的 global symbol 和 unresolved symbol 放入一个临时表，而且是 global symbol 是不能重复的。 对于静态库的 .o，链接器会将没有任何 symbol 在 unresolved symbol table 的给忽略。 unresolved symbol 类似 extern int test(); — .h 的声明? global symbol 类似 void test() { print(“test”) } -- .m 的实现? 最后，链接器会用函数的实际地址来代替函数引用。 四、动态库的处理方式 首先，对于动态库而言其实分动态链接库和动态加载库两种的，这两个最本质的区别还是加载时间。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后】 但是不论是哪种动态库，相比较与静态库，动态库处理起来要棘手的多。由于动态库是动态的，所以你事先不知道某个函数的具体地址，因此动态链接器在链接函数的时候需要做大量的工作。 因为动态库在链接函数需要做大量的工作，而静态库已经实现处理好了。所以单纯的在所有都没有加载的情况下，静态库的加载速度会更快一点。而在 iOS 开发中的『库』(一) 提到的有所不妥，正确应该是，虽然动态库更加耗时，但是对于加载过的 share libraries 不需要再加载的这个前提下，使用动态库可以节省一些启动时间。 而实现这个动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果每个函数都被调用过的话，下一次调用就可以通过 PLT 直接跳转了，但是和静态库还是有点区别的是，每一个函数的调用还是需要通过一张 PLT。这也正是 sunny 所说的所有静态链接做的事情都搬到运行时来做了，会导致更慢的原因。 五、动态库的作用 应用插件化 每一个功能点都是一个动态库，在用户想使用某个功能的时候让其从网络下载，然后手动加载动态库，实现功能的的插件化。 虽然技术上来说这种动态更新是可行的，但是对于 AppStore 上上架的 app 是不可以的。iOS8 之后虽然可以上传含有动态库的 app，但是苹果不仅需要你动态库和 app 的签名一致，而且苹果会在你上架的时候再经过一次 AppStore 的签名。所以你想在线更新动态库，首先你得有苹果 AppStore 私钥，而这个基本不可能。 除非你的应用不需要通过 AppStore 上架，比如企业内部的应用，通过企业证书发布，那么就可以实现应用插件化在线更新动态库了。 共享可执行文件 在其它大部分平台上，动态库都可以用于不同应用间共享，这就大大节省了内存。从目前来看，iOS 仍然不允许进程间共享动态库，即 iOS 上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 六、签名系统在加载动态库时，会检查 framework 的签名，签名中必须包含 TeamIdentifier，并且 framework 和 host app 的 TeamIdentifier 必须一致。 我们在 Debug 测试的时候是不会报错的，在打包时如果有动态库，那么就会检查 TeamIdentifier。 如果不一致，否则会报下面的错误： 1Error loading /path/to/framework: dlopen(/path/to/framework, 265): no suitable image found. Did find:/path/to/framework: mmap() error 1 如果用来打包的证书是 iOS 8 发布之前生成的，则打出的包验证的时候会没有 TeamIdentifier 这一项。这时在加载 framework 的时候会报下面的错误： 1[deny-mmap] mapped file has no team identifier and is not a platform binary:/private/var/mobile/Containers/Bundle/Application/5D8FB2F7-1083-4564-94B2-0CB7DC75C9D1/YourAppNameHere.app/Frameworks/YourFramework.framework/YourFramework 可以通过 codesign 命令来验证。 123codesign -dv /path/to/YourApp.app或codesign -dv /path/to/YourFramework.framework 如果证书太旧，输出的结果如下： 12345678910Executable=/path/to/YourApp.app/YourAppIdentifier=com.company.yourappFormat=bundle with Mach-O thin (armv7)CodeDirectory v=20100 size=221748 flags=0x0(none) hashes=11079+5 location=embeddedSignature size=4321Signed Time=2015年10月21日 上午10:18:37Info.plist entries=42TeamIdentifier=not setSealed Resources version=2 rules=12 files=2451Internal requirements count=1 size=188 注意其中的 TeamIdentifier=not set。 我们在用 cocoapods 的 use_framework! 的时候生成的动态库也可以用 codesign -dv /path/to/youFramework.framework 查看到 TeamIdentifier=not set。 七、Framework7.1 什么是 FrameworkFramework 是 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。一般如果是静态 Framework 的话，资源打包进 Framework 是读取不了的。静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 下面的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 Cocoa/Cocoa Touch 开发框架本身提供了大量的 Framework，比如 Foundation.framework/UIKit.framework 等。需要注意的是，这些 Framework 无一例外都是动态库。 平时用的第三方 SDK 的 Framework 都是静态库，真正的动态库是上不了 AppStore（iOS8 之后能上 AppStore，因为 App Extension，需要动态库支持)。 Framework 为什么既是静态库又是动态库？ 系统的 .framework 是动态库，我们自己建立的 .framework 一般都是静态库。但是现在用 xcode 创建Framework 的时候默认是动态库，一般打包成 SDK 给别人用的话都使用的是静态库，可以修改 Build Settings的 Mach-O Type 为 Static Library。 八、Framework 目录 Headers 表示暴露的头文件，一般都会有一个和 Framework 同名的 .h 文件，在创建 Framework 的时候文件夹里也会默认生成这样一个文件。有这个和 Framework 同名的 .h 文件 @import 导入库的时候编译器才能找到这个库（@import 导入头文件可参考 iOS里的导入头文件）。 info.plist 主要就是这个 Framework 的一些配置信息。 Modules 这个文件夹里有个 module.modulemap 文件 123456framework module DynamicFramework &#123; umbrella header \"DynamicFramework.h\" export * module * &#123; export * &#125;&#125; 这里面有这样一句 umbrella header “DynamicFramework.h”，umbrella 有保护伞、庇护的意思。 也就是说 Headers 中暴露的 DynamicFramework.h 文件被放在 umbrella 雨伞下保护起来了，所以我们需要将其他的所有需要暴露的 .h 文件放到 DynamicFramework.h 文件中保护起来，不然会出现警告。@import 的时候也只能找到 umbrella 雨伞下保护起来的 .h 文件。 二进制文件（Unix 可执行文件） 这个就是你源码编译而成的二进制文件，主要的执行代码就在这个里面。 .bundle 文件 如果我们在 Build Phases -&gt; Copy Bundle Resources 里加入 .bundle 文件，那么创建出来的 .Framework 里就会有这个 .bundle 的资源文件夹。 九、Framework 的资源文件CocoaPods 如何生成 Framework 的资源文件？ 我们能看到用 cocoapods 创建 Framework 的时候，Framework 里面有一个 .bundle 文件，跟 Framework 同级目录里也有一个 .bundle文件。这两个文件其实是一样的。 那这两个 .bundle 是怎么来的呢？我们能看到用 use_frameworks! 生成的 pod 里面，pods 这个 PROJECT 下面会为每一个 pod 生成一个 target。 那么如果这个 pod 有资源文件的话，就会有一个叫 xxx-bundleName 的 target，最后这个 target 生成的就是 bundleName.bundle。 在 xxx 的 target 的 Build Phases -&gt; Copy Bundle Resources 里加入这个 .bundle，在 Framework 里面就会生成这样一个 bundle。在 xxx 的 target 的 Build Phases -&gt; Target Dependencies 里加入这个 target：xxx-bundleName，就会在 Framework 的同级目录里生成这样一个 bundle。 静态 Framework 里不需要加入资源文件。一般资源打包进静态 Framework 是读取不了的。 静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 你可以用 NSBundle * bundle = [[NSBundle mainBundle] bundlePath]; 得到 .app 目录，如果是动态库你能在 Framework 目录下看到这个动态库以及动态库里面资源文件。然后你只要用 NSBundle * bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;]; 得到这个动态库的路径就能读取到里面的资源了。但是如果是静态库的话，因为编译进了可执行文件里面，你也就没办法读到这个静态库了，你能看到 .app 下的 Framework 目录为空。 在 Framework 或子工程中使用 xib 十、问题 如果静态库中有 category 类，则在使用静态库的项目配置中【Other Linker Flags】需要添加参数[-ObjC] 或者 [-all_load]。 出现 Umbrella header for module ‘XXXX’ does not include header ‘XXXXX.h’ 因为把 xxxxx.h 错误的拖到了 public 中。 出现 dyld: Library not loaded:XXXXXX 是因为打包的 Framework 版本太高。比如打包 Framework 时，选择的是 iOS 9.0，而实际的工程环境是 iOS 8 开始的。需要到 iOS Deployment Target 设置对应版本。 报错 “Include of non-modular header inside framework module” 如果创建的 Framework 类中使用了 .dylib 或者 .tbd，首先需要在实际项目中导入 .dylib 或者 .tbd 动态库，然后需要设置 Allow Non-modular Includes In Framework Modules = YES 有时候我们会发现在使用的时候加载不了动态 Framework 里的资源文件，其实是加载方式不对，比如用 pod 的时候使用的是 use_frameworks!，那么资源是在 Framework 里面的，需要使用以下代码加载（具体可参考给pod添加资源文件）： 1234NSBundle * bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;];NSString * path = [bundle pathForResource:@\"imageName@2x\"(@\"bundleName.bundle/imageName@2x\") ofType:@\"png\"];UIImage * image = [UIImage imageWithContentsOfFile:path]; 报错 Reason: image not found 如果直接在工程里使用创建的动态库时候会出现此错误，需要在工程的 General 里的 Embedded Binaries 添加这个动态库才能使用。 因为创建的这个动态库其实也不能给其他程序使用的，而你的 App Extension 和 APP 之间是需要使用这个动态库的。这个动态库可以 App Extension 和 APP 之间共用一份（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。 十一、Swift 支持跟着 iOS8/Xcode6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种：1、把代码拷贝到工程中；2、用动态 Framework。使用静态库是不支持的。 造成这个问题的原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的运行库（这是苹果自家的解释）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考这个问题的问题描述，也是来自苹果自家文档）。 十二、CocoaPods 的做法在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应着一个 Pod 的静态库。 当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 vendored_framework 选项来使用第三方 Framework。 对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持。通过 use_frameworks! 选项控制。对于 Swift 写的库来说，想通过 CocoaPods 引入工程，必须加入 use_frameworks! 选项。 十三、关于 use_frameworks!在使用 CocoaPods 的时候在 Podfile 里加入 use_frameworks!，那么你在编译的时候就会默认帮你生成动态库，我们能看到每个源码 Pod 都会在 Pods 工程下面生成一个对应的动态库 Framework 的 target，我们能在这个 target 的 Build Settings -&gt; Mach-O Type 看到默认设置是 Dynamic Library，也就是会生成一个动态 Framework，我们能在 Products 下面看到每一个 Pod 对应生成的动态库。 这些生成的动态库将链接到主项目给主工程使用，但是我们上面说过动态库需要在主工程 target 的 General -&gt; Embedded Binaries 中添加才能使用，而我们并没有在 Embedded Binaries 中看到这些动态库。那这是怎么回事呢，其实是 cocoapods 已经执行了脚本把这些动态库嵌入到了 .app 的 Framework 目录下，相当于在 Embedded Binaries 加入了这些动态库。我们能在主工程 target 的 Build Phase -&gt; Embed Pods Frameworks 里看到执行的脚本。 所以 Pod 默认是生成动态库，然后嵌入到 .app 下面的 Framework 文件夹里。我们去 Pods 工程的 target 里把 Build Settings -&gt; Mach-O Type 设置为 Static Library。那么生成的就是静态库，但是 cocoapods 也会把它嵌入到 .app 的Framework目录下，而因为它是静态库，所以会报错：unrecognized selector sent to instanceunrecognized selector sent to instance。 十四、参考创建一个 iOS Framework 项目Xcode7创建静态库和FrameworkiOS 静态库开发静态库与动态库的使用iOS 静态库，动态库与 Framework签名iOS打包静态库（完整篇）iOS armv7、armv7s、 arm64iOS 创建 .a 和 .framework 静态库，以及 Bundle 资源文件的使用iOS 静态库和动态库（库详解）齐滇大圣 &amp; iOS里的动态库和静态库","tags":[]},{"title":"HTTPS 单向认证和双向认证","date":"2019-05-23T10:19:03.941Z","path":"2019/05/23/计算机网络/HTTPS 单向认证和双向认证/","text":"一、HttpHyperText Transfer Protocol 超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准。HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。 使用 TCP 端口为：80 二、HttpsHyper Text Transfer Protocol over Secure Socket Layer 安全的超文本传输协议，网景公司设计了 SSL（Secure Sockets Layer） 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。 使用 TCP 端口默认：443 三、SSL 协议加密方式SSL 协议既用到了对称加密也用到了非对称加密（公钥加密），在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密。 对称加密 速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 四、单向认证Https 在建立 Socket 连接之前，需要进行握手，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 五、双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式，将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 六、文章Https单向认证和双向认证","tags":[]},{"title":"图片的解压缩、渲染","date":"2019-05-23T10:19:03.941Z","path":"2019/05/23/iOS/iOS媒体/图片的解压缩、渲染/","text":"一、图像从文件到屏幕过程首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CPU/GPU 等在这样一次渲染过程中的具体分工： CPU：计算视图 frame、图片解码、需要绘制纹理图片通过数据总线交给 GPU GPU：纹理混合、顶点变换与计算、像素点的填充计算、渲染到帧缓冲区 时钟信号：垂直同步信号 V-Sync / 水平同步信号 H-Sync iOS 设备双缓冲机制：显示系统通常会引入两个帧缓冲区，双缓冲机制 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。通常计算机显示图片到屏幕是 CPU 与 GPU 协同合作完成一次渲染。 对应用来说，图片是最占用手机内存的资源，将一张图片从磁盘中加载出来，并最终显示到屏幕上，中间经过了一系列复杂的处理过程。 二、图片加载的工作流程 假设使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩； 然后将生成的 UIImage 赋值给 UIImageView； 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 在主线程的下一个 runloop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤： 分配内存缓冲区用于管理文件 IO 和解压缩操作； 将文件数据从磁盘读到内存中； 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作； 最后 Core Animation 中 CALayer 使用未压缩的位图数据渲染 UIImageView 的图层。 CPU 计算好图片的 Frame，对图片解压之后就会交给 GPU 来做图片渲染 渲染流程 GPU 获取获取图片的坐标 将坐标交给顶点着色器（顶点计算） 将图片光栅化（获取图片对应屏幕上的像素点） 片元着色器计算（计算每个像素点的最终显示的颜色值） 从帧缓存区中渲染到屏幕上 图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。 三、为什么要解压缩图片既然图片的解压缩需要消耗大量的 CPU 时间，那么是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。 位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。 12345 NSString * filePath = [[NSBundle mainBundle] pathForResource:@\"Large\" ofType:@\"png\"]; UIImage * image = [UIImage imageWithContentsOfFile:filePath]; CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));&lt;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00007c54 540a540a 540a540a 540a540a 7c000000 00000000 250a5454 0a540a54 0a540a0f 00000000 2554540a 540a540a 540a540a 540a5459 0000258c 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f8c0101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010170 13131313 13131313 13131313 13131313 13131313 13131301 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 16161616 16161616 16161670 70701616 70137070 70707070 70131313 13131313 13131313 13131370 70161616 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 010101a2 03032525 00007c54 540a540a 540a540a 543f0000 00000000 00000000 00000000 00000000 5254540a 540a540a 540a540a 547c0000 00000000 00000000 0000000a 54540a54 0a540a54 0a520000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000283d 48074848 事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片： 12345// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image); // return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least) UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality); 在磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么要对图片解压缩。 四、解压缩原理既然图片的解压缩不可避免，又不想让它在主线程执行，影响应用的响应性，那么是否有比较好的解决方案呢？ 前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。 强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是： 123456789101112131415161718192021/** * data : 如果不为 NULL，它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果为 NULL，系统会自动分配和释放所需的内存 * * width : 位图的宽度。传入图片的像素宽度即可 * height : 位图的高度。传入图片的像素高度即可 * * bitsPerComponent : 像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可 * * bytesPerRow : 位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。 当指定 0/NULL 时，系统不仅会自动计算，而且还会进行 cache line alignment 的优化。 * * space : 颜色空间，一般使用 RGB * bitmapInfo : 位图的布局信息。kCGImageAlphaPremultipliedFirst */CG_EXTERN CGContextRef __nullable CGBitmapContextCreate( void * __nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 五、YYImage\\SDWebImage 开源框架实现YYImage 用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 YYImageCoder 类中，核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay)&#123; ... if (decodeForDisplay) &#123; // decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) &#123; hasAlpha = YES; &#125; // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -[UIView drawRect:] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate( NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; // decode CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; &#125; else &#123; ... &#125;&#125; 它接受一个原始的位图参数 imageRef ，最终返回一个解压缩后的位图 newImage ，中间主要经过了以下三个步骤： 使用 CGBitmapContextCreate 函数创建一个位图上下文； 使用 CGContextDrawImage 函数将原始位图绘制到上下文中； 使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。 事实上，SDWebImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别。 性能对比： 解压 PNG 图片 SDWebImage &gt; YYImage 解压 JPEG 图片 SDWebImage &lt; YYImage 六、总结 图片文件只有在确认要显示时 CPU 才会对其进行解压缩，因为解压非常消耗性能。解压过的图片就不会重复解压，会缓存。 图片渲染到屏幕的过程： 读取文件 -> 计算 Frame -&gt; CPU 图片解码 -> 解码后纹理图片位图数据通过数据总线交给 GPU -&gt; GPU 获取图片 Frame -&gt; 顶点变换计算 -> 光栅化 -> 根据纹理坐标获取每个像素点的颜色值（如果出现透明值需要将每个像素点的颜色*透明度值） -> 渲染到帧缓存区 -> 渲染到屏幕 细究离屏渲染和渲染中的细节处理，就需要掌握 OpenGL ES/Metal 这 2 个图形处理 API。 七、文章探讨 iOS 中图片的解压缩到渲染过程SDWebImageYYImage","tags":[]},{"title":"NSOperation、NSOperationQueue","date":"2019-05-23T10:19:03.941Z","path":"2019/05/23/iOS/iOS多线程/NSOperationQueue/","text":"一、NSOperation 和 NSOperationQueue 简介NSOperation、NSOperationQueue 是苹果提供给开发者使用的一套多线程解决方案。实际上是基于 GCD 的更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。 为什么要使用 NSOperation、NSOperationQueue？ 添加在操作完成后执行的代码； 添加操作之间的依赖关系，方便的控制执行顺序； 设定操作执行的优先级； 可以很方便的取消一个操作的执行。 使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 二、NSOperation 和 NSOperationQueue 操作和操作队列GCD 的一些概念同样适用于 NSOperation、NSOperationQueue，也有类似的任务（操作）和队列（操作队列）的概念。 操作（Operation） 在 GCD 中，任务是放在 block 里的。在 NSOperation 中，使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation 或者自定义子类来封装操作。 操作队列（Operation Queues） 即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 三、NSOperation 和 NSOperationQueue 使用步骤NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时是同步执行操作，配合 NSOperationQueue 能更好的实现异步执行。NSOperation 实现多线程的使用步骤分为三步： 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 创建队列：创建 NSOperationQueue 对象。 将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 四、NSOperation 和 NSOperationQueue 基本使用4.1 创建操作NSOperation 是个抽象类，不能用来封装操作。只有使用它的子类来封装操作，有三种方式来封装操作。 使用子类 NSInvocationOperation 使用子类 NSBlockOperation 自定义继承于 NSOperation 的子类，通过实现内部相应的方法来封装操作。 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下是同步执行操作。 NSInvocationOperation 1234567891011121314151617- (void)useInvocationOperation&#123; NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil]; [operation start];&#125;- (void)task&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"%@\", [NSThread currentThread]); &#125;&#125;2019-03-19 18:03:18.840607+0800 Demo[46957:3117389] &lt;NSThread: 0x600001ffd400&gt;&#123;number = 1, name = main&#125;2019-03-19 18:03:20.842158+0800 Demo[46957:3117389] &lt;NSThread: 0x600001ffd400&gt;&#123;number = 1, name = main&#125; 在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，没有开启新线程。 1234 [NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];2019-03-19 18:06:22.667818+0800 Demo[46995:3119165] &lt;NSThread: 0x6000025e4b40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:06:22.668057+0800 Demo[46995:3119165] &lt;NSThread: 0x6000025e4b40&gt;&#123;number = 3, name = (null)&#125; 在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。 NSBlockOperation 12345678910111213- (void)useBlockOperation&#123; NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"%@\", [NSThread currentThread]); &#125; &#125;]; [operation start];&#125;2019-03-19 18:09:56.666612+0800 Demo[47047:3121571] &lt;NSThread: 0x600003222940&gt;&#123;number = 1, name = main&#125;2019-03-19 18:09:56.666754+0800 Demo[47047:3121571] &lt;NSThread: 0x600003222940&gt;&#123;number = 1, name = main&#125; 在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中并发执行。只有当所有相关的操作已经完成执行时，才视为完成。如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在非当前线程执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (void)useBlockOperationAddExecutionBlock&#123; NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"1---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"2---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"3---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"4---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"5---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"6---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"7---%@\", [NSThread currentThread]); &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"8---%@\", [NSThread currentThread]); &#125; &#125;]; [op start];&#125;2019-03-19 18:14:55.099519+0800 Demo[47115:3124684] 2---&lt;NSThread: 0x600002d51f80&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:14:55.099548+0800 Demo[47115:3124683] 3---&lt;NSThread: 0x600002d5cb00&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:14:55.099549+0800 Demo[47115:3124621] 4---&lt;NSThread: 0x600002d3e880&gt;&#123;number = 1, name = main&#125;2019-03-19 18:14:55.099555+0800 Demo[47115:3124682] 1---&lt;NSThread: 0x600002d51f40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:14:55.099717+0800 Demo[47115:3124621] 4---&lt;NSThread: 0x600002d3e880&gt;&#123;number = 1, name = main&#125;2019-03-19 18:14:55.099720+0800 Demo[47115:3124684] 2---&lt;NSThread: 0x600002d51f80&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:14:55.099730+0800 Demo[47115:3124682] 1---&lt;NSThread: 0x600002d51f40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:14:55.099735+0800 Demo[47115:3124683] 3---&lt;NSThread: 0x600002d5cb00&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:14:55.099873+0800 Demo[47115:3124684] 5---&lt;NSThread: 0x600002d51f80&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:14:55.099873+0800 Demo[47115:3124682] 6---&lt;NSThread: 0x600002d51f40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:14:55.099878+0800 Demo[47115:3124683] 7---&lt;NSThread: 0x600002d5cb00&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:14:55.100183+0800 Demo[47115:3124621] 8---&lt;NSThread: 0x600002d3e880&gt;&#123;number = 1, name = main&#125;2019-03-19 18:14:55.100414+0800 Demo[47115:3124684] 5---&lt;NSThread: 0x600002d51f80&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:14:55.100590+0800 Demo[47115:3124682] 6---&lt;NSThread: 0x600002d51f40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:14:55.100763+0800 Demo[47115:3124683] 7---&lt;NSThread: 0x600002d5cb00&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:14:55.100968+0800 Demo[47115:3124621] 8---&lt;NSThread: 0x600002d3e880&gt;&#123;number = 1, name = main&#125; 使用 NSBlockOperation 并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock: 方法中的操作和 addExecutionBlock: 中的操作是在不同的线程中异步执行的，包括主线程一共有 4 个线程。而且，这次执行结果中 blockOperationWithBlock: 方法中的操作也不是在当前线程（主线程）中执行的。 一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 自定义继承自 NSOperation 的子类 如果 NSInvocationOperation、NSBlockOperation 不能满足日常需求，可以自定义继承于 NSOperation 的子类。 可以通过重写 main 或者 start 方法来定义自己的 NSOperation 对象。重写 main 方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。 先定义一个继承自 NSOperation 的子类，重写 main 方法。 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@interface MyOperation : NSOperation@end@implementation MyOperation- (void)main&#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"%@\", [NSThread currentThread]); &#125; &#125;&#125;@end&#123; [[[MyOperation alloc] init] start];&#125;2019-03-19 18:25:22.022105+0800 Demo[47221:3129776] &lt;NSThread: 0x600003486940&gt;&#123;number = 1, name = main&#125;2019-03-19 18:25:22.022289+0800 Demo[47221:3129776] &lt;NSThread: 0x600003486940&gt;&#123;number = 1, name = main&#125; 在主线程单独使用自定义继承于 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。 4.2 创建队列NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列 除使用 addExecutionBlock: 添加的额外操作外，凡是添加到主队列中的操作都会放到主线程中执行。 1NSOperationQueue * queue = [NSOperationQueue mainQueue]; 自定义队列（非主队列） 添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。 1NSOperationQueue * queue = [[NSOperationQueue alloc] init]; 4.3 将操作加入到队列NSOperation 需要配合 NSOperationQueue 来实现多线程。那么我们需要将创建好的操作加入到队列。总共有两种方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 使用 addOperation: 将操作加入到操作队列中 */- (void)addOperationToQueue&#123; // 1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSInvocationOperation * op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; NSInvocationOperation * op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; NSBlockOperation * op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"3---%@\", [NSThread currentThread]); &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"4---%@\", [NSThread currentThread]); &#125; &#125;]; // 3.添加 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] [queue addOperation:op3]; // [op3 start]&#125;- (void)task1&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"1---%@\", [NSThread currentThread]); &#125;&#125;- (void)task2&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"2---%@\", [NSThread currentThread]); &#125;&#125;2019-03-19 18:34:24.016396+0800 Demo[47313:3134164] 3---&lt;NSThread: 0x6000000d2840&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:34:24.016394+0800 Demo[47313:3134163] 2---&lt;NSThread: 0x6000000d2800&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:34:24.016400+0800 Demo[47313:3134165] 4---&lt;NSThread: 0x6000000da480&gt;&#123;number = 6, name = (null)&#125;2019-03-19 18:34:24.016423+0800 Demo[47313:3134162] 1---&lt;NSThread: 0x6000000da3c0&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:34:24.016590+0800 Demo[47313:3134164] 3---&lt;NSThread: 0x6000000d2840&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:34:24.016609+0800 Demo[47313:3134163] 2---&lt;NSThread: 0x6000000d2800&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:34:24.016620+0800 Demo[47313:3134165] 4---&lt;NSThread: 0x6000000da480&gt;&#123;number = 6, name = (null)&#125;2019-03-19 18:34:24.016624+0800 Demo[47313:3134162] 1---&lt;NSThread: 0x6000000da3c0&gt;&#123;number = 4, name = (null)&#125; 使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。 1234567891011121314151617181920212223242526272829303132/** * 使用 addOperationWithBlock: 将操作加入到操作队列中 */- (void)addOperationWithBlockToQueue&#123; // 1. 创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2. 添加 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"1---%@\", [NSThread currentThread]); &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"2---%@\", [NSThread currentThread]); &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"3---%@\", [NSThread currentThread]); &#125; &#125;];&#125;2019-03-19 18:36:28.275696+0800 Demo[47351:3135582] 1---&lt;NSThread: 0x600002d0df40&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:36:28.275818+0800 Demo[47351:3135583] 2---&lt;NSThread: 0x600002d0df00&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:36:28.275846+0800 Demo[47351:3135581] 3---&lt;NSThread: 0x600002d06440&gt;&#123;number = 4, name = (null)&#125;2019-03-19 18:36:28.275899+0800 Demo[47351:3135582] 1---&lt;NSThread: 0x600002d0df40&gt;&#123;number = 5, name = (null)&#125;2019-03-19 18:36:28.275973+0800 Demo[47351:3135583] 2---&lt;NSThread: 0x600002d0df00&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:36:28.275977+0800 Demo[47351:3135581] 3---&lt;NSThread: 0x600002d06440&gt;&#123;number = 4, name = (null)&#125; 使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。 五、NSOperationQueue 控制串行执行、并发执行NSOperationQueue 有个关键属性 maxConcurrentOperationCount 叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 maxConcurrentOperationCount 默认情况下为 -1 表示不进行限制，可进行并发执行。= 1 为串行队列；> 1 为并发队列。 当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 MIN{ 自定的值，系统默认最大值 }。 六、NSOperation 操作依赖NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。 通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了 3 个接口供开发者管理和查看依赖。 1234- (void)addDependency:(NSOperation *)op; // 添加依赖，使当前操作依赖于操作 op 的完成- (void)removeDependency:(NSOperation *)op; // 移除依赖，取消当前操作对操作 op 的依赖@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; // 在当前操作开始执行之前完成执行的所有操作对象数组 有 A、B 两个操作，A 执行完操作，B 才能执行操作。如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。 123// op2 依赖于 op1。先执行 op1，再执行 op2[op2 addDependency:op1]; 七、NSOperation 优先级queuePriority 属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是 NSOperationQueuePriorityNormal。但是我们可以通过 setQueuePriority: 方法来改变当前操作在同一队列中的执行优先级。 12345678// 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123; NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8&#125;; 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序由操作之间相对的优先级决定。那么，什么样的操作才是进入就绪状态的操作呢？ 当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。 举个例子，现在有 4 个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1、op2、op3、op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3-&gt;op2-&gt;op1。现在将这 4 个操作添加到队列中并发执行。 因为 op1 和 op4 都没有需要依赖的操作，所以在 op1、op4 执行之前，就是处于准备就绪状态的操作。 而 op3 和 op2 都有依赖的操作，所以 op3 和 op2 都不是准备就绪状态下的操作。 理解了进入就绪状态的操作，那么就理解了queuePriority 属性的作用对象。 queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。 如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。如果 op1 和 op4 是不同优先级的操作，那么就会先执行两者中优先级高的操作。 如果一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。 八、NSOperation 和 NSOperationQueue 线程间的通信123456789101112131415161718192021222324252627282930/** * 线程间通信 */- (void)communication&#123; // 1. 创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; // 2. 添加操作 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"1---%@\", [NSThread currentThread]); &#125; // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; NSLog(@\"2---%@\", [NSThread currentThread]); &#125; &#125;]; &#125;];&#125;2019-03-19 18:58:11.699590+0800 Demo[47501:3143587] 1---&lt;NSThread: 0x600003c44c40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:58:11.699836+0800 Demo[47501:3143587] 1---&lt;NSThread: 0x600003c44c40&gt;&#123;number = 3, name = (null)&#125;2019-03-19 18:58:11.705709+0800 Demo[47501:3143542] 2---&lt;NSThread: 0x600003c1d400&gt;&#123;number = 1, name = main&#125;2019-03-19 18:58:11.706378+0800 Demo[47501:3143542] 2---&lt;NSThread: 0x600003c1d400&gt;&#123;number = 1, name = main&#125; 通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。 九、NSOperation 和 NSOperationQueue 线程同步和线程安全 线程安全 线程可能会同时运行一段代码，如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步 线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 十、NSOperation 和 NSOperationQueue 常用属性和方法归纳123456789101112/** * NSOperation */- (void)cancel; // 取消操作，实质是标记 isCancelled 状态。- (void)waitUntilFinished; // 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。- (void)setCompletionBlock:(void (^)(void))block; // 会在当前操作执行完毕时执行 block。取消/暂停/恢复操作- (void)cancelAllOperations; 可以取消队列的所有操作。/** * NSOperationQueue */- (void)waitUntilAllOperationsAreFinished; // 阻塞当前线程，直到队列中的操作全部执行完毕。- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; // 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 这里的暂停和取消（操作和队列）并不代表可以将当前的操作立即取消，而是在当前的操作执行完毕之后不再执行新的操作。 暂停和取消的区别：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法继续执行。 十一、文章行走少年郎 &amp; iOS 多线程：『NSOperation、NSOperationQueue』详尽总结苹果官方–并发编程指南：Operation Queues苹果官方文档：NSOperationObjc 中国：并发编程：API 及挑战","tags":[]},{"title":"尾调用（Tail Call）","date":"2019-05-23T10:19:03.940Z","path":"2019/05/23/C/尾调用（Tail Call）/","text":"一、什么是尾调用 尾调用(Tail Call)是函数式编程的一个重要概念。 一个函数里的最后一个动作是返回一个函数的调用结果，用简单的一句话描述就是“在函数的最后一步调用函数”。 12345function f(x)&#123; let y = x + 1; return g(y);&#125; 函数 f 的最后一步是调用函数 g，这就是尾调用。 以下几种情况，都不属于尾调用： 123456789function f(x) &#123; return g(x) + 1;&#125;function f(x) &#123; var ret = g(x); return (ret === 0) ? 1 : ret;&#125; 这是因为程序必须返回 g(x) 函数的调用以检查、更动 g(x) 的返回值。 二、尾调用优化传统模式的编译器对于尾调用的处理方式就像处理其他普通函数调用一样，总会在调用时在内存中形成一个“调用记录”，又称“调用帧”（call frame），并将其推入调用栈顶部，用于表示该次函数调用，保存调用位置和内部变量等信息。 当一个函数调用发生时，计算机必须 “记住”调用函数的返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般存在调用栈上。在尾调用这种特殊情形中，计算机理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置（相当于直接连续返回两次）。 如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一条 B 的调用记录，等到 B 运行结束，将结果返回 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那在 B 的调用记录上方还有一个 C 的调用记录栈，以此类推，所有的调用记录，就形成一个调用栈。这有可能会出现函数调用栈过大甚至溢出的情况。 尾调用由于是函数的最后一步，所以当前函数帧上包含调用位置、局部变量等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。 尾调用消除： 在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化（完全不改变调用栈是不可能的，还是需要校正调用栈上形式参数与局部变量的信息）。 尾调用优化： 只保留内层函数的调用记录，如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。 产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除（Tail Call Elimination）或尾调用优化（Tail Call Optimization, TCO）。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。 1234567function f() &#123; let a = 1, b = 2; return g(a+b);&#125;f(); // 等价于 function f()&#123; return g(3); &#125; // 等价于 g(3); 上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 a 和 b 的值、函数 f 的调用位置等信息。但由于调用 g 后，函数 f 就结束了，所以执行到最后一步，完全可以删除函数 f 的调用记录，只保留 g(3) 的调用记录。 然而，对于 C++ 等语言来说，在函数最后 return g(x); 并不一定是尾递归，因为在返回之前很可能涉及到对象的析构函数，使得 g(x) 不是最后执行的那个。这可以通过返回值优化来解决。 三、尾递归如果尾调用自身，则称为尾递归。 递归非常耗费内存，因为需要同时保存成百上千条调用记录，很容易出现“栈溢出”的错误。但对于尾递归而言，由于只存在一个调用记录，所以不会发生“栈溢出”的错误。 12345678int factorial(n) &#123; if(n == 1) &#123; return 1; &#125; return n * factorial(n-1);&#125;factorial(5); // 120 上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，空间复杂度 O(n)，当 n 足够大时，则会发生调用栈溢出。如果改写成尾递归，则只保留一个调用记录，空间复杂度 O(1)。 12345678int factorial(n, total) &#123; if(n == 1) &#123; return total; &#125; return factorial(n-1, n*total);&#125; factorial(5,1); 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。在 ES6 中，严格模式下，宣称支持尾调用优化这个新特性。 但目前 V8 引擎并没有优化尾递归，V8 团队认为做尾递归优化存在一系列问题，因此倾向于支持用显示的语法来实现，而非做优化。在 node 环境和浏览器环境都做了测试，当尾递归函数中传入 n 过大时，同样会出现栈溢出的情况，不管是否开启严格模式，所以似乎尾递归优化并没有起作用。 四、递归函数的改写尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。就是把所有用到的内部变量改写成函数的参数。 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total，那就把这个中间变量改写成函数的参数。这样做的缺点是使函数看起来不太直观，为什么计算 5 的阶乘，需要传入两个参数 5 和 1。两个方法可以解决这个问题。 在尾递归函数之外，再提供一个正常形式的函数 123456789101112int tailFactorial(n, total) &#123; if(n == 1) &#123; return total; &#125; return tailFactorial(n - 1, n * total);&#125;int factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5); // 120 上面代码通过一个正常形式的阶乘函数 factorial，调用尾递归函数 tailFactorial，看起来就正常多了。 函数式编程中有一个概念叫做柯里化（currying），简单来说就是将多参数的函数转换为单参数函数的形式，这里也可以使用柯里化。 123456789101112131415function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;&#125;function tailFactorial(n, total) &#123; if(n===1) &#123; return total; &#125; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1) factorial(5) // 120 上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受一个参数的 factorial 函数。 使用 ES6 的默认值特性。 12345678function factorial(n, total=1) &#123; if(n===1) &#123; return total; &#125; return factorial(n-1, n * total);&#125;factorial(5); 上面代码中参数 total 有默认值 1，调用时可以不提供这个值。 总结，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作的命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言，我们需要知道循环可以用递归来代替，而一旦使用递归，就最好使用尾递归。 五、文章百度百科尾调用优化(Tail Call Optimization)深入理解JavaScript中的尾调用(Tail Call)","tags":[]},{"title":"协议分发","date":"2019-05-23T10:19:03.940Z","path":"2019/05/23/iOS/iOS架构/iOS 协议分发/","text":"Github：AOMultiproxier、HJProtocolDispatcher 协议实现分发器，能够轻易实现将协议事件分发给多个实现者。 一、AOMultiproxier.h1#define AOMultiproxierForProtocol(__protocol__, ...) ((AOMultiproxier &lt;__protocol__&gt; *)[AOMultiproxier multiproxierForProtocol:@protocol(__protocol__) withObjects:((NSArray *)[NSArray arrayWithObjects:__VA_ARGS__,nil])]) 调用类方法的宏定义。 12345678@interface AOMultiproxier : NSProxy@property (nonatomic, strong, readonly) Protocol * protocol; // 协议@property (nonatomic, strong, readonly) NSArray * attachedObjects; // 协议方法实现者+ (instancetype)multiproxierForProtocol:(Protocol *)protocol withObjects:(NSArray*)objects;@end AOMultiproxier 继承自 NSProxy 类，声明了两个只读属性和一个初始化方法。 1234NS_ROOT_CLASS@interface NSProxy &lt;NSObject&gt;&#123; Class isa;&#125; NSProxy 是一个类似于 NSObject 的根类，实现了 NSObject 协议。 苹果的官方文档描述： Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information. NSProxy 仅仅是个转发消息的场所，至于如何转发，取决于派生类到底如何实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了，甚至可以不去创建这些对象，去做任何你想做的事情，但是必须要实现他的 forwardInvocation: 和 methodSignatureForSelector: 方法。 二、AOMultiproxier.m1234@interface AOMultiproxier()@property (nonatomic, strong) Protocol * protocol;@property (nonatomic, strong) NSOrderedSet * objects;@end 私有 readwrite 属性。 123456789101112131415161718192021222324252627282930313233343536+ (instancetype)multiproxierForProtocol:(Protocol *)protocol withObjects:(NSArray *)objects&#123; // 调用实例方法 return [[super alloc] initWithProtocol:protocol objects:objects];;&#125;- (instancetype)initWithProtocol:(Protocol*)protocol objects:(NSArray*)objects&#123; // 保存协议 _protocol = protocol; NSMutableArray * validObjects = [NSMutableArray array]; BOOL oneConforms = NO; for (id object in objects) &#123; // 判断 object 是否遵守了 protocol 协议 if ([object conformsToProtocol:protocol]) &#123; oneConforms = YES; &#125; // 判断 object 是否遵守了 protocol 协议或者 protocol 的父协议 if ([self _object:object inheritsProtocolOrAncestorOfProtocol:protocol]) &#123; [validObjects addObject:object]; &#125; &#125; // 没有任何对象遵守协议，触发断言 NSAssert(oneConforms, @\"You didn't attach any object that declares itself conforming to %@. At least one is needed.\", NSStringFromProtocol(protocol)); _objects = [NSOrderedSet orderedSetWithArray:validObjects]; if (_objects.count &lt;= 0 || !oneConforms) return nil; return self;&#125; 初始化方法，给属性赋值。判断对象数组 objects 里的对象是否能够遵守了协议。 123456789+ (BOOL)conformsToProtocol:(Protocol*)protocol&#123; return YES;&#125;- (BOOL)conformsToProtocol:(Protocol *)aProtocol &#123; return protocol_conformsToProtocol(self.protocol, aProtocol);&#125; 重写方法。在此处一直返回 YES，且未调用。 1234- (NSArray *)attachedObjects&#123; return [self.objects array];&#125; NSSet -》NSArray。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 是否能够响应 selector 方法。 */- (BOOL)respondsToSelector:(SEL)selector &#123; BOOL responds = NO; // 是否是必须实现的协议方法（required） BOOL isMandatory = NO; // 获取方法描述 struct objc_method_description methodDescription = [self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory]; if (isMandatory) &#123; responds = YES; &#125; else if (methodDescription.name != NULL) &#123; // 非必须实现的再检查 object 是否实现了协议方法 responds = [self _checkIfAttachedObjectsRespondToSelector:selector]; &#125; return responds;&#125;/** * 转发消息 */- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; SEL selector = [anInvocation selector]; BOOL isMandatory = NO; struct objc_method_description methodDescription = [self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory]; // 方法描述获取失败，调用 super 触发 crash if (methodDescription.name == NULL) &#123; [super forwardInvocation:anInvocation]; return; &#125; BOOL someoneResponded = NO; for (id object in self.objects) &#123; // 可以响应，由 object 调用协议方法 if ([object respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:object]; someoneResponded = YES; &#125; &#125; // If a mandatory method has not been implemented by any attached object, this would provoke a crash // 如果没有 required 方法没有被实现，调用 super 触发 crash if (isMandatory &amp;&amp; !someoneResponded) &#123; [super forwardInvocation:anInvocation]; &#125;&#125;/** * 获取方法签名，包含参数类型、返回值类型等信息。 */- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector&#123; NSMethodSignature * theMethodSignature; BOOL isMandatory = NO; struct objc_method_description methodDescription = [self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory]; if (methodDescription.name == NULL) &#123; return nil; &#125; // 方法描述 -&gt; 方法签名 theMethodSignature = [NSMethodSignature signatureWithObjCTypes:methodDescription.types]; return theMethodSignature;&#125; 消息转发核心方法。检查 selector 对应的方法描述是否正确，并对 required 方法未实现的情况做出处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 返回方法描述 */- (struct objc_method_description)_methodDescriptionForSelector:(SEL)selector isMandatory:(BOOL *)isMandatory&#123; struct objc_method_description method = &#123;NULL, NULL&#125;; // First check on main protocol. 当前协议查找 method = [self _methodDescriptionInProtocol:self.protocol selector:selector isMandatory:isMandatory]; // If no method is known on main protocol, try on ancestor protocols. 在父协议查找 if (method.name == NULL) &#123; unsigned int count = 0; Protocol * __unsafe_unretained * list = protocol_copyProtocolList(self.protocol, &amp;count); for (NSUInteger i = 0; i &lt; count; i++) &#123; Protocol * aProtocol = list[i]; // Skip root protocol if ([NSStringFromProtocol(aProtocol) isEqualToString:@\"NSObject\"]) continue; method = [self _methodDescriptionInProtocol:aProtocol selector:selector isMandatory:isMandatory]; // 找到了 if (method.name != NULL) &#123; break; &#125; &#125; free(list); &#125; return method;&#125;/** * 获取方法描述 */- (struct objc_method_description)_methodDescriptionInProtocol:(Protocol *)protocol selector:(SEL)selector isMandatory:(BOOL *)isMandatory&#123; struct objc_method_description method = &#123;NULL, NULL&#125;; // 使用 runtime 方法获取 method = protocol_getMethodDescription(protocol, selector, YES, YES); if (method.name != NULL) &#123; *isMandatory = YES; return method; &#125; method = protocol_getMethodDescription(protocol, selector, NO, YES); if (method.name != NULL) &#123; *isMandatory = NO; &#125; return method;&#125; 实际获取方法是 _methodDescriptionInProtocol:selector: isMandatory:，在方法内调用运行时方法 protocol_getMethodDescription，这个方法有四个参数，来看看各代表了什么。 12345678910111213141516171819/** * Returns a method description structure for a specified method of a given protocol. * * @param proto A protocol. * @param aSel A selector. * @param isRequiredMethod A Boolean value that indicates whether aSel is a required method. 标识是否是必须实现的 * @param isInstanceMethod A Boolean value that indicates whether aSel is an instance method. 标识是否是实例方法 * * @return An c objc_method_description structure that describes the method specified by e aSel, * e isRequiredMethod, and e isInstanceMethod for the protocol e p. * If the protocol does not contain the specified method, returns an c objc_method_description structure * with the value c &#123;NULL, c NULL&#125;. * * @note This function recursively searches any protocols that this protocol conforms to. */OBJC_EXPORT struct objc_method_descriptionprotocol_getMethodDescription(Protocol * _Nonnull proto, SEL _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 注意第三、四个参数即可。 12345678910- (BOOL)_checkIfAttachedObjectsRespondToSelector:(SEL)selector&#123; for (id object in self.objects) &#123; if ([object respondsToSelector:selector]) &#123; return YES; &#125; &#125; return NO;&#125; 检查 object 对象是否能够响应 selector 方法。 1234567891011121314151617181920212223242526272829- (BOOL)_object:(id)object inheritsProtocolOrAncestorOfProtocol:(Protocol*)protocol&#123; // 在当前协议中查找 if ([object conformsToProtocol:protocol]) &#123; return YES; &#125; BOOL conforms = NO; unsigned int count = 0; Protocol * __unsafe_unretained * list = protocol_copyProtocolList(protocol, &amp;count); // 在查找父协议中查找 for (NSUInteger i = 0; i &lt; count; i++) &#123; Protocol * aProtocol = list[i]; // Skip root protocol. 如果查找到了 NSObject 协议，结束查找 if ([NSStringFromProtocol(aProtocol) isEqualToString:@\"NSObject\"]) continue; // 递归调用 if ([self _object:object inheritsProtocolOrAncestorOfProtocol:aProtocol]) &#123; conforms = YES; break; &#125; &#125; free(list); return conforms;&#125; 查找 object 是否实现了协议方法。 三、HJProtocolDispatcher.h123#define AOProtocolDispatcher(__protocol__, ...) \\ [ProtocolDispatcher dispatcherProtocol:@protocol(__protocol__) \\ toImplemertors:\\[NSArray arrayWithObjects:__VA_ARGS__, nil]] 同样的宏定义，这里用了 \\ 换行，更适合阅读。__VA_ARGS__ 是新的 C99 规范中新增的一个可变参数的宏，目前似乎只有 gcc 支持（VC6.0的编译器不支持），实现思想就是宏定义中参数列表的最后一个参数为 …。 四、HJProtocolDispatcher.m12345678910111213141516171819202122232425262728/** * 返回方法描述 */struct objc_method_description MethodDescriptionForSELInProtocol(Protocol *protocol, SEL sel) &#123; // required 方法 struct objc_method_description description = protocol_getMethodDescription(protocol, sel, YES, YES); if (description.types) &#123; return description; &#125; // optional 方法 description = protocol_getMethodDescription(protocol, sel, NO, YES); if (description.types) &#123; return description; &#125; // 未找到 return (struct objc_method_description)&#123;NULL, NULL&#125;;&#125;/** * 判断 protocol 是否包含 sel 方法 */BOOL ProtocolContainSel(Protocol *protocol, SEL sel) &#123; return MethodDescriptionForSELInProtocol(protocol, sel).types ? YES: NO;&#125; 私有方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@interface ImplemertorContext : NSObject@property (nonatomic, weak) id implemertor; // 方法实现者，即最后调用方法的对象@end@implementation ImplemertorContext@endImplemertorContext 是每个实现者的封装。@interface ProtocolDispatcher ()@property (nonatomic, strong) Protocol * prococol; // 协议@property (nonatomic, strong) NSArray * implemertors; // 实现者数组@end@implementation ProtocolDispatcher+ (id)dispatcherProtocol:(Protocol *)protocol toImplemertors:(NSArray *)implemertors &#123; return [[ProtocolDispatcher alloc] initWithProtocol:protocol toImplemertors:implemertors];&#125;- (instancetype)initWithProtocol:(Protocol *)protocol toImplemertors:(NSArray *)implemertors &#123; if (self = [super init]) &#123; self.prococol = protocol; NSMutableArray *implemertorContexts = [NSMutableArray arrayWithCapacity:implemertors.count]; [implemertors enumerateObjectsUsingBlock:^(id implemertor, NSUInteger idx, BOOL * _Nonnull stop) &#123; ImplemertorContext *implemertorContext = [ImplemertorContext new]; implemertorContext.implemertor = implemertor; [implemertorContexts addObject:implemertorContext]; objc_setAssociatedObject(implemertor, _cmd, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125;]; self.implemertors = [implemertorContexts copy]; &#125; return self;&#125;- (BOOL)respondsToSelector:(SEL)aSelector&#123; // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) &#123; return [super respondsToSelector:aSelector]; &#125; for (ImplemertorContext *implemertorContext in self.implemertors) &#123; if ([implemertorContext.implemertor respondsToSelector:aSelector]) &#123; return YES; &#125; &#125; return NO;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) &#123; return [super methodSignatureForSelector:aSelector]; &#125; struct objc_method_description methodDescription = MethodDescriptionForSELInProtocol(self.prococol, aSelector); return [NSMethodSignature signatureWithObjCTypes:methodDescription.types];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; SEL aSelector = anInvocation.selector; // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) &#123; [super forwardInvocation:anInvocation]; return; &#125; for (ImplemertorContext *implemertorContext in self.implemertors) &#123; if ([implemertorContext.implemertor respondsToSelector:aSelector]) &#123; [anInvocation invokeWithTarget:implemertorContext.implemertor]; &#125; &#125;&#125; 五、总结HJProtocolDispatcher 与 AOMultiproxier 的思想和功能大体相同。 AO 功能更齐全，它会去父协议中检查方法是否存在，且对 required 方法添加了逻辑判断。 AO 继承自 NSProxy，HJ 继承自 NSObject。NSObject 寻找方法顺序：本类-&gt;父类-&gt;动态方法解析-&gt;消息转发；NSproxy 顺序：本类-&gt;消息转发，同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间，所以 NSProxy 效率更高。","tags":[]},{"title":"离屏渲染","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/iOS/iOS原理/离屏渲染/","text":"一、Off-Screen Rendering 离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 离屏渲染的数量才是影响 app 交互性能的根源。 离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。原因主要在于创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。 二、上下文切换不管是在 GPU 渲染过程中，还是熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。 首先要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源 -> 初始化环境 -> 开始一个绘制 -> 绘制完毕后销毁这个绘制环境，如需要切换到 On-Screen Rendering 或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次 mask 的渲染操作。 一次 mask 发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次 mask 需要渲染三次才能在屏幕上显示，这已经是普通视图显示 3 倍耗时，若再加上下文环境切换，一次 mask 就是普通渲染的 30 倍以上耗时操作。 三、出现场景下面的情况或操作会引发离屏渲染： 为图层设置遮罩（layer.mask） 将图层的 layer.masksToBounds/view.clipsToBounds 属性设置为 true 将图层的 layer.allowsGroupOpacity 属性设置为 YES 和 layer.opacity &lt; 1.0 为图层设置阴影（layer.shadow*） 为图层设置 layer.shouldRasterize = true 具有 layer.cornerRadius、layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing 的图层 文本（任何种类，包括 UILabel、CATextLayer、CoreText 等） 使用 CGContext 在 drawRect: 方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现 四、优化方案官方对离屏渲染产生性能问题也进行了优化：iOS 9.0 之前 UIImageView 跟 UIButton 设置圆角都会触发离屏渲染；iOS 9.0 之后 UIButton 设置圆角会触发离屏渲染，而 UIImageView 设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。 4.1 圆角优化在 APP 开发中圆角图片还是经常出现的。如果一个界面中只有少量圆角图片或许对性能没有非常大的影响，但是当圆角图片比较多的时候就会 APP 性能产生明显的影响。 我们设置圆角一般通过如下方式： 12imageView.layer.cornerRadius = CGFloat(10);imageView.layer.masksToBounds = YES; 这样处理的渲染机制是 GPU 在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区的频繁合并和上下文的的频繁切换，出现掉帧现象。 使用贝塞尔曲线 UIBezierPath 和 Core Graphics 框架画出一个圆角。 12345678910111213UIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];UIImage * image = [UIImage imageNamed:@\"myImg\"];// 开始对 imageView 进行画图UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, [UIScreen mainScreen].scale);// 使用贝塞尔曲线画出一个圆形图[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];[image drawInRect:imageView.bounds];imageView.image = UIGraphicsGetImageFromCurrentImageContext();// 结束画图UIGraphicsEndImageContext();[self.view addSubview:imageView]; [HJCornerRadius](https://github.com/panghaijiao/HJCornerRadius) 视图上添加一个子 layer 到最上层，用于遮盖该视图及其子视图，设置 layer 的图片为刚好能够遮盖成所需圆角样子，并且图片颜色刚好是该视图父视图的背景颜色就达到想要的效果。 弊端：如果该父视图的颜色不是纯色，此时该方式就不适用了，同样，如果父视图的颜色会变化，那实现起来的代码也不那么优雅。 通过修改 layer.mask，首先通过贝塞尔曲线创建基于矢量的路径，传递给 CAShapeLayer 进行渲染。路径闭环，再把绘制出的 Shape 赋值给 layer.mask，在 Mask 范围之外的 Layer 将不被显示从而达到圆角效果。代码实现很简单，如下： 1234567891011UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(130, 330, 100, 100)]; [btn setBackgroundColor:[UIColor colorWithRed:(226.0 / 255.0) green:(113.0 / 255.0) blue:(19.0 / 255.0) alpha:1]]; [backgroundImageView addSubview:btn]; //绘制曲线路径 UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:btn.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:btn.bounds.size]; CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init]; //设置大小 maskLayer.frame = btn.bounds; //设置图形样子 maskLayer.path = maskPath.CGPath; btn.layer.mask = maskLayer; &lt;center&gt; ![](http://api.cocoachina.com/uploads//20181012/1539330089810897.png) &lt;/center&gt; 4.2 shadow 优化对于 shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置 shadowPath 来优化性能，能大幅提高性能。示例如下： 12345imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0;imageView.layer.shadowRadius = 2.0;UIBezierPath * path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 当使用阴影的视图形状发生变化时，即 shadowPath 并不会跟随 CALayer 的 bounds 属性进行变化，所以在 layer 的 bounds 产生变化以后需要手动更新 shadowPath 才能让其适配新的 bounds。具体推荐看这篇文章 我们还可以通过设置 shouldRasterize 属性值为 YES 来强制开启离屏渲染。其实就是光栅化（Rasterization）。既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于 UITableViewCell 中，cell 的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是 2.5 个屏幕尺寸。在 100ms 之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。 4.3 其他的一些优化建议 当我们需要圆角效果时，可以使用一张中间透明图片蒙上去 使用 ShadowPath 指定 layer 阴影效果路径 使用异步进行 layer 渲染（Facebook 开源的异步绘制框架 AsyncDisplayKit） 设置 layer 的 opaque 值为 YES，减少复杂图层合成 尽量使用不包含透明（alpha）通道的图片资源 尽量设置 layer 的大小值为整形值 直接让美工把图片切成圆角进行显示，这是效率最高的一种方案 很多情况下用户上传图片进行显示，可以让服务端处理圆角 使用代码手动生成圆角 Image 设置到要显示的 View 上，利用 UIBezierPath（CoreGraphics框架）画出来圆角图片 4.4 Core Animation 工具检测离屏渲染对于离屏渲染的检测，苹果为我们提供了一个测试工具Core Animation。可以在Xcode-&gt;Open Develeper Tools-&gt;Instruments中找到，如下图： Core Animation工具用来监测Core Animation性能，提供可见的FPS值，并且提供几个选项来测量渲染性能。如下图： 下面我们来说明每个选项的功能： Color Blended Layers：这个选项如果勾选，你能看到哪个 layer 是透明的，GPU 正在做混合计算。显示红色的就是透明的，绿色就是不透明的。 Color Hits Green and Misses Red：如果勾选这个选项，且当我们代码中有设置shouldRasterize为YES，那么红色代表没有复用离屏渲染的缓存，绿色则表示复用了缓存。我们当然希望能够复用。 Color Copied Images：按照官方的说法，当图片的颜色格式GPU不支持的时候，Core Animation 会拷贝一份数据让 CPU 进行转化。例如从网络上下载了 TIFF 格式的图片，则需要 CPU 进行转化，这个区域会显示成蓝色。还有一种情况会触发Core Animation的copy方法，就是字节不对齐的时候。 Color Immediately：默认情况下 Core Animation 工具以每毫秒 10 次的频率更新图层调试颜色，如果勾选这个选项则移除 10ms 的延迟。对某些情况需要这样，但是有可能影响正常帧数的测试。 Color Misaligned Images：勾选此项，如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。像素对齐我们已经在上面有所介绍。 Color Offscreen-Rendered Yellow：用来检测离屏渲染的，如果显示黄色，表示有离屏渲染。当然还要结合 Color Hits Green and Misses Red 来看，是否复用了缓存。 Color OpenGL Fast Path Blue：这个选项对那些使用 OpenGL 的图层才有用，像是 GLKView 或者 CAEAGLLayer，如果不显示蓝色则表示使用了 CPU 渲染，绘制在了屏幕外，显示蓝色表示正常。 Flash Updated Regions：当对图层重绘的时候回显示黄色，如果频繁发生则会影响性能。可以用增加缓存来增强性能。 五、UITableView 优化 使用tableView的复用机制 作用：减少内存资源的消耗。 注意：cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect: 或 setNeedsDisplay 方法。 提前预估高度 提前计算并缓存好高度（布局），因为 heightForRowAtIndexPath: 是调用最频繁的方法。 cell 内部有图片 此时需要异步加载图片，防止卡顿（此时的 SDWebImage 的每个 cell 中都创建一个子线程吗？）但是内部开启的线程过多也会影响主线程的性能 解决办法： 在 scrollerView 的代理方法中，didEndDragging，didEndDeceleratiing 方法中，才开始异步加载，其它时刻不进行加载 在 didEndDragging，didEndDeceleratiing 方法中实现方法：获取屏幕上显示出来的 cell 的 indexPath 数组，然后通过遍历 indexPath 的数组，在数据源中，如果已经加载了，就不需要再异步加载，反之进行异步加载,然后再cellForRow方法中也进行一次判断：当self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO 的时候执行异步加载图片的方法 尽量少用 addView 给 Cell 动态添加 View 可以初始化时就添加，相对于一些固定的视图在初始化时就布局好，学会用 hidden 属性来控制是否显示。 减少子视图的数目 当 cell 上面的子视图数量过多时，会影响滑动性能，当子视图太多的时候，对适当的视图进行绘制。 使用不透明视图 不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将 table cell 及其子视图的 opaque 属性设为 YES（默认值）。 预渲染图像和离屏渲染 你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是预渲染图像，在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见《利用预渲染加速iOS设备的图像显示》。 离屏渲染就是在 tableView 中展示多张需要切圆形的图片，此时不要使用 setCornerRadius 的方法，这样耗损性能，用 Core Graphics 绘制圆角，然后返回图片，在 SDWebImage 处理我的分类返回的图片，并进行缓存。 UIImage：本地图片加载方式本地图片加载常用方法有两种： [UIImage imageNamed:@”xx.png”] 图片多次使用时使用，需要使用此方式加入缓存。 [[UIImage alloc] initWithContentsOfFile:@”xx.png”] 图片不常使用时，不使用缓存。 避免对象创建时过多消耗资源 例如：日期处理，将保持日期对象全局唯一。 老生常谈之UITableView的性能优化","tags":[]},{"title":"Sql","date":"2019-05-23T10:19:03.925Z","path":"2019/05/23/数据结构/sql/","text":"一、SQL 语句 什么是 SQL SQL 全称 structured query language 结构化查询语言，是用于访问和处理数据库的标准的计算机语言。 - SQL 指结构化查询语言 - SQL 使我们有能力访问数据库 - SQL 是一种 [ANSI](https://www.ansi.org/) 的标准计算机语言 SQL 能做什么？ SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 RDBMS RDBMS 指的是关系型数据库管理系统。 RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础。 RDBMS 中的数据存储在被称为表（tables）的数据库对象中。表是相关的数据项的集合，它由列和行组成。 什么是 SQL 语句 使用 SQL 语言编写出来的句子/代码，就是 SQL 语句。在程序运行过程中，要想操作数据库中的数据，必须使用 SQL 语句。 SQL 语句的特点 不区分大小写（比如数据库认为 user 和UsEr 是一样的） 每条语句都必须以分号 ‘;’ 结尾。分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。如果使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。 SQL 中的常用关键字 select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index 等等。数据库中不可以使用关键字来命名表、字段。 二、SQL 语句的种类 数据定义语句（DDL:Data Definition Language）可以用于对数据库中的表进行操作。包括 create、drop、alter。 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 数据操作语句（DML:Data Manipulation Language）可以用于对数据库中的数据进行操作。包括insert、update、delete。 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 数据查询语句（DQL:Data Query Language）可以用于查询获得表中的数据。关键字 select 是DQL(也是所有 SQL)用得最多的操作。其他 DQL 常用的关键字有 where、order by、group by 和 having。 三、基本操作 创建表 create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); 1create table t_st (id integer, name text, age integer, score real); 字段类型 SQLite 将数据划分为以下几种存储类型： text 文本字符串 real 浮点值 integer 整型值 blob 二进制数据(比如文件) 注意：实际上 SQLite 是无类型的，就算声明为 integer 类型，还是能存储字符串文本(主键除外)。建表时声明任何类型或者不声明类型都可以，也就意味着创表语句可以这么写： 1create table t_st(name, age); 提示：为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型。 删表 drop table 表名; drop table if exists 表名; 示例： 1drop table t_st; 插入数据 insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …); 示例： 1insert into t_st (name, age) values ('mj', 10); 注意：数据库中的字符串内容应该用单引号括住。 更新数据 update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, …; 示例： 1update t_st set name = 'jack', age = 20; 注意：上面的示例会将 t_st 表中所有记录的 name 都改为 jack，age 都改为 20 删除数据 delete from 表名 ; 示例： 1delete from t_st ; 注意：上面的示例会将 t_st 表中所有记录都删掉。 条件语句 如果只想更新或者删除某些固定的记录，那就必须在 DML 语句后加上一些条件。 条件语句的常见格式： 1234567where 字段 = 某个值 ; // 不能用 ==where 字段 is 某个值 ; // is 相当于 =where 字段 != 某个值 ; where 字段 is not 某个值 ; // is not 相当于!= where 字段 &gt; 某个值 ; where 字段1 = 某个值 and 字段2 &gt; 某个值 ; // and 相当于 C 语言中的 &amp;&amp;where 字段1 = 某个值 or 字段2 = 某个值 ; // or 相当于 C 语言中的 || 示例： 1234567891011①、将 t_st 表中年龄大于 10 并且 姓名不是 jack 的记录，年龄都改为 5update t_st set age = 5 where age &gt; 10 and name != 'jack' ;②、删除 t_st 表中年龄小于等于 10 或者年龄大于 30 的记录delete from t_st where age &lt;= 10 or age &gt; 30 ;③、将 t_st 表中名字等于 jack 的记录，score 字段的值都改为 age 字段的值update t_st set score = age where name = 'jack' ; DQL 语句 12select 字段1, 字段2, ... from 表名 ;select * from 表名; // 查询所有的字段 示例： 1select name, age from t_st where age &gt; 10 ; 起别名(字段和表都可以起别名) 123select 字段1 别名, 字段2 别名, ... from 表名 别名 ;select 别名.字段1, 别名.字段2, ... from 表名 别名 ;select 字段1 别名, 字段2 as 别名, ... from 表名 as 别名 ; 示例： 1select name myname, s.age from t_st as s ; 计算记录的数量 12select count (字段) from 表名 ;select count ( * ) from 表名 ; 示例： 1select count (age) from t_st where score &gt;= 60; 排序 select * from t_st order by 字段 ; 默认是按照升序排序(由小到大)，也可以变为降序(由大到小) select * from t_st order by age desc ; // 降序 select * from t_st order by age asc ; // 升序(默认) 也可以用多个字段进行排序。 // 先按照年龄升序，相同年龄再按照身高降序 select * from t_st order by age asc, height desc ; limit 使用 limit 可以精确地控制查询结果的数量，比如每次只查询 10 条数据 select * from 表名 limit 数值1, 数值2 ; 示例： 1select * from t_st limit 4, 8 ; // 跳过最前面 4 条语句，然后取8 条记录 limit 常用来做分页查询，比如每页固定显示 5 条数据，那么应该这样取数据： 1第 n 页：limit 5*(n-1), 5 // limit 5 相当于limit 0, 5 取最前面的5 条 四、约束 简单约束 建表时可以给特定的字段设置一些约束条件，常见的约束有 not null 规定字段的值不能为 null unique 规定字段的值必须唯一 default 指定字段的默认值 建议：尽量给字段设定严格的约束，以保证数据的规范性。 示例： 1create table st (id integer, name text not null unique, age integer not null default 1) ; // name 字段不能为null，并且唯一；age 字段不能为null，并且默认为 1 主键约束 ①、简单说明 如果 t_st 表中就 name 和 age 两个字段，而且有些记录的 name 和 age 字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据。 良好的数据库编程规范应该要保证每条记录的唯一性。为此，增加了主键约束，也就是说，每张表都必须有一个主键，用来标识记录的唯一性 ②、什么是主键？ 主键(Primary Key，简称 PK)用来唯一地标识某一条记录。例如：t_st 可以增加一个 id 字段作为主键，相当于人的身份证。主键可以是一个字段或多个字段。 ③、主键的设计原则 主键应当是对用户没有意义的 永远也不要更新主键 主键不应包含动态变化的数据 主键应当由计算机自动生成 ④、主键的声明 在创表的时候用 primary key 声明一个主键 123// integer 类型的id 作为t_st 表的主键create table t_st (id integer primary key, name text, age integer); 只要声明为 primary key，就说明是一个主键字段。主键字段默认就包含了 not null 和 unique 两个约束。 如果想要让主键自动增长(必须是 integer 类型)，应该增加 autoincrement 1create table t_st (id integer primary key autoincrement, ...) ; 外键约束 利用外键约束可以用来建立表与表之间的联系。外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段。 新建一个外键： 123// 以下外键的作用是用 t_st 表中的 class_id 字段引用 t_class 表的 id 字段create table t_st (id integer primary key autoincrement, name text, age integer, class_id integer, constraint fk_student_class foreign key (class_id) references t_class (id)); // t_st 表中有一个叫做 fk_t_student_class_id_t_class_id 的外键 表连接查询 需要联合多张表才能查到想要的数据 表连接的类型： 内连接：inner join 或者join(显示的是左右表都有完整字段值的记录) 左外连接：left outer join(保证左表数据的完整性) 示例： 123// 查询 0316iOS 班的所有学生select s.name, s.age from t_st s, t_class c where s.class_id = c.id and c.name = '0316iOS'; 五、文章W3school菜鸟教程","tags":[]},{"title":"GLSL：图形流水线","date":"2019-05-23T10:19:03.923Z","path":"2019/05/23/GLSL/(1)、图形流水线/","text":"一、流水线概述下图描述了一个简化的图形处理流水线，展示了着色器编程（shader programming）的一些重要概念。 一个固定流水线包括如下功能： 1.1 顶点变换（Vertex Transformation） 一个顶点是一个信息集合，包括空间中的位置、顶点的颜色、法线、纹理坐标等。 此阶段的输入是独立的顶点信息。固定功能流水线在这一阶段通常进行如下工作： 顶点位置变换 为每个顶点计算光照 纹理坐标的生成与变换 1.2 图元组合和光栅化（Primitive Assembly and Rasterization）此阶段的输入是变换后的顶点和连接信息(connectivity information)。连接信息告诉流水线顶点如何组成图元(三角形、四边形等)。 此阶段还负责视景体(view frustum)裁剪和背面剔除。 光栅化决定了片断(fragment)以及图元的像素位置。这里的片断是指一块数据，用来更新帧缓存(frame buffer)中特定位置的一个像素。一个片断除了包含颜色，还有法线和纹理坐标等属性，这些信息用来计算新的像素颜色值。 本阶段的输出包括： 帧缓存中片断的位置 在顶点变换阶段计算出的信息对每个片断的插值 这个阶段利用在顶点变换阶段算出的数据，结合连接信息计算出片断的数据。 例如，每个顶点包含一个变换后的位置，当它们组成图元时，就可以用来计算图元的片断 位置。另一个例子是使用颜色，如果多边形的每个顶点都有自己的颜色值，那么多边形内部片断的颜色值就是各个顶点颜色插值得到的。 1.3 片断纹理化和色彩化（Fragment Texturing and Coloring）此阶段的输入是经过插值的片断信息。在前一阶段已经通过插值计算了纹理坐标和一个颜色值，这个颜色在本阶段可以用来和纹理元素进行组合。 此外，这一阶段还可以进行雾化处理。通常最后的输出是片断的颜色值以及深度信息。 1.4 光栅操作（Raster Operations）此阶段的输入： 像素位置 片断深度和颜色值 在这个阶段对片断进行一系列的测试，包括：· 剪切测试(scissor test)· Alpha测试· 模版测试 · 深度测试 如果测试成功，则根据当前的混合模式(blend mode)用片断信息来更新像素值。注意混合只能在此阶段进行，因为片断纹理化和颜色化阶段不能访问帧缓存。帧缓存只能在此阶段访问。 5、一幅图总结固定功能流水线（Visual Summary of the Fixed Functionality）下图直观地总结了上述流水线的各个阶段： 6、取代固定的功能（Replacing Fixed Functionality）现在的显卡允许程序员自己编程实现上述流水线中的两个阶段：· 顶点 shader 实现顶点变换阶段的功能· 片断 shader 替代片断纹理化和色彩化的功能 7、顶点处理器顶点处理器用来运行顶点 shader(着色程序)。顶点 shader 的输入是顶点数据，即位置、颜色、法线等。 下面的 OpenGL 程序发送数据到顶点处理器，每个顶点中包含一个颜色信息和一个位置信息。glBegin(…);glColor3f(0.2, 0.4, 0.6);glVertex3f(-1.0, 1.0, 2.0);glColor3f(0.2, 0.4, 0.8);glVertex3f(1.0, -1.0, 2.0);glEnd(); 一个顶点 shader 可以编写代码实现如下功能：· 使用模型视图矩阵以及投影矩阵进行顶点变换· 法线变换及归一化· 纹理坐标生成和变换· 逐顶点或逐像素光照计算· 颜色计算 不一定要完成上面的所有操作，例如你的程序可能不使用光照。但一旦你使用了顶点 shader，顶点处理器的所有固定功能都将被替换。所以你不能只编写法线变换的 shader 而指望固定功能帮你完成纹理坐标生成。 从上一节已经知道，顶点处理器并不知道连接信息，因此这里不能执行拓扑信息有关的操作。比如顶点处理器不能进行背面剔除，它只是操作顶点而不是面。 顶点 shader 至少需要一个变量：gl_Position，通常要用模型视图矩阵以及投影矩阵进行变换。顶点处理器可以访问 OpenGL 状态，所以可以用来处理材质和光照。最新的设备还可以访问纹理。 8、片断处理器片断处理器可以运行片断 shader，这个单元可以进行如下操作：· 逐像素计算颜色和纹理坐标· 应用纹理· 雾化计算· 如果需要逐像素光照，可以用来计算法线 片断处理器的输入是顶点坐标、颜色、法线等计算插值得到的结果。在顶点 shader 中对每个顶点的属性值进行了计算，现在将对图元中的每个片断进行处理，因此需要插值的结果。 如同顶点处理器一样，当你编写片断 shader 后，所有固定功能将被取代，所以不能使用片断 shader对片断材质化，同时用固定功能进行雾化。程序员必须编写程序实现需要的所有效果。 片断处理器只对每个片断独立进行操作，并不知道相邻片断的内容。类似顶点 shader，我们必须访问OpenGL 状态，才可能知道应用程序中设置的雾颜色等内容。 一个片断shader有两种输出：· 抛弃片断内容，什么也不输出· 计算片断的最终颜色 gl_FragColor，当要渲染到多个目标时计算 gl_FragData。 还可以写入深度信息，但上一阶段已经算过了，所以没有必要。 需要强调的是片断 shader 不能访问帧缓存，所以混合(blend) 这样的操作只能发生在这之后。 【GLSL教程】（一）图形流水线 【转】","tags":[]},{"title":"【GLSL】九、其他","date":"2019-05-23T10:19:03.923Z","path":"2019/05/23/GLSL/(9)、其他/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580988.html 一、法线矩阵在很多顶点 shader 中都用到了 gl_NormalMatrix。这里将介绍这个矩阵是什么，以及它的作用。 大部分计算是在视图空间内完成的，主要原因是光照的运算要放在这个空间内，否则一些依赖观察点坐标的效果，比如镜面反射光就很难实现。 所以我们需要将法线变换到视图空间。变换一个顶点到视图空间的方法如下： vertexEyeSpace = gl_ModelViewMatrix * gl_Vertex; 对法线也能如此操作吗？一个法线是 3 个浮点数组成的向量，而模型视图矩阵是一个 4×4 的矩阵。另外，因为法线是一个向量，我们只需要变换它的方向，而模型视图矩阵中左上方的 3×3 子矩阵正好包含了旋转变换。所以可不可以用法线来乘这个子矩阵呢？ 下面的代码很简单地实现了这个要求： normalEyeSpace = vec3(gl_ModelViewMatrix * vec4(gl_Normal, 0.0)); 这样的话，gl_NormalMatrix 还有什么用呢？只是为了简化代码书写吗？实际当然不是这么简单，上面的代码在某些情况下是有效的，但不能应对所有情况。 让我们看看潜在的问题：在上图中我们可以看到一个三角面以及它的法线和切线。下图显示了如果模型视图矩阵包含非一致缩放(non-uniform scale)的话会发生什么。注意，如果缩放是一致的(uniform)，那么法线方向保持不变，变的只是长度，而且可以通过归一化修正这个影响。 在上图中，模型视图矩阵应用到所有顶点以及法线上，最后的结果明显错误：法线不再与三角面垂直了。 现在我们知道模型视图矩阵在某些情况下，不能用来变换法线向量。下面的问题就是：那么该使用哪个矩阵？ 考虑一个 3×3 矩阵 G，让我们看看要正确变换法线，这个矩阵该是什么样子。 我们知道，变换前切线和法线是垂直的，即 T • N = 0，在变换后切线和法线同样应该保持垂直，即 T’ • N’ = 0。现在假设 G 是正确变换法线的矩阵，同时模型视图矩阵的左上 3×3 子矩阵 M 可以正确变换切线 T(T 是一个向量，所以 w 成分为 0)。因为 T 可以通过两个顶 点的差来计算，所以变换顶点的矩阵同样可以用来变换 T。由此可以得到如下等式：向量的点乘相当于向量的内积，所以有：我们知道相乘的转置等于分别转置再交换顺序相乘：已知 N 和 T 点乘结果为 0，所以如果下式成立就可以满足等式为 0：即有：可见变换法线的正确矩阵是 M 的逆的转置。OpenGL 计算出的这个矩阵就保存在 gl_NormalMatrix 里。在本节开始讨论过，某些情况下使用模型视图矩阵也可以。当模型视图矩阵的左上 3×3 子矩阵 M 正交时，可以得到：一个正交矩阵的所有行/列都为单位向量，并且互相正交。当两个向量乘上正交矩阵时，它们之间的夹角在变换前后不变。由于这种保角变换的关系，所以法线和切线依然保存垂直。此外，向量的长度也保持不变。 M 在什么时候能确定为正交的呢？当我们把几何变换限制为旋转和平移时(在 OpenGL 应用程序中只使用 glRotate 和 glTranslate，而不使用 glScale)，就可以保证 M 正交。注意：gluLookAt 同样建立正交矩阵。二、关于法线归一化 当一个法线到达顶点 shader 后，我们一般会将它归一化： normal = normalize(gl_NormalMatrix * gl_Normal); 法线与 gl_NormalMatrix 矩阵相乘，将会被变换到视图空间。归一化向量可以保证使用点乘得到余弦值。 我们可以避免归一化计算吗？在某些情况下是可行的。如果 gl_NormalMatrix 是正交矩阵，那么经过变换后输入法线的长度不会变，依然等于 gl_Normal。所以如果在 OpenGL 程序中法线已经是归一化的，那么在 shader 中就不需要在重复了。 也就是说，如果我们使用 gluLookAt 设置照相机，对模型值进行旋转和平移变换，就可以在 shader 中避免使用归一化操作。这对于归一化过的光线向量也是适用的。 三、片断 shader 的情况在片断 shader 中，我们经常发现需要重新归一化在顶点 shader 中已归一化的法线。这是必要的吗？答案是肯定的。 考虑一个包含三个不同顶点法线的三角面。片断 shader 接收经过插值的法线，插值基于距离三个顶点的远近。这样得到的法线方向是对的，但不再是单位长度了。 下图显示了原因。图中黑线表示三角面，顶点法线用蓝色表示，插值得到的片断法线用绿色表示。所有的插值法线排列在黑色的点划线上。从图上可以看出绿色的插值法线大小小于单位长度的顶点法线。注意，如果顶点法线没有单位化，那么得到的插值法线的方向也将是错误的。所以，即使一个顶点没有在顶点 shader 用到，也可能要对它在顶点 shader 中进行归一化。 有一种情况，在片断 shader 中可以避免归一化操作，那就是每个顶点法线方向相同，而且顶点法线是经过归一化的。此时顶点法线插值得到的结果都相同。 以方向光为例，每个片断都需要考虑光线方向，如果光线向量已经在之前归一化了，在片断 shader 中就可以避免归一化这一步。","tags":[]},{"title":"【GLSL】七、逐像素的光照","date":"2019-05-23T10:19:03.923Z","path":"2019/05/23/GLSL/(7)、逐像素的光照/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580965.html 一、逐像素的方向光（Directional Light per Pixel）这一节将把前面的 shader 代码改为逐像素计算的方向光。我们需要将工作按照两个 shader 拆分，以确定哪些是需要逐像素操作的。 首先看看每个顶点接收到的信息：• 法线• 半向量• 光源方向 我们需要将法线变换到视点空间然后归一化。我们还需要将半向量和光源方向也归一化，不过它们已经位于视点空间中了。这些归一化之后的向量会进行插值，然后送入片断 shader，所以需要声明易变变量保存这些向量。 我们也可以在顶点 shader 中完成一些与光和材质相关的计算，这样可以帮助平衡顶点 shader 和片断 shader 的负载。 顶点 shader 代码可以写成如下形式： varying vec4 diffuse, ambient; varying vec3 normal, lightDir, halfVector; void main() { / first transform the normal into eye space and normalize the result / normal = normalize(gl_NormalMatrix * gl_Normal); /* now normalize the light’s direction. Note that according to the OpenGL specification, the light is stored in eye space. Also since we’re talking about a directional light, the position field is actually direction */ lightDir = normalize(vec3(gl_LightSource[0].position)); / Normalize the halfVector to pass it to the fragment shader / halfVector = normalize(gl_LightSource[0].halfVector.xyz); / Compute the diffuse, ambient and globalAmbient terms / diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient; ambient += gl_FrontMaterial.ambient * gl_LightModel.ambient; gl_Position = ftransform(); } 接下来在片断 shader 中，首先要声明同样的易变变量。此外还要再次对法线进行归一化，光线向量不需要进行归一化了，因为方向光对所有顶点都是一致的，插值得到的结果自然也不会变。之后就是计算插值过的法线向量与光线向量的点积。 varying vec4 diffuse,ambient; varying vec3 normal,lightDir,halfVector; void main() { vec3 n,halfV; float NdotL,NdotHV; / The ambient term will always be present / vec4 color = ambient; /* a fragment shader can’t write a varying variable, hence we need a new variable to store the normalized interpolated normal */ n = normalize(normal); / compute the dot product between normal and ldir / NdotL = max(dot(n,lightDir),0.0); … } 如果点积结果 NdotL 大于 0，我们就必须计算散射光，也就是用顶点 shader 传过来的散射项乘以这个点积。我们还需要计算镜面反射光，计算时首先对接收到的半向量归一化，然后计算半向量和法线之间的点积。 … if (NdotL &gt; 0.0) { color += diffuse * NdotL; halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += gl_FrontMaterial.specular gl_LightSource[0].specular pow(NdotHV, gl_FrontMaterial.shininess); } gl_FragColor = color; 下图显示了逐像素光照和逐顶点光照效果的区别：本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/dirpixsd.zip 二、逐像素的点光（Point Light Per Pixel）本节基于前面有关方向光的内容，大部分代码都相同。本节内容主要涉及方向光和点光的不同之处。方向光一般假设光源在无限远的地方，所以到达物体时是平行光。相反，点光源有一个空间中的位置，并向四面八方辐射光线。此外，点光的强度会随到达顶点的距离而衰弱。 对于 OpenGL 程序来说，这两种光的区别主要有：• 光源的 position 域的 w 分量：对方向光来说它是 0，表面这个 position 实际是一个方向(direction)；对点光来说，这个分量是 1。• 点光源的衰减由三个系数决定：一个常数项，一个线性项和一个二次项。 对方向光来说，光线的方向对所有顶点相同，但是对点光来说，方向是从顶点指向光源位置的向量。因此对我们来说需要修改的就是在顶点 shader 中加入计算光线方向的内容。 在 OpenGL 中衰减是按照如下公式计算的： 式中 k0 是常数衰减系数，k1 是线性衰减系数，k2 是二次衰减系数，d 是光源位置到顶点的距离。 注意衰减与距离是非线性关系，所以我们不能逐顶点计算衰减再在片断 shader 中使用插值结果，不过我们可以在顶点 shader 中计算距离，然后在片断 shader 中使用距离的插值计算衰减。 使用点光计算颜色值的公式为： 在上面公式中，环境光部分必须分解为两项：使用光照模型的全局环境光设置和光源中的环境光设置。顶点 shader 也必须分别计算这两个环境光成分。新的顶点 shader 如下： varying vec4 diffuse, ambientGlobal, ambient; varying vec3 normal, lightDir, halfVector; varying float dist; void main() { vec4 ecPos; vec3 aux; normal = normalize(gl_NormalMatrix * gl_Normal); / these are the new lines of code to compute the light’s direction / ecPos = gl_ModelViewMatrix * gl_Vertex; aux = vec3(gl_LightSource[0].position - ecPos); lightDir = normalize(aux); dist = length(aux); halfVector = normalize(gl_LightSource[0].halfVector.xyz); / Compute the diffuse, ambient and globalAmbient terms / diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; / The ambient terms have been separated since one of them / / suffers attenuation / ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient; ambientGlobal = gl_FrontMaterial.ambient * gl_LightModel.ambient; gl_Position = ftransform(); } 在片断 shader 中需要计算衰减，还需要将插值得到的光线方向向量归一化，因为一般来说照到每个顶点的光线方向都不同。 varying vec4 diffuse, ambientGlobal, ambient; varying vec3 normal, lightDir, halfVector; varying float dist; void main() { vec3 n, halfV, viewV, ldir; float NdotL, NdotHV; vec4 color = ambientGlobal; float att; /* a fragment shader can’t write a varying variable, hence we need a new variable to store the normalized interpolated normal */ n = normalize(normal); / compute the dot product between normal and normalized lightdir / NdotL = max(dot(n,normalize(lightDir)), 0.0); if (NdotL &gt; 0.0) { att = 1.0 / (gl_LightSource[0].constantAttenuation + gl_LightSource[0].linearAttenuation * dist + gl_LightSource[0].quadraticAttenuation dist dist); color += att (diffuse NdotL + ambient); halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += att gl_FrontMaterial.specular gl_LightSource[0].specular * pow(NdotHV,gl_FrontMaterial.shininess); } gl_FragColor = color; } 下图显示了固定功能的逐顶点与本节中逐像素计算得到的点光效果： 本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/pointlightsd.zip 三、逐像素的聚光（Spot Light Per Pixel）本节内容与上一节基本一致，唯一不同的就是聚光不同于点光，其发出的光线被限制在一个圆锥体中。对于 OpenGL 程序来说，这两种光的区别主要有：• 聚光包含一个方向向量 spotDirection，表示圆锥体的轴。• 圆锥体包含一个角度，在 GLSL 中可以使用应用程序设置的角度值以及对应的余弦值spotCosCutoff。• 最后还有一个衰减速率 spotExponent，它表示从圆锥的中心轴向外表面变化时光强度的衰减。 聚光的顶点 shader 与点光完全相同，我们只需要对片断 shader 进行一些修改。只有当当前片断位于聚光的光锥内时，才需要对散射光、镜面反射光和环境光成分进行着色。所以我们首先要检查这个条件。 光源与某点连线向量以及聚光方向向量(spotDirection)之间夹角的余弦值必须大于 spotCosCutoff，否则此点位于聚光之外，只能接收到全局环境光。 … n = normalize(normal); / compute the dot product between normal and ldir / NdotL = max(dot(n, normalize(lightDir)), 0.0); if (NdotL &gt; 0.0) { spotEffect = dot(normalize(gl_LightSource[0].spotDirection), normalize(-lightDir)); if (spotEffect &gt; gl_LightSource[0].spotCosCutoff) { / compute the illumination in here / } } gl_FragColor = … 下面的光照计算与点光非常相似，唯一区别是衰减必须乘以聚光效果(spotlight effect)，这个值按如下公式计算： 上式中 spotDirection 来自 OpenGL 中设置的状态，lightDir 是光源到某点的向量，spotExp 是聚光衰减率，这个值也是在 OpenGL 程序中设置的，它用来控制从聚光光锥中心到边缘的衰减。spotExp 越大衰减越快，如果为 0 表示在光锥内光强是常数。 spotEffect = pow(spotEffect, gl_LightSource[0].spotExponent); att = spotEffect / (gl_LightSource[0].constantAttenuation + gl_LightSource[0].linearAttenuation * dist + gl_LightSource[0].quadraticAttenuation dist dist); color += att (diffuse NdotL + ambient); halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += att gl_FrontMaterial.specular gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess); 下图分别显示了使用固定功能流水线的逐顶点光照计算，以及使用本节 shader 的逐像素光照计算得到的聚光效果。本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/spotlightsd.zip","tags":[]},{"title":"【GLSL】三、在OpenGL中向shader传递信息","date":"2019-05-23T10:19:03.923Z","path":"2019/05/23/GLSL/(3)、在OpenGL中向shader传递信息/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580946.html 引言一个 OpenGL 程序可以用多种方式和 shader 通信。注意这种通信是单向的，因为 shader 的输出只能是渲染到某些目标，比如颜色和深度缓存。 OpenGL 的部分状态可以被 shader 访问，因此程序改变 OpenGL 某些状态就可以与 shader 进行通信了。例如一个程序想把光的颜色传给 shader，可以直接调用 OpenGL 接口，就像使用固定功能流水线时做的那样。 不过，使用 OpenGL 状态并不是设置 shader 中使用数据的直观方式。比如一个 shader 需要一个表示时间变化的变量来计算动画，在 OpenGL 状态中就没有现成的变量可用。当然，你可以使用没有用到的”镜面光截止角度(cutoffangle)”这样一个变量表示时间，但显然让人难以接受。 幸运的是 GLSL 允许用户自定义变量，实现 OpenGL 应用程序与 shader 通信。有了这个功能，你就可以命名一个叫做 timeElapsed 的变量表示经过的时间。 上文的讨论涉及到了 GLSL 提供的两种类型修饰符(更多的类型将在后面提到)：· 一致变量 - Uniform· 属性 - Attribute 在 shader 中定义的变量如果用这两种类型修饰符，表示对 shader 来说，它们是只读的。下面将详细讲述怎样使用这些类型的变量。 还有一种将变量送给 shader 的方法：使用纹理。一个纹理不止可以表示一张图片，它还可以表示一个数组。事实上，你完全可以决定如何在 shader 中解释纹理数据，即使它真是一幅图片。 1、数据类型和变量下面是 GLSL 中的基本数据类型：· float· bool· int浮点类型与 C 中类似，布尔类型可以为 true 或 false。这些基本类型可以组成 2、3 或 4 维向量，如下所示：· vec{2,3,4} a vector of 2,3,or 4 floats· bvec{2,3,4} bool vector· ivec{2,3,4} vector of integers GLSL 还包括 2×2、3×3 或 4×4 型矩阵，因为这些矩阵类型在图形处理中很常用：· mat2· mat3· mat4 此外，还有一组用来实现纹理访问的特殊类型，它们被称为采样器(sampler)，在读取纹理值(也称为纹素 texel)时用到。下面就是纹理采样用到的数据类型：· sampler1D – for 1D textures· sampler2D – for 2D textures· sampler3D – for 3D textures· samplerCube – for cube map textures· sampler1DShadow – for shadow maps· sampler2DShadow – for shadow maps 在 GLSL 中，可以像 C 一样声明和访问数组，但是不能在声明时初始化数组。GLSL 还可以定义结构体：struct dirlight{vec3 color;vec3 direction;}; 变量声明一个基本类型变量的方法与 C 类似，你还可以在声明它的同时进行初始bool d = true; // d is trueint c = 2; // c is initialized with 2 float a, b; // two vector (yes, the comments are like in C) 声明其它类型变量也是按照这种方法，但是初始化与 C 语言有区别。GLSL 非常依赖构造函数实现初始化和类型转换。float b = 2; // incorrect, there is no automatic type castingfloat e = (float)2; // incorrect, requires constructors for type casting int a = 2; float c = float(a); // correct. c is 2.0 vec3 f; // declaring f as a vec3 vec3 g = vec3(1.0,2.0,3.0); // declaring and initializing g 在 GLSL 中使用一些变量初始化其它变量是非常灵活的。你只需要给出需要的数据成员即可。请看下面的例子：vec2 a = vec2(1.0, 2.0); vec2 b = vec2(3.0, 4.0); vec4 c = vec4(a, b) // c = vec4(1.0, 2.0, 3.0, 4.0); vec2 g = vec2(1.0, 2.0); float h = 3.0; vec3 j = vec3(g, h); 矩阵的初始化也是类似方法，矩阵包含很多种构造函数，下面的例子给出了一些初始化矩阵的构造函数：mat4 m = mat4(1.0) // initializing the diagonal of the matrix with 1.0 vec2 a = vec2(1.0, 2.0); vec2 b = vec2(3.0, 4.0); mat2 n = mat2(a, b); // matrices are assigned in column major order mat2 k = mat2(1.0, 0.0, 1.0, 0.0); // all elements are specified 下面的例子给出了初始化结构体的方法：struct dirlight // type definition { vec3 color;vec3 direction; }; dirlight d1; dirlight d2 = dirlight(vec3(1.0, 1.0, 0.0), vec3(0.8, 0.8, 0.4)); 在 GLSL 中还有一些实用的选择器(selector)，可以简化我们的操作并让代码更简洁。访问一个向量可以使用如下的方法：vec4 a = vec4(1.0, 2.0, 3.0, 4.0); float posX = a.x; float posY = a[1]; vec2 posXY = a.xy; float depth = a.w 在上面的代码片段中，可以使用 x、y、z、w 来访问向量成员。如果是颜色的话可以使用 r、g、b、a，如果是纹理坐标的话可以使用 s、t、p、q。注意表示纹理坐标通常是使用 s、t、r、q，但 r 已经表示颜色中的红色了，所以纹理坐标中需要使用 p 来代替。 矩阵的选择器可以使用一个或两个参数，比如 m[0] 或者 m[2][3]。第一种情况选择了第一列，第二种情况选择了一个数据成员。 对于结构体来说，可以像在 C 语言中一样访问其成员。所以访问前面定义的结构体，可以使用如下的代码：d1.direction = vec3(1.0, 1.0, 1.0); 2、变量修饰符修饰符给出了变量的特殊含义，GLSL 中有如下修饰符：· const 声明一个编译期常量。· attribute 随不同顶点变化的全局变量，由 OpenGL 应用程序传给顶点 shader。这个修饰符只能用在顶点 shader 中，在 shader 中它是一个只读变量。· uniform 随不同图元变化的全局变量（即不能在 glBegin/glEnd 中设置），由 OpenGL 应用程序传给shader。这个修饰符能用在顶点和片断 shader 中，在 shader 中它是一个只读变量。· varying用于顶点 shader 和片断 shader 间传递的插值数据，在顶点 shader 中可写，在片断 shader中只读。 3、一致变量（Uniform Variables）不同于顶点属性在每个顶点有其自己的值，一个一致变量在一个图元的绘制过程中是不会改变的，所以其值不能在 glBegin/glEnd 中设置。一致变量适合描述在一个图元中、一帧中甚至一个场景中都不变的值。一致变量在顶点 shader 和片断 shader 中都是只读的。 首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得。注意，对某些驱动程序，在获得存储位置前还必须使用程序(调用 glUseProgram)。 获取一个一致变量的存储位置只需要给出其在 shader 中定义的变量名即可：/* @param program - the hanuler to the program @param name - the name of the variable / GLint glGetUniformLocation(GLuint program, const char *name); 返回值就是变量位置，可以用此信息设置变量的值。根据变量的数据类型不同，有一系列函数可以用来设置一致变量。用来设置浮点值的一组函数如下：/** @param location - the previously queried location @param v0,v1,v2,v3 - float values @param count - the number of elements in the array @param v - an array of floats / void glUniform1f(GLint location, GLfloat v0); void glUniform2f(GLint location, GLfloat v0, GLfloat v1); void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); GLint glUniform{1, 2, 3, 4}fv(GLint location, GLsizei count, GLfloat \\v); 对 integer 类型也有一组类似的函数，不过要用 i 替换函数中的 f。对 bool 类型没有专门的函数，但可以使用整数的 0 和 1 来表示真假。一旦你使用了一致变量数组，那么就必须使用向量版本的函数。 对 sampler 变量，使用函数 glUniform1i 和 glUniform1iv。 矩阵也是一种 GLSL 的数据类型，所以也有一组针对矩阵的函数：/** @param location - the previously queried location @param count - the number of matrices. 1 if a single matrix is being set, or n for an array of n matrices. @param transpose - wheter to transpose the matrix values. A value of 1 indicates that the matrix values are specified in row major order, zero is column major order @param v – an array of floats. /GLint glUniformMatrix{2,3,4}fv(GLint location, GLsizei count, GLboolean transpose, GLfloat v); 还有一点要注意的是：使用这些函数之后，变量的值将保持到程序再次连接之时。一旦进行重新连接，所有变量的值将被重置为 0。 最后是一些示例代码。假设一个 shader 中使用了如下变量： uniform float specIntensity; uniform vec4 specColor; uniform float t[2]; uniform vec4 colors[3]; 在 OpenGL 程序中可以使用下面的代码设置这些变量： GLint loc1, loc2, loc3, loc4; float specIntensity = 0.98; float sc[4] = {0.8, 0.8, 0.8, 1.0}; float threshold[2] = {0.5, 0.25}; float colors[12] = { 0.4, 0.4, 0.8, 1.0, 0.2, 0.2, 0.4, 1.0, 0.1, 0.1, 0.1, 1.0 }; loc1 = glGetUniformLocation( p, “specIntensity” ); glUniform1f(loc1, specIntensity); loc2 = glGetUniformLocation( p, “specColor” ); glUniform4fv(loc2, 1, sc); loc3 = glGetUniformLocation(p, “t”); glUniform1fv(loc3, 2, threshold); loc4 = glGetUniformLocation(p, “colors”); glUniform4fv(loc4, 3, colors); 例子代码的下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl2_2.0.zip 注意：设置一个数组(例子中的 t)与设置四元向量(例子中的 colors 和 specColor)的区别。中间的count 参数指在 shader 中声明的数组元素数量，而不是在 OpenGL 程序中声明的。所以虽然specColor 包含 4 个值，但 glUniform4fv 函数中的参数是 1，因为它只是一个向量。 另一种设置 specColor 的方法： loc2 = glGetUniformLocation(p, “specColor”); glUniform4f(loc2, sc[0], sc[1], sc[2], sc[3]); GLSL 中还可以获取数组中某个变量的地址。比如，可以获得 t[1] 的地址。下面的代码片段展示了设置 t 数组元素的另一种方法： loct0 = glGetUniformLocation(p, “t[0]“); glUniform1f(loct0, threshold[0]); loct1 = glGetUniformLocation(p, “t[1]“); glUniform1f(loct1, threshold[1]); 注意在 glGetUniformLocation 中使用方括号指示的变量。4、属性变量（Attribute Variables）在前一节提到，一致变量只能针对一个图元全体，就是说不能在 glBegin 和 glEnd 之间改变。 如果要针对每个顶点设置变量，那就需要属性变量了。事实上属性变量可以在任何时刻更新。在顶点 shader 中属性变量是只读的。因为它包含的是顶点数据，所以在片断 shader 中不能直接应用。 与一致变量相似，首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得。注意，对某些驱动程序，在获得存储位置前还必须使用程序。 /** @param program – the handle to the program @param name – the name of the variable */ GLint glGetAttribLocation(GLuint program, char *name); 上述函数调用的返回变量在存储器中的地址。下面就可以为它指定一个值，类似一致变量，每种数据类型都有对应的函数。 /** @param location – the previously queried location. @param v0, v1, v2, v3 – float values. @param v – an array of floats. */ void glVertexAttrib1f(GLint location, GLfloat v0); void glVertexAttrib2f(GLint location, GLfloat v0, GLfloat v1); void glVertexAttrib3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); void glVertexAttrib4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); 或者 GLint glVertexAttrib{1, 2, 3, 4}fv(GLint location, GLfloat *v); 对于 integer 类型，也有一组类似的函数。与一致变量不同，这里向量版的函数并不支持对向量数组的赋值，所以函数参数用向量或是分别指定的效果没有太大区别，就好像 OpenGL 中 glColor3f 和 glColor3fv 的关系。下面是一个简单的例子，假定顶点 shader 中声明了一个名为 height 的浮点属性变量，在程序连接之后可以进行如下操作： loc = glGetAttribLocation(p, “height”); 在执行渲染的代码中间可以为 shader 中的变量赋值： glBegin(GL_TRIANGLE_STRIP); glVertexAttrib1f(loc, 2.0); glVertex2f(-1, 1); glVertexAttrib1f(loc, 2.0); glVertex2f( 1, 1); glVertexAttrib1f(loc, -2.0); glVertex2f(-1, -1); glVertexAttrib1f(loc, -2.0); glVertex2f( 1, -1); glEnd(); 例子代码的下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl3_2.0.zip、 顶点数组和属性变量也可以一起使用。首先需要使能数组，使用如下函数： /** @param loc - the location of the variable. */ void glEnableVertexAttribArray(GLint loc); 接下来使用函数提交包含数据的数组指针： /** @param loc – the location of the variable @param size – the number of components per element, for instance: 1 for float; 2 for vec2; 3 for vec3, and so on @param type – The data type associated: GL_FLOAT is an example @param normalized – if set to 1 then the array values will be normalized, converted to a range from -1 to 1 for signed data, or 0 to 1 for unsigned data @param stride – the spacing between elements. Exactly the same as in OpenGL @param pointer – pointer to the array containing the data */ void glVertexAttribPointer(GLint loc, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer); 下面是示例代码，首先执行初始化，定义了顶点数组和属性数组。 float vertices[8] = { -1, 1, 1, 1, -1, -1, 1, -1 }; float heights[4] = { 2, 2, -2, -2 }; … loc = glGetAttribLocation(p, “height”); glEnableClientState(GL_VERTEX_ARRAY); glEnableVertexAttribArray(loc); glVertexPointer(2, GL_FLOAT, 0, vertices); glVertexAttribPointer(loc, 1, GL_FLOAT, 0, 0, heights); 接下来的渲染步骤与 OpenGL 中的通常做法一致，比如调用 glDrawArrays。示例源代码下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl4_2.0.zip 5、易变变量（Varying Variables）前 面说过，shader 包括两种类型：顶点 shader 和片断 shader。为了计算片断的值，往往需要访问顶点的插值数据。例如，当使用逐片断光照时，我 们需要知道当前片断的法线，但是在 OpenGL 中只为每个顶点指定了法线。顶点 shader 可以访问这些法线，而片断 shader 不能，因为法线是 OpenGL 程序作为属性变量指定的。 顶点变换后的数据移动到流水线的下一个阶段，在这个阶段通过使用连接信息，生成了所有图元并完成片断化。对每个片断，有一组变量会被自动进行插值并提供给片断 shader，这些都是固定功能。片断的颜色就是这么处理的，到达片断 shader 的颜色就是组成图元的顶点颜色插值的结果。 像片断 shader 接收到的这种插值产生的变量，就是”易变变量”类型。GLSL 包含一些预先定义的易变变量，例如前面提到的颜色。用户也可以自己定义易变变量，它们必须同时在顶点 shader 和片断 shader中声明： varying float intensity; 一个易变变量必须先在顶点 shader 中声明，然后计算每个顶点的变量值。在片断 shader 中，接收这个变量通过插值得到的结果，注意此时这个变量是只读的。 6、语句和函数①、控制流语句 与 C 语言类似，GLSL 中有类似 if-else 的条件语句，for、while、do-while等循环语句。 if (bool expression) … else … for (initialization; bool expression; loop expression) … while (bool expression) … do … while (bool expression) GLSL 也有跳转语句：· continue – available in loops, causes a jump to thenext iteration of the loop· break – available in loops, causes an exit of theloop· discard最后的 discard 关键字只能在片断 shader 中使用，它将在不写入帧缓存或者深度缓存的情况下，终止当前片断的 shader 程序。 ②、函数 与 C 语言类似，shader 也是由函数组成的结构化程序。至少每类 shader 都必须包含一个如下方式声明的主函数： void main() 此外用户还可以自定义函数。这些函数像 C 函数一样，一般都会有返回值，返回值的类型没有限制，但不能是数组。 函数参数可以有如下修饰符：· in – for input parameters· out – for outputs of the function. The returnstatement is also an option for sending the result of a function.· inout – for parameters that are both input andoutput of a function 如果没有指定修饰符，默认情况下为 in 类型。 最后还有两点要注意：· 允许函数重载，只要参数不同。· 在标准中没有定义递归行为。 结束本节之前来看一个函数的例子： vec4 toonify(in float intensity) { vec4 color; if (intensity &gt; 0.98) color = vec4(0.8, 0.8, 0.8, 1.0); else if (intensity &gt; 0.5) color = vec4(0.4, 0.4, 0.8, 1.0); else if (intensity &gt; 0.25) color = vec4(0.2, 0.2, 0.4, 1.0); else color = vec4(0.1, 0.1, 0.1, 1.0); return(color); }","tags":[]},{"title":"iOS 内存管理：从 MRC 到 ARC 实践","date":"2019-05-23T09:43:10.193Z","path":"2019/05/23/iOS/iOS原理/iOS 内存管理：从 MRC 到 ARC 实践/","text":"对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。 iOS 内存管理的核心是引用计数。 接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？ 同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？ 12NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding]; 属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。 12self.name = @\"qqstock\"; _name = @\"qqstock\"; 一、MRC 的初衷和实现方式苹果为什么要做这个？ 首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。 当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。 尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了。要么，自己写许许多多的代码，频繁对容器进行主动操作。 于是，苹果要解决这个问题。初衷就是：任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责。 苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。 与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。 另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。” 那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。 OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。 二、MRC 的优点和无奈总结： MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题 为了应对各种复杂的场景，很无奈的留了一个口子； 两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。 难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。 略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。 系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！ 引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。 再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。 三、编程语言和编译器的发展方向由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。 然而，编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？ 许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？ 更何况，人，总有打盹的时候。 四、ARC 的适时推出随着硬件的升级，条件已经成熟了，ARC 到来了！ ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。 之前对 C++ 程序员头疼的问题变得异常简单： 1234NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding];self.name = @\"qqstock\";_name = @\"qqstock\"; 到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。 许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。 逻辑其实很简单。 首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低； 其次，一旦出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。 总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！ 五、总结如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。 许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。 ①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。 ②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。 ③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。 ④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。","tags":[]},{"title":"ARC","date":"2019-05-23T08:17:05.311Z","path":"2019/05/23/iOS/iOS原理/ARC/","text":"一、ARCARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果修改了一些内存管理代码的书写方式，干脆编译器在编译时把内存管理的代码都自动补上。 ARC 是编译器特性，而不是运行时特性，更不是垃圾回收器（GC）。 Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. 程序在编译的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，编译器帮我们在合适的地方插入retain、release 等代码以管理对象的引用计数，从而达到自动管理对象生命周期的目的。 所以 ARC 是工作在编译期的一种技术方案，这样的好处： 编译之后，ARC 与 MRC 代码是没有什么差别的，所以二者可以在源码中共存。 相对于垃圾回收这类内存管理方案，ARC 不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。相反的，由于ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。 只有编译器是无法单独完成这一工作的，还需要 OC 运行时库的配合协助，因此 ARC 的实现工具主要包括： LLVM 编译器（clang 3.0 以上） OC 运行时库 493.9 以上 weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。 ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外 10% 的内存管理问题是需要开发者处理的，这主要是与底层 Core Foundation 对象交互的部分，底层 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。 二、ARC 的开启和关闭在 Targets -》Build Settings 中搜索 Automatic Reference Counting，可以修改它的布尔值，yes - 开启 no - 关闭。 如果需要对特定文件开启或关闭 ARC，可以在 Targets -》Build Phases -》Compile Sources，在里面找到对应文件，添加flag： 开启：-fobjc-arc 关闭：-fno-objc-arc 三、ARC 的修饰符主要提供了 4 种修饰符，他们分别是：__strong、__weak、__autoreleasing、__unsafe_unretained。 3.1 __strong强引用。相当于 @property 的 “strong”。所有对象只有当没有任何一个强引用指向（引用计数为 0）时，才会被释放。 注意：如果在声明引用时不加修饰符，那么将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置 nil。 使用 __strong 修饰变量的程序运行过程。 123&#123; id __strong object = [[NSObject alloc] init];&#125; 转换后的模拟源代码为： 1234/*编译器的模拟代码*/id object = objc_msgSend(NSObjct, @selector(alloc));objc_msgSend(object, @selector(init));objc_release(object); 对象变量生成时，分别调用 alloc 和 init 方法，对象变量作用域结束时调用 objc_release 方法释放对象变量，虽然 ARC 情况下不能使用 release 方法，但是由此可见编译器编译时在合适的地方插入了 release。 在使用 alloc、new、copy、mutableCopy 以外的方法生成对象变量方法时会有什么不同 123&#123; id __strong object = [NSMutableArray array];&#125; 调用 array 的类方法转换后： 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); objc_release(object);&#125; objc_retainAutoreleasedReturnValue(object) 函数的作用：最优化程序运行。 自己持有（retain）对象的函数，但它持有的应为返回注册在 autoreleasepool 中对象的方法或函数的返回值。 objc_retainAutoreleasedReturnValue 函数与 objc_autoreleasedReturnValue 是成对出现的，现在看看 NSMutableArray 类的 array 类方法的编译器实现。 123+ (id)array &#123; return [[NSMutableArray alloc] init];&#125; 转换后的源代码。 1234567+ (id)array&#123; /*编译器的模拟代码*/ id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 通过 objc_autoreleaseReturnValue 函数将对象注册在自动释放池 autoreleasepool 中并返回，但是与 objc_autorelease 函数不同的是，objc_autoreleaseReturnValue 函数一般不仅限于注册对象到 autoreleasepool 中去。 objc_autoreleaseReturnValue 与 objc_retainAutoreleasedReturnValue 的配合使用，可以不将对象注册到autoreleasepool 中而直接传递，达到最优化。 objc_autoreleaseReturnValue 函数会检查使用该函数的方法或者函数的调用方的执行命令列表，如果调用方在调用该函数或方法之后，紧接着调用了 objc_retainAutoreleasedReturnValue 函数，那么不再将对象注册到 autoreleasepool 中去，而直接将对象传递给调用方。 相比于 objc_retain 函数来说 objc_retainAutoreleasedReturnValue 函数在返回一个即使没有注册到 autoreleasepool 中的对象，也能正确的获取对象。 3.2 __weak弱引用。相当于 @property 的 “weak”。弱引用不会影响对象的引用计数，即只要对象没有任何强引用指向，即使有 n 个弱引用对象指向也没用，该对象依然会被释放。 对象在被释放的同时，指向它的弱引用（weak）会自动被置 nil，这个技术叫 zeroing weak pointer。这样有效的防止无效指针、野指针的产生。__weak 一般用在 delegate 关系中防止循环引用或者用来修饰指向由 Interface Builder 编辑与生成的 UI 控件。 123&#123; id _weak object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id object; id tmp = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(tmp, @selector(init)); objc_initWeak(&amp;object, tmp); objc_release(tmp); objc_destoryWeak(&amp;object);&#125; 自己生成并且持有的对象通过 objc_initWeak 函数赋值给 __weak 修饰符的变量，但是编译器判断并没有对其进行持有，因此该对象通过 objc_release 函数被释放和废弃。 随后通过 objc_destoryWeak 将引用废弃对象的附有 __weak 修饰符的变量置为 nil。 如果不是直接赋值，而是通过使用 __weak 修饰符来引用变量时。 1234&#123; id __weak object = obj; NSLog(@\"%@\", object);&#125; 转换后的模拟源代码。 123456789/*编译器的模拟代码*/&#123; id object; objc_initWeak(&amp;object, obj); id temp = objc_loadWeakRetained(&amp;object); objc_autorelease(temp); NSLog(@\"%@\", temp); objc_destoryWeak(&amp;object);&#125; 明显增加了 objc_loadWeakRetained 与 objc_autorelease 函数调用，他们的主要作用是： objc_loadWeakRetained 函数取出 __weak 修饰符变量引用的对象并且 retain objc_autorelease 函数将引用的对象注册到 autoreleasepool 中。 因此，使用 __weak 修饰符引用的对象都被注册到 autoreleasepool 中，在 @autoreleasepool 块结束之前都可以放心使用，大量使用 __weak 修饰符的变量，导致注册到 autoreleasepool 中的对象也大量地增加。所以在使用 __weak 修饰符引用的变量时，最好先暂时用 __strong 修饰符的变量进行引用后再使用。 2 种不能使用 __weak 修饰符的情况： 重写了 retain/release 的类，例如 NSMachPort 类； 当 allowsWeakReference/retainWeakReference 实例方法返回 NO 时。 3.3 __autoreleasing对象被加入到 autorelease pool，是会自动释放的引用，与 MRC 中 autorelease 的用法相同。定义 @property 时不能使用这个修饰符。 对于 alloc、new、copy、mutableCopy 的实现。 123@autoreleasepool&#123; id __autoreleasing object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSObjct, @selector(alloc)); objc_msgSend(object, @selector(init)); // 调用autorelease方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; NSMutableArray 类中的 array 方法如何实现 autorelease 功能。 123@autoreleasepool&#123; id __autoreleasing object = [NSMutableArray array];&#125; 转化后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); // 调用 autorelease 方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; 除了持有对象的方法从 alloc 变成了 objc_retainAutoreleasedReturnValue 函数，但是注册到 autoreleasepool 的方法没有变化，都是调用了 objc_autorelease 函数。 一个常见的误解是，在 ARC 中没有 autorelease，因为这样一个“自动释放”看起来好像有点多余。 这个误解可能源自于将 ARC 的“自动” 和 autorelease “自动” 的混淆。其实你只要看一下每个 iOS App 的 main.m 文件就能知道，autorelease 不仅好好的存在着，并且不需要再手工被创建，也不需要再显式得调用 [pool drain] 方法释放内存池。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 以下两行代码的意义是相同的。 12NSString * str = [[[NSString alloc] initWithFormat:@\"China\"] autorelease]; // MRCNSString * __autoreleasing str = [[NSString alloc] initWithFormat:@\"China\"]; // ARC __autoreleasing 在 ARC 中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。 __autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 比如常见的 NSError 的使用： 123456NSError * __autoreleasing error; // writeToFile方法中 error 参数的类型为 (NSError *__autoreleasing *)）￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123; NSLog(@\"Error: %@\", error.localizedDescription); &#125; 注意：如果 error 的修饰符为 strong，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个 __autoreleasing 类型的引用。 12345678NSError * error; NSError * __autoreleasing tempError = error; // 编译器添加 if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) ￼&#123; error = tempError; // 编译器添加 NSLog(@\"Error: %@\", error.localizedDescription); &#125; 为了避免这种情况，提高效率，一般在定义 error 的时候将其声明为__autoreleasing 类型的： 1NSError *__autoreleasing error; 加上 __autoreleasing 之后，相当于在 MRC 中对返回值 error 做了如下事情： 1*error = [[[NSError alloc] init] autorelease]; *error 指向的对象在创建出来后，被放入到了 autoreleasing pool 中，等待使用结束后的自动释放，函数外 error 的使用者并不需要关心 *error 指向对象的释放。 另外，在 ARC 中，所有这种指针的指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 __autoreleasing 类型。 比如下面的两段代码是等同的： 12345678- (NSString *)doSomething:(NSNumber **)value&#123; // do something &#125;- (NSString *)doSomething:(NSNumber * __autoreleasing *)value&#123; // do something &#125; 除非显式得给 value 声明了 __strong，否则 value 默认就是 __autoreleasing 的。 最后一点，某些类的方法会隐式地使用自己的 autorelease pool，在这种时候使用 __autoreleasing 类型要特别小心。 比如 NSDictionary 的 - enumerateKeysAndObjectsUsingBlock: 方法会隐式地创建一个 autorelease pool. 123456789- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; // do stuff if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; &#125;];￼&#125; 上面代码实际类似于： 123456789101112- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; @autoreleasepool // 被隐式创建 &#123; if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125;￼ &#125; &#125;]; // *error 在这里已经被dict的做枚举遍历时创建的 autorelease pool 释放掉了 ￼&#125; 为了能够正常的使用 *error，我们需要一个 strong 型的临时引用，在 dict 的枚举 block 中使用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 block 后被释放，正确的方式如下： 123456789101112131415- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; __block NSError * tempError; // 加 __block 保证可以在 Block 内被修改 [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (...) &#123; *tempError = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; ￼ &#125;] if (error != nil) &#123; *error = tempError; &#125; ￼&#125; 3.4 __unsafe_unretainedARC 是在 iOS 5 引入的，而这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些低版本的设备没有 weak pointer system，这个系统简单的理解就是上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil。 相当于 @property 的 “unsafe_unretained”，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然指向原来被释放的对象（所在的内存区域）。所以非常不安全。 现在可以完全忽略掉这个修饰符了，因为 iOS 4 早已退出历史舞台很多年。 123&#123; id __unsafe_unretained object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(object, @selector(init)); objc_release(tmp);&#125; 可见通过 __unsafe_unretained 修饰的变量引用了对象但是并不持有对象，对象在释放和废弃后，并没有调用被 __unsafe_unretained 修饰的变量的 objc_destoryWeak 函数，因此该对象的悬垂指针被赋值给变量 object，导致引用变量 object 时发生崩溃。 3.5 正确使用修饰符苹果的文档中明确地写道： You should decorate variables correctly. When using qualifiers in an object variable declaration,the correct format is: ClassName * qualifier variableName; 按照这个说明，要定义一个 weak 修饰的 NSString 引用，它的写法应该是： 1NSString * __weak str = @\"Hello\"; // 正确 而不应该是： 1__weak NSString *str = @\"Hello\"; // 错误 那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道： Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see http://cdecl.org/. 看来是苹果考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符。 3.6 栈中指针默认值为 nil无论是被 strong、weak 还是 autoreleasing 修饰，声明在栈中的指针默认值都会是 nil。所有这类型的指针不用再初始化的时候置 nil 了。这个特性更加降低了“野指针”出现的可能性。 在 ARC 中，以下代码会输出 null 而不是 crash。 12345- (void)myMethod &#123; NSString * name; NSLog(@\"%@\", name);&#125; 四、ARC 与 Block在手动管理内存时代，block 会隐式地对进入其作用域内的对象（或者说被 block 捕获的指针指向的对象）执行 retain 操作，来确保 block 使用到该对象时，能够正确的访问。 123456789101112131415161718192021222324252627MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; // 隐式地调用 [myController retain]; 造成循环引用 [myController dismissViewControllerAnimated:YES completion:nil];&#125;;[self presentViewController:myController animated:YES completion:^&#123; // 调用[myController release];是在 MRC 中的一个常规写法，并不能解决上面循环引用的问题 [myController release]; &#125;];@interface SecondVC : UIViewController@property (nonatomic, copy) void (^ block)(void);@end&#123; SecondVC * vc = [[SecondVC alloc] init]; NSLog(@\"%lu\", (unsigned long)vc.retainCount); vc.block = ^ &#123; NSLog(@\"%lu\", (unsigned long)vc.retainCount); &#125;; vc.block();&#125;2018-11-16 10:26:05.872092+0800 Demo[49289:1083433] 12018-11-16 10:26:05.872214+0800 Demo[49289:1083433] 2 dismissBlock 调用了 [myController dismiss..] 方法，这时 dismissBlock 会对 myController 执行 retain 操作。 而作为 myController 的属性，myController 对 dismissBlock 也至少有一个 retain（一般准确讲是 copy），这时就出现了在内存管理中最糟糕的情况：循环引用。也就是说：相互持有对方。循环引用导致了 myController 和 dismissBlock 最终都不能被释放。 对 delegate 指针用 weak 就是为了避免这种问题。 不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题： 我们一般用如下方法解决：给进入 block 的指针加一个 __block 修饰符。 这个 __block 在 MRC 时代有两个作用： 说明变量可改 说明指针指向的对象不做隐式的 retain 操作 除了静态变量和全局变量不需要加 __block 就可以在 block 中修改外，其他变量不加则不能在 block 中修改。 对代码做出修改，解决了循环引用的问题： 12345MyViewController * __block myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;; // 之后正常的 release 或者 retain 在 ARC 环境下，没有了 retain 和 release 等操作，情况也发生了改变： 在任何情况下，__block 修饰符的作用只有上面的第一条：说明变量可改。即使加上了 __block 修饰符，一个被 block 捕获的强引用也依然是一个强引用。 所以在 ARC 下，如果还按照 MRC 下的写法，添加 __block 是没有解决循环引用的问题。 代码修改如下： 12345__block MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; // 注意这里，保证了 block 结束对 myController 强引用的解除&#125;; 在 block 中将捕获的指针置为 nil，保证了 dismissBlock 对 myController 强引用的解除，不过也同时解除了myController 指针对 myController 对象的强引用。 更好的方法就是使用 weak。（或者为了考虑 iOS4 的兼容性用 unsafe_unretained，具体用法和 weak 相同） 为了保证 dismissBlock 对 myController 没有强引用，我们可以定义一个临时的弱引用 weakMyViewController 来指向原myController 的对象，并把这个弱引用传入到 dismissBlock 内，这样就保证了 dismissBlock 对 myController 持有的是一个弱引用，而不是一个强引用。如此，继续修改代码如下： 1234MyViewController * __weak weakMyViewController = myController;myController.dismissBlock = ^(NSString * result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 这样循环引用的问题就解决了，但是却引入了一个新的问题：由于传入 dismissBlock 的是一个弱引用，那么当 myController指向的对象在 dismissBlock 被调用前释放，那么 dismissBlock 就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。 为了保证在 dismissBlock 内能够访问到正确的 myController，我们在 dismissBlock 内新定义一个强引用strongMyController 来指向 weakMyController 指向的对象，这样多了一个强引用，就能保证这个 myController 对象不会在 dismissBlock 被调用前释放掉了。于是，对代码再次做出修改： 1234567891011MyViewController * __weak weakMyController = myController;// __weak typeof(myController) weakMyController = myController;myController.dismissBlock = ^(NSString * result) &#123; MyViewController * strongMyController = weakMyController; // __strong typeof(weakMyController) strongMyController = weakMyController; if (strongMyController) &#123; [strongMyController dismissViewControllerAnimated:YES completion:nil]; &#125; else &#123; &#125;&#125;; 很多读者会有疑问，不是不希望 block 对原 myController 对象增加强引用么，这里为什么堂而皇之地在 block 内新定义了一个强引用，这个强引用不会造成循环引用么？ 理解这个问题的关键在于被 block 捕获的引用和在 block 内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block 的实现原理，详细的内容可以参考其他的文章：谈Objective-C block的实现、block 实现、正确使用Block避免Cycle Retain和Crash。 为了更清楚地说明问题，这里用一个简单的程序举例。如下程序： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int b = 10; int *a = &amp;b; void (^ block)() = ^() &#123; int *c = a; &#125;; block(); return 1;&#125; 程序中，同为 int 型的指针，a 变量被 block 捕获，而 c 变量是在 block 内定义的。用 clang -rewrite-objc 命令处理后，可以看到如下代码。 原 main 函数： 12345678910int main()&#123; int b = 10; int *a = &amp;b; void (*block)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 1;&#125; block 的结构： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *a; // 被捕获的引用 a 出现在了 block 的结构体里面 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 实际执行的函数： 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *a = __cself-&gt;a; // bound by copy int *c = a; // 在 block 中声明的引用 c 在函数中声明，存在于函数栈上&#125; 可以清楚的看到，a 和 c 存在的位置完全不同，如果 block 存在于堆上（在 ARC 下 block 默认在堆上），那么 a 作为 block 结构体的一个成员，也自然会存在于堆上，而 c 无论如何，永远位于 block 内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c 在 block 的函数运行完毕，即会被释放，而 a 只有在 block 被从堆上释放的时候才会释放。 回到之前的示例，如果直接让 dismissBlock 捕获 myController 引用，那么这个引用会被复制后作为 dismissBlock 的成员变量存在于其所在的堆空间中，也就是为 dismissBlock 增加了一个指向 myController 对象的强引用，这就是造成循环引用的本质原因。 对于 MyViewController 的例子，dismissBlock 的结构体大概是这个样子： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __strong myController; // 被捕获的强引用 myController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而给 dismissBlock 传入一个弱引用 weakMyController，这时 dismissBlock 的结构： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __weak weakMyController; // 被捕获的弱引用 weakMyController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 在 dismissBlock 内声明的强引用 strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，一直持有 myController 对象，但当函数执行完毕，strongMyController 即被销毁，于是它对 myController 对象的强引用被解除，这时 dismissBlock 对 myController 对象就不存在强引用关系了！ 加入了 strongMyController 的函数大体会是这个样子： 123static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; MyViewController * __strong strongMyController = __cself-&gt;weakMyController;&#125; 在 ARC 中，block 捕获的引用和 block 内声明的引用，存储空间与生命周期都是不同的。 实际上，在自动引用计数环境下，对 block 捕获对象的内存管理已经简化了很多，由于没有了 retain 和 release 等操作，实际只需要考虑循环引用的问题就行了。 五、ARC 与 Toll-Free Bridging There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的示例： 12345678910NSLocale * gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_GB\"];CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);NSLog(@\"cfIdentifier: %@\", (NSString *)cfIdentifier); // logs: \"cfIdentifier: en_GB\"CFRelease((CFLocaleRef) gbNSLocale);CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale * myNSLocale = (NSLocale *) myCFLocale;[myNSLocale autorelease];NSString * nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef) [@\"nsIdentifier: \" stringByAppendingString:nsIdentifier]); // logs identifier for current locale 在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 retain 和 release 操作规则，所以Toll-Free Bridging 的使用比较简单，但是自从 ARC 加入后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。 这个时候就必须要考虑一个问题，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership 的改变。 If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined in NSObject.h) 于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。 5.1 __bridge 只是声明类型转变，但是不做内存管理规则的转变。 示例： 1CFStringRef s = (__bridge CFStringRef)[[NSString alloc] initWithFormat:@\"Hi, %@!\", name]; 只是 NSString 到 CFStringRef 的类型转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s，不能用CFRelease() 去释放 s。 5.2 __bridge_retained、CFBridgingRetain() 将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给 Core Foundation 来处理，也就是，将 ARC 转变为 MRC。 示例： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (__bridge_retained CFStringRef)s1;...￼CFRelease(s2); // 注意在使用结束后释放 在第二行做了转化，这时内存管理规则由 ARC 变成了 MRC，需要手动的来管理 s2 的内存，而对于 s1，即使将其置为 nil，也不能释放内存。 也可以写成： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);...￼CFRelease(s2); // 注意在使用结束后释放 5.3 __bridge_transfer、CFBridgingRelease() 功能与 __bridge_retained 相反，表示将管理的责任由 Core Foundation 转交给 Objective-C，即将管理方式由MRC 转变为 ARC。 比如： 1234CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);￼NSString * s = (__bridge_transfer NSString *)result; // 或 NSString * s = (NSString *)CFBridgingRelease(result);￼return s; 这里将 result 的管理责任交给了 ARC 来处理，就不需要再显式地调用 CFRelease() 了。 这里和 ARC 中 4 个主要的修饰符 __strong、__weak、__autoreleasing… 不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但最好与官方的相同。 六、ARC下获取引用计数6.1 使用 KVC1[obj valueForKey:@\"retainCount\"]; 6.2 使用私有 API123OBJC_EXTERN int _objc_rootRetainCount(id);_objc_rootRetainCount(obj); 这个不一定完全可信。Xcode 10.1 用的示例一直返回 1。 6.3 使用 CFGetRetainCount1CFGetRetainCount((__bridge CFTypeRef)(obj)) 使用 Toll-Free-Bridging 将 OC 对象的内容管理转为 Core Foundation 对象。 七、学习文章iOS 开发ARC内存管理技术要点谈 Objective-C block的实现block 的实现正确使用 Block 避免Cycle Retain和CrashARC 的实现原理","tags":[]},{"title":"引用计数","date":"2019-05-23T07:16:48.623Z","path":"2019/05/23/iOS/iOS原理/iOS 引用计数/","text":"一、简介 OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。 OC 在内存管理上采用了引用计数，它是一个简单而有效管理对象生命周期的方式。在对象内部保存一个用来表示被引用次数的数字，init、new 和 copy 都会让计数 +1，调用 release 让计数 -1。当计数等于 0 的时候，系统调用 dealloc 方法来销毁对象。 123A * a = [[A alloc] init]; // retain count = 1A * b = a; // 指针赋值时，retain count 不会自动增加[b retain]; // retain count = 2 12345678910111213141516171819&#123; OBJC_EXTERN int _objc_rootRetainCount(id); NSObject * obj = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj)); NSObject * obj1 = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj1 retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj1)); // obj 指向了 obj1 所指的对象 B，失去了对原来对象A的引用,所以对象A的引用计数-1，为 0。A 被销毁 // 对于 B，obj 引用了它，所以引用计数 +1，为 2 obj = obj1; // self.obj 又引用了 A,所以引用计数 +1，为 3 self.obj = obj; NSLog(@\"strong obj1 retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj1)); NSLog(@\"strong obj retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj));&#125; 引用计数分为自动引用计数「ARC : Automatic Reference Counting」和手动引用计数「MRC : Manual Reference Counting」。 二、原理 三、示例1234567891011121314151617NSObject * obj1 = [NSObject new];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);NSObject * obj2 = [obj1 retain];NSObject * obj3 = [obj1 retain];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);引用计数：1引用计数：3引用计数：2 &lt;NSObject：0x60400001ecd0&gt;引用计数：1 &lt;NSObject：0x60400001ecd0&gt;*** -[NSObject retainCount]: message sent to deallocated instance 0x60400001ecd0 根据 Debug 输出可以看到：obj1 可以调用多次 release 方法。 从两次打印 obj1 的地址相同可以猜测，在 [obj1 release] 执行之后对象的引用计数 -1，不再强引用对象，但 obj1 仍然指向对象所在的那片内存空间。在第三次执行 release 后，对象的引用计数为 0，对象所在的内存空间被销毁，但是 obj1 指针仍然存在，此时调用 retainCount 会报野指针错误。可以通过置 obj1 = nil 解决这个问题。 对 Linux 文件系统比较了解的可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于 retain），当删除一个文件时（相当于 release），系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 四、僵尸对象、野指针、空指针僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用。 野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC_BAD_ACCESS）。 空指针：没有指向任何对象的指针（存储的是 nil、NULL），给空指针发送消息不会报错；空指针的一个经典使用场景就是在开发中获取服务器 API 数据时，转换野指针为空指针，避免发送消息报错。 五、为什么需要引用计数？引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。 举个例子： 对象 A 生成了一个对象 O，需要调用对象 B 的某个方法，并将对象 O 作为参数传递过去。 1[objB doSomething:O]; 在没有引用计数的情况下，一般内存管理的原则是「谁申请谁释放」。 那么对象 A 就需要在对象 B 不再需要 O 的时候，将 O 销毁。但对象 B 可能临时用一下 O，也可能将它设置为自己的一个成员变量，在这种情况下，什么时候销毁就成了一个难题了。 对于以上情况有两种做法： 对象 A 在调用完对象 B 的某个方法之后，马上销毁参数 O；然后对象 B 需要将对象 O 复制一份，生成另一个对象 O2，同时自己来管理对象 O2 的生命周期。 这种做法带来更多的内存申请、复制、释放的工作。本来可以复用的对象，因为不方便管理它的生命周期，就简单地把它销毁，又重新构造一份一样的，实在太影响性能。 对象 A 只负责生成 O，之后就由对象 B 负责完成 O 的销毁工作。如果对象 B 只是临时用一下 O，就可以用完后马上销毁；如果对象 B 需要长时间使用 O，就不销毁它。 这种做法看似解决了对象复制的问题，但是它强烈依赖于 A 和 B 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于 O 的生成和释放在不同对象中，使得它的内存管理代码分散在不同对象中，管理起来也很费劲。如果这个时候情况更加复杂一些，例如对象 B 需要再向对象 C 传递参数 O，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方法带来的复杂度更高，更加不可取。 引用计数的出现很好地解决这个问题，在参数 O 的传递过程中，哪些对象需要长时间使用它，就把它的引用计数 +1，使用完就-1。所有对象遵守这个规则，对象的生命周期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 六、ARC 下的内存管理问题问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要手工管理它们的引用计数时，显得一筹莫展。 6.1 循环引用引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁又依赖于对象 A 的销毁，这样就造成了循环引用 Reference Cycle 的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 6.2 主动断开循环引用解决循环引用问题主要有两个办法。第一个办法：明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存，所以这种解决方法并不常用，更常见的办法是使用弱引用的办法。 6.3 使用弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。如下所示： 6.4 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： 在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 6.5 检测循环引用 七、学习文章iOS 内存管理iOS 的内存管理","tags":[]},{"title":"深拷贝和浅拷贝","date":"2019-05-22T10:52:52.721Z","path":"2019/05/22/iOS/iOS原理/深拷贝和浅拷贝/","text":"深拷贝和浅拷贝的本质区别是地址是否相同。 浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址； 深拷贝是真正的复制了一份，复制的对象指向了新的地址。 一、非容器类对象对象的 copy 是浅拷贝，mutableCopy 是深拷贝。 1、不可变 12345678910NSString * s1 = @\"AAA\";NSString * s2 = [s1 copy];NSString * s3 = [s1 mutableCopy]; NSLog(@\"%p %@\", s1, s1.class);NSLog(@\"%p %@\", s2, s2.class);NSLog(@\"%p %@\", s3, s3.class);0x1083a40e8 __NSCFConstantString0x1083a40e8 __NSCFConstantString0x60400044f840 __NSCFString 结论： ①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 2、可变 12345678910NSMutableString * ms1 = [NSMutableString stringWithString:@\"1\"];NSMutableString * ms2 = [ms1 copy];NSString * ms3 = [ms1 mutableCopy]; NSLog(@\"%p %@\", ms1, ms1.class);NSLog(@\"%p %@\", ms2, ms2.class);NSLog(@\"%p %@\", ms3, ms3.class);0x6040004500b0 __NSCFString0xa000000000000311 NSTaggedPointerString0x60400044fc60 __NSCFString 结论： ①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝； ②、copy 和 mutableCopy 返回对象都为可变对象。 二、容器对象1、不可变 123456789101112NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSArray * arr1 = [NSArray arrayWithObjects:ms, @\"2\", nil];NSArray * arr2 = [arr1 copy];NSArray * arr3 = [arr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]); 0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025a940 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 ③、容器内的元素始终都是浅拷贝。 2、可变 1234567891011NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:ms, @\"2\", nil];NSMutableArray * mArr2 = [mArr1 copy];NSMutableArray * mArr3 = [mArr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]);0x60000025aeb0 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037640 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025ae80 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；②、copy 返回不可变对象，mutableCopy 返回可变对象；③、容器内的元素始终是浅拷贝。 三、自定义类对象的深浅拷贝自定义的类需要遵循 才支持 copy，遵循 支持 mutableCopy。 12345678910111213141516171819202122@interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@end@implementation Person- (instancetype)copyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone]; // return self;&#125;- (instancetype)mutableCopyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone];&#125;@endPerson * p1 = [[Person alloc] init];Person * p2 = [p1 copy];Person * p3 = [p1 mutableCopy]; NSLog(@\"%p %@\", p1, p1.class);NSLog(@\"%p %@\", p2, p2.class);NSLog(@\"%p %@\", p3, p3.class);0x600000011e30 Person0x600000011f70 Person0x600000011f90 Person 四、实现容器对象的完全拷贝1234567891011NSMutableString * ms = [NSMutableString stringWithFormat:@\"1\"];NSArray * arr = [NSArray arrayWithObjects:ms, @\"2\", nil];NSLog(@\"%p %p\", arr[0], arr[1]);NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];NSLog(@\"%p %p\", mArr[0], mArr[1]);NSData * data = [NSKeyedArchiver archivedDataWithRootObject:mArr];NSMutableArray * newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];NSLog(@\"%p %p\", newMutableArr[0], newMutableArr[1]);0x6040004434b0 0x109c931000xa000000000000311 0x109c931000xa000000000000311 0xa000000000000321 由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。 自定义类对象需要遵循 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。 123456789- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self.xxx = [aDecoder decodeObjectForKey:@\"key\"]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.xxx forKey:@\"key\"];&#125; 五、总结只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。 六、学习文章深刻理解iOS中的“深拷贝”和“浅拷贝”","tags":[]},{"title":"atomic","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/iOS/iOS原理/atomic/","text":"atomic 在 set 方法里加了锁，防止了多线程一直去写这个 property，造成难以预计的数值。 当属性使用 atomic 修饰时，它的读和写是原子性的：当线程 A 进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当 A 线程的写操作结束后，B 线程进行写操作，然后当 A 线程需要读操作时，获得了在 B 线程中修改的值。如果有 C 线程在 A 线程读操作之前 release 了该属性，可能导致程序崩溃。 导致崩溃并不是线程安全问题。所谓线程安全是保证同一时间只有一个线程对该内存进行访问。只要我们使用 getter、setter 方法来访问，上面的表述中的每一个步骤都只有一条线程在访问该内存，哪个线程会获得锁完全取决于代码顺序，这个崩溃就是程序员自身的问题了。如果绕开 getter、setter 方法访问这个属性，才会造成线程不安全，比如使用 KVC。 一、atomic 是绝对安全的在 64 位的操作系统下，所有类型的指针(包括 void *)都是占用 8 个字节的。超过 4 个字节的基本类型数据都会有线程并发的问题。 那所有的指针类型都会有这个问题。 以 Objective-C 的 NSArray * 为例子，如果一个多线程操作这个数据，会有两个层级的并发问题： 指针本身 指针所指向的内存 指针本身也是占用内存的，并且一定是 8 个字节。第二部分，指针所指向的内存，有可能非常大，有可能也就 1 个字节。 所以考虑 NSArray * array 这个数据在进行多线程操作的时候，必须分成两部分来描述，一个是 &amp;array 这个指针本身，另一个则是它所指向的内存 array。想象现在有两块内存，一块是 8 字节，一块 n 字节，8 字节里面放的值，就是 n 字节内存的首地址。 如果用 atomic 修饰之后，会有什么影响？ 从内存的角度来解释这个过程。atomic 其实修饰的是这个指针 &amp;array，与指针指向的第二部分 n 字节数据没有任何关系，被 atomic 修饰之后，你不可能随意去多线程操作这个 8 字节，但是对 8 字节里面所指向的 n 字节没有任何限制！ atomic 已经完美的履行了它的指责，你不可能对这个 8 字节进行无序的多线程操作，这就够了呀！有问题的是程序员，程序员并未对 n 字节做任何的限制。 二、NSMutableArray 本身是线程不安全的简单来说，线程安全就是多个线程访问同一段代码，程序不会异常、不 Crash。而编写线程安全的代码主要依靠线程同步。 不使用 atomic 修饰属性。原因有二： atomic 的内存管理语义是原子性的，仅保证了属性的 setter 和 getter 方法是原子性的、线程安全的，但是属性的其他方法，如数组添加/移除元素等并不是原子操作，所以不能保证属性是线程安全的。 atomic 虽然保证了 getter、setter 方法线程安全，但是付出的代价很大，执行效率要比 nonatomic 慢很多倍(有说法是慢 10-20 倍)。 总之：使用 nonatomic 修饰 NSMutableArray 对象就可以了，而使用锁、dispatch_queue 来保证 NSMutableArray 对象的线程安全。 打造线程安全的 NSMutableArray 在《Effective Objective-C 2.0》书中第 41 条：多用派发队列，少用同步锁中指出：使用“串行同步队列”(serial synchronization queue)，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD 的栅栏块(barrier)来不仅实现数据同步线程安全，还比串行同步队列方式更高效。 说明：栅栏块单独执行，不能与其他块并行。直到当前所有并发块都执行完毕，才会单独执行这个栅栏块 线程安全实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@interface QSThreadSafeMutableArray()@property (nonatomic, strong) NSMutableArray * MDataArray;@property (nonatomic, strong) dispatch_queue_t MSyncQueue;@end@implementation QSThreadSafeMutableArray- (instancetype)initCommon&#123; if (self = [super init]) &#123; // %p 以 16 进制的形式输出内存地址，附加前缀 0x NSString * uuid = [NSString stringWithFormat:@\"com.jzp.array_%p\", self]; // 注意：_MSyncQueue 是并行队列 _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT); &#125; return self;&#125;- (instancetype)init&#123; if (self = [self initCommon]) &#123; _MDataArray = [NSMutableArray array]; &#125; return self;&#125;- (id)objectAtIndex:(NSUInteger)index&#123; __block id obj; dispatch_sync(_MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; obj = _MDataArray[index]; &#125; &#125;); return obj;&#125;- (NSEnumerator *)objectEnumerator&#123; __block NSEnumerator * enu; dispatch_sync( _MSyncQueue, ^&#123; enu = [_MDataArray objectEnumerator]; &#125;); return enu;&#125;- (void)insertObject:(id)anObject atIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray insertObject:anObject atIndex:index]; &#125; &#125;);&#125;- (void)addObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if(anObject)&#123; [_MDataArray addObject:anObject]; &#125; &#125;);&#125;- (void)removeObjectAtIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; [_MDataArray removeObjectAtIndex:index]; &#125; &#125;);&#125;- (void)removeLastObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; [_MDataArray removeLastObject]; &#125;);&#125;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray replaceObjectAtIndex:index withObject:anObject]; &#125; &#125;);&#125;- (NSUInteger)indexOfObject:(id)anObject&#123; __block NSUInteger index = NSNotFound; dispatch_sync( _MSyncQueue, ^&#123; for (int i = 0; i &lt; [_MDataArray count]; i ++) &#123; if ([_MDataArray objectAtIndex:i] == anObject) &#123; index = i; break; &#125; &#125; &#125;); return index;&#125;- (void)dealloc&#123; if (_MSyncQueue) &#123; _MSyncQueue = NULL; &#125;&#125;@end 说明 ①：使用 dispatch queue 实现线程同步；将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，又不会阻塞执行异步派发的线程；使用同步队列及栅栏块，可以令同步行为更加高效。 说明 ②：NSMutableDictionary 本身也是线程不安全的，实现线程安全的 NSMutableDictionary 原理同线程安全的NSMutableArray。(代码见 [QSUseCollectionDemo](https://github.com/buaa0300/QSKitDemo/tree/master/QSUseCollectionDemo)) 线程安全的 NSMutableArray 使用 123456789101112131415161718192021- (void)testQsMutableArray&#123; _MSafeArray = [[QSThreadSafeMutableArray alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (NSInteger i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSString * str = [NSString stringWithFormat:@\"数组%d\", (int)i+1]; [_MSafeArray addObject:str]; &#125;); &#125; sleep(1); NSEnumerator * enu = [_MSafeArray objectEnumerator]; for (NSObject * object in enu) &#123; NSLog(@\"value: %@\", object); &#125;&#125; 三、atomic 与 nonatomic 的区别在默认情况下，由编译器生成的属性的 set、get 方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不需要同步锁。 尽管没有指明 atomic 的特质（如果某属性不具备 nonatomic 特质，那它就是”原子的”(atomic)），仍然可以在属性特质中写明这一点，编译器是不会报错的。 一般 iOS 程序中，所有属性都声明为 nonatomic。这样做的原因是： 在 iOS 中使用同步锁的开销比较大， 会带来性能问题。 一般情况下并不要求属性必须是”原子的”，因为这并不能保证线程安全。若要实现线程安全的操作，还需采用更为深层的锁的机制。 一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic 也还是会读取到不同的属性值。 因此，iOS 程序一般都会使用 nonatomic 属性。但在 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。 nonatomic 的实现： 12345678910111213- (void)setImage:(UIImage *)image&#123; if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125;&#125;- (UIImage *)image&#123; return _image;&#125; atomic 的实现： 123456789101112131415161718- (void)setImage:(UIImage *)image&#123; @synchronized(self) &#123; // 锁 if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125; &#125;&#125;- (UIImage *)image&#123; @synchronized(self) &#123; return _image; &#125;&#125; @synchronized 的介绍： The @synchronized directive is a convenient way to create mutex locks on the fly in Objective-C code. The @synchronized directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example: - (void)myMethod:(id)anObj{ @synchronized(anObj) { // Everything between the braces is protected by the @synchronized directive. } } The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the anObj parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section. As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes. For more information about the @synchronized directive, see The Objective-C Programming Language. 更准确的说应该是读写安全，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。 四、文章清雨未尽时 &amp; NSMutableArray使用中忽视的问题","tags":[]},{"title":"","date":"2019-04-23T15:31:08.000Z","path":"2019/04/23/GLSL/GLSL/","text":"##一、GLSL基础 GLSL（OpenGL Shading Language）作为一种着色语言是纯粹的和 GPU 打交道的计算机语言。因为 GPU 是多线程并行处理器，所以 GLSL 直接面向 SIMD 模型的多线程计算。 GLSL 编写的着色器函数是对每个数据同时执行的。 每个顶点都会由顶点着色器中的算法处理，每个像素也都会由片段着色器中的算法处理。 因此，初学者在编写自己的着色器时，需要考虑到SIMD的并发特性，并用并行计算的思路来思考问题。 最常见用法是在顶点着色器里生成所需要的值，然后传给片断着色器用。 ##二、GLSL能做什么？ 日以逼真的材质 – 金属，岩石，木头，油漆等 日益逼真的光照效果 – 区域光和软阴影 非现实材质 – 美术效果，钢笔画，水墨画和对插画技术的模拟 针对纹理内存的新用途 更少的纹理访问 图形处理 – 选择，边缘钝化遮蔽和复杂混合 动画效果 – 关键帧插值，粒子系统 用户可编程的反走样方法 ##三、GLSL注意 GLSL支持函数重载 GLSL不存在数据类型的自动提升，数据类型必须严格保持一致。 GLSL不支持指针，字符串，字符，它基本上是一种处理数字数据的语言 GLSL不支持联合、枚举类型、结构体位字段及按位运算符 ##四、数据类型GLSL 有三种基本数据类型：float，int 和 bool，以及由这些数据类型组成的数组和结构体。 需要注意的是，GLSL 并不支持指针。与 C/C++ 不同的是，GLSL 将向量和矩阵作为基本数据类型。 注意：GLSL不存在数据类型的自动提升，类型必须严格保持一致。 ####1、标量 float int bool 12342 // 十进制 042 // 八进制 0x2A // 十六进制 GLSL 不存在数据类型的自动提升，类型必须严格保持一致 ####2、矢量 矢量可以和标量甚至矩阵做加减乘除(必须符合规则) 123 vec2, vec3, vec4 // 包含2/3/4个浮点数的矢量ivec2, ivec3, ivec4 // 包含2/3/4个整数的矢量bvec2, bvec3, bvec4 // 包含2/3/4个布尔值的矢量 声明： 123456vec3 v; //声明三维浮点型向量v v[1]=3.0; //给向量v的第二个元素赋值 // 下面两种等价vec3 v = vec3(0.6);vec3 v = vec3(0.6, 0.6, 0.6); 注意：除了用索引的方式外，还可以用选择运算符的方式来使用向量。选择运算符是对于向量的各个元素（最多为 4 个）约定俗成的名称，用一个小写拉丁字母来表示。根据向量表示对象的意义不同，可以使用以下选择运算符： 表示顶点可以用 (x、y、z、w) 表示颜色可以用 (r、g、b、a) 表示纹理坐标用 (s、t、r、q) 用户可以选择其中任意一种选择运算符，它们的作用是等效的。 例如： 12345vec4 v1=vec4(1.0, 2.0, 3.0, 4.0)； //用构造函数的方式声明并初始化四维浮点型vec4 v2； v2.xy=v1.yz; //将v1的第二个和第三个元素复制到v2的第一个和第二个元素 v2.z=2.0; //给v2的第三个元素赋值 v2.xy=v1.yx; //将v1的头两个元素互换，再复制到v2的头两个元素中 ####3、矩阵 mat2, mat3, mat4 -- 2*2 / 3*3 / 4*4 的矩阵 矩阵是按列顺序组织的，先列后行。 例如： 123456mat4 m; // 声明四维浮点型方阵 m m[2][3]=2.0; // 给方阵的第三列、第四行元素赋值 // 下面两种等价，初始化矩阵对角mat2 m = mat2(1.0)mat2 m = mat2(1.0, 0.0, 0.0, 1.0); ####4、取样器(Sampler) 纹理查找需要指定哪个纹理或者纹理单元将指定查找。 123456sampler1D 访问一个一维纹理sampler2D 访问一个二维纹理 sampler3D 访问一个三维纹理samplerCube 访问一个立方贴图纹理sampler1DShadow 访问一个带对比的一维深度纹理sampler2DShadow 访问一个带对比的二维深度纹理 12345678910111213uniform sampler2D grass;vcc2 coord = vec2(100, 100);vec4 color = texture2D(grass, coord);// 如果一个着色器要在程序里结合多个纹理，可以使用取样器数组const int tex_nums = 4;uniform sampler2D textures[tex_nums];for(int i = 0; i &lt; tex_nums; ++i) &#123; sampler2D tex = textures[i]; // todo ...&#125; ####5、结构体 这是唯一的用户定义类型。 1234567struct light &#123; vec3 position; vec3 color; &#125;; light ceiling_light; ####6、数组 数组索引是从 0 开始的，而且没有指针概念。 1234567// 创建一个具有 10 个元素的数组 vec4 points[10]; // 创建一个不指定大小的数组vec4 points[]; points[2] = vec4(1.0); // points 现在数组长度为 3points[7] = vec4(2.0); // points 现在数组长度为 8 ####7、void 只能用于声明函数返回值。 ##五、类型转换必须明确地进行类型转换，不会自动类型提升。 12float f = 2.3; bool b = bool(f); // b is true ##六、限定符GLSL 中有 4 个限定符（variable qualifiers）可供使用，它们限定了被标记的变量不能被更改的”范围”。 const attribute uniform varying ####1、const const 和 C++ 里差不多，定义不可变常量。表示限定的变量在编译时不可被修改 ####2、attribute attribute 是应用程序传给顶点着色器用的。不允许声明时初始化。 attribute 限定符标记的是一种全局变量，该变量在顶点着色器中是只读（read-only）的，该变量被用作从OpenGL应用程序向顶点着色器中传递参数，因此该限定符仅能用于顶点着色器。 ####3、uniform unifrom 一般是应用程序用于设定顶点着色器和片断着色器相关初始化值。 不允许声明时初始化 uniform限定符标记的是一种全局变量,该变量对于一个图元（primitive）来说是不可更改的 它可以从OpenGL应用程序中接收传递来的参数。 ####4、varying varying用于传递顶点着色器的值给片断着色器 不允许声明时初始化 它提供了从顶点着色器向片段着色器传递数据的方法，varying限定符可以在顶点着色器中定义变量，然后再传递给光栅化器，光栅化器对数据插值后，再将每个片段的值交给片段着色器。 ##七、限制 不能在 if-else 中声明变量 用于判断的条件必须是bool类型(if,while,for…) (?:) 操作符后两个参数必须类型相同 不支持 switch 语句 123456vec4 toonify(in float intensify) &#123; vec4 color; color = vec4(0.8,0.8,0.8,0.8) return color;&#125; 八、discard关键字discard 关键字可以避免片段更新帧缓冲区，当流控制遇到这个关键字时，正在处理的片段就会被标记为丢 九、函数 函数名可以通过参数类型重载，但是和返回值类型无关 所有参数必须完全匹配，参数不会自动 函数不能被递归调用 函数返回值不能是数组 函数参数标示符 in: 进复制到函数中，但不返回的参数(默认) out: 不将参数复制到函数中，但返回参数 inout: 复制到函数中并返回 十、混合操作通过在选择器 (.) 后列出各分量名，就可以选择这些分量。 123456789vec4 v4;v4.rgba; // 得到vec4v4.rgb; // 得到vec3v4.b; // 得到floatv4.xy; // 得到vec2v4.xgba; // 错误！分量名不是同一类v4.wxyz; // 打乱原有分量顺序v4.xxyy; // 重复分量 原文地址：https://www.tuicool.com/articles/yEBFvmA","tags":[]}]