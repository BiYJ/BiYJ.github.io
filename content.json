[{"title":"iOS 证书","date":"2019-05-22T08:51:44.499Z","path":"2019/05/22/iOS 证书/","text":"一、引言 什么是 App ID？Explicit/Wildcard App ID 有何区别？什么是 App Group ID？ 什么是证书（Certificate）？如何申请？有啥用？ 什么是Key Pair（公钥/私钥）？有啥用？与证书有何关联？ 什么是签名（Signature）？如何签名（CodeSign）？怎样校验（Verify）？ 什么是（Team）Provisioning Profiles？有啥用？ Xcode如何配置才能使用iOS真机进行开发调试？ 多台机器如何共享开发者账号或证书？ 遇到证书配置问题怎么办？ Xcode 7免证书调试真机调试 二、App ID（bundle identifier） App ID 即 Product ID，用于标识一个或者一组 App。 App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。 App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。 App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类： Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。 Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“*”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.*”可以表示Bundle Identifier以“com.apple.”开头的所有应用程序。 用户可在Developer MemberCenter网站上注册或删除已注册的App IDs。 App ID 被配置到【Target-&gt;Info-&gt;Bundle Identifier】下；对于 Wildcard App ID，只要 bundle identifier 包含其作为 Prefix/Seed 即可。 三、设备（Device） Device 就是运行 iOS 系统用于开发调试 App 的设备。每台Apple设备使用 UDID 来唯一标识。 iOS设备连接Mac后，可通过 iTunes-&gt;Summary 或者 Xcode-&gt;Window-&gt;Devices 获取 iPhone 的 UDID。 Apple Member Center 网站个人账号下的 Devices 中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册 100 个设备。 Apps signed by you or your team run only on designated development devices. Apps run only on the test devices you specify. 用户可在网站上注册或启用/禁用（Enable/Disable）已注册的 Device。本文的 Devices 是指连接到 Xcode 被授权用于开发测试的 iOS 设备（iPhone/iPad）。 四、开发证书（Certificates）4.1 证书 证书是由公证处或认证机关开具的证明资格或权力的证件，它是表明（或帮助断定）事理的一个凭证。证件或凭证的尾部通常会烙印公章。 每个中国人一生可能需要 70 多个证件，含 15 种身份证明。 4.2 数字证书 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在 Internet 上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。 它是由一个由权威机构——CA机构，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。 数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。 数字证书中的公开密钥（公钥）相当于公章。 某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。 为了防止 GFW 进行中间人攻击(MitM)，例如篡改 github 证书，导致无法访问 github 网站等问题，可选择不信任根证书。 在【钥匙串】中输入 ROOT 进行搜索，可以找到很多根证书，在【简介】|【使用此证书时】下拉选择【永不信任】。 4.3 iOS（开发）证书 iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。 iOS证书分为两类：Development 和 Production（Distribution）。 Development 证书用来开发和调试应用程序：A development certificate identifies you, as a team member, in a development provisioning profile that allows apps signed by you to launch on devices. Production 主要用来分发应用程序（根据证书种类有不同作用）：A distribution certificate identifies your team or organization in a distribution provisioning profile and allows you to submit your app to the store. Only a team agent or an admin can create a distribution certificate. 普通个人开发账号最多可注册 iOS Development/Distribution 证书各 2 个，用户可在网站上删除（Revoke）已注册的Certificate。 下文主要针对 iOS App 开发调试过程中的开发证书（Certificate for Development）。 4.4 iOS（开发）证书的根证书那么，iOS 开发证书是谁颁发的呢？或者说我们是从哪个 CA 申请到用于 Xcode 开发调试 App 的证书呢？ iOS 以及 Mac OS X 系统（在安装 Xcode 时）将自动安装 AppleWWDRCA.cer 这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。 AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer 之于 iOS（开发）证书则好比户籍证之于身份证。 如果 Mac Keychain Access 证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。 4.5 申请证书（CSR：Certificate Signing Request）可以在缺少证书时通过 Xcode Fix Issue 自动请求证书，这里通过 Keychain 证书助理从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。 keychain 将生成一个包含开发者身份信息的 CSR（Certificate Signing Request）文件；同时，Keychain Access|Keys 中将新增一对 Public/Private Key Pair（This signing identity consists of a public-private key pair that Apple issues）。 private key始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）对外发布的 App；public key一般随证书（Provisioning Profile）散布出去，对 App 签名进行校验认证。用户必须保护好本地 Keychain 中的 private key，以防伪冒。 Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an entirely new identity to sign code. Worse, if someone else has your private key, that person may be able to impersonate you. 在 Apple 开发网站上传该 CSR 文件来添加证书（Upload CSR file to generate your certificate）： Apple 证书颁发机构 WWDRCA(Apple Worldwide Developer Relations Certification Authority) 将使用private key 对 CSR 中的 public key 和一些身份信息进行加密签名生成数字证书（ios_development.cer）并记录在案（Apple Member Center）。 从 Apple Member Center 网站下载证书到 Mac 上双击即可安装（当然也可在 Xcode 中添加开发账号自动同步证书和【生成】配置文件）。证书安装成功后，在 KeychainAccess|Keys 中展开创建 CSR 时生成的 Key Pair 中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在 Keychain Access|Certificates 中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。 Certificate 被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Identity】下，下拉选择 Identities from Profile。 五、供应配置文件（Provisioning Profiles）5.1 Provisioning Profile的概念 Provisioning Profile文件包含了上述的所有内容：证书、App ID 和设备。 一个 Provisioning Profile 对应一个 Explicit App ID 或 Wildcard App ID（一组相同Prefix/Seed的App IDs）。 在网站上手动创建一个Provisioning Profile时，需要依次指定 App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的 Provisioning Profiles。 Provisioning Profile 决定 Xcode 用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product），将在应用程序打包时嵌入到 .ipa 包里。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备也通过它来认证安装的程序。 如果要打包或者在真机上运行一个APP，一般要经历以下三步： 首先，需要指明它的 App ID，并且验证 Bundle ID 是否与其一致； 其次，需要证书对应的私钥来进行签名，用于标识这个 APP 是合法、安全、完整的； 然后，如果是真机调试，需要确认这台设备是否授权运行该 APP。 Provisioning Profile 把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。 Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited），App ID 为 Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。 Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录 ~/Library/MobileDevice/Provisioning Profiles 下。 5.2 Provisioning Profile的构成以下为典型供应配置文件 *.mobileprovision 的 构成简析： （1）Name：该mobileprovision的文件名。（2）UUID：该mobileprovision文件的真实文件名。（3）TeamName：Apple ID账号名。（4）TeamIdentifier：Team Identity。（5）AppIDName：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。（6）ApplicationIdentifierPrefix：完整 App ID 的前缀（TeamIdentifier.*）。（7）DeveloperCertificates：包含了可以为使用该配置文件应用签名的所有证书。 证书是基于 Base64 编码，符合 PEM（PrivacyEnhanced Mail, RFC 1848）格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。 从 DeveloperCertificates 提取之间的内容到文件cert.cer（cert.perm）： —–BEGIN CERTIFICATE—– 将之间的内容拷贝至此 —–END CERTIFICATE—– Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥 KeyPair 配对）应吻合；Windows 下没有足够信息（WWDRCA.cer），无法验证该证书。 如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。 （8）Entitlements键对应的： keychain-access-groups：$(AppIdentifierPrefix)，参见Code Signing Entitlements(*.entitlements)。 每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的 keychain，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。 application-identifier：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。 com.apple.security.application-groups：App Group ID（group. com.apple），参见Code Signing Entitlements(*.entitlements)。 com.apple.developer.team-identifier：同Team Identifier。 （9）ProvisionedDevices：该mobileprovision授权的开发设备的UDID 。 Provisioning Profile 被配置到【XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。 六、开发组供应配置文件（Team Provisioning Profiles）6.1 Team Provisioning Profile的概念每个Apple开发者账号都对应一个唯一的 Team ID， Xcode3.2.3 预发布版本中加入了Team Provisioning Profile这项新功能。 在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑自动生成iOS Team Provisioning Profile（Managed by Xcode）。 Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(*)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。 6.2 Team Provisioning Profile生成/更新时机 Add an Apple ID account to Xcode Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode Assign Your App to a Team in Xcode project settings of General|Identity Register new device on the apple development website or Xcode detected new device connected 利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。 Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也被配置到【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。 七、App Group（ID）7.1 App Group的概念WWDC14除了发布了OS X v10.10和 Swift 外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。 扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。 App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。 7.2 App Group的配置Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范： 置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard） Extension App ID以Containing App ID为Prefix/Seed 假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.extImportRecording”。 关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。 App Group会被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。 八、证书与签名（Certificate&amp; Signature）8.1 Code Signing Identity Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。 Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性： 若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信； 再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。 8.2 Code Signing每个证书（其实是公钥）对应Key Pair中的私钥会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字签名（CodeSign）——使用哈希算法生成内容摘要（digest）。 Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。 8.3 Verify Code Signature with Certificate上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。 第一步，App在Mac／iOS真机上启动时，需要对配置的bundle ID、entitlements和certificate与Provisioning Profile进行匹配校验： 第二步，iOS/Mac真机上的ios_development.cer被AppleWWDRCA.cer中的 public key解密校验合法后，获取每个开发证书中可信任的公钥对App的可靠性和完整性进行校验。 iOS/Mac设备（系统）使用App Provisioning Profile （Code Signing Identity） 中的开发证书来判断App的合法性： 若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信； 再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。 小结： 基于Provisioning Profile校验了CodeSign的一致性； 基于Certificate校验App的可靠性和完整性； 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。 九、在多台机器上共享开发账户/证书9.1 Xcode导出开发者账号(*.developerprofile)或PKCS12文件(*.p12)进入Xcode Preferences|Accounts： 选中Apple IDs列表中对应Account的的Email，点击+-之后的☸|Export Accounts，可导出包含account/code signing identity/provisioning profiles信息的*.developerprofile（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。 选中右下列表中某行Account Name条目|ViewDetails，可以查看Signing Identities和Provisioning Profiles。 选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权export key “privateKey” from keychain，将导出Certificates.p12。** 点击左下角的刷新按钮可从Member Center同步该账号下所有的Provisioning Profile到本地。 选中右击列表中某个Provisioning Profile可以【Show in Finder】到[~/Library/MobileDevice/Provisioning\\ Profiles]目录，其中Provisioning Profile的真实名称为$(UUID).mobileprovision，名如”2488109f-ff65-442e-9774-fd50bd6bc827.mobileprovision”，其中Name中为Xcode中看到的描述性别名。 9.2 Keychain Access导出PKCS12文件(*.p12)在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出Certificates.p12——PKCS12 file holds the private key and certificate。 其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书。有了共享证书之后，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件，方可在iOS真机设备上开发调试。 十、证书配置常见错误 no such provisioning profile was found Xcode Target -&gt; Genera -&gt; Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.” Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioning profile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！ No identities from profile Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioning profile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain. Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（.developerprofile）或共享证书(.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。 Code Signing Entitlements file do not match profile “Invalid application-identifier Entitlement“ or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).” （1） 检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。（2） 也可以将Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。 Xcode配置反应有时候不那么及时 可刷新、重置相关配置项开关（若有）或重启Xcode试试。 十一、Xcode7 免证书真机调试在 Xcode 7 中，苹果改变了自己在许可权限上的策略： 此前 Xcode 只开放给注册开发者下载，现在 Xcode 7 改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。 此前开发者需每年支付99美元的费用成为注册开发者才能在 iPhone/iPad 真机上运行调试APP，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。——Developers would be able to test apps on devices without a paid Apple developer account in Xcode 7. 所谓“免证书”真机调试，并不是真的不需要证书，Xcode真机调试原有的证书配置体系仍在——All iOS, tvOS, and watchOS apps must be code signed and provisioned to launch on a device. 所以，上文啰嗦几千字还是有点用的。 自 Xcode7 开始，原来基于付费开发者账号及自助生成证书及配置文件的繁琐过程被苹果简化，Xcode将针对任何普通账号自动为联调真机生成所需相关的证书及配置文件。当你打算向 App Store 提交发布应用，才需要付费。 第一步：进入 Xcode Preferences|Accounts，添加自己的 Apple ID 账号。 第二步：Build Settings|Code Signing 下的 Provisioning Profile 选择 Automatic，Code Signing Identity 选择 Automatic 下的iOS Developer。 第三步：General 配置 Bundle identifier，Team 下拉选择苹果Member Center自动为你的账号生成的Personal Team ID。 自己的账号在调试公司或其他第三方APP代码时，若填写 Bundle identifier 为他人账号注册的 APP ID（例如苹果相机应用 com.apple.camera），会报错： No provisioning profiles with a valid signing identity (i.e. certificate and private key pair) matching the bundle identifier “com.apple.camera” were found. 即使编译通过了，可能运行时APP自身与服务器校验也可能会报签名错误，肿么办？？？ Her skill：此时，可以在他人原有App ID基础上添加后缀（例如com.apple.camera.extension），配置成应用的衍生插件（相当于置于同一 App Group 下）就可以快乐的玩耍了。 如果启动APP时，Xcode报错“process launch failed: Security”或iPhone报错【不受信任的开发者】，此时需要到iPhone通用配置中的描述文件（最新系统中可能叫设备管理）中，在描述文件（开发商应用）中选择对应的描述文件（你的Apple ID）点击 信任 或 验证 即可。 十二、推送证书APNS远程推送证书的申请和制作——详细解析APNS推送服务证书制作 图文详解教程 十三、学习文章《iOS开发各种证书问题》《iPhone真机调试应用程序》《iOS Developer：真机测试》《Xcode5 &amp; iOS 7 及以下版本免证书真机调试记录》《iOS Development–Certificates, Provisioning Profiles》《关于Certificate、Provisioning Profile、App ID的介绍及其关系》《数字签名和数字证书》《iOS keyChain 研究》《苹果开发者账号那些事儿》《iOS关于Provisioning Profiles這些事》《iOS Code Signing 学习笔记》《代码签名探析/Inside Code Signing》《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》《iOS行货自动打包》《解决Xcode无法生成Archive的问题》《iOS程序完成后如何生成ipa进行真机测试》《发布iOS应用程序(Application Loader)》《iOS发布遇到的一些问题》《Xcode打包ipa包》《iOS程序生成ipa进行真机测试》","tags":[]},{"title":"iOS Push","date":"2019-05-22T06:31:14.236Z","path":"2019/05/22/iOS Push/","text":"1、前言早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。 2、push流程 Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。 上图可以分为三个阶段：①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。 从上图可以看到： ①、在程序上注册远程通知，这是通知的前提（程序员的工作）；1234 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];&#125; ②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；123456789101112-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;#if !TARGET_IPHONE_SIMULATOR //注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做） self.deviceToken = [[[[devToken description] stringByReplacingOccurrencesOfString:@\"&lt;\"withString:@\"\"] stringByReplacingOccurrencesOfString:@\"&gt;\" withString:@\"\"] stringByReplacingOccurrencesOfString: @\" \" withString: @\"\"];#endif // 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送 [JPUSHService registerDeviceToken:devToken];&#125; ④、将这个 token 值发送到公司的服务器上去，存储下来。⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。 3、APNs的限制APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： 可靠性。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 Payload Size。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 成功率并不高。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。 4、不仅仅是Local Push很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。 Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。 5、叫醒你的App开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。 唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。 6、前台消息通道大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在12345678// iOS 10 Support- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123;&#125; 也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。 7、PushKitAPNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。 之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。 当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。 微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。 8、总结关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。 9、学习文章MrPeak杂货铺 &amp; iOS Push的门道Silent Push实现PushKit实现APNS推送服务证书制作 图文详解教程APNS远程推送证书的申请和制作——详细解析","tags":[]},{"title":"iOS 时间","date":"2019-05-21T08:15:20.020Z","path":"2019/05/21/iOS 时间/","text":"1、时间的形式在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。 1.1、GMT人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。 前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。 1.2、UTC太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。 我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。 接下来看下iOS里，五花八门的记录时间的方式。 2、NSDateNSDate是我们平时使用较多的一个类，先看下它的定义： NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001). NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。 这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。 理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：12NSDate* date = [NSDate date];NSLog(@\"current date interval: %f\", [date timeIntervalSinceReferenceDate]); timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。 又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：12NSDate* date = [NSDate date];NSLog(@\"current date: %@\", date); current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。 NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。 另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。 3、CFAbsoluteTimeGetCurrent()官方定义如下： Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock. 从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。 同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。 4、gettimeofday这个API也能返回一个描述当前时间的值，代码如下：1234struct timeval now;struct timezone tz;gettimeofday(&amp;now, &amp;tz);NSLog(@\"gettimeofday: %ld\", now.tv_sec); 使用gettimeofday获得的值是Unix time。Unix time又是什么呢？ Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。 Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：1date -r 1481266031 实际上NSDate也有一个API能返回Unix time：12NSDate* date = [NSDate date];NSLog(@\"timeIntervalSince1970: %f\", [date timeIntervalSince1970]); gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。 5、mach_absolute_time()mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。 前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。 不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。 mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。 6、CACurrentMediaTime()CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：123/* Returns the current CoreAnimation absolute time. This is the result of * calling mach_absolute_time () and converting the units to seconds. */CFTimeInterval CACurrentMediaTime (void) CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：12double mediaTime = CACurrentMediaTime();NSLog(@\"CACurrentMediaTime: %f\", mediaTime); 返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：12NSTimeInterval systemUptime = [[NSProcessInfo processInfo] systemUptime];NSLog(@\"systemUptime: %f\", systemUptime); CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。 7、sysctliOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：123456789101112131415161718#include &lt;sys/sysctl.h&gt;- (long)bootTime&#123;#define MIB_SIZE 2 int mib[MIB_SIZE]; size_t size; struct timeval boottime; mib[0] = CTL_KERN; mib[1] = KERN_BOOTTIME; size = sizeof(boottime); if (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, 0) != -1) &#123; return boottime.tv_sec; &#125; return 0;&#125; 返回的值是上次设备重启的Unix time。 这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。 有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。 8、场景一，时间测量我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。 在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。 客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。 上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：1234567891011121314151617int testCount = 10000;double avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; NSDate* begin = [NSDate date]; NSLog(@\"a meaningless log\"); avgCost += -[begin timeIntervalSinceNow];&#125;NSLog(@\"benchmark with NSDate: %f\", avgCost/testCount);avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; double startTime = CACurrentMediaTime(); NSLog(@\"a meaningless log\"); double endTime = CACurrentMediaTime(); avgCost += (endTime - startTime);&#125;NSLog(@\"benchmark with CACurrentMediaTime: %f\", avgCost/testCount); 输出结果为：12benchmark with NSDate: 0.000046benchmark with CACurrentMediaTime: 0.000037 可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：12#define TICK NSDate *startTime = [NSDate date]#define TOCK NSLog(@\"Time Cost: %f\", -[startTime timeIntervalSinceNow]) 9、场景二：客户端和服务器之间的时间同步这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。 比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？ 上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。 首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：1234567uint64_t realLocalTime = 0;if (serverTime != 0 &amp;&amp; lastSyncLocalTime != 0) &#123; realLocalTime = serverTime + (curLocalTime - lastSyncLocalTime);&#125;else &#123; realLocalTime = [[NSDate date] timeIntervalSince1970]*1000;&#125; 如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。 关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：1234567891011121314151617181920//get system uptime since last boot- (NSTimeInterval)uptime&#123; struct timeval boottime; int mib[2] = &#123;CTL_KERN, KERN_BOOTTIME&#125;; size_t size = sizeof(boottime); struct timeval now; struct timezone tz; gettimeofday(&amp;now, &amp;tz); double uptime = -1; if (sysctl(mib, 2, &amp;boottime, &amp;size, NULL, 0) != -1 &amp;&amp; boottime.tv_sec != 0) &#123; uptime = now.tv_sec - boottime.tv_sec; uptime += (double)(now.tv_usec - boottime.tv_usec) / 1000000.0; &#125; return uptime;&#125; gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。 多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。 10、学习文章MrPeak杂货铺iOS倒计时的探究与选择","tags":[]},{"title":"hexo+pages建站","date":"2019-05-14T07:42:50.947Z","path":"2019/05/14/hexo+pages建站/","text":"hexo史上最全搭建教程 解决用Hexo和GitHub搭建博客时hexo d命令报错问题 hexo d后 ERROR Deployer not found: git git-ssh 配置和使用 给博客添加文章目录 https://hexo.io/zh-cn/ Hexo博客多台电脑设备同步管理","tags":[]}]