[{"title":"weak","date":"2019-05-23T06:43:21.310Z","path":"2019/05/23/weak/","text":"一、基本用法weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候自动被设置为 nil，大大避免了野指针访问坏内存引起崩溃的情况，另外 weak 还可以用于解决循环引用。 二、原理概括 weak 表其实是一个 hash（哈希）表。 key：所引用对象的地址；value：weak 指针的地址数组（这个地址的值是指向对象的指针的地址）。 weak 的底层实现的原理是什么？ runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表是由单个自旋锁管理的散列表。 为什么 value 是数组？ 因为一个对象可能被多个弱引用指针指向。 三、实现步骤weak 的实现原理可概括三步： ①、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 ②、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 ③、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 四、详细过程1、初始化时：runtime 会调用 objc_initWeak 函数，objc_initWeak 函数会初始化一个新的 weak 指针指向对象的地址。 123NSObject * obj = [[NSObject alloc] init];id __weak obj1 = obj; 当初始化一个 weak 变量时，runtime 会调用 NSObject.mm 中的 objc_initWeak 函数。 这个函数在 Clang 中的声明如下： 1id objc_initWeak(id *object, id value); 而对于 objc_initWeak() 方法的实现如下： 123456789101112id objc_initWeak(id *location, id newObj)&#123; // 查看对象实例是否有效，无效对象直接导致指针释放 if (!newObj) &#123; *location = nil; return nil; &#125; // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt;(location, (objc_object*)newObj);&#125; 这里先判断了其指针指向的类对象是否有效，无效直接释放返回，不再往深层调用函数。否则 object 将被注册为一个指向 value 的 __weak 对象，而这事应该是 objc_storeWeak 函数干的。可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断）。 注意：objc_initWeak 函数有一个前提条件：就是 object 必须是一个没有被注册为 __weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 objc_storeWeak() 的函数声明如下： 1id objc_storeWeak(id *location, id value); objc_storeWeak() 的具体实现如下，请参考 weak弱引用实现的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// HaveOld: true - 变量有值// false - 需要被及时清理，当前值可能为 nil// HaveNew: true - 需要被分配的新值，当前值可能为 nil// false - 不需要分配新值// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停// false - 用 nil 替代存储template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj) &#123; // 该过程用来更新弱引用指针的指向 // 初始化 previouslyInitializedClass 指针 Class previouslyInitializedClass = nil; id oldObj; // 声明两个 SideTable // ①、创建新旧散列 SideTable *oldTable; SideTable *newTable; // 获得新值和旧值的锁存位置（用地址作为唯一标示） // 通过地址来建立索引标志，防止桶重复 // 下面指向的操作会改变旧值retry: if (HaveOld) &#123; // 如果 HaveOld 为 true，更改指针，获得以 oldObj 为索引所存储的值地址 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // 更改新值指针，获得以 newObj 为索引所存储的值地址 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁操作，防止多线程中竞争冲突 SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 避免线程冲突重处理 // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // 防止弱引用间死锁 // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向 if (HaveNew &amp;&amp; newObj) &#123; // 获得新对象的 isa 指针 Class cls = newObj-&gt;getIsa(); // 判断 isa 非空且已经初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; // 解锁 SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 对其 isa 指针进行初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // 如果该类已经完成执行 +initialize 方法是最理想情况 // 如果该类 +initialize 在线程中 // 例如 +initialize 正在调用 storeWeak 方法 // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; // 重新尝试 goto retry; &#125; &#125; // ② 清除旧值 if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // ③ 分配新值 if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // 如果弱引用被释放 weak_register_no_lock 方法返回 nil // 在引用计数表中设置若引用标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // 弱引用位初始化操作 // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用 newObj-&gt;setWeaklyReferenced_nolock(); &#125; // 之前不要设置 location 对象，这里需要更改指针指向 *location = (id)newObj; &#125; else &#123; // 没有新值，则无需更改 &#125; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 撇开源码中各种锁操作，来看看这段代码都做了些什么。 ①、SideTable SideTable 这个结构体，我给它起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable。实例在 NSObject.mm 中声明其数据结构： 12345678struct SideTable &#123; // 保证原子操作的自旋锁 spinlock_t slock; // 引用计数的 hash 表 RefcountMap refcnts; // weak 引用全局 hash 表 weak_table_t weak_table;&#125; slock 是为了防止竞争选择的自旋锁，用来保证线程安全； refcnts 是协助对象的 isa 指针的 extra_rc 共同引用计数的变量，每个对象的引用计数保存在全局的引用计数表中，一个对象地址对应一个引用计数； weak_table 就是接下来要讲的 weak 表，所有的 weak 变量会被加入到全局的 weak 表中，表的 key 是 weak 修饰的变量指向的对象， value 值就是 weak 修饰的变量。这里主要看 weak 全局 hash 表的结构与作用。 ②、weak 表 weak 表是一个弱引用表，实现为一个 weak_table_t 结构体，存储了某个对象相关的所有的弱引用信息。其定义如下（具体定义在 objc-weak.h 中）： 12345678910struct weak_table_t &#123; // 保存了所有指向指定对象的 weak 指针 weak_entry_t * weak_entries; // 存储空间，即 entries 的数目 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;&#125;; 这是一个全局弱引用 hash 表，它的作用就是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。使用不定类型对象的地址的 hash 化后的数值作为 key，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。 weak_entry_t 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下： 12345678910111213141516171819typedef objc_object ** weak_referrer_t;// 存储在弱引用表中的一个内部结构体struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 封装 objc_object 指针，即 weak 修饰的变量指向的对象 union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; // LSB 最低有效元。当标志位为0时，增加引用表指针纬度，当其为0的时候， weak_referrer_t 成员将扩展为静态数组型的 hash table uintptr_t num_refs : PTR_MINUS_1; // 引用数值，这里记录弱引用表中引用有效数字，即里面元素的数量 uintptr_t mask; uintptr_t max_hash_displacement; // hash 元素上限阀值 &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;&#125; 在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题，其内容可以理解为对象的内存地址。 从注释中写 out_of_line 成员为最低有效位，当其为 0 的时候， weak_referrer_t 成员将扩展为一个静态数组型的 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。 那么在有效位未生效的时候，out_of_line、num_refs、mask、max_hash_displacement 有什么作用？以下是笔者自身的猜测： out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。 num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。 mask：计数辅助量。 max_hash_displacement：hash 元素上限阀值。 其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT。 每个对象的 SideTable 中的 weak_table_t 都是全局 weak 表的入口，以引用计数对象为键找到其所记录的 weak 修饰的对象。 weak_entry_t 中的 referrers 有两种形式：当 out_of_line 为 0 的时候，referrers 是一个静态数组型的表，数组大小默认为 WEAK_INLINE_COUNT 大小；当 out_of_line 不为 0 的时候，referrers 是一个动态数组，内容随之增加。 StripedMap[] 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。 ③、旧对象解除注册操作 weak_unregister_no_lock 123456789101112131415161718192021222324252627282930313233void weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; 该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。 来看看这个函数的逻辑： 首先参数是 weak_table_t 表、键和值。声明 weak_entry_t 变量，如果 key，也就是引用计数对象为空，直接返回。根据全局入口表和键获取对应的 weak_entry_t 对象，也就是 weak 表记录。获取到记录后，将记录表以及 weak 对象作为参数传入 remove_referrer 函数中，这个函数就是解除操作。然后判断这个 weak 记录是否为空，如果为空，从全局记录表中清除相应的引用计数对象的 weak 记录表。 从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。 再来了解一下解除对象的函数： 123456789101112131415161718192021222324252627282930313233343536static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)&#123; if (! entry-&gt;out_of_line) &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == old_referrer) &#123; entry-&gt;inline_referrers[i] = nil; return; &#125; &#125; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; size_t index = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; &#125; entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;&#125; 这个函数传入的是 weak 对象，当 out_of_line 为 0 时，遍历数组，找到对应的对象，置 nil，如果未找到，报错并返回。当 out_of_line 不为 0 时，根据对象的地址 hash 化并和 mask 做与操作作为下标，查找相应的对象，若没有，报错并返回，若有，相应的置为 nil，并减少元素数量，即 num_refs 减 1。 ④、新对象添加注册操作 weak_register_no_lock 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; weak_entry_t new_entry; new_entry.referent = referent; new_entry.out_of_line = 0; new_entry.inline_referrers[0] = referrer; for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_entry.inline_referrers[i] = nil; &#125; weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 这一步与上一步相反，通过 weak_register_no_lock 函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。 一大堆 if-else 主要是为了判断该对象是不是 taggedPoint 以及是否正在调用 dealloc 等。下面操作开始，同样是先获取 weak 表记录，如果获取到，则调用 append_referrer 插入对象，若没有，则新建一个 weak 表记录，默认为 out_of_line，然后将新对象放到 0 下标位置，其他位置置为 nil 。下面两个函数 weak_grow_maybe 是用来判断是否需要重申请内存重 hash，weak_entry_insert 函数是用来将新建的 weak 表记录插入到全局 weak 表中。插入时同样是以对象地址的 hash 化和 mask 值相与作为下标来记录的。 接下来看看 append_referrer 函数，源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)&#123; if (! entry-&gt;out_of_line) &#123; // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; // Couldn't insert inline. Allocate out of line. weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = 1; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; &#125; assert(entry-&gt;out_of_line); if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer); &#125; size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; &#125; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement; &#125; weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;&#125; ⑤、初始化弱引用对象流程一览 弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图： 这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然，storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？当释放对象时，其基本流程如下： ①、调用 objc_release②、因为对象的引用计数为 0，所以执行 dealloc③、在 dealloc 中，调用了_objc_rootDealloc 函数④、在 _objc_rootDealloc 中，调用了 object_dispose 函数⑤、调用 objc_destructInstance⑥、最后调用 objc_clear_deallocating，详细过程如下： a. 从 weak 表中获取废弃对象的地址为键值的记录 b. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nil c. 将 weak 表中该记录删除 d. 从引用计数表中删除废弃对象的地址为键值的记录 重点看对象被释放时调用的 objc_clear_deallocating 函数。该函数实现如下： 123456789void objc_clear_deallocating(id obj) &#123; assert(obj); assert(!UseGC); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating();&#125; 这个函数只是做一些判断以及更深层次的函数调用。 123456789101112131415161718void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); // 迭代器 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125; 也就是调用了 clearDeallocating()，继续追踪可以发现，它最终是使用了迭代器来取 weak 表的 value，然后调用 weak_clear_no_lock，然后查找对应的 value，将该 weak 指针置空，weak_clear_no_lock 函数的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id)&#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 简单来说，这个方法首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组，把每个地址存储的数据设为 nil ，最后把这个 key-value entry 从 weak 表中删除。 注意： ①、从实现中可以看出，weak 指针的使用涉及到 hash 表的增删改查，存在一定的性能开销。②、使用 weak 指针的时候，应首先获取一个 Strong 指针再使用。倒不是为了防止在使用过程中对象被回收，形成野指针。这个不用担心，因为你使用了 weak 指针，对象就会被加入到 autoreleasepool 中，可以放心使用。但是要注意的是，如果在一个代码块中频繁使用 weak 指针，还是应首先获取一个 Strong 指针，否则这个对象会被一次又一次的加入 autoreleasepool 中，也存在一定的性能开销。 五、拓展补充weak、__unsafe_unretained、unowned 与 assign 区别 __unsafe_unretained：不会对对象进行 retain，当对象销毁时，会依然指向之前的内存空间（野指针） weak：不会对对象进行 retain，当对象销毁时，会自动置为 nil __unsafe_unretained 可以修饰代表基础数据类型的 property，weak 不能修饰基础数据类型的 property。 使用 weak 是有代价的，因为通过上面的原理可知，__weak 需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况，因此 __unsafe_unretained 比 __weak 快。所以当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，__unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。 unowned 使用在 Swift 中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。 假如很明确的知道对象的生命期，也可以选择 unowned。 assign：实质与 __unsafe_unretained 等同 通过上面的描述，我们基本能了解一个 weak 引用从生到死的过程。从这个流程可以看出，一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 __weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 __weak 修饰符。 六、学习文章 weak 弱引用的实现方式iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）iOS weak 的底层实现weak 的生命周期：具体实现方法iOS 中 weak 的实现","tags":[]},{"title":"深拷贝和浅拷贝","date":"2019-05-22T10:52:52.721Z","path":"2019/05/22/深拷贝和浅拷贝/","text":"深拷贝和浅拷贝的本质区别是地址是否相同。 浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址； 深拷贝是真正的复制了一份，复制的对象指向了新的地址。 一、非容器类对象对象的 copy 是浅拷贝，mutableCopy 是深拷贝。 1、不可变 12345678910NSString * s1 = @\"AAA\";NSString * s2 = [s1 copy];NSString * s3 = [s1 mutableCopy]; NSLog(@\"%p %@\", s1, s1.class);NSLog(@\"%p %@\", s2, s2.class);NSLog(@\"%p %@\", s3, s3.class);0x1083a40e8 __NSCFConstantString0x1083a40e8 __NSCFConstantString0x60400044f840 __NSCFString 结论： ①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 2、可变 12345678910NSMutableString * ms1 = [NSMutableString stringWithString:@\"1\"];NSMutableString * ms2 = [ms1 copy];NSString * ms3 = [ms1 mutableCopy]; NSLog(@\"%p %@\", ms1, ms1.class);NSLog(@\"%p %@\", ms2, ms2.class);NSLog(@\"%p %@\", ms3, ms3.class);0x6040004500b0 __NSCFString0xa000000000000311 NSTaggedPointerString0x60400044fc60 __NSCFString 结论： ①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝； ②、copy 和 mutableCopy 返回对象都为可变对象。 二、容器对象1、不可变 123456789101112NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSArray * arr1 = [NSArray arrayWithObjects:ms, @\"2\", nil];NSArray * arr2 = [arr1 copy];NSArray * arr3 = [arr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]); 0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025a940 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 ③、容器内的元素始终都是浅拷贝。 2、可变 1234567891011NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:ms, @\"2\", nil];NSMutableArray * mArr2 = [mArr1 copy];NSMutableArray * mArr3 = [mArr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]);0x60000025aeb0 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037640 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025ae80 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；②、copy 返回不可变对象，mutableCopy 返回可变对象；③、容器内的元素始终是浅拷贝。 三、自定义类对象的深浅拷贝自定义的类需要遵循 才支持 copy，遵循 支持 mutableCopy。 12345678910111213141516171819202122@interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@end@implementation Person- (instancetype)copyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone]; // return self;&#125;- (instancetype)mutableCopyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone];&#125;@endPerson * p1 = [[Person alloc] init];Person * p2 = [p1 copy];Person * p3 = [p1 mutableCopy]; NSLog(@\"%p %@\", p1, p1.class);NSLog(@\"%p %@\", p2, p2.class);NSLog(@\"%p %@\", p3, p3.class);0x600000011e30 Person0x600000011f70 Person0x600000011f90 Person 四、实现容器对象的完全拷贝1234567891011NSMutableString * ms = [NSMutableString stringWithFormat:@\"1\"];NSArray * arr = [NSArray arrayWithObjects:ms, @\"2\", nil];NSLog(@\"%p %p\", arr[0], arr[1]);NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];NSLog(@\"%p %p\", mArr[0], mArr[1]);NSData * data = [NSKeyedArchiver archivedDataWithRootObject:mArr];NSMutableArray * newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];NSLog(@\"%p %p\", newMutableArr[0], newMutableArr[1]);0x6040004434b0 0x109c931000xa000000000000311 0x109c931000xa000000000000311 0xa000000000000321 由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。 自定义类对象需要遵循 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。 123456789- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self.xxx = [aDecoder decodeObjectForKey:@\"key\"]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.xxx forKey:@\"key\"];&#125; 五、总结只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。 六、学习文章深刻理解iOS中的“深拷贝”和“浅拷贝”","tags":[]},{"title":"String","date":"2019-05-22T10:48:05.651Z","path":"2019/05/22/String/","text":"一、字符串常量123456789101112131415161718@property (nonatomic, copy) NSString * string1;@property (nonatomic, weak) NSString * string2;&#123; NSString * temp = @\"AAAA\"; self.s1 = temp; NSLog(@\"temp -&gt; %p\", temp); self.s2 = self.s1; self.s1 = nil; NSLog(@\"s1 = %@，s2 = %@\", self.s1, self.s2); NSLog(@\"s1 -&gt; %p，s2 -&gt; %p\", self.s1, self.s2); NSLog(@\"retainCount = %@\", [temp valueForKey:@\"retainCount\"]);&#125;temp -&gt; 0x108551118s1 = (null)，s2 = AAAAs1 -&gt; 0x0，s2 -&gt; 0x108551118retainCount = 18446744073709551615 解释 1 temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。 即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。 另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子： 1NSString ** s2 = s1; // 需要关闭 arc 才能使用二级指针 这样 s1 = nil 后 s2 也是 nil 了。 解释 2 @”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。 self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。 字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。 致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。 12345678910&#123; NSString * temp1 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp2 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp3 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSString * temp4 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSLog(@\"%p %p\", temp1, temp2); NSLog(@\"%p %p\", temp3, temp4);&#125;0xa414141414141417 0xa4141414141414170x60000022a3a0 0x60000022a260 通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区： 如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。 二、Copy 和 strong@interface ViewController () @property (nonatomic, strong) NSString * sString; @property (nonatomic, copy) NSString * cString; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSMutableString * mString = [NSMutableString string]; [mString appendFormat:@&quot;AA&quot;]; self.sString = mString; self.cString = mString; NSLog(@&quot;mString -&gt; %p, sString -&gt; %p, cString -&gt; %p&quot;, mString, _sString, _cString); // mString -&gt; 0x600002565b30, sString -&gt; 0x600002565b30, cString -&gt; 0xcac34ab7cb397e8b NSLog(@&quot;%@&quot;, self.sString); // AA NSLog(@&quot;%@&quot;, self.cString); // AA [mString appendFormat:@&quot;BB&quot;]; NSLog(@&quot;%@&quot;, self.sString); // AABB NSLog(@&quot;%@&quot;, self.cString); // AA } @end 结果分析: 使用 strong 修饰 NSString 类型属性，指针指向可变字符串对象的地址，当可变字符串内容发生变化时，self.sStrong 相对应的也发生变化；使用 copy 修饰，会将可变字符串重新拷贝一份，重新开辟内存空间，修改 mutableString 的值不会对 self.cString 造成影响。","tags":[]},{"title":"atomic","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/atomic/","text":"参考文章：http://blog.csdn.net/kangguang/article/details/79194563 atomic 在 set 方法里加了锁，防止了多线程一直去写这个 property，造成难以预计的数值。 当属性使用 atomic 修饰时，它的读和写是原子性的：当线程 A 进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当 A 线程的写操作结束后，B 线程进行写操作，然后当 A 线程需要读操作时，获得了在 B 线程中修改的值。如果有 C 线程在 A 线程读操作之前 release了该属性，可能导致程序崩溃。 导致崩溃并不是线程安全问题。所谓线程安全是保证同一时间只有一个线程对该内存进行访问。只要我们使用 getter、setter 方法来访问，上面的表述中的每一个步骤都只有一条线程在访问该内存，哪个线程会获得锁完全取决于代码顺序，这个崩溃就是程序员自身的问题了。如果绕开 getter、setter 方法访问这个属性，才会造成线程不安全，比如使用 KVC。 一、atomic 是绝对安全的在 64 位的操作系统下，所有类型的指针(包括 void *)都是占用 8 个字节的。超过 4 个字节的基本类型数据都会有线程并发的问题。 那所有的指针类型都会有这个问题。 以 Objective-C 的 NSArray * 为例子，如果一个多线程操作这个数据，会有两个层级的并发问题： ①、指针本身 ②、指针所指向的内存 指针本身也是占用内存的，并且一定是 8 个字节。第二部分，指针所指向的内存，有可能非常大，有可能也就 1 个字节。 所以考虑 NSArray * array 这个数据在进行多线程操作的时候，必须分成两部分来描述，一个是 &amp;array 这个指针本身，另一个则是它所指向的内存 array。想象现在有两块内存，一块是 8 字节，一块 n 字节，8 字节里面放的值，就是 n 字节内存的首地址。 如果用 atomic 修饰之后，会有什么影响？ 从内存的角度来解释这个过程。atomic 其实修饰的是这个指针 &amp;array，与指针指向的第二部分 n 字节数据没有任何关系，被atomic 修饰之后，你不可能随意去多线程操作这个 8 字节，但是对 8 字节里面所指向的 n 字节没有任何限制！ atomic 已经完美的履行了它的指责，你不可能对这个 8 字节进行无序的多线程操作，这就够了呀！有问题的是程序员，程序员并未对 n 字节做任何的限制。 二、NSMutableArray 本身是线程不安全的简单来说，线程安全就是多个线程访问同一段代码，程序不会异常、不 Crash。而编写线程安全的代码主要依靠线程同步。 1、不使用 atomic 修饰属性。原因有二： ①、atomic 的内存管理语义是原子性的，仅保证了属性的 setter 和 getter 方法是原子性的、线程安全的，但是属性的其他方法，如数组添加/移除元素等并不是原子操作，所以不能保证属性是线程安全的。 ②、atomic 虽然保证了 getter、setter 方法线程安全，但是付出的代价很大，执行效率要比 nonatomic 慢很多倍(有说法是慢 10-20 倍)。 总之：使用 nonatomic 修饰 NSMutableArray 对象就可以了，而使用锁、dispatch_queue 来保证 NSMutableArray 对象的线程安全。 2、打造线程安全的 NSMutableArray 在《Effective Objective-C 2.0..》书中第 41 条：多用派发队列，少用同步锁中指出：使用“串行同步队列”(serial synchronization queue)，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD 的栅栏块(barrier)来不仅实现数据同步线程安全，还比串行同步队列方式更高效。 GCD 的栅栏块作用示意图 说明：栅栏块单独执行，不能与其他块并行。直到当前所有并发块都执行完毕，才会单独执行这个栅栏块 线程安全实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@interface QSThreadSafeMutableArray()@property (nonatomic, strong) NSMutableArray * MDataArray;@property (nonatomic, strong) dispatch_queue_t MSyncQueue;@end@implementation QSThreadSafeMutableArray- (instancetype)initCommon&#123; if (self = [super init]) &#123; // %p 以 16 进制的形式输出内存地址，附加前缀 0x NSString * uuid = [NSString stringWithFormat:@\"com.jzp.array_%p\", self]; // 注意：_MSyncQueue 是并行队列 _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT); &#125; return self;&#125;- (instancetype)init&#123; if (self = [self initCommon]) &#123; _MDataArray = [NSMutableArray array]; &#125; return self;&#125;- (id)objectAtIndex:(NSUInteger)index&#123; __block id obj; dispatch_sync(_MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; obj = _MDataArray[index]; &#125; &#125;); return obj;&#125;- (NSEnumerator *)objectEnumerator&#123; __block NSEnumerator * enu; dispatch_sync( _MSyncQueue, ^&#123; enu = [_MDataArray objectEnumerator]; &#125;); return enu;&#125;- (void)insertObject:(id)anObject atIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray insertObject:anObject atIndex:index]; &#125; &#125;);&#125;- (void)addObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if(anObject)&#123; [_MDataArray addObject:anObject]; &#125; &#125;);&#125;- (void)removeObjectAtIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; [_MDataArray removeObjectAtIndex:index]; &#125; &#125;);&#125;- (void)removeLastObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; [_MDataArray removeLastObject]; &#125;);&#125;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray replaceObjectAtIndex:index withObject:anObject]; &#125; &#125;);&#125;- (NSUInteger)indexOfObject:(id)anObject&#123; __block NSUInteger index = NSNotFound; dispatch_sync( _MSyncQueue, ^&#123; for (int i = 0; i &lt; [_MDataArray count]; i ++) &#123; if ([_MDataArray objectAtIndex:i] == anObject) &#123; index = i; break; &#125; &#125; &#125;); return index;&#125;- (void)dealloc&#123; if (_MSyncQueue) &#123; _MSyncQueue = NULL; &#125;&#125;@end 说明 ①：使用 dispatch queue 实现线程同步；将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，又不会阻塞执行异步派发的线程；使用同步队列及栅栏块，可以令同步行为更加高效。 说明 ②：NSMutableDictionary 本身也是线程不安全的，实现线程安全的 NSMutableDictionary 原理同线程安全的NSMutableArray。(代码见 QSUseCollectionDemo) 3、线程安全的 NSMutableArray 使用 123456789101112131415161718192021- (void)testQsMutableArray&#123; _MSafeArray = [[QSThreadSafeMutableArray alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (NSInteger i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSString * str = [NSString stringWithFormat:@\"数组%d\", (int)i+1]; [_MSafeArray addObject:str]; &#125;); &#125; sleep(1); NSEnumerator * enu = [_MSafeArray objectEnumerator]; for (NSObject * object in enu) &#123; NSLog(@\"value: %@\", object); &#125;&#125; 三、atomic 与 nonatomic 的区别在默认情况下，由编译器生成的属性的 set、get 方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不需要同步锁。 尽管没有指明 atomic 的特质（如果某属性不具备 nonatomic 特质，那它就是”原子的”(atomic)），仍然可以在属性特质中写明这一点，编译器是不会报错的。 一般 iOS 程序中，所有属性都声明为 nonatomic。这样做的原因是： ①、在 iOS 中使用同步锁的开销比较大， 会带来性能问题。 ②、一般情况下并不要求属性必须是”原子的”，因为这并不能保证线程安全。若要实现线程安全的操作，还需采用更为深层的锁的机制。 一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic 也还是会读取到不同的属性值。 因此，iOS 程序一般都会使用 nonatomic 属性。但在 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。 nonatomic 的实现： 12345678910111213- (void)setImage:(UIImage *)image&#123; if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125;&#125;- (UIImage *)image&#123; return _image;&#125; atomic 的实现： 123456789101112131415161718- (void)setImage:(UIImage *)image&#123; @synchronized(self) &#123; // 锁 if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125; &#125;&#125;- (UIImage *)image&#123; @synchronized(self) &#123; return _image; &#125;&#125; @synchronized 的介绍： The @synchronized directive is a convenient way to create mutex locks on the fly in Objective-C code. The @synchronized directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example: - (void)myMethod:(id)anObj{ @synchronized(anObj) { // Everything between the braces is protected by the @synchronized directive. } } The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the anObj parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section. As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes. For more information about the @synchronized directive, see The Objective-C Programming Language. 更准确的说应该是读写安全，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。","tags":[]},{"title":"malloc","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/malloc/","text":"原文：iOS内存管理和malloc源码解读 在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。 与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？ 和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。 如上所述，iOS 在外存没有交换区，没有内存页换出的过程。 一、malloc 基本原理在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。 创建新对象 [NSObject alloc]; 释放对象 [Object release]; 而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。 从苹果公开的 malloc 源码上来看，它的原理大致如下： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone。在 64 位环境下，会初始化 default zone 为 nano zone，同时初始化一个 scalable zone 作为 helper zone。nano zone 负责 nano 大小的分配，scalable zone 则负责 tiny、small 和 large内存的分配。 每次 malloc 时，根据传入的 size 参数，优先交给 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。 二、nano malloc在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为Magazine、Band 和 Slot 几个级别。 Magazine 范围对应于 CPU，CPU0 对应 Mag0，CPU1 对应 Mag1，依次类推 Band 范围为 2M，连续内存分配当内存不够时以 Band 为单位向内核请求 Slot 则对应于每个 Band 中 128K 大小的范围，每个 Band 都分为 16 个 Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配 分配过程： 确定当前 cpu 对应的 mag 和通过 size 参数计算出来的 slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 Band 中当前 Slot 耗尽则向系统申请新的 Band(每个 Band 固定大小 2M，容纳了 16 个 128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是 16 个)的二维数组形式，放在 nanozone_t 的 meta_data 字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。 除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data上挂着的空闲链表上内存区块回收来完成。 三、scalable zone 上内存分配简要分析对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。 在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为-1 的 magazine 作为后备之用。 下面是一个简图。 分配时(以 tiny 的情况为例)： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。这里需要注意的是，在一般情况下 free list 分为 64 个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63 为所有更大的内存区块挂载的地方。 上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。 如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 要是再不行就没招了，系统也给不到内存，就报错返回。 free 时： 检查指针指向地址是否有问题。 如果 last free 指针上没有挂载内存区块，则放到 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上(在挂载的 free list 前，会先根据 region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。 合并后所在的 region 如果空闲字节超过一定条件，则将把此 region 放到后备的 magazine 中(-1)。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。","tags":[]},{"title":"iOS 证书","date":"2019-05-22T08:51:44.499Z","path":"2019/05/22/iOS 证书/","text":"一、引言 什么是 App ID？Explicit/Wildcard App ID 有何区别？什么是 App Group ID？ 什么是证书（Certificate）？如何申请？有啥用？ 什么是Key Pair（公钥/私钥）？有啥用？与证书有何关联？ 什么是签名（Signature）？如何签名（CodeSign）？怎样校验（Verify）？ 什么是（Team）Provisioning Profiles？有啥用？ Xcode如何配置才能使用iOS真机进行开发调试？ 多台机器如何共享开发者账号或证书？ 遇到证书配置问题怎么办？ Xcode 7免证书调试真机调试 二、App ID（bundle identifier） App ID 即 Product ID，用于标识一个或者一组 App。 App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。 App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。 App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类： Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。 Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“*”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.*”可以表示Bundle Identifier以“com.apple.”开头的所有应用程序。 用户可在Developer MemberCenter网站上注册或删除已注册的App IDs。 App ID 被配置到【Target-&gt;Info-&gt;Bundle Identifier】下；对于 Wildcard App ID，只要 bundle identifier 包含其作为 Prefix/Seed 即可。 三、设备（Device） Device 就是运行 iOS 系统用于开发调试 App 的设备。每台Apple设备使用 UDID 来唯一标识。 iOS设备连接Mac后，可通过 iTunes-&gt;Summary 或者 Xcode-&gt;Window-&gt;Devices 获取 iPhone 的 UDID。 Apple Member Center 网站个人账号下的 Devices 中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册 100 个设备。 Apps signed by you or your team run only on designated development devices. Apps run only on the test devices you specify. 用户可在网站上注册或启用/禁用（Enable/Disable）已注册的 Device。本文的 Devices 是指连接到 Xcode 被授权用于开发测试的 iOS 设备（iPhone/iPad）。 四、开发证书（Certificates）4.1 证书 证书是由公证处或认证机关开具的证明资格或权力的证件，它是表明（或帮助断定）事理的一个凭证。证件或凭证的尾部通常会烙印公章。 每个中国人一生可能需要 70 多个证件，含 15 种身份证明。 4.2 数字证书 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在 Internet 上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。 它是由一个由权威机构——CA机构，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。 数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。 数字证书中的公开密钥（公钥）相当于公章。 某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。 为了防止 GFW 进行中间人攻击(MitM)，例如篡改 github 证书，导致无法访问 github 网站等问题，可选择不信任根证书。 在【钥匙串】中输入 ROOT 进行搜索，可以找到很多根证书，在【简介】|【使用此证书时】下拉选择【永不信任】。 4.3 iOS（开发）证书 iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。 iOS证书分为两类：Development 和 Production（Distribution）。 Development 证书用来开发和调试应用程序：A development certificate identifies you, as a team member, in a development provisioning profile that allows apps signed by you to launch on devices. Production 主要用来分发应用程序（根据证书种类有不同作用）：A distribution certificate identifies your team or organization in a distribution provisioning profile and allows you to submit your app to the store. Only a team agent or an admin can create a distribution certificate. 普通个人开发账号最多可注册 iOS Development/Distribution 证书各 2 个，用户可在网站上删除（Revoke）已注册的Certificate。 下文主要针对 iOS App 开发调试过程中的开发证书（Certificate for Development）。 4.4 iOS（开发）证书的根证书那么，iOS 开发证书是谁颁发的呢？或者说我们是从哪个 CA 申请到用于 Xcode 开发调试 App 的证书呢？ iOS 以及 Mac OS X 系统（在安装 Xcode 时）将自动安装 AppleWWDRCA.cer 这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。 AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer 之于 iOS（开发）证书则好比户籍证之于身份证。 如果 Mac Keychain Access 证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。 4.5 申请证书（CSR：Certificate Signing Request）可以在缺少证书时通过 Xcode Fix Issue 自动请求证书，这里通过 Keychain 证书助理从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。 keychain 将生成一个包含开发者身份信息的 CSR（Certificate Signing Request）文件；同时，Keychain Access|Keys 中将新增一对 Public/Private Key Pair（This signing identity consists of a public-private key pair that Apple issues）。 private key始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）对外发布的 App；public key一般随证书（Provisioning Profile）散布出去，对 App 签名进行校验认证。用户必须保护好本地 Keychain 中的 private key，以防伪冒。 Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an entirely new identity to sign code. Worse, if someone else has your private key, that person may be able to impersonate you. 在 Apple 开发网站上传该 CSR 文件来添加证书（Upload CSR file to generate your certificate）： Apple 证书颁发机构 WWDRCA(Apple Worldwide Developer Relations Certification Authority) 将使用private key 对 CSR 中的 public key 和一些身份信息进行加密签名生成数字证书（ios_development.cer）并记录在案（Apple Member Center）。 从 Apple Member Center 网站下载证书到 Mac 上双击即可安装（当然也可在 Xcode 中添加开发账号自动同步证书和【生成】配置文件）。证书安装成功后，在 KeychainAccess|Keys 中展开创建 CSR 时生成的 Key Pair 中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在 Keychain Access|Certificates 中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。 Certificate 被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Identity】下，下拉选择 Identities from Profile。 五、供应配置文件（Provisioning Profiles）5.1 Provisioning Profile的概念 Provisioning Profile文件包含了上述的所有内容：证书、App ID 和设备。 一个 Provisioning Profile 对应一个 Explicit App ID 或 Wildcard App ID（一组相同Prefix/Seed的App IDs）。 在网站上手动创建一个Provisioning Profile时，需要依次指定 App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的 Provisioning Profiles。 Provisioning Profile 决定 Xcode 用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product），将在应用程序打包时嵌入到 .ipa 包里。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备也通过它来认证安装的程序。 如果要打包或者在真机上运行一个APP，一般要经历以下三步： 首先，需要指明它的 App ID，并且验证 Bundle ID 是否与其一致； 其次，需要证书对应的私钥来进行签名，用于标识这个 APP 是合法、安全、完整的； 然后，如果是真机调试，需要确认这台设备是否授权运行该 APP。 Provisioning Profile 把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。 Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited），App ID 为 Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。 Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录 ~/Library/MobileDevice/Provisioning Profiles 下。 5.2 Provisioning Profile的构成以下为典型供应配置文件 *.mobileprovision 的 构成简析： （1）Name：该mobileprovision的文件名。（2）UUID：该mobileprovision文件的真实文件名。（3）TeamName：Apple ID账号名。（4）TeamIdentifier：Team Identity。（5）AppIDName：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。（6）ApplicationIdentifierPrefix：完整 App ID 的前缀（TeamIdentifier.*）。（7）DeveloperCertificates：包含了可以为使用该配置文件应用签名的所有证书。 证书是基于 Base64 编码，符合 PEM（PrivacyEnhanced Mail, RFC 1848）格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。 从 DeveloperCertificates 提取之间的内容到文件cert.cer（cert.perm）： —–BEGIN CERTIFICATE—– 将之间的内容拷贝至此 —–END CERTIFICATE—– Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥 KeyPair 配对）应吻合；Windows 下没有足够信息（WWDRCA.cer），无法验证该证书。 如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。 （8）Entitlements键对应的： keychain-access-groups：$(AppIdentifierPrefix)，参见Code Signing Entitlements(*.entitlements)。 每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的 keychain，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。 application-identifier：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。 com.apple.security.application-groups：App Group ID（group. com.apple），参见Code Signing Entitlements(*.entitlements)。 com.apple.developer.team-identifier：同Team Identifier。 （9）ProvisionedDevices：该mobileprovision授权的开发设备的UDID 。 Provisioning Profile 被配置到【XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。 六、开发组供应配置文件（Team Provisioning Profiles）6.1 Team Provisioning Profile的概念每个Apple开发者账号都对应一个唯一的 Team ID， Xcode3.2.3 预发布版本中加入了Team Provisioning Profile这项新功能。 在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑自动生成iOS Team Provisioning Profile（Managed by Xcode）。 Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(*)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。 6.2 Team Provisioning Profile生成/更新时机 Add an Apple ID account to Xcode Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode Assign Your App to a Team in Xcode project settings of General|Identity Register new device on the apple development website or Xcode detected new device connected 利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。 Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也被配置到【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。 七、App Group（ID）7.1 App Group的概念WWDC14除了发布了OS X v10.10和 Swift 外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。 扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。 App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。 7.2 App Group的配置Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范： 置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard） Extension App ID以Containing App ID为Prefix/Seed 假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.extImportRecording”。 关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。 App Group会被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。 八、证书与签名（Certificate&amp; Signature）8.1 Code Signing Identity Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。 Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性： 若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信； 再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。 8.2 Code Signing每个证书（其实是公钥）对应Key Pair中的私钥会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字签名（CodeSign）——使用哈希算法生成内容摘要（digest）。 Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。 8.3 Verify Code Signature with Certificate上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。 第一步，App在Mac／iOS真机上启动时，需要对配置的bundle ID、entitlements和certificate与Provisioning Profile进行匹配校验： 第二步，iOS/Mac真机上的ios_development.cer被AppleWWDRCA.cer中的 public key解密校验合法后，获取每个开发证书中可信任的公钥对App的可靠性和完整性进行校验。 iOS/Mac设备（系统）使用App Provisioning Profile （Code Signing Identity） 中的开发证书来判断App的合法性： 若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信； 再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。 小结： 基于Provisioning Profile校验了CodeSign的一致性； 基于Certificate校验App的可靠性和完整性； 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。 九、在多台机器上共享开发账户/证书9.1 Xcode导出开发者账号(*.developerprofile)或PKCS12文件(*.p12)进入Xcode Preferences|Accounts： 选中Apple IDs列表中对应Account的的Email，点击+-之后的☸|Export Accounts，可导出包含account/code signing identity/provisioning profiles信息的*.developerprofile（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。 选中右下列表中某行Account Name条目|ViewDetails，可以查看Signing Identities和Provisioning Profiles。 选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权export key “privateKey” from keychain，将导出Certificates.p12。** 点击左下角的刷新按钮可从Member Center同步该账号下所有的Provisioning Profile到本地。 选中右击列表中某个Provisioning Profile可以【Show in Finder】到[~/Library/MobileDevice/Provisioning\\ Profiles]目录，其中Provisioning Profile的真实名称为$(UUID).mobileprovision，名如”2488109f-ff65-442e-9774-fd50bd6bc827.mobileprovision”，其中Name中为Xcode中看到的描述性别名。 9.2 Keychain Access导出PKCS12文件(*.p12)在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出Certificates.p12——PKCS12 file holds the private key and certificate。 其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书。有了共享证书之后，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件，方可在iOS真机设备上开发调试。 十、证书配置常见错误 no such provisioning profile was found Xcode Target -&gt; Genera -&gt; Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.” Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioning profile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！ No identities from profile Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioning profile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain. Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（.developerprofile）或共享证书(.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。 Code Signing Entitlements file do not match profile “Invalid application-identifier Entitlement“ or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).” （1） 检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。（2） 也可以将Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。 Xcode配置反应有时候不那么及时 可刷新、重置相关配置项开关（若有）或重启Xcode试试。 十一、Xcode7 免证书真机调试在 Xcode 7 中，苹果改变了自己在许可权限上的策略： 此前 Xcode 只开放给注册开发者下载，现在 Xcode 7 改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。 此前开发者需每年支付99美元的费用成为注册开发者才能在 iPhone/iPad 真机上运行调试APP，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。——Developers would be able to test apps on devices without a paid Apple developer account in Xcode 7. 所谓“免证书”真机调试，并不是真的不需要证书，Xcode真机调试原有的证书配置体系仍在——All iOS, tvOS, and watchOS apps must be code signed and provisioned to launch on a device. 所以，上文啰嗦几千字还是有点用的。 自 Xcode7 开始，原来基于付费开发者账号及自助生成证书及配置文件的繁琐过程被苹果简化，Xcode将针对任何普通账号自动为联调真机生成所需相关的证书及配置文件。当你打算向 App Store 提交发布应用，才需要付费。 第一步：进入 Xcode Preferences|Accounts，添加自己的 Apple ID 账号。 第二步：Build Settings|Code Signing 下的 Provisioning Profile 选择 Automatic，Code Signing Identity 选择 Automatic 下的iOS Developer。 第三步：General 配置 Bundle identifier，Team 下拉选择苹果Member Center自动为你的账号生成的Personal Team ID。 自己的账号在调试公司或其他第三方APP代码时，若填写 Bundle identifier 为他人账号注册的 APP ID（例如苹果相机应用 com.apple.camera），会报错： No provisioning profiles with a valid signing identity (i.e. certificate and private key pair) matching the bundle identifier “com.apple.camera” were found. 即使编译通过了，可能运行时APP自身与服务器校验也可能会报签名错误，肿么办？？？ Her skill：此时，可以在他人原有App ID基础上添加后缀（例如com.apple.camera.extension），配置成应用的衍生插件（相当于置于同一 App Group 下）就可以快乐的玩耍了。 如果启动APP时，Xcode报错“process launch failed: Security”或iPhone报错【不受信任的开发者】，此时需要到iPhone通用配置中的描述文件（最新系统中可能叫设备管理）中，在描述文件（开发商应用）中选择对应的描述文件（你的Apple ID）点击 信任 或 验证 即可。 十二、推送证书APNS远程推送证书的申请和制作——详细解析APNS推送服务证书制作 图文详解教程 十三、学习文章《iOS开发各种证书问题》《iPhone真机调试应用程序》《iOS Developer：真机测试》《Xcode5 &amp; iOS 7 及以下版本免证书真机调试记录》《iOS Development–Certificates, Provisioning Profiles》《关于Certificate、Provisioning Profile、App ID的介绍及其关系》《数字签名和数字证书》《iOS keyChain 研究》《苹果开发者账号那些事儿》《iOS关于Provisioning Profiles這些事》《iOS Code Signing 学习笔记》《代码签名探析/Inside Code Signing》《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》《iOS行货自动打包》《解决Xcode无法生成Archive的问题》《iOS程序完成后如何生成ipa进行真机测试》《发布iOS应用程序(Application Loader)》《iOS发布遇到的一些问题》《Xcode打包ipa包》《iOS程序生成ipa进行真机测试》","tags":[]},{"title":"iOS Push","date":"2019-05-22T06:31:14.236Z","path":"2019/05/22/iOS Push/","text":"1、前言早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。 2、push流程 Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。 上图可以分为三个阶段：①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。 从上图可以看到： ①、在程序上注册远程通知，这是通知的前提（程序员的工作）；1234 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];&#125; ②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；123456789101112-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;#if !TARGET_IPHONE_SIMULATOR //注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做） self.deviceToken = [[[[devToken description] stringByReplacingOccurrencesOfString:@\"&lt;\"withString:@\"\"] stringByReplacingOccurrencesOfString:@\"&gt;\" withString:@\"\"] stringByReplacingOccurrencesOfString: @\" \" withString: @\"\"];#endif // 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送 [JPUSHService registerDeviceToken:devToken];&#125; ④、将这个 token 值发送到公司的服务器上去，存储下来。⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。 3、APNs的限制APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： 可靠性。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 Payload Size。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 成功率并不高。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。 4、不仅仅是Local Push很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。 Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。 5、叫醒你的App开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。 唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。 6、前台消息通道大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在12345678// iOS 10 Support- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123;&#125; 也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。 7、PushKitAPNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。 之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。 当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。 微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。 8、总结关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。 9、学习文章MrPeak杂货铺 &amp; iOS Push的门道Silent Push实现PushKit实现APNS推送服务证书制作 图文详解教程APNS远程推送证书的申请和制作——详细解析","tags":[]},{"title":"iOS 时间","date":"2019-05-21T08:15:20.020Z","path":"2019/05/21/iOS 时间/","text":"1、时间的形式在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。 1.1、GMT人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。 前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。 1.2、UTC太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。 我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。 接下来看下iOS里，五花八门的记录时间的方式。 2、NSDateNSDate是我们平时使用较多的一个类，先看下它的定义： NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001). NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。 这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。 理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：12NSDate* date = [NSDate date];NSLog(@\"current date interval: %f\", [date timeIntervalSinceReferenceDate]); timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。 又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：12NSDate* date = [NSDate date];NSLog(@\"current date: %@\", date); current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。 NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。 另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。 3、CFAbsoluteTimeGetCurrent()官方定义如下： Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock. 从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。 同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。 4、gettimeofday这个API也能返回一个描述当前时间的值，代码如下：1234struct timeval now;struct timezone tz;gettimeofday(&amp;now, &amp;tz);NSLog(@\"gettimeofday: %ld\", now.tv_sec); 使用gettimeofday获得的值是Unix time。Unix time又是什么呢？ Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。 Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：1date -r 1481266031 实际上NSDate也有一个API能返回Unix time：12NSDate* date = [NSDate date];NSLog(@\"timeIntervalSince1970: %f\", [date timeIntervalSince1970]); gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。 5、mach_absolute_time()mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。 前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。 不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。 mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。 6、CACurrentMediaTime()CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：123/* Returns the current CoreAnimation absolute time. This is the result of * calling mach_absolute_time () and converting the units to seconds. */CFTimeInterval CACurrentMediaTime (void) CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：12double mediaTime = CACurrentMediaTime();NSLog(@\"CACurrentMediaTime: %f\", mediaTime); 返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：12NSTimeInterval systemUptime = [[NSProcessInfo processInfo] systemUptime];NSLog(@\"systemUptime: %f\", systemUptime); CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。 7、sysctliOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：123456789101112131415161718#include &lt;sys/sysctl.h&gt;- (long)bootTime&#123;#define MIB_SIZE 2 int mib[MIB_SIZE]; size_t size; struct timeval boottime; mib[0] = CTL_KERN; mib[1] = KERN_BOOTTIME; size = sizeof(boottime); if (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, 0) != -1) &#123; return boottime.tv_sec; &#125; return 0;&#125; 返回的值是上次设备重启的Unix time。 这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。 有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。 8、场景一，时间测量我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。 在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。 客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。 上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：1234567891011121314151617int testCount = 10000;double avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; NSDate* begin = [NSDate date]; NSLog(@\"a meaningless log\"); avgCost += -[begin timeIntervalSinceNow];&#125;NSLog(@\"benchmark with NSDate: %f\", avgCost/testCount);avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; double startTime = CACurrentMediaTime(); NSLog(@\"a meaningless log\"); double endTime = CACurrentMediaTime(); avgCost += (endTime - startTime);&#125;NSLog(@\"benchmark with CACurrentMediaTime: %f\", avgCost/testCount); 输出结果为：12benchmark with NSDate: 0.000046benchmark with CACurrentMediaTime: 0.000037 可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：12#define TICK NSDate *startTime = [NSDate date]#define TOCK NSLog(@\"Time Cost: %f\", -[startTime timeIntervalSinceNow]) 9、场景二：客户端和服务器之间的时间同步这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。 比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？ 上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。 首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：1234567uint64_t realLocalTime = 0;if (serverTime != 0 &amp;&amp; lastSyncLocalTime != 0) &#123; realLocalTime = serverTime + (curLocalTime - lastSyncLocalTime);&#125;else &#123; realLocalTime = [[NSDate date] timeIntervalSince1970]*1000;&#125; 如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。 关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：1234567891011121314151617181920//get system uptime since last boot- (NSTimeInterval)uptime&#123; struct timeval boottime; int mib[2] = &#123;CTL_KERN, KERN_BOOTTIME&#125;; size_t size = sizeof(boottime); struct timeval now; struct timezone tz; gettimeofday(&amp;now, &amp;tz); double uptime = -1; if (sysctl(mib, 2, &amp;boottime, &amp;size, NULL, 0) != -1 &amp;&amp; boottime.tv_sec != 0) &#123; uptime = now.tv_sec - boottime.tv_sec; uptime += (double)(now.tv_usec - boottime.tv_usec) / 1000000.0; &#125; return uptime;&#125; gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。 多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。 10、学习文章MrPeak杂货铺iOS倒计时的探究与选择","tags":[]},{"title":"hexo+pages建站","date":"2019-05-14T07:42:50.947Z","path":"2019/05/14/hexo+pages建站/","text":"hexo史上最全搭建教程 解决用Hexo和GitHub搭建博客时hexo d命令报错问题 hexo d后 ERROR Deployer not found: git git-ssh 配置和使用 给博客添加文章目录 https://hexo.io/zh-cn/ Hexo博客多台电脑设备同步管理","tags":[]}]