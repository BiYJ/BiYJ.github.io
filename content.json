[{"title":"iOS 编译过程原理(2)","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS 编译过程原理(2)/","text":"原文：黄文臣/深入浅出iOS编译 一、前言《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚： Clang 和 LLVM 究竟是什么 源文件到机器码的细节 Linker 做了哪些工作 编译顺序如何确定 头文件是什么？XCode 是如何找到头文件的？ Clang Module 签名是什么？为什么要签名 为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。 二、编译器 把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做编译器。 大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swift，后端都是 LLVM。 三、LLVMLLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。 LLVM 的核心库提供了现代化的 source-target-independent 优化器和支持诸多流行 CPU 架构的代码生成器，这些核心代码是围绕着 LLVM IR（中间代码）建立的。 基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。 四、clangclang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程： 接下来，从代码层面看一下具体的转化过程，新建一个 main.c： 123456789101112#include &lt;stdio.h&gt;#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\\\n\");#else printf(\"hello world\\\\n\");#endif return 0;&#125; 五、预处理（preprocessor）预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。 #include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，这个过程是递归的：因为 stdio.h 也有可能包含其他头文件。 用 clang 查看预处理的结果： 1$ xcrun clang -E main.c 预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。 123456789101112131415$ xcrun clang -E main.c......extern int __vsnprintf_chk (char * restrict, size_t, int, size_t, const char * restrict, va_list);# 412 \"/usr/include/stdio.h\" 2 3 4# 10 \"main.c\" 2int main() &#123; printf(\"hello debug\\n\"); return 0;&#125; 可以看到，在预处理的时候，注释被删除，条件编译被处理。 六、词法分析（lexical anaysis）词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。 1$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 输出： 123456789101112131415161718192021222324$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.cannot_module_include '#include &lt;stdio.h&gt;// 一点注释#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\n\");#else printf' Loc=&lt;main.c:9:1&gt;int 'int' [StartOfLine] Loc=&lt;main.c:14:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.c:14:5&gt;l_paren '(' Loc=&lt;main.c:14:9&gt;r_paren ')' Loc=&lt;main.c:14:10&gt;l_brace '&#123;' [LeadingSpace] Loc=&lt;main.c:14:12&gt;identifier 'printf' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:16:5&gt;l_paren '(' Loc=&lt;main.c:16:11&gt;string_literal '\"hello debug\\n\"' Loc=&lt;main.c:16:12&gt;r_paren ')' Loc=&lt;main.c:16:27&gt;semi ';' Loc=&lt;main.c:16:28&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:20:5&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;main.c:20:12&gt;semi ';' Loc=&lt;main.c:20:13&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.c:21:1&gt;eof '' Loc=&lt;main.c:21:2&gt; Loc=\\main.c:9:1\\ 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。 七、语法分析（semantic analysis）词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。 1$ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f main 函数 AST 的结构： 123456789101112131415[0;1;32mTranslationUnitDecl\u001b[0m\u001b[0;33m 0x7fd9a18166e8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816c60\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __int128_t\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816980\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816cd0\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __uint128_t\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a18169a0\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816fa8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __NSConstantString\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mRecordType\u001b[0m\u001b[0;33m 0x7fd9a1816db0\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;1;32mRecord\u001b[0m\u001b[0;33m 0x7fd9a1816d28\u001b[0m\u001b[0;1;36m '__NSConstantString_tag'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817040\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __builtin_ms_va_list\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mPointerType\u001b[0m\u001b[0;33m 0x7fd9a1817000\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816780\u001b[0m \u001b[0;32m'char'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817308\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit referenced\u001b[0;1;36m __builtin_va_list\u001b[0m \u001b[0;32m'struct __va_list_tag [1]'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mConstantArrayType\u001b[0m\u001b[0;33m 0x7fd9a18172b0\u001b[0m \u001b[0;32m'struct ... 有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。 AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST。 八、CodeGenCodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。 1xcrun clang -S -emit-llvm main.c -o main.ll main.ll 文件内容： 12345678910111213141516; ModuleID = 'main.c'source_filename = \"main.c\"target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"target triple = \"x86_64-apple-macosx10.13.0\"@.str = private unnamed_addr constant [13 x i8] c\"hello debug\\0A\\00\", align 1; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 &#123; %1 = alloca i32, align 4 store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret i32 0&#125;... Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。 LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass。 九、生成汇编代码LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。 生成 arm 64 汇编： 1$ xcrun clang -S main.c -o main.s 查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：iOS汇编快速入门。 12345678910111213141516171819202122232425262728293031 .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp leaq L_.str(%rip), %rdi movl $0, -4(%rbp) movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz \"hello debug\\n\" .subsections_via_symbols 十、汇编器汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 1$ xcrun clang -fmodules -c main.c -o main.o 还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号 123$ xcrun nm -nm main.o (undefined) external _printf0000000000000000 (\\_\\_TEXT,\\_\\_text) external _main _printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。 10.1 什么是符号（Symbols）?符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。 十一、链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。 1$ xcrun clang main.o -o main 就得到了一个 mach o 格式的可执行文件 123456789101112$ file mainmain: Mach-O 64-bit executable x86_64$ ./mainhello debug再用 nm 命令，查看可执行文件的符号表：$ nm -nm main (undefined) external _printf (from libSystem) (undefined) external dyld\\_stub\\_binder (from libSystem)0000000100000000 (\\_\\_TEXT,\\_\\_text) \\[referenced dynamically\\] external \\_\\_mh\\_execute_header0000000100000f60 (\\_\\_TEXT,\\_\\_text) external _main _printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。 十二、XCode 编译通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？ 新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志： 详细的步骤： 创建 Product.app 的文件夹 把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。 创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。 执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。 编译 .m 文件，生成 .o 文件。 链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。 编译 assets，编译 storyboard，链接 storyboard 拷贝动态库 Logger.framework，并且对其签名 执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework 对 Demo.App 签名，并验证（validate） 生成 Product.app 生成 dYSM 文件 Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。 十三、编译顺序编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？ 答案是：依赖关系。 还是以刚刚的 Demo 项目为例，整个依赖关系如下： 可以从 XCode 的 Report Navigator 看到 Target 的编译顺序： XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。 那么，XCode 又从哪里得到了这些依赖关系呢？ Target Dependencies - 显式声明的依赖关系 Linked Frameworks and Libraries - 隐式声明的依赖关系 Build Phase - 定义了编译一个 Target 的每一步 十四、增量编译日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？ 因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。 比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。 十五、头文件C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。 头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。 当只有声明，没有实现的时候，链接器就会报错。 12345Undefined symbols for architecture arm64:“_umimplementMethod”, referenced from:-\\[ClassA method\\] in ClassA.old: symbol(s) not found for architecture arm64clang: error: linker command failed with exit code 1 (use -v to see invocation) Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。 日常开发中，两种常见的头文件引入方式： 12#include \"CustomClass.h\" // 自定义#include &lt;Foundation/Foundation.h&gt; // 系统或者内部 framework 引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？ 回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志： 把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的： 12345678910111213141516171819#include \"...\" search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap) /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers #include &lt;...&gt; search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources /Users/.../Build/Products/Debug-iphoneos (framework directory) /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory) /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory) /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include $SDKROOT/usr/include $SDKROOT/System/Library/Frameworks (framework directory) End of search list. 这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。 可以通过一个辅助的小工具 hmap 查看 hmap 中的内容： 1234567$ ./hmap print Demo-project-headers.hmap AppDelegate.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.hDemo-Bridging-Header.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.hDummy.h -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.hFramework.h -&gt; Framework/Framework.hTestView.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.hViewController.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h 这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。 clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找： 12/Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/TestView.h/Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers/TestView.h 系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。 以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时： 首先查找 framework 是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework 如果 framework 存在，再在 headers 目录里查找头文件是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework/headers/Foundation.h 十六、Clang Module传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的： 大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。 文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。 边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。 clang module 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。 XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。 #import &lt;Foundation/NSString.h&gt; 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。 那么，如何定义一个 module 呢？答案是：modulemap 文件，这个文件描述了一组头文件如何转换为一个 module，举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546framework module Foundation \\[extern_c\\] \\[system\\] &#123; umbrella header \"Foundation.h\" // 所有要暴露的头文件 export * module * &#123; export * &#125; explicit module NSDebug &#123; //submodule header \"NSDebug.h\" export * &#125; &#125;``` swift 是可以直接 import 一个 clang module 的，比如你有一些 C 库，需要在 Swift 中使用，就可以用 modulemap 的方式。## 十七、Swift 编译现代化的语言几乎都抛弃了头文件，swift 也不例外。问题来了，swift 没有头文件又是怎么找到声明的呢？&gt; 编译器干了这些脏活累活。编译一个 Swift 头文件，需要解析 module 中所有的 Swift 文件，找到对应的声明。![29](https://upload-images.jianshu.io/upload_images/5294842-bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)当开发中难免要有 Objective-C 和 Swift 相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？### 17.1 Swift 引用 Objective-CSwift 的编译器内部使用了 clang，所以 swift 可以直接使用 clang module，从而支持直接 import Objective-C 编写的framework。![30](https://upload-images.jianshu.io/upload_images/5294842-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) swift 编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：* Bridging-Header.h 中暴露给 swfit 的头文件* framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。XCode 提供了宏定义 NS\\_SWIFT\\_NAME 来让开发者定义 Objective-C =&gt; Swift的符号映射，可以通过 Related Items -&gt; Generate Interface 来查看转换后的结果：![31](https://upload-images.jianshu.io/upload_images/5294842-bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 17.2 Objective-C 引用 swiftxcode 会以 module 为单位，为 swift 自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-Swift.h。swift 提供了关键词 @objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。 @objc public class MyClass12345678910111213141516171819## 十八、深入理解 Linker&gt; &lt;font color=#cc0000&gt;链接器会把编译器编译生成的多个文件，链接成一个可执行文件&lt;/font&gt;。链接并不会产生新的代码，只是在现有代码的基础上做&lt;font color=#cc0000&gt;移动和补丁&lt;/font&gt;。链接器的输入可能是以下几种文件：* object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。* 动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载* 静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。* tbd，只包含符号的库文件这里提到了一个概念：符号（Symbols），那么符号是什么呢？&gt; 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。以一段代码为例，看看链接时究竟发生了什么？源代码： (void)log{ printf(“hello world\\n”);}12.o 文件： #代码adrp x0, l.str@PAGEadd x0, x0, l.str@PAGEOFFbl _printf #字符串符号l_.str: ; @.str .asciz “hello world\\n”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172在 .o 文件中，字符串 \"hello world\\\\n\" 作为一个符号（l\\_.str）被引用，汇编代码读取的时候按照 l\\_.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：1. l_.str 在可执行文件的哪个位置？2. printf 函数来自哪里？再来看看链接之后的 mach o 文件：![32](https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)链接器如何解决这两个问题呢？1. 链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。2. 链接后，不再是调用符号 \\_printf，而是在 DATA 段上创建了一个函数指针 \\_printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 _printf 地址。更多细节，可以参考这篇文章：[深入理解iOS App的启动过程](https://blog.csdn.net/Hello_Hwc/article/details/78317863)。Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。## 十九、理解签名### 19.1 基础回顾非对称加密在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。数字签名数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。![33](https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。![34](https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。&gt; 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。## 二十、iOS App 签名为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。除此之外，Apple 要严格控制 App 的分发：1. App 来自 Apple 信任的开发者2. 安装的设备是 Apple 允许的设备### 20.1 证书通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。![35](https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.2 Provisioning ProfileiOS App 安装到设备的途径（非越狱）有以下几种：* 开发包（插线，或者 archive 导出 develop 包）* Ad Hoc* App Store* 企业证书开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。![36](https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)可以通过以下命令来查看 Provisioning Profile 中的内容： security cms -D -i embedded.mobileprovision &gt; result.plistopen result.plist12345678910本质上就是一个编码过后的 plist。![37](https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.3 iOS 签名生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名 Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nibT2g5jlq7EVFHNzL/ip3fSoXKoOI= Info.plist5aVg/3m4y30m+GSB8LkZNNU3mug= PkgInfon57qDP4tZfLD1rCS43W0B4LQjzE= embedded.mobileprovisiontm/I1g+0u2Cx9qrPJeC0zgyuVUE=…` 代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名： 20.4 验证20.4.1 安装 App 的时候 从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者 证书验证通过后，从证书中取出 Leo 的公钥 读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确 文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证） 验证通过后，安装 App 20.4.2 启动 App 的时候 验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致 判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证 如果是企业证书，验证用户是否信任企业证书 App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。 以上都验证通过，App 才能正常启动","tags":[]},{"title":"iOS 内存管理：从 MRC 到 ARC 实践","date":"2019-05-23T09:43:10.193Z","path":"2019/05/23/iOS 内存管理：MRC、ARC/","text":"对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。 iOS 内存管理的核心是引用计数。 接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？ 同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？ 12NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding]; 属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。 12self.name = @\"qqstock\"; _name = @\"qqstock\"; 一、MRC 的初衷和实现方式苹果为什么要做这个？ 首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。 当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。 尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了。要么，自己写许许多多的代码，频繁对容器进行主动操作。 于是，苹果要解决这个问题。初衷就是：任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责。 苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。 与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。 另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。” 那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。 OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。 二、MRC 的优点和无奈总结： MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题 为了应对各种复杂的场景，很无奈的留了一个口子； 两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。 难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。 略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。 系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！ 引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。 再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。 三、编程语言和编译器的发展方向由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。 然而，编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？ 许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？ 更何况，人，总有打盹的时候。 四、ARC 的适时推出随着硬件的升级，条件已经成熟了，ARC 到来了！ ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。 之前对 C++ 程序员头疼的问题变得异常简单： 1234NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding];self.name = @\"qqstock\";_name = @\"qqstock\"; 到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。 许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。 逻辑其实很简单。 首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低； 其次，一旦出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。 总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！ 五、总结如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。 许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。 ①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。 ②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。 ③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。 ④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。","tags":[]},{"title":"iOS 内存监控","date":"2019-05-23T09:27:05.583Z","path":"2019/05/23/iOS 内存监控/","text":"一、导读目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于 App 上线后发现内存问题。 FOOM(Foreground Out Of Memory) 是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。Facebook 早在 2015 年 8 月提出 FOOM 检测办法。 微信自 15 年年底上线 FOOM 上报，从最初数据来看，每天 FOOM 次数与登录用户数比例接近 3%，同期 crash 率 1% 不到。而后发现 kv 上报频繁打 log 引起 FOOM。接着分析大量日志还是不能找到 FOOM 原因。微信急需一个有效的内存监控工具来发现问题。 二、实现原理微信内存监控最初版本是使用 Facebook 的 FBAllocationTracker 工具监控 OC 对象分配，用 fishhook 工具 hook malloc/free 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP200 最大堆内存及其分配堆栈，用文本 log 输出到本地。该方案实现简单，一天内完成，通过给用户下发 TestFlight，最终发现联系人模块因迁移 DB 加载大量联系人导致FOOM。 不过这方案有不少缺点： ①、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用； ②、输出 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io 频繁等性能问题； ③、上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。 所以二期版本以 Instruments 的 Allocations 为参考，着重四个方面优化：数据收集、存储、上报及展现。 2.1 数据收集16 年 9 月底为了解决 ios10 nano crash，研究了 libmalloc 源码，无意中发现这几个接口： 123456789typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *__syscall_logger; // use this to set up syscall logging (e.g., vm_allocate, vm_deallocate, mmap, munmap) malloc_logger_t *malloc_logger = NULL; 当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。 有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址 = 堆栈地址 - slide。 另外为了更好的归类数据，每个内存对象应该有它所属的分类 Category。如上图所示。对于堆内存对象，它的 Category 名是 “Malloc” +分配大小，如 “Malloc 48.00KiB”。 对于虚拟内存对象，调用 vm_allocate 创建时，最后的参数 flags 代表它是哪类虚拟内存，而这个 flags 正对应于上述函数指针 __syscall_logger 的第一个参数 type，每个 flag 具体含义可以在头文件 \\&lt;mach/vm_statistics.h> 找到； 对于 OC 对象，它的 Category 名是 OC 类名，我们可以通过 hook OC方法 +[NSObject alloc] 来获取： 12345678910111213141516171819202122232425262728@implementation NSObject (Logger)+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originSEL = @selector(alloc); SEL swizzeSEL = @selector(event_logging_alloc); Method originMethod = class_getClassMethod(self.class, originSEL); Method swizzeMethod = class_getClassMethod(self.class, swizzeSEL); method_exchangeImplementations(originMethod, swizzeMethod); &#125;);&#125;+ (instancetype)event_logging_alloc&#123; id object = [self event_logging_alloc]; // 对于 NSAutoreleasePool 对象会崩掉 nsobject_set_last_allocation_event_name(object, class_getName(self.class)); return object;&#125;void nsobject_set_last_allocation_event_name(id obj, const char * clsName)&#123; NSLog(@\"%s\", clsName); // 输出类名&#125; 但后来发现，NSData 创建对象的类静态方法没有调用 +[NSObject alloc]，里面实现是调用 C 方法 NSAllocateObject 来创建对象，也就是说类方式创建的 OC 对象无法通过 hook 来获取 OC 类名。最后在苹果开源代码 CF-1153.18 找到了答案，当__CFOASafe=true 并且 __CFObjectAllocSetLastAllocEventNameFunction != NULL 时，CoreFoundation 创建对象后通过这个函数指针告诉上层当前对象是什么类型： 1234// CFRuntime.cbool __CFOASafe = false;void (*__CFObjectAllocSetLastAllocEventNameFunction)(void *, const char *) = NULL; 通过上面方式，我们的监控数据来源基本跟 Allocations 一样了，当然是借助了私有 API，这是可能会被苹果打回的。只能退而求其次，修改 malloc_default_zone 函数返回的 malloc_zone_t 结构体里的 malloc、free 等函数指针，也是可以监控堆内存分配，效果等同于 malloc_logger；而虚拟内存分配只能通过 fishhook 方式。 2.2 数据存储①、存活对象管理 APP 在运行期间会大量申请/释放内存。以上图为例，微信启动 10 秒内，已经创建了 80 万对象，释放了 50 万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了 sqlite，改用了更轻量级的平衡二叉树来存储。 伸展树 Splay Tree，也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是 O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过 “伸展” 操作搬移到离树根更近的地方。 大部分情况下，内存申请很快又被释放，如 autoreleased 对象、临时变量等；而 OC 对象申请内存后紧接着会更新它所属 Category。所以用伸展树管理最适合不过了。 传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。 ②、堆栈存储 据统计，微信运行期间，backtrace 的堆栈有成百万上千万种，在捕获最大栈长 64 情况下，平均栈长 35。如果 36bits 存储一个地址（armv8 最大虚拟内存地址 48bits，实际上 36bits 够用了），一个堆栈平均存储长度 157.5bytes，1M 个堆栈需要157.5M 存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后 7 个地址是一样的： 为此，可以用 Hash Table 来存储这些堆栈。思路是整个堆栈以链表的方式插入到 table 里，链表结点存放当前地址和上一个地址所在 table 的索引。每插入一个地址，先计算它的 hash 值，作为在 table 的索引，如果索引对应的 slot 没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash 命中，继续处理下一个地址；数据不一致，意味着 hash 冲突，需要重新计算 hash 值，直到满足存储条件。举个例子（简化了 hash 计算）： Stack1 的 G、F、E、D、C、A 依次插入到哈希表，索引 1～6 结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1 索引入口是 6 轮到插入 Stack2，由于 G、F、E、D、C 结点数据跟 Stack1 前 5 个结点一致，hash 命中；B 插入新的 7 号位置 (B, 5)。Stack2 索引入口是 7 最后插入 Stack3，G、F、E、D 结点 hash 命中；但由于 Stack3 的 A 的上一个地址 D 索引是 4，而不是已有的 (A, 5)，hash 不命中，查找下一个空白位置 8，插入结点 (A, 4)；B 上一个地址 A 索引是 8，而不是已有的 (B, 5)，hash 不命中，查找下一个空白位置 9，插入结点 (B, 9)。Stack3 索引入口是 9 经过这样的后缀压缩存储，平均栈长由原来的 35 缩短到 5 不到。而每个结点存储长度为 64bits（36bits 存储地址，28bits 储存 parent 索引），hashTable 空间利用率 60%+，一个堆栈平均存储长度只需要 66.7bytes，压缩率高达 42%。 ③、性能数据 经过上述优化，内存监控工具在 iPhone6Plus 运行占用 CPU 占用率 13% 不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量 20M 左右，都用 mmap 方式把文件映射到内存。有关 mmap 好处可自行google。 三、数据上报由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现 FOOM 时，不可能全量上报，而是按某些规则有选择性的上报。 首先把所有对象按 Category 进行归类，统计每个 Category 的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对 Category 下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些 Category，如分配大小 TOP N，或者UI相关的（如 UIViewController、UIView 之类的），它里面分配大小 TOP M 的堆栈才做上报。上报格式类似这样： 123456789101112131415&#123; \"items\" : [&#123; \"name\" : \"NSObject\", # 分类名字 \"size\" : 123456, # 该分类下分配内存总大小 \"count\" : 123, \"stacks\" : [&#123; \"size\" : 21313, # 总大小 \"count\" : 123, # 对象个数 \"frames\" : [&#123; \"uuid\" : uuid1, # 地址所在 image 的 uuid \"offset\" : offset1 # 地址所在 image 的偏移 &#125;] &#125;] &#125;]&#125; 四、页面展现页面展现参考了 Allocations，可看出有哪些 Category，每个 Category 分配大小和对象数，某些 Category 还能看分配堆栈。 为了突出问题，提高解决问题效率，后台先根据规则找出可能引起 FOOM 的 Category（如上面的 Suspect Categories），规则有： UIViewController 数量是否异常 UIView 数量是否异常 UIImage 数量是否异常 其它 Category 分配大小是否异常，对象个数是否异常 接着对可疑的 Category 计算特征值，也就是 OOM 原因。特征值是由 “Caller1”、”Caller2” 和 “Category, Reason” 组成。Caller1 是指申请内存点，Caller2 是指具体场景或业务，它们都是从 Category 下分配大小第一的堆栈提取。Caller1 提取尽量是有意义的，并不是分配函数的上一地址。例如： 所有 report 计算出特征值后，可以对它们进行归类了。一级分类可以是 Caller1，也可以是 Category，二级分类是与Caller1/Category 有关的特征聚合。效果如下： 4.1 一级分类 4.2 二级分类 五、运营策略上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概 300K 左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做 100% 开启。本地最多只保留最近三次数据。 六、降低误判先回顾 Facebook 如何判定上一次启动是否出现 FOOM： App 没有升级 App 没有调用 exit() 或 abort() 退出 App 没有出现 crash 用户没有强退 App 系统没有升级/重启 App 当时没有后台运行 App 出现 FOOM 1、2、4、5 比较容易判断，3 依赖于自身 CrashReport 组件的 crash 回调，6、7 依赖于 ApplicationState 和前后台切换通知。微信自上线 FOOM 数据上报以来，出现不少误判，主要情况有： 6.1 ApplicationState 不准部分系统会在后台短暂唤起 app，ApplicationState 是 Active，但又不是 BackgroundFetch；执行完 didFinishLaunchingWithOptions 就退出了，也有收到 BecomeActive 通知，但很快也退出；整个启动过程持续 5～8 秒不等。解决方法是收到 BecomeActive 通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。 6.2 群控类外挂这类外挂是可以远程控制 iPhone 的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。 6.3 CrashReport 组件出现 crash 没有回调上层微信曾经在 17 年 5 月底爆发大量 GIF crash，该 crash 由内存越界引起，但收到 crash 信号写 crashlog 时，由于内存池损坏，组件无法正常写 crashlog，甚至引起二次 crash；上层也无法收到 crash 通知，因此误判为 FOOM。目前改成不依赖 crash回调，只要本地存在上一次 crashlog（不管是否完整），就认为是 crash 引起的 APP 重启。 6.4 前台卡死引起系统 watchdog 强杀也就是常见的 0x8badf00d，通常原因是前台线程过多，死锁，或 CPU 使用率持续过高等，这类强杀无法被 App 捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被 watchdog 强杀。同时我们从 FOOM 划分出新的重启原因叫“App 前台卡死导致重启”，列入重点关注。 七、成果微信自 2017 年三月上线内存监控以来，解决了 30 多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM 率由 17 年年初 3%，降到目前 0.67%，而前台卡死率由 0.6% 下降到 0.3%，效果特别明显。 八、常见问题1、UIGraphicsEndImageContext UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode的 Analyze 也能扫出这类问题。 2、UIWebView 无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 APP 大量内存。而 WKWebView 不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。 3、autoreleasepool 通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。 4、互相引用 比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer的target、CAAnimation 的 delegate，是对 Obj 强引用。目前微信通过自己实现的 MMNoRetainTimer 和MMDelegateCenter 来规避这类问题。 5、大图片处理 举个例子，以往图片缩放接口是这样写的： 123456789- (UIImage *)scaleImage:(UIImage *)originIamge newSize:(CGSize)newSize&#123; UIGraphicsBeginImageContextWithOptions(originIamge.size, NO, 0); [originIamge drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很耗内存的。解决方法是使用更低层的 ImageIO 接口，避免中间 bitmap 产生： 1234567891011+ (UIImage *)scaleImageWithData:(NSData *)data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation&#123; CGFloat maxPixelSize = MAX(size.width, size.height); CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil); NSDictionary * options = @&#123; (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceThumbnailMaxPixelSize : @(maxPixelSize)&#125;; CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options); UIImage * resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation]; CGImageRelease(imageRef); CFRelease(sourceRef); return resultImage; 6、大视图 大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。 九、学习文章iOS微信内存监控Memory Usage Performance GuidelinesNo pressure, Mon!","tags":[]},{"title":"property","date":"2019-05-23T08:46:45.820Z","path":"2019/05/23/property/","text":"一、简介属性 property 是 Objective-C 的一项特性，用于封装对象中的数据。这一特性可以令编译器自动编写与属性存取方法，并且保存为各种实例变量。 属性的本质是实例变量与存取方法的结合。@property = ivar + getter + setter 二、特质2.1 原子性 atomic/noatomic 原子性：并发编程中确保其操作具备整体性，系统其它部分无法观察到中间步骤，只能看到操作前后的结果。 由于要保证操作完整，atomic 速度比较慢，线程相对安全；nonatomic 速度比较快，但是线程不安全。 atomic 也不是绝对的线程安全，当多个线程同时调用 set 和 get 时，就会导致获取的值不一样。由于锁定机制开销较大，一般 iOS 开发中会使用 nonatomic，而 macOS 中使用 atomic 通常不会有性能瓶颈。 要想线程绝对安全，就要使用 @synchronized 同步锁。但是由于同步锁有等待操作，会降低代码效率。为了兼顾线程安全和提升效率，可采用 GCD 并发队列进行优化改进。get 使用同步派发，set 使用异步栅栏。 12345678910111213141516171819202122232425262728293031// 同步锁-(NSString *)some&#123; @synchronized(self) &#123; return _some; &#125; &#125;-(void)setSome:(NSString *)some&#123; @synchronized(self) &#123; _some = some; &#125;&#125;// 并发队列_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);-(NSString *)some&#123; __block NSString *localSome; dispatch_sync(_queue, ^ &#123; localSome = _some; &#125;); return localSome;&#125;-(void)setSome:(NSString *)some&#123; dispatch_barrier_async(_queue, ^&#123; _some = some; &#125;);&#125; 2.2 读写权限 readwrite/readonly默认为 readwrite。一般可在 .h 里写成 readonly，对外只提供读取方法，在 .m 的 Extension 中再设置为 readwrite 可进行写入。 12345// .h 文件@property (nonatomic, readonly, strong) AModel * model;// .m 文件@property (nonatomic, readwrite, strong) AModel * model; 2.3 内存管理语义 assign、strong、copy、weak、unsafe_unretained2.3.1 关键词strong：指向并拥有该对象。其修饰的对象引用计数会 +1，该对象只要引用计数不为 0 就不会销毁，置为 nil 可以销毁它，一般用于修饰对象类型、字符串和集合类的可变版本。 1234567891011121314151617// .h 文件@property (nonatomic, strong) NSMutableArray * nArr;// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-10-16 19:29:27.550029+0800 Demo[64192:936916] ( a, b, c, d) 0x60000005bc60 0x60000005bc60 // 地址相同 copy：与 strong 类似，设置方法会拷贝一份副本。一般用于修饰字符串和集合类的不可变版，block 用 copy 修饰。自定义对象需要实现 NSCoping 协议。 12345678910111213141516// .h 文件@property (nonatomic, copy) NSArray * nArr;// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-10-16 19:27:27.678093+0800 Demo[63966:933713] ( a, b, c) 0x60000024e070 0x60000024c960 // 地址不同 自定义对象实现 NSCoping 协议 1234567- (instancetype)copyWithZone:(NSZone *)zone&#123; AModel * model = [[[self class] allocWithZone:zone] init]; model.title = self.title; model.desc = self.desc; return model;&#125; weak：指向但不拥有该对象。其修饰的对象引用计数不会增加，属性所指的对象遭到摧毁时值会清空。ARC 环境下一般用于修饰可能会引起循环引用的对象，delegate、xib 控件用 weak 修饰。 assign：主要用于修饰基本数据类型，如 NSInteger、CGFloat 等，这些数值主要存在于栈中。 unsafe_unretained：与 weak 类型，但是销毁时不自动清空，容易形成野指针。 2.3.2 比较 copy 和 strong相同：用于修饰表示拥有关系的对象； 不同：strong 赋值是多个指针指向同一个地址，而 copy 的赋值是每次会在内存中赋值一份对象，指针指向不同的地址。 NSString、NSArray、NSDictionary 等不可变对象用 copy 修饰，因为有可能赋值一个可变类型的指针，此时能保证属性值不会受外界影响。 注意：若用 strong 修饰 NSArray，当数组接收一个可变数组，可变数组若发生变化，被修饰的属性数组也会发生变化，也就是说属性值容易被篡改；若用 copy 修饰 NSMutableArray，当试图修改属性数组里的值时，程序会崩溃，因为数组被复制成了一个不可变的版本。 123456789101112131415161718// .h 文件@property (nonatomic, strong) NSArray * nArr; // strong 修改不可变属性// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-11-02 11:12:25.479726+0800 DemoDemo[11401:1924103] ( a, b, c, d) 0x60000045bed0 0x60000045bed0 // 地址相同 2.3.3 比较 assign、weak、unsafe_unretained相同点：都不是强引用 不同点：weak 引用的 OC 对象被销毁时，指针会被自动清空，不再指向销毁的对象，不会产生野指针错误；unsafe_unretained 引用的 OC 对象被销毁时，指针并不会被自动清空，依然指向销毁的对象，很容易产生野指针错误：EXC_BAD_ACCESS；assign 修饰基本数据类型，内存在栈上由系统自动回收，修饰对象类型时，也可能存在野指针。 在使用 delegate 时，需要注意：MRC 时是使用 assign，到了 ARC 环境，都建议使用 weak，这样更安全。 不管是 MRC 还是 ARC，使用 assign 时，都需要注意释放。如果在 ARC 下，没有做这个逻辑的话，当页面销毁的时候，很可能出现delegate 对象无效，导致程序 crash。 2.4 方法 setter= 与 getter=&lt;&gt; 中为方法名，通过此特质来指定存取方法的名称。 123456@property (nonatomic, assign, getter=isOn) BOOL on;-(BOOL)isOn&#123; return self.on;&#125; 三、默认设置基本数据类型：(atomic, readwrite, assign)对象类型：(atomic, readwrite, strong) 注意：考虑到代码可读性以及日常代码修改频率，规范的编码风格中关键词的顺序是：原子性、读写权限、内存管理语义、setter/getter。 四、延伸@property 会使编译器自动编写访问这些属性所需的方法，此过程在编译期完成，称为自动合成（autosynthesis）。与此相关的还有两个关键词：@dynamic 和 @synthesize。 4.1 @dynamic告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。即使编译器发现没有定义存取方法也不会报错，运行期会导致崩溃。 4.2 @synthesize在类的实现文件里可以通过 @synthesize 指定实例变量的名称。 注意：Xcode4.4 之前，@property 配合 @synthesize 使用，@property 负责声明属性，@synthesize 负责让编译器生成带下划线的实例变量并且自动生成 setter、getter 方法；在 Xcode4.4 之后 @property 得到增强，直接一并替代了@synthesize 的工作。 五、学习文章《Effective Objective-C 2.0》","tags":[]},{"title":"ARC","date":"2019-05-23T08:17:05.311Z","path":"2019/05/23/ARC/","text":"一、ARCARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果修改了一些内存管理代码的书写方式，干脆编译器在编译时把内存管理的代码都自动补上。 ARC 是编译器特性，而不是运行时特性，更不是垃圾回收器（GC）。 Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. 程序在编译的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，编译器帮我们在合适的地方插入retain、release 等代码以管理对象的引用计数，从而达到自动管理对象生命周期的目的。 所以 ARC 是工作在编译期的一种技术方案，这样的好处： 编译之后，ARC 与 MRC 代码是没有什么差别的，所以二者可以在源码中共存。 相对于垃圾回收这类内存管理方案，ARC 不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。相反的，由于ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。 只有编译器是无法单独完成这一工作的，还需要 OC 运行时库的配合协助，因此 ARC 的实现工具主要包括： LLVM 编译器（clang 3.0 以上） OC 运行时库 493.9 以上 weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。 ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外 10% 的内存管理问题是需要开发者处理的，这主要是与底层 Core Foundation 对象交互的部分，底层 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。 二、ARC 的开启和关闭在 Targets -》Build Settings 中搜索 Automatic Reference Counting，可以修改它的布尔值，yes - 开启 no - 关闭。 如果需要对特定文件开启或关闭 ARC，可以在 Targets -》Build Phases -》Compile Sources，在里面找到对应文件，添加flag： 开启：-fobjc-arc 关闭：-fno-objc-arc 三、ARC 的修饰符主要提供了 4 种修饰符，他们分别是：__strong、__weak、__autoreleasing、__unsafe_unretained。 3.1 __strong强引用。相当于 @property 的 “strong”。所有对象只有当没有任何一个强引用指向（引用计数为 0）时，才会被释放。 注意：如果在声明引用时不加修饰符，那么将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置 nil。 使用 __strong 修饰变量的程序运行过程。 123&#123; id __strong object = [[NSObject alloc] init];&#125; 转换后的模拟源代码为： 1234/*编译器的模拟代码*/id object = objc_msgSend(NSObjct, @selector(alloc));objc_msgSend(object, @selector(init));objc_release(object); 对象变量生成时，分别调用 alloc 和 init 方法，对象变量作用域结束时调用 objc_release 方法释放对象变量，虽然 ARC 情况下不能使用 release 方法，但是由此可见编译器编译时在合适的地方插入了 release。 在使用 alloc、new、copy、mutableCopy 以外的方法生成对象变量方法时会有什么不同 123&#123; id __strong object = [NSMutableArray array];&#125; 调用 array 的类方法转换后： 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); objc_release(object);&#125; objc_retainAutoreleasedReturnValue(object) 函数的作用：最优化程序运行。 自己持有（retain）对象的函数，但它持有的应为返回注册在 autoreleasepool 中对象的方法或函数的返回值。 objc_retainAutoreleasedReturnValue 函数与 objc_autoreleasedReturnValue 是成对出现的，现在看看 NSMutableArray 类的 array 类方法的编译器实现。 123+ (id)array &#123; return [[NSMutableArray alloc] init];&#125; 转换后的源代码。 1234567+ (id)array&#123; /*编译器的模拟代码*/ id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 通过 objc_autoreleaseReturnValue 函数将对象注册在自动释放池 autoreleasepool 中并返回，但是与 objc_autorelease 函数不同的是，objc_autoreleaseReturnValue 函数一般不仅限于注册对象到 autoreleasepool 中去。 objc_autoreleaseReturnValue 与 objc_retainAutoreleasedReturnValue 的配合使用，可以不将对象注册到autoreleasepool 中而直接传递，达到最优化。 objc_autoreleaseReturnValue 函数会检查使用该函数的方法或者函数的调用方的执行命令列表，如果调用方在调用该函数或方法之后，紧接着调用了 objc_retainAutoreleasedReturnValue 函数，那么不再将对象注册到 autoreleasepool 中去，而直接将对象传递给调用方。 相比于 objc_retain 函数来说 objc_retainAutoreleasedReturnValue 函数在返回一个即使没有注册到autoreleasepool 中的对象，也能正确的获取对象。 3.2 __weak弱引用。相当于 @property 的 “weak”。弱引用不会影响对象的引用计数，即只要对象没有任何强引用指向，即使有 n 个弱引用对象指向也没用，该对象依然会被释放。 对象在被释放的同时，指向它的弱引用（weak）会自动被置 nil，这个技术叫 zeroing weak pointer。这样有效的防止无效指针、野指针的产生。__weak 一般用在 delegate 关系中防止循环引用或者用来修饰指向由 Interface Builder 编辑与生成的 UI 控件。 123&#123; id _weak object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id object; id tmp = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(tmp, @selector(init)); objc_initWeak(&amp;object, tmp); objc_release(tmp); objc_destoryWeak(&amp;object);&#125; 自己生成并且持有的对象通过 objc_initWeak 函数赋值给 __weak 修饰符的变量，但是编译器判断并没有对其进行持有，因此该对象通过 objc_release 函数被释放和废弃。 随后通过 objc_destoryWeak 将引用废弃对象的附有 __weak 修饰符的变量置为 nil。 如果不是直接赋值，而是通过使用 __weak 修饰符来引用变量时。 1234&#123; id __weak object = obj; NSLog(@\"%@\", object);&#125; 转换后的模拟源代码。 123456789/*编译器的模拟代码*/&#123; id object; objc_initWeak(&amp;object, obj); id temp = objc_loadWeakRetained(&amp;object); objc_autorelease(temp); NSLog(@\"%@\", temp); objc_destoryWeak(&amp;object);&#125; 明显增加了 objc_loadWeakRetained 与 objc_autorelease 函数调用，他们的主要作用是： objc_loadWeakRetained 函数取出 __weak 修饰符变量引用的对象并且 retain objc_autorelease 函数将引用的对象注册到 autoreleasepool 中。 因此，使用 __weak 修饰符引用的对象都被注册到 autoreleasepool 中，在 @autoreleasepool 块结束之前都可以放心使用，大量使用 __weak 修饰符的变量，导致注册到 autoreleasepool 中的对象也大量地增加。所以在使用 __weak 修饰符引用的变量时，最好先暂时用 __strong 修饰符的变量进行引用后再使用。 2 种不能使用 __weak 修饰符的情况： 重写了 retain/release 的类，例如 NSMachPort 类； 当 allowsWeakReference/retainWeakReference 实例方法返回 NO 时。 3.3 __autoreleasing对象被加入到 autorelease pool，是会自动释放的引用，与 MRC 中 autorelease 的用法相同。定义 @property 时不能使用这个修饰符。 对于 alloc、new、copy、mutableCopy 的实现。 123@autoreleasepool&#123; id __autoreleasing object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSObjct, @selector(alloc)); objc_msgSend(object, @selector(init)); // 调用autorelease方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; NSMutableArray 类中的 array 方法如何实现 autorelease 功能。 123@autoreleasepool&#123; id __autoreleasing object = [NSMutableArray array];&#125; 转化后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); // 调用 autorelease 方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; 除了持有对象的方法从 alloc 变成了 objc_retainAutoreleasedReturnValue 函数，但是注册到 autoreleasepool 的方法没有变化，都是调用了 objc_autorelease 函数。 一个常见的误解是，在 ARC 中没有 autorelease，因为这样一个“自动释放”看起来好像有点多余。 这个误解可能源自于将 ARC 的“自动” 和 autorelease “自动” 的混淆。其实你只要看一下每个 iOS App 的 main.m 文件就能知道，autorelease 不仅好好的存在着，并且不需要再手工被创建，也不需要再显式得调用 [pool drain] 方法释放内存池。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 以下两行代码的意义是相同的。 12NSString * str = [[[NSString alloc] initWithFormat:@\"China\"] autorelease]; // MRCNSString * __autoreleasing str = [[NSString alloc] initWithFormat:@\"China\"]; // ARC __autoreleasing 在 ARC 中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。 __autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 比如常见的 NSError 的使用： 123456NSError * __autoreleasing error; // writeToFile方法中 error 参数的类型为 (NSError *__autoreleasing *)）￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123; NSLog(@\"Error: %@\", error.localizedDescription); &#125; 注意：如果 error 的修饰符为 strong，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个 __autoreleasing 类型的引用。 12345678NSError * error; NSError * __autoreleasing tempError = error; // 编译器添加 if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) ￼&#123; error = tempError; // 编译器添加 NSLog(@\"Error: %@\", error.localizedDescription); &#125; 为了避免这种情况，提高效率，一般在定义 error 的时候将其声明为__autoreleasing 类型的： 1NSError *__autoreleasing error; 加上 __autoreleasing 之后，相当于在 MRC 中对返回值 error 做了如下事情： 1*error = [[[NSError alloc] init] autorelease]; *error 指向的对象在创建出来后，被放入到了 autoreleasing pool 中，等待使用结束后的自动释放，函数外 error 的使用者并不需要关心 *error 指向对象的释放。 另外，在 ARC 中，所有这种指针的指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 __autoreleasing 类型。 比如下面的两段代码是等同的： 12345678- (NSString *)doSomething:(NSNumber **)value&#123; // do something &#125;- (NSString *)doSomething:(NSNumber * __autoreleasing *)value&#123; // do something &#125; 除非显式得给 value 声明了 __strong，否则 value 默认就是 __autoreleasing 的。 最后一点，某些类的方法会隐式地使用自己的 autorelease pool，在这种时候使用 __autoreleasing 类型要特别小心。 比如 NSDictionary 的 - enumerateKeysAndObjectsUsingBlock: 方法会隐式地创建一个 autorelease pool. 123456789- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; // do stuff if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; &#125;];￼&#125; 上面代码实际类似于： 123456789101112- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; @autoreleasepool // 被隐式创建 &#123; if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125;￼ &#125; &#125;]; // *error 在这里已经被dict的做枚举遍历时创建的 autorelease pool 释放掉了 ￼&#125; 为了能够正常的使用 *error，我们需要一个 strong 型的临时引用，在 dict 的枚举 block 中使用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 block 后被释放，正确的方式如下： 123456789101112131415- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; __block NSError * tempError; // 加 __block 保证可以在 Block 内被修改 [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (...) &#123; *tempError = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; ￼ &#125;] if (error != nil) &#123; *error = tempError; &#125; ￼&#125; 3.4 __unsafe_unretainedARC 是在 iOS 5 引入的，而这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些低版本的设备没有 weak pointer system，这个系统简单的理解就是上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil。 相当于 @property 的 “unsafe_unretained”，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然指向原来被释放的对象（所在的内存区域）。所以非常不安全。 现在可以完全忽略掉这个修饰符了，因为 iOS 4 早已退出历史舞台很多年。 123&#123; id __unsafe_unretained object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(object, @selector(init)); objc_release(tmp);&#125; 可见通过 __unsafe_unretained 修饰的变量引用了对象但是并不持有对象，对象在释放和废弃后，并没有调用被 __unsafe_unretained 修饰的变量的 objc_destoryWeak 函数，因此该对象的悬垂指针被赋值给变量 object，导致引用变量 object 时发生崩溃。 3.5 正确使用修饰符苹果的文档中明确地写道： You should decorate variables correctly. When using qualifiers in an object variable declaration,the correct format is: ClassName * qualifier variableName; 按照这个说明，要定义一个 weak 修饰的 NSString 引用，它的写法应该是： 1NSString * __weak str = @\"Hello\"; // 正确 而不应该是： 1__weak NSString *str = @\"Hello\"; // 错误 那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道： Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see http://cdecl.org/. 看来是苹果考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符。 3.6 栈中指针默认值为 nil无论是被 strong、weak 还是 autoreleasing 修饰，声明在栈中的指针默认值都会是 nil。所有这类型的指针不用再初始化的时候置 nil 了。这个特性更加降低了“野指针”出现的可能性。 在 ARC 中，以下代码会输出 null 而不是 crash。 12345- (void)myMethod &#123; NSString * name; NSLog(@\"%@\", name);&#125; 四、ARC 与 Block在手动管理内存时代，block 会隐式地对进入其作用域内的对象（或者说被 block 捕获的指针指向的对象）执行 retain 操作，来确保 block 使用到该对象时，能够正确的访问。 123456789101112131415161718192021222324MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; // 隐式地调用 [myController retain]; 造成循环引用 [myController dismissViewControllerAnimated:YES completion:nil];&#125;;[self presentViewController:myController animated:YES completion:^&#123; // 调用[myController release];是在 MRC 中的一个常规写法，并不能解决上面循环引用的问题 [myController release]; &#125;];@interface SecondVC : UIViewController@property (nonatomic, copy) void (^ block)(void);@end&#123; SecondVC * vc = [[SecondVC alloc] init]; NSLog(@\"%lu\", (unsigned long)vc.retainCount); vc.block = ^ &#123; NSLog(@\"%lu\", (unsigned long)vc.retainCount); &#125;; vc.block();&#125;2018-11-16 10:26:05.872092+0800 Demo[49289:1083433] 12018-11-16 10:26:05.872214+0800 Demo[49289:1083433] 2 dismissBlock 调用了 [myController dismiss..] 方法，这时 dismissBlock 会对 myController 执行 retain 操作。 而作为 myController 的属性，myController 对 dismissBlock 也至少有一个 retain（一般准确讲是 copy），这时就出现了在内存管理中最糟糕的情况：循环引用。也就是说：相互持有对方。循环引用导致了 myController 和 dismissBlock 最终都不能被释放。 对 delegate 指针用 weak 就是为了避免这种问题。 不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题： 我们一般用如下方法解决：给进入 block 的指针加一个 __block 修饰符。 这个 __block 在 MRC 时代有两个作用： 说明变量可改 说明指针指向的对象不做隐式的 retain 操作 除了静态变量和全局变量不需要加 __block 就可以在 block 中修改外，其他变量不加则不能在 block 中修改。 对代码做出修改，解决了循环引用的问题： 12345MyViewController * __block myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;; // 之后正常的 release 或者 retain 在 ARC 环境下，没有了 retain 和 release 等操作，情况也发生了改变： 在任何情况下，__block 修饰符的作用只有上面的第一条：说明变量可改。即使加上了 __block 修饰符，一个被 block 捕获的强引用也依然是一个强引用。 所以在 ARC 下，如果还按照 MRC 下的写法，添加 __block 是没有解决循环引用的问题。 代码修改如下： 12345__block MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; // 注意这里，保证了 block 结束对 myController 强引用的解除&#125;; 在 block 中将捕获的指针置为 nil，保证了 dismissBlock 对 myController 强引用的解除，不过也同时解除了myController 指针对 myController 对象的强引用。 更好的方法就是使用 weak。（或者为了考虑 iOS4 的兼容性用 unsafe_unretained，具体用法和 weak 相同） 为了保证 dismissBlock 对 myController 没有强引用，我们可以定义一个临时的弱引用 weakMyViewController 来指向原myController 的对象，并把这个弱引用传入到 dismissBlock 内，这样就保证了 dismissBlock 对 myController 持有的是一个弱引用，而不是一个强引用。如此，继续修改代码如下： 1234MyViewController * __weak weakMyViewController = myController;myController.dismissBlock = ^(NSString * result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 这样循环引用的问题就解决了，但是却引入了一个新的问题：由于传入 dismissBlock 的是一个弱引用，那么当 myController指向的对象在 dismissBlock 被调用前释放，那么 dismissBlock 就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。 为了保证在 dismissBlock 内能够访问到正确的 myController，我们在 dismissBlock 内新定义一个强引用strongMyController 来指向 weakMyController 指向的对象，这样多了一个强引用，就能保证这个 myController 对象不会在 dismissBlock 被调用前释放掉了。于是，对代码再次做出修改： 1234567891011MyViewController * __weak weakMyController = myController;// __weak typeof(myController) weakMyController = myController;myController.dismissBlock = ^(NSString * result) &#123; MyViewController * strongMyController = weakMyController; // __strong typeof(weakMyController) strongMyController = weakMyController; if (strongMyController) &#123; [strongMyController dismissViewControllerAnimated:YES completion:nil]; &#125; else &#123; &#125;&#125;; 很多读者会有疑问，不是不希望 block 对原 myController 对象增加强引用么，这里为什么堂而皇之地在 block 内新定义了一个强引用，这个强引用不会造成循环引用么？ 理解这个问题的关键在于被 block 捕获的引用和在 block 内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block 的实现原理，详细的内容可以参考其他的文章：谈Objective-C block的实现、block 实现、正确使用Block避免Cycle Retain和Crash。 为了更清楚地说明问题，这里用一个简单的程序举例。如下程序： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int b = 10; int *a = &amp;b; void (^ block)() = ^() &#123; int *c = a; &#125;; block(); return 1;&#125; 程序中，同为 int 型的指针，a 变量被 block 捕获，而 c 变量是在 block 内定义的。用 clang -rewrite-objc 命令处理后，可以看到如下代码。 原 main 函数： 12345678910int main()&#123; int b = 10; int *a = &amp;b; void (*block)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 1;&#125; block 的结构： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *a; // 被捕获的引用 a 出现在了 block 的结构体里面 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 实际执行的函数： 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *a = __cself-&gt;a; // bound by copy int *c = a; // 在 block 中声明的引用 c 在函数中声明，存在于函数栈上&#125; 可以清楚的看到，a 和 c 存在的位置完全不同，如果 block 存在于堆上（在 ARC 下 block 默认在堆上），那么 a 作为 block 结构体的一个成员，也自然会存在于堆上，而 c 无论如何，永远位于 block 内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c 在 block 的函数运行完毕，即会被释放，而 a 只有在 block 被从堆上释放的时候才会释放。 回到之前的示例，如果直接让 dismissBlock 捕获 myController 引用，那么这个引用会被复制后作为 dismissBlock 的成员变量存在于其所在的堆空间中，也就是为 dismissBlock 增加了一个指向 myController 对象的强引用，这就是造成循环引用的本质原因。 对于 MyViewController 的例子，dismissBlock 的结构体大概是这个样子： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __strong myController; // 被捕获的强引用 myController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而给 dismissBlock 传入一个弱引用 weakMyController，这时 dismissBlock 的结构： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __weak weakMyController; // 被捕获的弱引用 weakMyController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 在 dismissBlock 内声明的强引用 strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，一直持有 myController 对象，但当函数执行完毕，strongMyController 即被销毁，于是它对 myController 对象的强引用被解除，这时 dismissBlock 对 myController 对象就不存在强引用关系了！ 加入了 strongMyController 的函数大体会是这个样子： 123static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; MyViewController * __strong strongMyController = __cself-&gt;weakMyController;&#125; 在 ARC 中，block 捕获的引用和 block 内声明的引用，存储空间与生命周期都是不同的。 实际上，在自动引用计数环境下，对 block 捕获对象的内存管理已经简化了很多，由于没有了 retain 和 release 等操作，实际只需要考虑循环引用的问题就行了。 五、ARC 与 Toll-Free Bridging There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的示例： 12345678910NSLocale * gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_GB\"];CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);NSLog(@\"cfIdentifier: %@\", (NSString *)cfIdentifier); // logs: \"cfIdentifier: en_GB\"CFRelease((CFLocaleRef) gbNSLocale);CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale * myNSLocale = (NSLocale *) myCFLocale;[myNSLocale autorelease];NSString * nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef) [@\"nsIdentifier: \" stringByAppendingString:nsIdentifier]); // logs identifier for current locale 在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 retain 和 release 操作规则，所以Toll-Free Bridging 的使用比较简单，但是自从 ARC 加入后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。 这个时候就必须要考虑一个问题，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership 的改变。 If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined in NSObject.h) 于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。 5.1 __bridge 只是声明类型转变，但是不做内存管理规则的转变。 示例： 1CFStringRef s = (__bridge CFStringRef)[[NSString alloc] initWithFormat:@\"Hi, %@!\", name]; 只是 NSString 到 CFStringRef 的类型转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s，不能用CFRelease() 去释放 s。 5.2 __bridge_retained、CFBridgingRetain() 将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给 Core Foundation 来处理，也就是，将 ARC 转变为 MRC。 示例： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (__bridge_retained CFStringRef)s1;...￼CFRelease(s2); // 注意在使用结束后释放 在第二行做了转化，这时内存管理规则由 ARC 变成了 MRC，需要手动的来管理 s2 的内存，而对于 s1，即使将其置为 nil，也不能释放内存。 也可以写成： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);...￼CFRelease(s2); // 注意在使用结束后释放 5.3 __bridge_transfer、CFBridgingRelease() 功能与 __bridge_retained 相反，表示将管理的责任由 Core Foundation 转交给 Objective-C，即将管理方式由MRC 转变为 ARC。 比如： 1234CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);￼NSString * s = (__bridge_transfer NSString *)result; // 或 NSString * s = (NSString *)CFBridgingRelease(result);￼return s; 这里将 result 的管理责任交给了 ARC 来处理，就不需要再显式地调用 CFRelease() 了。 这里和 ARC 中 4 个主要的修饰符 __strong、__weak、__autoreleasing… 不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但最好与官方的相同。 六、ARC下获取引用计数6.1 使用 KVC1[obj valueForKey:@\"retainCount\"]; 6.2 使用私有 API123OBJC_EXTERN int _objc_rootRetainCount(id);_objc_rootRetainCount(obj); 这个不一定完全可信。Xcode 10.1 用的示例一直返回 1。 6.3 使用 CFGetRetainCount1CFGetRetainCount((__bridge CFTypeRef)(obj)) 使用 Toll-Free-Bridging 将 OC 对象的内容管理转为 Core Foundation 对象。 七、学习文章iOS 开发ARC内存管理技术要点谈 Objective-C block的实现block 的实现正确使用 Block 避免Cycle Retain和CrashARC 的实现原理","tags":[]},{"title":"引用计数","date":"2019-05-23T07:16:48.623Z","path":"2019/05/23/引用计数/","text":"一、简介 OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。 OC 在内存管理上采用了引用计数，它是一个简单而有效管理对象生命周期的方式。在对象内部保存一个用来表示被引用次数的数字，init、new 和 copy 都会让计数 +1，调用 release 让计数 -1。当计数等于 0 的时候，系统调用 dealloc 方法来销毁对象。 123A * a = [[A alloc] init]; // retain count = 1A * b = a; // 指针赋值时，retain count 不会自动增加[b retain]; // retain count = 2 12345678910111213141516171819&#123; OBJC_EXTERN int _objc_rootRetainCount(id); NSObject * obj = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj)); NSObject * obj1 = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj1 retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj1)); // obj 指向了 obj1 所指的对象 B，失去了对原来对象A的引用,所以对象A的引用计数-1，为 0。A 被销毁 // 对于 B，obj 引用了它，所以引用计数 +1，为 2 obj = obj1; // self.obj 又引用了 A,所以引用计数 +1，为 3 self.obj = obj; NSLog(@\"strong obj1 retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj1)); NSLog(@\"strong obj retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj));&#125; 引用计数分为自动引用计数「ARC : Automatic Reference Counting」和手动引用计数「MRC : Manual Reference Counting」。 二、原理 三、示例1234567891011121314151617NSObject * obj1 = [NSObject new];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);NSObject * obj2 = [obj1 retain];NSObject * obj3 = [obj1 retain];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);引用计数：1引用计数：3引用计数：2 &lt;NSObject：0x60400001ecd0&gt;引用计数：1 &lt;NSObject：0x60400001ecd0&gt;*** -[NSObject retainCount]: message sent to deallocated instance 0x60400001ecd0 根据 Debug 输出可以看到：obj1 可以调用多次 release 方法。 从两次打印 obj1 的地址相同可以猜测，在 [obj1 release] 执行之后对象的引用计数 -1，不再强引用对象，但 obj1 仍然指向对象所在的那片内存空间。在第三次执行 release 后，对象的引用计数为 0，对象所在的内存空间被销毁，但是 obj1 指针仍然存在，此时调用 retainCount 会报野指针错误。可以通过置 obj1 = nil 解决这个问题。 对 Linux 文件系统比较了解的可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于 retain），当删除一个文件时（相当于 release），系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 四、僵尸对象、野指针、空指针僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用。 野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC_BAD_ACCESS）。 空指针：没有指向任何对象的指针（存储的是 nil、NULL），给空指针发送消息不会报错；空指针的一个经典使用场景就是在开发中获取服务器 API 数据时，转换野指针为空指针，避免发送消息报错。 五、为什么需要引用计数？引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。 举个例子： 对象 A 生成了一个对象 O，需要调用对象 B 的某个方法，并将对象 O 作为参数传递过去。 1[objB doSomething:O]; 在没有引用计数的情况下，一般内存管理的原则是「谁申请谁释放」。 那么对象 A 就需要在对象 B 不再需要 O 的时候，将 O 销毁。但对象 B 可能临时用一下 O，也可能将它设置为自己的一个成员变量，在这种情况下，什么时候销毁就成了一个难题了。 对于以上情况有两种做法： ①、对象 A 在调用完对象 B 的某个方法之后，马上销毁参数 O；然后对象 B 需要将对象 O 复制一份，生成另一个对象 O2，同时自己来管理对象 O2 的生命周期。 这种做法带来更多的内存申请、复制、释放的工作。本来可以复用的对象，因为不方便管理它的生命周期，就简单地把它销毁，又重新构造一份一样的，实在太影响性能。 ②、对象 A 只负责生成 O，之后就由对象 B 负责完成 O 的销毁工作。如果对象 B 只是临时用一下 O，就可以用完后马上销毁；如果对象 B 需要长时间使用 O，就不销毁它。 这种做法看似解决了对象复制的问题，但是它强烈依赖于 A 和 B 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于 O 的生成和释放在不同对象中，使得它的内存管理代码分散在不同对象中，管理起来也很费劲。如果这个时候情况更加复杂一些，例如对象 B 需要再向对象 C 传递参数 O，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方法带来的复杂度更高，更加不可取。 引用计数的出现很好地解决这个问题，在参数 O 的传递过程中，哪些对象需要长时间使用它，就把它的引用计数 +1，使用完就-1。所有对象遵守这个规则，对象的生命周期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 六、ARC 下的内存管理问题问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要手工管理它们的引用计数时，显得一筹莫展。 6.1 循环引用引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁又依赖于对象 A 的销毁，这样就造成了循环引用 Reference Cycle 的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 6.2 主动断开循环引用解决循环引用问题主要有两个办法。第一个办法：明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存，所以这种解决方法并不常用，更常见的办法是使用弱引用的办法。 6.3 使用弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。如下所示： 6.4 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： ①、在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 ②、大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 ③、早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 6.5 检测循环引用 七、学习文章iOS 内存管理iOS 的内存管理","tags":[]},{"title":"weak","date":"2019-05-23T06:43:21.310Z","path":"2019/05/23/weak/","text":"一、基本用法weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候自动被设置为 nil，大大避免了野指针访问坏内存引起崩溃的情况，另外 weak 还可以用于解决循环引用。 二、原理概括 weak 表其实是一个 hash（哈希）表。 key：所引用对象的地址；value：weak 指针的地址数组（这个地址的值是指向对象的指针的地址）。 weak 的底层实现的原理是什么？ runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表是由单个自旋锁管理的散列表。 为什么 value 是数组？ 因为一个对象可能被多个弱引用指针指向。 三、实现步骤weak 的实现原理可概括三步： ①、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 ②、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 ③、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 四、详细过程1、初始化时：runtime 会调用 objc_initWeak 函数，objc_initWeak 函数会初始化一个新的 weak 指针指向对象的地址。 123NSObject * obj = [[NSObject alloc] init];id __weak obj1 = obj; 当初始化一个 weak 变量时，runtime 会调用 NSObject.mm 中的 objc_initWeak 函数。 这个函数在 Clang 中的声明如下： 1id objc_initWeak(id *object, id value); 而对于 objc_initWeak() 方法的实现如下： 123456789101112id objc_initWeak(id *location, id newObj)&#123; // 查看对象实例是否有效，无效对象直接导致指针释放 if (!newObj) &#123; *location = nil; return nil; &#125; // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt;(location, (objc_object*)newObj);&#125; 这里先判断了其指针指向的类对象是否有效，无效直接释放返回，不再往深层调用函数。否则 object 将被注册为一个指向 value 的 __weak 对象，而这事应该是 objc_storeWeak 函数干的。可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断）。 注意：objc_initWeak 函数有一个前提条件：就是 object 必须是一个没有被注册为 __weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 objc_storeWeak() 的函数声明如下： 1id objc_storeWeak(id *location, id value); objc_storeWeak() 的具体实现如下，请参考 weak弱引用实现的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// HaveOld: true - 变量有值// false - 需要被及时清理，当前值可能为 nil// HaveNew: true - 需要被分配的新值，当前值可能为 nil// false - 不需要分配新值// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停// false - 用 nil 替代存储template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj) &#123; // 该过程用来更新弱引用指针的指向 // 初始化 previouslyInitializedClass 指针 Class previouslyInitializedClass = nil; id oldObj; // 声明两个 SideTable // ①、创建新旧散列 SideTable *oldTable; SideTable *newTable; // 获得新值和旧值的锁存位置（用地址作为唯一标示） // 通过地址来建立索引标志，防止桶重复 // 下面指向的操作会改变旧值retry: if (HaveOld) &#123; // 如果 HaveOld 为 true，更改指针，获得以 oldObj 为索引所存储的值地址 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // 更改新值指针，获得以 newObj 为索引所存储的值地址 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁操作，防止多线程中竞争冲突 SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 避免线程冲突重处理 // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // 防止弱引用间死锁 // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向 if (HaveNew &amp;&amp; newObj) &#123; // 获得新对象的 isa 指针 Class cls = newObj-&gt;getIsa(); // 判断 isa 非空且已经初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; // 解锁 SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 对其 isa 指针进行初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // 如果该类已经完成执行 +initialize 方法是最理想情况 // 如果该类 +initialize 在线程中 // 例如 +initialize 正在调用 storeWeak 方法 // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; // 重新尝试 goto retry; &#125; &#125; // ② 清除旧值 if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // ③ 分配新值 if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // 如果弱引用被释放 weak_register_no_lock 方法返回 nil // 在引用计数表中设置若引用标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // 弱引用位初始化操作 // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用 newObj-&gt;setWeaklyReferenced_nolock(); &#125; // 之前不要设置 location 对象，这里需要更改指针指向 *location = (id)newObj; &#125; else &#123; // 没有新值，则无需更改 &#125; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 撇开源码中各种锁操作，来看看这段代码都做了些什么。 ①、SideTable SideTable 这个结构体，我给它起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable。实例在 NSObject.mm 中声明其数据结构： 12345678struct SideTable &#123; // 保证原子操作的自旋锁 spinlock_t slock; // 引用计数的 hash 表 RefcountMap refcnts; // weak 引用全局 hash 表 weak_table_t weak_table;&#125; slock 是为了防止竞争选择的自旋锁，用来保证线程安全； refcnts 是协助对象的 isa 指针的 extra_rc 共同引用计数的变量，每个对象的引用计数保存在全局的引用计数表中，一个对象地址对应一个引用计数； weak_table 就是接下来要讲的 weak 表，所有的 weak 变量会被加入到全局的 weak 表中，表的 key 是 weak 修饰的变量指向的对象， value 值就是 weak 修饰的变量。这里主要看 weak 全局 hash 表的结构与作用。 ②、weak 表 weak 表是一个弱引用表，实现为一个 weak_table_t 结构体，存储了某个对象相关的所有的弱引用信息。其定义如下（具体定义在 objc-weak.h 中）： 12345678910struct weak_table_t &#123; // 保存了所有指向指定对象的 weak 指针 weak_entry_t * weak_entries; // 存储空间，即 entries 的数目 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;&#125;; 这是一个全局弱引用 hash 表，它的作用就是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。使用不定类型对象的地址的 hash 化后的数值作为 key，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。 weak_entry_t 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下： 12345678910111213141516171819typedef objc_object ** weak_referrer_t;// 存储在弱引用表中的一个内部结构体struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 封装 objc_object 指针，即 weak 修饰的变量指向的对象 union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; // LSB 最低有效元。当标志位为0时，增加引用表指针纬度，当其为0的时候， weak_referrer_t 成员将扩展为静态数组型的 hash table uintptr_t num_refs : PTR_MINUS_1; // 引用数值，这里记录弱引用表中引用有效数字，即里面元素的数量 uintptr_t mask; uintptr_t max_hash_displacement; // hash 元素上限阀值 &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;&#125; 在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题，其内容可以理解为对象的内存地址。 从注释中写 out_of_line 成员为最低有效位，当其为 0 的时候， weak_referrer_t 成员将扩展为一个静态数组型的 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。 那么在有效位未生效的时候，out_of_line、num_refs、mask、max_hash_displacement 有什么作用？以下是笔者自身的猜测： out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。 num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。 mask：计数辅助量。 max_hash_displacement：hash 元素上限阀值。 其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT。 每个对象的 SideTable 中的 weak_table_t 都是全局 weak 表的入口，以引用计数对象为键找到其所记录的 weak 修饰的对象。 weak_entry_t 中的 referrers 有两种形式：当 out_of_line 为 0 的时候，referrers 是一个静态数组型的表，数组大小默认为 WEAK_INLINE_COUNT 大小；当 out_of_line 不为 0 的时候，referrers 是一个动态数组，内容随之增加。 StripedMap[] 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。 ③、旧对象解除注册操作 weak_unregister_no_lock 123456789101112131415161718192021222324252627282930313233void weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; 该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。 来看看这个函数的逻辑： 首先参数是 weak_table_t 表、键和值。声明 weak_entry_t 变量，如果 key，也就是引用计数对象为空，直接返回。根据全局入口表和键获取对应的 weak_entry_t 对象，也就是 weak 表记录。获取到记录后，将记录表以及 weak 对象作为参数传入 remove_referrer 函数中，这个函数就是解除操作。然后判断这个 weak 记录是否为空，如果为空，从全局记录表中清除相应的引用计数对象的 weak 记录表。 从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。 再来了解一下解除对象的函数： 123456789101112131415161718192021222324252627282930313233343536static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)&#123; if (! entry-&gt;out_of_line) &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == old_referrer) &#123; entry-&gt;inline_referrers[i] = nil; return; &#125; &#125; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; size_t index = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; &#125; entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;&#125; 这个函数传入的是 weak 对象，当 out_of_line 为 0 时，遍历数组，找到对应的对象，置 nil，如果未找到，报错并返回。当 out_of_line 不为 0 时，根据对象的地址 hash 化并和 mask 做与操作作为下标，查找相应的对象，若没有，报错并返回，若有，相应的置为 nil，并减少元素数量，即 num_refs 减 1。 ④、新对象添加注册操作 weak_register_no_lock 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; weak_entry_t new_entry; new_entry.referent = referent; new_entry.out_of_line = 0; new_entry.inline_referrers[0] = referrer; for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_entry.inline_referrers[i] = nil; &#125; weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 这一步与上一步相反，通过 weak_register_no_lock 函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。 一大堆 if-else 主要是为了判断该对象是不是 taggedPoint 以及是否正在调用 dealloc 等。下面操作开始，同样是先获取 weak 表记录，如果获取到，则调用 append_referrer 插入对象，若没有，则新建一个 weak 表记录，默认为 out_of_line，然后将新对象放到 0 下标位置，其他位置置为 nil 。下面两个函数 weak_grow_maybe 是用来判断是否需要重申请内存重 hash，weak_entry_insert 函数是用来将新建的 weak 表记录插入到全局 weak 表中。插入时同样是以对象地址的 hash 化和 mask 值相与作为下标来记录的。 接下来看看 append_referrer 函数，源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)&#123; if (! entry-&gt;out_of_line) &#123; // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; // Couldn't insert inline. Allocate out of line. weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = 1; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; &#125; assert(entry-&gt;out_of_line); if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer); &#125; size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; &#125; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement; &#125; weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;&#125; ⑤、初始化弱引用对象流程一览 弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图： 这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然，storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？当释放对象时，其基本流程如下： ①、调用 objc_release②、因为对象的引用计数为 0，所以执行 dealloc③、在 dealloc 中，调用了_objc_rootDealloc 函数④、在 _objc_rootDealloc 中，调用了 object_dispose 函数⑤、调用 objc_destructInstance⑥、最后调用 objc_clear_deallocating，详细过程如下： a. 从 weak 表中获取废弃对象的地址为键值的记录 b. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nil c. 将 weak 表中该记录删除 d. 从引用计数表中删除废弃对象的地址为键值的记录 重点看对象被释放时调用的 objc_clear_deallocating 函数。该函数实现如下： 123456789void objc_clear_deallocating(id obj) &#123; assert(obj); assert(!UseGC); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating();&#125; 这个函数只是做一些判断以及更深层次的函数调用。 123456789101112131415161718void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); // 迭代器 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125; 也就是调用了 clearDeallocating()，继续追踪可以发现，它最终是使用了迭代器来取 weak 表的 value，然后调用 weak_clear_no_lock，然后查找对应的 value，将该 weak 指针置空，weak_clear_no_lock 函数的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id)&#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 简单来说，这个方法首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组，把每个地址存储的数据设为 nil ，最后把这个 key-value entry 从 weak 表中删除。 注意： ①、从实现中可以看出，weak 指针的使用涉及到 hash 表的增删改查，存在一定的性能开销。②、使用 weak 指针的时候，应首先获取一个 Strong 指针再使用。倒不是为了防止在使用过程中对象被回收，形成野指针。这个不用担心，因为你使用了 weak 指针，对象就会被加入到 autoreleasepool 中，可以放心使用。但是要注意的是，如果在一个代码块中频繁使用 weak 指针，还是应首先获取一个 Strong 指针，否则这个对象会被一次又一次的加入 autoreleasepool 中，也存在一定的性能开销。 五、拓展补充weak、__unsafe_unretained、unowned 与 assign 区别 __unsafe_unretained：不会对对象进行 retain，当对象销毁时，会依然指向之前的内存空间（野指针） weak：不会对对象进行 retain，当对象销毁时，会自动置为 nil __unsafe_unretained 可以修饰代表基础数据类型的 property，weak 不能修饰基础数据类型的 property。 使用 weak 是有代价的，因为通过上面的原理可知，__weak 需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况，因此 __unsafe_unretained 比 __weak 快。所以当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，__unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。 unowned 使用在 Swift 中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。 假如很明确的知道对象的生命期，也可以选择 unowned。 assign：实质与 __unsafe_unretained 等同 通过上面的描述，我们基本能了解一个 weak 引用从生到死的过程。从这个流程可以看出，一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 __weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 __weak 修饰符。 六、学习文章 weak 弱引用的实现方式iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）iOS weak 的底层实现weak 的生命周期：具体实现方法iOS 中 weak 的实现","tags":[]},{"title":"深拷贝和浅拷贝","date":"2019-05-22T10:52:52.721Z","path":"2019/05/22/深拷贝和浅拷贝/","text":"深拷贝和浅拷贝的本质区别是地址是否相同。 浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址； 深拷贝是真正的复制了一份，复制的对象指向了新的地址。 一、非容器类对象对象的 copy 是浅拷贝，mutableCopy 是深拷贝。 1、不可变 12345678910NSString * s1 = @\"AAA\";NSString * s2 = [s1 copy];NSString * s3 = [s1 mutableCopy]; NSLog(@\"%p %@\", s1, s1.class);NSLog(@\"%p %@\", s2, s2.class);NSLog(@\"%p %@\", s3, s3.class);0x1083a40e8 __NSCFConstantString0x1083a40e8 __NSCFConstantString0x60400044f840 __NSCFString 结论： ①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 2、可变 12345678910NSMutableString * ms1 = [NSMutableString stringWithString:@\"1\"];NSMutableString * ms2 = [ms1 copy];NSString * ms3 = [ms1 mutableCopy]; NSLog(@\"%p %@\", ms1, ms1.class);NSLog(@\"%p %@\", ms2, ms2.class);NSLog(@\"%p %@\", ms3, ms3.class);0x6040004500b0 __NSCFString0xa000000000000311 NSTaggedPointerString0x60400044fc60 __NSCFString 结论： ①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝； ②、copy 和 mutableCopy 返回对象都为可变对象。 二、容器对象1、不可变 123456789101112NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSArray * arr1 = [NSArray arrayWithObjects:ms, @\"2\", nil];NSArray * arr2 = [arr1 copy];NSArray * arr3 = [arr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]); 0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025a940 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 ③、容器内的元素始终都是浅拷贝。 2、可变 1234567891011NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:ms, @\"2\", nil];NSMutableArray * mArr2 = [mArr1 copy];NSMutableArray * mArr3 = [mArr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]);0x60000025aeb0 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037640 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025ae80 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；②、copy 返回不可变对象，mutableCopy 返回可变对象；③、容器内的元素始终是浅拷贝。 三、自定义类对象的深浅拷贝自定义的类需要遵循 才支持 copy，遵循 支持 mutableCopy。 12345678910111213141516171819202122@interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@end@implementation Person- (instancetype)copyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone]; // return self;&#125;- (instancetype)mutableCopyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone];&#125;@endPerson * p1 = [[Person alloc] init];Person * p2 = [p1 copy];Person * p3 = [p1 mutableCopy]; NSLog(@\"%p %@\", p1, p1.class);NSLog(@\"%p %@\", p2, p2.class);NSLog(@\"%p %@\", p3, p3.class);0x600000011e30 Person0x600000011f70 Person0x600000011f90 Person 四、实现容器对象的完全拷贝1234567891011NSMutableString * ms = [NSMutableString stringWithFormat:@\"1\"];NSArray * arr = [NSArray arrayWithObjects:ms, @\"2\", nil];NSLog(@\"%p %p\", arr[0], arr[1]);NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];NSLog(@\"%p %p\", mArr[0], mArr[1]);NSData * data = [NSKeyedArchiver archivedDataWithRootObject:mArr];NSMutableArray * newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];NSLog(@\"%p %p\", newMutableArr[0], newMutableArr[1]);0x6040004434b0 0x109c931000xa000000000000311 0x109c931000xa000000000000311 0xa000000000000321 由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。 自定义类对象需要遵循 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。 123456789- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self.xxx = [aDecoder decodeObjectForKey:@\"key\"]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.xxx forKey:@\"key\"];&#125; 五、总结只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。 六、学习文章深刻理解iOS中的“深拷贝”和“浅拷贝”","tags":[]},{"title":"String","date":"2019-05-22T10:48:05.651Z","path":"2019/05/22/String/","text":"一、字符串常量123456789101112131415161718@property (nonatomic, copy) NSString * string1;@property (nonatomic, weak) NSString * string2;&#123; NSString * temp = @\"AAAA\"; self.s1 = temp; NSLog(@\"temp -&gt; %p\", temp); self.s2 = self.s1; self.s1 = nil; NSLog(@\"s1 = %@，s2 = %@\", self.s1, self.s2); NSLog(@\"s1 -&gt; %p，s2 -&gt; %p\", self.s1, self.s2); NSLog(@\"retainCount = %@\", [temp valueForKey:@\"retainCount\"]);&#125;temp -&gt; 0x108551118s1 = (null)，s2 = AAAAs1 -&gt; 0x0，s2 -&gt; 0x108551118retainCount = 18446744073709551615 解释 1 temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。 即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。 另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子： 1NSString ** s2 = s1; // 需要关闭 arc 才能使用二级指针 这样 s1 = nil 后 s2 也是 nil 了。 解释 2 @”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。 self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。 字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。 致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。 12345678910&#123; NSString * temp1 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp2 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp3 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSString * temp4 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSLog(@\"%p %p\", temp1, temp2); NSLog(@\"%p %p\", temp3, temp4);&#125;0xa414141414141417 0xa4141414141414170x60000022a3a0 0x60000022a260 通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区： 如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。 二、Copy 和 strong@interface ViewController () @property (nonatomic, strong) NSString * sString; @property (nonatomic, copy) NSString * cString; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSMutableString * mString = [NSMutableString string]; [mString appendFormat:@&quot;AA&quot;]; self.sString = mString; self.cString = mString; NSLog(@&quot;mString -&gt; %p, sString -&gt; %p, cString -&gt; %p&quot;, mString, _sString, _cString); // mString -&gt; 0x600002565b30, sString -&gt; 0x600002565b30, cString -&gt; 0xcac34ab7cb397e8b NSLog(@&quot;%@&quot;, self.sString); // AA NSLog(@&quot;%@&quot;, self.cString); // AA [mString appendFormat:@&quot;BB&quot;]; NSLog(@&quot;%@&quot;, self.sString); // AABB NSLog(@&quot;%@&quot;, self.cString); // AA } @end 结果分析: 使用 strong 修饰 NSString 类型属性，指针指向可变字符串对象的地址，当可变字符串内容发生变化时，self.sStrong 相对应的也发生变化；使用 copy 修饰，会将可变字符串重新拷贝一份，重新开辟内存空间，修改 mutableString 的值不会对 self.cString 造成影响。","tags":[]},{"title":"malloc","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/malloc/","text":"原文：iOS内存管理和malloc源码解读 在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。 与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？ 和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。 如上所述，iOS 在外存没有交换区，没有内存页换出的过程。 一、malloc 基本原理在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。 创建新对象 [NSObject alloc]; 释放对象 [Object release]; 而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。 从苹果公开的 malloc 源码上来看，它的原理大致如下： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone。在 64 位环境下，会初始化 default zone 为 nano zone，同时初始化一个 scalable zone 作为 helper zone。nano zone 负责 nano 大小的分配，scalable zone 则负责 tiny、small 和 large内存的分配。 每次 malloc 时，根据传入的 size 参数，优先交给 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。 二、nano malloc在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为Magazine、Band 和 Slot 几个级别。 Magazine 范围对应于 CPU，CPU0 对应 Mag0，CPU1 对应 Mag1，依次类推 Band 范围为 2M，连续内存分配当内存不够时以 Band 为单位向内核请求 Slot 则对应于每个 Band 中 128K 大小的范围，每个 Band 都分为 16 个 Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配 分配过程： 确定当前 cpu 对应的 mag 和通过 size 参数计算出来的 slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 Band 中当前 Slot 耗尽则向系统申请新的 Band(每个 Band 固定大小 2M，容纳了 16 个 128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是 16 个)的二维数组形式，放在 nanozone_t 的 meta_data 字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。 除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data上挂着的空闲链表上内存区块回收来完成。 三、scalable zone 上内存分配简要分析对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。 在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为-1 的 magazine 作为后备之用。 下面是一个简图。 分配时(以 tiny 的情况为例)： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。这里需要注意的是，在一般情况下 free list 分为 64 个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63 为所有更大的内存区块挂载的地方。 上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。 如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 要是再不行就没招了，系统也给不到内存，就报错返回。 free 时： 检查指针指向地址是否有问题。 如果 last free 指针上没有挂载内存区块，则放到 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上(在挂载的 free list 前，会先根据 region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。 合并后所在的 region 如果空闲字节超过一定条件，则将把此 region 放到后备的 magazine 中(-1)。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。","tags":[]},{"title":"iOS 证书","date":"2019-05-22T08:51:44.499Z","path":"2019/05/22/iOS 证书/","text":"一、引言 什么是 App ID？Explicit/Wildcard App ID 有何区别？什么是 App Group ID？ 什么是证书（Certificate）？如何申请？有啥用？ 什么是Key Pair（公钥/私钥）？有啥用？与证书有何关联？ 什么是签名（Signature）？如何签名（CodeSign）？怎样校验（Verify）？ 什么是（Team）Provisioning Profiles？有啥用？ Xcode如何配置才能使用iOS真机进行开发调试？ 多台机器如何共享开发者账号或证书？ 遇到证书配置问题怎么办？ Xcode 7免证书调试真机调试 二、App ID（bundle identifier） App ID 即 Product ID，用于标识一个或者一组 App。 App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。 App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。 App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类： Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。 Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“*”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.*”可以表示Bundle Identifier以“com.apple.”开头的所有应用程序。 用户可在Developer MemberCenter网站上注册或删除已注册的App IDs。 App ID 被配置到【Target-&gt;Info-&gt;Bundle Identifier】下；对于 Wildcard App ID，只要 bundle identifier 包含其作为 Prefix/Seed 即可。 三、设备（Device） Device 就是运行 iOS 系统用于开发调试 App 的设备。每台Apple设备使用 UDID 来唯一标识。 iOS设备连接Mac后，可通过 iTunes-&gt;Summary 或者 Xcode-&gt;Window-&gt;Devices 获取 iPhone 的 UDID。 Apple Member Center 网站个人账号下的 Devices 中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册 100 个设备。 Apps signed by you or your team run only on designated development devices. Apps run only on the test devices you specify. 用户可在网站上注册或启用/禁用（Enable/Disable）已注册的 Device。本文的 Devices 是指连接到 Xcode 被授权用于开发测试的 iOS 设备（iPhone/iPad）。 四、开发证书（Certificates）4.1 证书 证书是由公证处或认证机关开具的证明资格或权力的证件，它是表明（或帮助断定）事理的一个凭证。证件或凭证的尾部通常会烙印公章。 每个中国人一生可能需要 70 多个证件，含 15 种身份证明。 4.2 数字证书 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在 Internet 上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。 它是由一个由权威机构——CA机构，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。 数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。 数字证书中的公开密钥（公钥）相当于公章。 某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。 为了防止 GFW 进行中间人攻击(MitM)，例如篡改 github 证书，导致无法访问 github 网站等问题，可选择不信任根证书。 在【钥匙串】中输入 ROOT 进行搜索，可以找到很多根证书，在【简介】|【使用此证书时】下拉选择【永不信任】。 4.3 iOS（开发）证书 iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。 iOS证书分为两类：Development 和 Production（Distribution）。 Development 证书用来开发和调试应用程序：A development certificate identifies you, as a team member, in a development provisioning profile that allows apps signed by you to launch on devices. Production 主要用来分发应用程序（根据证书种类有不同作用）：A distribution certificate identifies your team or organization in a distribution provisioning profile and allows you to submit your app to the store. Only a team agent or an admin can create a distribution certificate. 普通个人开发账号最多可注册 iOS Development/Distribution 证书各 2 个，用户可在网站上删除（Revoke）已注册的Certificate。 下文主要针对 iOS App 开发调试过程中的开发证书（Certificate for Development）。 4.4 iOS（开发）证书的根证书那么，iOS 开发证书是谁颁发的呢？或者说我们是从哪个 CA 申请到用于 Xcode 开发调试 App 的证书呢？ iOS 以及 Mac OS X 系统（在安装 Xcode 时）将自动安装 AppleWWDRCA.cer 这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。 AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer 之于 iOS（开发）证书则好比户籍证之于身份证。 如果 Mac Keychain Access 证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。 4.5 申请证书（CSR：Certificate Signing Request）可以在缺少证书时通过 Xcode Fix Issue 自动请求证书，这里通过 Keychain 证书助理从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。 keychain 将生成一个包含开发者身份信息的 CSR（Certificate Signing Request）文件；同时，Keychain Access|Keys 中将新增一对 Public/Private Key Pair（This signing identity consists of a public-private key pair that Apple issues）。 private key始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）对外发布的 App；public key一般随证书（Provisioning Profile）散布出去，对 App 签名进行校验认证。用户必须保护好本地 Keychain 中的 private key，以防伪冒。 Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an entirely new identity to sign code. Worse, if someone else has your private key, that person may be able to impersonate you. 在 Apple 开发网站上传该 CSR 文件来添加证书（Upload CSR file to generate your certificate）： Apple 证书颁发机构 WWDRCA(Apple Worldwide Developer Relations Certification Authority) 将使用private key 对 CSR 中的 public key 和一些身份信息进行加密签名生成数字证书（ios_development.cer）并记录在案（Apple Member Center）。 从 Apple Member Center 网站下载证书到 Mac 上双击即可安装（当然也可在 Xcode 中添加开发账号自动同步证书和【生成】配置文件）。证书安装成功后，在 KeychainAccess|Keys 中展开创建 CSR 时生成的 Key Pair 中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在 Keychain Access|Certificates 中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。 Certificate 被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Identity】下，下拉选择 Identities from Profile。 五、供应配置文件（Provisioning Profiles）5.1 Provisioning Profile的概念 Provisioning Profile文件包含了上述的所有内容：证书、App ID 和设备。 一个 Provisioning Profile 对应一个 Explicit App ID 或 Wildcard App ID（一组相同Prefix/Seed的App IDs）。 在网站上手动创建一个Provisioning Profile时，需要依次指定 App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的 Provisioning Profiles。 Provisioning Profile 决定 Xcode 用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product），将在应用程序打包时嵌入到 .ipa 包里。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备也通过它来认证安装的程序。 如果要打包或者在真机上运行一个APP，一般要经历以下三步： 首先，需要指明它的 App ID，并且验证 Bundle ID 是否与其一致； 其次，需要证书对应的私钥来进行签名，用于标识这个 APP 是合法、安全、完整的； 然后，如果是真机调试，需要确认这台设备是否授权运行该 APP。 Provisioning Profile 把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。 Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited），App ID 为 Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。 Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录 ~/Library/MobileDevice/Provisioning Profiles 下。 5.2 Provisioning Profile的构成以下为典型供应配置文件 *.mobileprovision 的 构成简析： （1）Name：该mobileprovision的文件名。（2）UUID：该mobileprovision文件的真实文件名。（3）TeamName：Apple ID账号名。（4）TeamIdentifier：Team Identity。（5）AppIDName：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。（6）ApplicationIdentifierPrefix：完整 App ID 的前缀（TeamIdentifier.*）。（7）DeveloperCertificates：包含了可以为使用该配置文件应用签名的所有证书。 证书是基于 Base64 编码，符合 PEM（PrivacyEnhanced Mail, RFC 1848）格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。 从 DeveloperCertificates 提取之间的内容到文件cert.cer（cert.perm）： —–BEGIN CERTIFICATE—– 将之间的内容拷贝至此 —–END CERTIFICATE—– Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥 KeyPair 配对）应吻合；Windows 下没有足够信息（WWDRCA.cer），无法验证该证书。 如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。 （8）Entitlements键对应的： keychain-access-groups：$(AppIdentifierPrefix)，参见Code Signing Entitlements(*.entitlements)。 每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的 keychain，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。 application-identifier：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。 com.apple.security.application-groups：App Group ID（group. com.apple），参见Code Signing Entitlements(*.entitlements)。 com.apple.developer.team-identifier：同Team Identifier。 （9）ProvisionedDevices：该mobileprovision授权的开发设备的UDID 。 Provisioning Profile 被配置到【XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。 六、开发组供应配置文件（Team Provisioning Profiles）6.1 Team Provisioning Profile的概念每个Apple开发者账号都对应一个唯一的 Team ID， Xcode3.2.3 预发布版本中加入了Team Provisioning Profile这项新功能。 在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑自动生成iOS Team Provisioning Profile（Managed by Xcode）。 Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(*)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。 6.2 Team Provisioning Profile生成/更新时机 Add an Apple ID account to Xcode Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode Assign Your App to a Team in Xcode project settings of General|Identity Register new device on the apple development website or Xcode detected new device connected 利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。 Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也被配置到【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。 七、App Group（ID）7.1 App Group的概念WWDC14除了发布了OS X v10.10和 Swift 外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。 扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。 App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。 7.2 App Group的配置Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范： 置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard） Extension App ID以Containing App ID为Prefix/Seed 假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.extImportRecording”。 关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。 App Group会被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。 八、证书与签名（Certificate&amp; Signature）8.1 Code Signing Identity Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。 Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性： 若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信； 再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。 8.2 Code Signing每个证书（其实是公钥）对应Key Pair中的私钥会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字签名（CodeSign）——使用哈希算法生成内容摘要（digest）。 Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。 8.3 Verify Code Signature with Certificate上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。 第一步，App在Mac／iOS真机上启动时，需要对配置的bundle ID、entitlements和certificate与Provisioning Profile进行匹配校验： 第二步，iOS/Mac真机上的ios_development.cer被AppleWWDRCA.cer中的 public key解密校验合法后，获取每个开发证书中可信任的公钥对App的可靠性和完整性进行校验。 iOS/Mac设备（系统）使用App Provisioning Profile （Code Signing Identity） 中的开发证书来判断App的合法性： 若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信； 再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。 小结： 基于Provisioning Profile校验了CodeSign的一致性； 基于Certificate校验App的可靠性和完整性； 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。 九、在多台机器上共享开发账户/证书9.1 Xcode导出开发者账号(*.developerprofile)或PKCS12文件(*.p12)进入Xcode Preferences|Accounts： 选中Apple IDs列表中对应Account的的Email，点击+-之后的☸|Export Accounts，可导出包含account/code signing identity/provisioning profiles信息的*.developerprofile（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。 选中右下列表中某行Account Name条目|ViewDetails，可以查看Signing Identities和Provisioning Profiles。 选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权export key “privateKey” from keychain，将导出Certificates.p12。** 点击左下角的刷新按钮可从Member Center同步该账号下所有的Provisioning Profile到本地。 选中右击列表中某个Provisioning Profile可以【Show in Finder】到[~/Library/MobileDevice/Provisioning\\ Profiles]目录，其中Provisioning Profile的真实名称为$(UUID).mobileprovision，名如”2488109f-ff65-442e-9774-fd50bd6bc827.mobileprovision”，其中Name中为Xcode中看到的描述性别名。 9.2 Keychain Access导出PKCS12文件(*.p12)在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出Certificates.p12——PKCS12 file holds the private key and certificate。 其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书。有了共享证书之后，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件，方可在iOS真机设备上开发调试。 十、证书配置常见错误 no such provisioning profile was found Xcode Target -&gt; Genera -&gt; Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.” Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioning profile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！ No identities from profile Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioning profile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain. Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（.developerprofile）或共享证书(.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。 Code Signing Entitlements file do not match profile “Invalid application-identifier Entitlement“ or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).” （1） 检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。（2） 也可以将Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。 Xcode配置反应有时候不那么及时 可刷新、重置相关配置项开关（若有）或重启Xcode试试。 十一、Xcode7 免证书真机调试在 Xcode 7 中，苹果改变了自己在许可权限上的策略： 此前 Xcode 只开放给注册开发者下载，现在 Xcode 7 改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。 此前开发者需每年支付99美元的费用成为注册开发者才能在 iPhone/iPad 真机上运行调试APP，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。——Developers would be able to test apps on devices without a paid Apple developer account in Xcode 7. 所谓“免证书”真机调试，并不是真的不需要证书，Xcode真机调试原有的证书配置体系仍在——All iOS, tvOS, and watchOS apps must be code signed and provisioned to launch on a device. 所以，上文啰嗦几千字还是有点用的。 自 Xcode7 开始，原来基于付费开发者账号及自助生成证书及配置文件的繁琐过程被苹果简化，Xcode将针对任何普通账号自动为联调真机生成所需相关的证书及配置文件。当你打算向 App Store 提交发布应用，才需要付费。 第一步：进入 Xcode Preferences|Accounts，添加自己的 Apple ID 账号。 第二步：Build Settings|Code Signing 下的 Provisioning Profile 选择 Automatic，Code Signing Identity 选择 Automatic 下的iOS Developer。 第三步：General 配置 Bundle identifier，Team 下拉选择苹果Member Center自动为你的账号生成的Personal Team ID。 自己的账号在调试公司或其他第三方APP代码时，若填写 Bundle identifier 为他人账号注册的 APP ID（例如苹果相机应用 com.apple.camera），会报错： No provisioning profiles with a valid signing identity (i.e. certificate and private key pair) matching the bundle identifier “com.apple.camera” were found. 即使编译通过了，可能运行时APP自身与服务器校验也可能会报签名错误，肿么办？？？ Her skill：此时，可以在他人原有App ID基础上添加后缀（例如com.apple.camera.extension），配置成应用的衍生插件（相当于置于同一 App Group 下）就可以快乐的玩耍了。 如果启动APP时，Xcode报错“process launch failed: Security”或iPhone报错【不受信任的开发者】，此时需要到iPhone通用配置中的描述文件（最新系统中可能叫设备管理）中，在描述文件（开发商应用）中选择对应的描述文件（你的Apple ID）点击 信任 或 验证 即可。 十二、推送证书APNS远程推送证书的申请和制作——详细解析APNS推送服务证书制作 图文详解教程 十三、学习文章《iOS开发各种证书问题》《iPhone真机调试应用程序》《iOS Developer：真机测试》《Xcode5 &amp; iOS 7 及以下版本免证书真机调试记录》《iOS Development–Certificates, Provisioning Profiles》《关于Certificate、Provisioning Profile、App ID的介绍及其关系》《数字签名和数字证书》《iOS keyChain 研究》《苹果开发者账号那些事儿》《iOS关于Provisioning Profiles這些事》《iOS Code Signing 学习笔记》《代码签名探析/Inside Code Signing》《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》《iOS行货自动打包》《解决Xcode无法生成Archive的问题》《iOS程序完成后如何生成ipa进行真机测试》《发布iOS应用程序(Application Loader)》《iOS发布遇到的一些问题》《Xcode打包ipa包》《iOS程序生成ipa进行真机测试》","tags":[]},{"title":"iOS Push","date":"2019-05-22T06:31:14.236Z","path":"2019/05/22/iOS Push/","text":"1、前言早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。 2、push流程 Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。 上图可以分为三个阶段：①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。 从上图可以看到： ①、在程序上注册远程通知，这是通知的前提（程序员的工作）；1234 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];&#125; ②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；123456789101112-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;#if !TARGET_IPHONE_SIMULATOR //注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做） self.deviceToken = [[[[devToken description] stringByReplacingOccurrencesOfString:@\"&lt;\"withString:@\"\"] stringByReplacingOccurrencesOfString:@\"&gt;\" withString:@\"\"] stringByReplacingOccurrencesOfString: @\" \" withString: @\"\"];#endif // 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送 [JPUSHService registerDeviceToken:devToken];&#125; ④、将这个 token 值发送到公司的服务器上去，存储下来。⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。 3、APNs的限制APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： 可靠性。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 Payload Size。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 成功率并不高。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。 4、不仅仅是Local Push很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。 Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。 5、叫醒你的App开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。 唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。 6、前台消息通道大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在12345678// iOS 10 Support- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123;&#125; 也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。 7、PushKitAPNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。 之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。 当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。 微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。 8、总结关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。 9、学习文章MrPeak杂货铺 &amp; iOS Push的门道Silent Push实现PushKit实现APNS推送服务证书制作 图文详解教程APNS远程推送证书的申请和制作——详细解析","tags":[]},{"title":"iOS 时间","date":"2019-05-21T08:15:20.020Z","path":"2019/05/21/iOS 时间/","text":"1、时间的形式在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。 1.1、GMT人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。 前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。 1.2、UTC太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。 我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。 接下来看下iOS里，五花八门的记录时间的方式。 2、NSDateNSDate是我们平时使用较多的一个类，先看下它的定义： NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001). NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。 这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。 理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：12NSDate* date = [NSDate date];NSLog(@\"current date interval: %f\", [date timeIntervalSinceReferenceDate]); timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。 又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：12NSDate* date = [NSDate date];NSLog(@\"current date: %@\", date); current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。 NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。 另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。 3、CFAbsoluteTimeGetCurrent()官方定义如下： Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock. 从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。 同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。 4、gettimeofday这个API也能返回一个描述当前时间的值，代码如下：1234struct timeval now;struct timezone tz;gettimeofday(&amp;now, &amp;tz);NSLog(@\"gettimeofday: %ld\", now.tv_sec); 使用gettimeofday获得的值是Unix time。Unix time又是什么呢？ Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。 Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：1date -r 1481266031 实际上NSDate也有一个API能返回Unix time：12NSDate* date = [NSDate date];NSLog(@\"timeIntervalSince1970: %f\", [date timeIntervalSince1970]); gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。 5、mach_absolute_time()mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。 前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。 不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。 mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。 6、CACurrentMediaTime()CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：123/* Returns the current CoreAnimation absolute time. This is the result of * calling mach_absolute_time () and converting the units to seconds. */CFTimeInterval CACurrentMediaTime (void) CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：12double mediaTime = CACurrentMediaTime();NSLog(@\"CACurrentMediaTime: %f\", mediaTime); 返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：12NSTimeInterval systemUptime = [[NSProcessInfo processInfo] systemUptime];NSLog(@\"systemUptime: %f\", systemUptime); CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。 7、sysctliOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：123456789101112131415161718#include &lt;sys/sysctl.h&gt;- (long)bootTime&#123;#define MIB_SIZE 2 int mib[MIB_SIZE]; size_t size; struct timeval boottime; mib[0] = CTL_KERN; mib[1] = KERN_BOOTTIME; size = sizeof(boottime); if (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, 0) != -1) &#123; return boottime.tv_sec; &#125; return 0;&#125; 返回的值是上次设备重启的Unix time。 这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。 有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。 8、场景一，时间测量我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。 在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。 客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。 上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：1234567891011121314151617int testCount = 10000;double avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; NSDate* begin = [NSDate date]; NSLog(@\"a meaningless log\"); avgCost += -[begin timeIntervalSinceNow];&#125;NSLog(@\"benchmark with NSDate: %f\", avgCost/testCount);avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; double startTime = CACurrentMediaTime(); NSLog(@\"a meaningless log\"); double endTime = CACurrentMediaTime(); avgCost += (endTime - startTime);&#125;NSLog(@\"benchmark with CACurrentMediaTime: %f\", avgCost/testCount); 输出结果为：12benchmark with NSDate: 0.000046benchmark with CACurrentMediaTime: 0.000037 可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：12#define TICK NSDate *startTime = [NSDate date]#define TOCK NSLog(@\"Time Cost: %f\", -[startTime timeIntervalSinceNow]) 9、场景二：客户端和服务器之间的时间同步这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。 比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？ 上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。 首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：1234567uint64_t realLocalTime = 0;if (serverTime != 0 &amp;&amp; lastSyncLocalTime != 0) &#123; realLocalTime = serverTime + (curLocalTime - lastSyncLocalTime);&#125;else &#123; realLocalTime = [[NSDate date] timeIntervalSince1970]*1000;&#125; 如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。 关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：1234567891011121314151617181920//get system uptime since last boot- (NSTimeInterval)uptime&#123; struct timeval boottime; int mib[2] = &#123;CTL_KERN, KERN_BOOTTIME&#125;; size_t size = sizeof(boottime); struct timeval now; struct timezone tz; gettimeofday(&amp;now, &amp;tz); double uptime = -1; if (sysctl(mib, 2, &amp;boottime, &amp;size, NULL, 0) != -1 &amp;&amp; boottime.tv_sec != 0) &#123; uptime = now.tv_sec - boottime.tv_sec; uptime += (double)(now.tv_usec - boottime.tv_usec) / 1000000.0; &#125; return uptime;&#125; gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。 多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。 10、学习文章MrPeak杂货铺iOS倒计时的探究与选择","tags":[]},{"title":"hexo+pages建站","date":"2019-05-14T07:42:50.947Z","path":"2019/05/14/hexo+pages建站/","text":"hexo史上最全搭建教程 解决用Hexo和GitHub搭建博客时hexo d命令报错问题 hexo d后 ERROR Deployer not found: git git-ssh 配置和使用 给博客添加文章目录 https://hexo.io/zh-cn/ Hexo博客多台电脑设备同步管理","tags":[]}]