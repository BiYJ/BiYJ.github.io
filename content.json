[{"title":"iOS 页面流畅技巧","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS 页面流畅技巧/","text":"一、屏幕显示图像原理首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。 二、卡顿产生的原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。 三、CPU 资源消耗的原因和解决方案3.1 对象的创建对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以： ①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适； ②、如果对象不涉及 UI 操作，尽量放到后台线程去创建； ③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用； ④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去； ⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 3.2 对象调整对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer： ①、CALayer 内部没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源； ②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改； ③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3.3 对象销毁当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了： 12345NSArray * tmp = self.arr_data;self.arr_data = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 3.4 对象布局在后台线程提前计算好视图布局、并对视图的布局进行缓存。 不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。 3.5 Autolayout这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但对于复杂视图来说常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。 3.6 文本计算如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。 3.7 文本渲染屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。 显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制，尽管麻烦但优势强大： ①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）； ②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。 3.8 图片解码用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。 该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 3.9 图像的绘制是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致） 123456789101112- (void)display&#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 四、GPU 资源消耗原因和解决方案GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。 4.1 纹理的渲染所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。 4.2 视图的混合（Composing）当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。 所以应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 也可以把多个视图预先渲染为一张图片来显示。 4.3 图形的生成CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。 当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。 对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。 最彻底的做法：把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 五、文章幸运的芳1990 &amp; 浅谈iOS页面流畅技巧","tags":[]},{"title":"iOS 响应链","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS 响应链/","text":"一、UIResponder app 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。 UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。 响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。 有时候可能会通过 UIResponder 来查找控件的父视图。 1234567891011121314151617181920212223242526272829/** * 通过遍历 UIView 上的响应链来查找当前顶部 vc */- (UIViewController *)firstVC&#123; for (UIView * next = self; next; next = next.superview) &#123; UIResponder * nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125;/** * 通过遍历 button 上的响应链来查找 cell */- (MyCell *)buttonTaped:(UIButton *)button&#123; UIResponder * responder = button.nextResponder; while (responder) &#123; if ([responder isKindOfClass:[MyCell class]]) &#123; MyCell * cell = (MyCell *)responder; break; &#125; responder = responder.nextResponder; &#125;&#125; 二、事件的第一响应者事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。 Touch event 第一响应者是触摸事件产生的 view Press event 第一响应者是焦点响应者。 Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象 ⚠️注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。 控件直接与它相关的 target 对象使用 action 消息通信。 当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。 如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。 三、事件的分发和传递 当iOS程序中发生触摸事件后，系统会将事件加入到 UIApplication 管理的一个任务队列中； UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。 UIWindow 将事件向下分发，即 UIView。 UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。 遍历子控件，重复以上两步。 如果没有找到，那么自己就是事件处理者。 如果自己不能处理，那么不做任何处理。 其中 UIView 不接受事件处理的情况主要有以下三种 alpha &lt; 0.01 userInteractionEnabled = NO hidden ＝ YES 这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果父视图不接受事件处理，那么子视图也不能接收事件。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。 四、hitTest:withEvent:1234/** * @return 本次点击事件需要的最佳 View */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。 ⚠️注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。 当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。 把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。 如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢? 事件传递给窗口或控件的后，就调用 hitTest:withEvent: 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到找到最合适的 view 或者废弃事件。 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // ①、判断当前控件能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // ②、判断触摸点在不在当前控件内 if ([self pointInside:point withEvent:event] == NO) return nil; // ②、倒序遍历自己的子控件 NSInteger count = self.subviews.count; for (NSInteger i = count - 1; i &gt;= 0; i--) &#123; UIView * childView = self.subviews[i]; // 把当前控件上的坐标系转换成子控件上的坐标系 CGPoint childP = [self convertPoint:point toView:childView]; UIView * fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; return fitView; // 找到了最合适的 view &#125; &#125; // 循环结束，表示没有比自己更合适的 view return self; &#125; 所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。 从后往前遍历子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。 视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。 如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。 如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。 如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。 如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。 四、pointInside:withEvent:1、判断触摸点是否在视图内。 1234/** * @brief 判断一个点是否落在范围内 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢? 扩大响应范围。 12345678910- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; /* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and decrease its size by `(2*dx, 2*dy)'. CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10 */ bounds = CGRectInset(self.bounds, -10, -10); return CGRectContainsPoint(bounds, point);&#125; 不规则的点击区域 123456789101112131415/** * @brief 改变图片的点击范围 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 控件范围宽度 +40，高度 +40 CGRect bounds = CGRectInset(self.bounds, -20, -20); UIBezierPath * path1 = [UIBezierPath bezierPathWithRect:CGRectMake(-20, 0, 40, 120)]; UIBezierPath * path2 = [UIBezierPath bezierPathWithRect:CGRectMake(self.frame.size.width - 20, 0, 40, 120)]; if (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; CGRectContainsPoint(bounds, point))&#123; return YES; // 如果在 path 区域内返回 YES &#125; return NO;&#125; 可以看出： 在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。 不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。 在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。 五、响应者链响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。 在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。 1、改变响应链 可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。 UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。 UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。 -UIWindow 下一个响应者为 UIApplication 对象。 UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。 六、文章Using Responders and the Responder Chain to Handle Events iOS开发 - 事件传递响应链 iOS响应链（Responder Chain）","tags":[]},{"title":"isa 和 Class","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/isa 和 Class/","text":"一、Runtime 简介Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要由运行时来决定了。 C 语言中，函数的调用在编译期就会决定调用哪个函数。而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。 Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。 Objc 在三种层面上与 Runtime 系统进行交互： 1、通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。 2、通过 Foundation 框架的 NSObject 类定义的方法 在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。 在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。 123456789101112131415161718192021222324/** * 返回对象的类 */- (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'anObject.dynamicType' instead\");/** * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类 */- (BOOL)isKindOfClass:(Class)aClass;/** * 检查对象是否是某个类的实例 */- (BOOL)isMemberOfClass:(Class)aClass;/** * 检查对象能否响应指定的消息 */- (BOOL)conformsToProtocol:(Protocol *)aProtocol;/** * 检查对象是否实现了指定协议类的方法 */- (BOOL)respondsToSelector:(SEL)aSelector; 在 NSObject 的类中还定义了一个方法 1234/** * 返回指定方法实现的地址 IMP */- (IMP)methodForSelector:(SEL)aSelector; 3、通过对 Runtime 库函数的直接调用 关于库函数可以在 Objective-C Runtime Reference 中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。 具体设置如下： 如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。 二、NSObject 起源与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自objc4-680 NSObject 的定义如下： 12345typedef struct objc_class *Class;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 在 Objc2.0 之前，objc_class 源码如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 指向成员变量列表的指针 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 指向方法列表指针的指针 struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif &#125; OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。 动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。 关于 Category，推荐 2 篇文章可以仔细研读：深入理解Objective-C：Category、结合 Category 工作原理分析 OC2.0 中的 runtime 然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 objc_private。 123456789101112131415161718192021222324252627typedef struct objc_class *Class;typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123;&#125; 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。 objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。 objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论： Objective-C 中类也是一个对象。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。 object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。 2.1 isa12345678910111213141516171819202122232425262728293031323334353637union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;# if __arm64__ struct &#123; uintptr_t indexed : 1; // 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化 uintptr_t has_assoc : 1; // 是否有设置过关联对象，如果没有，释放时会更快 uintptr_t has_cxx_dtor : 1; // 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被弱引用指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中 uintptr_t extra_rc : 19; // 里面存储的值是引用计数 - 1 &#125;;# elif __x86_64__ struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;# else# endif&#125; isa 详解 在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 64 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 What is a meta-class in Objective-C? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。 类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系： 实线是 super_class 指针，虚线是 isa 指针。 Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。 每个 Class 都有一个 isa 指针指向唯一的 Meta class Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。 每个 Meta class 的 isa 指针都指向 Root class（meta）。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 iOS 程序 main 函数之前发生了什么 2.1.1 isa_t 结构体的具体实现接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。 12345678910111213struct objc_object &#123;private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor); ...｝ 那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 objc_object。 1234567891011121314151617inline voidobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline voidobjc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)&#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。 1234567891011121314151617181920212223242526272829303132333435# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;; ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图： 参数的说明： index 代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。 在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer 的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：关于 Tagged Pointer 技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64 架构中有 33 位可以存储类指针。源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解 isa这篇文章里面的 shiftcls 分析。 magic判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。123456inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;关于 x86_64 的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。#### 2.2 cache_t 的具体实现继续看源码1234567891011121314151617struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; // 分配用来缓存 bucket 的总数 mask_t _occupied; // 表明实际占用的缓存 bucket 的个数&#125;typedef unsigned int uint32_t;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bitstypedef unsigned long uintptr_t;typedef uintptr_t cache_key_t;struct bucket_t &#123;private: cache_key_t _key; IMP _imp;&#125;根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。cache_t 中的 bucket_t _buckets 其实就是一个散列表，用来存储 Method 的链表。Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。#### 2.3 class_data_bits_t 的具体实现源码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;;在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。1class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags它为我们提供了便捷方法用于返回其中的 class_rw_t 指针：123class_rw_t *data() &#123; return bits.data();&#125;Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly在编译期，类的结构中的 class_data_bits_t data 指向的是一个 class_ro_t 指针：在运行时调用 realizeClass方法，会做以下 3 件事情：1. 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针2. 初始化一个 class_rw_t 结构体3. 设置结构体 ro 的值以及 flag最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。1234567891011121314struct method_t &#123; SEL name; // 方法名字 const char *types; // Type Encoding 类型编码 IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;;方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 Type Encoding。IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。整个运行时过程描述如下：更加详细的分析，请看@Draveness 的这篇文章深入解析 ObjC 中方法的结构到此，总结 objc_class 1.0 和 2.0 的差别。## 三、测试题1. [self class] 与 [super class]123456789101112@implementation Son : Father- (id)init&#123; if (self = [super init]) &#123; NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); &#125; return self;&#125;@endself 和 super 的区别： self 是类的一个隐藏参数，每个方法的实现的第一个参数即为 self。 super 并不是隐藏参数，它实际上只是一个“编译器标示符”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。在调用 [super class] 的时候，runtime 会去调用 objc_msgSendSuper 方法，而不是 objc_msgSend。1234567891011121314151617OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。objc_msgSendSuper 的工作原理应该是这样的：&gt; 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。那么 objc_msgSendSuper 最后就转变成1234567891011// 注意这里是从父类开始 msgSend，而不是从本类开始。objc_msgSend(objc_super-&gt;receiver, @selector(class))/// Specifies an instance of a class. 这是类的一个实例 __unsafe_unretained id receiver; // 由于是实例调用，所以是减号方法- (Class)class &#123; return object_getClass(self);&#125;由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。2. isKindOfClass 与 isMemberOfClass12345678910111213141516@interface Sark : NSObject@end@implementation Sark@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@\"%d %d %d %d\", res1, res2, res3, res4); &#125; return 0;&#125;先来分析一下源码这两个函数的对象实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;inline Class objc_object::getIsa() &#123; if (isTaggedPointer()) &#123; uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; &#125; return ISA();&#125;inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;首先题目中 NSObject 和 Sark 分别调用了 class 方法。+ (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去调用当前类的 obj-&gt;getIsa()，最后在 ISA() 方法中获得 meta class 的指针。接着在 isKindOfClass 中有一个循环，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。[NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。&gt; isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。3. Class 与内存地址下面的代码会？Compile Error / Runtime Crash / NSLog…?12345678910111213141516171819202122@interface Sark : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Sark- (void)speak &#123; NSLog(@\"my name's %@\", self.name);&#125;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak];&#125;@end这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？首先需要谈谈隐藏参数 self 和 _cmd 的问题。当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。难点一：能不能调用 speak 方法？12id cls = [Sark class]; void *obj = &amp;cls;答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。难点二：如果能调用 speak，会输出什么呢？很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。正确的答案会输出1my name is &lt;ViewController: 0x7ff6d9f31c50&gt;内存地址每次运行都不同，但是前面一定是 ViewController。why？我们把代码改变一下，打印更多的信息出来。12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj, &amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark, &amp;sark); [sark speak];&#125;我们把对象的指针地址都打印出来。输出结果：12345678ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8Sark class = Sark 地址 = 0x7fff543f5a88Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80my name is &lt;ViewController: 0x7fb570e2ad00&gt;Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78my name is (null)123// objc_msgSendSuper2() takes the current search class, not its superclass.OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);objc_msgSendSuper2 方法入参是一个 objc_super super。123456789101112131415/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;#endif所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。至此，Objc 中的对象到底是什么呢？实质：Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject，而对象的实例变量 void ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); NSString *myName = @\"halfrost\"; id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark,&amp;sark); [sark speak]; &#125;ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78Sark class = Sark 地址 = 0x7fff56a48a50Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48my name is halfrostSark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。 原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。 这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController： 1my name is &lt;ViewController: 0x7fb570e2ad00&gt; 其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？ obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。 LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示： x/ n、f、u 是可选的参数。 n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。 u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。 这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。 四、文章一缕殇流化隐半边冰霜 &amp; 神经病院Objective-C Runtime入院第一天–isa和Class","tags":[]},{"title":"Runtime","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/Runtime/","text":"一、简介C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。函数标识与函数实现之间的关联可以动态修改。 OC 把一些决定工作从编译链接推迟到运行时，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。 Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事： 封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。 传递消息，找出方法的最终执行代码。 ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）； ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发） 动态加载：NSBundle类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。 1234[receiver message]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)[receiver message:(id)arg...]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...) Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。 当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。runtime源码，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。 二、作用Objc 与 Runtime 相关： ①、通过 Objective-C 源代码②、通过 Foundation 框架的 NSObject 类定义的方法③、通过对 Runtime 库函数的直接调用 2.1 Objective-C 源代码多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。 2.2 通过 Foundation 框架的 NSObject 类定义的方法Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类） NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。 一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如： -class 方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中 -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol: 检查对象是否实现了指定协议类的方法； -methodForSelector: 返回指定方法实现的地址。 2.3 通过对 Runtime 库函数的直接调用Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。 许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。 三、Runtime 相关的头文件ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件 12345678910111213141516171819List.hNSObjCRuntime.hNSObject.hObject.hProtocol.ha.txthashtable.hhashtable2.hmessage.hmodule.mapobjc-api.hobjc-auto.hobjc-class.hobjc-exception.hobjc-load.hobjc-runtime.hobjc-sync.hobjc.hruntime.h 都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括： 3.1 操作对象的类型的定义1234567891011121314151617181920212223242526272829/// An opaque type that represents a method in a class definition. 一个类型，代表着类定义中的一个方法typedef struct objc_method *Method;/// An opaque type that represents an instance variable. 代表实例(对象)的变量typedef struct objc_ivar *Ivar;/// An opaque type that represents a category. 代表一个分类typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property. 代表OC声明的属性typedef struct objc_property *objc_property_t;// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取： 1234Class cls = obj.class;// NSLog(@\"%s\", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLEconst char * clsName = class_getName(cls);NSLog(@\"%s\", clsName); 3.2 函数的定义 操作对象的方法一般以 object_ 开头操作类的方法一般以 class_ 开头操作类或对象的方法的方法一般以 method_ 开头操作成员变量的方法一般以 ivar_ 开头操作属性的方法一般以 property_ 开头操作协议的方法一般以 protocol_ 开头 以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。 根据以上的函数的前缀可以大致了解到层级关系。 123456789101112// 使用 runtime 对当前的应用中加载的类进行打印- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; unsigned int count = 0; Class * clsList = objc_copyClassList(&amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = class_getName(clsList[i]); NSLog(@\"%s\", clsName); &#125;&#125; 四、术语及其数据结构4.1 SEL它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度。它的数据结构是： 1typedef struct objc_selector *SEL; // An opaque type that represents a method selector. 可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。 注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 4.2 idid 是一个参数类型，它是指向某个类的实例的指针。定义如下： 12typedef struct objc_object *id;struct objc_object &#123; Class isa; &#125;; objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。 Direct access to Objective-C’s isa is deprecated in favor of object_getClass() KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。 4.3 Class1typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ /* 父类 */ Class _Nullable super_class OBJC2_UNAVAILABLE; /* 类名 */ const char * _Nonnull name OBJC2_UNAVAILABLE; /* 类的版本信息，默认为 0 */ long version OBJC2_UNAVAILABLE; /* 类信息，供运行时期使用的一些位标识。 如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量; CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; */ long info OBJC2_UNAVAILABLE; /* 实例变量大小（包括从父类继承下来的实例变量）*/ long instance_size OBJC2_UNAVAILABLE; /* 成员变量地址列表 */ struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; /* 方法地址列表，与 info 的一些标志位有关。 如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法; */ struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; /* 缓存最近使用的方法地址，用于提升效率 */ struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; /* 存储该类声明遵守的协议的列表 */ struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif&#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： 123456789101112131415161718192021// 成员变量列表struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。深入理解 Objective-C: Category。 objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。 值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。 实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）； 类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。 为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。 1[NSObject.class alloc]; // [NSObject alloc] 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。 最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。 4.4 Method代表类中某个方法的类型。 123456789101112131415161718192021222324252627282930typedef struct objc_method *Method;struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法名 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; ``` * method\\_name 类型为 SEL* method\\_types 是个 char 指针，存储方法的参数类型和返回值类型* method\\_imp 指向了方法的实现，本质是一个函数指针#### 4.5 Ivar表示成员变量的类型。```objctypedef struct objc_ivar *Ivar;struct objc_ivar &#123; char * _Nullable ivar_name OBJC2_UNAVAILABLE; char * _Nullable ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef __LP64__ int space OBJC2_UNAVAILABLE; // 占用空间#endif&#125; 4.6 IMPobjc.h 中定义如下： 12// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针typedef id (*IMP)(id, SEL, ...); 它就是一个由编译器生成的函数指针，指向方法实现的首地址。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。 如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。 你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。 4.7 Cacheruntime.h 中定义如下： 123456789101112131415typedef struct objc_cache *Cachestruct objc_cache &#123; /* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/ unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; /* 实际占用cache buckets的总数 */ unsigned int occupied OBJC2_UNAVAILABLE; /* 指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。 指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长 */ Method _Nullable buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。 Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。 4.8 Property12typedef struct objc_property *Property;typedef struct objc_property *objc_property_t; // 这个更常用 可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性： 12345678OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT objc_property_t _Nonnull * _Nullableprotocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。 property_getName() 用来查找属性的名称，返回 c 字符串。property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。 五、消息体会官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。 这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤： ①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数； ②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 ③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。 ④、如果 cache 找不到就找类的方法列表中是否有对应的方法。 ⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。 ⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。 在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。 5.1 方法中的隐藏参数 我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？ 其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。 当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数： self 当前方法的对象指针，接受消息的对象 _cmd 当前方法的 SEL 指针，方法选择器 因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。 这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体： 12345678910111213struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */&#125;; 这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现： 123NSLog(@\"%@\", NSStringFromClass([super class]));2018-11-05 11:30:25.082134+0800 Demo[22838:128408] ViewController // 当前类 5.2 获取方法地址NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP： 1234567891011121314151617181920212223242526272829&#123; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; [self fail:YES]; &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;- (void)fail:(BOOL)value&#123;&#125;2018-11-05 13:06:22.683838+0800 Demo[36187:211037] 4.104993&#123; void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(fail:)]; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; setter(self, @selector(fail:), YES); &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;2018-11-05 13:05:48.480498+0800 Demo[36095:209893] 3.751424 虽然是更高效的调用方法，但这种做法很少用，除非是需要持续大量重复调用某个方法的情况，才会选择使用，以免消息发送泛滥。 注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性 六、动态方法解析如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。 1@dynamic propertyName; 这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。 Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。 12345678910111213141516void dynamicIMP(id self, SEL _cmd) &#123; // implementation ....&#125;@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicIMP, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;@end 上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：Type Encoding 动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。 七、消息转发 ①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步； ②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步； ③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步； ④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。 7.1 重定向消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(xxx:))&#123; return otherObj; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。 7.2 转发当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑： 123456789101112131415161718- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; return [otherObj methodSignatureForSelector:aSelector];&#125;/** * @param anInvocation 封装了原始的消息和消息的参数 */- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 判断 otherObj 对象是否实现了方法 if ([otherObj respondsToSelector:[anInvocation selector]]) &#123; [anInvocation invokeWithTarget:otherObj]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。 参数 anInvocation 是从哪来的？ 在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。 forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。 forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。 7.3 转发和多继承转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。 在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 7.4 转发与继承虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。 如果判断上图中的 Warrior 对象是否能响应 negotiate 消息： 12if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... 尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。 如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。 如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。 八、应用场景8.1 获取属性/成员变量列表12345678910// 简单的定义了一个成员变量和两个属性@interface Person : NSObject&#123; @private CGFloat _height;&#125;@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age;@end 使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表： 1234567891011121314151617181920212223242526- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = NSClassFromString(@\"Person\"); // Class cls = Person.class; unsigned int count = 0; // 获取成员变量数组 Ivar * ivarList = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 获取成员变量名 const char * ivarName = ivar_getName(ivarList[i]); NSLog(@\"%s\", ivarName); &#125; // 获取属性数组 objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ptyName = property_getName(ptyList[i]); NSLog(@\"%s\", ptyName); &#125;&#125;2018-11-04 17:28:03.905326+0800 Demo[5894:1444503] _height2018-11-04 17:28:03.905486+0800 Demo[5894:1444503] _name2018-11-04 17:28:03.905616+0800 Demo[5894:1444503] _age2018-11-04 17:28:03.905745+0800 Demo[5894:1444503] name2018-11-04 17:28:03.905877+0800 Demo[5894:1444503] age 从这里就可以看出 @property 做了三件事： ①、生成一个带下划线的成员变量②、生成这个成员变量的 set 方法③、生成这个成员变量的 get 方法 因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。 1234567891011@property (nonatomic, copy, readonly) NSString * name; // 只读属性- (NSString *)name&#123; return @\"job\";&#125;2018-11-04 17:52:52.690815+0800 Demo[6025:1474196] _height2018-11-04 17:52:52.691025+0800 Demo[6025:1474196] _age2018-11-04 17:52:52.691159+0800 Demo[6025:1474196] name2018-11-04 17:52:52.691308+0800 Demo[6025:1474196] age 当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。 一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好? 大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。 在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？ 首先要了解 setValue:forKeyPath: 方法的底层实现： ①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]②、查找有没有成员变量 _XX，如果有 _XX = value；③、查找有没有成员变量 XX，如果有 XX = value；④、如果都没有找到，直接报错。 123Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key name.' 首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。 另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc； 使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。 要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。 12345678910111213141516@property (nonatomic, weak) NSTimer * timer;@property (nonatomic, strong) NSThread * thread;@property (nonatomic, strong, readonly) AModel * a; // 自定义对象&#123; unsigned int count = 0; objc_property_t * propertyList = class_copyPropertyList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSLog(@\"%s\", property_getAttributes(propertyList[i])); &#125;&#125;2018-11-05 15:09:37.839596+0800 Demo[39749:288880] T@\"NSTimer\",W,N,V_timer2018-11-05 15:09:37.839692+0800 Demo[39749:288880] T@\"NSThread\",&amp;,N,V_thread2018-11-05 15:09:37.839771+0800 Demo[39749:288880] T@\"AModel\",R,N,V_a 通过 property_getAttributes() 方法获取属性的参数。 8.2 KVC字典转模型获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。 为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程： ①、遍历字典里面的所有 key，取出 key；②、取出 key 的 value，即 dict[key]；③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。 因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。 因此使用逐一为属性赋值的方法进行 KVC： 12345678910111213141516171819- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = Person.class; unsigned int count = 0; Person * person = [[Person alloc] init]; NSDictionary * dict = @&#123; @\"name\" : @\"Tom\", @\"age\" : @19, @\"height\": @175 &#125;; Ivar * ivars = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:clsName]; NSString * key = [name substringFromIndex:1]; // 去掉'_' [person setValue:dict[key] forKey:key]; &#125;&#125;2018-11-04 19:42:16.964474+0800 Demo[6425:1574210] height:175.0000，name:Tom，age:19，time:(null) 使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。 但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。 setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。 解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。 runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。Type Encodings 123456789101112131415for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; const char * coding = ivar_getTypeEncoding(ivars[i]); // 获取类型 NSString * strCode = [NSString stringWithUTF8String:coding]; id value = dict[key]; if ([strCode isEqualToString:@\"f\"]) &#123; // 判断类型是否是 float value = @(0.0); &#125; [person setValue:value forKey:key];&#125; method_getTypeEncoding() 函数可以获取到方法类型编码 12345678&#123; Method m = class_getInstanceMethod(self.class, @selector(do:at:on:)); NSLog(@\"%s\", method_getTypeEncoding(m));&#125;- (BOOL)do:(NSString *)something at:(char)place on:(int)count;2018-11-05 14:42:30.891829+0800 Demo[38588:270099] B32@0:8@16c24i28 property_getAttributes() 函数可以获取到属性的参数。Declared Properties 8.3 NSCoding 归档和解档获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样： 123456789101112131415161718192021222324252627282930313233- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [self valueForKey:key]; // 取出 key 对应的 value [aCoder encodeObject:value forKey:key]; // 编码 &#125;&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [aDecoder decodeObjectForKey:key]; // 解码 [self setValue:value forKey:key]; // 设置 key 对应的 value &#125; &#125; return self; &#125; 8.4 交换方法实现交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。 1234567891011121314151617+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method orginalMethod = class_getClassMethod([UIImage class], @selector(imageNamed:)); Method swizzleMethod = class_getClassMethod([UIImage class], @selector(my_imageNamed:)); //方法交换 method_exchangeImplementations(orginalMethod, swizzleMethod); &#125;);&#125;+ (UIImage *)my_imageNamed:(NSString *)name&#123; return [self my_imageNamed:name];&#125; 需要注意的是 ①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。 任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。 8.5 类/对象的关联对象关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联 123456789101112131415/* 参数 1 : 关联到对象 参数 2 : 关联的 key，可以是任意类型 参数 3 : 被关联的对象 参数 4 : 关联引用的规则 enum &#123; OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403 &#125;;*/objc_setAssociatedObject(self, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);id value = objc_getAssociatedObject(self, key); 8.6 动态添加方法，拦截未实现的方法每个类都有继承自 NSObject 的两个类方法 12+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel; 一个适用于类方法，一个适用于对象方法。 在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。 123456789101112131415161718192021222324// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmdvoid method(id self, SEL _cmd) &#123;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if ([NSStringFromSelector(sel) isEqualToString:@\"doSomething\"]) &#123; /* 参数 4 : const char *types 方法的类型 要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。 如果想要再增加参数，就可以从实现的第三个参数算起： class_addMethod(self, sel, method, \"v@:@\"); // 多一个对象类型参数增加了 @ void method(id self, SEL _cmd, NSString * name) &#123; &#125; 返回值：YES if the method was found and added to the receiver, otherwise NO. */ class_addMethod(self, sel, method, \"v@:\"); // 为 sel 指定实现为 method &#125; return YES;&#125; 8.7 动态创建一个类动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;objc/message.h&gt;void sayFunction(id self, SEL _cmd, id param) &#123; NSLog(@\"%ld岁的%@在%@说%@\", [object_getIvar(self, class_getInstanceVariable([self class], \"_age\")) integerValue], object_getIvar(self, class_getInstanceVariable([self class], \"_name\")), object_getIvar(self, class_getInstanceVariable([self class], \"schoolName\")), param);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 创建 Student 类。参数 1 : 父类 参数 2 : 类名 参数 3 : 通常为 0 Class StudentClass = objc_allocateClassPair(NSObject.class, \"Student\", 0); // 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型 // 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用 if (class_addIvar(StudentClass, \"schoolName\", sizeof(NSString *), 0, \"@\")) &#123; NSLog(@\"添加成员变量成功\"); &#125; // 添加 NSString * _name 成员变量 class_addIvar(StudentClass, \"_name\", sizeof(NSString *), 0, @encode(NSString *)); // 添加 int _age 成员变量 class_addIvar(StudentClass, \"_age\", sizeof(int), 0, @encode(int)); // 为 Student 类添加方法 \"v@:\" 这种写法见参数类型连接 SEL sel = sel_registerName(\"sayFunction:\"); if (class_addMethod(StudentClass, sel, (IMP)sayFunction, \"v@:@\")) &#123; NSLog(@\"添加方法成功\"); &#125; // 注册这个类到 runtime 系统中就可以使用了 objc_registerClassPair(StudentClass); // 使用创建的类 id student = [[StudentClass alloc] init]; // 给刚刚添加的变量赋值 // object_setInstanceVariable(student, \"schoolName\", (void *)&amp;str);在ARC下不允许使用 [student setValue:@\"清华大学\" forKey:@\"schoolName\"]; // KVC 动态改变实例变量 [student setValue:@\"Tom\" forKey:@\"name\"]; // 从类中获取成员变量Ivar Ivar ageIvar = class_getInstanceVariable(StudentClass, \"_age\"); // 为peopleInstance的成员变量赋值 object_setIvar(StudentClass, ageIvar, @18); // 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息 objc_msgSend(student, \"sayFunction:\", @\"你好~\"); // [student performSelector:sel withObject:@\"你好~\"]; // 动态调用未显式在类中声明的方法 student = nil; StudentClass = nil;// objc_disposeClassPair(StudentClass);&#125; 直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO 九、健壮的实例变量(Non Fragile ivars)在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。 当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移： 上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了： 我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？ 在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。 需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。 十、文章Mike_zh &amp; iOS-Runtime知识点整理 ian &amp; Objective-C Runtime 1小时入门教程 iOS开发-Runtime 详解 iOS RunTime 之数据结构 iOS 模块分解—「Runtime面试、工作」 Runtime 源码","tags":[]},{"title":"消息转发","date":"2019-05-23T10:19:03.940Z","path":"2019/05/23/消息转发/","text":"一、前言在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现 unrecognized selector sent to instance，导致应用 crash 的情况。 针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 NullSafe。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。 消息转发的整个过程主要涉及的 3 个方法： 123+(BOOL)resolveInstanceMethod:(SEL)sel;-(id)forwardingTargetForSelector:(SEL)aSelector;-(void)forwardInvocation:(NSInvocation*)anInvocation; 其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。 二、消息转发过程首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。 下边分析消息转发的过程，以 [MyObjet Length] 为例： ①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。 ②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。 ③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。 三、结合 MyObject 中的代码对消息转发流程进一步分析①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下： 12345678910111213+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; printf(\"%s:%s \\n\", __func__ ,NSStringFromSelector(sel).UTF8String); if (sel == @selector(length)) &#123; BOOL success = class_addMethod([self class], sel, (IMP)(length), \"q@:\"); if (success) &#123; return success; &#125; &#125; return [super resolveInstanceMethod:sel];&#125; 传入的 “q@:” 分别代表： 123q : 返回值 long long@ : 调用方法的的实例为对象类型: : 表示方法 下图表示了编码类型。 ②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637static NSArray * respondClasses;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; printf(\"%s:%s \\n\", __func__ , NSStringFromSelector(aSelector).UTF8String); id forwardTarget = [super forwardingTargetForSelector:aSelector]; if (forwardTarget) &#123; return forwardTarget; &#125; Class someClass = [self myResponedClassForSelector:aSelector]; if (someClass) &#123; forwardTarget = [someClass new]; &#125; return forwardTarget;&#125;- (Class)myResponedClassForSelector:(SEL)selector&#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; +(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。 ③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。 -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。 摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。 相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; printf(\"%s:%s \\n\\n\\n\\n\", __func__ , NSStringFromSelector(anInvocation.selector).UTF8String); anInvocation.target = nil; [anInvocation invoke];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; Class responededClass = [self myResponedClassForSelector:selector]; if (responededClass) &#123; @try &#123; signature = [responededClass instanceMethodSignatureForSelector:selector]; &#125; @catch (NSException *exception) &#123; &#125;@finally &#123; &#125; &#125; &#125; return signature;&#125;- (Class)myResponedClassForSelector:(SEL)selector &#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; 这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。 12345678910111213141516171819202122232425262728293031323334353637&lt;NSMethodSignature: 0x6000030a17c0&gt; number of arguments = 2 frame size = 224 is special struct return? NO return value: -------- -------- -------- -------- type encoding (f) 'f' flags &#123;isFloat&#125; modifiers &#123;&#125; frame &#123;offset = 16, offset adjust = 0, size = 16, size adjust = -12&#125; memory &#123;offset = 0, size = 4&#125; argument 0: -------- -------- -------- -------- type encoding (@) '@' flags &#123;isObject&#125; modifiers &#123;&#125; frame &#123;offset = 0, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125; argument 1: -------- -------- -------- -------- type encoding (:) ':' flags &#123;&#125; modifiers &#123;&#125; frame &#123;offset = 8, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125;``` NSInvocation。仍然以`myObject`调用`length`方法为例。 \\- (void)forwardInvocation:(NSInvocation \\*)anInvocation中的 anInvocation 的信息如下：```objc&lt;NSInvocation: 0x6000025b8140&gt;return value: &#123;Q&#125; 0target: &#123;@&#125; 0x60000322c360selector: &#123;:&#125; length&gt; return value 指返回值，\"Q\" 表示返回值类型为 long long 类型；&gt; target 指的是消息的接收者，\"@\"标识对象类型；&gt; selector 指的是方法，\":\"表示是方法，后边的 length 为方法名。 更多内容可见下图 NSInvocation 的 types： 12345678910111213141516171819enum _NSObjCValueType &#123; NSObjCNoType = 0, NSObjCVoidType = 'v', NSObjCCharType = 'c', NSObjCShortType = 's', NSObjCLongType = 'l', NSObjCLonglongType = 'q', NSObjCFloatType = 'f', NSObjCDoubleType = 'd', NSObjCBoolType = 'B', NSObjCSelectorType = ':', NSObjCObjectType = '@', NSObjCStructType = '&#123;', NSObjCPointerType = '^', NSObjCStringType = '*', NSObjCArrayType = '[', NSObjCUnionType = '(', NSObjCBitfield = 'b'&#125; API_DEPRECATED(\"Not supported\", macos(10.0,10.5), ios(2.0,2.0), watchos(2.0,2.0), tvos(9.0,9.0)); 四、尚存疑点细心的读者可能会发现在首次消息转发的时候流程并不是 123+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length -[MyObject forwardInvocation:]:length 而是 12345+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length +[MyObject resolveInstanceMethod:]:length +[MyObject resolveInstanceMethod:]:_forwardStackInvocation: -[MyObject forwardInvocation:]:length 查看了开源源码 NSObject.mm 相关源码如下： 12345678910111213// Replaced by CF (returns an NSMethodSignature)- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];&#125;// Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, object_getClassName(self), sel_getName(sel), self);&#125; 五、NSNull+QiNullSafe.m根据 NullSafe 仿写的 NSNull+QiNullSafe.m。 NSNull+QiNullSafe.m 能够避免的问题有： NSNull *null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@”aaa”];[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];[null performSelector:@selector(valueForKey:) withObject:@”aaa”];[null performSelector:@selector(length) withObject:nil];[null performSelector:@selector(integerValue) withObject:nil];[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];[null performSelector:@selector(bytes) withObject:nil]; 六、NullSafe 是怎么处理 null 问题其实 NullSafe 处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。 不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。 注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。 七、单元测试1234567891011121314151617181920212223- (void)testStringValue&#123; id null = [NSNull null]; NSString * string = [null stringValue]; XCTAssertNil(string);&#125;- (void)testFloatValue&#123; id null = [NSNull null]; CGFloat f = [null floatValue]; XCTAssertEqualWithAccuracy(f, 0.0f, 0.0f);&#125;- (void)testPerformSelector&#123; NSNull * null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@\"aaa\"];&#125; 八、文章iOS 消息转发 Protocol 协议分发器","tags":[]},{"title":"图片加载和处理","date":"2019-05-23T10:19:03.939Z","path":"2019/05/23/图片加载和处理/","text":"一、图片显示图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。 以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。UIImage 持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。 当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。 解码是一个计算量较大且需要 CPU 来执行的任务；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 高 每个像素点的大小 = width height 4bytes。 图像解码操作会造成什么问题？ 以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于在主线程同时进行 IO 操作、解码操作等，会造成内存迅速增长和 CPU 负载瞬间提升。 并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。 1.1 优化一：降采样在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示： 我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。 思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？ 12345678910111213141516171819202122- (UIImage *)downsampleImageAt:(NSURL *)imageURL to:(CGSize)pointSize scale:(CGFloat)scale&#123; CFDictionaryRef imageSourceOptions = CFDictionaryCreate ( CFAllocatorGetDefault(), (void *)@[ (NSString *)kCGImageSourceShouldCache ], (void *)@[ @(YES) ], 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, imageSourceOptions); NSInteger maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale; CFDictionaryRef downsampleOptions = (__bridge CFDictionaryRef)@&#123; (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @(YES), (NSString *)kCGImageSourceShouldCacheImmediately : @(YES), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @(YES), (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;; CGImageRef downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions); return [UIImage imageWithCGImage:downsampledImage];&#125; 正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。 1.2 优化二：异步处理 从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以在 Prefetching 时把降采样放到子线程进行处理，因为降采样过程就包括解码操作。 Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。 需要特别注意，此处不能是并发队列，否则会造成线程爆炸，原因见总结部分。 123456789101112131415161718192021222324252627282930313233343536&#123; // 创建串行队列 _serialQueue = dispatch_queue_create(\"DecodeQueue\", DISPATCH_QUEUE_SERIAL);&#125;/** * @brief 获取单元格的图片 */- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAt:(NSArray&lt;NSIndexPath *&gt; *)indexPaths&#123; for (NSIndexPath * indexPath in indexPaths) &#123; dispatch_async(_serialQueue, ^&#123; UIImage * downsampledImage = [self downsample]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self updateAt:indexPath with:downsampledImage]; &#125;); &#125;); &#125;&#125;/** * @brief 降采样。自行实现。 */- (UIImage *)downsample&#123; return nil;&#125;/** * @brief 更新单元格的图片 */- (void)updateAt:(NSIndexPath *)indexPath with:(UIImage *)image&#123; &#125; 1.3 优化三：使用 Image Asset Catalogs苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。 WWDC Session。 二、总结应用上述的优化策略，已经能对图片加载有比较好的优化。 WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。 三、WWDC学习原作者的经验：落影loyinglin 先主观假设两个前提： ①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚； ②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。 所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，看我们的 iOS 知识体系是否存在缺陷；另外，WWDC 介绍的很多知识点同样免验证的加入自己的知识体系。 以上文提到的线程爆炸为例，看看这种方式的好处。 原文如下： Thread Explosion（线程爆炸） More images to decode than available CPUs（解码图像数量大于 CPU 数量）GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像） 从这个案例我们学习到如何避免图像解码的线程爆炸，我们分析苹果工程师的逻辑，然后扩散思维： 原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间 延伸出来的问题： GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？… 举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来： ①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别； ②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。 接下来的表现是操作系统相关的知识： ①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程； ②、cpu 的时间是分为多个时间片，每个线程轮询执行； ③、线程切换执行有代价，但比进程切换小得多； ④、每个 cpu 核心在同一时刻只能执行一个线程。 至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现： 主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。 结合此案例，我们能回答相关问题： ①、现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？ ②、GCD 的串行队列和并发队列的应用场景有何不同？ 四、文章iOS性能优化–图片加载和处理 WWDC2018-Image and Graphics Best Practices","tags":[]},{"title":"NSDateFormatter性能","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/NSDateFormatter性能/","text":"一、探究123NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];NSString * current = [dateFormatter stringFromDate:[NSDate date]]; 关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。 1234567891011121314151617181920212223242526272829303132333435363738394041double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = nil;&#123; begin = CACurrentMediaTime(); for (int i = 0; i &lt; 1000; i++) &#123; formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter: %8.2f ms\", (end - begin) * 1000);&#125;&#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter once: %8.2f ms\", (end - begin) * 1000);&#125;-----------Xcode 10.1 iPhone 6s(10.0)----------2019-03-01 10:08:42.184 Demo[95118:1359994] NSDateFormatter: 48.73 ms2019-03-01 10:08:42.188 Demo[95118:1359994] NSDateFormatter once: 3.57 ms2019-03-01 10:11:18.871 Demo[95164:1361958] NSDateFormatter: 61.18 ms2019-03-01 10:11:18.875 Demo[95164:1361958] NSDateFormatter once: 3.85 ms2019-03-01 10:12:03.123 Demo[95178:1362677] NSDateFormatter: 79.80 ms2019-03-01 10:12:03.129 Demo[95178:1362677] NSDateFormatter once: 6.08 ms 上面可以看出两者之间消耗时间差距很大。创建单例很有必要。 那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？ 123456789101112131415161718192021222324252627282930313233343536373839NSDateFormatter * formatter = nil;double begin = 0.0;double end = 0.0;double a = 0, b = 0, c = 0;for (int i = 0; i &lt; 1000; i++) &#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; end = CACurrentMediaTime(); a += (end - begin); begin = CACurrentMediaTime(); [formatter setDateFormat:@\"yyyy-MM-dd\"]; end = CACurrentMediaTime(); b += (end - begin); begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); c += (end - begin);&#125;NSLog(@\"NSDateFormatter:alloc %8.2f ms\", a * 1000);NSLog(@\"NSDateFormatter:setFormat %8.2f ms\", b * 1000);NSLog(@\"NSDateFormatter:stringFromDate %8.2f ms\", c * 1000);-------------Xcode 10.1 iPhone 6s(10.0)-------------2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:alloc 7.01 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:setFormat 0.28 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:stringFromDate 55.98 ms2019-03-01 10:12:03.198 Demo[95178:1362677] NSDateFormatter:alloc 7.69 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:setFormat 0.25 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:stringFromDate 60.97 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:alloc 6.01 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:setFormat 0.20 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:stringFromDate 49.06 ms 从上面可以看出，实际最耗时的方法是 stringFromDate:/dateFromString:。再往下细究。 1234567891011121314151617181920212223242526272829303132double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); NSLog(@\"%8.2f ms\", (end - begin) * 1000);&#125;-------------Xcode 10.0 iPhone 6s(10.0)-------------2019-03-01 10:27:06.218 Demo[95456:1372764] 1.43 ms2019-03-01 10:27:06.218 Demo[95456:1372764] 0.03 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms 从上面可以看出，只有首次调用 stringFromDate:/dateFromString: 方法才会很耗时。再往下细究。 还有人说应该针对 format 格式创建对应的单例对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double begin = 0.0;double end = 0.0;// 不同的对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter1 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter2 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter3 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter4 = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter1 setDateFormat:@\"yyyy-MM-dd\"]; [formatter1 stringFromDate:[NSDate date]]; [formatter2 setDateFormat:@\"MM-dd-yyyy\"]; [formatter2 stringFromDate:[NSDate date]]; [formatter3 setDateFormat:@\"MM-dd\"]; [formatter3 stringFromDate:[NSDate date]]; [formatter4 setDateFormat:@\"MM-yyyy\"]; [formatter4 stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: different format %8.2f ms\\n\", (end - begin) * 1000);&#125;// 同一个对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd-yyyy\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-yyyy\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: %8.2f ms\\n\", (end - begin) * 1000);&#125;---------------Xcode 10.1 iPhone 6s(10.0)---------------NSDateFormatter: different format 23.26 msNSDateFormatter: 16.25 ms 如果不计 NSDateFormatter 对象的初始化时间，那么打印输出： 12NSDateFormatter:different format 23.81 msNSDateFormatter: 23.02 ms 两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。 二、文章NSDateFormatter 性能测试","tags":[]},{"title":".pch","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/pch/","text":"Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的预编译头文件，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之后则需要手动创建。 一、作用①、定义全局性宏； ②、引用全局性头文件； ③、根据运行环境，自动打开或者关闭日志输出功能。 二、优点①、PCH 文件的内容能被项目中的其他所有文件共享和访问，其它地方可直接使用，不用再手动重复定义或引用； ②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而提高编译速度。 三、缺点①、把类中使用的框架等放到 PCH 中，依赖关系不明确，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。 ②、大量的共用性不高的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长； 四、思考①、PCH 的目的是：提高编译速度，而不是少敲几行 #import； ②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用； ③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。 ④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。 ⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。 ⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。 ⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。 五、文章PCH 文件的优缺点 PCH文件的新建和其缺点","tags":[]},{"title":"iOS 内置图片瘦身","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/iOS 内置图片瘦身/","text":"一、iOS 内置资源的集中方式1.1 将图片存放在 bundle这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到隔离资源的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。 这种方式有比较明显的缺点： ①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。 ②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。 在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。 下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下： 以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。 1.2 使用 .ttf 字体文件替代图标使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。 使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。 字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。 123UILabel * iconLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];iconLabel.font = [UIFont fontWithName:@\"icomoon\" size:50];iconLabel.text = [NSString stringWithUTF8String:\"\\ue902\"]; 由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。 优点： ①、可以降低应用图片内置资源的体积。 ②、可以随意缩放和修改颜色。 缺点： ①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。 ②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。 任何一种需要大刀阔斧改革的优化都是一种不明智的行为。 1.3 图片存在 Assets.xcassets使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。 二、优化项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。 为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。 与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。.framework 中可以存放资源，但 .a 不可以，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。 优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。 先要抛出两个问题： &emsp;①、cocoapods 是否支持使用 Assets.xcassets。 &emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。 为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数： 1234567s.source_files ：源文件路径。s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。s.resources ：资源文件路径及文件类型。s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。 实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。 如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。 查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。 最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。 运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。 既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案： ①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。 ②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。 ③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。 ④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。 只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示： 看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。 为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如 很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。 123456789- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); return value;&#125; 打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。 在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。 这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息： 重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。 12345678910111213141516171819202122- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @\"emaNecruoseRIU\"; // 反转字符串 propKey = [XUtil stringByReversed:propKey]; if ([key isEqualToString:propKey]) &#123; if (normal_imageName) &#123; select_imageName = value; &#125; else &#123; normal_imageName = value; &#125; &#125; return value;&#125; hook UIImageView 的 initWithCoder: 12345678910111213141516171819202122- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; if (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[NSString class]] &amp;&amp; normal_imageName.length &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:normal_imageName]; // 赋值 if (normalImage) &#123; instance.image = normalImage; &#125; normal_imageName = nil; select_imageName = nil; &#125; return instance;&#125; 上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。 但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对增加了项目维护的难度。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。 hook method_exchangeImplementations 方法。 检测方法（字典写入时不要忘了加锁）。 这种方式不能区分 image 和 backgroundImage、normal 和 Selected。目前根据观察顺序应该是： 1234UIResourceName ： normal - image(前景图)UIResourceName ： normal - backgroundImage(背景图)UIResourceName ： selected - image(前景图)UIResourceName ： selected - backgroundImage(背景图)","tags":[]},{"title":"iOS 单例","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/iOS 单例/","text":"一、单例介绍单例：该类在程序运行期间有且仅有一个实例。 1.1 单例的主要优点①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例； ②、因为类控制了实例化过程，所以类可以灵活更改实例化过程； ③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。 1.2 单例的主要缺点①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放； ②、单例不能继承。 二、单例的实现单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。 主要是做到以下几点： 防止调用 [[A alloc] init] 引起的错误防止调用 new 引起的错误防止调用 copy 引起的错误防止调用 mutableCopy 引起的错误 2.1 实现方式一 把所有可能出现的初始化方法做了相应的处理来其保证安全性 1234567891011121314151617181920212223242526272829+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 不能再使用 alloc 方法 // 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法 _sharedSingleton = [[super allocWithZone:NULL] init]; &#125;); return _sharedSingleton;&#125;// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.- (id)copyWithZone:(nullable NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.- (id)mutableCopyWithZone:(nullable NSZone *)zone &#123; return [Singleton sharedSingleton];&#125; 2.2 实现方式二 不做处理的情况下禁止外部调用 一些成熟的第三方代码的单例中也有使用该方法的。 123456789101112131415161718.h 文件- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (id)copy NS_UNAVAILABLE;- (id)mutableCopy NS_UNAVAILABLE;.m 文件+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _sharedSingleton = [[self alloc] init]; // 要使用 self 来调用 &#125;); return _sharedSingleton;&#125; 当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。 三、单例的滥用3.1 全局状态大多数的开发者都认同使用全局可变的状态是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。 12345678910@implementation SPMath&#123; NSInteger _a; NSInteger _b;&#125; - (NSInteger)add&#123; return _a + _b;&#125; 在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题： add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。 当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。 把下面的代码和上面的例子做对比: 1234+ (NSUInteger)addOf:(NSUInteger)a plus:(NSUInteger)b&#123; return a + b;&#125; 这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为类方法，这样就显式的告诉了代码的阅读者：这个方法不会修改任何实例的状态。 那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“单例就是披着羊皮的全局状态” 。 一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。 12345678910111213141516171819202122232425262728@interface Singleton : NSObject+ (instancetype)sharedInstance;- (NSString *)name;- (void)setName:(NSString *)name;@end@implementation A - (void)a &#123; if ([[Singleton sharedInstance] name]) &#123; // ... &#125;&#125;@end@implementation B- (void)b&#123; [[Singleton sharedInstance] setName:\"\"];&#125;@end 在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的共享状态来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致隐式的在两个看起来完全不相关的模块之间建立了耦合。 来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。 想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器： 123456@interface URLCache+ (NSCache *)sharedURLCache;- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;@end 这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。 几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？ 原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。 持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。 3.2 对象的生命周期另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。 假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例： 1234567@interface ThumbnailCache : NSObject+ (instancetype)sharedThumbnailCache;- (void)cacheProfileImage:(NSData *)imageData forUserId:(NSString *)userId;- (NSData *)cachedProfileImageForUserId:(NSString *)userId;@end 继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。 当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。 问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例： 123456789101112131415static ThumbnailCache * sharedThumbnailCache;+ (instancetype)sharedThumbnailCache&#123; if (!sharedThumbnailCache) &#123; sharedThumbnailCache = [[self alloc] init]; &#125; return sharedThumbnailCache;&#125;+ (void)cleanUp&#123; // The SPThumbnailCache will clean up persistent states when deallocated sharedThumbnailCache = nil;&#125; 这是一个明显的对单例模式的滥用，但是它可以工作，对吧。 当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作： 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];&#125;); 需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。 由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。 分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。 举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。 这里我们得到的教训是：单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。 四、避免使用单例既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？ 重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。 123456789101112131415@interface User : NSObject@property (nonatomic, readonly) ThumbnailCache * thumbnailCache;@end @implementation User- (instancetype)init&#123; if ((self = [super init])) &#123; _thumbnailCache = [[ThumbnailCache alloc] init]; &#125; return self;&#125;@end 现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。 现在假设我们有一个 VC 来展现好友列表： 12345@interface FriendListVC : UIViewController- (instancetype)initWithUser:(User *)user; @end 我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，并且它有很多优点： ①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。 ②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];&#125;); 这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。 为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。 假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示： vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。 当用户登出后，清理 rootViewController 并且退出到登录页面： 这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。 使用依赖注入的对象图： 简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了简化 applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示： 这个对象图看起来和使用单例时很像。这有什么区别？ 关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互： 当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态： 五、结论在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。 这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。 六、文章避免滥用单例","tags":[]},{"title":"依赖注入","date":"2019-05-23T10:19:03.938Z","path":"2019/05/23/依赖注入/","text":"一、简介依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。 初始化方法注入： 1- (instancetype)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2; 属性注入： 12@property (nonatomic, retain) Dependency1 * dependency1;@property (nonatomic, retain) Dependency2 * dependency2; 一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。 二、为什么使用依赖注入依赖注入的几个重要之处： ①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量； ②、使用构成。 即一直坚持的多构成少继承原则。它能提高代码的可重用性； ③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。 ④、明确的所有者。 ⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。 三、使用依赖注入3.1 注入类的类型首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。 简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。 复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。 分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。 3.2 在初始化时依赖分配原始代码： 12345678910111213141516@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)init&#123; if (self = [super init]) &#123; ... _engine = [[RCEngine alloc] init]; &#125; return self;&#125;@end 使用依赖注入改版后： 1234567891011121314151617@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine&#123; if (self = [super init]) &#123; ... _engine = engine; &#125; return self;&#125;@end 3.3 延迟初始化依赖通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子： 1234567891011@implementation RCRaceCar- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init]; [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。 工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。 下面，通过一个工厂，使用依赖注入创建一个灭火器。 1234567891011121314151617181920212223242526272829typedef RCFireExtinguisher *(^RCFireExtinguisherFactory)();@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@property (nonatomic, copy, readonly) RCFireExtinguisherFactory fireExtinguisherFactory;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory&#123; if (self = [super init]) &#123; ... _engine = engine; _fireExtinguisherFactory = [extFactory copy]; &#125; return self;&#125;- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = self.fireExtinguisherFactory(); [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下： 123456789101112131415161718@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;&#123; if (self = [super init]) &#123; _engine = engine; _transmission = transmission; _leftFrontWheel = wheelFactory(); _leftRearWheel = wheelFactory(); _rightFrontWheel = wheelFactory(); _rightRearWheel = wheelFactory(); // 保留轮子工厂，之后还需要一个备胎。 _wheelFactory = [wheelFactory copy]; &#125; return self;&#125;@end 四、避免多余的配置如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。 在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。 为了配置我们的对象，将从 4 个点来收集我们的依赖： ①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中； ②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值； ③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。 ④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。 下面是关于赛车的简单初便利构造器 12345678910111213+ (instancetype)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency&#123; RCEngine * engine = [[RCEngine alloc] init]; RCTransmission * transmission = [[RCTransmission alloc] init]; RCWheel *(^wheelFactory)() = ^&#123; return [[RCWheel alloc] init]; &#125;; return [[self alloc] initWithEngine:engine transmission:transmission pitRadioFrequency:frequency wheelFactory:wheelFactory];&#125; 便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。 五、系统单例在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。 这里建议避免在你的代码中创建全局的单例，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。 六、不可修改的构造函数有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码： 12345// 一个我们不能直接调用初始化方法的例子。RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];// 我们仍然可以使用属性来配置我们的赛车路径raceTrack.width = 10;raceTrack.numberOfHairpinTurns = 2; setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。 七、类注册“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码： 123456789101112131415161718192021NSArray * raceCarClasses = @[ [RCFastRaceCar class], [RCSlowRaceCar class] ];NSMutableArray *raceCars = [[NSMutableArray alloc] init];for (Class raceCarClass in raceCarClasses) &#123; // 所有赛车必须有相同的初始化方法 (在这个例子中是 \"init\" 方法). // 这里意味着我们不能自定义不同的子类 [raceCars addObject:[[raceCarClass alloc] init]];&#125;// 一个简单的替换方法是：使用工厂 block 来代替typedef RCRaceCar *(^RCRaceCarFactory)();NSArray * raceCarFactories = @[ ^&#123; return [[RCFastRaceCar alloc] initWithTopSpeed:200]; &#125;, ^&#123; return [[RCSlowRaceCar alloc] initWithLeatherPlushiness:11]; &#125; ];NSMutableArray * raceCars = [[NSMutableArray alloc] init];for (RCRaceCarFactory raceCarFactory in raceCarFactories) &#123; // 现在这样，我们就不用关心到底是那个初始化方法被调用了 [raceCars addObject:raceCarFactory()];&#125; 八、StoryboardsStoryboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。 解决方法是避免使用 storyboard。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。 九、公有和私有依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。 12345678910111213141516// In public ObjectA.h.@interface ObjectA// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件- (instancetype)initWithObjectB:(ObjectB *)objectB;@end@interface ObjectB// 这里也一样：需要暴露 ObjectC.h- (instancetype)initWithObjectC:(ObjectC *)objectC;@end@interface ObjectC- (instancetype)init;@end 对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。 12345678910@interface ObjectA- (instancetype)initWithObjectB:(id &lt;ObjectB&gt;)objectB;@end// 这个协议只暴露 ObjectA 需要原始的 ObjectB。// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 @protocol ObjectB- (void)methodNeededByObjectA;@end 十、一次高效的依赖注入10.1 问题场景如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的： 这里依赖路径有两条： ①、主项目依赖第三方 pods。 ②、组件依赖第三方 pods，主项目再依赖组件。 单向的依赖关系决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，组件却没有办法主动和主项目通讯。 可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。 10.2 依赖注入依赖注入有另外一个名字，叫做“控制反转”。 像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。 所以依赖注入有两个比较重要的点： ①、要实现这种反转控制的功能。 ②、要解耦。 不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。 出自这篇文章：理解依赖注入与控制反转 10.3 iOS 依赖注入调查iOS 平台实现依赖注入功能的开源项目有两个大头：objection、typhoon。 详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。 还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。 那有没有其他没那么方案呢？libextobjc libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点： ①、充分使用了 OC 动态语言的特性，不侵入项目 ②、高度自动化 ③、框架十分轻量（只有一个 .h 和 .m 文件） ④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。 10.4 EXTConcreteProtocol 实现原理有两个比较重要的概念需要提前明白才能继续往下讲。 ①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。 ②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。 如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。 10.4.1 EXTConcreteProtocol 的使用比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。 1234567891011121314151617181920@protocol ObjectProtocol&lt;NSObject&gt;+ (void)sayHello;- (int)age;@end@concreteprotocol(ObjectProtocol)+ (void)sayHello&#123; NSLog(@\"Hello\");&#125;- (int)age &#123; return 18;&#125;@end 之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。 123@interface Person : NSObject&lt;ObjectProtocol&gt;@end 我们接下来就可以对 Person 调用注入的方法。 12345678int main(int argc, char * argv[]) &#123; Person * p = [Person new]; NSLog(@\"%@\", [p age]); [p.class sayHello];&#125;18Hello 10.4.2 源码解析先来看一下头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define concreteprotocol(NAME) \\ /* * create a class used to contain all the methods used in this protocol */ \\ // 定义一个容器类 interface NAME ## _ProtocolMethodContainer : NSObject &lt; NAME &gt; &#123;&#125; \\ @end \\ \\ @implementation NAME ## _ProtocolMethodContainer \\ /* * when this class is loaded into the runtime, add the concrete protocol * into the list we have of them */ \\ // load 方法添加混合协议 + (void)load &#123; \\ /* * passes the actual protocol as the first parameter, then this class as * the second */ \\ if (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), self)) \\ fprintf(stderr, \"ERROR: Could not load concrete protocol %s\\n\", metamacro_stringify(NAME)); \\ &#125; \\ \\ /* * using the \"constructor\" function attribute, we can ensure that this * function is executed only AFTER all the Objective-C runtime setup (i.e., * after all +load methods have been executed) */ \\ // 在 load 之后，main 之前执行方法注入 __attribute__((constructor)) \\ static void ext_ ## NAME ## _inject (void) &#123; \\ /* * use this injection point to mark this concrete protocol as ready for * loading */ \\ ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \\ &#125;/*** implementation details follow ***/// load 方法添加混合协议BOOL ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);// load 之后，main 之前执行方法注入void ext_loadConcreteProtocol (Protocol *protocol); 可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。 然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// contains the information needed to reference a full special protocoltypedef struct &#123; // the actual protocol declaration (@protocol block) 用户定义的协议. __unsafe_unretained Protocol *protocol; // the injection block associated with this protocol // // this block is RETAINED and must eventually be released by transferring it // back to ARC // 在 __attribute__((constructor)) 时往指定类里注入方法的 block. void *injectionBlock; // whether this protocol is ready to be injected to its conforming classes // // this does NOT refer to a special protocol having been injected already // 对应的协议是否已经准备好注入. BOOL ready;&#125; EXTSpecialProtocol;BOOL ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123; return ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123; ext_injectConcreteProtocol(protocol, containerClass, destinationClass); &#125;);&#125;BOOL ext_loadSpecialProtocol (Protocol *protocol, void (^injectionBehavior)(Class destinationClass)) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); NSCParameterAssert(injectionBehavior != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return NO; &#125; // if we've hit the hard maximum for number of special protocols, we can't // continue if (specialProtocolCount == SIZE_MAX) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; // if the array has no more space, we will need to allocate additional // entries // specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols. if (specialProtocolCount &gt;= specialProtocolCapacity) &#123; size_t newCapacity; if (specialProtocolCapacity == 0) // if there are no entries, make space for just one newCapacity = 1; else &#123; // otherwise, double the current capacity newCapacity = specialProtocolCapacity &lt;&lt; 1; // if the new capacity is less than the current capacity, that's // unsigned integer overflow if (newCapacity &lt; specialProtocolCapacity) &#123; // set it to the maximum possible instead newCapacity = SIZE_MAX; // if the new capacity is still not greater than the current // (for instance, if it was already SIZE_MAX), we can't continue if (newCapacity &lt;= specialProtocolCapacity) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; &#125; &#125; // we have a new capacity, so resize the list of all special protocols // to add the new entries void * restrict ptr = realloc(specialProtocols, sizeof(*specialProtocols) * newCapacity); if (!ptr) &#123; // the allocation failed, abort pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; specialProtocols = ptr; specialProtocolCapacity = newCapacity; &#125; // at this point, there absolutely must be at least one empty entry in the // array assert(specialProtocolCount &lt; specialProtocolCapacity); // disable warning about \"leaking\" this block, which is released in // ext_injectSpecialProtocols() #ifndef __clang_analyzer__ ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior copy]; // construct a new EXTSpecialProtocol structure and add it to the first // empty space in the array // 将协议保存为一个 EXTSpecialProtocol 结构体。 specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123; .protocol = protocol, .injectionBlock = (__bridge_retained void *)copiedBlock, .ready = NO &#125;; #endif ++specialProtocolCount; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125; // success! return YES;&#125; ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。 ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static void ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class class) &#123; // get the full list of instance methods implemented by the concrete // protocol 获取容器类里所有的实例方法. unsigned imethodCount = 0; Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount); // get the full list of class methods implemented by the concrete // protocol 获取容器类里所有的类方法方法. unsigned cmethodCount = 0; Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount); // get the metaclass of this class (the object on which class // methods are implemented) 拿到要注入方法的类的元类. Class metaclass = object_getClass(class); // inject all instance methods in the concrete protocol 注入实例方法. for (unsigned methodIndex = 0;methodIndex &lt; imethodCount;++methodIndex) &#123; Method method = imethodList[methodIndex]; SEL selector = method_getName(method); // first, check to see if such an instance method already exists // (on this class or on a superclass) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(class, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this instance method to the class in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(class, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // inject all class methods in the concrete protocol 注入类方法. for (unsigned methodIndex = 0;methodIndex &lt; cmethodCount;++methodIndex) &#123; Method method = cmethodList[methodIndex]; SEL selector = method_getName(method); // +initialize is a special case that should never be copied // into a class, as it performs initialization for the concrete // protocol // +initialize 不能被注入. if (selector == @selector(initialize)) &#123; // so just continue looking through the rest of the methods continue; &#125; // first, check to see if a class method already exists (on this // class or on a superclass) // // since 'class' is considered to be an instance of 'metaclass', // this is actually checking for class methods (despite the // function name) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(metaclass, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this class method to the metaclass in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(metaclass, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // free the instance method list 管理内存 free(imethodList); imethodList = NULL; // free the class method list free(cmethodList); cmethodList = NULL; // use [containerClass class] and discard the result to call +initialize // on containerClass if it hasn't been called yet // // this is to allow the concrete protocol to perform custom initialization // 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行. (void)[containerClass class];&#125; 我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142void ext_specialProtocolReadyForInjection (Protocol *protocol) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return; &#125; // loop through all the special protocols in our list, trying to find the // one associated with 'protocol' // 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; if (specialProtocols[i].protocol == protocol) &#123; // found the matching special protocol, check to see if it's // already ready if (!specialProtocols[i].ready) &#123; // if it's not, mark it as being ready now specialProtocols[i].ready = YES; // since this special protocol was in our array, and it was not // loaded, the total number of protocols loaded must be less // than the total count at this point in time assert(specialProtocolsReady &lt; specialProtocolCount); // ... and then increment the total number of special protocols // loaded – if it now matches the total count of special // protocols, begin the injection process if (++specialProtocolsReady == specialProtocolCount) // 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入. ext_injectSpecialProtocols(); &#125; break; &#125; &#125; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125;&#125; 上面都是准备工作，接下来开始进入核心方法进行注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * This function actually performs the hard work of special protocol injection. * It obtains a full list of all classes registered with the Objective-C * runtime, finds those conforming to special protocols, and then runs the * injection blocks as appropriate. */static void ext_injectSpecialProtocols (void) &#123; /* * don't lock specialProtocolsLock in this function, as it is called only * from public functions which already perform the synchronization */ /* * This will sort special protocols in the order they should be loaded. If * a special protocol conforms to another special protocol, the former * will be prioritized above the latter. */ // 对协议进行排序. // 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的 load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现. // 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面. qsort_b(specialProtocols, specialProtocolCount, sizeof(EXTSpecialProtocol), ^(const void *a, const void *b)&#123; // if the pointers are equal, it must be the same protocol if (a == b) return 0; const EXTSpecialProtocol *protoA = a; const EXTSpecialProtocol *protoB = b; // A higher return value here means a higher priority int (^protocolInjectionPriority)(const EXTSpecialProtocol *) = ^(const EXTSpecialProtocol *specialProtocol)&#123; int runningTotal = 0; for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; // the pointer passed into this block is guaranteed to point // into the 'specialProtocols' array, so we can compare the // pointers directly for identity if (specialProtocol == specialProtocols + i) continue; if (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol)) runningTotal++; &#125; return runningTotal; &#125;; /* * This will return: * 0 if the protocols are equal in priority (such that load order does not matter) * &lt; 0 if A is more important than B * &gt; 0 if B is more important than A */ return protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA); &#125;); // 获取项目中所有的类 unsigned classCount = objc_getClassList(NULL, 0); if (!classCount) &#123; fprintf(stderr, \"ERROR: No classes registered with the runtime\\n\"); return; &#125; Class *allClasses = (Class *)malloc(sizeof(Class) * (classCount + 1)); if (!allClasses) &#123; fprintf(stderr, \"ERROR: Could not allocate space for %u classes\\n\", classCount); return; &#125; // use this instead of ext_copyClassList() to avoid sending +initialize to // classes that we don't plan to inject into (this avoids some SenTestingKit // timing issues) classCount = objc_getClassList(allClasses, classCount); /* * set up an autorelease pool in case any Cocoa classes get used during * the injection process or +initialize */ @autoreleasepool &#123; // loop through the special protocols, and apply each one to all the // classes in turn // // ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in // the order in which they appear in specialProtocols. Consider classes // X and Y that implement protocols A and B, respectively. B needs to get // its implementation into Y before A gets into X. // 遍历所有的要注入的协议结构体. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; Protocol *protocol = specialProtocols[i].protocol; // transfer ownership of the injection block to ARC and remove it // from the structure // 使用 __bridge_transfer 把对象的内存管理交给 ARC. ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer id)specialProtocols[i].injectionBlock; specialProtocols[i].injectionBlock = NULL; // loop through all classes 遍历所有的类 for (unsigned classIndex = 0;classIndex &lt; classCount;++classIndex) &#123; Class class = allClasses[classIndex]; // if this class doesn't conform to the protocol, continue to the // next class immediately // 如果这个类遵守了要注入的协议，那么就执行注入 // 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法. if (!class_conformsToProtocol(class, protocol)) continue; injectionBlock(class); &#125; &#125; &#125; // 管理内存. // free the allocated class list free(allClasses); // now that everything's injected, the special protocol list can also be // destroyed free(specialProtocols); specialProtocols = NULL; specialProtocolCount = 0; specialProtocolCapacity = 0; specialProtocolsReady = 0;&#125; 这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 10.4.3 问题在哪？接下来讨论 EXTConcreteProtocol 的缺点。 如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。 这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。 这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。 10.5 解决方案从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。 那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。 但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。 如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。 ①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。 ②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。 ③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。 ④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。 https://github.com/newyjp/BLMethodInjecting 十一、结语依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。 十二、文章依赖注入——让iOS代码更简洁 [iOS]一次高效的依赖注入","tags":[]},{"title":"利用预渲染加速iOS设备的图像显示","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/利用预渲染加速iOS设备的图像显示/","text":"使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。 于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。 接着下面举个例子程序来验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;UIKit/UIKit.h&gt;@interface ImageView : UIView@property (nonatomic, strong) UIImage * image;@end#import \"ImageView.h\"#include &lt;mach/mach_time.h&gt;static const CGRect imageRect = &#123; &#123;0, 0&#125;, &#123;100, 100&#125;&#125;;@implementation ImageView- (void)awakeFromNib&#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; &#125; [superawakeFromNib];&#125; - (void)drawRect:(CGRect)rect&#123; if (CGRectContainsRect(rect, imageRect)) &#123; uint64_t start = getTickCount(); [self.image drawInRect:imageRect]; uint64_t drawTime = getTickCount() - start; NSLog(@\"%llu\", drawTime); // 打印时间间隔 &#125;&#125;// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。uint64_t getTickCount(void)&#123; static mach_timebase_info_data_t sTimebaseInfo; uint64_t machTime = mach_absolute_time(); // Convert to nanoseconds - if this is the first time we've run, get the timebase. if (sTimebaseInfo.denom == 0) &#123; (void)mach_timebase_info(&amp;sTimebaseInfo); &#125; uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom; // 纳秒 return millis;&#125;@end 测试用一张 1838 * 890 的图 2018-07-05 11:05:25.950978+0800 Demo[5831:113872] 31802012 接下来就是见证奇迹的时刻了，把这段代码加入程序： 12345678910111213141516static const CGSize imageSize = &#123;100, 100&#125;;- (void)awakeFromNib &#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; // 由于JPEG图像是不透明的，所以第二个参数就设为YES // 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了 UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0); // 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作 [image drawInRect:imageRect]; self.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); &#125;&#125; 值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。 时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] 127939，缩短了很多。 还能更快吗？让我们来试试 Core Graphics。 先定义一个全局的 CGImageRef 变量： 123456static CGImageRef imageRef;- (void)awakeFromNib&#123; imageRef = self.image.CGImage;&#125; 然后 12345- (void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawImage(context, imageRect, imageRef);&#125; 运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] 27425265，而且图像还上下颠倒了⋯ 这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正： 1234CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, 0, 100);CGContextScaleCTM(context, 1, -1);CGContextDrawImage(context, imageRect, imageRef); 这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] 34242146，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。","tags":[]},{"title":"UITableView优化","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/UITableView优化/","text":"一、Cell 复用在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 解决方案：创建一个静态变量 reuseID，防止重复创建（提高性能），使用系统的缓存池功能。 123456789static NSString * CELL_RUID = @\"CELL\"; // 调用次数太多，static 保证只创建一次 reuseID，提高性能- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 缓存池中取已经创建的 cell UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID forIndexPath:indexPath]; return cell;&#125; 通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。 12- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 复用 Cell 时 不会调用 awakeFromNib。 获取方法的区别 dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示： 1reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard' dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示： 1failed to obtain a cell from its dataSource 判断 nil 后可以自己创建 cell。 123456&#123; MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot;]; if (cell == nil) &#123; cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;]; &#125;&#125; 为什么需要 forIndexPath: 因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。 我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。 注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。 二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的。 好处： ①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（多个 Cell 不是更容易维护？） ②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。 既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。 尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。 三、提前计算并缓存 Cell 的高度3.1 固定高度的 cell1self.tableView.rowHeight = 88; 直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。 3.2 动态高度的 cell实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。 tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。 解决方案：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。 12345678910@interface Model : NSObject@property (nonatomic, assign) CGFloat cellHeight; // Cell 高度/** * @brief 计算高度 */ - (void)calculateCellHeight;@end 在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。 还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。 四、异步绘制（自定义 Cell 绘制）遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。详细整理：UITableView 优化技巧 123456789101112131415161718/** * @brief cell 添加 draw 方法 */- (void)draw&#123; // 异步绘制 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);&#125;/** * @brief 重写 drawRect: 方法 */- (void)drawRect:(CGRect)rect&#123; // 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。&#125; 绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。 五、滑动时，按需加载自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。 123456789101112131415161718192021222324252627282930313233343536- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (needLoadArr.count &gt; 0 &amp;&amp; [needLoadArr indexOfObject:indexPath] == NSNotFound) &#123; [cell clear]; // 清掉内容 &#125; return cell;&#125;// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath * ip = [self.tableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath * cip = [[self.tableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 8; // -8 &lt; 当前位置 - 目标位置 &lt; 8 if (labs(cip.row - ip.row) &gt; skipCount) &#123; // 目标区域的 cell 的 indexPaths NSArray * temp = [self.tableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.tableView.frame.size.width, self.tableView.frame.size.height)]; NSMutableArray * arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y &lt; 0) &#123; NSIndexPath * indexPath = [temp lastObject]; if (indexPath.row + 33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 3 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 2 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。 六、缓存 View当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。 七、尽量显示“大小刚好合适的”图片资源避免大量的图片缩放、颜色渐变等。 八、避免同步的从网络、文件获取数据Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。 九、渲染1、减少 subviews 的个数和层级 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。 2、少用 subviews 的透明图层 渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。 3、背景色不要使用 clearColor 4、避免 CALayer 特效（shadowPath） 给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿： 1234view.layer.shadowColor = color.CGColor;view.layer.shadowOffset = offset;view.layer.shadowOpacity = 1;view.layer.shadowRadius = radius; 5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。 十、总结UITableView 的优化主要从四个方面入手： 1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法； 2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage； 3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。 大概需要关注的： 1、cell 复用 2、cell 高度的计算 3、渲染（混合问题） 4、减少视图的数目（重写 drawRect:） 5、减少多余的绘制操作 6、不要给 cell 动态添加 subView 7、异步化 UI，不要阻塞主线程 8、滑动时按需加载对应的内容 十一、资料图片加载优化官方 Demo：LazyTableImages 文章：提升 UITableView 性能-复杂页面的优化 代码：VVeboTableViewDemo","tags":[]},{"title":"图片设置圆角性能问题","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/图片设置圆角性能问题/","text":"通常设置圆角方式 12imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50; 这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。 注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。 一、设置圆角的方法①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。 ②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化 1234imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50;imageView.layer.shouldRasterize = YES; // 设置光栅化imageView.layer.rasterizationScale = [UIScreen mainScreen].scale; // UIImageView 不加这句会产生一点模糊 设置光栅化可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。 但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 ③、直接覆盖一张中间为圆形透明的图片（推荐使用） 这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。 这种圆片覆盖的方法一般只用在底色为纯色的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色） ④、UIImage drawInRect 绘制圆角 这种方式 GPU 损耗低内存占用大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface CornerImageView ()&#123; NSBlockOperation * _operation; // 任务 NSOperationQueue * _queue; UIImage * _cornerImage; // 圆角化的图片&#125;@end@implementation CornerImageView- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; _queue = [[NSOperationQueue alloc] init]; &#125; return self;&#125;/** * 重写设置方法。如果是 UIButton 可以换成 setImage:forState: */- (void)setImage:(UIImage *)image&#123; [super setImage:nil]; [self roundedImage:image];&#125;- (void)roundedImage:(UIImage *)image&#123; [_queue cancelAllOperations]; [_operation cancel]; _operation = nil; _operation = [NSBlockOperation blockOperationWithBlock:^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, [UIScreen mainScreen].scale); // Add a clip before drawing anything, in the shape of an rounded rect [[UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:self.bounds.size.height / 2] addClip]; [image drawInRect:self.bounds]; _cornerImage = UIGraphicsGetImageFromCurrentImageContext(); // Lets forget about that we were drawing UIGraphicsEndImageContext(); if (!_operation) &#123; return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [super setImage:_cornerImage]; &#125;); &#125;]; [_queue addOperation:_operation];&#125; 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。 问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？ ⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface UIImage (corner)+ (id)createRoundedRectImage:(UIImage *)image;@end@implementation UIImage (corner)static void addRoundedRectToPath(CGContextRef context, CGRect rect, float ovalWidth, float ovalHeight)&#123; float fw, fh; if (ovalWidth == 0 || ovalHeight == 0) &#123; CGContextAddRect(context, rect); return; &#125; CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); CGContextScaleCTM(context, ovalWidth, ovalHeight); fw = CGRectGetWidth(rect) / ovalWidth; fh = CGRectGetHeight(rect) / ovalHeight; // 使的圆角半径为 1 CGContextMoveToPoint(context, fw, fh/2); // Start at lower right corner CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1); // Top right corner CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1); // Top left corner CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1); // Lower left corner CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); // Back to lower right CGContextClosePath(context); CGContextRestoreGState(context);&#125;+ (id)createRoundedRectImage:(UIImage *)image&#123; CGFloat wh = MIN(MAX(image.size.width, image.size.height), 160); CGSize imageSize = CGSizeMake(wh, wh); CGfloat radius = wh / 2; CGContextRef context = CGBitmapContextCreate( NULL, wh, wh, 8, 4 * wh, CGColorSpaceCreateDeviceRGB(), kCGImageAlphaPremultipliedFirst ); // 绘制圆角 CGContextBeginPath(context); addRoundedRectToPath(context, CGRectMake(0, 0, wh, wh), radius, radius); CGContextClosePath(context); CGContextClip(context); CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); CGImageRef imageMasked = CGBitmapContextCreateImage(context); image = [UIImage imageWithCGImage:imageMasked]; CGContextRelease(context); CGImageRelease(imageMasked); return image;&#125; 以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。 123456/** * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 '(x1，y1)' 的直线相切，与 '(x1，y1)' 到 '(x2, y2)' 的直线相切。 */CG_EXTERN void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) CG_AVAILABLE_STARTING(10.0, 2.0); 二、使用 Instruments 的 Core Animation 查看性能 Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 用 Instruments 测试得： ①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。 ②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。 ③、添加圆形透明图片，无任何高亮，说明没离屏渲染。 ④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大） ⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法) 三、问题①、有提到还有一种 mask 方法。 这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考小心别让圆角成了你列表的帧数杀手。 ②、第四种比第一种更卡。 第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。 可以用 Instruments的 GPU Driver 进行测试： Renderer Utilization 如果这个值 &gt; 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization 如果这个值 &gt; 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。 第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。 帧率越接近 60 滑动越顺畅。 发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。 如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。 而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。 所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。 四、参考文章 内存恶鬼drawRect - 谈画图功能的内存优化 github 绘制圆角源码参考 NZCircularImageView、HJCornerRadius","tags":[]},{"title":"0-1 背包","date":"2019-05-23T10:19:03.934Z","path":"2019/05/23/01-背包/","text":"01 背包问题是用来介绍动态规划算法最经典的例子。 一、解释 1①、状态方程 f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] } ( j &gt;= Wi ) f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。 决策：为了背包中物品总价值最大化，第 i 件物品应该放入背包中吗 ？ ②、实例 假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。 只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。 首先要明确这张表是至底向上，从左到右生成的。 用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。 对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。 同理 c2 = 0，b2 = 3，a2 = 6。 对于承重为 8 的背包，a8 = 15 是怎么得出的呢？ 根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。 f[i-1, j] 表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 Pi 指的是 a 物品的价值，即 6。 由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。 ③、代码 物品信息类 12345678910111213141516171819202122232425@interface PackageItem : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger weight;@property (nonatomic, assign) NSInteger value;- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;@end@implementation PackageItem- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value&#123; if (self = [super init]) &#123; self.name = name; self.weight = weight; self.value = value; &#125; return self;&#125;@end 非递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]; for(int i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; &#125; [self packageAlgorithm:bagItems bagSize:10];&#125;/** * @brief 01 背包算法 */- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize&#123; if (bagSize == 0 || bagItems.count == 0) return; NSInteger bagMatrix[bagSize][bagItems.count]; // 是否选中数组 PackageItem * item; NSInteger i = 0; // 背包容量，列数 NSInteger j = 0; // 物品数量，行数 // 初始化数组 for (; i &lt;= bagSize; i++) &#123; for (j = 0; j &lt; bagItems.count; j++) bagMatrix[i][j] = 0; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); for (i = 0; i &lt;= bagSize; i++) &#123; // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取 for (j = bagItems.count - 1; j &gt; -1; j--) &#123; item = bagItems[j]; // 装不下 if (item.weight &gt; i) &#123; // 价值总和为 0 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = 0; &#125; // 价值总和为之前项的和 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = bagMatrix[i][j+1]; &#125; &#125; // 能装下 else &#123; // 是第一个物品，保存起来 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = item.value; &#125; // 非第一个物品，求最大值 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value); &#125; &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; NSInteger curSize = bagSize; // 当前能装的空间 NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]; // 以 a、b、c、d、e 的顺序获取 for (j = 0; j &lt; bagItems.count; j++) &#123; item = bagItems[j]; // 剩下能装的空间为 0 if (curSize == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123; [answer addObject:item.name]; curSize -= item.weight; &#125; &#125; NSLog(@&quot;%@&quot;, answer);&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 9 9 12 12 15 15 15 0 0 3 3 6 6 9 9 9 10 11 0 0 0 0 6 6 6 6 6 10 11 0 0 0 0 6 6 6 6 6 10 10 0 0 0 0 6 6 6 6 6 6 6 2019-01-25 22:12:03.795695+0800 Demo[1750:32295] ( a, b, e) 二、解释 2①、状态方程 max.F(n,C,x). x∈0,1 展开公式： F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn x1∗w1 + x2∗w2 + … + xn∗wn ≤ C xi∈0,1 x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。 我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够自动组合 x 的取值使得 F(n,c,x) 达到最大。 再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。 如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。 B(n, C) = B(n−1, C); 没有多余的空间去放置最后一个物品 B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn }; 如果有多余的空间去放置，则考虑是否要放置 B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。 ②、实例 w = {1, 2} v = {1, 2} C = 2 解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。 拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2 不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。 然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2 ③、递归代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]; for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; // a、b、c、d、e selectedArray[i] = @(0); &#125; NSLog(@&quot;%ld&quot;, (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]); [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123; if (obj.integerValue) &#123; NSLog(@&quot;%@ &quot;, nameArr[idx]); &#125; &#125;];&#125;/** * @brief 01 背包算法。递归方式 */- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize&#123; if (bagItems.count == 0 || bagSize == 0 || bagNo == 0) return 0; PackageItem * item = bagItems[bagNo - 1]; // 装不下 if (bagSize &lt; item.weight) &#123; // 在剩余的物品中查找 return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; &#125; else &#123; NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value; if (more &lt; less) &#123; selectedArray[bagNo - 1] = @(1); // 拿 &#125; else &#123; selectedArray[bagNo - 1] = @(0); // 不拿 &#125; return MAX(more, less); &#125;&#125;2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 152019-01-26 00:11:13.897903+0800 Demo[3618:88346] a2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e 三、DP 优于递归的好处动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。 四、学习文章动态规划之 01 背包问题（最易理解的讲解）一文彻底搞懂01背包算法DP——01背包问题使用迭代和动态规划","tags":[]},{"title":"Category","date":"2019-05-23T10:19:03.931Z","path":"2019/05/23/iOS Category/","text":"分类可以拓展类的属性、方法、协议等信息 一、底层结构在 objc-4 的源码中，搜索 category_t 可以看到: 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。 在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： objc-os.mm _objc_init() map_images() map_images_nolock() objc-runtime-new.mm _read_images() remethodizeClass() attachCategories() attachLists() realloc、memmove、memcpy 最终可以找到这个方法 attachCategories 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); // 判断是否元类 bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /* 方法数组 @[ @[method_t, method_t], @[method_t .....] ] */ method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); /* 属性数组 @[ @[property_t, property_t], @[property_t .....] ] */ property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); /* 协议数组 @[ @[peotocol_t, peotocol_t], @[peotocol_t .....] ] */ protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[I]; // 将所有分类的对象方法，附加到类对象列表中 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 将所有分类的属性，附加到类属性列表中 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 将所有分类的协议，附加到类协议列表中 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。 二、Category和Class Extension 的区别Class Extension: 1234@interface Person ()@property (nonatomic, assign) int sex;- (void)isBig;@end 将属性、方法等封装在 .m 文件里面，类似 private 的应用。 区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。 三、+ Load 和 +initialize 方法的区别Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次） 四、objc_msgSend() 方法实现在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的 12345678910111213141516171819202122232425262728/******************************************************************** * * id objc_msgSend(id self, SEL _cmd, ...); * IMP objc_msgLookup(id self, SEL _cmd, ...); * * objc_msgLookup ABI: * IMP returned in x17 * x16 reserved for our use but not used * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class 但是可以大概猜出它的实现思路: 由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断； 通过 isa 寻找类/元类对象，寻找方法调用； 如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。 五、文章宁夏灼雪__ &amp; iOS底层day4 - 探索Category的实现","tags":[]},{"title":"重构 AppDelegate","date":"2019-05-23T10:19:03.931Z","path":"2019/05/23/重构AppDelegate/","text":"一、Massive AppDelegate AppDelegate 是应用程序的根对象，它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互，通常被认为是每个 iOS 项目的核心。 随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。 在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的简洁和清晰对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。 AppDelegate 常见的业务代码如下： 日志埋点统计数据分析 初始化数据存储系统 配置 UIAppearance 管理 App Badge 数字 管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分 管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换 管理 UserDefaults：设置首先启动标志，保存和加载数据 管理后台任务 管理设备方向 更新位置信息 初始化第三方库（如分享、日志、第三方登陆、支付） 这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。 看看以下可能的解决方案，每个 Recipe（方案）遵循单一职责、易于扩展、易于测试原则。 二、命令模式 Command Design Pattern 命令模式是一种数据驱动的设计模式，属于行为型模式。 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。 可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。 123456789101112131415161718192021/// 命令协议@protocol Command &lt;NSObject&gt;- (void)execute;@end/// 初始化第三方库@interface InitializeThirdPartiesCommand : NSObject &lt;Command&gt;@end/// 初始化主视图@interface InitializeRootViewControllerCommand : NSObject &lt;Command&gt;@property (nonatomic, strong) UIWindow * keyWindow;@end/// 初始化视图全局配置@interface InitializeAppearanceCommand : NSObject &lt;Command&gt;@end/// ... 然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。 1234567891011@implementation StartupCommandsBuilder// 返回数组，元素为遵守 Command 协议的对象- (NSArray&lt;id&lt;Command&gt;&gt; *)build&#123; return @[ [InitializeAppearanceCommand new], [InitializeRootViewControllerCommand new], [InitializeThirdPartiesCommand new] ];&#125;@end 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(id&lt;Command&gt; _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj execute]; &#125;]; return YES;&#125; 如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。 三、组合设计模式 Composite Design Pattern 组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。 这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。 12345678910111213141516171819202122/// 组装类@interface CompositeAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;+ (instancetype)makeDefault;@end@implementation CompositeAppDelegate+ (instancetype)makeDefault&#123; // 这里要实现单例 return [[CompositeAppDelegate alloc] init];&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125;@end 实现执行具体职责的叶子类。 12345678910111213141516171819202122232425262728293031323334/// 叶子类。推送消息处理@interface PushNotificationAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end/// 叶子类。初始化第三方库@interface ThirdPartiesConfiguratorAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end@implementation PushNotificationAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"PushNotificationAppDelegate\"); return YES;&#125;@end@implementation ThirdPartiesConfiguratorAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"ThirdPartiesConfiguratorAppDelegate\"); return YES;&#125;@end 在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125; 它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。 四、中介者模式 Mediator Design Pattern 中介者模式是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。 让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface APPLifeCycleMediator : NSObject+ (instancetype)makeDefaultMediator;@end@implementation APPLifeCycleMediator&#123; @private NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; * _listeners;&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;- (instancetype)initWithListeners:(NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; *)listeners&#123; if (self = [super init]) &#123; _listeners = listeners; // 通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidEnterBackgroud) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidFinishLaunching) name:UIApplicationDidFinishLaunchingNotification object:nil]; &#125; return self;&#125;/// 定义好静态类方法，初始化所有监听者+ (instancetype)makeDefaultMediator&#123; static APPLifeCycleMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]]; &#125;); return mediator;&#125;- (void)onAppWillEnterForeground&#123; [_listeners[1] onAppWillEnterForeground];&#125;- (void)onAppDidEnterBackgroud&#123; [_listeners[0] onAppDidEnterBackgroud];&#125;- (void)onAppDidFinishLaunching&#123;&#125;@end 定义 AppLifecycleListener 协议，以及协议的的实现者。 123456789101112131415161718192021222324252627282930313233343536/// 监听协议@protocol AppLifeCycleListener &lt;NSObject&gt;@optional- (void)onAppWillEnterForeground;- (void)onAppDidEnterBackgroud;- (void)onAppDidFinishLaunching;@end@interface VideoListener : NSObject &lt;AppLifeCycleListener&gt;@end@interface SocketListener : NSObject &lt;AppLifeCycleListener&gt;@end@implementation VideoListener- (void)onAppDidEnterBackgroud&#123; NSLog(@\"停止视频播放\");&#125;@end@implementation SocketListener- (void)onAppWillEnterForeground&#123; NSLog(@\"开启长链接\");&#125;@end 加入到 AppDelegate 中 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [APPLifeCycleMediator makeDefaultMediator]; return YES;&#125; 这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。 五、总结大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。 通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。 这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。 六、学习文章最佳实践：重构AppDelegate Refactoring Massive App Delegate iOSTips OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》 Swift 设计模式：《Design_Patterns_by_Tutorials_v0.9.1》 重构：《重构改善既有代码的设计》","tags":[]}]