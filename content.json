[{"title":"静态、动态 pod","date":"2019-09-03T10:58:18.085Z","path":"2019/09/03/静态、动态 Pod/","text":"一、静态和动态在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。 当在 podfile 中指定 use_frameworks! 时，子模块和第三方类库将被打包成 .framework 动态库，模块之间的代码不能直接引用，需要添加依赖； 反之（默认情况）将打包成 .a 静态库。 动态库和静态库的区别： 资源加载方式 包的大小 编译速度 1.1 资源加载方式 s.dependency ‘xx’ 静态方式中各模块的 podspec 文件不用设置依赖，就可以直接 #import 其他模块的类头文件。 ￼ 而动态方式则会报错。 s.resources 1234s.resources = [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt&#125;&apos;, &apos;Resource/**/*&apos;]``` 图片等资源是都放入 mainbundle，直接用 imageNamed: 访问，不用增加很多获取 bundle 的代码。 s.resource = ‘xx/xxx.bundle’ s.resource_bundles = { ‘xxx’ =&gt; [‘/Classes//*.{xib,storyboard,Bundle,png,gif,jpg,jpeg,txt}’, ‘Resource//*’] } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 这两种写法，资源都在模块自己的 bundle 里面，文件名为 xxx.bundle，工程中需要通过 ``bundleForClass`` 等获取资源路径。 #### 1.2 包的大小&lt;center&gt;![](https://coding-net-production-file-ci.codehub.cn/c3a89a40-cb11-11e9-9abe-7341ed163cae.png?sign=H6IebxDROcDaD0PGAQYPUWb2RophPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNTY3Mzc3Mjg5JnQ9MTU2NzE2MTI4OSZyPTYxNjMxOTMzJmY9L2MzYTg5YTQwLWNiMTEtMTFlOS05YWJlLTczNDFlZDE2M2NhZS5wbmcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==)&lt;/center&gt;在图中，上面的是使用 use\\_frameworks! 的动态包， 下面的是默认（或使用 use\\_modular\\_headers!）的静态包，几次验证，都是&lt;font color=#cc0000&gt;动态的更小&lt;/font&gt;。#### 1.3 编译速度这个未验证。#### 1.4 工程实例在项目开发中的场景是一个第三方类库 bongSDK.framework 引入了 Realm.framework 和 RealmSwift.framework，RealmSwift.framework 是通过 swift 语言写的，它的内部调用 Realm。最初静态方式的 pod 遇到了难以理解的报错，因为知识的欠缺和时间的紧迫，放弃了静态这条路，使用 use\\_frameworks! 动态 pod 的方式。动态方式在 pod install 阶段没有报错，但子模块需要添加依赖，更困难的是图片、xib、storyboard 等资源需要获取到模块的 bundle 才能加载，导致工程大面积的图片加载错误，页面跳转崩溃。因此不得不增加很多获取 bundle 路径的代码，修改的位置几百上千处。```oc+ (NSBundle *)bundleWithClassName:(Class)cls moduleName:(NSString*)module&#123; if (module == nil) &#123; return [NSBundle mainBundle]; &#125; NSBundle * bundle = [NSBundle bundleForClass:cls]; NSURL * bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;]; if (bundleURL == nil) &#123; __block UINavigationController* nav; [[UIApplication sharedApplication].windows enumerateObjectsUsingBlock:^(__kindof UIWindow * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; UIViewController * windowVC = obj.rootViewController; if ([windowVC isKindOfClass:[UINavigationController class]]) &#123; nav = (UINavigationController *)windowVC; *stop = YES; &#125; &#125;]; if (nav != nil) &#123; Class callerCls = [nav.viewControllers.firstObject class]; bundle = [NSBundle bundleForClass:callerCls]; bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;]; &#125; if (bundleURL == nil) &#123; return [NSBundle mainBundle]; &#125; &#125; return [NSBundle bundleWithURL:bundleURL];&#125; 图片加载则更加困难，因为很多图片是在 xib 中写的，通过断点发现，系统并没有调用 imageNamed: 方法，导致使用 runtime 替换方法实现图片位置修改的方式失败，通过查找资料，发现 xib 中的 UIButton、UIImageView 会调用 - initWithCoder: 方法，底层会调用 UINibDecoder 类的 decodeObjectForKey。 runtime 替换 decodeObjectForKey 方法后，打印输出发现，UIButton、UIImageView 控件加载的图片名称在 UIResourceName 字段。由此就有了如下的处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118+ (void)load&#123; _imageViewImageArray = [NSMutableArray arrayWithCapacity:2]; propKey = [CYKJXUtil stringByReversed:@&quot;emaNecruoseRIU&quot;]; btnKey = [CYKJXUtil stringByReversed:@&quot;tnetnoClufetatSnottuBIU&quot;]; // hook UINibDecoder - decodeObjectForKey: NSString* clsName = [NSString stringWithFormat:@&quot;redoce%@biNIU&quot;, @&quot;D&quot;]; clsName = [CYKJXUtil stringByReversed:clsName]; [HookTool exchangeInstanceMethod:NSClassFromString(clsName) originalSEL:@selector(decodeObjectForKey:) swizzledSEL:@selector(swizzle_decodeObjectForKey:)]; // hook UIImageView - initWithCoder: [HookTool exchangeInstanceMethod:UIImageView.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_imageView_initWithCoder:)]; // hook UIButton - initWithCoder: [HookTool exchangeInstanceMethod:UIButton.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_button_initWithCoder:)];&#125;- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); // 保存图片名称 if ([key isEqualToString:propKey]) &#123; [_imageViewImageArray addObject:value]; &#125; // 保存 button 状态数据 if ([key isEqualToString:btnKey]) &#123; if ([value isKindOfClass:[NSDictionary class]]) &#123; _buttonImageDictionary = value; &#125; &#125; return value;&#125;#pragma mark - UIImageView- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; // 设置 image if (_imageViewImageArray.count &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:_imageViewImageArray[0]]; if (normalImage) &#123; instance.image = normalImage; &#125; &#125; // 设置 highlightedImage if (_imageViewImageArray.count &gt; 1) &#123; UIImage * highlightedImage = [HookTool imageAfterSearch:_imageViewImageArray[1]]; if (highlightedImage) &#123; instance.highlightedImage = highlightedImage; &#125; &#125; return instance;&#125;#pragma mark - UIButton- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; _buttonImageDictionary = nil; UIButton * instance = (UIButton *)[self swizzle_button_initWithCoder:aDecoder]; @autoreleasepool &#123; [_buttonImageDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; if (_imageViewImageArray.count == 0) &#123; *stop = YES; &#125; else &#123; switch ([key integerValue]) &#123; case ButtonImageOrder_Normal: [HookTool setImageForButton:instance object:obj state:UIControlStateNormal]; break; case ButtonImageOrder_Highlighted: [HookTool setImageForButton:instance object:obj state:UIControlStateHighlighted]; break; case ButtonImageOrder_Selected: [HookTool setImageForButton:instance object:obj state:UIControlStateSelected]; break; case ButtonImageOrder_Disabled: [HookTool setImageForButton:instance object:obj state:UIControlStateDisabled]; break; &#125; &#125; &#125;]; &#125; return instance;&#125; 更详细的代码：ImageTool 如上可见，这种动态方式对于编码并不友好，资源必须要特定的 bundle，一旦资源路径出错，轻则图片未加载，重则程序崩溃。 所以需要研究下如果使用静态方式 pod 子模块代码。 操作步骤： 修改各个子模块的 podspec 文件，删除依赖，修改资源的路径 12345678# s.resource_bundles = &#123; &apos;xx&apos; =&gt; [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt,js&#125;&apos;, &apos;Resource/**/*&apos;] &#125; s.resources = [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt,js&#125;&apos;, &apos;Resource/**/*&apos;]# s.dependency &apos;Realm&apos;, &apos;3.11.2&apos;# s.dependency &apos;RealmSwift&apos;, &apos;3.11.2&apos; ## 依赖私有库# s.dependency &apos;xxx&apos; 删除 use_frameworks! 1#use_frameworks! 重新执行 pod install，等 Pod installation complete! 之后，运行工程。报错，一个一个的解决。 #import \\&lt;AlipaySDK/AlipaySDK.h> 修改为 #import “AlipaySDK.h” dyld: Library not loaded: @rpath/Realm.framework/Realm 现在不用 pod 导入 realm，而是将 realm.framework 拖入 basicModule 工程。这里找了官方最新的 realm.framework，它分为静态版和动态版，添加到工程的 Embedded Binaries，编译时报错 Unknown type name namespace。 不管通过修改 .h 为 .hpp，还是修改 build settings -&gt; Compile Sources As -&gt; Objectoive-C++ 都没有效果，无计可施之时想到了，可以将 use_frameworks! 时 cocoapods 生成 的 Realm.framework 拷贝一份，拖入工程死马等活马医。 编译运行，这个问题解决了~ dyld: Library not loaded: @rpath/libswiftCore.dylib Referenced from: /Users/…/CYKJMain.app/Frameworks/RealmSwift.framework/RealmSwift Reason: image not found 在主工程中创建 xx.swift，并自动创建桥接文件。 Check dependenciesArgument list too long: recursive header expansion failed Search Paths -&gt; Header Search Paths，去掉 $(PODS_ROOT)/**，去掉不必要的 recursive search。原因是：参数列表太长，在递归展开的时候失败，当工程根目录的层级比较深时，Pods里面的层级也比较多时，导致路径太长，超出范围。 duplicate symbol xx in 工程中出现重复的类或者 storyboard 文件等，删除或修改名称即可。 二、文章关于Argument list too long的问题","tags":[]},{"title":"NSPredicate","date":"2019-08-31T05:34:34.645Z","path":"2019/08/31/iOS/iOS原理/NSPredicate/","text":"官方的解释: The NSPredicate class is used to define logical conditions used to constrain a search either for a fetch or for in-memory filtering. NSPredicate 类是用来定义逻辑条件，用来有约束的获取内存中的对象或过滤搜索。 简而言之：只选取符合条件的对象。 一、基本语法使用谓词（NSPredicate）都需要为谓词定义谓词表达式，而这个表达式必须是一个返回 BOOL 的值。 谓词表达式由表达式、运算符和值构成。 1.1 比较运算符 =、==：判断两个表达式是否相等，在谓词中 = 和 == 是相同的意思，而没有赋值的概念。 123456789101112NSString * string = @&quot;1234&quot;;NSPredicate * predicate = [NSPredicate predicateWithFormat:@&quot;SELF = &apos;1234&apos;&quot;];// 验证对象是否符合条件。底层调用了 [xx compare:] 方法if ([predicate evaluateWithObject:string]) &#123; NSLog(@&quot;Evaluate Success!\\n&quot;);&#125;else &#123; NSLog(@&quot;Evaluate Fail!\\n&quot;);&#125;2019-08-31 11:53:35.305452+0800 Predicate[7069:1165684] Evaluate Success! 当传入数组对象时，报错：*** Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSArrayI compare:]: unrecognized selector sent to instance 0x600000234c00’。可以发现底层调用了 compare: 方法。 >=、=>：判断左边表达式的值是否大于或等于右边表达式的值 \\&lt;=、=\\&lt;：判断左边表达式的值是否小于或等于右边表达式的值 >：判断左边表达式的值是否大于右边表达式的值 \\&lt;：判断左边表达式的值是否小于右边表达式的值 !=、\\&lt;>：判断两个表达式是否不相等 1.2 逻辑运算符 AND、&amp;&amp;：逻辑与。两个表达式的值都为 YES 时，结果才为 YES。 OR、||：逻辑或。要求其中一个表达式为 YES 时，结果就是 YES。 NOT、!：逻辑非。对原有的表达式取反 1.3 关系运算符 ANY、SOME：集合中任意一个元素满足条件，就返回 YES。 123456789101112131415@interface Person : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age;@end&#123; NSArray * arr = @[ person1, person2, ... ]; predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;]; NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);&#125;2019-08-31 13:33:03.764130+0800 Predicate[8478:1206451] *** Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;The left hand side for an ALL or ANY operator must be either an NSArray or an NSSet.&apos; 根据报错信息得知，谓词表达式中 ANY 的操作的主体需要是 NSArray 或者 NSSet。上面 filteredArrayUsingPredicate: 方法传入的是 Person 对象，所以报错，因此 ANY 操作的数据结构要是 @[ @[] ] 双层数组。 123456&#123; NSArray * arr = @[ @[ person1, person2, ... ] ]; predicate = [NSPredicate predicateWithFormat:@&quot;ANY name LIKE &apos;Tom*2&apos;&quot;]; NSLog(@&quot;%@&quot;, [arr filteredArrayUsingPredicate:predicate]);&#125; ALL：集合中所有元素都满足条件，才返回 YES。 NONE：集合中没有任何元素满足条件就返回 YES，等同于 not any。如: NONE person.age &lt; 18，表示 person 集合中所有元素的 age &gt;= 18 时，才返回 YES。 IN：等价于 SQL 语句中的 IN 运算符，只有当左边表达式或值出现在右边的集合中才会返回 YES 1234predicateString = @&quot;self.name IN &#123;&apos;Tom&apos;,&apos;Jay&apos;&#125; || self.age IN&#123;25,30&#125;&quot;;predicate = [NSPredicate predicateWithFormat:predicateString]; NSLog(@&quot;%@ = %@&quot;, predicateString, [self.persons filteredArrayUsingPredicate:predicate]); 1.4 范围运算符 BETWEEN：BETWEEN 表达式必须满足表达式 BETWEEN {下限，上限} 的格式，要求该表达式必须大于或等于下限，并小于或等于上限 1234567891011NSNumber * number = @(1234); predicate = [NSPredicate predicateWithFormat:@&quot;SELF BETWEEN &#123;1000, 2000&#125;&quot;]; if ([predicate evaluateWithObject:number]) &#123; NSLog(@&quot;Success!&quot;); &#125; else &#123; NSLog(@&quot;Fail!&quot;); &#125; 2019-08-31 13:06:59.443083+0800 Predicate[8050:1192540] Success! IN 1.5 字符串比较运算符 BEGINSWITH：检查某个字符串是否以指定的字符串开头 ENDSWITH：检查某个字符串是否以指定的字符串结尾 CONTAINS：检查某个字符串是否包含指定的字符串 LIKE：检查某个字符串是否匹配指定的字符串模板。其之后可以跟 ? 代表一个字符和 * 代表任意多个字符。比如 “name LIKE ‘*ac*‘“，这表示 name 的值中包含 ac 则返回 YES；”name LIKE ‘?ac*’”，表示 name 的第 2、3 个字符为 ac 时返回 YES。 MATCHES：检查某个字符串是否匹配指定的正则表达式。虽然正则表达式的执行效率是最低的，但其功能是最强大的，也是我们最常用的。 注意：字符串比较都是区分大小写和重音符号的。如：café 和 cafe 是不一样的，Cafe 和 cafe 也是不一样的。如果希望字符串比较运算不区分大小写和重音符号，请在这些运算符后使用 [c]、[d] 选项。其中 [c] 是不区分大小写，[d] 是不区分重音符号，其写在字符串比较运算符之后，比如：name LIKE[cd] ‘cafe’，那么不论 name 是cafe、Cafe 还是 café 上面的表达式都会返回 YES。 1.6 直接量在谓词表达式中可以使用如下直接量 FALSE、NO：代表逻辑假 TRUE、YES：代表逻辑真 NULL、NIL：代表空值 SELF：代表正在被判断的对象自身，不区分大小写，self 也可以。 “string” 或 ‘string’：代表字符串 数组：和 c 中的写法相同，如：{‘one’, ‘two’, ‘three’}。 数值：包括整数、小数和科学计数法表示的形式 十六进制数：0x开头的数字 八进制：0o开头的数字 二进制：0b开头的数字 1.7 数组操作 array[index]：指定数组中特定索引处的元素。 array[first]：指定第一个元素 array[last]：指定最后一个元素 array[size]：指定数组大小 1.8 保留字下列单词都是保留字（不区分大小写） AND、OR、IN、NOT、ALL、ANY、SOME、NONE、LIKE、CASEINSENSITIVE、CI、MATCHES、CONTAINS、BEGINSWITH、ENDSWITH、BETWEEN、NULL、NIL、SELF、TRUE、YES、FALSE、NO、FIRST、LAST、SIZE、ANYKEY、SUBQUERY、CAST、TRUEPREDICATE、FALSEPREDICATE 虽然大小写都可以，但是更推荐使用大写来表示这些保留字 二、谓词的用法2.1 数据校验1234567891011// MATCHES（正则表达式）NSString * phoneRegex = @&quot;^((13[0-9])|(15[^4,\\\\D])|(18[0,0-9]))\\\\d&#123;8&#125;$&quot;;NSString * phoneNumber = @&quot;15180168516&quot;;predicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, phoneRegex]; if ([predicate evaluateWithObject:phoneNumber]) &#123; NSLog(@&quot;%@ 是电话号码!&quot;, phoneNumber);&#125;else &#123; NSLog(@&quot;%@ 不是电话号码!&quot;, phoneNumber);&#125; evaluateWithObject: 方法返回的是一个 BOOL 值，如果符合条件就返回 YES，不符合就返回 NO。常见的有判断手机号码、邮编等等。 1234567// 检测字符串中是否有特殊字符- (BOOL)checkSpecialCharacter:(NSString *)string&#123; NSString *regex = @&quot;[`~!@#$^&amp;*()=|&#123;&#125;&apos;:;&apos;,\\\\[\\\\].&lt;&gt;/?~！@#￥……&amp;*（）——|&#123;&#125;【】‘；：”“&apos;。，、？]+&quot;; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex]; return [pred evaluateWithObject:string];&#125; 2.2 过滤集合谓词本身就代表了一个逻辑条件，计算谓词之后返回的结果永远为 BOOL 类型的值。而谓词最常用的功能就是对集合进行过滤。当程序使用谓词对集合元素进行过滤时，程序会自动遍历其元素，并根据集合元素来计算谓词的值，当这个集合中的元素计算谓词并返回 YES 时，这个元素才会被保留下来。请注意程序会自动遍历其元素，它会将自动遍历过之后返回为YES的值重新组合成一个集合返回。 1234567891011121314151617181920/** * @brief NSArray * @return 使用指定的谓词过滤 NSArray 集合，返回符合条件的元素组成的新集合 */- (NSArray&lt;ObjectType&gt; *)filteredArrayUsingPredicate:(NSPredicate *)predicate;/** * @brief 使用指定的谓词过滤 NSMutableArray，剔除集合中不符合条件的元素 */- (void)filterUsingPredicate:(NSPredicate *)predicate;/** * @brief NSSet */- (NSSet&lt;ObjectType&gt; *)filteredSetUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0);/** * @brief NSMutableSet */- (void)filterUsingPredicate:(NSPredicate *)predicate NS_AVAILABLE(10_5, 3_0); 使用谓词过滤不可变集合和可变集合的区别是：过滤不可变集合时，会返回符合条件的集合元素组成的新集合；过滤可变集合时，没有返回值，会直接剔除不符合条件的集合元素。 2.3 在谓词中使用占位符参数上面所有的例子中谓词总是固定的，然而我们在现实中处理变量时决定了谓词应该是可变的。 首先如果我们想在谓词表达式中使用变量，那么我们需要了解下列两种占位符： %K：用于动态传入属性名%@：用于动态设置属性值 相当于变量名与变量值。 除此之外，还可以在谓词表达式中使用动态改变的属性值，就像环境变量一样。 12345678NSPredicate * predicate1 = [NSPredicate predicateWithFormat:@&quot;%K CONTAINS %@&quot;, key, value];NSArray * filterArray = [array filteredArrayUsingPredicate:predicate];// 包含 $VALUE 字符串NSPredicate * predicateTemp = [NSPredicate predicateWithFormat:@&quot;%K &gt; $VALUE&quot;, @&quot;age&quot;];// 指定 $VALUE 的值为 25NSPredicate * predicate2 = [predicateTemp predicateWithSubstitutionVariables:@&#123; @&quot;VALUE&quot; : @25&#125; ];filterArray = [array filteredArrayUsingPredicate:predicate2]; 三、文章sunny_zl &amp; iOS中的谓词（NSPredicate）使用","tags":[]},{"title":"静态、动态 pod","date":"2019-08-30T07:20:43.836Z","path":"2019/08/30/iOS/iOS原理/静态、动态 Pod/","text":"一、静态和动态在项目中使用 pod 实现模块化，对于子模块和第三类库的导入方式存在两种：静态库、动态库。 当在 podfile 中指定 use_frameworks! 时，子模块和第三方类库将被打包成 .framework 动态库，模块之间的代码不能直接引用，需要添加依赖； 反之（默认情况）将打包成 .a 静态库。 动态库和静态库的区别： 资源加载方式 包的大小 编译速度 1.1 资源加载方式 s.dependency ‘xx’ 静态方式中各模块的 podspec 文件不用设置依赖，就可以直接 #import 其他模块的类头文件。 ￼ 而动态方式则会报错。 s.resources 1234s.resources = [&apos;Classes/**/*.&#123;xib,storyboard,Bundle,png,gif,jpg,jpeg,txt&#125;&apos;, &apos;Resource/**/*&apos;]``` 图片等资源是都放入 mainbundle，直接用 imageNamed: 访问，不用增加很多获取 bundle 的代码。 s.resource = ‘xx/xxx.bundle’ s.resource_bundles = { ‘xxx’ =&gt; [‘/Classes//*.{xib,storyboard,Bundle,png,gif,jpg,jpeg,txt}’, ‘Resource//*’] } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 这两种写法，资源都在模块自己的 bundle 里面，文件名为 xxx.bundle，工程中需要通过 ``bundleForClass`` 等获取资源路径。 #### 1.2 包的大小&lt;center&gt;![](http://dzliving.com/StaticModule2.png)&lt;/center&gt;在图中，上面的是使用 use\\_frameworks! 的动态包， 下面的是默认（或使用 use\\_modular\\_headers!）的静态包，几次验证，都是&lt;font color=#cc0000&gt;动态的更小&lt;/font&gt;。#### 1.3 编译速度这个未验证。#### 1.4 工程实例在项目开发中的场景是一个第三方类库 bongSDK.framework 引入了 Realm.framework 和 RealmSwift.framework，RealmSwift.framework 是通过 swift 语言写的，它的内部调用 Realm。最初静态方式的 pod 遇到了难以理解的报错，因为知识的欠缺和时间的紧迫，放弃了静态这条路，使用 use\\_frameworks! 动态 pod 的方式。动态方式在 pod install 阶段没有报错，但子模块需要添加依赖，更困难的是图片、xib、storyboard 等资源需要获取到模块的 bundle 才能加载，导致工程大面积的图片加载错误，页面跳转崩溃。因此不得不增加很多获取 bundle 路径的代码，修改的位置几百上千处。```oc+ (NSBundle *)bundleWithClassName:(Class)cls moduleName:(NSString*)module&#123; if (module == nil) &#123; return [NSBundle mainBundle]; &#125; NSBundle * bundle = [NSBundle bundleForClass:cls]; NSURL * bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;]; if (bundleURL == nil) &#123; __block UINavigationController* nav; [[UIApplication sharedApplication].windows enumerateObjectsUsingBlock:^(__kindof UIWindow * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; UIViewController * windowVC = obj.rootViewController; if ([windowVC isKindOfClass:[UINavigationController class]]) &#123; nav = (UINavigationController *)windowVC; *stop = YES; &#125; &#125;]; if (nav != nil) &#123; Class callerCls = [nav.viewControllers.firstObject class]; bundle = [NSBundle bundleForClass:callerCls]; bundleURL = [bundle URLForResource:module withExtension:@&quot;bundle&quot;]; &#125; if (bundleURL == nil) &#123; return [NSBundle mainBundle]; &#125; &#125; return [NSBundle bundleWithURL:bundleURL];&#125; 图片加载则更加困难，因为很多图片是在 xib 中写的，通过断点发现，系统并没有调用 imageNamed: 方法，导致使用 runtime 替换方法实现图片位置修改的方式失败，通过查找资料，发现 xib 中的 UIButton、UIImageView 会调用 - initWithCoder: 方法，底层会调用 UINibDecoder 类的 decodeObjectForKey。 runtime 替换 decodeObjectForKey 方法后，打印输出发现，UIButton、UIImageView 控件加载的图片名称在 UIResourceName 字段。由此就有了如下的处理方式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118+ (void)load&#123; _imageViewImageArray = [NSMutableArray arrayWithCapacity:2]; propKey = [CYKJXUtil stringByReversed:@&quot;emaNecruoseRIU&quot;]; btnKey = [CYKJXUtil stringByReversed:@&quot;tnetnoClufetatSnottuBIU&quot;]; // hook UINibDecoder - decodeObjectForKey: NSString* clsName = [NSString stringWithFormat:@&quot;redoce%@biNIU&quot;, @&quot;D&quot;]; clsName = [CYKJXUtil stringByReversed:clsName]; [HookTool exchangeInstanceMethod:NSClassFromString(clsName) originalSEL:@selector(decodeObjectForKey:) swizzledSEL:@selector(swizzle_decodeObjectForKey:)]; // hook UIImageView - initWithCoder: [HookTool exchangeInstanceMethod:UIImageView.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_imageView_initWithCoder:)]; // hook UIButton - initWithCoder: [HookTool exchangeInstanceMethod:UIButton.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle_button_initWithCoder:)];&#125;- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); // 保存图片名称 if ([key isEqualToString:propKey]) &#123; [_imageViewImageArray addObject:value]; &#125; // 保存 button 状态数据 if ([key isEqualToString:btnKey]) &#123; if ([value isKindOfClass:[NSDictionary class]]) &#123; _buttonImageDictionary = value; &#125; &#125; return value;&#125;#pragma mark - UIImageView- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; // 设置 image if (_imageViewImageArray.count &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:_imageViewImageArray[0]]; if (normalImage) &#123; instance.image = normalImage; &#125; &#125; // 设置 highlightedImage if (_imageViewImageArray.count &gt; 1) &#123; UIImage * highlightedImage = [HookTool imageAfterSearch:_imageViewImageArray[1]]; if (highlightedImage) &#123; instance.highlightedImage = highlightedImage; &#125; &#125; return instance;&#125;#pragma mark - UIButton- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。 [_imageViewImageArray removeAllObjects]; _buttonImageDictionary = nil; UIButton * instance = (UIButton *)[self swizzle_button_initWithCoder:aDecoder]; @autoreleasepool &#123; [_buttonImageDictionary enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; if (_imageViewImageArray.count == 0) &#123; *stop = YES; &#125; else &#123; switch ([key integerValue]) &#123; case ButtonImageOrder_Normal: [HookTool setImageForButton:instance object:obj state:UIControlStateNormal]; break; case ButtonImageOrder_Highlighted: [HookTool setImageForButton:instance object:obj state:UIControlStateHighlighted]; break; case ButtonImageOrder_Selected: [HookTool setImageForButton:instance object:obj state:UIControlStateSelected]; break; case ButtonImageOrder_Disabled: [HookTool setImageForButton:instance object:obj state:UIControlStateDisabled]; break; &#125; &#125; &#125;]; &#125; return instance;&#125; 更详细的代码：ImageTool 如上可见，这种动态方式对于编码并不友好，资源必须要特定的 bundle，一旦资源路径出错，轻则图片未加载，重则程序崩溃。 所以需要研究下如果使用静态方式 pod 子模块代码。 首先将 use_frameworks! 删除，重新执行 pod install，等 Pod installation complete! 之后，运行工程，报错，一个一个的解决。 dyld: Library not loaded: @rpath/Realm.framework/Realm 现在不用 pod 导入 realm，而是将 realm.framework 拖入 basicModule 工程。这里找了官方最新的 realm.framework，它分为静态版和动态版，添加到工程的 Embedded Binaries，编译时报错 Unknown type name namespace。 不管通过修改 .h 为 .hpp，还是修改 build settings -&gt; Compile Sources As -&gt; Objectoive-C++ 都没有效果，无计可施之时想到了，可以将 use_frameworks! 时 cocoapods 生成 的 Realm.framework 拷贝一份，拖入工程死马等活马医。 编译运行，这个问题解决了~ Argument list too long: recursive header expansion failed Search Paths -&gt; Header Search Paths，去掉 $(PODS_ROOT)/**，去掉不必要的 recursive search。 其余的就是解决一些资源加载问题，资源重名问题，动态库的引用问题 #import “” 改为 #import &lt;&gt;。 二、文章关于Argument list too long的问题","tags":[]},{"title":"编程思想","date":"2019-08-17T15:41:19.406Z","path":"2019/08/17/iOS/iOS原理/编程思想/","text":"一、链式编程 链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。 123456789101112- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void)two&#123; NSLog(@&quot;2&quot;);&#125;[[self one] two]; 在 Objective-C 中，没有传递参数的方法可以写成点语法的方式。 1self.one.two; 上面的写法会产生警告：Property access result unused - getters should not be used for side effects。这是因为 two 方法被当成 getter 方法，getter 方法会有返回值，self.one.two 没有使用该返回值。 Objective-C : 点语法 + 事务 12345678910111213141516171819202122232425262728293031323334@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.one.two(@&quot;3&quot;);&#125;- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void(^)(NSString *))two&#123; NSLog(@&quot;2&quot;); return ^ (NSString * s) &#123; NSLog(@&quot;%@&quot;, s); &#125;;&#125;2019-08-17 19:45:34.079059+0800 Demo[858:23949] 12019-08-17 19:45:34.079188+0800 Demo[858:23949] 22019-08-17 19:45:34.079271+0800 Demo[858:23949] 3@end 经典使用链式编程思想的开源代码：Masonry 二、函数式编程在数学中 y = f(x), y = f(f(x)) 都是函数，x 既可以是一个简单的参数，也可以是一个表达式。 在 OC 中，将 block 作为参数传递可实现灵活的函数封装。 12345678910111213141516- (ViewController *)one&#123; NSLog(@&quot;1&quot;); return self;&#125;- (void)two:(void (^)(NSString *))block&#123; NSLog(@&quot;2&quot;); block(@&quot;3&quot;);&#125;[self.one two:^(NSString * s) &#123; NSLog(@&quot;%@&quot;, s);&#125;]; 函数式编程（Functional Programming）相对于要理解「函数」，我们更需要理解的其实是「状态」。 2.1 状态说到状态，很容易会联想到变量、局部变量、全局变量、property、model，这些都可以成为状态，但变量和状态又不是一回事，要真正理解状态，得先理解下面一行代码： 1int i = 0 简单的一行代码，分析起来却有不少门道。 「i」就是变量，一个变量可以看做是一个实体，真实存在于内存空间的实体。 int 是它的类型信息，是对于它的一种约束。 0 是它被赋予的一个值。 变量是我们要分析的目标。它的类型信息、值信息虽然会约束变量的行为，但不是我们关注的重点，真正让变量变得危险的是中间的等号，= 是个赋值操作，意味着改变 i 的值，原本处于静态的 i，由于一个 = 发生了变化，它的值可以变为 1，或者 10000，或者其他任何值，我们可以说这个变量有了状态。 状态也是个相对的概念，变量都有其生命周期，一旦变量被回收，其所包含的状态也随之消失，所以状态所带来的影响是受限于变量的生命周期的。 12345- (int)do&#123; int i = 0; return i;&#125; i 是函数 do 方法内部的临时变量，分配在内存的栈上。在 do 函数内部这个空间范畴来说，i 是有状态的，i 被赋予了值 0。一旦 return，i 的生命周期也随之结束，其所对应的状态也消失了。所以一旦出了do，i 又变得没有状态了。代码虽然执行了 return i，但返回的其实是 i 所代表的值，i 将自己的值交出来之后，就完成了自己的使命。 所以 do 函数的使用者是感受不到 i 的存在的，do 的调用方可以认为 do 是无状态（stateless）的，无状态意味着静止，静止的事物都是安全的，飞驰而过的火车和静止的石块，当然是后者感觉更安全。 我们编写代码的时候会经常谈论状态，函数的状态、类的状态、App 的状态，归根结底，我们所讨论的是：在某个空间范畴内会发生变化的变量。 函数式编程当中的函数 f(x) 强调无状态，其实是强调将状态锁定在函数的内部。一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，前面说过变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量。下面两个函数，一个入参是传值，一个入参是传变量： 123456789- (void)do:(int)value // 传值&#123; &#125; - (void)do:(NSMutableArray *)arr // 传变量&#123;&#125; 第一个没状态，对调用方来说是安全的，对整个app来说也是安全的，既避免了依赖外部的状态，也不会修改外部的状态，即：不会产生 side effect，没有副作用。 第二个 do 函数，不但是传入了变量，还是可以变化的变量，是真正意义上的外部状态。很有可能在你遍历这个 arr 的时候，外部某个同时执行的线程正在尝试改变这个 arr 里的元素。 所以让我来总结函数式编程当中的函数，可以一句话归结为：隔绝一切外部状态，传入值，输出值。 再看看函数式编程当中的纯函数（Pure Function）的定义: In computer programming, a function) may be considered a pure function if both of the following statements about the function hold: The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or bet`ween different executions of the program, nor can it depend on any external input from I/O devices (usually—see below). Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below). 纯函数即为函数式编程所强调的函数，上述两点可翻译为： ①、不依赖外部状态②、不改变外部状态 所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解：时间和空间。 2.2 时间变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。 时间的武器是赋值，赋予变量新的值，在不可预知的未来埋下隐患。 123456- (void)setUserName:(NSString *)name&#123; //before assignment _userName = name; //after assignment&#125; 一旦有了赋值操作，时间就找到了空隙，可以对代码的执行产生影响。或许是现在，或许是明天，或许是在 appDidFinishLaunch，或许是在 didReceiveMemoryWarning。 变量会随着时间变化。有状态的函数也会随着时间的流动产生不同的输出，Pure Function 却是对时间免疫的，纯函数没有状态，无论怎样去执行一个纯函数，它所输出的结果永远不会变。 2.3 空间如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。(线程安全问题) Pure Function 同样是对空间免疫的。 多线程的 bug 调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。 2.4 离不开的状态函数式编程通过 Pure Function，使得我们的代码经得起时间和空间的考验。 我们可以把一个 App 的代码按照函数式编程的方式，拆分成一个个合格的 pure function，再通过某种方式串联起来，要方便的串联函数，需要能像使用变量一样方便的使用函数。 一个 Pure Function 可以是 stateless 的，但 App 可以变成 stateless 吗？显然不能。 离开了变量和状态，我们很难完整的描述业务。用户购物车里的商品总是会发生变化，今天或明天，我们总是需要在一个地方接收这种变化，保存这种变化，继而反应这种变化。所以，大多数时候，我们离不开状态，但我们能做的是，将一定会变化的状态，锁定在尽可能小的时间和空间跨度之内，通过改变代码的组织方式或架构，将必须改变的难以管教的状态，囚禁在特定的模块代码之中，让不可控变得尽量可控。 其实，即使不严格遵从函数式编程，我们同样可以写出带有 Functional Programming 精髓的代码，一切的一切，都是对于状态（state）的理解。 NSMutableArray 的 copy 也是颇具函数式编程精髓的。 2.5 一等公民当我们把函数改造成 pure function 之后，会产生一些奇妙的化学连锁反应，这些反应甚至会改变我们的编程习惯。 一旦我们有了绝对安全的纯函数，我们当然希望能尽最大可能的去发挥它的价值，增加它出现和被使用的场景。为了加大纯函数的使用率，我们需要在语言层面做一些改造或者增强，以提高纯函数传递性。怎么增强呢？答案是将函数变为一等公民。 何谓公民？有身份证才叫公民，有身份证还能自由迁徙的就叫一等公民。 当我们的变量可以指向函数时，这个变量就有了函数的身份。当我们把这个变量当做函数的参数传入，或者函数的返回值传出的时候，这个变量就有了自由迁徙的能力。 一个函数 A，可以接收另一个函数 B 作为参数，然后再返回第三个函数 C 作为返回值。类似下面的一段swift代码： 12345func funcA(funcB: @escaping (Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; return &#123; input in return funcB(input) &#125; //funcC&#125; 在 funcA 的定义里，funcB 是作为参数传入，funcC（匿名的）是作为返回值返回。funcB 和 funcC 在这个语境里就称之为 first class function。而 funcA 作为 funcB 和 funcC 的管理者，有个更高端的称谓：high order function。 有了 first class function 和 high order function，我们还会收获另一个成果：语言的表达力更灵活，更简洁，更强大了。举个例子，我们写一段代码来实现一个功能：参加 party 前选一件衣服。用传统的方式来写： 123456789101112func chooseColor(gender: Int) -&gt; Int &#123; return 0&#125;func dressup(dressColor: Int) -&gt; Int &#123; return 1&#125; //imperativelet dressColor = chooseColor(gender: 1)let dress = dressup(dressColor: dressColor)user.dress = dress 先定义函数，再分三步依次调用 chooseColor, dressup，然后赋值。 如果用 first class function 和 high order function 的方式来写就是： 1234567891011121314func gotoParty(dressup: @escaping (Int) -&gt; Int, chooseColor: @escaping (Int) -&gt; Int) -&gt; (Int) -&gt; Int &#123; return &#123; gender in let dressColor = chooseColor(gender) return dressup(dressColor) &#125;&#125; // declarativelet prepare = gotoParty(dressup: &#123; color in return 1&#125;, chooseColor: &#123; gender in return 0&#125;)user.dress = prepare(1) gotoParty 函数糅合了 dressup 和 chooseColor，gotoParty 成了一个 high order function，当我们读 gotoParty 的代码的时候，这单一一个函数就将我们的目的和结果都表明了。 这就是 high order function 的神奇之处，原先啰啰嗦嗦的几句话变成一句话就说清楚了，它更接近我们自然语言的表达方式，比如 gotoParty 可以这样阅读：我要挑选一件颜色适合的衣服去参加 party，这样的代码是不是语意更简洁更美呢？ 注意，functional programming 并不会减少我们的代码量，它改变的只是我们书写代码的方式。 这种更为强大的表达力我们也有个行话来称呼它：declarative programming。而我们传统的代码表达方式（OOP当中所使用的方式）则叫做：imperative programming。 imperative programming 更强调实现的步骤，而 declarative programming 则重在表达我们想要的结果。这句话理解起来可能有些抽象，实在理解不了也没啥关系，只要记住declarative programming 能更简洁精炼的表达我们想要的结果即可。 以上都是我们将function变为一等公民所产生的结果，这一改变还有更多的妙用，比如lazy evaluation。 上述代码中的dressup和chooseColor虽然都是function，但是他们在传入gotoParty的时候并不会立马执行（evaluation），而是等gotoParty被执行的时候再一起执行。这也很大程度上增强了我们的表达能力，dressup和chooseColor都具备了lazy evaluation的属性，可以被拼装，被delay，最后在某一时刻才被执行。 所以，functional programming改变了我们使用函数的方式，之前使用 OOP，我们对于怎么处理变量（定义变量，修改值，传递值，等）轻车熟路，到了函数式编程的世界，我们要学会如何同函数打交道了，要能像使用变量一样灵活自如的使用函数，这在刚开始的时候确实需要一段适应期。 三、响应式编程在网上流传一个非常经典的解释｀响应式编程的概念｀ 在程序开发中： a ＝ b ＋ c赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化。响应式编程的目标就是：如果 b 或者 c 的数值发生变化，a 的数值会同时发生变化。 什么是响应式编程？ 响应式编程是一种编程范例，它处理异步数据流和特定的变更传播，按照特定顺序对执行环境（上下文）进行修改。 使用响应式编程有哪些好处？ 提高系统性能：使用响应式编程能提高处理大量数据的反应速度。提升用户体验：使用响应式编程能提升系统的响应能力。简化修改和维护：代码更容易理解。 所有都应该是响应式的么？ 响应式编程可以作为应用的一部分集成到应用中，没必要将已经证明有效的编程模式全部推倒。如果只是简单的网站，肯定没有必要应用响应式编程；如果需要引入推荐系统，引入响应式编程处理来大数据、高负载就是个好办法。 什么时候使用响应式编程？ 响应式编程是高负载、多用户应用的优雅的解决方案，像社交应用、游戏、音视频应用；此外，应用有以下模块也适合应用：需要大量交互的服务端代码、代理服务器/负载均衡器、人工智能/机器学习、实时数据流处理。 四、文章suiling &amp; 简单点，理解iOS与函数式编程阳仔dynamics &amp; ReactiveCocoa学习笔记（三）：响应式和函数响应式编程Why Reactive(Cocoa)?吴启辉 &amp; 关于响应式编程的十个问题","tags":[]},{"title":"dyld","date":"2019-08-07T08:13:26.814Z","path":"2019/08/07/iOS/iOS原理/dyld/","text":"一、介绍在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。 dyld 全称 the dynamic link editor，即动态链接器，其本质是 Mach-O 文件，是专门用来加载动态库的库。 源码下载地址：https://opensource.apple.com/tarballs/dyld/ dyld 会将 App 依赖的动态库和 App 文件加载到内存以后执行，动态库不是可执行文件，无法独自执行。当点击 App 的时候，系统在内核态完成一些必要配置，从 App 的 MachO 文件解析出 dyld 的地址，这里会记录在 MachO 的 LC_LOAD_DYLINKER 命令中，内容参考如下： 123456789 cmd LC_LOAD_DYLINKER cmdsize 28 name /usr/lib/dyld (offset 12)Load command 8 cmd LC_UUID cmdsize 24 uuid DF0F9B2D-A4D7-37D0-BC6B-DB0297766CE8Load command 9 cmd LC_VERSION_MIN_IPHONEOS dyld 位于 /usr/lib/dyld，可以从越狱机或者 mac 电脑中找到。以 mac 为例，终端执行命令： 12$ cd /usr/lib$ file dyld dyld 是 Mach-O 类型的通用二进制文件，支持 x86_64 和 i386 两种架构。iPhone 真机对应的 dyld 支持的为 arm 系列架构。 二、otool otool 是专门用来查看 Mach-O 类型文件的工具 Mac OS X 下二进制可执行文件的动态链接库是 dylib 文件。 dylib 也就是 bsd 风格的动态库。基本可以认为等价于 windows 的 dll 和 linux 的so。mac 基于 bsd，所以也使用的是 dylib。 Linux 下用 ldd 查看，苹果系统用 otool。 2.1 查看 otool 地址电脑已安装 Xcode。终端输入： 12345678910111213141516171819202122232425262728293031323334$ otoolUsage: /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ... -f print the fat headers -a print the archive header -h print the mach header -l print the load commands -L print shared libraries used -D print shared library id name -t print the text section (disassemble with -v) -p &lt;routine name&gt; start dissassemble from routine name -s &lt;segname&gt; &lt;sectname&gt; print contents of section -d print the data section -o print the Objective-C segment -r print the relocation entries -S print the table of contents of a library (obsolete) -T print the table of contents of a dynamic shared library (obsolete) -M print the module table of a dynamic shared library (obsolete) -R print the reference table of a dynamic shared library (obsolete) -I print the indirect symbol table -H print the two-level hints table (obsolete) -G print the data in code table -v print verbosely (symbolically) when possible -V print disassembled operands symbolically -c print argument strings of a core file -X print no leading addresses or headers -m don&apos;t use archive(member) syntax -B force Thumb disassembly (ARM objects only) -q use llvm&apos;s disassembler (the default) -Q use otool(1)&apos;s disassembler -mcpu=arg use `arg&apos; as the cpu for disassembly -j print opcode bytes -P print the info plist section as strings -C print linker optimization hints --version print the version of /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 由上可知 otool 的地址：/Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 进入地址发现 otool 文件是一个替身（软连接）。 查看 otool 指向的软连接地址： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283$ cd /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/$$ ls -ltotal 223352-r-xr-xr-x 1 cykj staff 33920 10 20 2018 ar-r-xr-xr-x 1 cykj staff 28000 10 20 2018 as-rwxr-xr-x 1 cykj staff 18176 10 20 2018 asa-rwxr-xr-x 1 cykj staff 212208 10 20 2018 bison-r-xr-xr-x 1 cykj staff 150048 10 20 2018 bitcode_striplrwxr-xr-x 1 cykj staff 5 11 22 2018 c++ -&gt; clang-rwxr-xr-x 1 cykj staff 23152 10 20 2018 c89-rwxr-xr-x 1 cykj staff 23248 10 20 2018 c99lrwxr-xr-x 1 cykj staff 5 11 22 2018 cc -&gt; clang-rwxr-xr-x 1 cykj staff 78705232 10 20 2018 clanglrwxr-xr-x 1 cykj staff 5 11 22 2018 clang++ -&gt; clang-r-xr-xr-x 1 cykj staff 120064 10 20 2018 cmpdylib-r-xr-xr-x 1 cykj staff 145872 10 20 2018 codesign_allocatelrwxr-xr-x 1 cykj staff 17 11 22 2018 codesign_allocate-p -&gt; codesign_allocate-rwxr-xr-x 1 cykj staff 4937600 10 20 2018 coremlcompiler-rwxr-xr-x 1 cykj staff 3344 9 26 2018 cpp-rwxr-xr-x 1 cykj staff 27712 10 20 2018 ctags-r-xr-xr-x 1 cykj staff 145824 10 20 2018 ctf_insertlrwxr-xr-x 1 cykj staff 13 11 22 2018 dsymutil -&gt; llvm-dsymutil-rwxr-xr-x 1 cykj staff 1006032 10 20 2018 dwarfdump-rwxr-xr-x 1 cykj staff 219088 10 20 2018 dyldinfo-rwxr-xr-x 2 cykj staff 569056 10 20 2018 flex-rwxr-xr-x 2 cykj staff 569056 10 20 2018 flex++lrwxr-xr-x 1 cykj staff 8 11 22 2018 gcov -&gt; llvm-cov-rwxr-xr-x 2 cykj staff 142336 10 20 2018 gm4-rwxr-xr-x 1 cykj staff 90960 10 20 2018 gperf-rwxr-xr-x 1 cykj staff 65520 10 20 2018 indent-r-xr-xr-x 1 cykj staff 136784 10 20 2018 install_name_tool-rwxr-xr-x 1 cykj staff 2480704 10 20 2018 ld-rwxr-xr-x 1 cykj staff 230 9 26 2018 lex-r-xr-xr-x 1 cykj staff 154592 10 20 2018 libtool-r-xr-xr-x 1 cykj staff 66000 10 20 2018 lipo-rwxr-xr-x 1 cykj staff 3320816 10 20 2018 llvm-cov-rwxr-xr-x 1 cykj staff 29723968 10 20 2018 llvm-dsymutil-rwxr-xr-x 1 cykj staff 10591472 10 20 2018 llvm-nm-rwxr-xr-x 1 cykj staff 11899296 10 20 2018 llvm-objdump-r-xr-xr-x 1 cykj staff 32672 10 20 2018 llvm-otool-rwxr-xr-x 1 cykj staff 1272096 10 20 2018 llvm-profdata-rwxr-xr-x 1 cykj staff 2873440 10 20 2018 llvm-size-rwxr-xr-x 1 cykj staff 3567 9 26 2018 lorder-rwxr-xr-x 2 cykj staff 142336 10 20 2018 m4-rwxr-xr-x 1 cykj staff 24800 10 20 2018 metal-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-ar-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-as-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-link-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metal-opt-rwxr-xr-x 1 cykj staff 24768 10 20 2018 metallib-rwxr-xr-x 1 cykj staff 7604 9 26 2018 miglrwxr-xr-x 1 cykj staff 7 11 22 2018 nm -&gt; llvm-nm-r-xr-xr-x 1 cykj staff 132896 10 20 2018 nm-classic-r-xr-xr-x 1 cykj staff 162720 10 20 2018 nmeditlrwxr-xr-x 1 cykj staff 12 11 22 2018 objdump -&gt; llvm-objdumplrwxr-xr-x 1 cykj staff 10 11 22 2018 otool -&gt; llvm-otool-r-xr-xr-x 1 cykj staff 648720 10 20 2018 otool-classic-r-xr-xr-x 1 cykj staff 132784 10 20 2018 pagestufflrwxr-xr-x 1 cykj staff 7 11 22 2018 ranlib -&gt; libtool-rwxr-xr-x 1 cykj staff 59344 10 20 2018 rebase-r-xr-xr-x 1 cykj staff 204960 10 20 2018 redo_prebinding-rwxr-xr-x 1 cykj staff 73664 10 20 2018 rpcgen-r-xr-xr-x 1 cykj staff 48864 10 20 2018 segeditlrwxr-xr-x 1 cykj staff 9 11 22 2018 size -&gt; llvm-size-r-xr-xr-x 1 cykj staff 120080 10 20 2018 size-classic-r-xr-xr-x 1 cykj staff 120400 10 20 2018 strings-r-xr-xr-x 1 cykj staff 189568 10 20 2018 strip-rwxr-xr-x 1 cykj staff 87671328 10 20 2018 swiftlrwxr-xr-x 1 cykj staff 5 11 22 2018 swift-autolink-extract -&gt; swift-rwxr-xr-x 1 cykj staff 5031520 10 20 2018 swift-build-rwxr-xr-x 1 cykj staff 384480 10 20 2018 swift-build-tool-rwxr-xr-x 1 cykj staff 461136 10 20 2018 swift-demangle-rwxr-xr-x 1 cykj staff 5031552 10 20 2018 swift-package-rwxr-xr-x 1 cykj staff 5031472 10 20 2018 swift-run-rwxr-xr-x 1 cykj staff 53024 10 20 2018 swift-stdlib-tool-rwxr-xr-x 1 cykj staff 5031504 10 20 2018 swift-testlrwxr-xr-x 1 cykj staff 5 11 22 2018 swiftc -&gt; swift-rwxr-xr-x 1 cykj staff 12042320 10 20 2018 tapi-rwxr-xr-x 1 cykj staff 32592 10 20 2018 unifdef-rwxr-xr-x 1 cykj staff 2946 9 26 2018 unifdefall-rwxr-xr-x 1 cykj staff 59776 10 20 2018 unwinddump-rwxr-xr-x 1 cykj staff 135 9 26 2018 yacc 可以看到 otool 指向 llvm-otool，而 llvm-otool 和 otool 在同一个目录中。 另外，还可以发现，这个文件夹下面还有很多有用的文件，如 lipo。 2.2 otool -L 查看动态链接库 终端执行命令： 123456789$ cd /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-fpfdxjbemnwnqcfjimbqpbzpnpem/Build/Products/Debug-iphonesimulator/Demo.app/$$ otool -L DemoDemo: /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5) /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0) /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0) 查看动态库的依赖库： 12345678910111213$ otool -L /usr/lib/system/libdispatch.dylib/usr/lib/system/libdispatch.dylib: /usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 913.60.3) /usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 551.4.0) /usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 62.0.0) /usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 4570.71.8) /usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 161.50.1) /usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 301.50.1) /usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 140.50.6) /usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1244.50.9) /usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 67.0.0) /usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 35.3.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0) 2.3 otool -ov 显示 Objective-C 类结构及其定义的方法。 终端执行命令： 123456789101112131415161718192021222324252627282930$ otool -ov DemoDemo:Contents of (__DATA,__objc_classlist) section00000001000041f0 0x100005080 _OBJC_CLASS_$_HookTool isa 0x1000050a8 _OBJC_METACLASS_$_HookTool superclass 0x0 _OBJC_CLASS_$_NSObject cache 0x0 __objc_empty_cache vtable 0x0 data 0x100004328 (struct class_ro_t *) flags 0x80 instanceStart 8 instanceSize 8 reserved 0x0 ivarLayout 0x0 name 0x100003555 HookTool baseMethods 0x1000042f0 (struct method_list_t *) entsize 24 count 2 name 0x1000028b3 swizzle_decodeObjectForKey: types 0x1000035c4 @24@0:8@16 imp 0x1000015f0 -[HookTool swizzle_decodeObjectForKey:] name 0x100002914 swizzle_button_initWithCoder: types 0x1000035c4 @24@0:8@16 imp 0x1000017c0 -[HookTool swizzle_button_initWithCoder:] baseProtocols 0x0 ivars 0x0 weakIvarLayout 0x0 baseProperties 0x0Meta Class ... 2.4 otool -tV [Mach-O] 查看 ARM 汇编码 1234567891011121314151617181920212223242526272829$ otool -tV DemoDemo:(__TEXT,__text) section+[HookTool load]:0000000100001400 pushq %rbp0000000100001401 movq %rsp, %rbp0000000100001404 subq $0x40, %rsp0000000100001408 movl $0x2, %eax000000010000140d movl %eax, %edx000000010000140f movq %rdi, -0x8(%rbp)0000000100001413 movq %rsi, -0x10(%rbp)0000000100001417 movq 0x3c1a(%rip), %rsi ## Objc class ref: _OBJC_CLASS_$_NSMutableArray000000010000141e movq 0x3b33(%rip), %rdi ## Objc selector ref: arrayWithCapacity:0000000100001425 movq %rdi, -0x20(%rbp)0000000100001429 movq %rsi, %rdi000000010000142c movq -0x20(%rbp), %rsi0000000100001430 callq *0x2bf2(%rip) ## Objc message: +[NSMutableArray arrayWithCapacity:]0000000100001436 movq %rax, %rdi0000000100001439 callq 0x10000265a ## symbol stub for: _objc_retainAutoreleasedReturnValue000000010000143e movq __imageViewImageArray(%rip), %rdx0000000100001445 movq %rax, __imageViewImageArray(%rip)000000010000144c movq %rdx, %rdi000000010000144f callq *0x2bdb(%rip) ## literal pool symbol address: _objc_release0000000100001455 leaq 0x2cb4(%rip), %rax ## Objc cfstring ref: @&quot;emaNecruoseRIU&quot;000000010000145c movq 0x3bdd(%rip), %rdx ## Objc class ref: HookTool0000000100001463 movq 0x3af6(%rip), %rsi ## Objc selector ref: stringByReversed:000000010000146a movq %rdx, %rdi ... 2.5 otool -h [Mach-O] 查看 Mach-O 头结构等 1234$ otool -h DemoMach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 2 21 3272 0x00200085 一个 Mach-O 的文件头结构为： 各字段的含义，可参看 /usr/include/mach-o/loader.h。 2.6 otool -l [Mach-O] | grep crypt1 查看 ipa 包是否加壳 12$ otool -l Demo | grep crypt1$ 没有进行过加壳处理。 123456 cryptoff 16384cryptsize 6651904 cryptid 0 cryptoff 16384cryptsize 6553600 cryptid 0123456 cryptid 代表是否加壳，1 - 加壳，0 - 已脱壳。 上面打印了两遍，其实代表着该可执行文件支持两种架构 armv7 和 arm64。 Mach-O 文件可以用 GUI 图形软件 MachOView 更加直观的查看相关信息。 三、dyld加载 动态库链接、load 方法执行都是在 main 函数执行之前的。 如图所示进行操作： 由上可知，load 的加载是从 __dyld_start 这个函数开始的。 3.1 __dyld_start系统内核在加载动态库前，会加载 dyld，然后调用去执行 __dyld_start（汇编语言实现）。该函数会执行 dyldbootstrap::start()，后者会执行 _main()函数，dyld 的加载动态库的代码就是从_main()开始执行的。这里可以查看 dyldStartup.s的部分内容（以x86_x64架构做参考)，其中标出了 _dyld_start() 与 dyldbootstrap 的 start 方法。 12345678910111213141516171819202122232425262728293031323334353637383940#if __x86_64__#if !TARGET_IPHONE_SIMULATOR .data .align 3__dyld_start_static: .quad __dyld_start#endif#if !TARGET_IPHONE_SIMULATOR .text .align 2,0x90 .globl __dyld_start__dyld_start: popq %rdi # param1 = mh of app pushq $0 # push a zero for debugger end of frames marker movq %rsp,%rbp # pointer to base of kernel frame andq $-16,%rsp # force SSE alignment subq $16,%rsp # room for local variables # call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue) movl 8(%rbp),%esi # param2 = argc into %esi leaq 16(%rbp),%rdx # param3 = &amp;argv[0] into %rdx movq __dyld_start_static(%rip), %r8 leaq __dyld_start(%rip), %rcx subq %r8, %rcx # param4 = slide into %rcx leaq ___dso_handle(%rip),%r8 # param5 = dyldsMachHeader leaq -8(%rbp),%r9 call __ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm movq -8(%rbp),%rdi cmpq $0,%rdi jne Lnew # clean up stack and jump to \"start\" in main executable movq %rbp,%rsp # restore the unaligned stack pointer addq $8,%rsp # remove the mh argument, and debugger end frame marker movq $0,%rbp # restore ebp back to zero jmp *%rax # jump to the entry point # LC_MAIN case, set up stack for call to main() 3.2 dyldInitialization.cpp__dyld_start 内部调用 dyldbootstrap::start，位于 dyldInitialization.cpp。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// This is code to bootstrap dyld. This work in normally done for a program by dyld and crt.// In dyld we have to do this manually.//uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue)&#123; // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables // ①、获取 dyld 对应的 slide slide = slideOfMainExecutable(dyldsMachHeader); bool shouldRebase = slide != 0;#if __has_feature(ptrauth_calls) shouldRebase = true;#endif if ( shouldRebase ) &#123; // ②、通过 slide 对 dyld 进行 rebase rebaseDyld(dyldsMachHeader, slide); &#125; // allow dyld to use mach messaging // ③、mach 初始化 mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; // ④、栈溢出保护 while(*apple != NULL) &#123; ++apple; &#125; ++apple; // set up random value for stack canary __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);#endif // now that we are done bootstrapping dyld, call dyld's main // ⑤、获取应用的 slide（appsSlide） uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); // ⑥、调用 dyld 的 main 函数 return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);&#125; 3.3 slide、rebase由于 apple 采用了 ASLR（Address space layout randomization）技术，所以 Mach-O 每次加载到内存中的首地址是变化的，此时想找到代码在内存中对应的地址需要重定位 rebase。rebase 要用到 slide 值： 1234567891011121314151617181920212223242526272829//// The kernel may have slid a Position Independent Executable//static uintptr_t slideOfMainExecutable(const struct macho_header* mh)&#123; // Mach-O 文件中 load commands 数量 const uint32_t cmd_count = mh-&gt;ncmds; // 偏移地址到 load commands 的首地址 const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header)); const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; // 选中 cmd = LC_SEGMENT_COMMAND if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123; const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd; // 实际对应 LC_SEGMENT_COMMAND(_TEXT) if ( (segCmd-&gt;fileoff == 0) &amp;&amp; (segCmd-&gt;filesize != 0)) &#123; // Mach-O 文件首地址 - LC_SEGMENT_COMMAND(_TEXT).vmaddr return (uintptr_t)mh - segCmd-&gt;vmaddr; &#125; &#125; // 偏移 command 指针 cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; return 0;&#125; 应用本身的 Mach-O 及 dyld 采用的是 slideOfMainExecutable 的方式获取 slide。从上代码得知：side = Mach-O header 首地址 - Load Commands 中 __TEXT 段的 VM Address 的值。 1234567891011121314151617181920212223242526intptr_t _dyld_get_image_slide(const mach_header* mh)&#123; log_apis(\"_dyld_get_image_slide(%p)\\n\", mh); // 获取 Mach-O 文件加载对象 const MachOLoaded* mf = (MachOLoaded*)mh; // 如果 mach 文件头没有 magic 值 if ( !mf-&gt;hasMachOMagic() ) return 0; // 调用 MachOLoaded::getSlide() 方法 return mf-&gt;getSlide();&#125;intptr_t _dyld_get_image_vmaddr_slide(uint32_t imageIndex)&#123; log_apis(\"_dyld_get_image_vmaddr_slide(%d)\\n\", imageIndex); // 获取到 Mach-O 文件 const mach_header* mh = gAllImages.imageLoadAddressByIndex(imageIndex); if ( mh != nullptr ) // 调用上面的方法 return dyld3::_dyld_get_image_slide(mh); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435intptr_t MachOLoaded::getSlide() const&#123; // 诊断对象。 Diagnostics diag; __block intptr_t slide = 0; // 循环 load command forEachLoadCommand(diag, ^(const load_command* cmd, bool&amp; stop) &#123; // 64 位 if ( cmd-&gt;cmd == LC_SEGMENT_64 ) &#123; const segment_command_64* seg = (segment_command_64*)cmd; // LC_SEGMENT_64(__TEXT) if ( strcmp(seg-&gt;segname, \"__TEXT\") == 0 ) &#123; // mach-O 首地址 - LC_SEGMENT_64(__TEXT).vmaddr slide = (uintptr_t)(((uint64_t)this) - seg-&gt;vmaddr); stop = true; &#125; &#125; // 32 位 else if ( cmd-&gt;cmd == LC_SEGMENT ) &#123; const segment_command* seg = (segment_command*)cmd; // LC_SEGMENT(__TEXT) if ( strcmp(seg-&gt;segname, \"__TEXT\") == 0 ) &#123; // mach-O 首地址 - LC_SEGMENT(__TEXT).vmaddr slide = (uintptr_t)(((uint64_t)this) - seg-&gt;vmaddr); stop = true; &#125; &#125; &#125;); diag.assertNoError(); // any malformations in the file should have been caught by earlier validate() call return slide;&#125; 动态库加载采用的是 \\_dyld\\_get\\_image\\_vmaddr\\_slide 的方式获取 slide。 简单验证一下，以应用 Mach-O 为例： Load Commands __TEXT 段 VM Address 值。 VM Address 的地址为 4294967296（10进制）。 在 Demo 项目中 ViewController.m viewDidLoad 方法设置断点，触发后，在 lldb 执行 image list 应用 Mach-O 的地址为 0x00000001004f8000（16进制）。 计算 viewDidLoad 在应用 Mach-O 文件中的地址，symbol address = stack address - slide。 ①、用 Mach-O 的 VM Address 减去对应虚拟地址，得到的 5210112（10进制）为 slide 值； ②、获取 viewDidLoad 函数在当前内存中的地址； ③、用 viewDidLoad 内存地址减去 slide 得到它在 Mach-O 中对应的虚拟地址； ④、将 10 进制转化为 16 进制。 计算得到地址：0x00000001000022c0 在 Mach-O 文件中查看。 可以看到，通过计算得出的值 0x100001750 与 Mach-O 中看到的值一致。 当然，也可以通过命令行直接获取 slide 的值。 3.4 dyld::_main对 ASLR 有了基本认知后，接着看看位于 dyld.cpp 中的 _main 干了什么。 3.4.1 设置运行环境123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//// Entry point for dyld. The kernel loads dyld and jumps to __dyld_start which// sets up some registers and call this function.//// Returns address of main() in target program which __dyld_start jumps to//uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123; launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (uint64_t)mainExecutableMH, 0, 0); &#125; // Grab the cdHash of the main executable from the environment uint8_t mainExecutableCDHashBuffer[20]; const uint8_t* mainExecutableCDHash = nullptr; if ( hexToBytes(_simple_getenv(apple, \"executable_cdhash\"), 40, mainExecutableCDHashBuffer) ) // 获取主程序 hash mainExecutableCDHash = mainExecutableCDHashBuffer; // Trace dyld's load // 告知 kernel，dyld 已加载 notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, \"dyld_file\"));#if !TARGET_IPHONE_SIMULATOR // Trace the main executable's load // 告知 kernel，主程序 Mach-O 已加载 notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, \"executable_file\"));#endif uintptr_t result = 0; // 赋值参数。 // mach_header 类型结构体，表示当前 App 的 Mach-O头部信息。有了头部信息，加载器就可以从头开始，遍历整个 Mach-O 文件的信息。 sMainExecutableMachHeader = mainExecutableMH; // long 类型数据，表示 ASLR 位移长度 sMainExecutableSlide = mainExecutableSlide;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if this is host dyld, check to see if iOS simulator is being run // 获取 dyld 路径 const char* rootPath = _simple_getenv(envp, \"DYLD_ROOT_PATH\"); if ( (rootPath != NULL) ) &#123; // look to see if simulator has its own dyld char simDyldPath[PATH_MAX]; strlcpy(simDyldPath, rootPath, PATH_MAX); strlcat(simDyldPath, \"/usr/lib/dyld_sim\", PATH_MAX); // 打开 dyld_sim 路径 int fd = my_open(simDyldPath, O_RDONLY, 0); // 成功 if ( fd != -1 ) &#123; // 如果是模拟器，并且正确加载`dyld_sim`，则直接返回主程序地址 const char* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result); if ( errMessage != NULL ) halt(errMessage); return result; &#125; &#125;#endif CRSetCrashLogMessage(\"dyld: launch started\"); // 设置一个全局链接上下文，包括一些回调函数、参数与标志设置信息，其中的 context 结构体实例、回调函数都是 dyld 自己的实现 setContext(mainExecutableMH, argc, argv, envp, apple); // Pickup the pointer to the exec path. // 获取主程序路径 sExecPath = _simple_getenv(apple, \"executable_path\"); // &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld if (!sExecPath) sExecPath = apple[0]; // 获取应用 Mach-O 文件的绝对路径 if ( sExecPath[0] != '/' ) &#123; // have relative path, use cwd to make absolute char cwdbuff[MAXPATHLEN]; if ( getcwd(cwdbuff, MAXPATHLEN) != NULL ) &#123; // maybe use static buffer to avoid calling malloc so early... char* s = new char[strlen(cwdbuff) + strlen(sExecPath) + 2]; strcpy(s, cwdbuff); strcat(s, \"/\"); strcat(s, sExecPath); sExecPath = s; &#125; &#125; // Remember short name of process for later logging // 设置进程名称 sExecShortName = ::strrchr(sExecPath, '/'); if ( sExecShortName != NULL ) ++sExecShortName; else sExecShortName = sExecPath; // 配置进程受限模式。根据当前进程是否受限，再次配置链接上下文以及其他环境参数 configureProcessRestrictions(mainExecutableMH); // 再次检测/设置上下文环境#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123; pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); &#125; else#endif &#123; checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); &#125;#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac) &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) &#123; gLinkContext.rootPaths = parseColonList(\"/System/iOSSupport\", NULL); gLinkContext.marzipan = true; if ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths ) sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths; if ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths ) sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths; &#125;#endif // 如果设置了DYLD_PRINT_OPTS，则打印参数 if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv); // 如果设置了DYLD_PRINT_ENV，则打印环境变量 if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); // 获取主程序架构信息 getHostInfo(mainExecutableMH, mainExecutableSlide); ... 从源码可以看到，在模拟器运行程序时，通过 dyld_sim 来进行后续加载工作的，与正常真机加载流程略有不同。 模拟器： 真机： 具体实现在 useSimulatorDyld 这个函数中，本文不做进一步解析。 这里还有一个知识点，环境变量 DYLD_PRINT_OPTS 与 DYLD_PRINT_ENV。在 processDyldEnvironmentVariable 方法中： 123456789 else if ( strcmp(key, \"DYLD_IMAGE_SUFFIX\") == 0 ) &#123; gLinkContext.imageSuffix = parseColonList(value, NULL); &#125; else if ( strcmp(key, \"DYLD_INSERT_LIBRARIES\") == 0 ) &#123; sEnv.DYLD_INSERT_LIBRARIES = parseColonList(value, NULL);#if SUPPORT_ACCELERATE_TABLES sDisableAcceleratorTables = true;#endif &#125; 在 secheme 添加这两个环境变量，对应的字段会被设置为 true，并不需要设置 value。 但是并非每个环境变量都不需要配置 value，如： 12345678910111213141516void processDyldEnvironmentVariable(const char* key, const char* value, const char* mainExecutableDir)&#123; if ( strcmp(key, \"DYLD_FRAMEWORK_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FRAMEWORK_PATH); &#125; else if ( strcmp(key, \"DYLD_FALLBACK_FRAMEWORK_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_FRAMEWORK_PATH); &#125; else if ( strcmp(key, \"DYLD_LIBRARY_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_LIBRARY_PATH); &#125; else if ( strcmp(key, \"DYLD_FALLBACK_LIBRARY_PATH\") == 0 ) &#123; appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_LIBRARY_PATH); &#125; ... 3.4.2 加载共享缓存dyld3 与 dyld 不同点在 _main 方法中可以看出。在 dyld 的 _main 方法中，完成第一步以后会初始化主 App，然后加载共享缓存。到了 dyld3，调整了顺序：加载缓存的步骤可以划分为 mapSharedCache 和 checkVersionedPaths，先执行 mapSharedCache，然后加载主 App，最后checkVersionedPaths。（苹果在 2017 年发布的 dyld3，视频链接） 对于共享缓存的理解：dyld 加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被 dyld 映射到内存中，之后，当任何 Mach-O 映像加载时，dyld 首先会检查该 Mach-O 映像及所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // load shared cache // 检查共享缓存是否可用 checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);#if TARGET_IPHONE_SIMULATOR // &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; // &lt;/HACK&gt;#endif // 非 Dont Use if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123; // 映射共享缓存到共享区 mapSharedCache(); &#125; // 缓存是否兼容（DyldSharedCache * loadAddress 为空 || 版本相同 -》YES） bool cacheCompatible = (sSharedCacheLoadInfo.loadAddress == nullptr) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion); // 设置了 DYLD_USE_CLOSURES || 在白名单 if ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) &#123; &#125; else &#123; if ( gLinkContext.verboseWarnings ) // 不使用closure，因为共享缓存格式版本与 dyld 不匹配 dyld::log(\"dyld: not using closure because shared cache format version does not match dyld's\\n\"); &#125; // could not use closure info, launch old way // install gdb notifier stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB); stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages); // make initial allocations large enough that it is unlikely to need to be re-alloced sImageRoots.reserve(16); sAddImageCallbacks.reserve(4); sRemoveImageCallbacks.reserve(4); sAddLoadImageCallbacks.reserve(4); sImageFilesNeedingTermination.reserve(16); sImageFilesNeedingDOFUnregistration.reserve(8); #if !TARGET_IPHONE_SIMULATOR#ifdef WAIT_FOR_SYSTEM_ORDER_HANDSHAKE // &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);#endif#endif try &#123; // add dyld itself to UUID list // 添加 dyld 的 UUID 到共享缓存 UUID 列表中 addDyldImageToUUIDList(); ...&#125; 检测共享缓存是否可用； 如果可用，映射共享缓存到共享区； 添加 dyld 的 UUID 到缓存列表。 其中，检测共享缓存是否可用的函数 checkSharedRegionDisable 中有两句注释： 123456789101112131415161718192021static void checkSharedRegionDisable(const dyld3::MachOLoaded* mainExecutableMH, uintptr_t mainExecutableSlide)&#123;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if main executable has segments that overlap the shared region, then disable using the shared region // 如果主程序 Mach-O 有 segments 与共享区重叠，那么共享区不可用。并且，iOS 不开启共享区无法运行。 // 检测两者是否重叠 if ( mainExecutableMH-&gt;intersectsRange(SHARED_REGION_BASE, SHARED_REGION_SIZE) ) &#123; gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion; if ( gLinkContext.verboseMapping ) dyld::warn(\"disabling shared region because main executable overlaps\\n\"); &#125;#if __i386__ if ( !gLinkContext.allowEnvVarsPath ) &#123; // &lt;rdar://problem/15280847&gt; use private or no shared region for suid processes gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; &#125;#endif#endif // iOS cannot run without shared region&#125; 具体检测代码： 123456789101112131415161718bool MachOLoaded::intersectsRange(uintptr_t start, uintptr_t length) const&#123; __block bool result = false; uintptr_t slide = getSlide(); forEachSegment(^(const SegmentInfo&amp; info, bool&amp; stop) &#123; /* ①、主程序 segment 中的虚拟地址 + 虚拟地址大小 + 偏移量 &gt;= 共享区起始地址 ②、主程序 segment 中的虚拟地址 + 偏移量 &lt; 共享区终止地址 ① 和 ② 同时 YES，那么认为主程序 Mach-O 有 segments 与共享区重叠，此时共享区不可用，从而动态库缓存不可用 疑问：地址是从高到低分配？ */ if ( (info.vmAddr+info.vmSize+slide &gt;= start) &amp;&amp; (info.vmAddr+slide &lt; start+length) ) result = true; &#125;); return result;&#125; 可以看到这段检测代码在满足重叠条件后，并没有设置 stop = true 停止 forEachLoadCommand 中的循环，这里值得深究和讨论。 加载共享缓存最核心的步骤在 mapSharedCache 中： 12345678910111213141516171819202122232425262728static void mapSharedCache()&#123; dyld3::SharedCacheOptions opts; opts.cacheDirOverride = sSharedCacheOverrideDir; opts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion); #if __x86_64__ &amp;&amp; !TARGET_IPHONE_SIMULATOR opts.useHaswell = sHaswell;#else opts.useHaswell = false;#endif opts.verbose = gLinkContext.verboseMapping; // 加载 dyld 缓存 loadDyldCache(opts, &amp;sSharedCacheLoadInfo); // update global state // 更新进程的全局状态信息 if ( sSharedCacheLoadInfo.loadAddress != nullptr ) &#123; gLinkContext.dyldCache = sSharedCacheLoadInfo.loadAddress; dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate; dyld::gProcessInfo-&gt;sharedCacheSlide = sSharedCacheLoadInfo.slide; dyld::gProcessInfo-&gt;sharedCacheBaseAddress = (unsigned long)sSharedCacheLoadInfo.loadAddress; sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID); dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (const uuid_t *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[0], &#123;0,0&#125;, &#123;&#123; 0, 0 &#125;&#125;, (const mach_header *)sSharedCacheLoadInfo.loadAddress); &#125;&#125; SharedCacheRuntime.cpp 文件： 1234567891011121314151617181920212223242526272829303132bool loadDyldCache(const SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)&#123; results-&gt;loadAddress = 0; results-&gt;slide = 0; results-&gt;errorMessage = nullptr; #if TARGET_IPHONE_SIMULATOR // simulator only supports mmap()ing cache privately into process // 模拟器只支持 mmap（内存映射） 缓存到当前进程 return mapCachePrivate(options, results);#else if ( options.forcePrivate ) &#123; // mmap cache into this process only // 只加载 mmap（内存映射） 缓存到当前进程 return mapCachePrivate(options, results); &#125; else &#123; // fast path: when cache is already mapped into shared region bool hasError = false; // 已加载过的 if ( reuseExistingCache(options, results) ) &#123; hasError = (results-&gt;errorMessage != nullptr); &#125; // 未加载过的 else &#123; // slow path: this is first process to load cache hasError = mapCacheSystemWide(options, results); &#125; return hasError; &#125;#endif&#125; 加载缓存分三种情况： ①、仅加载到当前进程。通过 mapCachePrivate() 加载并返回错误信息；②、已经加载过的。通过 reuseExistingCache() 加载并返回错误信息，同时返回是否加载过 BOOL 值；③、未加载过的。通过 mapCacheSystemWide() 加载缓存并映射，返回错误信息。 options.forcePrivate 的定义： 12345678910111213// dyld.cppopts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion) gLinkContext.sharedRegionMode = ImageLoader::kUseSharedRegion; // ImageLoader.hclass ImageLoader &#123;public: ... enum SharedRegionMode &#123; kUseSharedRegion, kUsePrivateSharedRegion, kDontUseSharedRegion, kSharedRegionIsSharedCache &#125;; ... &#125; gLinkContext.sharedRegionMode 在 setContext() 方法中设置默认值，默认值为 kUseSharedRegion，也就是之前检测共享区是否可用的标识值。 3.4.3 实例化主程序系统会对已经映射到进程空间的主程序（在 XNU 解析 MachO 阶段就完成了映射操作）创建一个ImageLoaderMachO，再将其加入到 master list 中（sAllImages）。如果加载的 MachO 的硬件架构与本设备相符，就执行 imageLoader 的创建和添加操作。其中主要实现是ImageLoaderMachO::instantiateMainExecutable方法，该方法将主 App 的 MachHeader、ASLR，文件路径和前面提到的链接上下文作为参数，做 imageLoader 的实例化操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... CRSetCrashLogMessage(sLoadingCrashMessage); // instantiate ImageLoader for main executable // 实例化主程序 sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); gLinkContext.mainExecutable = sMainExecutable; // 代码签名 gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH); #if TARGET_IPHONE_SIMULATOR // check main executable is not too new for this OS // 检测主程序是否支持当前设备版本 &#123; // 检查是否是模拟器二进制文件 if ( ! isSimulatorBinary((uint8_t*)mainExecutableMH, sExecPath) ) &#123; throwf(\"program was built for a platform that is not supported by this runtime\"); &#125; uint32_t mainMinOS = sMainExecutable-&gt;minOSVersion(); // dyld is always built for the current OS, so we can get the current OS version // from the load command in dyld itself. // 获取 dyld 中存储的当前 OS 版本 uint32_t dyldMinOS = ImageLoaderMachO::minOSVersion((const mach_header*)&amp;__dso_handle); // 应用 mach-O 文件的版本超过了当前模拟器设备的版本，抛出异常 if ( mainMinOS &gt; dyldMinOS ) &#123; #if TARGET_OS_WATCH throwf(\"app was built for watchOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #elif TARGET_OS_TV throwf(\"app was built for tvOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #else throwf(\"app was built for iOS %d.%d which is newer than this simulator %d.%d\", mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #endif &#125; &#125;#endif #if __MAC_OS_X_VERSION_MIN_REQUIRED // &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries uint32_t mainSDK = sMainExecutable-&gt;sdkVersion(); gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures; #else // simulators, iOS, tvOS, and watchOS are always strict gLinkContext.strictMachORequired = true; #endif #if SUPPORT_ACCELERATE_TABLES sAllImages.reserve((sAllCacheImagesProxy != NULL) ? 16 : INITIAL_IMAGE_COUNT); #else sAllImages.reserve(INITIAL_IMAGE_COUNT); #endif // Now that shared cache is loaded, setup an versioned dylib overrides #if SUPPORT_VERSIONED_PATHS checkVersionedPaths(); // 设置加载的动态库版本。这里的动态库还没有包括经 DYLD_INSERT_LIBRARIES 插入的库。 #endif // dyld_all_image_infos image list does not contain dyld // add it as dyldPath field in dyld_all_image_infos // for simulator, dyld_sim is in image list, need host dyld added // dyld 加载的 image_infos 并不包含 dyld 本身，它被放到 dyld_all_image_infos 的 dyldPath 字段中去了。而对于模拟器，dyld 加载的 image_infos 是包含 dyld_sim 的。#if TARGET_IPHONE_SIMULATOR // get path of host dyld from table of syscall vectors in host dyld void* addressInDyld = gSyscallHelpers;#else // get path of dyld itself void* addressInDyld = (void*)&amp;__dso_handle;#endif // 获取 dyld 路径并与 gProcessInfo-&gt;dyldPath 对比 char dyldPathBuffer[MAXPATHLEN+1]; int len = proc_regionfilename(getpid(), (uint64_t)(long)addressInDyld, dyldPathBuffer, MAXPATHLEN); if ( len &gt; 0 ) &#123; dyldPathBuffer[len] = '\\0'; // proc_regionfilename() does not zero terminate returned string // 如果不同将获取到的路径复制给 gProcessInfo-&gt;dyldPath if ( strcmp(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != 0 ) gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer); &#125; ...&#125; dyld_all_image_infos 是个结构体，同样分为 32 位和 64 位两个版本，分别对应 dyld_all_image_infos_32 与 dyld_all_image_infos_64，由于获取 dyld_all_image_infos 需要用到一些未开源信息，这里为了方便，从侧面验证一下这条注释信息： 12345678910#import &lt;mach-o/dyld.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; for (uint32_t i = 0; i &lt; _dyld_image_count(); ++i) &#123; NSLog(@\"%s\", _dyld_get_image_name(i)); &#125;&#125; 模拟器： 真机： 可以看到：模拟器打印的 image 没有 dyld，第 0 个 image 是 dyld_sim，第一个 image 才是主程序；真机打印出的加载 image 中也没有 dyld，第 0 个 image 是主程序。 回到最核心的 instantiateFromLoadedImage 实例化主程序函数： 123456789101112131415161718// The kernel maps in main executable before dyld gets control. We need to // make an ImageLoader* for the already mapped in main executable.// kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化成 ImageLoader 加载到内存中交给 dyld 管理static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123; // try mach-o loader // CPU 架构是否匹配 if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123; // 实例化 ImageLoader 对象。参数：macho header、ASLR、执行路径、链接上下文 ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); // 分配主程序image的内存，更新。 addImage(image); return (ImageLoaderMachO*)image; &#125; throw \"main executable not a known format\";&#125; kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化ImageLoader 对象，加载到内存，返回交给 dyld 管理。 123456789101112131415161718192021222324252627282930// create image for main executableImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)&#123; //dyld::log(\"ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\\n\", // sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed)); bool compressed; unsigned int segCount; unsigned int libCount; const linkedit_data_command* codeSigCmd; const encryption_info_command* encryptCmd; // sniffLoadCommands 函数会对主程序 Mach-O进 行一系列的校验：对代码签名，MachO加密，动态库数量，段的数量相关信息的 loadCommand 做解析，提取出 command 数据。 /* case LC_DYLD_INFO: case LC_DYLD_INFO_ONLY: *compressed = true; */ sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd); // instantiate concrete class based on content of load commands // 已解密 if ( compressed ) // Compressed return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context); else#if SUPPORT_CLASSIC_MACHO // Classic return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);#else throw \"missing LC_DYLD_INFO load command\";#endif&#125; sniffLoadCommands 的校验并不包括对主程序 Mach-O 的解密操作，解密操作是由 xnu 完成的。 ImageLoaderMachOCompressed::instantiateMainExecutable、ImageLoaderMachOClassic::instantiateMainExecutable 两者内部的逻辑相同，只是返回类型一个是 ImageLoaderMachOCompressed 一个是 ImageLoaderMachOClassic。 以 ImageLoaderMachOCompressed 为例： 123456789101112131415161718192021222324252627282930313233343536// create image for main executableImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, unsigned int segCount, unsigned int libCount, const LinkContext&amp; context)&#123; // 初始化 image ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount); // set slide for PIE programs // 设置 image 偏移量 image-&gt;setSlide(slide); // for PIE record end of program, to know where to start loading dylibs if ( slide != 0 ) // 设置动态库起始地址 fgNextPIEDylibAddress = (uintptr_t)image-&gt;getEnd(); // 禁用段覆盖检测 image-&gt;disableCoverageCheck(); // 结束 image 上下文 image-&gt;instantiateFinish(context); // 设置 image 加载状态为 dyld_image_state_mapped image-&gt;setMapped(context); if ( context.verboseMapping ) &#123; dyld::log(\"dyld: Main executable mapped %s\\n\", path); for(unsigned int i=0, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123; const char* name = image-&gt;segName(i); if ( (strcmp(name, \"__PAGEZERO\") == 0) || (strcmp(name, \"__UNIXSTACK\") == 0) ) dyld::log(\"%18s at 0x%08lX-&gt;0x%08lX\\n\", name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i)); else dyld::log(\"%18s at 0x%08lX-&gt;0x%08lX\\n\", name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i)); &#125; &#125; return image;&#125; 12345void ImageLoader::setMapped(const LinkContext&amp; context)&#123; fState = dyld_image_state_mapped; context.notifySingle(dyld_image_state_mapped, this, NULL); // note: can throw exception&#125; instantiateFinish() 在内部解析 loadCmds、设置动态库连接信息、设置符号表相关信息等。setMapped() 内部调用 notifySingle 进行处理。 3.4.4 加载插入的动态库1234567891011121314151617181920uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // load any inserted libraries // 插入动态库 if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123; for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; // record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others. // 记录插入的动态库个数 sInsertedDylibCount = sAllImages.size()-1; ...&#125; 如果配置了 DYLD_INSERT_LIBRARIES 环境变量，通过loadInsertedDylib() 方法插入配置的动态库。对于越狱插件而言，其实就是通过添加 DYLD_INSERT_LIBRARIES 这个环境变量达到加载插件的目的。 123456789101112131415161718192021222324252627282930static void loadInsertedDylib(const char* path)&#123; ImageLoader* image = NULL; unsigned cacheIndex; try &#123; LoadContext context; context.useSearchPaths = false; context.useFallbackPaths = false; context.useLdLibraryPath = false; context.implicitRPath = false; context.matchByInstallName = false; context.dontLoad = false; context.mustBeBundle = false; context.mustBeDylib = true; context.canBePIE = false; context.enforceIOSMac = true; context.origin = NULL; // can't use @loader_path with DYLD_INSERT_LIBRARIES context.rpath = NULL; image = load(path, context, cacheIndex); &#125; catch (const char* msg) &#123; if ( gLinkContext.allowInsertFailures ) dyld::log(\"dyld: warning: could not load inserted library '%s' into hardened process because %s\\n\", path, msg); else halt(dyld::mkstringf(\"could not load inserted library '%s' because %s\\n\", path, msg)); &#125; catch (...) &#123; halt(dyld::mkstringf(\"could not load inserted library '%s'\\n\", path)); &#125;&#125; 内部构建 context 后调用 load() 函数生成 image。 1234567891011121314151617181920212223242526272829303132333435363738394041/*** @brief 做路径展开，搜索查找，排重，以及缓存查找工作。其中路径的展开和搜索分几个阶段（phase）*/ImageLoader* load(const char* path, const LoadContext&amp; context, unsigned&amp; cacheIndex)&#123; ... // 查找 image ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, NULL); // 没有找到 if ( image != NULL ) &#123; // 继续查找 CRSetCrashLogMessage2(NULL); return image; &#125; // try all path permutations and try open() until first success std::vector&lt;const char*&gt; exceptions; image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);#if !TARGET_IPHONE_SIMULATOR // &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache // 在共享缓存中查找 if ( image == NULL) image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);#endif CRSetCrashLogMessage2(NULL); if ( image != NULL ) &#123; // &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables for (std::vector&lt;const char*&gt;::iterator it = exceptions.begin(); it != exceptions.end(); ++it) &#123; free((void*)(*it)); &#125; // if loaded image is not from cache, but original path is in cache // set gSharedCacheOverridden flag to disable some ObjC optimizations if ( !gSharedCacheOverridden &amp;&amp; !image-&gt;inSharedCache() &amp;&amp; image-&gt;isDylib() &amp;&amp; cacheablePath(path) &amp;&amp; inSharedCache(path) ) &#123; gSharedCacheOverridden = true; &#125; return image; &#125; ...&#125; load 方法不仅被 loadInsertedDylib 调用，也会被 dlopen 等运行时加载动态库的方法使用。 内部有一整套 loadPhase0~loadPhase6 的流程来查找及加载 image。如果在共享缓存中找到则直接调用 instantiateFromCache 实例化 image，否则通过 loadPhase5open 打开文件并调用loadPhase6，内部通过 instantiateFromFile 实例化 image，最后再调用 checkandAddImage 将image 加载进内存。 这些 phase 的搜索路径对应各个环境变量：DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。 ImageLoaderMachO 的 instantiateFromFile、instantiateFromCache 是 loader 将 MachO 文件解析映射到内存的核心方法，两个都会进入 Compressed 和 Classic 的分叉步骤。以 Compressed 下的 instantiateFromFile 来分析。 1234567891011121314151617181920212223242526272829303132333435363738// create image by mapping in a mach-o fileImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateFromFile(const char* path, int fd, const uint8_t* fileData, size_t lenFileData, uint64_t offsetInFat, uint64_t lenInFat, const struct stat&amp; info, unsigned int segCount, unsigned int libCount, const struct linkedit_data_command* codeSigCmd, const struct encryption_info_command* encryptCmd, const LinkContext&amp; context)&#123; ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart((macho_header*)fileData, path, segCount, libCount); try &#123; // record info about file image-&gt;setFileInfo(info.st_dev, info.st_ino, info.st_mtime); // if this image is code signed, let kernel validate signature before mapping any pages from image // ①、交给内核去验证动态库的代码签名 image-&gt;loadCodeSignature(codeSigCmd, fd, offsetInFat, context); // Validate that first data we read with pread actually matches with code signature // ②、映射到内存的 first page, （4k大小）与代码签名是否match。在这里会执行沙盒，签名认证 image-&gt;validateFirstPages(codeSigCmd, fd, fileData, lenFileData, offsetInFat, context); // mmap segments image-&gt;mapSegments(fd, offsetInFat, lenInFat, info.st_size, context); // if framework is FairPlay encrypted, register with kernel // 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据cryptid是否为1做了解密操作。 image-&gt;registerEncryption(encryptCmd, context); // probe to see if code signed correctly image-&gt;crashIfInvalidCodeSignature(); // finish construction image-&gt;instantiateFinish(context); ... &#125;&#125; 其中几个需要留意的步骤： 交给内核去验证动态库的代码签名 loadCodeSignature。 映射到内存的 first page（4k 大小）与代码签名是否 match。在这里会执行沙盒，签名认证，对于在线上运行时加载动态库的需求，可以重点研究这里。 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息 registerEncryption。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据 cryptid 是否为 1 做了解密操作。 如果走到 Phase6, 会调 xmap 函数将动态库从本地 mmap 到用户态内存空间。 根据上面的分析，主程序 imageLoader 在全局 image 表的首位，后面的是插入的动态库的 imageLoader，每个动态库对应一个 loader。 3.4.5 链接主程序链接所有动态库，进行符号修正绑定工作。 123456789101112131415161718192021222324uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // link main executable gLinkContext.linkingMainExecutable = true;#if SUPPORT_ACCELERATE_TABLES if ( mainExcutableAlreadyRebased ) &#123; // previous link() on main executable has already adjusted its internal pointers for ASLR // work around that by rebasing by inverse amount sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide); &#125;#endif // 链接主程序 link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) &#123; gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; &#125; ...&#125; 可以看到，主程序的链接是通过 link 这个函数完成的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)&#123; // add to list of known images. This did not happen at creation time for bundles // 添加到已知镜像列表中。这在创建 bundles 时没有处理。 if ( image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked() ) addImage(image); // we detect root images as those not linked in yet // 在根镜像中检测是否尚未链接 if ( !image-&gt;isLinked() ) addRootImage(image); // process images try &#123; const char* path = image-&gt;getPath();#if SUPPORT_ACCELERATE_TABLES if ( image == sAllCacheImagesProxy ) path = sAllCacheImagesProxy-&gt;getIndexedPath(cacheIndex);#endif // 调用 ImageLoader::link() 链接 image-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path); &#125; catch (const char* msg) &#123; // 标记 image 为未使用，处理 garbageCollectImages(); throw; &#125;&#125; void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)&#123; //dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload); // clear error strings (*context.setErrorStrings)(0, NULL, NULL, NULL); // 起始时间。用于记录时间间隔 uint64_t t0 = mach_absolute_time(); // ①、递归加载主程序依赖的库，完成之后发送一个状态为 dyld_image_state_dependents_mapped的通知。 this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath); context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly); // we only do the loading step for preflights 只做预检的装载步骤 if ( preflightOnly ) return; uint64_t t1 = mach_absolute_time(); // 清空 image 层级关系 context.clearAllDepths(); // 递归更新 image 层级关系 this-&gt;recursiveUpdateDepth(context.imageCount()); __block uint64_t t2, t3, t4, t5; &#123; dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0); t2 = mach_absolute_time(); // ②、递归修正自己和依赖库的基地址，因为 ASLR 的原因，需要根据随机 slide 修正基地址。 this-&gt;recursiveRebase(context); context.notifyBatch(dyld_image_state_rebased, false); t3 = mach_absolute_time(); if ( !context.linkingMainExecutable ) // ③、递归绑定 noLazy 的符号表，lazy的符号会在运行时动态绑定（首次被调用才去绑定） this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload); t4 = mach_absolute_time(); if ( !context.linkingMainExecutable ) // ④、绑定弱符号表，比如未初始化的全局变量就是弱符号。 this-&gt;weakBind(context); t5 = mach_absolute_time(); &#125; if ( !context.linkingMainExecutable ) context.notifyBatch(dyld_image_state_bound, false); uint64_t t6 = mach_absolute_time(); std::vector&lt;DOFInfo&gt; dofs; // ⑤、递归获取/注册程序的 DOF 节区，dtrace 会用其动态跟踪。 this-&gt;recursiveGetDOFSections(context, dofs); // 注册 context.registerDOFs(dofs); uint64_t t7 = mach_absolute_time(); // interpose any dynamically loaded images if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123; dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0); // 递归应用插入的动态库 this-&gt;recursiveApplyInterposing(context); &#125; // clear error strings (*context.setErrorStrings)(0, NULL, NULL, NULL); // 计算出各种时间间隔 fgTotalLoadLibrariesTime += t1 - t0; fgTotalRebaseTime += t3 - t2; fgTotalBindTime += t4 - t3; fgTotalWeakBindTime += t5 - t4; fgTotalDOF += t7 - t6; // done with initial dylib loads fgNextPIEDylibAddress = 0;&#125; 内部加载动态库、rebase、绑定符号表、注册dofs信息等，同时还计算各步骤的耗时。如果想获取这些耗时，只需要在环境变量中添加 DYLD_PRINT_STATISTICS 就可以了，这个环境变量不需要 value。 在步骤 ① 里，递归加载主 App 在打包阶段就确定好的动态库的操作，会使用前面提到的 setContext 里的链接上下文，调用它的 loadLibrary 方法；然后优先去加载依赖的动态库。loadLibary 的实现在设置链接上下文的时候就已经赋值确定，即 libraryLocator，在这个方法里会用到上面提到的 load 方法。 在步骤 ③ 里，会有符号绑定的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041/*** @brief recursiveBind 完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，对于 DYLD_BIND_AT_LAUNCH 等特殊情况下的 non-lazy 符号才执行立即绑定。*/void ImageLoader::recursiveBind(const LinkContext&amp; context, bool forceLazysBound, bool neverUnload)&#123; // Normally just non-lazy pointers are bound immediately. // The exceptions are: // 1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately // 2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately if ( fState &lt; dyld_image_state_bound ) &#123; // break cycles fState = dyld_image_state_bound; try &#123; // bind lower level libraries first for(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload); &#125; // bind this image // 绑定。this 表示递归调用时，recursiveBind 方法的调用者 this-&gt;doBind(context, forceLazysBound); // mark if lazys are also bound if ( forceLazysBound || this-&gt;usablePrebinding(context) ) fAllLazyPointersBound = true; // mark as never-unload if requested if ( neverUnload ) this-&gt;setNeverUnload(); // 通知 context.notifySingle(dyld_image_state_bound, this, NULL); &#125; catch (const char* msg) &#123; // restore state fState = dyld_image_state_rebased; CRSetCrashLogMessage2(NULL); throw; &#125; &#125;&#125; 方法的核心是 ImageLoaderMach 的 doBind，读取 image 的动态链接信息的 bind_off 与 bind_size 来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用 bindAt 函数；调用 resolve 解析完符号表后，调用 bindLocation 完成最终的绑定操作，需要绑定的符号信息有三种： BIND_TYPE_POINTER：需要绑定的是一个指针。直接将计算好的新值屿值即可。 BIND_TYPE_TEXT_ABSOLUTE32：一个32位的值。取计算的值的低32位赋值过去。 BIND_TYPE_TEXT_PCREL32：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。 对延迟绑定的实现感兴趣的可以在Xcode中调试查看，或者参考这个。 3.4.6 链接插入的动态库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses // 链接其他被插入的动态库 if ( sInsertedDylibCount &gt; 0 ) &#123; // 循环处理 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; // 链接 link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); // 递归修改 image 的 fNeverUnload 属性 image-&gt;setNeverUnloadRecursive(); &#125; // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works // 只有插入可插入的库。在绑定所有插入的库后注册插入信息，以便链接工作 for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); &#125; &#125; // &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES // 即使没有 DYLD_INSERT_LIBRARIES，dyld 也应该支持插入 for (long i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123; ImageLoader* image = sAllImages[i]; if ( image-&gt;inSharedCache() ) continue; image-&gt;registerInterposing(gLinkContext); &#125; #if SUPPORT_ACCELERATE_TABLES // !TARGET_IPHONE_SIMULATOR，非模拟器 if ( (sAllCacheImagesProxy != NULL) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123; // Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled // 加速键表不能与隐式插入一起使用，因此在禁用加速键表的情况下重新启动 ImageLoader::clearInterposingTuples(); // unmap all loaded dylibs (but not main executable) // 取消映射所有加载的 dylib 文件，除了主程序 for (long i=1; i &lt; sAllImages.size(); ++i) &#123; ImageLoader* image = sAllImages[i]; if ( image == sMainExecutable ) continue; if ( image == sAllCacheImagesProxy ) continue; image-&gt;setCanUnload(); ImageLoader::deleteImage(image); &#125; // note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table sAllImages.clear(); sImageRoots.clear(); sImageFilesNeedingTermination.clear(); sImageFilesNeedingDOFUnregistration.clear(); sAddImageCallbacks.clear(); sRemoveImageCallbacks.clear(); sAddLoadImageCallbacks.clear(); sDisableAcceleratorTables = true; sAllCacheImagesProxy = NULL; // 下次不再进入 sMappedRangesStart = NULL; mainExcutableAlreadyRebased = true; gLinkContext.linkingMainExecutable = false; resetAllImages(); // 跳转回上面的步骤，重新执行，加载所有的镜像 goto reloadAllImages; &#125; #endif // apply interposing to initial set of images for(int i=0; i &lt; sImageRoots.size(); ++i) &#123; // 是调用 ImageLoader::applyInterposing()，不是 ClosureWriter.cpp。内部递归，最终是执行 doInterpose() 方法 sImageRoots[i]-&gt;applyInterposing(gLinkContext); &#125; // 插入信息存入 dyld 缓存 ImageLoader::applyInterposingToDyldCache(gLinkContext); // 修改主程序插入标识 gLinkContext.linkingMainExecutable = false; // Bind and notify for the main executable now that interposing has been registered // 从主程序开始调用，递归执行绑定、通知（插入信息已经注册） uint64_t bindMainExecutableStartTime = mach_absolute_time(); // 内部执行 doBind()、notifySingle() sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); uint64_t bindMainExecutableEndTime = mach_absolute_time(); // 绑定和通知处理时间 ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime; gLinkContext.notifyBatch(dyld_image_state_bound, false); // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount &gt; 0 ) &#123; for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123; ImageLoader* image = sAllImages[i+1]; // 绑定插入的动态库 image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); &#125; &#125; ...&#125; 这里参与链接的动态库根据第 4 步中加载的插入的动态库，从 sAllImages 的第二个 imageLoader 开始，取出 image，重复 link 操作进行连接。registerInterposing 内部会加载 loadCmds 并查找 __interpose 及 __DATA 段，读取段信息保存到 fgInterposingTuples 中，然后调用 applyInterposing，内部调用 recursiveApplyInterposing，通过这个函数调用到 doInterpose。 123456789101112131415161718192021222324252627void ImageLoaderMachOCompressed::doInterpose(const LinkContext&amp; context)&#123; if ( context.verboseInterposing ) dyld::log(\"dyld: interposing %lu tuples onto image: %s\\n\", fgInterposingTuples.size(), this-&gt;getPath()); // update prebound symbols。更新预绑定的符号 eachBind(context, ^(const LinkContext&amp; ctx, ImageLoaderMachOCompressed* image, uintptr_t addr, uint8_t type, const char* symbolName, uint8_t symbolFlags, intptr_t addend, long libraryOrdinal, ExtraBindData *extraBindData, const char* msg, LastLookup* last, bool runResolver) &#123; // 直接调用 interposeAt() return ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags, addend, libraryOrdinal, extraBindData, msg, last, runResolver); &#125;); eachLazyBind(context, ^(const LinkContext&amp; ctx, ImageLoaderMachOCompressed* image, uintptr_t addr, uint8_t type, const char* symbolName, uint8_t symbolFlags, intptr_t addend, long libraryOrdinal, ExtraBindData *extraBindData, const char* msg, LastLookup* last, bool runResolver) &#123; // 直接调用 interposeAt() return ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags, addend, libraryOrdinal, extraBindData, msg, last, runResolver); &#125;);&#125; interposeAt 通过 interposedAddress 在上文提到的 fgInterposingTuples 中找到需要替换的符号地址进行替换。 3.4.7 弱符号绑定1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... // &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked // 弱符号绑定 sMainExecutable-&gt;weakBind(gLinkContext); ...&#125;void ImageLoader::weakBind(const LinkContext&amp; context)&#123; if ( context.verboseWeakBind ) dyld::log(\"dyld: weak bind start:\\n\"); uint64_t t1 = mach_absolute_time(); // get set of ImageLoaders that participate in coalecsing ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing]; unsigned imageIndexes[fgImagesRequiringCoalescing]; // 合并所有动态库的弱符号到列表中 int count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes); // count how many have not already had weakbinding done int countNotYetWeakBound = 0; int countOfImagesWithWeakDefinitionsNotInSharedCache = 0; for(int i=0; i &lt; count; ++i) &#123; if ( ! imagesNeedingCoalescing[i]-&gt;weakSymbolsBound(imageIndexes[i]) ) // 获取未进行绑定的弱符号的个数 ++countNotYetWeakBound; if ( ! imagesNeedingCoalescing[i]-&gt;inSharedCache() ) // 获取在共享缓存中已绑定的弱符号个数 ++countOfImagesWithWeakDefinitionsNotInSharedCache; &#125; // don't need to do any coalescing if only one image has overrides, or all have already been done if ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; 0) &amp;&amp; (countNotYetWeakBound &gt; 0) ) &#123; // make symbol iterators for each ImageLoader::CoalIterator iterators[count]; ImageLoader::CoalIterator* sortedIts[count]; for(int i=0; i &lt; count; ++i) &#123; // 对需要绑定的弱符号排序 imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i, imageIndexes[i]); sortedIts[i] = &amp;iterators[i]; if ( context.verboseWeakBind ) dyld::log(\"dyld: weak bind load order %d/%d for %s\\n\", i, count, imagesNeedingCoalescing[i]-&gt;getIndexedPath(imageIndexes[i])); &#125; // walk all symbols keeping iterators in sync by // only ever incrementing the iterator with the lowest symbol int doneCount = 0; while ( doneCount != count ) &#123; //for(int i=0; i &lt; count; ++i) // dyld::log(\"sym[%d]=%s \", sortedIts[i]-&gt;loadOrder, sortedIts[i]-&gt;symbolName); //dyld::log(\"\\n\"); // increment iterator with lowest symbol // 计算弱符号偏移量及大小，绑定弱符号 if ( sortedIts[0]-&gt;image-&gt;incrementCoalIterator(*sortedIts[0]) ) ++doneCount; ... &#125;&#125; 主要流程：合并所有动态库的弱符号到列表中 -&gt; 对需要绑定的弱符号排序 -&gt; 计算弱符号偏移量及大小，绑定弱符号 3.4.8 初始化主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; ... CRSetCrashLogMessage(\"dyld: launch, running initializers\"); #if SUPPORT_OLD_CRT_INITIALIZATION // Old way is to run initializers via a callback from crt1.o if ( ! gRunInitializersOldWay ) // 初始化主程序 initializeMainExecutable(); #else // run all initializers // 初始化主程序 initializeMainExecutable(); #endif // notify any montoring proccesses that this process is about to enter main() // 通知任何监视进程，此进程将要进入main（）。 if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123; dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); &#125; notifyMonitoringDyldMain(); ...&#125; void initializeMainExecutable()&#123; // record that we've reached this step。开始初始化标识 gLinkContext.startedInitializingMainExecutable = true; // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount &gt; 1 ) &#123; for(size_t i=1; i &lt; rootCount; ++i) &#123; // 初始化动态库 sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]); &#125; &#125; // run initializers for main executable and everything it brings up // 初始化主程序 sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); // register cxa_atexit() handler to run static terminators in all loaded images when this process exits if ( gLibSystemHelpers != NULL ) (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); // dump info if requested if ( sEnv.DYLD_PRINT_STATISTICS ) ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]); if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS ) ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);&#125; 先初始化动态库，然后初始化主程序。上文提到的 DYLD_PRINT_STATISTICS 环境变量在这里也出现了，除此之外还有个 detail 版的环境变量 DYLD_PRINT_STATISTICS_DETAILS。 1234567891011121314151617181920212223242526272829303132333435363738394041void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo)&#123; uint64_t t1 = mach_absolute_time(); // 获取线程 mach_port_t thisThread = mach_thread_self(); ImageLoader::UninitedUpwards up; up.count = 1; up.images[0] = this; // 在进程中初始化 processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); mach_port_deallocate(mach_task_self(), thisThread); uint64_t t2 = mach_absolute_time(); // 初始化耗时 fgTotalInitTime += (t2 - t1);&#125;// &lt;rdar://problem/14412057&gt; upward dylib initializers can be run too soon// To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs// have their initialization postponed until after the recursion through downward dylibs// has completed.void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread, InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)&#123; uint32_t maxImageCount = context.imageCount()+2; ImageLoader::UninitedUpwards upsBuffer[maxImageCount]; ImageLoader::UninitedUpwards&amp; ups = upsBuffer[0]; ups.count = 0; // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. for (uintptr_t i=0; i &lt; images.count; ++i) &#123; images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups); &#125; // If any upward dependencies remain, init them. if ( ups.count &gt; 0 ) // 递归调用 processInitializers(context, thisThread, timingInfo, ups);&#125; 动态库和主程序的初始化是调用 runInitializers，内部通过 processInitializers 调用 recursiveInitialization 递归初始化当前 image 所依赖的库。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)&#123; // 递归锁 recursive_lock lock_info(this_thread); recursiveSpinLock(lock_info); if ( fState &lt; dyld_image_state_dependents_initialized-1 ) &#123; uint8_t oldState = fState; // break cycles // 退出递归循环 fState = dyld_image_state_dependents_initialized-1; try &#123; // initialize lower level libraries first // 先初始化低级别的库 for(unsigned int i=0; i &lt; libraryCount(); ++i) &#123; ImageLoader* dependentImage = libImage(i); if ( dependentImage != NULL ) &#123; // don't try to initialize stuff \"above\" me yet // 不要试图初始化级别高于我的 if ( libIsUpward(i) ) &#123; uninitUps.images[uninitUps.count] = dependentImage; uninitUps.count++; &#125; else if ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123; dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps); &#125; &#125; &#125; // record termination order. 记录终止命令 if ( this-&gt;needsTermination() ) context.terminationRecorder(this); // let objc know we are about to initialize this image uint64_t t1 = mach_absolute_time(); fState = dyld_image_state_dependents_initialized; oldState = fState; // context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo); // initialize this image // 真正初始化镜像 bool hasInitializers = this-&gt;doInitialization(context); // let anyone know we finished initializing this image fState = dyld_image_state_initialized; oldState = fState; context.notifySingle(dyld_image_state_initialized, this, NULL); if ( hasInitializers ) &#123; uint64_t t2 = mach_absolute_time(); timingInfo.addTime(this-&gt;getShortName(), t2-t1); &#125; &#125; catch (const char* msg) &#123; // this image is not initialized fState = oldState; recursiveSpinUnLock(); throw; &#125; &#125; recursiveSpinUnLock();&#125; 注意内部有个调用 context.notifySingle(dyld_image_state_initialized, this, NULL)，其实每次 image 状态改变都会调用 notifySingle 这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)&#123; //dyld::log(\"notifySingle(state=%d, image=%s)\\n\", state, image-&gt;getPath()); std::vector&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers); if ( handlers != NULL ) &#123; dyld_image_info info; info.imageLoadAddress = image-&gt;machHeader(); info.imageFilePath = image-&gt;getRealPath(); info.imageFileModDate = image-&gt;lastModified(); for (std::vector&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123; const char* result = (*it)(state, 1, &amp;info); if ( (result != NULL) &amp;&amp; (state == dyld_image_state_mapped) ) &#123; //fprintf(stderr, \" image rejected by handler=%p\\n\", *it); // make copy of thrown string so that later catch clauses can free it const char* str = strdup(result); throw str; &#125; &#125; &#125; if ( state == dyld_image_state_mapped ) &#123; // &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache if ( !image-&gt;inSharedCache() ) &#123; dyld_uuid_info info; if ( image-&gt;getUUID(info.imageUUID) ) &#123; info.imageLoadAddress = image-&gt;machHeader(); addNonSharedCacheImageUUID(info); &#125; &#125; &#125; if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) &#123; uint64_t t0 = mach_absolute_time(); dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); uint64_t t1 = mach_absolute_time(); uint64_t t2 = mach_absolute_time(); uint64_t timeInObjC = t1-t0; uint64_t emptyTime = (t2-t1)*100; if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != NULL) ) &#123; timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC); &#125; &#125; // mach message csdlc about dynamically unloaded images if ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123; notifyKernel(*image, false); const struct mach_header* loadAddress[] = &#123; image-&gt;machHeader() &#125;; const char* loadPath[] = &#123; image-&gt;getPath() &#125;; notifyMonitoringDyld(true, 1, loadAddress, loadPath); &#125;&#125; 当 state == dyld_image_state_mapped 时，将 image 对应的 UUID 存起来，当state == dyld_image_state_dependents_initialized 并且有 sNotifyObjCInit 回调时调用sNotifyObjCInit函数。 搜索回调函数赋值入口： 12345678910111213141516void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; // record functions to call sNotifyObjCMapped = mapped; sNotifyObjCInit = init; sNotifyObjCUnmapped = unmapped; ...&#125; void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)&#123; dyld::registerObjCNotifiers(mapped, init, unmapped);&#125; 发现是通过 _dyld_objc_notify_register 这个函数注册回调的。 [NSObject load] 的堆栈： 1234567891011121314151617181920212223* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2 * frame #0: 0x000000010944f3b1 libobjc.A.dylib`+[NSObject load] frame #1: 0x000000010943d317 libobjc.A.dylib`call_load_methods + 691 frame #2: 0x000000010943e814 libobjc.A.dylib`load_images + 77 frame #3: 0x0000000108b73b97 dyld_sim`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 260 frame #4: 0x000000010b779bf3 libdyld.dylib`_dyld_objc_notify_register + 113 frame #5: 0x000000010944ca12 libobjc.A.dylib`_objc_init + 115 frame #6: 0x000000010b7015c0 libdispatch.dylib`_os_object_init + 13 frame #7: 0x000000010b70f4e5 libdispatch.dylib`libdispatch_init + 300 frame #8: 0x0000000109e05a78 libSystem.B.dylib`libSystem_initializer + 164 frame #9: 0x0000000108b82b96 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 506 frame #10: 0x0000000108b82d9c dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40 frame #11: 0x0000000108b7e3fc dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 324 frame #12: 0x0000000108b7e392 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 218 frame #13: 0x0000000108b7d5d3 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 133 frame #14: 0x0000000108b7d665 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 73 frame #15: 0x0000000108b71333 dyld_sim`dyld::initializeMainExecutable() + 129 frame #16: 0x0000000108b75434 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4384 frame #17: 0x0000000108b70630 dyld_sim`start_sim + 136 frame #18: 0x00000001155c1234 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2238 frame #19: 0x00000001155bf0ce dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 522 frame #20: 0x00000001155ba503 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1167 frame #21: 0x00000001155ba036 dyld`_dyld_start + 54 可以看到，_dyld_objc_notify_register 是在初始化 libobjc.A.dylib 这个动态库时调用的，然后 _objc_init 内部调用了 load_images，进而调用 call_load_methods，从而调用各个类中的load方法，Objc源码。 notifySingle 调用完毕后，开始真正初始化工作 doInitialization： 123456789101112bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)&#123; CRSetCrashLogMessage2(this-&gt;getPath()); // mach-o has -init and static initializers doImageInit(context); doModInitFunctions(context); CRSetCrashLogMessage2(NULL); return (fHasDashInit || fHasInitializers);&#125; doImageInit 执行 LC_ROUTINES_COMMAND segment 中保存的函数，doModInitFunctions执行 __DATA,__mod_init_func section 中保存的函数。这个 section 中保存的是 C++ 的构造函数及带有 attribute((constructor)) 的 C 函数，简单验证一下： 12345678910111213141516171819202122232425262728// ViewController.mm class Test &#123;public: Test();&#125;; Test::Test()&#123; NSLog(@&quot;%s&quot;, __func__);&#125; Test test; __attribute__((constructor)) void testConstructor() &#123; NSLog(@&quot;%s&quot;, __func__);&#125; - (void)viewDidLoad &#123; [super viewDidLoad]; testConstructor(); Test * t = new Test();&#125; 2019-08-19 13:26:33.587051+0800 Demo[7105:314102] testConstructor2019-08-19 13:26:33.587109+0800 Demo[7105:314102] Test 通过 MachOView 可以看到： 显然，__mod_init_func 中的函数在类对应的 load 方法之后调用。 对于 dumpdcrypted 这一类注入方法实现功能的插件，他们添加的静态方法会在 doModInitFunctions方法中被解析出来，位置在 MachO 文件的 __DATA 段的 __mod_init_func section。C++ 的全局对象也会出现在这个section中。 在递归初始化 (recursiveInitialization）中，如果当前执行的是主程序 image，doInitialization 完毕后会执行 notifySingle 方法去通知观察者。在 doInitialization 方法前会发送 state 为 dyld_image_state_dependents_initialized 的通知，由这个通知，会调用 libobjc 的 load_images，最后去依次调用各个 OC 类的 load 方法以及分类的 load 方法。 Objective-C 的入口方法是 _objc_init，dyld 唤起它的执行路径是从 runInitializers -&gt; recursiveInitialization -&gt; doInitialization -&gt; doModInitFunctions -&gt;.. _objc_init。 12345678void _objc_init(void)&#123; // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_2_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; _objc_init 会在 dyld 中注册两个通知，对应的回调会分别执行将 OC 类加载到内存和调用 load 方法的操作。后面的就是 OC 类加载的经典方法 map_2_images 了。 从 recursiveInitialization 的以下代码片段可以看出 load 是在全局实例或者方法调用前被触发的。 1234567context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo);// initialize this imagebool hasInitializers = this-&gt;doInitialization(context);// let anyone know we finished initializing this imagefState = dyld_image_state_initialized;oldState = fState;context.notifySingle(dyld_image_state_initialized, this, NULL); 3.4.9 查找主程序入口函数指针并返回调用getEntryFromLC_MAIN 获取主程序 main 函数的地址，如果未找到则调用getEntryFromLC_UNIXTHREAD 获取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void* ImageLoaderMachO::getEntryFromLC_MAIN() const&#123; const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; if ( cmd-&gt;cmd == LC_MAIN ) &#123; entry_point_command* mainCmd = (entry_point_command*)cmd; void* entry = (void*)(mainCmd-&gt;entryoff + (char*)fMachOData); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; else throw \"LC_MAIN entryoff is out of range\"; &#125; cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; return NULL;&#125; void* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() const&#123; const uint32_t cmd_count = ((macho_header*)fMachOData)-&gt;ncmds; const struct load_command* const cmds = (struct load_command*)&amp;fMachOData[sizeof(macho_header)]; const struct load_command* cmd = cmds; for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123; if ( cmd-&gt;cmd == LC_UNIXTHREAD ) &#123; #if __i386__ const i386_thread_state_t* registers = (i386_thread_state_t*)(((char*)cmd) + 16); void* entry = (void*)(registers-&gt;eip + fSlide); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #elif __x86_64__ const x86_thread_state64_t* registers = (x86_thread_state64_t*)(((char*)cmd) + 16); void* entry = (void*)(registers-&gt;rip + fSlide); // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #elif __arm64__ &amp;&amp; !__arm64e__ // temp support until &lt;rdar://39514191&gt; is fixed const uint64_t* regs64 = (uint64_t*)(((char*)cmd) + 16); void* entry = (void*)(regs64[32] + fSlide); // arm_thread_state64_t.__pc // &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image if ( this-&gt;containsAddress(entry) ) return entry; #endif &#125; cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize); &#125; throw \"no valid entry point\";&#125; 可以看到，入口是在 load_command 的 LC_MAIN 或者 LC_UNIXTHREAD 中 LC_MAIN。 四、dyld 闭包在第 2 步和第 3 步之间有一个查找闭包并以其结果作为程序入口返回的代码，这里是 WWDC 2017 推出的 dyld3 中提出的一种优化 App 启动速度的技术。大致步骤如下： 如果满足条件：开启闭包（DYLD_USE_CLOSURES 环境变量为 1），App 的路径在白名单中（目前只有系统 Ap p享有使用闭包的特权），共享缓存加载地址不为空，则往下执行。 去内存中查找闭包数据，这里的方法是 findClosure。如果内存中不存在，再去 /private/var/staged_system_apps 路径下去查找硬盘数据，找到就返回结果。 如果没有闭包数据，就会调用 socket 通信走 RPC 去获取闭包数据，执行方法为 callClosureDaemon，感兴趣可以研究下。 如果闭包数据不为空，就会走核心方法：launchWithClosure，基于闭包去启动 App，并且返回该方法中获取的程序入口地址给外界。这个方法重复了上面的各个步骤。具体实现和内部的数据结构有待分析。 五、共享缓存机制在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个一个加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到 /System/Library/Caches/com.apple.dyld/ 目录下，按不同的架构保存分别保存着，原作者的 iPhone6 里面就有 dyld_shared_cache_armv7s 和 dyld_shared_cache_armv64 两个文件，如下图所示。 想要分析某个系统库，就需要从 dyld_shared_cache 里先将的原始二进制文件提取出来，这里从易到难提供 3 种方法： 5.1 dyld_cache_extract 提取dyld_cache_extract 是一个可视化的工具，使用极其简单，把 dyld_shared_cache 载入即可解析出来，如下图所示。 5.2 jtool 提取以提取 CFNetwork 为例，使用如下命令即可： 1$ jtool -extract CFNetwork ./dyld_shared_cache_arm64 5.3 dsc_extractor 提取在 dyld 源代码的 launch-cache 文件夹里面找到 dsc_extractor.cpp，将 653 行的“#if 0”修改为“#if 1”，然后用如下命令编译生成 dsc_extractor，并使用它提取所有缓存文件： 12$ clang++ dsc_extractor.cpp dsc_iterator.cpp -o dsc_extractor$ ./dsc_extractor ./dyld_shared_cache_arm64 ./ 六、总结每个 MachO 都会由一个 imageLoader 来处理加载和依赖管理的操作，这里是由 dyld 来安排。主程序 app 的 image 的加载是由内核来完成的。其他的动态库的加载细节可以参考上面提到的 link 方法实现，当一个 image 加载完毕，dyld 会发送 dyld_image_state_bound 通知；著名的 hook 工具 fishhook 的实现原理也是借助监听这个通知，在回调里完成 hook 操作的。 七、文章01_Jack &amp; dyld源码解读伊织__ &amp; Mac - otoolRemisKrlet &amp; App启动过程 - dyld加载动态库dyld详解","tags":[]},{"title":"终端","date":"2019-08-06T05:54:23.090Z","path":"2019/08/06/工具/终端/","text":"1、github clone 提速1.1 修改 hosts 文件 在 IPAddress.com 网站中中分别查询 https://www.github.com 和 github.global.ssl.fastly.net 域名的 IP 地址。 打开的 hosts 文件 【Windows】 1C:\\Windows\\System32\\drivers\\etc\\host 【Mac】 1$ sudo vi /etc/hosts 更多阅读 重启 Finder 进程 1~ $ killall Finder","tags":[]},{"title":"Xcode","date":"2019-08-06T05:35:43.506Z","path":"2019/08/06/工具/Xcode/","text":"一、整行上下移动Xcode 自带的配置文件路径：/Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Versions/A/Resources/IDETextKeyBindingSet.plist，用文本编辑 IDETextKeyBindingSet.plist，并添加以下代码： 123456789101112131415&lt;key&gt;GDI Commands&lt;/key&gt;&lt;dict&gt; &lt;key&gt;GDI Duplicate Current Line&lt;/key&gt; &lt;string&gt;selectLine:, copy:, moveToEndOfLine:,insertNewline:, paste:, deleteBackward:&lt;/string&gt; &lt;key&gt;GDI Delete Current Line&lt;/key&gt; &lt;string&gt;moveToEndOfLine:, deleteToBeginningOfLine:,deleteBackward:,moveDown:,moveToEndOfLine:&lt;/string&gt; &lt;key&gt;GDI Move Current Line Up&lt;/key&gt; &lt;string&gt;selectLine:, cut:, moveUp:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt; &lt;key&gt;GDI Move Current Line Down&lt;/key&gt; &lt;string&gt;selectLine:, cut:, moveDown:, moveToBeginningOfLine:, insertNewLine:, paste:, moveBackward:&lt;/string&gt; &lt;key&gt;GDI Insert Line Above&lt;/key&gt; &lt;string&gt;moveUp:, moveToEndOfLine:, insertNewline:&lt;/string&gt; &lt;key&gt;GDI Insert Line Below&lt;/key&gt; &lt;string&gt;moveToEndOfLine:, insertNewline:&lt;/string&gt; &lt;/dict&gt; 注意：Xcode.app 需要换成实际的应用名，如 Xcode10.1.app。 详细文章：xcode 设置快捷键 整行上下移动 二、Other linker flagsOther linker flags 用来填写 XCode 的链接器参数。 从 C 代码到可执行文件经历的步骤是： 源代码 -&gt; 预处理器 -&gt; 编译器 -&gt; 汇编器 -&gt; 机器码 -&gt; 链接器 -> 可执行文件 在最后一步需要把 .o 文件和 C 语言运行库链接起来，这时候需要用到 ld 命令。 源文件经过一系列处理以后，会生成对应的 .obj 文件，然后一个项目必然会有许多 .obj 文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。 Other linker flags 设置的值实际上就是 ld 命令执行时后面所加的参数。 The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. 运行时的异常是由于标准 XNIX 静态库、链接器与 OC 语言的动态的特性之间的问题，OC 语言并不是对每一个函数或者方法建立链接器符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不知道将核心类与分类之间的代码实现联系起来，这就导致最终的应用程序中的可执行文件缺失了分类中的代码，这样函数调用就失败了。 常用参数： －ObjC 链接器就会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中。 这样编译之后的 app 会变大，因为加载了很多不必要的文件而导致可执行文件变大。但是如果静态库中有类和 category 的话只有加入这个 flag 才行。但是 Objc 也不是万能的，当静态库中只有分类而没有类的时候，Objc 就失效了，这就需要使用 -all_load 或者 -force_load 了。 123456789101112131415161718@implementation MyStaticLib+ (void)test&#123; NSLog(@&quot;sssss&quot;);&#125;@end@implementation MyStaticLib (Cate)/** * 重写方法 */+ (void)test&#123; NSLog(@&quot;哈哈哈&quot;);&#125;@end 静态库中分类重写了方法，导入工程中，设置 -Objc 参数将打印：哈哈哈；不设置将打印：sssss。 －all_load 会让链接器把所有找到的目标文件都加载到可执行文件中，即使没有 objc 代码。但是这个参数也有一个弊端，假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到 ld: duplicate symbol 错误，因为不同的库文件里面可能会有相同的目标文件，有两种方法解决：1、用命令行进行拆包；2、使用 -force_load 参数。 -force_load 适用于 Xcode3.2+ 版本，它允许 finer 得到文档加载的控制，所做的事情跟 -all_load 其实是一样的，但是每一个 -force_load 操作必须跟着一个文档路径，文档中的每一个对象文件将会被加载，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。 -lstdc++ OC 和 C++ 混编时，在 Compile 阶段一切顺利，Clang 会根据后缀（.m .cpp）选择编译器进行编译，产物都是 Object File（.o 文件）。如果一个文件调用另一个文件的方法，编译出的 Object File 中会出现 undefined symbol 去代表这个方法。在链接阶段，Linker 通过把依赖的文件也加到最终的 executable 中 resolve undefined symbol。 Linker 没有主动的去 link stdc++ 库，解决方案 1：在 Other Linker Flags 中新增标志 -lstdc++；解决方案2：在 Linked Framework and Libraries 中添加 libstdc++.tbd。 总结： 建议 -ObjC 与 -force_load 搭配使用比较好。 包含静态库时需要在 Target 的 Other linker flags 里面加上值：-objC、-all_load、-force_load 对于 64 位机器和 iPhone O S应用，解决方法是使用 -all_load 或者 -force_load。 文章： Xcode 中 other linker flags 的作用 当我们在设置 Other Linker Flags -lstdc++时，我们到底在设置什么？","tags":[]},{"title":"算法设计策略","date":"2019-08-05T16:07:52.660Z","path":"2019/08/06/算法/算法设计策略/","text":"一、分治1.1 基本思想 将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，分而治之。 能用分治法的基本特征： ①、问题缩小到一定规模容易解决 ②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想） ③、分解而成的小问题在解决之后要可以合并 ④、子问题是相互独立的，即子问题之间没有公共的子问题 第 ③ 条是能分治的关键。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。#### 1.2 分治步骤①、分解成很多子问题②、解决这些子问题③、将解决的子问题合并从而解决整个大问题化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。它的一般的算法设计模式如下：Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将 P 分解为较小的子问题 P1, P2, …, Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi6. T ← MERGE(y1,y2,…,yk) △ 合并子问题7. return(T)#### 1.3 分类根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形：1. 原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可；2. 原始问题的解需要由各个子问题的解再经过综合处理得到。#### 1.4 效果适当运用分治策略往往可以较快地缩小问题求解的范围，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好符合递归的特性。因此，计算机算法中的分治策略往往与递归联系在一起。#### 1.5 算法的典型应用 ①、MAXMIN问题 ②、二分搜索 ③、归并排序 ④、寻找第 K 小的元素 ⑤、大整数的乘法 ⑥、Strassen 矩阵乘法 ⑦、快速排序 ⑧、二叉树遍历 ⑨、棋盘覆盖 ⑩、线性时间选择最接近点对问题循环赛日程表汉诺塔。。。#### 1.6 依据分治法设计程序时的思维过程实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。①、一定是先找到最小问题规模时的求解方法；②、然后考虑随着问题规模增大时的求解方法；③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。文章：分治算法详解## 二、减治#### 2.1 基本思想减治技术利用了一种关系：一个问题给定实例的解和同样问题较小实例的解之间的关系。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡）有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫增量法。一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。#### 2.2 分类减治法有 3 种主要的变种：1. 减去一个常量2. 减去一个常数因子3. 减去的规模是可变的#### 2.3 减去一个常量每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。函数 f(n) = an 可以用一递归定义来计算f(n) = f(n-1) * a 如果 n &gt; 1 f(n) = a 如果 n = 1 虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！ 2.4 减去常量因子每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。 计算 an 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 an/2 的值；它们之间有着明显的关系： an = (an/2)2。 an = (an/2)2 n 是正偶数 an = (a(n-1)/2)2 * a n 是大于 1 的奇数，先提出一个 a 来再减半 an = a n = 1 上式递归根据所做的乘法次数来度量效率，该算法属于 O(log n); 因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。 2.5 减可变规模每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法 2.6 算法思想的典型应用减去一个常量： ①、插入排序 ③、深度优先查找 ④、广度优先查找 ⑤、拓扑排序（源删除法对无环有向图进行拓扑排序） ⑥、生成排列 ⑦、生成子集 减去常量因子： ①、折半查找 ②、假币问题 ③、俄式乘法 ④、约瑟夫斯问题 减可变规模 ①、插值查找、二叉查找树 ②、欧几里得算法，随着不断求余，n 越来越小 三、分治减治区别分治法：求解多个子问题（每个子问题都需要求解），合并子问题的解。 减治法：求解一个子问题（子问题只需要求解一次），扩展子问题的解。 求 an。 分治法：a(n/2) * a(n/2) 则左右两个 a(n/2) 均需要求解，所以时间复杂度为 O(n)。减治法：(a(n/2))2 则只需要求 a(n/2) 再平方即可，所以时间复杂度为 O(lgn)。 也就是说分治法是分解的部分需要进行分开的单独计算（需要计算两遍），而减治法则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量。 四、变治基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据对问题实例的变换方式，变治思想有 3 种主要类型： 变换为同样问题的一个更简单或者更方便的实例：实例化简； 变换为同样实例的不同表现：改变表现； 变换为另一个问题的实例， 这种问题的算法是已知的：问题化简。 基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。 4.1 实例化简①、检验数组中元素的唯一性（预排序） ②、模式计算（预排序） ③、AVL 树 4.2 改变表现①、2-3 树、2-3-4 树（二叉排序树） ②、堆和堆排序（利用最大/小堆总是找到最大/小值） ③、霍纳法则（多项式的计算） ④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组） 4.3 问题化简①、背包问题（线性规划） 五、动态规划将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往不是相互独立的。这种情况下若用分治法会对一些子问题进行多次求解，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。 动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质： 最优子结构性质 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。 子问题重叠性质 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。 用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法： ①、自底向上递归法 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。 ②、自顶向下递归法（即备忘录法） 利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。 当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。 文章：动态规划：从新手到专家 六、贪心当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单更直接效率更高的算法：贪心法。 贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。 贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质： 贪心选择性质 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。 最优子结构性质 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。 贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。 七、回溯回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。 回溯法通常的解题步骤如下： ①、定义问题的解空间。 ②、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。 ③、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。 用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h) 用回溯法解题时，常会遇到以下两类典型的解空间树： (1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 0-1背包问题 (2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 回溯法解旅行推销员问题 回溯法中的剪枝函数通常分为两类： (1)、用约束函数在指定节点处剪去不满足约束的子树，例如 0-1背包问题 (2)、用限界函数在指定节点处剪去得不到最优解的子树，例如回溯法解旅行推销员问题 八、分支限界回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。 分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。 九、学习文章姚来飞的博客 &amp; 常见的算法设计策略 算法设计之五大常用算法设计方法总结","tags":[]},{"title":"重构 AppDelegate","date":"2019-08-05T16:07:52.660Z","path":"2019/08/06/iOS/iOS优化/重构AppDelegate/","text":"一、Massive AppDelegate AppDelegate 是应用程序的根对象，它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互，通常被认为是每个 iOS 项目的核心。 随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。 在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持 AppDelegate 的简洁和清晰对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。 AppDelegate 常见的业务代码如下： 日志埋点统计数据分析 初始化数据存储系统 配置 UIAppearance 管理 App Badge 数字 管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分 管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换 管理 UserDefaults：设置首先启动标志，保存和加载数据 管理后台任务 管理设备方向 更新位置信息 初始化第三方库（如分享、日志、第三方登陆、支付） 这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。 看看以下可能的解决方案，每个 Recipe（方案）遵循单一职责、易于扩展、易于测试原则。 二、命令模式 Command Design Pattern 命令模式是一种数据驱动的设计模式，属于行为型模式。 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。 可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。 123456789101112131415161718192021/// 命令协议@protocol Command &lt;NSObject&gt;- (void)execute;@end/// 初始化第三方库@interface InitializeThirdPartiesCommand : NSObject &lt;Command&gt;@end/// 初始化主视图@interface InitializeRootViewControllerCommand : NSObject &lt;Command&gt;@property (nonatomic, strong) UIWindow * keyWindow;@end/// 初始化视图全局配置@interface InitializeAppearanceCommand : NSObject &lt;Command&gt;@end/// ... 然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。 1234567891011@implementation StartupCommandsBuilder// 返回数组，元素为遵守 Command 协议的对象- (NSArray&lt;id&lt;Command&gt;&gt; *)build&#123; return @[ [InitializeAppearanceCommand new], [InitializeRootViewControllerCommand new], [InitializeThirdPartiesCommand new] ];&#125;@end 12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(id&lt;Command&gt; _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [obj execute]; &#125;]; return YES;&#125; 如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。 三、组合设计模式 Composite Design Pattern 组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。 这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。 12345678910111213141516171819202122/// 组装类@interface CompositeAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;+ (instancetype)makeDefault;@end@implementation CompositeAppDelegate+ (instancetype)makeDefault&#123; // 这里要实现单例 return [[CompositeAppDelegate alloc] init];&#125;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125;@end 实现执行具体职责的叶子类。 12345678910111213141516171819202122232425262728293031323334/// 叶子类。推送消息处理@interface PushNotificationAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end/// 叶子类。初始化第三方库@interface ThirdPartiesConfiguratorAppDelegate : UIResponder &lt;UIApplicationDelegate&gt;@end@implementation PushNotificationAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"PushNotificationAppDelegate\"); return YES;&#125;@end@implementation ThirdPartiesConfiguratorAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; NSLog(@\"ThirdPartiesConfiguratorAppDelegate\"); return YES;&#125;@end 在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions]; return YES;&#125; 它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。 四、中介者模式 Mediator Design Pattern 中介者模式是用来降低多个对象和类之间的通信复杂性。 这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末给出关于设计模式比较经典的书籍。 让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@interface APPLifeCycleMediator : NSObject+ (instancetype)makeDefaultMediator;@end@implementation APPLifeCycleMediator&#123; @private NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; * _listeners;&#125;- (void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125;- (instancetype)initWithListeners:(NSArray&lt;id&lt;AppLifeCycleListener&gt;&gt; *)listeners&#123; if (self = [super init]) &#123; _listeners = listeners; // 通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidEnterBackgroud) name:UIApplicationDidEnterBackgroundNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAppDidFinishLaunching) name:UIApplicationDidFinishLaunchingNotification object:nil]; &#125; return self;&#125;/// 定义好静态类方法，初始化所有监听者+ (instancetype)makeDefaultMediator&#123; static APPLifeCycleMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]]; &#125;); return mediator;&#125;- (void)onAppWillEnterForeground&#123; [_listeners[1] onAppWillEnterForeground];&#125;- (void)onAppDidEnterBackgroud&#123; [_listeners[0] onAppDidEnterBackgroud];&#125;- (void)onAppDidFinishLaunching&#123;&#125;@end 定义 AppLifecycleListener 协议，以及协议的的实现者。 123456789101112131415161718192021222324252627282930313233343536/// 监听协议@protocol AppLifeCycleListener &lt;NSObject&gt;@optional- (void)onAppWillEnterForeground;- (void)onAppDidEnterBackgroud;- (void)onAppDidFinishLaunching;@end@interface VideoListener : NSObject &lt;AppLifeCycleListener&gt;@end@interface SocketListener : NSObject &lt;AppLifeCycleListener&gt;@end@implementation VideoListener- (void)onAppDidEnterBackgroud&#123; NSLog(@\"停止视频播放\");&#125;@end@implementation SocketListener- (void)onAppWillEnterForeground&#123; NSLog(@\"开启长链接\");&#125;@end 加入到 AppDelegate 中 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [APPLifeCycleMediator makeDefaultMediator]; return YES;&#125; 这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。 五、总结大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。 通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。 这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。 六、学习文章最佳实践：重构AppDelegate Refactoring Massive App Delegate iOSTips OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》 Swift 设计模式：《Design_Patterns_by_Tutorials_v0.9.1》 重构：《重构改善既有代码的设计》","tags":[]},{"title":"简单算法","date":"2019-08-05T16:07:52.659Z","path":"2019/08/06/算法/简单算法/","text":"1、交换 A 和 B1234567891011121314151617181920212223// 1.中间变量void swap1(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;// 2.加法void swap2(int a, int b) &#123; a = a + b; b = a - b; a = a - b; &#125;// 3.异或（相同为0，不同为1）void swap3(int a, int b) &#123; a = a ^ b; b = a ^ b; a = a ^ b;&#125; 2、求最大公约数123456789101112131415161718192021222324/** 1.直接遍历法 */int maxCommonDivisor(int a, int b) &#123; int max = 0; for (int i = 1; i &lt;= b; i++) &#123; if (a % i == 0 &amp;&amp; b % i == 0) &#123; max = i; &#125; &#125; return max;&#125;/** 2.辗转相除法 */int maxCommonDivisor(int a, int b) &#123; int r; while(a % b &gt; 0) &#123; r = a % b; a = b; b = r; &#125; return b;&#125;// 扩展：最小公倍数 = (a * b)/最大公约数 3、文章iOS开发_小迷糊 &amp; iOS面试题：算法与数据结构","tags":[]},{"title":"第 k 小的数","date":"2019-08-05T16:07:52.659Z","path":"2019/08/06/算法/第 k 小的数/","text":"一、寻找两个有序数组的中位数1、问题描述给定两个大小为 m 和 n 的不同时为空的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 2、算法分析题目要求的时间复杂度是 O(log(m + n))，要产生这样级别的时间复杂度只有采用二分查找法，用分治递归的思路来考虑这个问题。 需要转换题目中求中位数的问题为求第 k 小数的问题。如果 m + n 是奇数，那么寻找第 k = (m + n)/2 + 1 小的数即可；如果长度和是偶数，那么我们还需要寻找第 (m + n)/2 小的数，然后计算两数的平均值。 在求解整个问题的过程中，我们始终需要考虑一个很重要的问题–数组索引越界问题。 下面将详细地分析整个递归流程。 ①、首先定义递归函数的作用：寻找两个有序数组 nums1 数组中 [L1, R1] 范围内和 nums2 数组 [L2, R2] 范围内第 k 小的数，k 从 1开始计数。 12345678/** * L1 nums1数组的寻找范围的左边界 * R1 nums1数组的寻找范围的右边界 * L2 nums2数组的寻找范围的左边界 * R2 nums2数组的寻找范围的右边界 * k 需要寻找第k小的元素 */int findKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k) ②、用 len1 = R1 - L1 + 1 来记录 nums1 数组中寻找范围的长度，用 len2 = R2 - L2 + 1 来记录 nums2 数组中寻找范围的长度。 ③、如果要寻找的 k &gt; len1 + len2，就像只有 3 个数字要找第 4 小的数一样，超出寻找区域，显然无法找到。 ④、递归的终止条件： 当 len1 = 0 时，说明只有 nums2 数组中有元素，直接取 nums2[L2 + k - 1] 位元素即可。 当 k = 1 时，说明要取的是两个有序数组中的最小值 MIN(nums1[L1], nums2[L2])。 ⑤、递归过程： 由于要求的是第 k 小的数，而且是在两个有序数组中求。划分两个数组时按照 k 值来分。取变量 i = MIN(len1, k/2)，之所以这么取，是为了防止 L1 + k/2 - 1 &gt; len1 导致从 nums1 取值越界。再取变量 j = MIN(len2, k/2)。 接下来比较 nums1[L1 + i - 1] 和 nums2[L2 + i - 1] 这两个值。 如果 nums1[L1 + i - 1] &lt;= nums2[L2 + j - 1]，显然 nums1 数组中索引为 L1 + i - 1 及之前的元素不可能是中位数，去除 nums1 数组中 [L1, L1 + i - 1] 范围内的元素，缩小了查找范围。我们递归调用该函数，此时在 nums1 中的查找范围变成了 nums1[L1 + i, R1]，此时要找的也不应该是第 k 小的元素，因为已经剔除了 i 个比 k 小的元素，因此我们要找的元素变成了第 k - i 小的元素。 如果 nums1[L1 + i - 1] &gt; nums2[L2 + j - 1]，同理，nums2 数组中索引为 L2 + j - 1 及之前的元素不可能是中位数，缩小查找范围，剔除了 j 个比 k 小的元素，因此我们要找的元素变成了第 k - j 小的元素。 因为 i + j = MIN(len1, k/2) + MIN(len2, k/2) &lt;= k，所以可以直接判断 [L1, L1 + i - 1] 或者 [L2, L2 + j -1] 区间的元素不可能是中位数。 总结：算法的思想是不断的剔除数据，逐渐逼近第 k 小的数。 3、时间复杂度假设数组长度足够长，每次剔除的元素都是 k/2(i 或者j)，显然我们需要 log(k) 次才能找到第 k 小数，这和二分查找法是同理的，而我们要找的 k 值要么是 (m + n)/2 + 1，要么额外再加上 (m + n)/2，因此时间复杂度是 O(log(m + n)) 级别的。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define MIN(a, b) (a) &lt; (b) ? (a) : (b)int findKth(int* nums1, int left1, int right1, int* nums2, int left2, int right2, int k)&#123; int n1 = right1 - left1 + 1; int n2 = right2 - left2 + 1; // 递归退出条件 if(k &gt; n1 + n2) &#123; return 0; // 实际上 k 不会小于 n1 + n2 &#125; if(n1 == 0) &#123; return nums2[left2 + k - 1]; &#125; else if (n2 == 0) &#123; return nums1[left1 + k - 1]; &#125; if(k == 1) &#123; return MIN(nums1[left1], nums2[left2]); &#125; int i = MIN(n1, k / 2); int j = MIN(n2, k / 2); // 剔除比第 k 小的数还小的数，逐渐逼近 if(nums1[left1 + i - 1] &gt; nums2[left2 + j - 1]) &#123; return findKth(nums1, left1, right1, nums2, left2 + j, right2, k - j); &#125; else &#123; return findKth(nums1, left1 + i, right1, nums2, left2, right2, k - i); &#125;&#125;double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size)&#123; // k = (nums1Size + nums2Size) /2 + 1，因为 k 从 1 开始计数 int mid1 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2 + 1); // 两个数组总长度是奇数 if((nums1Size + nums2Size) % 2 != 0) &#123; return mid1; &#125; // 两个数组总长度是偶数 else &#123; // 额外求 (nums1Size + nums2Size) / 2 的值 int mid2 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2); return (mid1 + mid2) / 2.0; &#125;&#125; 二、文章LeetCode004——两个排序数组的中位数","tags":[]},{"title":"爬楼梯","date":"2019-08-05T16:07:52.658Z","path":"2019/08/06/算法/爬楼梯/","text":"原文：漫画：什么是动态规划？ 1、问题描述有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法。 2、算法分析从简单的分析，要到第 10 级台阶，有多少种方法？要么从 9 级跨 1 级，要么从 8 级跨 1 级。 记 10 级台阶的状态为 f(10)，9 级台阶的状态为 f(9)，8 级台阶的状态为 f(8)，那么 f(10) = f(9) + f(8)。 f(9) = f(8) + f(7)…f(2) = 2f(1) = 1 f(8)、f(9) 是 f(10) 的【最优子结构】；f(1)、f(2) 是【边界】；f(n) = f(n-1) + f(n-2) 是【状态转移方程】。 3、代码实现①、递归 123456int getClimbingWays(int n)&#123; if (n &lt; 3) return n; return getClimbingWays(n - 1) + getClimbingWays(n - 2);&#125; 递归调用的执行过程和一颗二叉树一样，所以它的时间复杂度就是叶子节点数。 时间复杂度：O(2n) ②、备忘录算法 递归方法中会重复计算相同的值，如图中的 f(n-3)。用缓存，先创建一个哈希表，每次把不同参数的计算结果存入哈希。当遇到相同参数时，再从哈希表里去除，避免重复计算。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int getClimbingWays(int n, int* hashMap)&#123; if (n &lt; 3) return n; // 没有缓存 if (hashMap[n] == 0) &#123; int value = getClimbingWays(n - 1, hashMap) + getClimbingWays(n - 2, hashMap); hashMap[n] = value; &#125; return hashMap[n];&#125;int main()&#123; int n = 10; int* hashMap = (int *)calloc(n, sizeof(int)); printf(\"%d\", getClimbingWays(n, hashMap)); return 0;&#125; 时间复杂度：O(n) 空间复杂度：O(n) ③、动态规划法 12345678910111213141516int getClimbingWays(int n)&#123; if (n &lt; 3) return n; int a = 1; int b = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) &#123; sum = a + b; a = b; b = sum; &#125; return sum;&#125; 时间复杂度：O(n) 空间复杂度：O(1)","tags":[]},{"title":"硬币问题","date":"2019-08-05T16:07:52.658Z","path":"2019/08/06/算法/硬币问题/","text":"1、问题描述假设有 1 元、3 元、5 元的硬币无限个，现在需要凑出 11 元，问如何组合才能使硬币的数量最少？ 2、算法分析有最小单位 1 的情况下，可以使用贪心算法： 123456789NSInteger count = m / 5;NSInteger mol = m % 5; if(mol/3 &gt; 0) &#123; count++; mol %= 3;&#125; count += mol; 但当硬币的种类改变，并且需要凑出的总价值变大时，很难靠简单的计算得出结果。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。 这里运用动态规划的思路解决该问题。动态规划中有三个重要的元素：最优子结构、边界、状态转移公式。按照一般思路，先从最基本的情况来一步一步地推导。 注意：动态规划的策略在于当前的硬币（或其他物品）是否能算进去。 先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量。 当 i = 0 时，很显然知道 d(0) = 0。 当 i = 1 时，因为有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = d(0) + 1。 当 i = 2 时，因为并没有 2 元的硬币，所以在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = d(1) + 1。 当 i = 3 时，需要 3 个 1 元硬币或者 1 个 3 元硬币，d(3) = min{ d(2)+1, d(3-3)+1 }; … 抽离出来 d(i) = min{ d(i-1)+1, d(i-vj)+1 }，其中 i - vj &gt;= 0，vj 表示第 j 个硬币的面值。 这里 d(i-1)+1 和 d(i-vj)+1 是 d(i) 的最优子结构；d(0) = 0 是边界；d(i) = min{ d(i-1)+1, d(i-vj)+1 } 是状态转移公式。其实我们根据边界 + 状态转移公式就能得到最终动态规划的结果。 3、算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Coins 3int dp(int n)&#123; // min 数组包含 d(0)~d(n)，所以数组长度是 n+1 n++; // 初始化数组 int* min = (int*)calloc(n, sizeof(int)); // 可选硬币种类 int v[Coins] = &#123; 1, 3, 5 &#125;; for (int i = 1; i &lt; n; i++) &#123; min[i] = min[i-1] + 1; for (int j = 0; j &lt; Coins; j++) &#123; // 装不下 if (v[j] &gt; i) &#123; break; &#125; // 装得下 if (min[i - v[j]] &lt; min[i - 1]) &#123; min[i] = min[i - v[j]] + 1; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf(\"%d \", min[i]); &#125; return min[n - 1];&#125;int main()&#123; printf(\"\\n%d\", dp(101)); return 0;&#125; 4、拓展上面的问题中包含了最小单位 1 元的硬币，所以每次 i 增加时，都能 min[i] = min[i - 1] + 1（+1 是用了 1 元硬币），但如果硬币为 2 元、3 元、5 元呢？应该如何求出 11 元呢？ 来推算下： ①、n = 1，不存在 1 元硬币，且 2、3、5 &gt; 1，所以 f(1) = 0; ②、n = 2，存在 2 元硬币，所以 f(2) = 1; ③、n = 3，存在 3 元硬币，所以 f(3) = 1; ④、n = 4，不存在 4 元硬币，而 2 和3 &lt; 4，5 &gt; 4，其中 f(4-3) = f(1) = 0 说明在去除 3 元的情况下，不能获得剩下的 1 元； f(4-2) = f(2) = 1 说明在去除2 元的情况下，可以获得剩下的2 元，f(4) = f(2) + 1 = 2; 结合上面两种情况 f(4) = MIN{ f(4-2) + 1 } ⑤、n = 5，存在 5 元硬币，所以 f(5) = 1; ⑥、n = 6，不存在 6元硬币，而 2、3、5 &lt; 6，其中 f(6-5) = f(1) = 0 说明在去除 5 元的情况下，不能获得剩下的 1 元； f(6-3) = f(3) = 1 说明在去除 3 元的情况下，可以获得剩下的 3 元，f(6) = f(6-3) + 1 = 2; f(6-2) = f(4) = 2 说明在去除 2 元的情况下，可以获得剩下的 3 元，f(6) = f(6-4) + 1 = 3; 结合上面三种情况 f(6) = MIN{ f(6-3) + 1, f(6-2) + 1 } 【状态】是 f(n) 【边界】是 n = 2、3、5 时只有一种选择 【状态转移方程】是 f(n) = MIN{ f(n - ci) +1 }, 其中 n 表示当前的总额，ci 表示金币数额。 注意：因为是取最小值，所以是无法获得的总额时，如 f(1)，应该让 f(1)等于很大的值，这样就可以将它剔除出去。 下面的代码为了直观每次选币的过程，增加了结构体、打印代码，不需要时可以自行删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Coins 3#define MIN(a, b) (a) &lt; (b) ? (a) : (b)typedef struct CoinLog &#123; int minCoin; // 最少的硬币数 int coin[100]; // 所选硬币&#125; CoinLog;int dp(int n)&#123; n++; // result 数组包含 d(0)~d(n)，所以数组长度是 n+1 // 初始化数组// int* result = (int*)malloc(sizeof(int) * n);// for (int i = 0; i &lt; n; i++) &#123;// result[i] = n;// &#125; CoinLog* result = (CoinLog *)malloc(sizeof(CoinLog) * n); for (int i = 0; i &lt; n; i++) &#123; CoinLog log = &#123; n, &#123;0&#125; &#125;; result[i] = log; &#125; // 硬币种类 int v[Coins] = &#123; 2, 3, 5 &#125;; for (int i = 1; i &lt; n; i++) &#123; printf(\"%3d =\", i); for (int j = 0; j &lt; Coins; j++) &#123; // 硬币正好 if (v[j] == i) &#123; result[i].minCoin = 1; result[i].coin[0] = v[j]; &#125; // 硬币太大 else if (v[j] &gt; i) &#123; &#125; // 循环 Coins，找出最少的币数 else if (result[i - v[j]].minCoin &lt; result[i].minCoin) &#123; result[i].minCoin = result[i - v[j]].minCoin + 1; int k = 0; for (; k &lt; result[i - v[j]].minCoin; k++) &#123; result[i].coin[k] = result[i - v[j]].coin[k]; &#125; result[i].coin[k] = v[j]; &#125; &#125; if (result[i].minCoin &lt; n) &#123; // 显示每次怎么找的 for (int k = 0; k &lt; result[i].minCoin; k++) &#123; printf(\"%3d \", result[i].coin[k]); &#125; &#125; printf(\"\\n\"); &#125; // for (int i = 1; i &lt; n; i++) &#123;// printf(\"%d \", result[i]);// &#125; return result[n - 1].minCoin;&#125;int main()&#123; printf(\"\\n最少的币数 = %d\", dp(21)); return 0;&#125; 1 = 2 = 2 3 = 3 4 = 2 2 5 = 5 6 = 3 3 7 = 2 5 8 = 3 5 9 = 2 2 5 10 = 5 5 11 = 3 3 5 12 = 2 5 5 13 = 3 5 5 14 = 2 2 5 5 15 = 5 5 5 16 = 3 3 5 5 17 = 2 5 5 5 18 = 3 5 5 5 19 = 2 2 5 5 5 20 = 5 5 5 5 21 = 3 3 5 5 5 最少的币数 = 5","tags":[]},{"title":"汉诺塔","date":"2019-08-05T16:07:52.657Z","path":"2019/08/06/算法/汉诺塔/","text":"学习文章：汉诺塔 1、问题描述在三根柱子之间一次只能移动一个圆盘，在小圆盘上不能放大圆盘。 2、算法分析依据分治的策略，将问题化简为两个圆盘，三根柱子 A、B、C，首先解决倒数第二个圆盘的移动，将 n - 1（小盘） 从 A 移到 B，然后将 n（大盘） 从 A 移到 C，再将小盘从 B 移到 C。 子问题分别为：小盘和大盘的移动。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define num 5static int a[num] = &#123; 1, 2, 3, 4, 5 &#125;; // 1 - 最小的物品 5 - 最大的物品static int b[num] = &#123; 0 &#125;; // 0 - 为空static int c[num] = &#123; 0 &#125;; // 0 - 为空static int idxA = 0; // 当前有物品的下标static int idxB = num;static int idxC = num;/// 定义 move 函数，移动物品void move(char from, char to)&#123; int x = 0; printf(\"%c -&gt; %c\\n\", from, to); // 移出 if (from == 'A' &amp;&amp; idxA &gt; -1 &amp;&amp; idxA &lt; num) &#123; x = a[idxA]; a[idxA] = 0; idxA++; &#125; else if (from == 'B' &amp;&amp; idxB &gt; -1 &amp;&amp; idxB &lt; num) &#123; x = b[idxB]; b[idxB] = 0; idxB++; &#125; else if (from == 'C' &amp;&amp; idxC &gt; -1 &amp;&amp; idxC &lt; num) &#123; x = c[idxC]; c[idxC] = 0; idxC++; &#125; else &#123; printf(\"%c from 数组越界！\", from); return; &#125; // 存入 if (to == 'A' &amp;&amp; --idxA &gt; -1 &amp;&amp; idxA &lt; num) &#123; a[idxA] = x; &#125; else if (to == 'B' &amp;&amp; --idxB &gt; -1 &amp;&amp; idxB &lt; num) &#123; b[idxB] = x; &#125; else if (to == 'C' &amp;&amp; --idxC &gt; -1 &amp;&amp; idxC &lt; num)&#123; c[idxC] = x; &#125; else &#123; printf(\"%c to 数组越界！\", to); return; &#125; // 打印移动后结果 for (int i = 0; i &lt; num; i++) &#123; printf(\"%d %d %d\\n\", a[i], b[i], c[i]); &#125; printf(\"\\n\");&#125;/// 将 n 个物品从 one 座借助 two 座，移到 three 座void hanoi(int n, char one, char two, char three)&#123; if(n == 1) &#123; move(one, three); // 只有一个物品，直接移动 &#125; else &#123; hanoi(n-1, one, three, two); //首先把 n - 1 个从 one 移动到 two move(one, three); // 然后把最后一个 n 从 one 移动到 three hanoi(n-1, two, one, three); // 最后再把 n - 1 个从 two 移动到 three &#125;&#125;int main()&#123; hanoi(num, 'A', 'B', 'C'); return 0;&#125;A -&gt; C0 0 02 0 03 0 04 0 05 0 1A -&gt; B0 0 00 0 03 0 04 0 05 2 1C -&gt; B0 0 00 0 03 0 04 1 05 2 0A -&gt; C0 0 00 0 00 0 04 1 05 2 3B -&gt; A0 0 00 0 01 0 04 0 05 2 3B -&gt; C0 0 00 0 01 0 04 0 25 0 3A -&gt; C0 0 00 0 00 0 14 0 25 0 3A -&gt; B0 0 00 0 00 0 10 0 25 4 3C -&gt; B0 0 00 0 00 0 00 1 25 4 3C -&gt; A0 0 00 0 00 0 02 1 05 4 3B -&gt; A0 0 00 0 01 0 02 0 05 4 3C -&gt; B0 0 00 0 01 0 02 3 05 4 0A -&gt; C0 0 00 0 00 0 02 3 05 4 1A -&gt; B0 0 00 0 00 2 00 3 05 4 1C -&gt; B0 0 00 1 00 2 00 3 05 4 0A -&gt; C0 0 00 1 00 2 00 3 00 4 5B -&gt; A0 0 00 0 00 2 00 3 01 4 5B -&gt; C0 0 00 0 00 0 00 3 21 4 5A -&gt; C0 0 00 0 00 0 10 3 20 4 5B -&gt; A0 0 00 0 00 0 10 0 23 4 5C -&gt; B0 0 00 0 00 0 00 1 23 4 5C -&gt; A0 0 00 0 00 0 02 1 03 4 5B -&gt; A0 0 00 0 01 0 02 0 03 4 5B -&gt; C0 0 00 0 01 0 02 0 43 0 5A -&gt; C0 0 00 0 00 0 12 0 43 0 5A -&gt; B0 0 00 0 00 0 10 0 43 2 5C -&gt; B0 0 00 0 00 0 00 1 43 2 5A -&gt; C0 0 00 0 00 0 30 1 40 2 5B -&gt; A0 0 00 0 00 0 30 0 41 2 5B -&gt; C0 0 00 0 20 0 30 0 41 0 5A -&gt; C0 0 10 0 20 0 30 0 40 0 5","tags":[]},{"title":"消息转发","date":"2019-08-05T16:07:52.657Z","path":"2019/08/06/iOS/iOS原理/消息转发/","text":"一、前言在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现 unrecognized selector sent to instance，导致应用 crash 的情况。 针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 NullSafe。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。 消息转发的整个过程主要涉及的 3 个方法： 123+(BOOL)resolveInstanceMethod:(SEL)sel;-(id)forwardingTargetForSelector:(SEL)aSelector;-(void)forwardInvocation:(NSInvocation*)anInvocation; 其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。 二、消息转发过程首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。 下边分析消息转发的过程，以 [MyObjet Length] 为例： ①、首先 MyObjet 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。 ②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。 ③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。 三、结合 MyObject 中的代码对消息转发流程进一步分析①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下： 12345678910111213+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; printf(\"%s:%s \\n\", __func__ ,NSStringFromSelector(sel).UTF8String); if (sel == @selector(length)) &#123; BOOL success = class_addMethod([self class], sel, (IMP)(length), \"q@:\"); if (success) &#123; return success; &#125; &#125; return [super resolveInstanceMethod:sel];&#125; 传入的 “q@:” 分别代表： 123q : 返回值 long long@ : 调用方法的的实例为对象类型: : 表示方法 下图表示了编码类型。 ②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下： 12345678910111213141516171819202122232425262728293031323334353637static NSArray * respondClasses;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; printf(\"%s:%s \\n\", __func__ , NSStringFromSelector(aSelector).UTF8String); id forwardTarget = [super forwardingTargetForSelector:aSelector]; if (forwardTarget) &#123; return forwardTarget; &#125; Class someClass = [self myResponedClassForSelector:aSelector]; if (someClass) &#123; forwardTarget = [someClass new]; &#125; return forwardTarget;&#125;- (Class)myResponedClassForSelector:(SEL)selector&#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; +(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。 ③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation *)anInvocation，这个过程会有一个插曲 -(NSMethodSignature *)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。 -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。 摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。 相关代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; printf(\"%s:%s \\n\\n\\n\\n\", __func__ , NSStringFromSelector(anInvocation.selector).UTF8String); anInvocation.target = nil; [anInvocation invoke];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature *signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; Class responededClass = [self myResponedClassForSelector:selector]; if (responededClass) &#123; @try &#123; signature = [responededClass instanceMethodSignatureForSelector:selector]; &#125; @catch (NSException *exception) &#123; &#125;@finally &#123; &#125; &#125; &#125; return signature;&#125;- (Class)myResponedClassForSelector:(SEL)selector &#123; respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) &#123; if ([someClass instancesRespondToSelector:selector]) &#123; return someClass; &#125; &#125; return nil;&#125; 这里有一个不常用的 API：+(NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。 12345678910111213141516171819202122232425262728293031323334353637&lt;NSMethodSignature: 0x6000030a17c0&gt; number of arguments = 2 frame size = 224 is special struct return? NO return value: -------- -------- -------- -------- type encoding (f) 'f' flags &#123;isFloat&#125; modifiers &#123;&#125; frame &#123;offset = 16, offset adjust = 0, size = 16, size adjust = -12&#125; memory &#123;offset = 0, size = 4&#125; argument 0: -------- -------- -------- -------- type encoding (@) '@' flags &#123;isObject&#125; modifiers &#123;&#125; frame &#123;offset = 0, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125; argument 1: -------- -------- -------- -------- type encoding (:) ':' flags &#123;&#125; modifiers &#123;&#125; frame &#123;offset = 8, offset adjust = 0, size = 8, size adjust = 0&#125; memory &#123;offset = 0, size = 8&#125;``` NSInvocation。仍然以`myObject`调用`length`方法为例。 \\- (void)forwardInvocation:(NSInvocation \\*)anInvocation中的 anInvocation 的信息如下：```objc&lt;NSInvocation: 0x6000025b8140&gt;return value: &#123;Q&#125; 0target: &#123;@&#125; 0x60000322c360selector: &#123;:&#125; length&gt; return value 指返回值，\"Q\" 表示返回值类型为 long long 类型；&gt; target 指的是消息的接收者，\"@\"标识对象类型；&gt; selector 指的是方法，\":\"表示是方法，后边的 length 为方法名。 更多内容可见下图 NSInvocation 的 types： 12345678910111213141516171819enum _NSObjCValueType &#123; NSObjCNoType = 0, NSObjCVoidType = 'v', NSObjCCharType = 'c', NSObjCShortType = 's', NSObjCLongType = 'l', NSObjCLonglongType = 'q', NSObjCFloatType = 'f', NSObjCDoubleType = 'd', NSObjCBoolType = 'B', NSObjCSelectorType = ':', NSObjCObjectType = '@', NSObjCStructType = '&#123;', NSObjCPointerType = '^', NSObjCStringType = '*', NSObjCArrayType = '[', NSObjCUnionType = '(', NSObjCBitfield = 'b'&#125; API_DEPRECATED(\"Not supported\", macos(10.0,10.5), ios(2.0,2.0), watchos(2.0,2.0), tvos(9.0,9.0)); 四、尚存疑点细心的读者可能会发现在首次消息转发的时候流程并不是 123+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length -[MyObject forwardInvocation:]:length 而是 12345+[MyObject resolveInstanceMethod:]:length -[MyObject forwardingTargetForSelector:]:length +[MyObject resolveInstanceMethod:]:length +[MyObject resolveInstanceMethod:]:_forwardStackInvocation: -[MyObject forwardInvocation:]:length 查看了开源源码 NSObject.mm 相关源码如下： 12345678910111213// Replaced by CF (returns an NSMethodSignature)- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];&#125;// Replaced by CF (throws an NSException)- (void)doesNotRecognizeSelector:(SEL)sel &#123; _objc_fatal(&quot;-[%s %s]: unrecognized selector sent to instance %p&quot;, object_getClassName(self), sel_getName(sel), self);&#125; 五、NSNull+QiNullSafe.m根据 NullSafe 仿写的 NSNull+QiNullSafe.m。 NSNull+QiNullSafe.m 能够避免的问题有： NSNull *null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@”aaa”];[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];[null performSelector:@selector(valueForKey:) withObject:@”aaa”];[null performSelector:@selector(length) withObject:nil];[null performSelector:@selector(integerValue) withObject:nil];[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];[null performSelector:@selector(bytes) withObject:nil]; 六、NullSafe 是怎么处理 null 问题其实 NullSafe 处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。 不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。 注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。 七、单元测试1234567891011121314151617181920212223- (void)testStringValue&#123; id null = [NSNull null]; NSString * string = [null stringValue]; XCTAssertNil(string);&#125;- (void)testFloatValue&#123; id null = [NSNull null]; CGFloat f = [null floatValue]; XCTAssertEqualWithAccuracy(f, 0.0f, 0.0f);&#125;- (void)testPerformSelector&#123; NSNull * null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@\"aaa\"];&#125; 八、文章iOS 消息转发 Protocol 协议分发器","tags":[]},{"title":"棋盘覆盖","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/棋盘覆盖/","text":"原文：棋盘覆盖问题、分治法之棋盘覆盖问题 1、问题描述在一个 2k * 2k（k ≥ 0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格，显然，特殊方格在棋盘中出现的位置有 4k 种情形，因而有 4k 种不同的棋盘。 2、算分分析用分治策略。 ①、当 k &gt; 0 时，将 2k * 2k 棋盘分割成 4 个 2k-1 * 2k-1 子棋盘，特殊方格必定只位于某个子棋盘中。 ②、用一个 L 型骨牌覆盖 3 个无特殊方格子棋盘的结合处，由原问题转化成 4 个较小规模的棋盘覆盖子问题。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt;#define max 1024int board[max][max]; // 最大棋盘static int tile = 0; // 覆盖标志位/** * （tr，tc） 棋盘左上角的方格坐标 * （dr，dc） 特殊方格所在的坐标 * size 是棋盘的行数和列数 */void ChessBoard(int tr,int tc,int dr,int dc,int size)&#123; if(size == 1) return; // 递归到棋盘大小为 1 时，则结束递归 int t = tile++; // L型骨牌号 int s = size / 2; // 分割棋盘，使得新得到的棋盘为原来棋盘大小的四分之一 // ①、左上角子棋盘 // 如果特殊方格在左上角，就对这个棋盘左上角的四分之一重新进行棋盘覆盖 if(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123; // 特殊方格在此棋盘中 ChessBoard(tr, tc, dr, dc, s); &#125; // 因为特殊方格不在左上角，所以要在左上角构造一个特殊方格 else &#123; // 用 t 号 L 型骨牌覆盖右下角 board[tr + s - 1][ tc + s - 1] = t; // 在构造完特殊方格之后，棋盘的左上角的四分之一又有了特殊方格，所以就对左上角棋盘的四分之一进行棋盘覆盖，直到棋盘大小为 1 * 1 ChessBoard(tr, tc, tr+s-1, tc+s-1, s); &#125; // ②、右上角子棋盘 if(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123; ChessBoard(tr, tc+s, dr, dc, s); &#125; else &#123; board[tr + s - 1][tc + s] = t; ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); &#125; // ③、左下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123; ChessBoard(tr + s, tc, dr, dc, s); &#125; else &#123; // 用 t 号 L 型骨牌覆盖右上角 board[tr + s][tc + s - 1] = t; ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); &#125; // ④、右下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123; ChessBoard(tr + s, tc + s, dr, dc, s); &#125; else &#123; // 用 t 号 L 型骨牌覆盖左上角 board[tr + s][tc + s] = t; ChessBoard(tr + s, tc + s, tr + s, tc + s, s); &#125;&#125;int main()&#123; int size = 8, dr = 0, dc = 0; printf(\"不可覆盖点的值为 -1！\\n\\n\"); board[dr][dc] = -1; ChessBoard(0, 0, dr, dc, size); for(int m = 0; m &lt; size; m++) &#123; printf(\"%2d\", board[m][0]); for(int n = 1; n &lt; size; n++) &#123; printf(\" %2d\", board[m][n]); &#125; printf(\"\\n\"); &#125; return 0;&#125;不可覆盖点的值为 -1！-1 2 3 3 7 7 8 8 2 2 1 3 7 6 6 8 4 1 1 5 9 9 6 10 4 4 5 5 0 9 10 1012 12 13 0 0 17 18 1812 11 13 13 17 17 16 1814 11 11 15 19 16 16 2014 14 15 15 19 19 20 20","tags":[]},{"title":"构造子集","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/构造子集/","text":"1、问题描述构造出 0~n-1 的所有子集。 2、算法分析一次选出一个元素放入集合。 3、代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define ARRAY_LENGTH 10&#123; int A[ARRAY_LENGTH]; print_subset(ARRAY_LENGTH, A, 0);&#125;void print_subset(int n, int* A, int cur)&#123; // cur:当前位置 printf(\"cur = %d \", cur); // 确定当前元素的最小可能值 int s = cur ? A[cur-1] + 1 : 0; printf(\"s = %d \", s); // 打印当前子集元素。 for(int i = 0; i &lt; cur; i++) &#123; printf(\"%d \", A[i]); &#125; // 每次选出一个元素当子集的首元素, for(int i = s; i &lt; n; i++) &#123; A[cur] = i; // 打印加入元素后的数组 printf(\" after：\"); for(int j = 0; j &lt;= cur; j++) &#123; printf(\"%d \", A[j]); &#125; printf(\"\\n\"); print_subset(n, A, cur + 1); // 递归构造子集 &#125;&#125;cur = 0 s = 0 after：0 cur = 1 s = 1 0 after：0 1 cur = 2 s = 2 0 1 after：0 1 2 cur = 3 s = 3 0 1 2 after：0 1 2 3 cur = 4 s = 4 0 1 2 3 after：0 1 3 cur = 3 s = 4 0 1 3 after：0 2 cur = 2 s = 3 0 2 after：0 2 3 cur = 3 s = 4 0 2 3 after：0 3 cur = 2 s = 4 0 3 after：1 cur = 1 s = 2 1 after：1 2 cur = 2 s = 3 1 2 after：1 2 3 cur = 3 s = 4 1 2 3 after：1 3 cur = 2 s = 4 1 3 after：2 cur = 1 s = 3 2 after：2 3 cur = 2 s = 4 2 3 after：3 cur = 1 s = 4 3","tags":[]},{"title":"第 k 小/大元素","date":"2019-08-05T16:07:52.656Z","path":"2019/08/06/算法/求第 k 小:大元素/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;void swap_t(int a[],int i,int j)&#123; int t=a[i]; a[i]=a[j]; a[j]=t;&#125;int par(int a[],int p,int q)//p是轴,轴前面是比a[p]小的，后面是比a[p]大的&#123; int i=p,x=a[p]; for(int j=p+1;j&lt;=q;j++) &#123; if(a[j]&gt;=x) &#123; i++; swap_t(a,i,j); &#125; &#125; swap_t(a,p,i); return i;//返回轴位置&#125;int Random(int p,int q)//返回p，q之间的随机数&#123; return rand()%(q-p+1)+p;&#125;int Randomizedpar(int a[],int p,int q)&#123; int i=Random(p,q); swap_t(a,p,i);//第一个和第i个交换，相当于有了一个随机基准元素 return par(a,p,q);&#125;int RandomizedSelect(int a[],int p,int r,int k)&#123; if(p==r) return a[p]; int i=Randomizedpar(a,p,r); int j=i-p+1; printf(&quot;i=%d j=%d\\n&quot;,i,j); if(k&lt;=j) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j);&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a[n]; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int x=RandomizedSelect(a,0,n-1,2); printf(&quot;%d\\n&quot;,x);&#125;","tags":[]},{"title":"最长回文子串","date":"2019-08-05T16:07:52.655Z","path":"2019/08/06/算法/最长回文子串/","text":"1、问题描述给定一个字符串 s，找到 s 中最长的回文子串。 2、算法分析大多数问题都可以用暴力法解决。暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。 时间复杂度：O(n3)，假设 n 是输入字符串的长度，则 (n * (n−1))/2​ 为此类子字符串（不包括字符本身是回文的一般解法）的总数。因为验证每个子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n3)。 空间复杂度：O(1)。 为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。 我们给出 P(i,j) 的定义如下： 如果子串 Si...Sj ​是回文子串 p(i, j) = true 其他情况 p(i, j) = false 因此： P(i, j) = ( P(i+1, j-1) and Si​ == Sj​) 基本示例如下： P(i, i) = true P(i, i+1) = (Si ​== Si+1​) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推… 3、复杂度分析 时间复杂度：O(n2)，这里给出我们的运行时间复杂度为 O(n2)。 空间复杂度：O(n2)，该方法使用 O(n2) 的空间来存储表。 4、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char * longestPalindrome(char* s)&#123; if (s == NULL || strlen(s) &lt; 1) &#123; return \"\"; &#125; int n = (int)strlen(s); // 初始化二维数组 int matrix[n][n]; for (int i = 0; i &lt; n; i++) for (int j = 0; j&lt; n; j++) matrix[i][j] = 0; int left = 0; int right = 0; // i 从倒数第二个开始，从右往左。标识子串的起始位置 for (int i = n - 2; i &gt;= 0; i--) &#123; matrix[i][i] = 1; // j 从 i 的下一位开始，从左往右。标识子串的结束位置 for (int j = i + 1; j &lt; n; j++) &#123; // ①、s[i] == s[j] ②、小于或等于 3 个字符 ③、内缩一位是回文子串 matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); // 获得最长的子串位置 if(matrix[i][j] &amp;&amp; right - left &lt; j - i) &#123; left = i; right = j; &#125; for (int m = 0; m &lt; n; m++) &#123; for (int k = 0; k &lt; n; k++) printf(\"%d \", matrix[m][k]); printf(\"\\n\\n\"); &#125; &#125; &#125; char* sub = (char *)malloc(sizeof(char) * (right - left + 1)); int i = 0; for (; i &lt; right - left + 1; i++) &#123; sub[i] = s[left + i]; //strncpy(sub, s+left, right+1); &#125; sub[i] = '\\0'; return sub;&#125;int main()&#123; printf(\"%s\", longestPalindrome(\"aaabaaaa\")); return 0;&#125; 关键代码： matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); 以及 i 和 j 的取值方向","tags":[]},{"title":"最长上升子序列","date":"2019-08-05T16:07:52.655Z","path":"2019/08/06/算法/最长上升子序列/","text":"1、问题描述给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, 3, 4, 8, 6, 7] 返回 4。 2、算法分析面对这个问题，首先要定义一个”状态“来代表它的子问题， 并且找到它的解。 注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。 假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。 这个 d(i) 就是我们要找的状态。 如果我们把 d(1) 到 d(N) 都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。 以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是： 5 3 4 8 6 7 根据上面找到的状态，可以得到： i = 1 的 LIS 长度 d(1) = 1, d[] = {5} i = 2 的 LIS 长度 d(2) = 1, d[] = {3} i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4} i = 4 的 LIS 长度 d(4) = max{ d(1), d(2), d(3) } + 1 = 3, d[] = {3, 4, 8} 状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到： d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A\\[j\\] &lt;= A\\[i\\] 想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。 分析完了，上图。 3、复杂度分析时间复杂度：O(n2) 空间复杂度：O(n) 4、代码实现1234567891011121314151617181920212223242526272829303132int lengthOfLIS(int* nums, int numsSize) &#123; if (numsSize == 0) return 0; int *d = (int *)malloc(sizeof(int) * numsSize); int len = 1; for(int i = 0; i &lt; numsSize; ++i)&#123; d[i] = 1; for(int j = 0; j &lt; i; ++j) // 如果当前的数值 A[i] 大于 它之前的数值 A[j] &amp;&amp; 最长的段 if(nums[j] &lt; nums[i] &amp;&amp; d[j] + 1 &gt; d[i]) d[i] = d[j] + 1; if(d[i] &gt; len) len = d[i]; &#125; free(d); return len;&#125;int main()&#123; int A[] = &#123; 5, 3, 4, 8, 6, 7 &#125;; printf(\"%d\", lengthOfLIS(A, 6)); return 0;&#125; 5、进阶：O(nlogn)算法假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。 定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。注意：B 的索引从 1 开始。 ①、把 d\\[0\\] 有序地放到 B 里，令 B\\[1\\] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。 ②、把 d\\[2\\] 有序地放到 B 里，令 B\\[1\\] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d\\[1\\] = 2 已经没用了，因为 2 &gt; 1。 ③、d\\[3\\] = 5，因为 d\\[3\\] &gt; B\\[1\\]，所以令 B\\[1+1\\] = B\\[2\\] = d\\[3\\] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B\\[\\] = { 1, 5 }。 ④、d\\[4\\] = 3，B\\[1\\] &lt; d\\[3\\] &lt; B\\[2\\]，放在 B\\[1\\] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B\\[\\] = { 1, 3 }。 ⑤、d\\[5\\] = 6，因为 d\\[5\\] &gt; B\\[2\\]，所以令 B\\[2+1\\] = B\\[3\\] = d\\[5\\] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B\\[\\] = { 1, 3, 6 }。 ⑥、d\\[6\\] = 4，3 &lt; d\\[6\\] &lt; 6，于是把 6 替换掉，这时 Len = 3, B\\[\\] = { 1, 3, 4 }。 ⑦、d\\[7\\] = 8，d\\[7\\] &gt; B\\[3\\]，将 8 追加到 B 数组末尾，这时 Len = 4, B\\[\\] = { 1, 3, 4, 8 }。 ⑧、d\\[8\\] = 9，d\\[8\\] &gt; B\\[4\\]，将 9 追加到 B 数组末尾，这时 Len = 5, B\\[\\] = { 1, 3, 4, 8, 9 }。 ⑨、d\\[9\\] = 7，B\\[3\\]=4 &lt; d\\[9\\] &lt; B\\[4\\]=8，所以最新的 B\\[4\\] = 7，这时 Len = 5, B\\[\\] = 1, 3, 4, 7, 9。 注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。 有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。 在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1int upper_bound(int B[], int left, int right, int key)&#123; int mid; // 将 key 插入到数组末尾 if (B[right] &lt; key) return right + 1; // num[left] ≤ key &lt; nums[right] 之后 left 将大于 right，循环结束 while (left &lt; right) &#123; mid = (left + right) / 2; if (B[mid] &lt; key) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125;int lengthOfLIS(int* nums, int numsSize)&#123; if (numsSize &lt; 2) return numsSize; int* B = (int *)malloc(sizeof(int) * (numsSize + 1)); B[0] = 0; // 无意义 B[1] = nums[0]; // 从 1 开始是为了让 len、pos 不需要 -1 或 +1 int len = 1; for (int i = 1; i &lt; numsSize; i++) &#123; // 找到插入位置 int pos = upper_bound(B, 1, len, nums[i]); B[pos] = nums[i]; // 打印 B 数组，看看每次循环的变化，B[0] 无意义 printf(\"%d \", pos); for (int k = 0; k &lt;= pos; k++) &#123; printf(\"%d\", B[k]); &#125; printf(\"\\n\"); if (len &lt; pos) &#123; len = pos; &#125; &#125; return len;&#125;int main()&#123; int A[] = &#123; 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 &#125;; printf(\"%d\", lengthOfLIS(A, 11)); return 0;&#125;","tags":[]},{"title":"整数划分","date":"2019-08-05T16:07:52.654Z","path":"2019/08/06/算法/整数划分/","text":"1、问题描述将一个正整数 n 写成如下形式 n = m1 + m2 + ... + mi; （其中 mi 为正整数，并且 1 &lt;= mi &lt;= n），则 {m1, m2, ..., mi} 为 n 的一个划分。 如果 { m1, m2, …, mi } 中的最大值不超过 m，即 max(m1, m2, …, mi) &lt;= m，则称它属于 n 的一个 m 划分。 算法分析这里记 n 的 m 划分的个数为 f(n, m); 例如当 n = 4 时，有 5 个划分 {4}, {3,1}, {2,2}, {2,1,1}, {1,1,1,1}; 该问题是求出 n 的所有划分个数，即 f(n, n)。下面考虑求 f(n,m) 的方法。 ①、m = 1 || n = 1 只有一种划分情况，即 n 个 1 相加， 所以 f(n, m) = 1; ②、m = n &gt; 1 f(n, m) = f(n, n-1) + 1 加上的 1 代表 n + 0 = n 这个划分方案 ③、n &lt; m f(n, m) = f(n, n) 逻辑上不存在 m &gt; n 的情况 ④、n &gt; m f(n, m) = f(n, m-1) + f(n-m, m); f(n, m-1) 表示划分方案中没有 m 的情况，f(n-m, m) 表示划分方案中有 m 的情况。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;/** * @brief 整数划分问题，将一个整数划分为若干个数相加。例：整数 4，最大加数 4 4 =4 + 0 1+3=4 1+1+2=4 2+2=4 1+1+1+1=4 注意：1+3=4，3+1=4被认为是同一种划分方案 * @param n 需要划分的数字 * @param m 最大的加数 */int algorithm(int n, int m)&#123; if (n == 1 || m == 1) &#123; // 只要存在一个为 1，那么划分的方法数肯定只有一种，那就是 n 个 1 相加 return 1; &#125; else if (n == m &amp;&amp; n &gt; 1) &#123; // 等价于：q(n, n-1) + 1; 最后面 +1 代表的是：0+n，这个划分的方案 return algorithm(n, m - 1) + 1; &#125; else if (n &lt; m) &#123; // 如果 m &gt; n,那么令 m = n，因为最大加数在逻辑上不可能超过 n return algorithm(n, n); &#125; else if (n &gt; m) &#123; // 分为两种：划分方案没有 m 的情况 + 划分方案有 m 的情况 return algorithm(n, m - 1) + algorithm(n - m, m); &#125; return 0;&#125;int main()&#123; int r = algorithm(7, 7); printf(\"%d\\n\", r); return 0;&#125;","tags":[]},{"title":"排序算法","date":"2019-08-05T16:07:52.654Z","path":"2019/08/06/算法/排序算法/","text":"一、冒泡排序1.1 简介冒泡排序是蛮力法在排序问题上的一个典型的应用场景。 对于一个给定长度为 n 的无序数组，由初始位置开始，比较数组相邻两个元素。如果是逆序排列的，就交换它们的位置，重复多次之后，最大数就“沉”到了数组最后的位置。第二次再从初始位置开始，将第二大的元素沉到倒数第二个位置。这样一直做 n-1 次，整个数组就是有序的了。 对于一个长度为 n 的数组，整个算法消耗的时间为：(n-1) + (n-2) + … + 1 = n(n-1)/2，那么它的时间复杂度为 O(n2)。同时，显而易见，整个算法只消耗一份数组的空间，所以空间复杂度为 O(1)。 另外，普及一下排序算法另一个重要的特性：稳定性。 所谓的稳定性，通俗地讲就是能保证两个相等的数在排序前后的顺序相同。 假定原数组有两个相同的元素 Ω，在数组的 a[i] 和 a[j] 位置。排序前 a[i] 在 a[j] 的前面，在排序之后，a[i] 仍然在 a[j] 的前面，那么就说这种排序方法具有稳定性。 冒泡排序是一种稳定排序。 蛮力法的应用有一个显著的特点，就是在经过适当的努力之后，可以对算法进行一定的改良，从而提高它的性能，但并不会减弱算法本身的时间复杂度。冒泡排序作为蛮力法的典型应用，自然也有这种特性。 1.2 改进 设定交换发生的标识位 对于待排序的数组，可以设定一个标志位，检查一次比较之后，是否有数据进行了交换，若是没有，那么整个数组就已经有序了，可以直接退出。极端情况下，如刚才提到的，对有序数组进行排序，只需要执行 n-1 次操作，就可以完成排序。 记录最后一次发生交换的位置 初始排序时，数组是在 [0, n] 区间遍历，那么下一轮的遍历是在 [0, n-1] 区间。 现在记录数组本轮遍历的最后一次交换发生在 lastSwapPos 位置，那么下一轮的遍历实际上是在 [0, lastSwapPos] 区间。 1.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142#define ARRAY_LENGTH 10void bubbleSort(int arr[])&#123; int lastSwapPos = ARRAY_LENGTH - 1; int lastSwapPosTemp = ARRAY_LENGTH - 1; int temp = 0; // ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; for (int j = 0; j &lt; ARRAY_LENGTH - i - 1; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; // ② for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; lastSwapPos = lastSwapPosTemp; for (int j = 0; j &lt; lastSwapPos; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; lastSwapPosTemp = j; &#125; &#125; // 一次都未交换的情况 if (lastSwapPos == lastSwapPosTemp) &#123; break; &#125; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", arr[i]); &#125;&#125; 1.4 总结优点： 空间复杂度 T = O(1) 稳定排序 在排序过程中，整个数组趋向稳定 对于已经有序的数组，排序效率高 缺点： 效率低 交换次数多，交换效率低（每次交换只减少一组逆序对） 不能并发执行 二、选择排序2.1 简介选择排序是蛮力法的一种实际应用。 首先扫描整个数组，找到最小的元素，然后和第一个元素进行交换，如此一来就等同于将最小的元素放到它在有序表中最终的位置上。然后从第二个元素开始扫描整个表，找到剩余 n-1 个元素中最小的元素，与第二个元素交换位置。以此类推，在执行 n-1 遍之后，这个数组就自然有序了。（当然每次找最大的元素，与最后一个元素交换也是可行的） 选择排序有一个最明显的优于冒泡排序的：数据交换的次数。在完全逆序的情况下，冒泡排序需要最多的 n*(n-1)/2 次交换，而选择排序最多产生 n-1 次交换。 选择排序的时间复杂度是 O(n^2)，空间复杂度是 O(1)。 选择排序有一个很重要的特性——它是一种不稳定排序。假定一个数组：[5, 5, 6, 1, 8]，可以很清晰的发现，在选择排序结束之后，两个 5 并不能保持原来的顺序，第一个 5 在第四的位置，第二个 5 还在第二的位置。 2.2 改进每一次外循环的遍历，可以同时找到最小值（minIndex）和最大值（maxIndex），分别和头、尾两个元素进行交换。这样一来外循环只要执行原来一半的循环次数就可以了。 但是需要注意一点：每次循环要进行 2 次交换，第一次最小值交换结束之后，在进行最大值交换的时候要先判断最大值是不是在第一个位置，在第一次最小值交换的时候已经换到了后面。 如 [5, 4, 3, 2, 1] 第一次最小值交换后变成了 [1, 4, 3, 2, 5]，初始记录的 maxIndex = 0 就指向了 1，而不是 5。 2.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define ARRAY_LENGTH 10void selectSort(int arr[])&#123; // 数组内容合法性判断 int minIndex; int maxIndex; // 方式 ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) &#123; minIndex = i; for (int j = i; j &lt; ARRAY_LENGTH; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) &#123; swap(i, minIndex, arr); &#125; &#125; // 方式 ② for (int i = 0; i &lt; ARRAY_LENGTH / 2; i++) &#123; minIndex = i; maxIndex = i; for (int j = i; j &lt; ARRAY_LENGTH - i; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; if (arr[j] &gt; arr[maxIndex]) &#123; maxIndex = j; &#125; &#125; // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) &#123; swap(i, minIndex, arr); &#125; if (ARRAY_LENGTH - 1 - i != maxIndex) &#123; // 防止最大数在第一个，优先和最小数进行交换 swap(ARRAY_LENGTH - 1 - i, (i == maxIndex) ? minIndex : maxIndex, arr); &#125; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", arr[i]); &#125;&#125;void swap(int idx1, int idx2, int arr[]) &#123; int temp = arr[idx1]; arr[idx1] = array[idx2]; arr[idx2] = temp;&#125; 三、直接插入排序3.1 减治法（增量法） 减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。 增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。 减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。 很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式： 减去一个常量。（直接插入排序） 减去一个常量因子。（二分查找法） 减去的规模可变。（辗转相除法） 3.2 直接插入排序直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下： 对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。 考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n - 1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。 很显然，基于增量法的思想在解决这个问题上拥有更高的效率。 直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。 当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序） 直接插入排序的时间复杂度是 O(n2)，空间复杂度是 O(1)，同时也是稳定排序。 3.3 优化 设置哨兵位 仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。 不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：记录上一次插入的值和位置，与当前插入值比较。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。 二分查找法 优化直接插入排序的核心在于：快速定位当前数字待插入的位置。 在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。 这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会打破排序算法的稳定性，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？ 3.4 简单的性能比较 结论： 在某些特定场景下，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。 对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。 大规模数组，二分查找优化效率明显。 3.5 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define ARRAY_LENGTH 10void insertSort(int list[])&#123; // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int j = 0; int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置 // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位 for (j = i - 1; j &gt; -1 &amp;&amp; temp &lt; list[j]; j--) &#123; list[j + 1] = list[j]; &#125; list[j + 1] = temp; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", list[i]); &#125;&#125;// 根据上一次的位置，简化下一次定位static void optimized_1(int array[]) &#123; // 记录上一个插入值的位置和数值 int checkValue = array[0]; int checkIndex = 0; // 循环插入 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int cur = array[i]; int start = i - 1; int j = 0; // 根据上一个值，定位开始遍历的位置 if (cur &lt; checkValue) &#123; start = checkIndex; for (int j = i - 1; j &gt; start - 1; j--) &#123; array[j + 1] = array[j]; &#125; &#125; // 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的 // 循环判断 + 插入 for (j = start; j &gt; -1; j--) &#123; if (cur &lt; array[j]) &#123; array[j + 1] = array[j]; &#125; else &#123; break; &#125; &#125; array[j + 1] = cur; checkValue = cur; checkIndex = j + 1; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", array[i]); &#125;&#125; 四、希尔排序4.1 和直接插入排序的关系希尔排序 Shell sort 是直接插入排序的变种方式之一，更高效的改进版本。其基本思想如下： ①、记录按下标的一定增量分组，对每组进行直接插入排序。 ②、不断地缩小增量，对每组进行直接插入排序，直至增量为 1。 数组：a[33, 13, 44, 21, 88, 8, 17] 增量 d = 3 分组 [33, 21, 17]、[13, 88]、[44, 8] 排序结果：[17, 13, 8, 21, 88, 44, 33] 增量 d = 3/2 = 1 分组 [17, 13, 8, 21, 88, 44, 33] 排序结果：[8, 13, 17, 21, 33, 44, 88] 由上可知，希尔排序本质就是多次使用直接插入排序。其优于直接插入排序的原因在之前也提到过，就是：直接插入排序对于基本有序的数组，拥有较高的性能。 希尔排序的时间复杂度是 O(n2)（只是针对最坏情况而言，平均的效率要远远高出其他时间复杂度为 O(n2) 的排序算法），空间复杂度是 O(1)。 希尔排序在提供优秀性能的同时，打破了排序算法的稳定性。 4.2 希尔排序的实现希尔排序，又称为缩小增量排序，其重点显然在于初始增量 d 的选取，以及每次增量 d 缩小的额度。一般来说，初始增量设为数组长度的一半，同时每次增量减半，直至 d = 1，可以满足大多数的需求。 4.3 优化1、设置哨兵位优化各分组的直接插入排序 2、二分查找法优化各分组的直接插入排序 4.4 简单的性能比较 结论： 直接插入排序的优化手段，对希尔排序没有作用，反而是一种伤害。原因是直接插入排序的优化手段对于小规模的数组是有害的，而希尔排序的原理是将整个数组拆成若干个小数组，利用直接插入排序对基本有序的数组拥有良好的性能这一特性出发的。 同样是不稳定排序，对比直接插入排序的二分查找优化，无论数组规模的大小，希尔排序在性能上都有明显的优势。 五、堆排序堆排序 Heap Sort，是指将整个数组转化成 “堆” 这种数据结构，利用堆的性质，去简化排序的过程。堆排序，可以看做是“变治法”的一种实现。 From Wikipedia：https://en.wikipedia.org/wiki/Heapsort 5.1 堆堆是一个可以被看做一棵树的数组对象，但是堆总是需要满足以下两条性质： ①、堆是一棵完全二叉树。树的每一层都是满的，除了最后一层最右边的元素有可能出现缺位。 ②、父母优势。即堆中的所有子节点，总是不大于或不小于其父节点的值。 根据子节点与父节点的关系，可以将堆分为最大堆（大的值在上）和最小堆（小的值在上）两种情况。 5.2 堆的数组表现形式数组 [9, 7, 3, 5, 1, 2, 6, 0, 8, 4] 按照顺序逐层放置可以转化为以下二叉树结构。（目前不具备堆的性质） 5.3 堆的性质1、获取堆中某个节点的左节点、右节点、父节点 1234567891011121314- (int)leftNode:(int)node&#123; return (node &lt;&lt; 1) + 1; // 0 &lt;&lt; 1 = 0&#125;- (int)rightNode:(int)node&#123; return (node &lt;&lt; 1) + 2;&#125;- (int)parentNode:(int)node&#123; return (node - 1) &gt;&gt; 1;&#125; ①、把完全二叉树每层的节点个数看成二进制 1、2、4、8… ②、当前节点在层 n（从 0 开始）的位置为 m（从 0 开始），那么节点在数组的位置为 index = 2(n - 1) + 2(n - 2) + … + 20 + m 左边子节点就是 2n + 2(n - 1) + … + 20 + m 2 + 1 = index 2 + 1右边子节点就是 2n + 2(n - 1) + … + 20 + m 2 + 2 = index 2 + 2 2、保持最大堆/最小堆的性质 当二叉树中的某个子节点，其左子树和右子树都具备堆的性质，那么可以通过一系列的交换，将以该子节点为根节点的树，转化为堆的结构。 123456789101112131415161718192021222324252627/** * @param array 待排序数组 * @param node 当前节点 * @param lastNode 最后一个节点 */- (void)maxHeapSort:(NSMutableArray *)array node:(int)node lastNode:(int)lastNode&#123; int lNode = [self leftNode:node]; // 左子节点 int rNode = [self rightNode:node]; // 右子节点 int largestNode = node; // 最大值节点。初始为当前节点 // 如果左子节点没有超出范围 &amp;&amp; 左子节点数值比 largestNode 的大 if (lNode &lt;= lastNode &amp;&amp; [array[lNode] integerValue] &gt; [array[largestNode] integerValue]) &#123; largestNode = lNode; &#125; // 如果右子节点没有超出范围 &amp;&amp; 右子节点数值比 largestNode 的大 if (rNode &lt;= lastNode &amp;&amp; [array[rNode] integerValue] &gt; [array[largestNode] integerValue]) &#123; largestNode = rNode; &#125; // 如果当前节点不是最大值，发生交换 if (node != largestNode) &#123; [array exchangeObjectAtIndex:node withObjectAtIndex:largestNode]; [self maxHeapSort:array node:largestNode lastNode:lastNode]; &#125;&#125; 3、构造最大堆/最小堆 将一个不具备堆性质的数组，转化为堆的结构，一般都是自底向上开始的。 自二叉树的第一个非叶节点开始，自底向上，依次保持二叉树的堆的性质，直至根节点。 123456NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; for (int i = lastNonLeaf; i &gt; -1; --i) &#123; [self maxHeapSort:arr node:i lastNode:arr.count - 1];&#125; 5.4 堆排序①、将原数组转化为堆的形式。升序排列使用最大堆，降序排列使用最小堆。 ②、将数组最后一位与第一位交换，因为是最大堆的关系，第一位数字就是最大值，落在了最后一位上。 ③、剔除最后一位数字，将数组剩余部分，看作一颗新的二叉树。其中根节点的左子树和右子树都满足最大堆的性质，保持这棵新二叉树的最大堆性质。这里是通过自顶向下的方式直到最后一个叶子节点调整二叉树。 ④、循环 ②、③，直至根节点，整个数组即自然有序。 123456789101112NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; // 从第一个非叶子节点开始构造，即最后一个叶子节点的父节点。 // 数组 -&gt; 堆 -&gt; 最大堆 for (int i = lastNonLeaf; i &gt; -1; --i) &#123; [self maxHeapSort:arr node:i lastNode:(int)arr.count - 1];&#125;// 最大堆 -&gt; 第一个与最后一个交换for (int i = (int)arr.count - 1; i &gt; 0; --i) &#123; [arr exchangeObjectAtIndex:i withObjectAtIndex:0]; [self maxHeapSort:arr node:0 lastNode:i - 1];&#125; 5.5 变治法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#define num 10int temp;void Description(int *a)&#123; for(int i = 0; i &lt; num; i++) &#123; printf(\"%d \", a[i]); &#125; printf(\"\\n\");&#125;/** * @brief 筛选算法。用于维护堆，保持最大堆的性质 * @param a 数组 * @param k 调整的结点 * @param n 堆的大小 */void MaxHeapify(int *a, int k, int n)&#123; int i = k, j; j = 2 * i + 1; // 置 i 为要筛的结点，j 为 i 的左孩子 while(j &lt; n) &#123; // j + 1 &lt; n 用于判断 i 是否有右孩子。a[j] &lt; a[j+1] 用于比较左右孩子的大小 if (j + 1 &lt; n &amp;&amp; a[j] &lt; a[j+1]) j++; if(a[i] &gt; a[j]) &#123; // i 节点大于左右孩子中的最大者 break; &#125; else &#123; temp = a[i]; a[i] = a[j]; a[j] = temp; i = j; j = 2 * i + 1; &#125; &#125;&#125;void HeapSort(int *a)&#123; int i; // 每建立一次堆，只能确定根节点是最大值，其他节点并没有按序排好，所以后面有重复建堆的过程，但是需要建堆的区间慢慢变少了 for(i = (num - 1)/2; i &gt;= 0; i--) &#123; MaxHeapify(a, i, num); // 初始建堆，其中一开始 i 表示的是最后一个元素的父节点 Description(a); &#125; printf(\"\\n\"); // 重复执行移走堆项及重建堆的操作 for (i = 1; i &lt; num; i++) &#123; // i 表示当前堆的大小，即等待排序的元素的个数 temp = a[0]; a[0] = a[num - i]; a[num - i] = temp; MaxHeapify(a, 0, num - i); //从根节点处继续调整建堆，0 ... n-i 是无序区 Description(a); &#125;&#125;int main()&#123; int a[num] = &#123;0, 1, 3, 5, 7, 9, 8, 6, 4, 2&#125;; HeapSort(a); Description(a); return 0;&#125;0 1 3 5 7 9 8 6 4 2 0 1 3 6 7 9 8 5 4 2 0 1 9 6 7 3 8 5 4 2 0 7 9 6 2 3 8 5 4 1 9 7 8 6 2 3 0 5 4 1 8 7 3 6 2 1 0 5 4 9 7 6 3 5 2 1 0 4 8 9 6 5 3 4 2 1 0 7 8 9 5 4 3 0 2 1 6 7 8 9 4 2 3 0 1 5 6 7 8 9 3 2 1 0 4 5 6 7 8 9 2 0 1 3 4 5 6 7 8 9 1 0 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 5.6 堆排序的时间复杂度堆排序由两部分组成： 构建最大堆 循环保持最大堆的性质 1、构建最大堆的时间复杂度 T = O(n) 构建最大堆的过程，是从第一个非叶节点开始的，即数组的 1/2 处。 考虑最坏情况： 二叉树的倒数第二行，总会与最后一行发生一次比较/交换。 二叉树的倒数第三行，总会与倒数第二行发生一次比较/交换，与最后一行发生一次比较/交换。 … 二叉树的第一行，总会与它下面的每一行都发生一次比较/交换，即交换次数为二叉树高度 d = log2n。 将这些比较/交换次数累加： 2、循环保持最大堆的性质的时间复杂度 T = O(n * log2n) 这一步的时间计算就相对比较明显了，在 n 次循环的内部，进行时间复杂度为 O(log2n) 的 maxHeapSort()。 所以总时间复杂度 T = O(n) + O(nlog2n) =O(nlog2n) 六、归并排序归并排序 Merge Sort，又称为二路归并排序，是指将一个数组一分为二，对每一个子数组递归排序，最后将排好的子数组合并为一个有序数组的过程。 归并排序，是 “分治法” 应用的完美实现。 From Wikipedia: https://en.wikipedia.org/wiki/Merge_sort 6.1 图示 6.2 流程通过图示可以发现归并排序一共只需要两个步骤： 分：将原数组分为 n 个子数组，每个子数组长度为 1。 合：依次将两个相邻的有序数组，合并成一个有序数组，重复操作直至剩下一个有序数组。 6.3 代码实现1、分成两个子数组，左右递归 123456789101112- (void)sort:(NSMutableArray *)arr left:(NSInteger)left right:(NSInteger)right&#123; if (left &lt; right) &#123; NSInteger mid = (left + right) &gt;&gt; 1; // ÷ 2 [self sort:arr left:left right:mid]; [self sort:arr left:(mid + 1) right:right]; // 将分开的两部分子数组合并 [self merge:arr left:left mid:mid right:right]; &#125;&#125; 2、合并两个有序数组，此时处理新数组的排序 123456789101112131415161718192021222324252627/** * @brief 合并 */- (void)merge:(NSMutableArray *)arr left:(NSInteger)left mid:(NSInteger)mid right:(NSInteger)right&#123; // 注意新数组的长度 NSMutableArray * newArr = [NSMutableArray arrayWithCapacity:right - left + 1]; NSInteger startIndex1 = left; NSInteger startIndex2 = mid + 1; for (int i = 0; i &lt; right - left + 1; ++i) &#123; // 左侧数组检索完毕 if (startIndex1 == mid + 1) &#123; newArr[i] = arr[startIndex2++]; &#125; // 右侧数组检索完毕 else if (startIndex2 == right + 1) &#123; newArr[i] = arr[startIndex1++]; &#125; else &#123; // 使用两个指针记录数组位置，依次比较指针位置的数字，将较小的数字放入新数组。这样可以在线性的时间内完成合并工作。 newArr[i] = [arr[startIndex1] integerValue] &lt; [arr[startIndex2] integerValue] ? arr[startIndex1++] : arr[startIndex2++]; &#125; &#125; [arr replaceObjectsInRange:NSMakeRange(left, newArr.count) withObjectsFromArray:newArr];&#125; 3、相似的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define max 1024int SR[max], TR[max];/** * @param SR 两个有序序列构成的序列 * @param TR 一个空数组，用来存放排序好之后的数字 * @param left 起始位置 * @param mid 两个序列的分解位置 * @param right 结束位置 */int merge(int SR[], int TR[], int left, int mid, int right)&#123; int i = left, j = mid + 1, k = left; // k 是 TR 当前存入数字的下标 while(i &lt;= mid &amp;&amp; j &lt;= right) &#123; if(SR[i] &lt; SR[j]) &#123; TR[k++] = SR[i++]; &#125; else &#123; TR[k++] = SR[j++]; &#125; &#125; while(i &lt;= mid) &#123; TR[k++] = SR[i++]; // 当前面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 &#125; while(j &lt;= right) &#123; TR[k++] = SR[j++]; // 当后面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 &#125; return 0;&#125;void copy(int SR[], int TR[], int s, int t)&#123; for(int i = s; i &lt;= t; i++) &#123; SR[i] = TR[i]; // TR -》 SR，相当于 TR 所在的区间有序 &#125;&#125;int mergesort2(int SR[], int left, int right)&#123; if(left &lt; right) &#123; int mid = (left + right) &gt;&gt; 1; mergesort2(SR, left, mid); // 前一半序列继续进行归并排序 mergesort2(SR, mid+1, right); // 后一半序列同时进行归并排序 // 以上递归调用的结束条件是 left ≥ right，也就是分到只有一个数字进行归并排序的时候，一个序列只有一个数字，那么这个序列肯定是有序的 // 以上都是属于“分”的阶段，目的是获得两个有序的数列。 merge(SR, TR, left, mid, right); // 对这两个有序的数列，进行排序，变成一个同样大小但是有序的数列 copy(SR, TR, left, right); //将在TR中排序好的数列给SR，方便SR递归调用归并排序，因为每次两个归并排序的结果都是保存在TR中的，现在要进行下一步就必须在TR数列的基础上面=进行，所以我们把TR给SR &#125; else &#123; ; &#125; return 0;&#125;int main()&#123; int n = 10; int i = 0; for(; i &lt; n; i++) &#123; SR[i] = arc4random() % 100 + 1; printf(\"%d \", SR[i]); &#125; printf(\"\\n\"); mergesort2(SR, 0, n-1); // 升序排列 for(i = 0; i &lt; n; i++) &#123; printf(\"%d \",SR[i]); &#125; printf(\"\\n\"); return 0;&#125; 6.4 时间复杂度和空间复杂度显而易见，递归的次数为 m = log2n，合并操作的时间消耗是线性的，所以时间复杂度 T(n) 如下： 空间复杂度为 O(n)。 6.5 空间复杂度为 O(1) 的归并排序因为两个子数组已经有序，合并的步骤可以采取直接插入排序。 如此一来，可以将空间复杂度由 O(n) 降低至 O(1)，然而相对的时间复杂度则由 O(nlog2n) 升至 O(n2)。 6.6 性能分析及优化两种归并排序的算法，分别是采取了空间换时间，以及时间换空间的策略，性能各有优劣，但是通过分析可以得出以下特点： 计算机对于频繁开辟小数组空间的消耗，比开辟等价大的单个数组空间，代价要来的更大。 使用直接插入排序（从 1/2 处开始），由于拥有较小的最高次幂系数，其性能在长度 n 较小的时候，与 T(n) = O(log2n) 相差不大。 根据以上两个性质，可以在归并排序中，设置一个阈值。超过这个给定的阈值，则采取空间换时间的策略；反之，采用时间换空间的策略，从而提高归并排序的效率。 七、快速排序7.1 简介快速排序 Quick Sort，有时又称划分-交换排序（Partition-Exchange Sort）。 快速排序的主要思想是：选取一个数字，通过一次遍历，将这个数字放到其最终的位置，并且保证其最终位置的左侧都小于等于这个数字，其右侧都大于等于这个数字。 与归并排序相同，是“分治法”的又一个实现案例。快速排序中分治的思想体现在哪里呢？ ①、把大问题分解成很多子问题（分区操作可以每次使得一位元素有序） ②、解决子问题（进行分区操作，每次使得一位元素有序） ③、所有子问题解决了，那么最大的问题也解决了。 一个优秀的快速排序实现，能比其竞争对手（归并排序、堆排序，都是时间复杂度为 O(nlog2n) 的排序算法），快 2-3 倍。 From Wikipedia: https://en.wikipedia.org/wiki/Quicksort 7.2 快速排序的具体步骤快速排序的过程可以拆分成以下三个步骤： 从数组中选择一个数字。 根据这个数字，对整个数组进行一次划分，即：通过一系列的交换，将这个数字放到其最终位置，并且保证其左侧的数字都小于等于它，右侧的数字都大于等于它。 对两侧的子数组进行递归。 7.3 快速排序的基本代码12345678910111213int partition(int array[], int left, int right)&#123; // ...&#125;void sort(int array[], int left, int right)&#123; if (left &lt; right) &#123; int q = partition(array, left, right); sort(array, left, q - 1); sort(array, q + 1, right); &#125;&#125; 7.4 划分 - 挖坑取数快速排序的核心内容：如何对一个数组进行一次划分（partition）。 这里先介绍一种常见的划分算法，我（原作者Gerrard_Feng）称之为“挖坑取数”，具体过程如下： 将最左侧的数字作为待划分的数字，在快速排序中，称这个数字是划分的主元（pivot）。 从最右侧开始向前寻找，找到第一个比 pivot 小的数字（坑），交换 pivot。 此时“坑”的位置被交换到了最左侧，从最左侧的下一个位置开始向后寻找，找到第一个比 pivot 大的数字，交换 pivot。 循环从两侧“夹逼”找“坑”的步骤，直至 pivot 到它的最终位置。 123456789101112131415161718192021222324int partition(int array[], int left, int right)&#123; int pivot = array[left]; int i = left; int j = right + 1; bool forward = NO; while(i &lt; j) &#123; while(forward &amp;&amp; array[++i] &lt;= pivot &amp;&amp; i &lt; j); while(!forward &amp;&amp; array[--j] &gt;= pivot &amp;&amp; i &lt; j); // 交换 i、j 的内容 swap(array, i, j); forward = !forward; &#125; return j;&#125;void swap(int arr[], int one, int two)&#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp;&#125; 其中在“夹逼”过程中的最后一个判断 i &lt; j，是为了防止在夹逼的过程中出现左侧小于右侧的情况。 退出循环后 i = j，所以最后一次交换也不会影响结果。 7.5 划分 - 挖坑取数 - 演示步骤如果上面的说明过于抽象，这里演示一遍“挖坑取数”在数组 {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 3。 从最右侧 7 开始，向前寻找，找到第一个小于等于 3 的数字：2，交换两者位置，得到数组： {2, 5, 1, 9, 8, 6, 0, 3, 4, 7} 。 从最左侧的下一个数字 5 开始，向后寻找，找到第一个大于等于 3 的数字：5，交换两者位置，得到数组： {2, 3, 1, 9, 8, 6, 0, 5, 4, 7} 。 从最右侧的上一个数字 0 开始，向前寻找，找到第一个小于等于 3 的数字：0，交换两者位置，得到数组： {2, 0, 1, 9, 8, 6, 3, 5, 4, 7} 。 从最左侧的下一个数字 1 开始，向后寻找，找到第一个大于等于 3 的数字：9，交换两者位置，得到数组： {2, 0, 1, 3, 8, 6, 9, 5, 4, 7} 。 从最右侧的上一个数字 6 开始，向前寻找，找到第一个小于等于 3 的数字，没有找到，得到最终数组：{2, 0, 1, 3, 8, 6, 9, 5, 4, 7}。 此时，pivot = 3 的左侧数字全部小于等于 3，右侧数字全部大于等于 3，划分完成。 7.6 划分 - 快慢指针这里介绍另外一种划分算法，我（原作者）称之为“快慢指针”，具体过程如下： 将最右侧的数字作为主元。 使用两个指针 faster 和 slower，faster 初始指向第一个数字，slower 初始时指向 faster 上一个数字。 从第一个数字开始遍历数组，快指针随着数组遍历的过程增大。 遍历数组时，每当数字小于等于 pivot 时，慢指针前进一位，然后交换快慢指针的位置，即慢指针指向的数字，永远小于等于 pivot。 当遍历结束时，0-慢指针的最终位置，都保证小于等于 pivot。快指针的最终位置，为 pivot 的前一位。 慢指针向前移动一位（指向的数字保证大于等于 pivot，只有指向 pivot 时，等号成立），交换 pivot 与此时慢指针的位置。 123456789101112131415161718int partition(int array[], int left, int right)&#123; int pivot = array[right]; // 慢指针指向小于 pivot 的值的位置 int slower = left - 1; for (int faster = left; faster &lt; right; ++faster) &#123; if(array[faster] &lt;= pivot) &#123; // 因为发现一个小于 pivot 的值，慢指针向右移一位，用于交换 slower++; swap(array, slower, faster); &#125; &#125; // 最终，慢指针右侧即为 pivot 的位置 swap(array, slower + 1, right); return slower + 1;&#125; 7.7 划分 - 快慢指针 - 演示步骤同样地，演示一遍“快慢指针”在数组 A = {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 7，快指针初始位置指向 3，faster = 0，慢指针初始位置在快指针的前一个位置，slower = -1。 第一个数，3 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 0，faster = 1。 第二个数，5 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 1，faster = 2。 第三个数，1 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 3。 第四个数，9 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 4。 第五个数，8 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 5。 第六个数，6 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 8, 9, 0, 2, 4, 7}，slower = 3，faster = 6。 第七个数，0 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 9, 8, 2, 4, 7}，slower = 4，faster = 7。 第八个数，2 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 8, 9, 4, 7}，slower = 5，faster = 8。 第九个数，4 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 4, 9, 8, 7}，slower = 6，faster = 9。 此时，快指针 faster = 9，不满足小于 right = 9 的条件，退出循环，将主元 pivot = 7，与慢指针的后一个数字 A[7] = 9，做一次交换，得到最终数组：{3, 5, 1, 6, 0, 2, 4, 7, 8, 9}，划分完成。 7.8 快速排序的时间复杂度和稳定性 最坏情况时间复杂度 T(n) = O(n2)。 最好情况时间复杂度 T(n) = O(nlog2n)。 平均情况时间复杂度 T(n) = O(nlog2n)。 最坏情况空间复杂度 T(n) = O(n)。 最好情况空间复杂度 T(n) = O(log2n)。 快速排序，始终只使用原来的数组空间 O(1)，真正消耗的空间，是由递归的深度决定的。 无论哪一种快速排序排序的划分算法，都会打破快速排序的稳定性。 7.9 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define n 5int a[n];int temp;static int count = 0;void swap_t(int a[], int i, int j)&#123; temp = a[i]; a[i] = a[j]; a[j] = temp; count++;&#125;int par(int a[], int left, int right)&#123; int i = left; int x = a[left]; // 基准元素 for(int j = left + 1; j &lt;= right; j++) &#123; if(a[j] &lt;= x) &#123; // 比 x 小的换到左侧 i++; swap_t(a, i, j); &#125; &#125; swap_t(a, left, i); return i; // 轴位置&#125;void QuickSort(int a[],int left, int right)&#123; if(left &lt; right) &#123; int r = par(a, left, right); QuickSort(a, left, r - 1); QuickSort(a, r + 1, right); &#125;&#125;int main()&#123; int i = 0; for(;i &lt; n; i++) &#123; a[i] = arc4random() % 100 + 1; printf(\"%d \", a[i]); &#125; printf(\"\\n\"); QuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) &#123; printf(\"%d \", a[i]); &#125; printf(\"\\n\"); printf(\"交换了 %d 次\", count); return 0;&#125;87 71 39 75 61 39 61 71 75 87 交换了 8 次 随机选择元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define n 5int a[n];int temp;void swap_t(int a[], int i, int j)&#123; temp = a[i]; a[i] = a[j]; a[j] = temp;&#125;int par(int a[], int left, int right)&#123; int i = left; int x = a[left]; for(int j = left + 1; j &lt;= right; j++) &#123; if(a[j] &lt;= x) &#123; i++; swap_t(a, i, j); &#125; &#125; swap_t(a, left, i); return i;&#125;/// 生成随机的基准元素下标int Random(int left, int right)&#123; return arc4random() % (right - left + 1) + left;&#125;// 用随机的基准元素进行快速排序int Randomizedpar(int a[], int left, int right)&#123; int i = Random(left, right); swap_t(a, left, i); // 第一个和第 i 个交换，相当于有了一个随机基准元素 return par(a, left, right);&#125;void RandomizedQuickSort(int a[], int left, int right)&#123; if(left &lt; right) &#123; int r = Randomizedpar(a, left, right); printf(\"%d到%d之间的随机数：%d\\n\", left, right, r); RandomizedQuickSort(a, left, r - 1); RandomizedQuickSort(a, r + 1, right); &#125;&#125;int main()&#123; int i = 0; for(; i&lt; n; i++) &#123; a[i] = arc4random() % 100 + 1; printf(\"%2d \", a[i]); &#125; printf(\"\\n\"); RandomizedQuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) &#123; printf(\"%2d \", a[i]); &#125; printf(\"\\n\"); return 0;&#125; 7.10 快速排序的性能瓶颈与优化策略详情见：排序算法杂谈（五）关于快速排序的优化策略分析 八、学习文章Gerrard_Feng &amp; 排序算法(一) 冒泡排序Gerrard_Feng &amp; 排序算法(二) 选择排序常见排序算法导读(3)[简单选择排序]Gerrard_Feng &amp; 排序算法(三) 直接插入排序Gerrard_Feng &amp; 排序算法(四) 希尔排序Gerrard_Feng &amp; 排序算法（五）堆排序使用减治法求解堆排序堆排序原理及算法实现（最大堆）Gerrard_Feng &amp; 排序算法（六）归并排序Gerrard_Feng 排序算法（七）快速排序快速排序算法分析和实现","tags":[]},{"title":"循环赛日程表","date":"2019-08-05T16:07:52.653Z","path":"2019/08/06/算法/循环赛日程表/","text":"1、问题描述设有 n = 2k 个运动员要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表 ①、每个选手必须与其他 n-1 个选手各赛一场 ②、每个选手一天只能比赛一场 ③、循环赛一共进行 n-1 天 2、算法分析按此要求可将比赛日程表设计成 n 行 n-1 列的表，在表中第 i 行和第 j 列处填入第 i 个选手在第 j 天所遇到的对手。 按分治策略，可以将所有的选手分为两半，则 n 个选手的比赛日程表可以通过 n/2 个选手的比赛日程表来决定。递归地用一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单，这时只要让这两个选手进行比赛就可以了。 通过 k 增长来看算法实现步骤： ①、当 k = 1 时，n = 21 = 2 人，循环表为 **&lt;font color=#cc0000&gt;1&lt;/font&gt; &lt;font color=#008200&gt;2&lt;/font&gt;** **&lt;font color=#008200&gt;2&lt;/font&gt; &lt;font color=#cc0000&gt;1&lt;/font&gt;** ②、当 k = 2 时，n = 22 = 4 人，循环表为 **&lt;font color=#cc0000&gt;1 2&lt;/font&gt; &lt;font color=#008200&gt;3 4&lt;/font&gt;** **&lt;font color=#cc0000&gt;2 1&lt;/font&gt; &lt;font color=#008200&gt;4 3&lt;/font&gt;** **&lt;font color=#008200&gt;3 4&lt;/font&gt; &lt;font color=#cc0000&gt;1 2&lt;/font&gt;** **&lt;font color=#008200&gt;4 3&lt;/font&gt; &lt;font color=#cc0000&gt;2 1&lt;/font&gt;** ③、当 k = 3 时，n = 23 = 8 人，循环表为 **&lt;font color=#cc0000&gt;1 2 3 4&lt;/font&gt; &lt;font color=#008200&gt;5 6 7 8&lt;/font&gt;** **&lt;font color=#cc0000&gt;2 1 4 3&lt;/font&gt; &lt;font color=#008200&gt;6 5 8 7&lt;/font&gt;** **&lt;font color=#cc0000&gt;3 4 1 2&lt;/font&gt; &lt;font color=#008200&gt;7 8 5 6&lt;/font&gt;** **&lt;font color=#cc0000&gt;4 3 2 1&lt;/font&gt; &lt;font color=#008200&gt;8 7 6 5&lt;/font&gt;** **&lt;font color=#008200&gt;5 6 7 8&lt;/font&gt; &lt;font color=#cc0000&gt;1 2 3 4&lt;/font&gt;** **&lt;font color=#008200&gt;6 5 8 7&lt;/font&gt; &lt;font color=#cc0000&gt;2 1 4 3&lt;/font&gt;** **&lt;font color=#008200&gt;7 8 5 6&lt;/font&gt; &lt;font color=#cc0000&gt;3 4 1 2&lt;/font&gt;** **&lt;font color=#008200&gt;8 7 6 5&lt;/font&gt; &lt;font color=#cc0000&gt;4 3 2 1&lt;/font&gt;** 以此类推，可以用分治的方法实现，先自顶向下分解，直到分解到最简单的情况，即人数为 2 人，这时就可以两两比赛，表的填充为对角填充的方式，然后再自底向上填充表格，具体的看上面的 k = 1、k = 2、k = 3 时形成的循环表就很好理解了。 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#define N 64void GameTable(int k, int a[][N])&#123; int n = 2; // 选手数 // 求解两个选手比赛日，得到左上角元素 a[0][0] = 1; a[0][1] = 2; a[1][0] = 2; a[1][1] = 1; int i, j, half; // 循环处理，依次处理 2^2 ... 2^k 个选手比赛日程 for (int t = 1; t &lt; k; t++) &#123; half = n; // 当前选手数的 1 / 2 n *= 2; // 当前选手数 // 左下角 for (i = half; i &lt; n; i++) // 行 for (j = 0; j &lt; half; j++) // 列 a[i][j] = a[i - half][j] + half; // 右上角 for (i = 0; i &lt; half; i++) for (j = half; j &lt; n; j++) a[i][j] = a[i + half][j - half]; // 右下角 for (i = half; i &lt; n; i++) for (j = half; j &lt; n; j++) a[i][j] = a[i - half][j - half]; &#125; printf(\"运动员编号\\t\"); for (i = 1; i &lt; n; i++) &#123; printf(\"第 %d 天\\t\", i); &#125; printf(\"\\n\\n\"); for (i = 0; i &lt; n; i++) &#123; printf(\" %d 号 \\t\", i + 1); for (j = 1; j &lt; n; j++) printf(\" %d\", a[i][j]); printf(\"\\n\"); &#125;&#125;int main()&#123; int a[N][N] = &#123; 0 &#125;; int k = 3; printf(\"******************************************\\n\"); printf(\"\\t\\t**\\t\\t循环赛日程表\\t\\t**\\n\"); printf(\"******************************************\\n\\n\"); GameTable(k, a); return 0;&#125;****************************************** ** 循环赛日程表 ********************************************运动员编号 第 1 天 第 2 天 第 3 天 第 4 天 第 5 天 第 6 天 第 7 天 1 号 2 3 4 5 6 7 8 2 号 1 4 3 6 5 8 7 3 号 4 1 2 7 8 5 6 4 号 3 2 1 8 7 6 5 5 号 6 7 8 1 2 3 4 6 号 5 8 7 2 1 4 3 7 号 8 5 6 3 4 1 2 8 号 7 6 5 4 3 2 1 4、学习文章算法之循环赛日程表","tags":[]},{"title":"挖金矿","date":"2019-08-05T16:07:52.653Z","path":"2019/08/06/算法/挖金矿/","text":"原文：https://juejin.im/post/5a29d52cf265da43333e4da7 1、问题描述有 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 2、算法分析w 表示总共人数，n 表示金矿数， ①、排列组合 每一座金矿都有挖与不挖两种选择，排列组合起来就有 2n 种选择。对所有可能性做遍历，剔除那些使用工人数超过 10 的选择，在剩下的选择里找出获得金币数最多的选择。 时间复杂度：O(2n)。 ②、递归 每个金矿存在”挖”、”不挖”两种情况，可以同时内部调用两次递归方法，表示”挖”和”不挖”。 12345678910void A()&#123; if (边界条件) return x; // 挖 A(); // 不挖 A();&#125; 时间复杂度：O(2n) 开辟空间：递归深度 O(n) ③、动态规划 这个问题与 0-1 背包问题相同，动态规划时的策略也是：当前金矿是否应该挖，挖与不挖的价值比较。整理出以下表格。 【状态】是 f(w)，【边界】是 f(w &lt; 3) = 0；状态方程 f(w) = max{ f(w - 1), f(w - i) + vi }, w &gt; i i 表示当前金矿需要的人数，vi 表示当前金矿的价值。 时间复杂度：O(n*w) 空间复杂度：O(n*w) 如果不保留挖金矿信息，只输出最高金币数，可以由上发现，每一层的数据只与上一层有关，那么就可以由上至下，只用一位数组保存状态，空间复杂度 O(w)。 ④、比较 当工人数 w -&gt; ∞ 时，动态规划的时间复杂度和空间复杂度与 w 成正比，所以增长较快；而递归算法与 w 无关，所以不增长，此时动态规划的效率就没有递归的好。 3、代码实现①、递归（自底向上） 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (a) &gt; (b) ? (a) : (b)typedef struct GoldMine &#123; int worker; int gold;&#125; GoldMine;/** * mineNum 金矿数 * workerNum 挖矿总人数 * curMine 当前金矿（从 0 开始） * curWorker 当前人数（从 0 开始） * max 当前最大金币数 */ int monerFinderAlgorithm(GoldMine* mines, int mineNum, int workerNum, int curMine, int curWorker, int max)&#123; GoldMine curGoldMine = mines[curMine]; // 金矿挖完了 || 人数不够了 if (curMine &gt;= mineNum || curWorker + curGoldMine.worker &gt; workerNum) return max; // 挖 int dig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker + curGoldMine.worker, max + curGoldMine.gold); // 不挖 int noDig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker, max); return MAX(dig, noDig);&#125;int main()&#123; GoldMine mines[5] = &#123; &#123;3, 200&#125;, &#123;4, 300&#125;, &#123;3, 350&#125;, &#123;5, 400&#125;, &#123;5, 500&#125; &#125;; printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 5, 10, 0, 0, 0)); //GoldMine mines[2] = &#123; &#123;4, 300&#125;, &#123;5, 500&#125; &#125;; //printf(\"\\n\\n%d\", monerFinderAlgorithm(mines, 2, 10, 0, 0, 0)); return 0;&#125; ②、动态规划 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAX(a, b) (a) &gt; (b) ? (a) : (b)typedef struct GoldMine &#123; int worker; int gold;&#125; GoldMine;/// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker)&#123; if (worker == 0 || mineNum == 0) return 0; // i 列 j 行 int i = 0, j = 0; // 二维数组，从左向右，第一个 [ ] 是列，第二个 [ ] 是行 int goldMatrix[worker + 1][mineNum]; // 初始化并打印二维数组 for (; j &lt; mineNum; j++) &#123; for (i = 0; i &lt;= worker; i++) &#123; goldMatrix[i][j] = 0; printf(&quot;0 &quot;); // printf(&quot;%d &quot;, goldMatrix[i][j]); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); GoldMine mine; for (i = 1; i &lt;= worker; i++) &#123; for (j = 0; j &lt; mineNum; j++) &#123; mine = mines[j]; // 挖矿人数不够 if (mine.worker &gt; i) &#123; // 第一个存储 0，非第一个存储前一个 j 的值 goldMatrix[i][j] = (j == 0) ? 0 : goldMatrix[i][j-1]; &#125; // 挖矿人数足够 else &#123; // 第一个直接存储，非第一个存储 MAX&#123; 不加入 j 的值， 加入 j 的值 &#125;，j -1 是因为剔除了当前 goldMatrix[i][j] = (j == 0) ? mine.gold : MAX(goldMatrix[i][j-1], goldMatrix[i-mine.worker][j-1] + mine.gold); &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; mineNum; j++) &#123; for (i = 1; i &lt;= worker; i++) printf(&quot;%d &quot;, goldMatrix[i][j]); printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); // 挖哪些矿 int curWorker = worker; for (j = mineNum - 1; j &gt;= 0; j--) &#123; mine = mines[j]; if (curWorker == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (goldMatrix[curWorker][j] - goldMatrix[curWorker - mine.worker][j-1] == mine.gold) &#123; printf(&quot;%d &quot;, mine.worker); curWorker -= mine.worker; &#125; &#125; return goldMatrix[worker][mineNum - 1];&#125;int main()&#123; GoldMine mines[5] = &#123; &#123;3, 200&#125;, &#123;4, 300&#125;, &#123;3, 350&#125;, &#123;5, 400&#125;, &#123;5, 500&#125; &#125;; printf(&quot;\\n\\n%d&quot;, monerFinderAlgorithm(mines, 5, 10)); //GoldMine mines[2] = &#123; &#123;4, 300&#125;, &#123;5, 500&#125; &#125;; //printf(&quot;\\n\\n%d&quot;, monerFinderAlgorithm(mines, 2, 10)); return 0;&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 200 200 200 200 200 200 200 200 0 0 200 300 300 300 500 500 500 500 0 0 350 350 350 550 650 650 650 850 0 0 350 350 400 550 650 750 750 850 0 0 350 350 500 550 650 850 850 900 5 5 900 空间复杂度 O(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445/// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker)&#123; if (worker == 0 || mineNum == 0) return 0; int* preGoldMatrix = (int *)calloc(sizeof(int), worker); int* goldMatrix = (int *)calloc(sizeof(int), worker); GoldMine mine; for (int i = 0; i &lt; mineNum; i++) &#123; mine = mines[i]; // 从 1 开始计算 for (int j = 1; j &lt;= worker; j++) &#123; // 挖矿人数不够 if (j &lt; mine.worker) &#123; goldMatrix[j-1] = preGoldMatrix[j-1]; &#125; // 挖矿人数足够 else &#123; // 从上一层中 [j - mine.worker - 1] 和 [j - 1] 中获取最大值 goldMatrix[j-1] = MAX(preGoldMatrix[j-1], preGoldMatrix[j - mine.worker - 1] + mine.gold); &#125; printf(\"%d \", goldMatrix[j - 1]); &#125; printf(\"\\n\"); // 打印 preGoldMatrix、goldMatrix 数组的内容// for (int k = 0; k &lt; worker; k++) &#123;// printf(\"%d \", preGoldMatrix[k]);// &#125;// printf(\"\\n\");//// for (int k = 0; k &lt; worker; k++) &#123;// printf(\"%d \", goldMatrix[k]);// &#125;// printf(\"\\n\\n\"); for (int k = 0; k &lt; worker; k++) &#123; // 不能使用 preGoldMatrix = goldMatrix; 这是指针赋值，preGoldMatrix 与 goldMatrix 内存地址一样 preGoldMatrix[k] = goldMatrix[k]; &#125; //printf(\"%p %p\", preGoldMatrix, goldMatrix); // 打印数组的内存地址 &#125; return goldMatrix[worker - 1];&#125;","tags":[]},{"title":"大整数相乘","date":"2019-08-05T16:07:52.652Z","path":"2019/08/06/算法/大整数相乘/","text":"学习文章：分治算法详解、分治法的经典问题——大整数相乘 1、问题描述计算两个很大整数的结果，例如：27392361983108271361039746313 * 37261038163103818366341087632113 2、算法分析先用一个简单的例子，如 234 * 456 = ？？？来考虑。在这里考虑将 456 拆分为 4、5、6，然后分别去乘以 234。 234 x 456 -------------------- 1404 1170 936 -------------------- 106704 这就是熟悉的竖式计算乘法的结构，看着每一步计算出来的结果，一层一层的，是否看起来像二维数组？我们就用二维数组来保存结果，数组的第一行保留 1404，第二行保留 11700，第三行保留 93600。由于不能直接存储，需要对存放的位置做一下计算：数组该有多少行，该有多少列？ 在这里我们需要知道，3 位 3 位，结果最多为 6 位数；2 位 6 位，结果最多为 2 + 6 = 8 位，所以这里数组该有 6 列，而对于行数，则由被乘数决定，所以这里为 3 行。 temp[3][6] = { 0 0 1 4 0 4 0 1 1 7 0 0 0 9 3 6 0 0 } 每列依次往下加 1 0 6 7 0 4; 所得刚好为我们要的答案。 3、代码实现时间复杂度 O(n2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;stdio.h&gt;#define num1 11#define num2 6void MultiOfLargeNumbers(int a1[], int a2[])&#123; int temp[num2][num1 + num2] = &#123; 0 &#125;; // 注意：二维数组列数的规律 int x, y; // x - 行数，y - 列数 uint isCarry = 0; // 进位值 // 打印二维数组 for (int i = 0; i &lt; num2; i++) &#123; // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(\"%d \", temp[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); for(int idx2 = num2 - 1; idx2 &gt;= 0; idx2--) &#123; // 乘数 x = num2 - idx2 - 1; y = num1 + idx2; for(int idx1 = num1 - 1; idx1 &gt;= 0; idx1--, y--) &#123; // 被乘数 // 加上进位数值 temp[x][y] = a1[idx1] * a2[idx2] + isCarry; isCarry = 0; // 当前计算结果需要进位，计算进位数值和结果数值 if(temp[x][y] &gt;= 10) &#123; isCarry = temp[x][y] / 10; temp[x][y] %= 10; &#125; &#125; if(isCarry) &#123; // 首位有进位 temp[x][y] += isCarry; isCarry = 0; &#125; &#125; // 合并 int temp_sum[num1 + num2] = &#123;0&#125;; // 将每一列的数组到最后的结果数组里面 for(int j = num2 + num1 - 1; j &gt;= 0; j--) &#123; // 列 for(int i = num2 - 1; i &gt;= 0; i--) &#123; // 行 temp_sum[j] += temp[i][j]; &#125; if (isCarry) &#123; temp_sum[j] += isCarry; isCarry = 0; &#125; if( temp_sum[j] &gt;= 10) &#123; isCarry = temp_sum[j] / 10; temp_sum[j] %= 10; &#125; &#125; // 打印二维数组 for (int i = 0; i &lt; num2; i++) &#123; // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(\"%d \", temp[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); // 打印相乘结果 for(int i = 0; i &lt; num2 + num1; i++) printf(\"%d\", temp_sum[i]);&#125;int main()&#123; //int a1[num1] = &#123; 2, 3, 4 &#125;; //int a2[num2] = &#123; 4, 5, 6 &#125;; // 2739236198310827136103974、37261038163103818366 int a1[num1] = &#123; 2, 7, 3, 9, 2, 3, 6, 1, 9, 8, 3 &#125;; int a2[num2] = &#123; 3, 7, 2, 6, 1, 0 &#125;; MultiOfLargeNumbers(a1, a2); return 0;&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 7 3 9 2 3 6 1 9 8 3 0 0 0 0 1 6 4 3 5 4 1 7 1 8 9 8 0 0 0 0 0 5 4 7 8 4 7 2 3 9 6 6 0 0 0 0 1 9 1 7 4 6 5 3 3 8 8 1 0 0 0 0 0 8 2 1 7 7 0 8 5 9 4 9 0 0 0 0 0 10206667998485630 4、分治法首先将 X 分为 A、B 和 Y 分成 C、D。注意：这里的 X、Y 假设位数相同。 此时将 X 和 Y 的乘积转化，把问题转化为求解式子的值。 分析一下：对这个式子，一共要进行 4 次 n/2 的乘法（AC 2 次， AD、BC 各 1 次）和 3 次加法，因而该算法的时间复杂度为 T(n) = 4 * T(n/2) + θ(n) 通过 master 定理可以求得 T(n) = θ(n2)，跟小学算法的时间复杂度没有区别。 但是我们再来看看，我们是否可以用加法来换取乘法？因为多一个加法操作，也是常数项，对时间复杂度没有影响，如果减少一个乘法则不同。 时间复杂度为： T(n) = 3 * T(n/2) + θ(n)，通过 master 定理求得 T(n) = O(nlog23) = O(n1.59)。","tags":[]},{"title":"寻找假币","date":"2019-08-05T16:07:52.652Z","path":"2019/08/06/算法/寻找假币/","text":"1、问题描述一个袋子里有若干硬币，其中一枚是假币，并且和假币和真币一模一样，目前只知道假币比真币轻一点。请问如何找到这枚假币？ 2、算法分析根据分治的策略，将硬币平分为两份（奇数个硬币取出中间的硬币后再平分），比较两边的重量之和的大小。左侧重，则假币在右半段，反之，假币在左半段（或者中间的假币），然后继续在有假币的半区查找，直到剩余两个硬币，比较大小后，返回假币的位置。 时间复杂度：O(logn)。 3、代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#define MAXNUM 30int FalseCoin(int coin[], int low, int high)&#123; // 两个硬币的比较 if (low + 1 == high) &#123; if (coin[low] &lt; coin[high]) &#123; return low + 1; &#125; return high + 1; &#125; int sum1 = 0, sum2 = 0, sum3 = 0; int mid = (low + high) &gt;&gt; 1; int i; // 偶数个硬币 if ((high - low + 1) % 2 == 0 ) &#123; // 左半段 for (i = low; i &lt;= mid; i++) &#123; sum1 += coin[i]; &#125; // 右半段 for (i = mid + 1; i &lt;= high; i++) &#123; sum2 += coin[i]; &#125; // 左侧重，则假币在右半段 if (sum1 &gt; sum2) &#123; return FalseCoin(coin, mid + 1, high);; &#125; // 右侧重，则假币在左半段 else if (sum2 &gt; sum1)&#123; return FalseCoin(coin, low, mid);; &#125; else &#123; printf(\"没有假币。输入的硬币重量有误！\"); &#125; &#125; // 奇数个硬币 else &#123; // 左半段，除去中间的一个硬币 for (i = low; i &lt;= mid - 1; i++) &#123; sum1 += coin[i]; &#125; // 右半段，除去中间的一个硬币 for (int i = mid + 1; i &lt;= high; i++) &#123; sum2 += coin[i]; &#125; sum3 = coin[mid]; // 左侧重，则假币在右半段 if (sum1 &gt; sum2) &#123; return FalseCoin(coin, mid + 1, high); &#125; // 右侧重，则假币在左半段 else if (sum2 &gt; sum1)&#123; return FalseCoin(coin, low, mid - 1); &#125; else &#123; // 中间的是假币 if (coin[mid] != coin[low]) &#123; return mid + 1; &#125; else &#123; printf(\"没有假币。输入的硬币重量有误！\"); &#125; &#125; &#125; return -1;&#125;int main()&#123; int coin[] = &#123; 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 &#125;; int position = FalseCoin(coin, 0, 9); printf(\"假币在第 %d 个位置\", position); return 0;&#125;假币在第 4 个位置","tags":[]},{"title":"图片设置圆角性能问题","date":"2019-08-05T16:07:52.651Z","path":"2019/08/06/iOS/iOS优化/图片设置圆角性能问题/","text":"通常设置圆角方式 12imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50; 这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。 注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。 一、设置圆角的方法①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。 ②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化 1234imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50;imageView.layer.shouldRasterize = YES; // 设置光栅化imageView.layer.rasterizationScale = [UIScreen mainScreen].scale; // UIImageView 不加这句会产生一点模糊 设置光栅化可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。 但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 ③、直接覆盖一张中间为圆形透明的图片（推荐使用） 这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。 这种圆片覆盖的方法一般只用在底色为纯色的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色） ④、UIImage drawInRect 绘制圆角 这种方式 GPU 损耗低内存占用大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@interface CornerImageView ()&#123; NSBlockOperation * _operation; // 任务 NSOperationQueue * _queue; UIImage * _cornerImage; // 圆角化的图片&#125;@end@implementation CornerImageView- (instancetype)initWithFrame:(CGRect)frame&#123; if (self = [super initWithFrame:frame]) &#123; _queue = [[NSOperationQueue alloc] init]; &#125; return self;&#125;/** * 重写设置方法。如果是 UIButton 可以换成 setImage:forState: */- (void)setImage:(UIImage *)image&#123; [super setImage:nil]; [self roundedImage:image];&#125;- (void)roundedImage:(UIImage *)image&#123; [_queue cancelAllOperations]; [_operation cancel]; _operation = nil; _operation = [NSBlockOperation blockOperationWithBlock:^&#123; UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, [UIScreen mainScreen].scale); // Add a clip before drawing anything, in the shape of an rounded rect [[UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:self.bounds.size.height / 2] addClip]; [image drawInRect:self.bounds]; _cornerImage = UIGraphicsGetImageFromCurrentImageContext(); // Lets forget about that we were drawing UIGraphicsEndImageContext(); if (!_operation) &#123; return; &#125; dispatch_async(dispatch_get_main_queue(), ^&#123; [super setImage:_cornerImage]; &#125;); &#125;]; [_queue addOperation:_operation];&#125; 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。 问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？ ⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface UIImage (corner)+ (id)createRoundedRectImage:(UIImage *)image;@end@implementation UIImage (corner)static void addRoundedRectToPath(CGContextRef context, CGRect rect, float ovalWidth, float ovalHeight)&#123; float fw, fh; if (ovalWidth == 0 || ovalHeight == 0) &#123; CGContextAddRect(context, rect); return; &#125; CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); CGContextScaleCTM(context, ovalWidth, ovalHeight); fw = CGRectGetWidth(rect) / ovalWidth; fh = CGRectGetHeight(rect) / ovalHeight; // 使的圆角半径为 1 CGContextMoveToPoint(context, fw, fh/2); // Start at lower right corner CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1); // Top right corner CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1); // Top left corner CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1); // Lower left corner CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); // Back to lower right CGContextClosePath(context); CGContextRestoreGState(context);&#125;+ (id)createRoundedRectImage:(UIImage *)image&#123; CGFloat wh = MIN(MAX(image.size.width, image.size.height), 160); CGSize imageSize = CGSizeMake(wh, wh); CGfloat radius = wh / 2; CGContextRef context = CGBitmapContextCreate( NULL, wh, wh, 8, 4 * wh, CGColorSpaceCreateDeviceRGB(), kCGImageAlphaPremultipliedFirst ); // 绘制圆角 CGContextBeginPath(context); addRoundedRectToPath(context, CGRectMake(0, 0, wh, wh), radius, radius); CGContextClosePath(context); CGContextClip(context); CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); CGImageRef imageMasked = CGBitmapContextCreateImage(context); image = [UIImage imageWithCGImage:imageMasked]; CGContextRelease(context); CGImageRelease(imageMasked); return image;&#125; 以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。 123456/** * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 '(x1，y1)' 的直线相切，与 '(x1，y1)' 到 '(x2, y2)' 的直线相切。 */CG_EXTERN void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) CG_AVAILABLE_STARTING(10.0, 2.0); 二、使用 Instruments 的 Core Animation 查看性能 Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 用 Instruments 测试得： ①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。 ②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。 ③、添加圆形透明图片，无任何高亮，说明没离屏渲染。 ④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大） ⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法) 三、问题①、有提到还有一种 mask 方法。 这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考小心别让圆角成了你列表的帧数杀手。 ②、第四种比第一种更卡。 第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。 可以用 Instruments的 GPU Driver 进行测试： Renderer Utilization 如果这个值 &gt; 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization 如果这个值 &gt; 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。 第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。 帧率越接近 60 滑动越顺畅。 发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。 如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。 而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。 所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。 四、参考文章 内存恶鬼drawRect - 谈画图功能的内存优化 github 绘制圆角源码参考 NZCircularImageView、HJCornerRadius","tags":[]},{"title":"全排列","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/算法/全排列/","text":"1、问题描述有 n 个数或字符，有多少种排列方法。 2、算法分析采用分治法把大问题分解成很多的子问题。大问题是所有的排列方法，分解得到的小问题就是以 1 开头的排列，以 2 开头的排列，以 a 开头的排列，以 b 开头的排列…把这些问题继续分解，以 12 开头的排列，以 123 开头的排列…将余下的看成大问题，一直分解下去，直到分解成的子问题只有一个数字或字符的时候，不再分解。 因为 1 个数字或字符肯定只有一种排列方式，现在将每个解决了的小问题合并，合并成一个大点的问题，合并之后这个大点的问题也解决了，再将这些大点的问题合并成一个更大的问题，直到最大的问题解决为止。 先固定一个字符，然后将固定的字符与它后面的每一个进行交换，一直递归下去，直到固定的字符后面只有一个字符。 下图中，红色字符是被固定的字符，白色字符的没有被固定的字符。具体做法就是每次将没有固定的第一个字符与其他未固定的字符交换（第 1 个与第 1个交换，第 1 个与第 2 个交换，… 第 1 个与第 n 个交换），直到只剩下一个没有被固定的字符时，输出此时的字符排列，但是输出之后要将字符的位置还原。 全排列可以看做固定前 i 位，对第 i+1 位之后的再进行全排列，比如固定第一位，后面跟着 n-1 位的全排列。那么解决 n-1 位元素的全排列就能解决 n 位元素的全排列了。 3、代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;char temp;void swapChar(char a[], int i, int k)&#123; temp = a[i]; a[i] = a[k]; a[k] = temp;&#125;void algorithm(char a[], int start, unsigned long count)&#123; // 深度控制。此时只剩一个没有固定的字符，直接输出 if(start == count - 1) &#123; puts(a); return; &#125; for(int i = start; i &lt; count; i++) &#123; swapChar(a, i, start); // 交换 algorithm(a, start + 1, count); swapChar(a, i, start); // 复原 &#125;&#125;int main()&#123; char arr[100] = &#123; 'a', 'b', 'c' &#125;; // gets(a); algorithm(arr, 0, strlen(arr)); return 0;&#125;","tags":[]},{"title":"利用预渲染加速iOS设备的图像显示","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/iOS/iOS优化/利用预渲染加速iOS设备的图像显示/","text":"使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。 于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。 接着下面举个例子程序来验证： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;UIKit/UIKit.h&gt;@interface ImageView : UIView@property (nonatomic, strong) UIImage * image;@end#import \"ImageView.h\"#include &lt;mach/mach_time.h&gt;static const CGRect imageRect = &#123; &#123;0, 0&#125;, &#123;100, 100&#125;&#125;;@implementation ImageView- (void)awakeFromNib&#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; &#125; [superawakeFromNib];&#125; - (void)drawRect:(CGRect)rect&#123; if (CGRectContainsRect(rect, imageRect)) &#123; uint64_t start = getTickCount(); [self.image drawInRect:imageRect]; uint64_t drawTime = getTickCount() - start; NSLog(@\"%llu\", drawTime); // 打印时间间隔 &#125;&#125;// mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。uint64_t getTickCount(void)&#123; static mach_timebase_info_data_t sTimebaseInfo; uint64_t machTime = mach_absolute_time(); // Convert to nanoseconds - if this is the first time we've run, get the timebase. if (sTimebaseInfo.denom == 0) &#123; (void)mach_timebase_info(&amp;sTimebaseInfo); &#125; uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom; // 纳秒 return millis;&#125;@end 测试用一张 1838 * 890 的图 2018-07-05 11:05:25.950978+0800 Demo[5831:113872] 31802012 接下来就是见证奇迹的时刻了，把这段代码加入程序： 12345678910111213141516static const CGSize imageSize = &#123;100, 100&#125;;- (void)awakeFromNib &#123; if (!self.image) &#123; self.image = [UIImage imageNamed:@\"xxx\"]; // 由于JPEG图像是不透明的，所以第二个参数就设为YES // 第三个参数是缩放比例。虽然这里可以用 [UIScreen mainScreen].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了 UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0); // 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作 [image drawInRect:imageRect]; self.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); &#125;&#125; 值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。 时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] 127939，缩短了很多。 还能更快吗？让我们来试试 Core Graphics。 先定义一个全局的 CGImageRef 变量： 123456static CGImageRef imageRef;- (void)awakeFromNib&#123; imageRef = self.image.CGImage;&#125; 然后 12345- (void)drawRect:(CGRect)rect&#123; CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawImage(context, imageRect, imageRef);&#125; 运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] 27425265，而且图像还上下颠倒了⋯ 这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正： 1234CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, 0, 100);CGContextScaleCTM(context, 1, -1);CGContextDrawImage(context, imageRect, imageRef); 这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] 34242146，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。","tags":[]},{"title":"图片加载和处理","date":"2019-08-05T16:07:52.650Z","path":"2019/08/06/iOS/iOS优化/图片加载和处理/","text":"一、图片显示图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。 以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。UIImage 持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。 当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。 解码是一个计算量较大且需要 CPU 来执行的任务；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 高 每个像素点的大小 = width height 4bytes。 图像解码操作会造成什么问题？ 以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于在主线程同时进行 IO 操作、解码操作等，会造成内存迅速增长和 CPU 负载瞬间提升。 并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。 1.1 优化一：降采样在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示： 我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。 思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？ 12345678910111213141516171819202122- (UIImage *)downsampleImageAt:(NSURL *)imageURL to:(CGSize)pointSize scale:(CGFloat)scale&#123; CFDictionaryRef imageSourceOptions = CFDictionaryCreate ( CFAllocatorGetDefault(), (void *)@[ (NSString *)kCGImageSourceShouldCache ], (void *)@[ @(YES) ], 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, imageSourceOptions); NSInteger maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale; CFDictionaryRef downsampleOptions = (__bridge CFDictionaryRef)@&#123; (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @(YES), (NSString *)kCGImageSourceShouldCacheImmediately : @(YES), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @(YES), (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) &#125;; CGImageRef downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions); return [UIImage imageWithCGImage:downsampledImage];&#125; 正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。 1.2 优化二：异步处理 从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以在 Prefetching 时把降采样放到子线程进行处理，因为降采样过程就包括解码操作。 Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。 需要特别注意，此处不能是并发队列，否则会造成线程爆炸，原因见总结部分。 123456789101112131415161718192021222324252627282930313233343536&#123; // 创建串行队列 _serialQueue = dispatch_queue_create(\"DecodeQueue\", DISPATCH_QUEUE_SERIAL);&#125;/** * @brief 获取单元格的图片 */- (void)collectionView:(UICollectionView *)collectionView prefetchItemsAt:(NSArray&lt;NSIndexPath *&gt; *)indexPaths&#123; for (NSIndexPath * indexPath in indexPaths) &#123; dispatch_async(_serialQueue, ^&#123; UIImage * downsampledImage = [self downsample]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self updateAt:indexPath with:downsampledImage]; &#125;); &#125;); &#125;&#125;/** * @brief 降采样。自行实现。 */- (UIImage *)downsample&#123; return nil;&#125;/** * @brief 更新单元格的图片 */- (void)updateAt:(NSIndexPath *)indexPath with:(UIImage *)image&#123; &#125; 1.3 优化三：使用 Image Asset Catalogs苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。 WWDC Session。 二、总结应用上述的优化策略，已经能对图片加载有比较好的优化。 WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。 三、WWDC学习原作者的经验：落影loyinglin 先主观假设两个前提： ①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚； ②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。 所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，看我们的 iOS 知识体系是否存在缺陷；另外，WWDC 介绍的很多知识点同样免验证的加入自己的知识体系。 以上文提到的线程爆炸为例，看看这种方式的好处。 原文如下： Thread Explosion（线程爆炸） More images to decode than available CPUs（解码图像数量大于 CPU 数量）GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像） 从这个案例我们学习到如何避免图像解码的线程爆炸，我们分析苹果工程师的逻辑，然后扩散思维： 原因：解码任务过多 =&gt; 过程：GCD 开启更多线程=&gt; 结果：每个线程获得更少的时间 延伸出来的问题： GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？… 举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来： ①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别； ②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。 接下来的表现是操作系统相关的知识： ①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程； ②、cpu 的时间是分为多个时间片，每个线程轮询执行； ③、线程切换执行有代价，但比进程切换小得多； ④、每个 cpu 核心在同一时刻只能执行一个线程。 至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现： 主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。 结合此案例，我们能回答相关问题： ①、现在有一个很复杂的计算任务，例如统计一个 5000*5000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 1000*1000 小图分别统计，是否会速度的提升？ ②、GCD 的串行队列和并发队列的应用场景有何不同？ 四、文章iOS性能优化–图片加载和处理 WWDC2018-Image and Graphics Best Practices","tags":[]},{"title":"二分查找","date":"2019-08-05T16:07:52.649Z","path":"2019/08/06/算法/二分查找/","text":"1、问题描述在一个有序（升序）数组查找一个数 x 2、算法分析暴力的做法就是拿 x 跟数组里面每个数比较一下，然后返回找到的 x 的下标。这里明显可以使用分治的思想：可以把数组分成很多部分，在每个部分里面查找 x。如果所有部分都没有找到 x，那么把这些子问题合并起来后，表示整个数组里没有 x。 这很好的反应了分治的思想，先分解成很多小问题，解决这些小问题，把解决的小问题合并起来，大问题就解决了。 3、代码实现递归： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;/** * @param a 需要二分的升序数组 * @param x 需要查找的数字 * @param low 低位 * @param high 高位 */int binarysearch(int a[], int x, int low, int high)&#123; if(low &gt; high) &#123; return -1; // 没有找到 &#125; int mid = (low + high) &gt;&gt; 1; if(x == a[mid]) &#123; return mid; // 找到 x &#125; else if(x &gt; a[mid]) &#123; return binarysearch(a, x, mid + 1, high); // 在后半部分继续二分查找 &#125; else &#123; return binarysearch(a, x, low, mid - 1); // 在前半部分继续二分查找 &#125;&#125;int main()&#123; int a[10] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; int idx = binarysearch(a, 2, 0, 9); if(idx == -1) &#123; printf(\"未查到！\\n\"); &#125; else &#123; printf(\"查到了！数组下标 = %d\\n\", idx); &#125; return 0;&#125; 非递归： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int BinarySearch(int a[], int n, int key)&#123; if (n == 0) return -1; int left = 0, mid, right = n - 1; while (left &lt;= right) &#123; mid = (left + right) &gt;&gt; 1; if (a[mid] &lt; key) &#123; left = mid + 1; &#125; else if (a[mid] &gt; key) &#123; right = mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;int main()&#123; int a[] = &#123; 1, 3, 5, 8, 22, 45, 65, 78, 79, 102 &#125;; printf(\"%d\", BinarySearch(a, 10, 65)); return 0;&#125;","tags":[]},{"title":"依赖注入","date":"2019-08-05T16:07:52.649Z","path":"2019/08/06/iOS/iOS原理/依赖注入/","text":"一、简介依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。 初始化方法注入： 1- (instancetype)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2; 属性注入： 12@property (nonatomic, retain) Dependency1 * dependency1;@property (nonatomic, retain) Dependency2 * dependency2; 一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。 二、为什么使用依赖注入依赖注入的几个重要之处： ①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量； ②、使用构成。 即一直坚持的多构成少继承原则。它能提高代码的可重用性； ③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。 ④、明确的所有者。 ⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。 三、使用依赖注入3.1 注入类的类型首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。 简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。 复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。 分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。 3.2 在初始化时依赖分配原始代码： 12345678910111213141516@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)init&#123; if (self = [super init]) &#123; ... _engine = [[RCEngine alloc] init]; &#125; return self;&#125;@end 使用依赖注入改版后： 1234567891011121314151617@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine&#123; if (self = [super init]) &#123; ... _engine = engine; &#125; return self;&#125;@end 3.3 延迟初始化依赖通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子： 1234567891011@implementation RCRaceCar- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init]; [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。 工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。 下面，通过一个工厂，使用依赖注入创建一个灭火器。 1234567891011121314151617181920212223242526272829typedef RCFireExtinguisher *(^RCFireExtinguisherFactory)();@interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@property (nonatomic, copy, readonly) RCFireExtinguisherFactory fireExtinguisherFactory;@end@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory&#123; if (self = [super init]) &#123; ... _engine = engine; _fireExtinguisherFactory = [extFactory copy]; &#125; return self;&#125;- (void)recoverFromCrash&#123; if (self.fire != nil) &#123; RCFireExtinguisher * fireExtinguisher = self.fireExtinguisherFactory(); [fireExtinguisher extinguishFire:self.fire]; &#125;&#125;@end 工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下： 123456789101112131415161718@implementation RCRaceCar- (instancetype)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;&#123; if (self = [super init]) &#123; _engine = engine; _transmission = transmission; _leftFrontWheel = wheelFactory(); _leftRearWheel = wheelFactory(); _rightFrontWheel = wheelFactory(); _rightRearWheel = wheelFactory(); // 保留轮子工厂，之后还需要一个备胎。 _wheelFactory = [wheelFactory copy]; &#125; return self;&#125;@end 四、避免多余的配置如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。 在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。 为了配置我们的对象，将从 4 个点来收集我们的依赖： ①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中； ②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值； ③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。 ④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。 下面是关于赛车的简单初便利构造器 12345678910111213+ (instancetype)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency&#123; RCEngine * engine = [[RCEngine alloc] init]; RCTransmission * transmission = [[RCTransmission alloc] init]; RCWheel *(^wheelFactory)() = ^&#123; return [[RCWheel alloc] init]; &#125;; return [[self alloc] initWithEngine:engine transmission:transmission pitRadioFrequency:frequency wheelFactory:wheelFactory];&#125; 便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。 五、系统单例在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。 这里建议避免在你的代码中创建全局的单例，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。 六、不可修改的构造函数有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码： 12345// 一个我们不能直接调用初始化方法的例子。RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];// 我们仍然可以使用属性来配置我们的赛车路径raceTrack.width = 10;raceTrack.numberOfHairpinTurns = 2; setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。 七、类注册“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码： 123456789101112131415161718192021NSArray * raceCarClasses = @[ [RCFastRaceCar class], [RCSlowRaceCar class] ];NSMutableArray *raceCars = [[NSMutableArray alloc] init];for (Class raceCarClass in raceCarClasses) &#123; // 所有赛车必须有相同的初始化方法 (在这个例子中是 \"init\" 方法). // 这里意味着我们不能自定义不同的子类 [raceCars addObject:[[raceCarClass alloc] init]];&#125;// 一个简单的替换方法是：使用工厂 block 来代替typedef RCRaceCar *(^RCRaceCarFactory)();NSArray * raceCarFactories = @[ ^&#123; return [[RCFastRaceCar alloc] initWithTopSpeed:200]; &#125;, ^&#123; return [[RCSlowRaceCar alloc] initWithLeatherPlushiness:11]; &#125; ];NSMutableArray * raceCars = [[NSMutableArray alloc] init];for (RCRaceCarFactory raceCarFactory in raceCarFactories) &#123; // 现在这样，我们就不用关心到底是那个初始化方法被调用了 [raceCars addObject:raceCarFactory()];&#125; 八、StoryboardsStoryboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。 解决方法是避免使用 storyboard。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。 九、公有和私有依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。 12345678910111213141516// In public ObjectA.h.@interface ObjectA// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件- (instancetype)initWithObjectB:(ObjectB *)objectB;@end@interface ObjectB// 这里也一样：需要暴露 ObjectC.h- (instancetype)initWithObjectC:(ObjectC *)objectC;@end@interface ObjectC- (instancetype)init;@end 对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。 12345678910@interface ObjectA- (instancetype)initWithObjectB:(id &lt;ObjectB&gt;)objectB;@end// 这个协议只暴露 ObjectA 需要原始的 ObjectB。// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 @protocol ObjectB- (void)methodNeededByObjectA;@end 十、一次高效的依赖注入10.1 问题场景如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的： 这里依赖路径有两条： ①、主项目依赖第三方 pods。 ②、组件依赖第三方 pods，主项目再依赖组件。 单向的依赖关系决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，组件却没有办法主动和主项目通讯。 可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。 10.2 依赖注入依赖注入有另外一个名字，叫做“控制反转”。 像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。 所以依赖注入有两个比较重要的点： ①、要实现这种反转控制的功能。 ②、要解耦。 不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。 出自这篇文章：理解依赖注入与控制反转 10.3 iOS 依赖注入调查iOS 平台实现依赖注入功能的开源项目有两个大头：objection、typhoon。 详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。 还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。 那有没有其他没那么方案呢？libextobjc libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点： ①、充分使用了 OC 动态语言的特性，不侵入项目 ②、高度自动化 ③、框架十分轻量（只有一个 .h 和 .m 文件） ④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。 10.4 EXTConcreteProtocol 实现原理有两个比较重要的概念需要提前明白才能继续往下讲。 ①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。 ②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。 如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。 10.4.1 EXTConcreteProtocol 的使用比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。 1234567891011121314151617181920@protocol ObjectProtocol&lt;NSObject&gt;+ (void)sayHello;- (int)age;@end@concreteprotocol(ObjectProtocol)+ (void)sayHello&#123; NSLog(@\"Hello\");&#125;- (int)age &#123; return 18;&#125;@end 之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。 123@interface Person : NSObject&lt;ObjectProtocol&gt;@end 我们接下来就可以对 Person 调用注入的方法。 12345678int main(int argc, char * argv[]) &#123; Person * p = [Person new]; NSLog(@\"%@\", [p age]); [p.class sayHello];&#125;18Hello 10.4.2 源码解析先来看一下头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define concreteprotocol(NAME) \\ /* * create a class used to contain all the methods used in this protocol */ \\ // 定义一个容器类 interface NAME ## _ProtocolMethodContainer : NSObject &lt; NAME &gt; &#123;&#125; \\ @end \\ \\ @implementation NAME ## _ProtocolMethodContainer \\ /* * when this class is loaded into the runtime, add the concrete protocol * into the list we have of them */ \\ // load 方法添加混合协议 + (void)load &#123; \\ /* * passes the actual protocol as the first parameter, then this class as * the second */ \\ if (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), self)) \\ fprintf(stderr, \"ERROR: Could not load concrete protocol %s\\n\", metamacro_stringify(NAME)); \\ &#125; \\ \\ /* * using the \"constructor\" function attribute, we can ensure that this * function is executed only AFTER all the Objective-C runtime setup (i.e., * after all +load methods have been executed) */ \\ // 在 load 之后，main 之前执行方法注入 __attribute__((constructor)) \\ static void ext_ ## NAME ## _inject (void) &#123; \\ /* * use this injection point to mark this concrete protocol as ready for * loading */ \\ ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \\ &#125;/*** implementation details follow ***/// load 方法添加混合协议BOOL ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);// load 之后，main 之前执行方法注入void ext_loadConcreteProtocol (Protocol *protocol); 可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。 然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// contains the information needed to reference a full special protocoltypedef struct &#123; // the actual protocol declaration (@protocol block) 用户定义的协议. __unsafe_unretained Protocol *protocol; // the injection block associated with this protocol // // this block is RETAINED and must eventually be released by transferring it // back to ARC // 在 __attribute__((constructor)) 时往指定类里注入方法的 block. void *injectionBlock; // whether this protocol is ready to be injected to its conforming classes // // this does NOT refer to a special protocol having been injected already // 对应的协议是否已经准备好注入. BOOL ready;&#125; EXTSpecialProtocol;BOOL ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123; return ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123; ext_injectConcreteProtocol(protocol, containerClass, destinationClass); &#125;);&#125;BOOL ext_loadSpecialProtocol (Protocol *protocol, void (^injectionBehavior)(Class destinationClass)) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); NSCParameterAssert(injectionBehavior != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return NO; &#125; // if we've hit the hard maximum for number of special protocols, we can't // continue if (specialProtocolCount == SIZE_MAX) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; // if the array has no more space, we will need to allocate additional // entries // specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols. if (specialProtocolCount &gt;= specialProtocolCapacity) &#123; size_t newCapacity; if (specialProtocolCapacity == 0) // if there are no entries, make space for just one newCapacity = 1; else &#123; // otherwise, double the current capacity newCapacity = specialProtocolCapacity &lt;&lt; 1; // if the new capacity is less than the current capacity, that's // unsigned integer overflow if (newCapacity &lt; specialProtocolCapacity) &#123; // set it to the maximum possible instead newCapacity = SIZE_MAX; // if the new capacity is still not greater than the current // (for instance, if it was already SIZE_MAX), we can't continue if (newCapacity &lt;= specialProtocolCapacity) &#123; pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; &#125; &#125; // we have a new capacity, so resize the list of all special protocols // to add the new entries void * restrict ptr = realloc(specialProtocols, sizeof(*specialProtocols) * newCapacity); if (!ptr) &#123; // the allocation failed, abort pthread_mutex_unlock(&amp;specialProtocolsLock); return NO; &#125; specialProtocols = ptr; specialProtocolCapacity = newCapacity; &#125; // at this point, there absolutely must be at least one empty entry in the // array assert(specialProtocolCount &lt; specialProtocolCapacity); // disable warning about \"leaking\" this block, which is released in // ext_injectSpecialProtocols() #ifndef __clang_analyzer__ ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior copy]; // construct a new EXTSpecialProtocol structure and add it to the first // empty space in the array // 将协议保存为一个 EXTSpecialProtocol 结构体。 specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123; .protocol = protocol, .injectionBlock = (__bridge_retained void *)copiedBlock, .ready = NO &#125;; #endif ++specialProtocolCount; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125; // success! return YES;&#125; ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。 ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485static void ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class class) &#123; // get the full list of instance methods implemented by the concrete // protocol 获取容器类里所有的实例方法. unsigned imethodCount = 0; Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount); // get the full list of class methods implemented by the concrete // protocol 获取容器类里所有的类方法方法. unsigned cmethodCount = 0; Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount); // get the metaclass of this class (the object on which class // methods are implemented) 拿到要注入方法的类的元类. Class metaclass = object_getClass(class); // inject all instance methods in the concrete protocol 注入实例方法. for (unsigned methodIndex = 0;methodIndex &lt; imethodCount;++methodIndex) &#123; Method method = imethodList[methodIndex]; SEL selector = method_getName(method); // first, check to see if such an instance method already exists // (on this class or on a superclass) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(class, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this instance method to the class in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(class, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // inject all class methods in the concrete protocol 注入类方法. for (unsigned methodIndex = 0;methodIndex &lt; cmethodCount;++methodIndex) &#123; Method method = cmethodList[methodIndex]; SEL selector = method_getName(method); // +initialize is a special case that should never be copied // into a class, as it performs initialization for the concrete // protocol // +initialize 不能被注入. if (selector == @selector(initialize)) &#123; // so just continue looking through the rest of the methods continue; &#125; // first, check to see if a class method already exists (on this // class or on a superclass) // // since 'class' is considered to be an instance of 'metaclass', // this is actually checking for class methods (despite the // function name) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(metaclass, selector)) &#123; // it does exist, so don't overwrite it continue; &#125; // add this class method to the metaclass in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(metaclass, selector, imp, types)) &#123; fprintf(stderr, \"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn\", sel_getName(selector), protocol_getName(protocol), class_getName(class)); &#125; &#125; // free the instance method list 管理内存 free(imethodList); imethodList = NULL; // free the class method list free(cmethodList); cmethodList = NULL; // use [containerClass class] and discard the result to call +initialize // on containerClass if it hasn't been called yet // // this is to allow the concrete protocol to perform custom initialization // 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行. (void)[containerClass class];&#125; 我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142void ext_specialProtocolReadyForInjection (Protocol *protocol) &#123; @autoreleasepool &#123; NSCParameterAssert(protocol != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread_mutex_lock(&amp;specialProtocolsLock) != 0) &#123; fprintf(stderr, \"ERROR: Could not synchronize on special protocol data\\n\"); return; &#125; // loop through all the special protocols in our list, trying to find the // one associated with 'protocol' // 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; if (specialProtocols[i].protocol == protocol) &#123; // found the matching special protocol, check to see if it's // already ready if (!specialProtocols[i].ready) &#123; // if it's not, mark it as being ready now specialProtocols[i].ready = YES; // since this special protocol was in our array, and it was not // loaded, the total number of protocols loaded must be less // than the total count at this point in time assert(specialProtocolsReady &lt; specialProtocolCount); // ... and then increment the total number of special protocols // loaded – if it now matches the total count of special // protocols, begin the injection process if (++specialProtocolsReady == specialProtocolCount) // 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入. ext_injectSpecialProtocols(); &#125; break; &#125; &#125; pthread_mutex_unlock(&amp;specialProtocolsLock); &#125;&#125; 上面都是准备工作，接下来开始进入核心方法进行注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * This function actually performs the hard work of special protocol injection. * It obtains a full list of all classes registered with the Objective-C * runtime, finds those conforming to special protocols, and then runs the * injection blocks as appropriate. */static void ext_injectSpecialProtocols (void) &#123; /* * don't lock specialProtocolsLock in this function, as it is called only * from public functions which already perform the synchronization */ /* * This will sort special protocols in the order they should be loaded. If * a special protocol conforms to another special protocol, the former * will be prioritized above the latter. */ // 对协议进行排序. // 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的 load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现. // 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面. qsort_b(specialProtocols, specialProtocolCount, sizeof(EXTSpecialProtocol), ^(const void *a, const void *b)&#123; // if the pointers are equal, it must be the same protocol if (a == b) return 0; const EXTSpecialProtocol *protoA = a; const EXTSpecialProtocol *protoB = b; // A higher return value here means a higher priority int (^protocolInjectionPriority)(const EXTSpecialProtocol *) = ^(const EXTSpecialProtocol *specialProtocol)&#123; int runningTotal = 0; for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; // the pointer passed into this block is guaranteed to point // into the 'specialProtocols' array, so we can compare the // pointers directly for identity if (specialProtocol == specialProtocols + i) continue; if (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol)) runningTotal++; &#125; return runningTotal; &#125;; /* * This will return: * 0 if the protocols are equal in priority (such that load order does not matter) * &lt; 0 if A is more important than B * &gt; 0 if B is more important than A */ return protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA); &#125;); // 获取项目中所有的类 unsigned classCount = objc_getClassList(NULL, 0); if (!classCount) &#123; fprintf(stderr, \"ERROR: No classes registered with the runtime\\n\"); return; &#125; Class *allClasses = (Class *)malloc(sizeof(Class) * (classCount + 1)); if (!allClasses) &#123; fprintf(stderr, \"ERROR: Could not allocate space for %u classes\\n\", classCount); return; &#125; // use this instead of ext_copyClassList() to avoid sending +initialize to // classes that we don't plan to inject into (this avoids some SenTestingKit // timing issues) classCount = objc_getClassList(allClasses, classCount); /* * set up an autorelease pool in case any Cocoa classes get used during * the injection process or +initialize */ @autoreleasepool &#123; // loop through the special protocols, and apply each one to all the // classes in turn // // ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in // the order in which they appear in specialProtocols. Consider classes // X and Y that implement protocols A and B, respectively. B needs to get // its implementation into Y before A gets into X. // 遍历所有的要注入的协议结构体. for (size_t i = 0;i &lt; specialProtocolCount;++i) &#123; Protocol *protocol = specialProtocols[i].protocol; // transfer ownership of the injection block to ARC and remove it // from the structure // 使用 __bridge_transfer 把对象的内存管理交给 ARC. ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer id)specialProtocols[i].injectionBlock; specialProtocols[i].injectionBlock = NULL; // loop through all classes 遍历所有的类 for (unsigned classIndex = 0;classIndex &lt; classCount;++classIndex) &#123; Class class = allClasses[classIndex]; // if this class doesn't conform to the protocol, continue to the // next class immediately // 如果这个类遵守了要注入的协议，那么就执行注入 // 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法. if (!class_conformsToProtocol(class, protocol)) continue; injectionBlock(class); &#125; &#125; &#125; // 管理内存. // free the allocated class list free(allClasses); // now that everything's injected, the special protocol list can also be // destroyed free(specialProtocols); specialProtocols = NULL; specialProtocolCount = 0; specialProtocolCapacity = 0; specialProtocolsReady = 0;&#125; 这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 10.4.3 问题在哪？接下来讨论 EXTConcreteProtocol 的缺点。 如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。 这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。 这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。 10.5 解决方案从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。 那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。 但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。 如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。 ①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。 ②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。 ③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。 ④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。 https://github.com/newyjp/BLMethodInjecting 十一、结语依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。 十二、文章依赖注入——让iOS代码更简洁 [iOS]一次高效的依赖注入","tags":[]},{"title":"n 次方","date":"2019-08-05T16:07:52.648Z","path":"2019/08/06/算法/n次方/","text":"1、问题描述计算 an 2、算法分析先将 n 变一变，寻找新的计算路径。预处理就是变治法的根本。 如果单纯循环执行 n 次相乘，那么时间复杂度为 O(n)。可以利用二进制幂大大改进效率。 主要思路是：将十进制的 n 转换成二进制的数组序列 b[]。二进制幂求解有两种方法：从左至右二进制幂和从右至左二进制幂。 ①、从左至右二进制幂 变换：an = a(b[n]2m + … + b[0]20) 先求 n 的二进制串，如：n = 5 =&gt; 1 0 1，那么 b[2] = 1, b[1] = 0, b[0] = 1 二进制求 n 的伪代码： Horner(b[0…n], x)k = b[n]for i = n-1 downto 0 do p = x*k + b[i]return p 那么 n 用作 a 的指数时意义是什么样的呢： ap = a1for i = n - 1 downto 0 do ap = a(2p+b[i]) ②、从右至左二进制幂 n 变换方法与上面相同，然后从 b[0] -&gt; b[n] 方向逐步求解。 时间复杂度：O(logn) 3、代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/** * @brief 返回 x 的二进制串（数组） */int GetBinArray(int x, int arr[], int length)&#123; int idx = 0; while(x &gt; 0) &#123; // 获取末位的二进制 arr[idx++] = (x &amp; 1) ? 1 : 0; if (idx == length) break; // 右移两位 x = x &gt;&gt; 1; &#125; return idx;&#125;/** * @brief a^n = a^（b[n]2^n + ... + b[0]2^0）= a^（b[n]2^n）* ... * a^b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_RightToLeft(int number, int power)&#123; if (power == 0) return 1; int length = sizeof(int) * 8; // 32 int *pint = (int *)malloc(length); // 获取幂的二进制数组 length = GetBinArray(power, pint, length); int item = number; int ret = 1; for (int i = 0; i &lt; length; i++) &#123; // 二进制值为 1，计入结果 if (pint[i] == 1) ret *= item; item *= item; &#125; free(pint); return ret;&#125;/** * @brief a^n = a^（b[n]2^n + ... + b[0]2^0）=（（b[n]*2 + b[n-1]）*X + ....）2 + b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_LeftToRight(int number, int power)&#123; if (power == 0) return 1; int length = sizeof(int)*8; int *pint = (int *)malloc(length); length = GetBinArray(power, pint, length); int ret = number; for (int i = length - 1 - 1; i &gt;= 0; i--) &#123; ret *= ret; if(pint[i] == 1) ret *= number; &#125; free(pint); return ret;&#125;int main()&#123; int num = 8, power = 6; int ret1 = Pow_Bin_RightToLeft(num, power); int ret2 = Pow_Bin_LeftToRight(num, power); printf(\"Pow_Bin_RightToLeft: %d^%d == %d\\n\", num, power, ret1); printf(\"Pow_Bin_LeftToRight: %d^%d == %d\\n\", num, power, ret2); return 0;&#125;Pow_Bin_RightToLeft: 8^6 == 262144Pow_Bin_LeftToRight: 8^6 == 262144 文章：计算 n 次方–变治法","tags":[]},{"title":".pch","date":"2019-08-05T16:07:52.648Z","path":"2019/08/06/iOS/iOS原理/pch/","text":"Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的预编译头文件，pch 头文件的内容能被项目中的其他所有源文件共享和访问。Xcode 6.0之后则需要手动创建。 一、作用①、定义全局性宏； ②、引用全局性头文件； ③、根据运行环境，自动打开或者关闭日志输出功能。 二、优点①、PCH 文件的内容能被项目中的其他所有文件共享和访问，其它地方可直接使用，不用再手动重复定义或引用； ②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而提高编译速度。 三、缺点①、把类中使用的框架等放到 PCH 中，依赖关系不明确，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。 ②、大量的共用性不高的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长； 四、思考①、PCH 的目的是：提高编译速度，而不是少敲几行 #import； ②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用； ③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。 ④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。 ⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。 ⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。 ⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。 五、文章PCH 文件的优缺点 PCH文件的新建和其缺点","tags":[]},{"title":"isa 和 Class","date":"2019-08-05T16:07:52.647Z","path":"2019/08/06/iOS/iOS原理/isa 和 Class/","text":"一、Runtime 简介Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要由运行时来决定了。 C 语言中，函数的调用在编译期就会决定调用哪个函数。而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。 Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。 Objc 在三种层面上与 Runtime 系统进行交互： 1、通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。 2、通过 Foundation 框架的 NSObject 类定义的方法 在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。 在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。 123456789101112131415161718192021222324/** * 返回对象的类 */- (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'anObject.dynamicType' instead\");/** * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类 */- (BOOL)isKindOfClass:(Class)aClass;/** * 检查对象是否是某个类的实例 */- (BOOL)isMemberOfClass:(Class)aClass;/** * 检查对象能否响应指定的消息 */- (BOOL)conformsToProtocol:(Protocol *)aProtocol;/** * 检查对象是否实现了指定协议类的方法 */- (BOOL)respondsToSelector:(SEL)aSelector; 在 NSObject 的类中还定义了一个方法 1234/** * 返回指定方法实现的地址 IMP */- (IMP)methodForSelector:(SEL)aSelector; 3、通过对 Runtime 库函数的直接调用 关于库函数可以在 Objective-C Runtime Reference 中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。 具体设置如下： 如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。 二、NSObject 起源与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自objc4-680 NSObject 的定义如下： 12345typedef struct objc_class *Class;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 在 Objc2.0 之前，objc_class 源码如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 指向成员变量列表的指针 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 指向方法列表指针的指针 struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif &#125; OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。 动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。 关于 Category，推荐 2 篇文章可以仔细研读：深入理解Objective-C：Category、结合 Category 工作原理分析 OC2.0 中的 runtime 然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 objc_private。 123456789101112131415161718192021222324252627typedef struct objc_class *Class;typedef struct objc_object *id;@interface Object &#123; Class isa; &#125;@interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;struct objc_object &#123;private: isa_t isa;&#125;struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125;union isa_t &#123;&#125; 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。 objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。 objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论： Objective-C 中类也是一个对象。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。 object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。 2.1 isa12345678910111213141516171819202122232425262728293031323334353637union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;# if __arm64__ struct &#123; uintptr_t indexed : 1; // 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化 uintptr_t has_assoc : 1; // 是否有设置过关联对象，如果没有，释放时会更快 uintptr_t has_cxx_dtor : 1; // 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被弱引用指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中 uintptr_t extra_rc : 19; // 里面存储的值是引用计数 - 1 &#125;;# elif __x86_64__ struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;# else# endif&#125; isa 详解 在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 64 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 What is a meta-class in Objective-C? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。 类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系： 实线是 super_class 指针，虚线是 isa 指针。 Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。 每个 Class 都有一个 isa 指针指向唯一的 Meta class Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。 每个 Meta class 的 isa 指针都指向 Root class（meta）。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 iOS 程序 main 函数之前发生了什么 2.1.1 isa_t 结构体的具体实现接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。 12345678910111213struct objc_object &#123;private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor); ...｝ 那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 objc_object。 1234567891011121314151617inline voidobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline voidobjc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)&#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。 1234567891011121314151617181920212223242526272829303132333435# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;; ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图： 参数的说明： index 代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。 在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer 的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：关于 Tagged Pointer 技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64 架构中有 33 位可以存储类指针。源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解 isa这篇文章里面的 shiftcls 分析。 magic判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。123456inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;关于 x86_64 的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。#### 2.2 cache_t 的具体实现继续看源码1234567891011121314151617struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; // 分配用来缓存 bucket 的总数 mask_t _occupied; // 表明实际占用的缓存 bucket 的个数&#125;typedef unsigned int uint32_t;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bitstypedef unsigned long uintptr_t;typedef uintptr_t cache_key_t;struct bucket_t &#123;private: cache_key_t _key; IMP _imp;&#125;根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。cache_t 中的 bucket_t _buckets 其实就是一个散列表，用来存储 Method 的链表。Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。#### 2.3 class_data_bits_t 的具体实现源码实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;;在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。1class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags它为我们提供了便捷方法用于返回其中的 class_rw_t 指针：123class_rw_t *data() &#123; return bits.data();&#125;Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly在编译期，类的结构中的 class_data_bits_t data 指向的是一个 class_ro_t 指针：在运行时调用 realizeClass方法，会做以下 3 件事情：1. 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针2. 初始化一个 class_rw_t 结构体3. 设置结构体 ro 的值以及 flag最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。1234567891011121314struct method_t &#123; SEL name; // 方法名字 const char *types; // Type Encoding 类型编码 IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;;方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 Type Encoding。IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。整个运行时过程描述如下：更加详细的分析，请看@Draveness 的这篇文章深入解析 ObjC 中方法的结构到此，总结 objc_class 1.0 和 2.0 的差别。## 三、测试题1. [self class] 与 [super class]123456789101112@implementation Son : Father- (id)init&#123; if (self = [super init]) &#123; NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); &#125; return self;&#125;@endself 和 super 的区别： self 是类的一个隐藏参数，每个方法的实现的第一个参数即为 self。 super 并不是隐藏参数，它实际上只是一个“编译器标示符”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。在调用 [super class] 的时候，runtime 会去调用 objc_msgSendSuper 方法，而不是 objc_msgSend。1234567891011121314151617OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。objc_msgSendSuper 的工作原理应该是这样的：&gt; 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。那么 objc_msgSendSuper 最后就转变成1234567891011// 注意这里是从父类开始 msgSend，而不是从本类开始。objc_msgSend(objc_super-&gt;receiver, @selector(class))/// Specifies an instance of a class. 这是类的一个实例 __unsafe_unretained id receiver; // 由于是实例调用，所以是减号方法- (Class)class &#123; return object_getClass(self);&#125;由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。2. isKindOfClass 与 isMemberOfClass12345678910111213141516@interface Sark : NSObject@end@implementation Sark@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@\"%d %d %d %d\", res1, res2, res3, res4); &#125; return 0;&#125;先来分析一下源码这两个函数的对象实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj)&#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;inline Class objc_object::getIsa() &#123; if (isTaggedPointer()) &#123; uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; &#125; return ISA();&#125;inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;首先题目中 NSObject 和 Sark 分别调用了 class 方法。+ (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去调用当前类的 obj-&gt;getIsa()，最后在 ISA() 方法中获得 meta class 的指针。接着在 isKindOfClass 中有一个循环，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。[NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。&gt; isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。3. Class 与内存地址下面的代码会？Compile Error / Runtime Crash / NSLog…?12345678910111213141516171819202122@interface Sark : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end@implementation Sark- (void)speak &#123; NSLog(@\"my name's %@\", self.name);&#125;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak];&#125;@end这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？首先需要谈谈隐藏参数 self 和 _cmd 的问题。当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。难点一：能不能调用 speak 方法？12id cls = [Sark class]; void *obj = &amp;cls;答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。难点二：如果能调用 speak，会输出什么呢？很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。正确的答案会输出1my name is &lt;ViewController: 0x7ff6d9f31c50&gt;内存地址每次运行都不同，但是前面一定是 ViewController。why？我们把代码改变一下，打印更多的信息出来。12345678910111213141516171819- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj, &amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark, &amp;sark); [sark speak];&#125;我们把对象的指针地址都打印出来。输出结果：12345678ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8Sark class = Sark 地址 = 0x7fff543f5a88Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80my name is &lt;ViewController: 0x7fb570e2ad00&gt;Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78my name is (null)123// objc_msgSendSuper2() takes the current search class, not its superclass.OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);objc_msgSendSuper2 方法入参是一个 objc_super super。123456789101112131415/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;#endif所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。至此，Objc 中的对象到底是什么呢？实质：Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject，而对象的实例变量 void ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ 12345678910111213141516171819202122232425262728293031- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); NSString *myName = @\"halfrost\"; id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark,&amp;sark); [sark speak]; &#125;ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78Sark class = Sark 地址 = 0x7fff56a48a50Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48my name is halfrostSark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。 原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。 这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController： 1my name is &lt;ViewController: 0x7fb570e2ad00&gt; 其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？ obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。 LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示： x/ n、f、u 是可选的参数。 n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。 u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。 这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。 四、文章一缕殇流化隐半边冰霜 &amp; 神经病院Objective-C Runtime入院第一天–isa和Class","tags":[]},{"title":"iOS 页面流畅技巧","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS优化/iOS 页面流畅技巧/","text":"一、屏幕显示图像原理首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。 二、卡顿产生的原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。 三、CPU 资源消耗的原因和解决方案3.1 对象的创建对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以： ①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适； ②、如果对象不涉及 UI 操作，尽量放到后台线程去创建； ③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用； ④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去； ⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 3.2 对象调整对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer： ①、CALayer 内部没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源； ②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改； ③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3.3 对象销毁当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了： 12345NSArray * tmp = self.arr_data;self.arr_data = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 3.4 对象布局在后台线程提前计算好视图布局、并对视图的布局进行缓存。 不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。 3.5 Autolayout这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但对于复杂视图来说常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。 3.6 文本计算如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。 3.7 文本渲染屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。 显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制，尽管麻烦但优势强大： ①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）； ②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。 3.8 图片解码用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。 该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 3.9 图像的绘制是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致） 123456789101112- (void)display&#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 四、GPU 资源消耗原因和解决方案GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。 4.1 纹理的渲染所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。 4.2 视图的混合（Composing）当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。 所以应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 也可以把多个视图预先渲染为一张图片来显示。 4.3 图形的生成CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。 当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。 对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。 最彻底的做法：把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 五、文章幸运的芳1990 &amp; 浅谈iOS页面流畅技巧","tags":[]},{"title":"iOS 响应链","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 响应链/","text":"一、UIResponder app 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。 UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。 响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。 有时候可能会通过 UIResponder 来查找控件的父视图。 1234567891011121314151617181920212223242526272829/** * 通过遍历 UIView 上的响应链来查找当前顶部 vc */- (UIViewController *)firstVC&#123; for (UIView * next = self; next; next = next.superview) &#123; UIResponder * nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125;/** * 通过遍历 button 上的响应链来查找 cell */- (MyCell *)buttonTaped:(UIButton *)button&#123; UIResponder * responder = button.nextResponder; while (responder) &#123; if ([responder isKindOfClass:[MyCell class]]) &#123; MyCell * cell = (MyCell *)responder; break; &#125; responder = responder.nextResponder; &#125;&#125; 二、事件的第一响应者事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。 Touch event 第一响应者是触摸事件产生的 view Press event 第一响应者是焦点响应者。 Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象 ⚠️注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。 控件直接与它相关的 target 对象使用 action 消息通信。 当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。 如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。 三、事件的分发和传递 当iOS程序中发生触摸事件后，系统会将事件加入到 UIApplication 管理的一个任务队列中； UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。 UIWindow 将事件向下分发，即 UIView。 UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。 遍历子控件，重复以上两步。 如果没有找到，那么自己就是事件处理者。 如果自己不能处理，那么不做任何处理。 其中 UIView 不接受事件处理的情况主要有以下三种 alpha &lt; 0.01 userInteractionEnabled = NO hidden ＝ YES 这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果父视图不接受事件处理，那么子视图也不能接收事件。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。 四、hitTest:withEvent:1234/** * @return 本次点击事件需要的最佳 View */- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。 ⚠️注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。 当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。 把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。 如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢? 事件传递给窗口或控件的后，就调用 hitTest:withEvent: 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到找到最合适的 view 或者废弃事件。 12345678910111213141516171819202122232425- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; // ①、判断当前控件能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // ②、判断触摸点在不在当前控件内 if ([self pointInside:point withEvent:event] == NO) return nil; // ②、倒序遍历自己的子控件 NSInteger count = self.subviews.count; for (NSInteger i = count - 1; i &gt;= 0; i--) &#123; UIView * childView = self.subviews[i]; // 把当前控件上的坐标系转换成子控件上的坐标系 CGPoint childP = [self convertPoint:point toView:childView]; UIView * fitView = [childView hitTest:childP withEvent:event]; if (fitView) &#123; return fitView; // 找到了最合适的 view &#125; &#125; // 循环结束，表示没有比自己更合适的 view return self; &#125; 所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。 从后往前遍历子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。 视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。 如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。 如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。 如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。 如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。 四、pointInside:withEvent:1、判断触摸点是否在视图内。 1234/** * @brief 判断一个点是否落在范围内 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢? 扩大响应范围。 12345678910- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; /* Inset `rect' by `(dx, dy)' -- i.e., offset its origin by `(dx, dy)', and decrease its size by `(2*dx, 2*dy)'. CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10 */ bounds = CGRectInset(self.bounds, -10, -10); return CGRectContainsPoint(bounds, point);&#125; 不规则的点击区域 123456789101112131415/** * @brief 改变图片的点击范围 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; // 控件范围宽度 +40，高度 +40 CGRect bounds = CGRectInset(self.bounds, -20, -20); UIBezierPath * path1 = [UIBezierPath bezierPathWithRect:CGRectMake(-20, 0, 40, 120)]; UIBezierPath * path2 = [UIBezierPath bezierPathWithRect:CGRectMake(self.frame.size.width - 20, 0, 40, 120)]; if (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; CGRectContainsPoint(bounds, point))&#123; return YES; // 如果在 path 区域内返回 YES &#125; return NO;&#125; 可以看出： 在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。 不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。 在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。 五、响应者链响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。 在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。 1、改变响应链 可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。 UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。 UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。 -UIWindow 下一个响应者为 UIApplication 对象。 UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。 六、文章Using Responders and the Responder Chain to Handle EventsiOS开发 - 事件传递响应链iOS响应链（Responder Chain）","tags":[]},{"title":"iOS 单例","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 单例/","text":"一、单例介绍单例：该类在程序运行期间有且仅有一个实例。 1.1 单例的主要优点①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例； ②、因为类控制了实例化过程，所以类可以灵活更改实例化过程； ③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。 1.2 单例的主要缺点①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放； ②、单例不能继承。 二、单例的实现单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。 主要是做到以下几点： 防止调用 [[A alloc] init] 引起的错误防止调用 new 引起的错误防止调用 copy 引起的错误防止调用 mutableCopy 引起的错误 2.1 实现方式一 把所有可能出现的初始化方法做了相应的处理来其保证安全性 1234567891011121314151617181920212223242526272829+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 不能再使用 alloc 方法 // 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法 _sharedSingleton = [[super allocWithZone:NULL] init]; &#125;); return _sharedSingleton;&#125;// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.- (id)copyWithZone:(nullable NSZone *)zone&#123; return [Singleton sharedSingleton];&#125;// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.- (id)mutableCopyWithZone:(nullable NSZone *)zone &#123; return [Singleton sharedSingleton];&#125; 2.2 实现方式二 不做处理的情况下禁止外部调用 一些成熟的第三方代码的单例中也有使用该方法的。 123456789101112131415161718.h 文件- (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (id)copy NS_UNAVAILABLE;- (id)mutableCopy NS_UNAVAILABLE;.m 文件+ (instancetype)sharedSingleton&#123; static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _sharedSingleton = [[self alloc] init]; // 要使用 self 来调用 &#125;); return _sharedSingleton;&#125; 当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。 三、单例的滥用3.1 全局状态大多数的开发者都认同使用全局可变的状态是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。 12345678910@implementation SPMath&#123; NSInteger _a; NSInteger _b;&#125; - (NSInteger)add&#123; return _a + _b;&#125; 在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题： add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。 当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。 把下面的代码和上面的例子做对比: 1234+ (NSUInteger)addOf:(NSUInteger)a plus:(NSUInteger)b&#123; return a + b;&#125; 这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为类方法，这样就显式的告诉了代码的阅读者：这个方法不会修改任何实例的状态。 那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“单例就是披着羊皮的全局状态” 。 一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。 12345678910111213141516171819202122232425262728@interface Singleton : NSObject+ (instancetype)sharedInstance;- (NSString *)name;- (void)setName:(NSString *)name;@end@implementation A - (void)a &#123; if ([[Singleton sharedInstance] name]) &#123; // ... &#125;&#125;@end@implementation B- (void)b&#123; [[Singleton sharedInstance] setName:\"\"];&#125;@end 在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的共享状态来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致隐式的在两个看起来完全不相关的模块之间建立了耦合。 来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。 想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器： 123456@interface URLCache+ (NSCache *)sharedURLCache;- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;@end 这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。 几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？ 原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。 持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。 3.2 对象的生命周期另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。 假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例： 1234567@interface ThumbnailCache : NSObject+ (instancetype)sharedThumbnailCache;- (void)cacheProfileImage:(NSData *)imageData forUserId:(NSString *)userId;- (NSData *)cachedProfileImageForUserId:(NSString *)userId;@end 继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。 当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。 问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例： 123456789101112131415static ThumbnailCache * sharedThumbnailCache;+ (instancetype)sharedThumbnailCache&#123; if (!sharedThumbnailCache) &#123; sharedThumbnailCache = [[self alloc] init]; &#125; return sharedThumbnailCache;&#125;+ (void)cleanUp&#123; // The SPThumbnailCache will clean up persistent states when deallocated sharedThumbnailCache = nil;&#125; 这是一个明显的对单例模式的滥用，但是它可以工作，对吧。 当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作： 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];&#125;); 需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。 由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。 分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。 举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。 这里我们得到的教训是：单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。 四、避免使用单例既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？ 重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。 123456789101112131415@interface User : NSObject@property (nonatomic, readonly) ThumbnailCache * thumbnailCache;@end @implementation User- (instancetype)init&#123; if ((self = [super init])) &#123; _thumbnailCache = [[ThumbnailCache alloc] init]; &#125; return self;&#125;@end 现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。 现在假设我们有一个 VC 来展现好友列表： 12345@interface FriendListVC : UIViewController- (instancetype)initWithUser:(User *)user; @end 我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，并且它有很多优点： ①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。 ②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];&#125;); 这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。 为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。 假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示： vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。 当用户登出后，清理 rootViewController 并且退出到登录页面： 这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。 使用依赖注入的对象图： 简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了简化 applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示： 这个对象图看起来和使用单例时很像。这有什么区别？ 关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互： 当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态： 五、结论在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。 这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。 六、文章避免滥用单例","tags":[]},{"title":"iOS 项目发布","date":"2019-08-05T16:07:52.646Z","path":"2019/08/06/iOS/iOS原理/iOS 项目发布/","text":"一、Apple开发者账号1.1 开发者账号类型 个人级 公司级 企业级 公司和企业的可多人协作。 在苹果的开发者平台登录后，可在 People 界面邀请其他人员协作开发，邀请的人需要注册一个 appleId 账号，并且可以设置开发人员的权限。 1.2 辨别账号类型 个人级 账户的 Apple Developer Program 下方只有 Certificates，identifiers &amp; Profiles 和 App Store Connect 两个图标。 公司级 账户的 Apple Developer Program 下方包含 People、Certificates，identifiers &amp; Profiles 和 App Store Connect 三个图标。 图标一：邀请其他开发人员的入口 图标二：开发者证书、App ID 和描述文件生成的入口 图标三：将 APP 上传到 App Store 的入口 企业级 账户的 Apple Developer Enterprise Program 下方有People、Certificates，identifiers &amp; Profiles 两个图标，第一个图标邀请其他开发人员的入口，第二个图标是开发者证书、App ID和描述文件生成的入口。 1.3 账号对比 个人（Individual） 99 美元/年 只能上架到 App Store 最大支持 100 台设备 1 人使用 “个人”开发者可以申请升级成“公司”，通过拨打苹果公司客服电话（400-6701-855）进行咨询办理。 公司（Company） 99美元/年 只能上架到 App Store 最大支持 100 台设备 多人协作 允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为 4 种级别的权限。 申请时需要填写公司的邓白氏码（DUNS Number）。 企业（Enterprise） 299美元/年 不能上架到 App Store，只能企业内部使用。通过 item-services 分发来下载 不限制设备数 多人协作 允许多个开发者进行协作开发，比个人账号多一些账号管理设置，可以设置多个 Apple ID，分为4种级别的权限。 申请时需要填写公司的邓白氏码（DUNS Number）。 只能企业内部使用，否则有被封号的风险。 总结 个人级和公司级只能上架 App Store 供用户下载，企业级不能上架 App Store，只能放在自己的服务器或者三方平台； 个人/公司级账号可以将开发环境的包上传到自己的服务器，或者第三方平台。首先在开发者账号添加最多 100 个手机的 UUID，创建开发 developer 证书和描述文件，将它两下载到电脑上，双击安装，在 Xcode 选择开发证书打包。这种可调式（Debug）包的有效期也是一年，一年内需要重新创建证书，并更新 ipa 包，否则 APP 将闪退。注意：每次添加设备 UUID 需要重新生成描述文件。 企业级账号，每年至少重新打包 ipa 一次，更新 ipa 包中的证书信息，证书的有效期是一年，一年不更新，APP将闪退，无法进入。个人/公司级别的没有限制，只要成功上架到 App Store，如果没有特殊情况，理论可以放到苹果公司倒闭也不用去更新。 安装企业级账号分发的包后，需要去设置中信任 APP，系统级限制，无法跳过。个人/公司级没有该限制。 个人/公司必须经过苹果的人工审核才能在 App Store 上架，而企业级发布到自己服务器或者第三方平台是不需要审核的。 二、证书相关2.1 开发者证书总共有两种类型： Developer（开发证书） Distribution（发布证书） 不论是真机调试，还是上传到 appstore 都是需要的，是一个基证书，用来证明自己开发者身份的。 2.2 App ID 是一个 APP 的唯一标示，相当于人的身份证号 Description 是一个 App ID 的描述，可以随便 App ID Prefix 苹果自动填了，可以看出，它是一个团队的 ID Suffix App ID Suffix 有两个选项： Explicit App ID : 一个明确的 App ID，什么意思呢？可以这么来解释：我们做项目时的Bundle Identifier (Bundle ID)是用来标示我们的 app 的。我们的 App ID 也是用来标示我们的app 的。这两个有什么联系呢？Explicit App ID 就是要我们确定一个唯一的 Bundle ID，用来标示我们的 app，使它有一个固定的身份。可以发现，当提交应用到苹果时，如果我们一开始没写 Explicit App ID，苹果会自动帮我们生成一个与我们发布时填的一样的 Bundle ID 到我们的 App ID 中。填写 Explicit App ID 的格式为：com.xxx.yyy。 Wildcard App ID : 一个通配符的 App ID。这个 App ID 能够在所有能够匹配的应用中使用。填写 WildcardApp ID 的格式为：com.xxx.*。 手机安装 app 时，会先查找是否已有相同 App ID 的 app，如果没有，则直接进行安装；如果已有，则进行覆盖安装。 2.3 CSR 在苹果开发者中心生成证书时需要一个 CSR（证书签名请求）文件。 当创建 CSR 时，电脑系统实际上会生成公钥和私钥对。CSR 包含公钥。 Apple 使用该公钥来制作证书。证书或多或少是一种发布公钥的方式以及关于该密钥的一些相关信息，并且验证发布实体，表示该信息是有效的。 由于每个证书都有自己的公钥 - 私钥对，因此推送证书、开发发证书和发布证书都可以使用不同的 CSR，每个证书用于验证和保护该特定项目。 生成 CSR 文件步骤： 用户电子邮件地址随便填写，并不一定非要填写邮件格式，无实际作用 常用名字使用默认的就可以，也可以修改 选择存储到磁盘。 选择继续，保存到指定位置即可。最终得到一个 CertificateSigningRequest.certSigningRequest 文件，也就是 CSR 文件。该文件后缀名不要更改，文件名可自由指定。 CSR文件尽量每个证书都制作一次，将常用名称区分开来，因为该常用名称是证书中的密钥的名字。 2.4 .cer 在苹果开发者中心生成的证书，导出后就是 .cer 文件。.cer 证书仅包含公钥。 提交 CSR 文件后就会生成一个 cer 证书，有效期为一年。 证书不可轻易删除，可能会造成相应的 Provisioning Profiles 失效，尤其是企业级的发布证书，删除后已经安装在手机上的 APP 将会闪退。如果是一个团队大家都在用，把这个证书删除了，会导致别人的描述文件失效。 2.5 .p12 .p12证书可能既包含公钥也包含私钥。 双击安装下载后的 .cer 文件，都可以在钥匙串访问工具中导出 .p12 文件。 为什么要导出.p12文件？ 开发证书和发布证书是有数量限制的，当超过数量后再也申请不了。 多台电脑开发程序时，没必要生成很多的证书，导出证书生成的 .p12 文件，供给所有的 mac 设备使用，使新设备不需要在苹果开发者网站重新申请开发和发布证书，就能使用。 点击 .p12 文件加入钥匙串中，使我们的电脑具备开发的证明。 注意：一般 .p12 文件是给别人使用的，本机必须已经有一个带秘钥的证书才可以生成.p12文件。 2.6 描述文件 Profiles 将 App ID、开发者证书、硬件 Device 绑定到一块儿。 在开发者中心配置好后可以添加到 Xcode 上，也可以直接在 Xcode 上连接开发者中心生成，真机调试时需要在描述文件中添加真机的 UDID。 2.7 邓白氏码 邓氏编码（D-U-N-S® Number，是 Data Universal Numbering System的缩写）。它是一个独一无二的 9 位数字全球编码系统，相当于企业的身份识别码，被广泛应用于企业识别、商业信息的组织及整理。可以帮助识别和迅速定位全球 2.4 亿家企业的信息。 三、打包上传3.1 payload适用于开发阶段。操作步骤： 选中 target -&gt; edit Scheme，修改 run 操作的 Build Configuration 是 budeg/release。 真机运行工程，在左侧工程目录 -&gt; Products 找到 .app 文件，show in Finder。 桌面生成一个名为 Payload 的空文件夹，将 .app 文件拖入其中。 压缩 Payload 文件夹，修改后缀名为 .ipa，此时就可以将包上传 fir.im 网站，进行提测。 3.2 Archive 常规打包方式 运行设备选择 Generic iOS Device 或者真机，顶部 Xcode 导航栏 -&gt; Product -&gt; Archive。 命令行使用 xcodebuild 自动打包 ①、clean 工程 12345$ cd Desktop/CYKJ/CYKJMain/CYKJMain/$ xcodebuild clean -project CYKJMain.xcodeproj -scheme CC -configuration Release$ xcodebuild clean -workspace CYKJMain.xcworkspace -scheme CC -configuration Release 如果工程使用了 pod，选择 -workspace，否则使用 -project。 上面的命令中： -project CYKJMain.xcodeproj : 编译项目名称 -workspace CYKJMain.xcworkspace : 编译工作空间名称 -scheme CC : scheme 名称 -configuration Release : (Debug/Release) clean 成功： ②、archive 导出 .xcarchive 文件 123$ xcodebuild archive -project CYKJMain.xcodeproj -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive$ xcodebuild archive -workspace CYKJMain.xcworkspace -scheme CC -archivePath /Users/cykj/Desktop/cc.xcarchive 上面的命令中： -archivePath /Users/cykj/Desktop/cc.xcarchive : 导出 .xcarchive 文件的目录以及文件名称 archive 成功： ③、导出 ipa 包 1$ xcodebuild -exportArchive -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc -exportFormat ipa -exportProvisioningProfile \"developmentProfile\" 上面的命令中: &gt; -archivePath /Users/cykj/Desktop/cc.xcarchive : 刚刚导出的 .xcarchive 文件的目录 &gt; &gt; -exportPath /Users/cykj/Desktop/cc : 将要导出的 ipa 文件的目录以及文件名 &gt; &gt; -exportFormat ipa : 导出为ipa文件 &gt; &gt; -exportProvisioningProfile &quot;developmentProfile&quot; : 工程配置的 profile 文件的名称 &lt;font color=#cc0000&gt;``xcodebuild: error: invalid option ‘-exportFormat’``&lt;/font&gt; 报错原因：Xcode8 之后，对之前的 exportFormat 方式不再支持。 解决方法：不使用 exportFormat ipa 引入 ``exportOptionsPlist``。 1$ xcodebuild -exportArchive -archivePath &quot;$&#123;ARCHIVEPATH&#125;/$&#123;TARGET_NAME&#125;.xcarchive&quot; -exportPath $&#123;EXPORTPATH&#125; -exportOptionsPlist $&#123;EXPORTOPTIONSPLIST&#125; 直接使用 xcodebuild -help 查看 exportOptionsPlist。 1234567891011121314151617181920212223242526272829303132333435363738394041Available keys for -exportOptionsPlist:compileBitcode : Bool For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.embedOnDemandResourcesAssetPacksInBundle : Bool For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.iCloudContainerEnvironment For non-App Store exports, if the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options: Development and Production. Defaults to Development.manifest : Dictionary For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on demand resources.method : String Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.onDemandResourcesAssetPacksBaseURL : String For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&apos;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.teamID : String The Developer Portal team to use for this export. Defaults to the team used to build the archive.thinning : String For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.uploadBitcode : Bool For App Store exports, should the package include bitcode? Defaults to YES.uploadSymbols : Bool For App Store exports, should the package include symbols? Defaults to YES. plist 格式： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;xxxx&lt;/string&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;app-store&lt;/string&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.xxx.yyy&lt;/key&gt; &lt;string&gt;&#123;iOS Provisioning Profiles Name&#125;&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 命令行： 1$ xcodebuild -exportArchive -exportOptionsPlist /Users/cykj/Desktop/cc.plist -archivePath /Users/cykj/Desktop/cc.xcarchive -exportPath /Users/cykj/Desktop/cc 导出 ipa 成功： &lt;center&gt;![](http://dzliving.com/XCodeBuildIPA.png)&lt;/center&gt; &lt;font color=#cc0000&gt;``Error Domain=IDEProfileLocatorErrorDomain Code=4 &quot;No &quot;iOS App Development&quot;``&lt;/font&gt; 问题原因：plist 文件中提供的 mehtod 的 value 不对。 3.3 Application Loader当已经生成了 ipa 包时，可以通过 Application Loader 将包 upload 至 AppStore，操作步骤如下： 登录 Application Loader。路径：Xcode -&gt; Open Developer Tool -&gt; Application Loader 这里需要注意的是，密码不是与 Apple ID 对应的用于登录 AppStore 的密码，而是 App 专用密码，获取地址：https://appleid.apple.com/account/manage 上传 ipa 包 登录成功后，需要导入 ipa 包，经过 Application Loader 的检查之后，即可上传 AppStore。 报错 bundle = 209 的包已经在 itunes connect 上有了，新上传的包需要在此 bundle 号的基础上增加，然后重新 upload。 四、打包审核注意 检查 Version 修改 BundleID 修改 Build 号 修改 pch 文件及其他宏定义。可以处理成代码自动根据 BundleID 识别当前为开发环境/发布环境 修改证书及描述文件为发布环境 询问设计人员是否要更换启动图、应用图标、市场图 五、Apple Store Connect5.1 新建 APP 名称 套装 ID：即 Bundle ID，显示在开发者中心中创建好 App ID。 SKU：与 Bundle ID 一样即可 注意：这些信息在创建好 App 后是不能修改的，需要修改的话，只能新建一个 App 替代。点击更多阅读 5.2 添加 App 版本填写信息： 此版本的新增内容。如果当前是第一个上线版本，则没有这一项。 App 预览和屏幕快照。每个版本发布时，记得询问设计人员市场图是否有更新。 关键词。在市场中搜索时有用，可以做优化。 技术支持网址。可以填写公司官网地址。 描述。对 app 进行说明，可以包括公司概述、功能介绍、联系方式等。 版权 商务代表联系信息 App 审核信息。 5.3 导入此构建版本时出错upload 包后，在 itunes connect 中等待处理后，查看发现报错： 报错后，着急去排查工程里面是否有配置问题，排查一圈之后，准备重新打包 upload。就在这时，刷新 itunes connect 网页看一下状态，发现报错的已经正常了，直接用那个包提交，不用重新打包了。点击更多阅读 5.4 IDFA提交审核时，IDFA 选择“否”，报错： 百度查找文章发现原因 着手排查工程中是否使用了 IDFA 并引入 AdSupport.framework，如果有则移除。终端使用命令： 12$ cd 项目目录$ grep -r advertisingIdentifier . 用这条命令检测自己的工程，如果没有查到相关引用，那么就不要勾选使用 IDFA，如果查到了相关引用，并且这些文件是用于展现广告的用途，那么勾选使用了 IDFA。 log 显示极光中有使用。百度搜索“极光 IDFA”问题，跳转到极光社区，找到文章：iOS审核时需要勾选IDFA吗？ 根据官方人员的说明，使用不带用 advertisingIdentifier 字段的方法。兴致勃勃的重新打包，等待了 10-20 分钟左右的时间，重新提交审核，IDFA 选择“否”，依然报错。 已经删除了工程中导入的 AdSupport.framework，不应该啊。 再次进行排查。将 ipa 包导出到本地，修改后缀名为 .zip，解压后使用终端命令： 12$ cd ipa解压后的文件目录$ grep -r AdSupport.framework . log 显示百度统计 sdk 中导入了 AdSupport.framework，百度搜索后跳转官方网站：iOS SDK采集IDFA注意事项 百度官方的意思是设置 IDFA 为 YES 并勾选。 考虑到上线紧迫，最后决策：移除百度统计相关代码，打包 upload。 六、文章Benjamin丶 &amp; Apple开发者账号介绍及证书配置说明PersonChen_QJ &amp; iOS申请邓白氏编码图文流程用于创建开发人员或分发证书和推送证书的CSR（证书签名请求）文件是否必须相同？2019年最新苹果企业开发者账号创建证书完整流程MrCoderLin &amp; Payload文件压缩法打包ipa咖啡绿茶1991 &amp; iOS命令行自动打包(archive)iOS自动化打包Xcode9 xcodebuild 命令行打包遇到的坑与解决方案一键打包完整Shell脚本xcodebuild archiveiOS 如何填App Store Connect信息iOS提交审核：您的 App 正在使用广告标识符 (IDFA)","tags":[]},{"title":"iOS 内置图片瘦身","date":"2019-08-05T16:07:52.645Z","path":"2019/08/06/iOS/iOS优化/iOS 内置图片瘦身/","text":"一、iOS 内置资源的集中方式1.1 将图片存放在 bundle这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到隔离资源的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。 这种方式有比较明显的缺点： ①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。 ②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。 在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。 下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下： 以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。 1.2 使用 .ttf 字体文件替代图标使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。 使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。 字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。 123UILabel * iconLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];iconLabel.font = [UIFont fontWithName:@\"icomoon\" size:50];iconLabel.text = [NSString stringWithUTF8String:\"\\ue902\"]; 由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。 优点： ①、可以降低应用图片内置资源的体积。 ②、可以随意缩放和修改颜色。 缺点： ①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。 ②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。 任何一种需要大刀阔斧改革的优化都是一种不明智的行为。 1.3 图片存在 Assets.xcassets使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。 二、优化项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。 为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。 与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。.framework 中可以存放资源，但 .a 不可以，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。 优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。 先要抛出两个问题： &emsp;①、cocoapods 是否支持使用 Assets.xcassets。 &emsp;②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。 为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数： 1234567s.source_files ：源文件路径。s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。s.resources ：资源文件路径及文件类型。s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。 实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。 如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。 查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。 最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。 运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。 既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案： ①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。 ②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。 ③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。 ④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。 只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示： 看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。 为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如 很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。 123456789- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); return value;&#125; 打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。 在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。 这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息： 重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。 12345678910111213141516171819202122- (id)swizzle_decodeObjectForKey:(NSString *)key&#123; Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (*functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @\"emaNecruoseRIU\"; // 反转字符串 propKey = [XUtil stringByReversed:propKey]; if ([key isEqualToString:propKey]) &#123; if (normal_imageName) &#123; select_imageName = value; &#125; else &#123; normal_imageName = value; &#125; &#125; return value;&#125; hook UIImageView 的 initWithCoder: 12345678910111213141516171819202122- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder&#123; // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)[self swizzle_imageView_initWithCoder:aDecoder]; if (normal_imageName &amp;&amp; [normal_imageName isKindOfClass:[NSString class]] &amp;&amp; normal_imageName.length &gt; 0) &#123; UIImage * normalImage = [HookTool imageAfterSearch:normal_imageName]; // 赋值 if (normalImage) &#123; instance.image = normalImage; &#125; normal_imageName = nil; select_imageName = nil; &#125; return instance;&#125; 上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。 但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对增加了项目维护的难度。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。 hook method_exchangeImplementations 方法。 检测方法（字典写入时不要忘了加锁）。 这种方式不能区分 image 和 backgroundImage、normal 和 Selected。目前根据观察顺序应该是： 1234UIResourceName ： normal - image(前景图)UIResourceName ： normal - backgroundImage(背景图)UIResourceName ： selected - image(前景图)UIResourceName ： selected - backgroundImage(背景图)","tags":[]},{"title":"Category","date":"2019-08-05T16:07:52.644Z","path":"2019/08/06/iOS/iOS原理/iOS Category/","text":"分类可以拓展类的属性、方法、协议等信息 一、底层结构在 objc-4 的源码中，搜索 category_t 可以看到: 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。 在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： objc-os.mm _objc_init() map_images() map_images_nolock() objc-runtime-new.mm _read_images() remethodizeClass() attachCategories() attachLists() realloc、memmove、memcpy 最终可以找到这个方法 attachCategories 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); // 判断是否元类 bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /* 方法数组 @[ @[method_t, method_t], @[method_t .....] ] */ method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); /* 属性数组 @[ @[property_t, property_t], @[property_t .....] ] */ property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); /* 协议数组 @[ @[peotocol_t, peotocol_t], @[peotocol_t .....] ] */ protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) &#123; auto&amp; entry = cats-&gt;list[I]; // 将所有分类的对象方法，附加到类对象列表中 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= entry.hi-&gt;isBundle(); &#125; // 将所有分类的属性，附加到类属性列表中 property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) &#123; proplists[propcount++] = proplist; &#125; // 将所有分类的协议，附加到类协议列表中 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; &#125; &#125; auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists);&#125; 这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。 二、Category和Class Extension 的区别Class Extension: 1234@interface Person ()@property (nonatomic, assign) int sex;- (void)isBig;@end 将属性、方法等封装在 .m 文件里面，类似 private 的应用。 区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。 三、+ Load 和 +initialize 方法的区别Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次） 四、objc_msgSend() 方法实现在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的 12345678910111213141516171819202122232425262728/******************************************************************** * * id objc_msgSend(id self, SEL _cmd, ...); * IMP objc_msgLookup(id self, SEL _cmd, ...); * * objc_msgLookup ABI: * IMP returned in x17 * x16 reserved for our use but not used * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 ENTRY _objc_msgSend UNWIND _objc_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, [x0] // x13 = isa and x16, x13, #ISA_MASK // x16 = class 但是可以大概猜出它的实现思路: 由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断； 通过 isa 寻找类/元类对象，寻找方法调用； 如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。 五、文章宁夏灼雪__ &amp; iOS底层day4 - 探索Category的实现","tags":[]},{"title":"UITableView优化","date":"2019-08-05T16:07:52.644Z","path":"2019/08/06/iOS/iOS优化/UITableView优化/","text":"一、Cell 复用在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 解决方案：创建一个静态变量 reuseID，防止重复创建（提高性能），使用系统的缓存池功能。 123456789static NSString * CELL_RUID = @\"CELL\"; // 调用次数太多，static 保证只创建一次 reuseID，提高性能- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; // 缓存池中取已经创建的 cell UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID forIndexPath:indexPath]; return cell;&#125; 通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。 12- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 复用 Cell 时 不会调用 awakeFromNib。 获取方法的区别 dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示： 1reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard' dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示： 1failed to obtain a cell from its dataSource 判断 nil 后可以自己创建 cell。 123456&#123; MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot;]; if (cell == nil) &#123; cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;]; &#125;&#125; 为什么需要 forIndexPath: 因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。 我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。 注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。 二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的。 好处： ①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（多个 Cell 不是更容易维护？） ②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。 既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。 尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。 三、提前计算并缓存 Cell 的高度3.1 固定高度的 cell1self.tableView.rowHeight = 88; 直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。 3.2 动态高度的 cell实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。 tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。 解决方案：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。 12345678910@interface Model : NSObject@property (nonatomic, assign) CGFloat cellHeight; // Cell 高度/** * @brief 计算高度 */ - (void)calculateCellHeight;@end 在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。 还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。 四、异步绘制（自定义 Cell 绘制）遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。详细整理：UITableView 优化技巧 123456789101112131415161718/** * @brief cell 添加 draw 方法 */- (void)draw&#123; // 异步绘制 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; &#125;);&#125;/** * @brief 重写 drawRect: 方法 */- (void)drawRect:(CGRect)rect&#123; // 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。&#125; 绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。 五、滑动时，按需加载自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。 123456789101112131415161718192021222324252627282930313233343536- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (needLoadArr.count &gt; 0 &amp;&amp; [needLoadArr indexOfObject:indexPath] == NSNotFound) &#123; [cell clear]; // 清掉内容 &#125; return cell;&#125;// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset&#123; NSIndexPath * ip = [self.tableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath * cip = [[self.tableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 8; // -8 &lt; 当前位置 - 目标位置 &lt; 8 if (labs(cip.row - ip.row) &gt; skipCount) &#123; // 目标区域的 cell 的 indexPaths NSArray * temp = [self.tableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.tableView.frame.size.width, self.tableView.frame.size.height)]; NSMutableArray * arr = [NSMutableArray arrayWithArray:temp]; if (velocity.y &lt; 0) &#123; NSIndexPath * indexPath = [temp lastObject]; if (indexPath.row + 33) &#123; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 3 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 2 inSection:0]]; [arr addObject:[NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0]]; &#125; &#125; [needLoadArr addObjectsFromArray:arr]; &#125;&#125; 思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。 六、缓存 View当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。 七、尽量显示“大小刚好合适的”图片资源避免大量的图片缩放、颜色渐变等。 八、避免同步的从网络、文件获取数据Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。 九、渲染1、减少 subviews 的个数和层级 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。 2、少用 subviews 的透明图层 渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。 3、背景色不要使用 clearColor 4、避免 CALayer 特效（shadowPath） 给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿： 1234view.layer.shadowColor = color.CGColor;view.layer.shadowOffset = offset;view.layer.shadowOpacity = 1;view.layer.shadowRadius = radius; 5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。 十、总结UITableView 的优化主要从四个方面入手： 1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法； 2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage； 3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。 大概需要关注的： 1、cell 复用 2、cell 高度的计算 3、渲染（混合问题） 4、减少视图的数目（重写 drawRect:） 5、减少多余的绘制操作 6、不要给 cell 动态添加 subView 7、异步化 UI，不要阻塞主线程 8、滑动时按需加载对应的内容 十一、资料图片加载优化官方 Demo：LazyTableImages 文章：提升 UITableView 性能-复杂页面的优化 代码：VVeboTableViewDemo","tags":[]},{"title":"0-1 背包","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/算法/01-背包/","text":"01 背包问题是用来介绍动态规划算法最经典的例子。 一、解释 1①、状态方程 f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] } ( j &gt;= Wi ) f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。 决策：为了背包中物品总价值最大化，第 i 件物品应该放入背包中吗 ？ ②、实例 假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。 只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。 首先要明确这张表是至底向上，从左到右生成的。 用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。 对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。 同理 c2 = 0，b2 = 3，a2 = 6。 对于承重为 8 的背包，a8 = 15 是怎么得出的呢？ 根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。 f[i-1, j] 表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 Pi 指的是 a 物品的价值，即 6。 由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。 ③、代码 物品信息类 12345678910111213141516171819202122232425@interface PackageItem : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger weight;@property (nonatomic, assign) NSInteger value;- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;@end@implementation PackageItem- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value&#123; if (self = [super init]) &#123; self.name = name; self.weight = weight; self.value = value; &#125; return self;&#125;@end 非递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]; for(int i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; &#125; [self packageAlgorithm:bagItems bagSize:10];&#125;/** * @brief 01 背包算法 */- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize&#123; if (bagSize == 0 || bagItems.count == 0) return; NSInteger bagMatrix[bagSize][bagItems.count]; // 是否选中数组 PackageItem * item; NSInteger i = 0; // 背包容量，列数 NSInteger j = 0; // 物品数量，行数 // 初始化数组 for (; i &lt;= bagSize; i++) &#123; for (j = 0; j &lt; bagItems.count; j++) bagMatrix[i][j] = 0; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); for (i = 0; i &lt;= bagSize; i++) &#123; // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取 for (j = bagItems.count - 1; j &gt; -1; j--) &#123; item = bagItems[j]; // 装不下 if (item.weight &gt; i) &#123; // 价值总和为 0 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = 0; &#125; // 价值总和为之前项的和 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = bagMatrix[i][j+1]; &#125; &#125; // 能装下 else &#123; // 是第一个物品，保存起来 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = item.value; &#125; // 非第一个物品，求最大值 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value); &#125; &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(&quot;%ld &quot;, (long)bagMatrix[i][j]); printf(&quot;\\n&quot;); &#125; NSInteger curSize = bagSize; // 当前能装的空间 NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]; // 以 a、b、c、d、e 的顺序获取 for (j = 0; j &lt; bagItems.count; j++) &#123; item = bagItems[j]; // 剩下能装的空间为 0 if (curSize == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123; [answer addObject:item.name]; curSize -= item.weight; &#125; &#125; NSLog(@&quot;%@&quot;, answer);&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 9 9 12 12 15 15 15 0 0 3 3 6 6 9 9 9 10 11 0 0 0 0 6 6 6 6 6 10 11 0 0 0 0 6 6 6 6 6 10 10 0 0 0 0 6 6 6 6 6 6 6 2019-01-25 22:12:03.795695+0800 Demo[1750:32295] ( a, b, e) 二、解释 2①、状态方程 max.F(n,C,x). x∈0,1 展开公式： F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn x1∗w1 + x2∗w2 + … + xn∗wn ≤ C xi∈0,1 x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。 我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够自动组合 x 的取值使得 F(n,c,x) 达到最大。 再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。 如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。 B(n, C) = B(n−1, C); 没有多余的空间去放置最后一个物品 B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn }; 如果有多余的空间去放置，则考虑是否要放置 B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。 ②、实例 w = {1, 2} v = {1, 2} C = 2 解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。 拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2 不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。 然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2 ③、递归代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; NSArray * nameArr = @[ @&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot; ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]; for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; // a、b、c、d、e selectedArray[i] = @(0); &#125; NSLog(@&quot;%ld&quot;, (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]); [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123; if (obj.integerValue) &#123; NSLog(@&quot;%@ &quot;, nameArr[idx]); &#125; &#125;];&#125;/** * @brief 01 背包算法。递归方式 */- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize&#123; if (bagItems.count == 0 || bagSize == 0 || bagNo == 0) return 0; PackageItem * item = bagItems[bagNo - 1]; // 装不下 if (bagSize &lt; item.weight) &#123; // 在剩余的物品中查找 return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; &#125; else &#123; NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value; if (more &lt; less) &#123; selectedArray[bagNo - 1] = @(1); // 拿 &#125; else &#123; selectedArray[bagNo - 1] = @(0); // 不拿 &#125; return MAX(more, less); &#125;&#125;2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 152019-01-26 00:11:13.897903+0800 Demo[3618:88346] a2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e 三、DP 优于递归的好处动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。 四、学习文章动态规划之 01 背包问题（最易理解的讲解）一文彻底搞懂01背包算法DP——01背包问题使用迭代和动态规划","tags":[]},{"title":"NSDateFormatter性能","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/iOS/iOS优化/NSDateFormatter性能/","text":"一、探究123NSDateFormatter * dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];NSString * current = [dateFormatter stringFromDate:[NSDate date]]; 关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。 1234567891011121314151617181920212223242526272829303132333435363738394041double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = nil;&#123; begin = CACurrentMediaTime(); for (int i = 0; i &lt; 1000; i++) &#123; formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter: %8.2f ms\", (end - begin) * 1000);&#125;&#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); NSLog(@\"NSDateFormatter once: %8.2f ms\", (end - begin) * 1000);&#125;-----------Xcode 10.1 iPhone 6s(10.0)----------2019-03-01 10:08:42.184 Demo[95118:1359994] NSDateFormatter: 48.73 ms2019-03-01 10:08:42.188 Demo[95118:1359994] NSDateFormatter once: 3.57 ms2019-03-01 10:11:18.871 Demo[95164:1361958] NSDateFormatter: 61.18 ms2019-03-01 10:11:18.875 Demo[95164:1361958] NSDateFormatter once: 3.85 ms2019-03-01 10:12:03.123 Demo[95178:1362677] NSDateFormatter: 79.80 ms2019-03-01 10:12:03.129 Demo[95178:1362677] NSDateFormatter once: 6.08 ms 上面可以看出两者之间消耗时间差距很大。创建单例很有必要。 那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？ 123456789101112131415161718192021222324252627282930313233343536373839NSDateFormatter * formatter = nil;double begin = 0.0;double end = 0.0;double a = 0, b = 0, c = 0;for (int i = 0; i &lt; 1000; i++) &#123; begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; end = CACurrentMediaTime(); a += (end - begin); begin = CACurrentMediaTime(); [formatter setDateFormat:@\"yyyy-MM-dd\"]; end = CACurrentMediaTime(); b += (end - begin); begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); c += (end - begin);&#125;NSLog(@\"NSDateFormatter:alloc %8.2f ms\", a * 1000);NSLog(@\"NSDateFormatter:setFormat %8.2f ms\", b * 1000);NSLog(@\"NSDateFormatter:stringFromDate %8.2f ms\", c * 1000);-------------Xcode 10.1 iPhone 6s(10.0)-------------2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:alloc 7.01 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:setFormat 0.28 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:stringFromDate 55.98 ms2019-03-01 10:12:03.198 Demo[95178:1362677] NSDateFormatter:alloc 7.69 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:setFormat 0.25 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:stringFromDate 60.97 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:alloc 6.01 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:setFormat 0.20 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:stringFromDate 49.06 ms 从上面可以看出，实际最耗时的方法是 stringFromDate:/dateFromString:。再往下细究。 1234567891011121314151617181920212223242526272829303132double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; begin = CACurrentMediaTime(); [formatter stringFromDate:[NSDate date]]; end = CACurrentMediaTime(); NSLog(@\"%8.2f ms\", (end - begin) * 1000);&#125;-------------Xcode 10.0 iPhone 6s(10.0)-------------2019-03-01 10:27:06.218 Demo[95456:1372764] 1.43 ms2019-03-01 10:27:06.218 Demo[95456:1372764] 0.03 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms 从上面可以看出，只有首次调用 stringFromDate:/dateFromString: 方法才会很耗时。再往下细究。 还有人说应该针对 format 格式创建对应的单例对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double begin = 0.0;double end = 0.0;// 不同的对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter1 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter2 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter3 = [[NSDateFormatter alloc] init]; NSDateFormatter * formatter4 = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter1 setDateFormat:@\"yyyy-MM-dd\"]; [formatter1 stringFromDate:[NSDate date]]; [formatter2 setDateFormat:@\"MM-dd-yyyy\"]; [formatter2 stringFromDate:[NSDate date]]; [formatter3 setDateFormat:@\"MM-dd\"]; [formatter3 stringFromDate:[NSDate date]]; [formatter4 setDateFormat:@\"MM-yyyy\"]; [formatter4 stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: different format %8.2f ms\\n\", (end - begin) * 1000);&#125;// 同一个对象不同的 format 格式&#123; begin = CACurrentMediaTime(); NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) &#123; [formatter setDateFormat:@\"yyyy-MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd-yyyy\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-dd\"]; [formatter stringFromDate:[NSDate date]]; [formatter setDateFormat:@\"MM-yyyy\"]; [formatter stringFromDate:[NSDate date]]; &#125; end = CACurrentMediaTime(); printf(\"NSDateFormatter: %8.2f ms\\n\", (end - begin) * 1000);&#125;---------------Xcode 10.1 iPhone 6s(10.0)---------------NSDateFormatter: different format 23.26 msNSDateFormatter: 16.25 ms 如果不计 NSDateFormatter 对象的初始化时间，那么打印输出： 12NSDateFormatter:different format 23.81 msNSDateFormatter: 23.02 ms 两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。 二、文章NSDateFormatter 性能测试","tags":[]},{"title":"Runtime","date":"2019-08-05T16:07:52.643Z","path":"2019/08/06/iOS/iOS原理/Runtime/","text":"一、简介C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。函数标识与函数实现之间的关联可以动态修改。 OC 把一些决定工作从编译链接推迟到运行时，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。 Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事： 封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。 传递消息，找出方法的最终执行代码。 ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）； ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发） 动态加载：NSBundle类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。 1234[receiver message]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)[receiver message:(id)arg...]; // 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...) Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。 当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。runtime源码，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。 二、作用Objc 与 Runtime 相关： ①、通过 Objective-C 源代码②、通过 Foundation 框架的 NSObject 类定义的方法③、通过对 Runtime 库函数的直接调用 2.1 Objective-C 源代码多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。 2.2 通过 Foundation 框架的 NSObject 类定义的方法Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类） NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。 一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如： -class 方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中 -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol: 检查对象是否实现了指定协议类的方法； -methodForSelector: 返回指定方法实现的地址。 2.3 通过对 Runtime 库函数的直接调用Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。 许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。 三、Runtime 相关的头文件ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件 12345678910111213141516171819List.hNSObjCRuntime.hNSObject.hObject.hProtocol.ha.txthashtable.hhashtable2.hmessage.hmodule.mapobjc-api.hobjc-auto.hobjc-class.hobjc-exception.hobjc-load.hobjc-runtime.hobjc-sync.hobjc.hruntime.h 都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括： 3.1 操作对象的类型的定义1234567891011121314151617181920212223242526272829/// An opaque type that represents a method in a class definition. 一个类型，代表着类定义中的一个方法typedef struct objc_method *Method;/// An opaque type that represents an instance variable. 代表实例(对象)的变量typedef struct objc_ivar *Ivar;/// An opaque type that represents a category. 代表一个分类typedef struct objc_category *Category;/// An opaque type that represents an Objective-C declared property. 代表OC声明的属性typedef struct objc_property *objc_property_t;// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; 这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取： 1234Class cls = obj.class;// NSLog(@\"%s\", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLEconst char * clsName = class_getName(cls);NSLog(@\"%s\", clsName); 3.2 函数的定义 操作对象的方法一般以 object_ 开头操作类的方法一般以 class_ 开头操作类或对象的方法的方法一般以 method_ 开头操作成员变量的方法一般以 ivar_ 开头操作属性的方法一般以 property_ 开头操作协议的方法一般以 protocol_ 开头 以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。 根据以上的函数的前缀可以大致了解到层级关系。 123456789101112// 使用 runtime 对当前的应用中加载的类进行打印- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; unsigned int count = 0; Class * clsList = objc_copyClassList(&amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = class_getName(clsList[i]); NSLog(@\"%s\", clsName); &#125;&#125; 四、术语及其数据结构4.1 SEL它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度。它的数据结构是： 1typedef struct objc_selector *SEL; // An opaque type that represents a method selector. 可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。 注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 4.2 idid 是一个参数类型，它是指向某个类的实例的指针。定义如下： 12typedef struct objc_object *id;struct objc_object &#123; Class isa; &#125;; objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。 Direct access to Objective-C’s isa is deprecated in favor of object_getClass() KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。 4.3 Class1typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： 123456789101112131415161718192021222324252627282930313233343536373839struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ /* 父类 */ Class _Nullable super_class OBJC2_UNAVAILABLE; /* 类名 */ const char * _Nonnull name OBJC2_UNAVAILABLE; /* 类的版本信息，默认为 0 */ long version OBJC2_UNAVAILABLE; /* 类信息，供运行时期使用的一些位标识。 如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量; CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; */ long info OBJC2_UNAVAILABLE; /* 实例变量大小（包括从父类继承下来的实例变量）*/ long instance_size OBJC2_UNAVAILABLE; /* 成员变量地址列表 */ struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; /* 方法地址列表，与 info 的一些标志位有关。 如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法; */ struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; /* 缓存最近使用的方法地址，用于提升效率 */ struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; /* 存储该类声明遵守的协议的列表 */ struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif&#125; OBJC2_UNAVAILABLE; 从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： 123456789101112131415161718192021// 成员变量列表struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;// 方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; 由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。深入理解 Objective-C: Category。 objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。 值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。 实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）； 类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。 为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。 1[NSObject.class alloc]; // [NSObject alloc] 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。 最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。 4.4 Method代表类中某个方法的类型。 123456789101112131415161718192021222324252627282930typedef struct objc_method *Method;struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法名 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; ``` * method\\_name 类型为 SEL* method\\_types 是个 char 指针，存储方法的参数类型和返回值类型* method\\_imp 指向了方法的实现，本质是一个函数指针#### 4.5 Ivar表示成员变量的类型。```objctypedef struct objc_ivar *Ivar;struct objc_ivar &#123; char * _Nullable ivar_name OBJC2_UNAVAILABLE; char * _Nullable ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节#ifdef __LP64__ int space OBJC2_UNAVAILABLE; // 占用空间#endif&#125; 4.6 IMPobjc.h 中定义如下： 12// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针typedef id (*IMP)(id, SEL, ...); 它就是一个由编译器生成的函数指针，指向方法实现的首地址。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。 如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。 你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。 4.7 Cacheruntime.h 中定义如下： 123456789101112131415typedef struct objc_cache *Cachestruct objc_cache &#123; /* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/ unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; /* 实际占用cache buckets的总数 */ unsigned int occupied OBJC2_UNAVAILABLE; /* 指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。 指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长 */ Method _Nullable buckets[1] OBJC2_UNAVAILABLE;&#125;; Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。 Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。 4.8 Property12typedef struct objc_property *Property;typedef struct objc_property *objc_property_t; // 这个更常用 可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性： 12345678OBJC_EXPORT objc_property_t _Nonnull * _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT objc_property_t _Nonnull * _Nullableprotocol_copyPropertyList(Protocol * _Nonnull proto, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。 property_getName() 用来查找属性的名称，返回 c 字符串。property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。 五、消息体会官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。 这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤： ①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数； ②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 ③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。 ④、如果 cache 找不到就找类的方法列表中是否有对应的方法。 ⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。 ⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。 在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。 5.1 方法中的隐藏参数 我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？ 其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。 当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数： self 当前方法的对象指针，接受消息的对象 _cmd 当前方法的 SEL 指针，方法选择器 因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。 这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体： 12345678910111213struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */&#125;; 这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现： 123NSLog(@\"%@\", NSStringFromClass([super class]));2018-11-05 11:30:25.082134+0800 Demo[22838:128408] ViewController // 当前类 5.2 获取方法地址NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP： 1234567891011121314151617181920212223242526272829&#123; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; [self fail:YES]; &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;- (void)fail:(BOOL)value&#123;&#125;2018-11-05 13:06:22.683838+0800 Demo[36187:211037] 4.104993&#123; void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(fail:)]; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) &#123; setter(self, @selector(fail:), YES); &#125; NSLog(@\"%f\", CFAbsoluteTimeGetCurrent() - ti);&#125;2018-11-05 13:05:48.480498+0800 Demo[36095:209893] 3.751424 虽然是更高效的调用方法，但这种做法很少用，除非是需要持续大量重复调用某个方法的情况，才会选择使用，以免消息发送泛滥。 注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性 六、动态方法解析如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。 1@dynamic propertyName; 这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。 Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。 12345678910111213141516void dynamicIMP(id self, SEL _cmd) &#123; // implementation ....&#125;@implementation MyClass+ (BOOL)resolveInstanceMethod:(SEL)aSEL&#123; if (aSEL == @selector(resolveThisMethodDynamically)) &#123; class_addMethod([self class], aSEL, (IMP) dynamicIMP, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:aSEL];&#125;@end 上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：Type Encoding 动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。 七、消息转发 ①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步； ②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步； ③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步； ④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。 7.1 重定向消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(xxx:))&#123; return otherObj; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。 7.2 转发当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑： 123456789101112131415161718- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; return [otherObj methodSignatureForSelector:aSelector];&#125;/** * @param anInvocation 封装了原始的消息和消息的参数 */- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; // 判断 otherObj 对象是否实现了方法 if ([otherObj respondsToSelector:[anInvocation selector]]) &#123; [anInvocation invokeWithTarget:otherObj]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。 参数 anInvocation 是从哪来的？ 在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。 forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。 forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。 7.3 转发和多继承转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。 在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 7.4 转发与继承虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。 如果判断上图中的 Warrior 对象是否能响应 negotiate 消息： 12if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... 尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。 如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。 如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。 八、应用场景8.1 获取属性/成员变量列表12345678910// 简单的定义了一个成员变量和两个属性@interface Person : NSObject&#123; @private CGFloat _height;&#125;@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age;@end 使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表： 1234567891011121314151617181920212223242526- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = NSClassFromString(@\"Person\"); // Class cls = Person.class; unsigned int count = 0; // 获取成员变量数组 Ivar * ivarList = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 获取成员变量名 const char * ivarName = ivar_getName(ivarList[i]); NSLog(@\"%s\", ivarName); &#125; // 获取属性数组 objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ptyName = property_getName(ptyList[i]); NSLog(@\"%s\", ptyName); &#125;&#125;2018-11-04 17:28:03.905326+0800 Demo[5894:1444503] _height2018-11-04 17:28:03.905486+0800 Demo[5894:1444503] _name2018-11-04 17:28:03.905616+0800 Demo[5894:1444503] _age2018-11-04 17:28:03.905745+0800 Demo[5894:1444503] name2018-11-04 17:28:03.905877+0800 Demo[5894:1444503] age 从这里就可以看出 @property 做了三件事： ①、生成一个带下划线的成员变量②、生成这个成员变量的 set 方法③、生成这个成员变量的 get 方法 因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。 1234567891011@property (nonatomic, copy, readonly) NSString * name; // 只读属性- (NSString *)name&#123; return @\"job\";&#125;2018-11-04 17:52:52.690815+0800 Demo[6025:1474196] _height2018-11-04 17:52:52.691025+0800 Demo[6025:1474196] _age2018-11-04 17:52:52.691159+0800 Demo[6025:1474196] name2018-11-04 17:52:52.691308+0800 Demo[6025:1474196] age 当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。 一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好? 大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。 在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？ 首先要了解 setValue:forKeyPath: 方法的底层实现： ①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]②、查找有没有成员变量 _XX，如果有 _XX = value；③、查找有没有成员变量 XX，如果有 XX = value；④、如果都没有找到，直接报错。 123Terminating app due to uncaught exception 'NSUnknownKeyException', reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key name.' 首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。 另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc； 使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。 要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。 12345678910111213141516@property (nonatomic, weak) NSTimer * timer;@property (nonatomic, strong) NSThread * thread;@property (nonatomic, strong, readonly) AModel * a; // 自定义对象&#123; unsigned int count = 0; objc_property_t * propertyList = class_copyPropertyList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; NSLog(@\"%s\", property_getAttributes(propertyList[i])); &#125;&#125;2018-11-05 15:09:37.839596+0800 Demo[39749:288880] T@\"NSTimer\",W,N,V_timer2018-11-05 15:09:37.839692+0800 Demo[39749:288880] T@\"NSThread\",&amp;,N,V_thread2018-11-05 15:09:37.839771+0800 Demo[39749:288880] T@\"AModel\",R,N,V_a 通过 property_getAttributes() 方法获取属性的参数。 8.2 KVC字典转模型获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。 为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程： ①、遍历字典里面的所有 key，取出 key；②、取出 key 的 value，即 dict[key]；③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。 因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。 因此使用逐一为属性赋值的方法进行 KVC： 12345678910111213141516171819- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; Class cls = Person.class; unsigned int count = 0; Person * person = [[Person alloc] init]; NSDictionary * dict = @&#123; @\"name\" : @\"Tom\", @\"age\" : @19, @\"height\": @175 &#125;; Ivar * ivars = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * clsName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:clsName]; NSString * key = [name substringFromIndex:1]; // 去掉'_' [person setValue:dict[key] forKey:key]; &#125;&#125;2018-11-04 19:42:16.964474+0800 Demo[6425:1574210] height:175.0000，name:Tom，age:19，time:(null) 使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。 但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。 setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。 解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。 runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。Type Encodings 123456789101112131415for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; const char * coding = ivar_getTypeEncoding(ivars[i]); // 获取类型 NSString * strCode = [NSString stringWithUTF8String:coding]; id value = dict[key]; if ([strCode isEqualToString:@\"f\"]) &#123; // 判断类型是否是 float value = @(0.0); &#125; [person setValue:value forKey:key];&#125; method_getTypeEncoding() 函数可以获取到方法类型编码 12345678&#123; Method m = class_getInstanceMethod(self.class, @selector(do:at:on:)); NSLog(@\"%s\", method_getTypeEncoding(m));&#125;- (BOOL)do:(NSString *)something at:(char)place on:(int)count;2018-11-05 14:42:30.891829+0800 Demo[38588:270099] B32@0:8@16c24i28 property_getAttributes() 函数可以获取到属性的参数。Declared Properties 8.3 NSCoding 归档和解档获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样： 123456789101112131415161718192021222324252627282930313233- (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [self valueForKey:key]; // 取出 key 对应的 value [aCoder encodeObject:value forKey:key]; // 编码 &#125;&#125;- (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char * ivarName = ivar_getName(ivars[i]); NSString * name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; id value = [aDecoder decodeObjectForKey:key]; // 解码 [self setValue:value forKey:key]; // 设置 key 对应的 value &#125; &#125; return self; &#125; 8.4 交换方法实现交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。 1234567891011121314151617+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Method orginalMethod = class_getClassMethod([UIImage class], @selector(imageNamed:)); Method swizzleMethod = class_getClassMethod([UIImage class], @selector(my_imageNamed:)); //方法交换 method_exchangeImplementations(orginalMethod, swizzleMethod); &#125;);&#125;+ (UIImage *)my_imageNamed:(NSString *)name&#123; return [self my_imageNamed:name];&#125; 需要注意的是 ①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。 任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。 8.5 类/对象的关联对象关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联 123456789101112131415/* 参数 1 : 关联到对象 参数 2 : 关联的 key，可以是任意类型 参数 3 : 被关联的对象 参数 4 : 关联引用的规则 enum &#123; OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403 &#125;;*/objc_setAssociatedObject(self, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);id value = objc_getAssociatedObject(self, key); 8.6 动态添加方法，拦截未实现的方法每个类都有继承自 NSObject 的两个类方法 12+ (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel; 一个适用于类方法，一个适用于对象方法。 在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。 123456789101112131415161718192021222324// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmdvoid method(id self, SEL _cmd) &#123;&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if ([NSStringFromSelector(sel) isEqualToString:@\"doSomething\"]) &#123; /* 参数 4 : const char *types 方法的类型 要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。 如果想要再增加参数，就可以从实现的第三个参数算起： class_addMethod(self, sel, method, \"v@:@\"); // 多一个对象类型参数增加了 @ void method(id self, SEL _cmd, NSString * name) &#123; &#125; 返回值：YES if the method was found and added to the receiver, otherwise NO. */ class_addMethod(self, sel, method, \"v@:\"); // 为 sel 指定实现为 method &#125; return YES;&#125; 8.7 动态创建一个类动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#import &lt;objc/message.h&gt;void sayFunction(id self, SEL _cmd, id param) &#123; NSLog(@\"%ld岁的%@在%@说%@\", [object_getIvar(self, class_getInstanceVariable([self class], \"_age\")) integerValue], object_getIvar(self, class_getInstanceVariable([self class], \"_name\")), object_getIvar(self, class_getInstanceVariable([self class], \"schoolName\")), param);&#125;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; // 创建 Student 类。参数 1 : 父类 参数 2 : 类名 参数 3 : 通常为 0 Class StudentClass = objc_allocateClassPair(NSObject.class, \"Student\", 0); // 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型 // 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用 if (class_addIvar(StudentClass, \"schoolName\", sizeof(NSString *), 0, \"@\")) &#123; NSLog(@\"添加成员变量成功\"); &#125; // 添加 NSString * _name 成员变量 class_addIvar(StudentClass, \"_name\", sizeof(NSString *), 0, @encode(NSString *)); // 添加 int _age 成员变量 class_addIvar(StudentClass, \"_age\", sizeof(int), 0, @encode(int)); // 为 Student 类添加方法 \"v@:\" 这种写法见参数类型连接 SEL sel = sel_registerName(\"sayFunction:\"); if (class_addMethod(StudentClass, sel, (IMP)sayFunction, \"v@:@\")) &#123; NSLog(@\"添加方法成功\"); &#125; // 注册这个类到 runtime 系统中就可以使用了 objc_registerClassPair(StudentClass); // 使用创建的类 id student = [[StudentClass alloc] init]; // 给刚刚添加的变量赋值 // object_setInstanceVariable(student, \"schoolName\", (void *)&amp;str);在ARC下不允许使用 [student setValue:@\"清华大学\" forKey:@\"schoolName\"]; // KVC 动态改变实例变量 [student setValue:@\"Tom\" forKey:@\"name\"]; // 从类中获取成员变量Ivar Ivar ageIvar = class_getInstanceVariable(StudentClass, \"_age\"); // 为peopleInstance的成员变量赋值 object_setIvar(StudentClass, ageIvar, @18); // 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息 objc_msgSend(student, \"sayFunction:\", @\"你好~\"); // [student performSelector:sel withObject:@\"你好~\"]; // 动态调用未显式在类中声明的方法 student = nil; StudentClass = nil;// objc_disposeClassPair(StudentClass);&#125; 直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO 九、健壮的实例变量(Non Fragile ivars)在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。 当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移： 上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了： 我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？ 在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。 需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。 十、文章Mike_zh &amp; iOS-Runtime知识点整理ian &amp; Objective-C Runtime 1小时入门教程iOS开发-Runtime 详解iOS RunTime 之数据结构iOS 模块分解—「Runtime面试、工作」Runtime 源码","tags":[]},{"title":"TCP 的断包、粘包","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/计算机网络/TCP 的断包和粘包/","text":"以太网中存在一个对于帧的有效数据大小的限制，即 MTU，以太网的 MTU 为 1500 字节。 一、断包 就是说发送端一次发送的消息长度过大，如果超过了 MTU，那么 ip 会对其进行分片。 在网络编程中，要避免出现 IP 分片。因为是 IP 层是没有超时重传机制的，如果 IP 层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP 分片会大大降低传输层传送数据的成功率，所以要避免 IP 分片。 对于 UDP 包，我们需要在应用层去限制每个包的大小，一般不要超过 1472 字节，即以太网 MTU（1500）- UDP 首部（8）- IP 首部（20）。 对于 TCP 数据，应用层就不需要考虑这个问题了，因为传输层已经做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），一般 MSS = MTU - IP 首部（20）- TCP 首部（20），每次发送的 TCP 数据都不会超过双方 MSS 的最小值，所以就保证了 IP 数据报不会超过 MTU，避免了 IP 分片。 而断包就是因为 MSS 的存在，当消息长度过大，例如超过了 1460 字节（因为 tcp 首部一般为 20 个字节，ip 首部为 20 个字节），那么 tcp 就会将其分片，然后每片被 tcp 封装，然后由 ip 封装，最后被传输到接收端，这样子当接收端接收到消息后，就会不清楚这是不是一个完整的消息。 二、粘包为了提高网络利用率，当传输层发现传输的数据长度太小时，会等待多个消息一起发送，这时候就会提高网络利用率，但是当接收端接收过以后，会不知道这是一个完整的消息，还是多个消息在一起。从而有可能将其作为一个消息来处理。nagle 算法就是实现的这个功能。 对于断包和粘包的通常处理方法为将消息封装为一定的格式，例如每个消息头部为 aa，尾部为 55，或者将整个消息的有效长度标明，这样子当接收端接收到消息之后，就可以以此来分辨消息是不是我完整的。","tags":[]},{"title":"if-else、switch、while、for","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/C/if-else、switch、while、for/","text":"文章主要会涉及如下几个问题： if-else 和 switch-case 两者相比谁的效率会高些？在日常开发中该如何抉择？ 如何基于赫夫曼树结构减少 if-else 分支判断次数？ 如何巧妙的应用 do…while(0) 改善代码结构？ 哨兵是什么东西？如何利用哨兵提高有序数组查找效率？ 如何降低 for 循环嵌套的时间复杂度？ 如何利用策略模式替换繁琐的 if-else 分支？ 一、if-else 和 switch-case 效率问题switch-case 与 if-else 的根本区别： switch 会生成一个跳转表来指示实际的 case 分支的地址，而这个跳转表的索引号与 switch 变量的值是相等的。 所以 switch-case 不用像 if-else 那样遍历条件分支直到命中条件，只需访问对应索引号的表项从而到达定位分支。 具体地说，switch-case 会生成一份大小（表项数）为最大 case 常量 +1 的跳转表，程序首先判断 switch 变量是否大于最大 case 常量，若大于，则跳到 default 分支处理；否则取得索引号为 switch 变量大小的跳表项的地址（即跳表的起始地址+表项大小 * 索引号），程序接着跳到此地址执行，到此完成了分支的跳转。 123456789101112131415161718192021222324252627282930int main() &#123; unsigned int i, j; i = 3; switch (i) &#123; case 0: j = 0; break; case 1: j = 1; break; case 2: j = 2; break; case 3: j = 3; break; case 4: j = 4; break; default: j = 10; break; &#125;&#125; 用 gcc 编译器，生成汇编代码（不开编译器优化） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283_main: ## @mainLfunc_begin0: .loc 1 12 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:12:0 .cfi_startproc\\## %bb.0: pushq %rbp .cfi\\_def\\_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi\\_def\\_cfa_register %rbp movl $0, -4(%rbp)Ltmp0: .loc 1 14 7 prologue_end ## /Users/cykj/Desktop/Demo/Demo/MyC.c:14:7 movl $3, -8(%rbp) .loc 1 16 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:13 movl -8(%rbp), %eax movl %eax, %ecx movq %rcx, %rdx subq $4, %rdx .loc 1 16 5 is_stmt 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:5 movq %rcx, -24(%rbp) ## 8-byte Spill movq %rdx, -32(%rbp) ## 8-byte Spill ja LBB0_6\\## %bb.8: .loc 1 0 5 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:0:5 leaq LJTI0_0(%rip), %rax movq -24(%rbp), %rcx ## 8-byte Reload movslq (%rax,%rcx,4), %rdx addq %rax, %rdx jmpq *%rdxLBB0_1:Ltmp1: .loc 1 18 15 is_stmt 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:18:15 movl $0, -12(%rbp) .loc 1 19 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:19:13 jmp LBB0_7LBB0_2: .loc 1 22 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:22:15 movl $1, -12(%rbp) .loc 1 23 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:23:13 jmp LBB0_7LBB0_3: .loc 1 26 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:26:15 movl $2, -12(%rbp) .loc 1 27 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:27:13 jmp LBB0_7LBB0_4: .loc 1 30 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:30:15 movl $3, -12(%rbp) .loc 1 31 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:31:13 jmp LBB0_7LBB0_5: .loc 1 34 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:34:15 movl $4, -12(%rbp) .loc 1 35 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:35:13 jmp LBB0_7LBB0_6: .loc 1 38 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:38:15 movl $10, -12(%rbp)Ltmp2:LBB0_7: .loc 1 42 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:42:1 movl -4(%rbp), %eax popq %rbp retqLtmp3:Lfunc_end0: .cfi_endproc .p2align 2, 0x90 .data_region jt32L0\\_0\\_set\\_1 = LBB0\\_1-LJTI0_0L0\\_0\\_set\\_2 = LBB0\\_2-LJTI0_0L0\\_0\\_set\\_3 = LBB0\\_3-LJTI0_0L0\\_0\\_set\\_4 = LBB0\\_4-LJTI0_0L0\\_0\\_set\\_5 = LBB0\\_5-LJTI0_0LJTI0_0: .long L0\\_0\\_set_1 .long L0\\_0\\_set_2 .long L0\\_0\\_set_3 .long L0\\_0\\_set_4 .long L0\\_0\\_set_5 .end\\_data\\_region ## \\-\\- End function 由此看来，switch 有点以空间换时间的意思，而事实上也的确如此。 当分支较多时，当时用 switch 的效率是很高的。因为 switch 是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是 if-else 是遍历所有的可能值，直到找到符合条件的分支。 但不总是那么好，因为每次计算会有一个二次查表过程。 具体需要看应用场景，举个例子：对于网络层的协议分析，99% 可能都是 IP 协议，因此基本上会在第一个 if 时就命中，只有一次计算。 总结：对于分支较多或分布相对均匀的情况，使用 switch 可以提高效率；对于分支较少或分布不均匀的情况，使用 if-else 更好。 由上面的汇编代码可知道，switch-case 占用较多的代码空间，因为它要生成跳转表，特别是当 case 常量分布范围很大但实际有效值又比较少的情况，switch-case 的空间利用率将变得很低。 switch-case 只能处理 case 为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用 switch-case 来处理的。所以 if-else 能应用于更多的场合，比较灵活。 文章：switch 与 if-else 的效率问题 二、用 do-while(0) 改善代码结构先看一段代码，要重点注意代码中的注释。 1234567891011121314- (NSString *)handleString:(NSString *)str&#123; if (![str isKindOfClass:[NSString class]]) &#123; return nil; &#125; if(str.length &lt;= 0) &#123; return nil; &#125; // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1...code1 // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果)，无论判断是否通过都要执行 code2...code2&#125; 试问，怎样做才能巧妙的满足上述注释代码的需求，因为上述代码中存在 return nil，一旦执行到此处，逻辑一和逻辑二处的伪代码都不会再执行。为了满足上述要求，我们可以巧妙的利用 break 退出临时构造的代码块，但不退出整个函数。 123456789101112131415- (NSString *)handleString:(NSString *)str &#123; do &#123; if (![str isKindOfClass:[NSString class]]) &#123; break; &#125; if(str.length &lt;= 0) &#123; break; &#125; // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1...code2 &#125; while (0); // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果),无论判断是否通过都要执行 code2...code2&#125; 三、有序数组查找操作中的哨兵正常的查找处理。 123456NSArray *arr = @[@1, @2, @3, @4, @5];for (NSInteger i = 0; i &lt; arr.count; i++) &#123; if ([arr[i] integerValue] == 2) &#123; NSLog(@&quot;for 找到了&quot;); &#125;&#125; 利用哨兵进行查找处理。 123456789101112131415161718192021222324- (BOOL)search:(NSNumber *)key array:(NSMutableArray *)arr&#123; if (arr.count &lt;= 0) &#123; return NO; &#125; NSNumber * firstObj = (NSNumber *)arr[0]; if ([firstObj integerValue] == [key integerValue]) &#123; return YES; &#125; NSInteger i = arr.count - 1; NSLock * lock = [[NSLock alloc] init]; [lock lock]; arr[0] = key; // 同上面 for 循环相比，i &lt; arr.count 的判断，在处理大批量数据时候，对性能提升比较大 while ([arr[i] integerValue] != [key integerValue]) &#123; i--; &#125; arr[0] = firstObj; [lock unlock]; return (i != 0);&#125; 仔细观察上述两段代码，同样是在有序数组中查找目标为 2 的元素，第一段代码是常规迭代处理，第二段代码是将要查找的元素设置为哨兵。同第一段代码相比第二种方式少了 i &lt; arr.count 的判断，在小批量有序数组查询中对效率的提升并无明显影响，但是在处理大批量数据时候，对性能提升还是比较明显的。 四、多层 for 嵌套处理实际开发中应尽量避免使用双层 for 循环，客户端数据量比较小可能实际开发中并不是很注意这些。但是后端开发过程中，数据量比较大, 为了提升性能，有些公司后端开发中可能会直接规定避免使用多层 for 循环嵌套的形式。一般第二层或更深层的 for 循环可以使用字典替换。双层 for 循环嵌套的时间复杂度是 n 的二次方。但如果内部 for 循环用字典代替时间复杂度为 O(2n)（实际是 O(n)）。如：两个数组中有且只有一个相同元素，寻找该元素。其中一个数组就可以先用字典做保存，遍历第一个数组的时候，同字典中的数据做比较即可。 1234567891011121314NSArray *arr1 = @[@1, @2, @3, @4, @5];NSArray *arr2 = @[@5, @6, @7, @8];NSMutableDictionary * dict = [NSMutableDictionary dictionary];for (NSInteger i = 0; i &lt; arr2.count; i++) &#123; [dict setObject:arr2[i] forKey:[NSString stringWithFormat:@&quot;%ld&quot;, i]];&#125;for (NSInteger i= 0 ; i &lt; arr1.count; i++) &#123; NSNumber * number = [dict objectForKey:[NSString stringWithFormat:@&quot;%ld&quot;, i]]; if ([arr1[i] integerValue] == [number integerValue]) &#123; NSLog(@&quot;相同的数据为:%@&quot;, number); break; &#125; &#125; 五、用策略模式替换 if-elsehttps://www.jianshu.com/p/98fa80eebc52 六、文章用if else,switch,while,for颠覆你的编程认知","tags":[]},{"title":"心跳保活","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/计算机网络/心跳保活/","text":"一、前言TCP 协议自身有 KeepAlive 机制，为何基于它的通讯链接，仍然需要在应用层实现额外的心跳保活？本文将从移动端 IM 实践的角度说明，即使使用 TCP 协议，应用层的心跳保活仍旧必不可少。有关 TCP 协议的权威理论介绍，请参见《TCP/IP详解》。 移动端 IM 开发推荐文章：《新手入门一篇就够：从零开发移动端IM》 二、参考资料《TCP/IP详解-第11章·UDP：用户数据报协议》《TCP/IP详解-第17章·TCP：传输控制协议》《TCP/IP详解-第18章·TCP连接的建立与终止》《TCP/IP详解-第21章·TCP的超时与重传》《通俗易懂-深入理解TCP协议（上）：理论基础》《通俗易懂-深入理解TCP协议（下）：RTT、滑动窗口、拥塞处理》《理论经典：TCP协议的3次握手与4次挥手过程详解》《计算机网络通讯协议关系图（中文珍藏版）》《NAT详解：基本原理、穿越技术（P2P 打洞）、端口老化等》 三、心跳保活在使用 TCP 长连接的 IM 服务设计中，往往都会涉及到心跳。心跳一般是指某端（绝大多数情况下是客户端）每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。 有兴趣了解 IM/推送的心跳保活技术的文章，请参见： 《Android进程保活详解：一篇文章解决你的所有疑问》《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》《微信团队原创分享：Android版微信后台保活实战分享(进程保活篇)》《微信团队原创分享：Android版微信后台保活实战分享(网络保活篇)》《移动端IM实践：实现Android版微信的智能心跳机制》《移动端IM实践：WhatsApp、Line、微信的心跳策略分析》更多同类文章 …… 四、TCP 协议的 KeepAlive为什么需要在应用层做心跳，难道 TCP 不是个可靠连接吗？我们不能够依赖 TCP 做断线检测吗？比如使用 TCP 的 KeepAlive 机制来实现。应用层心跳是目前的最佳实践吗？怎么样的心跳才是最佳实践。很多做移动端 IM 的同行，以前确实没有仔细考虑过这些问题，潜意识里想当然的认为这仅仅只是个简单的心跳而已啊。事实并非这么简单。 五、IM 中保持有效长连接的重要性对于客户端而言，使用 TCP 长连接来实现业务的最大驱动力在于：在当前连接可用的情况下，每一次请求都只是简单的数据发送和接受，免去了 DNS 解析，连接建立等时间，大大加快了请求的速度，同时也有利于接受服务器的实时消息。但前提是连接可用。 如果连接无法很好地保持，每次请求就会变成撞大运：运气好，通过长连接发送请求并收到反馈。运气差，当前连接已失效，请求迟迟没有收到反馈直到超时，又需要一次连接建立的过程，其效率甚至还不如 HTTP。而连接保持的前提必然是检测连接的可用性，并在连接不可用时主动放弃当前连接并建立新的连接。 基于这个前提，必须要有一种机制用于检测连接可用性。同时移动网络的特殊性也要求客户端需要在空余时间发送一定的信令，避免连接被回收。详见微信和运营商的撕B（另一篇针对微信的信令风暴技术研究文章请见：《微信对网络影响的技术试验及分析》）。而对于服务器而言，能够及时获悉连接可用性也非常重要：一方面服务器需要及时清理无效连接以减轻负载，另一方面也是业务的需求，如游戏副本中服务器需要及时处理玩家掉线带来的问题。 六、TCP 的 KeepAlive 无法替代应用层心跳保活机制的原因说了保持连接的重要性，那么回到具体实现上。为什么我们需要使用应用层心跳来做检测，而不是直接使用 TCP 的特性呢？ TCP 是一个基于连接的协议，其连接状态是由一个状态机进行维护，连接完毕后，双方都会处于 established 状态，这之后的状态并不会主动进行变化。这意味着如果上层不进行任何调用，一直使 TCP 连接空闲，那么这个连接虽然没有任何数据，但仍是保持连接状态，一天、一星期，甚至一个月，即使在这期间中间路由崩溃重启无数次。举个现实中经常遇到的栗子：当我们 ssh 到自己的 VPS 上，然后不小心踢掉网线，此时的网络变化并不会被 TCP 检测出，当我们重新插回网线，仍旧可以正常使用 ssh，同时此时并没有发生任何 TCP 的重连。 有人会说 TCP 不是有 KeepAlive 机制么，通过这个机制来实现不就可以了吗？但是事实上，TCP KeepAlive 的机制其实并不适用于此。Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200s（详情请参见《TCP/IP详解》中第23章），失败后重试 10 次，每次超时时间 75s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。 因为 TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：检测通讯双方的存活状态。两者听起来似乎是一个意思，但实际上却大相径庭。 考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。 从上面可以知道，KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。 七、心跳保活机制的实现方案参考从上面可以得出结论，目前而言，应用层心跳的确是检测连接有效性，双方是否存活的最佳实践，那么剩下的问题就是怎么实现。 最简单粗暴做法当然是定时心跳，如每隔 30 秒心跳一次，15 秒内没有收到心跳回包则认为当前连接已失效，断开连接并进行重连。这种做法最直接，实现也简单。缺点是比较耗电和耗流量。以一个协议包 5 个字节计算，一天收发 2880 个心跳包，一个月就是 5 2 2880 * 30 = 0.8M 的流量，如果手机上多装几个 IM 软件，每个月只心跳就好几兆流量没了，更不用说频繁的心跳带来的电量损耗。 既然频繁心跳会带来耗电和耗流量的弊端，改进的方向自然是减少心跳频率，但也不能过于影响连接检测的实时性。基于这个需求，一般可以将心跳间隔根据程序状态进行调整，当程序在后台时（这里主要考虑安卓），尽量拉长心跳间隔，5 分钟、甚至 10 分钟都可以。 而当 App 在前台时则按照原来规则操作。连接可靠性的判断也可以放宽，避免一次心跳超时就认为连接无效的情况，使用错误积累，只在心跳超时 n 次后才判定当前连接不可用。当然还有一些小 trick 比如从收到的最后一个指令包进行心跳包周期计时而不是固定时间，这样也能够一定程度减少心跳次数。 八、文章JackJiang2011 &amp; 为什么说基于TCP的移动端IM仍然需要心跳保活？","tags":[]},{"title":"iOS 构建静态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 构建静态库/","text":"一、.a 文件静态库打包 打开 Xcode 创建一个新的 Static Library 工程，取名 MyStaticLibrary。 创建工程完毕后，系统自动创建了一个同名类，添加一个方法用于测试。 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface MyStaticLibrary : NSObject+ (void)test;@end@implementation MyStaticLibrary+ (void)test&#123; NSLog(@&quot;sssss&quot;);&#125;@end Command + B 运行工程进行打包。运行完毕后，在工程中 Products 文件夹下的 libMyStaticLibrary.a 文件由红色变成了黑色。右键 show in finder 可以在其目录下找到它。这就是我们打包好的 .a 静态文件。 接下来公开些接口或者头文件供人调用。 公开接口头文件 targets -&gt; Build Phases -&gt; Copy Files -&gt; “+” 添加你需要公开的头文件。可以多添加几个类。 公开头文件后，Command + B 重新运行打包，我们会得到一个 include 文件夹和一个 .a 静态库。 新建一个可运行的工程，把这两个打包好的文件拖入项目测试。 选择 iPhone7 模拟器运行，运行程序，看到日志输出没有问题，即打包.a静态库大功告成。 别高兴的太早。当把模拟器切换成 iPhone5 运行时，编译直接不通过，报错如下： Undefined symbols for architecture i386 的意思是 libMyStaticLibrary.a 静态库不支持 i386 架构，即 32 位模拟器。 iPhone5 模拟器正好是 i386 架构，打包的静态库不支持。但是 iPhone7 模拟器运行却没有问题，这说明打包的静态库支持 iPhone7 模拟器的 cpu 架构 x86_64。如何查看静态库所支持的架构，请看下一步。 终端查看静态库所支持的架构 终端 -> cd 进入库文件路径 -&gt; lipo -info 库名 可以看到静态库仅支持 x86_64 架构，所以运行 iPhone5 模拟器时，编译会报错。 设置适配所有模拟器架构 project -&gt; buildSeting -&gt; Build Active Architecture Only 设为 NO，Valid Architectures 添加 arm7、arm7s 等架构，注意工程 iOS Deployment Target 设置为较低版本，如 8.0，不然不会有 i386。 设置完成后，重新 Command + B 运行打包静态库文件（这时你可随便选一个模拟器），按照上述第 6 步终端查看其支持的架构，我们可以看到终端输出的结果是同时支持 i386 和 x86_64，这也就意味着同时支持所有模拟器。 到这里打包 .a 静态库已经告一段落，但是按上述流程打包的只能在模拟器上跑，真机是不能运行的，因为 ios 真机设备跟模拟器的架构又不一样，继续处理。 打包支持真机架构的静态库 所有流程都跟上面的一样，只是我们运行打包时要选择真机运行，如下图你可以选择自己插上去的真机，也可以选择 Generic ios Devices。当然不要忘记了设置支持所有真机机型架构： Build Active Architecture Only 设为 NO。 看下打包出来的终端查看结果如下： 可以看到同时支持 armv7 和 arm64，也就是支持所有 ios 设备。好了到此打包 .a 静态库算是告一段落。 如果要同时支持模拟器和真机，请使用命令合成 .a 静态库： 1lipo -create \\[name1.a 所在路径\\] \\[name2.a 所在路径\\] -output \\[newname.a\\] ![14](https://upload-images.jianshu.io/upload_images/5294842-23c07761cdb71163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 二、.frameworke 文件静态库打包 Xcode 创建一个新的工程 MyFrameworkLib，选择工程如下： 创建完成后我们可以看到，工程本身自带一个 MyFrameworkLib.h 文件，这是类似一个主头文件一样的东西 创建需要测试的类。 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface MyFramework : NSObject+ (void)test;@end@implementation MyFramework+ (void)test&#123; NSLog(@&quot;sssss&quot;);&#125;@end 设置支持所有模拟器架构或真机架构（和打包 .a 第 7 步骤一样） 公开头文件 target -&gt; Build Phases -&gt; Headers -&gt; 把需要公开的头文件从 project 拖入 Public。 设置打包的是静态库。 因为动态库也可以是以 framework 形式存在，所以需要设置，否则默认打出来的是动态库（注意：如果要上线 AppSotre，一定要改成静态库，否则审核通不过） target -&gt; BuildSetting -&gt; 搜索关键字 mach-&gt; Mach-o Type 设为 Static Library（这个默认选项是动态的） 选中真机或模拟器运行设备打包（与打包 .a 一样），完成后 Products 文件夹下的 MyFrameworkLib.framework 文件由红色变成了黑色，右键 show in finder 显示如下： MyFrameworkLib.framework 拖入项目便可直接使用。此外还要补充的一点是，打包静态库的时候还需注意打包的是测试版（Debug）还是发布版（Release），这个根据你自己的需求决定，而如何进行设置请下一步骤。 设置打包静态库的测试版和发布版（.a 和 .frameworke） product -&gt; scheme -&gt; Edit scheme -&gt; Run -&gt; 选择 Debug 或 Release。 如果要同时支持多种架构，和 .a 类似，需要设置 Build Activ Architecture Only = NO 和 iOS Deployment Target。 如果要同时支持模拟器和真机，和 .a 类似，使用命令合成 framework 库：lipo -create [.framework/] [.framework/] -output newname 将生成的 MyLib 替换掉任何一个里面的 MyFrameworkLib 文件。","tags":[]},{"title":"iOS 构建动态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 构建动态库/","text":"一、构建步骤 创建一个动态库 MyDynamicFramework 创建一个测试类 在 MyDynamicFramework.h（默认生成，可统一暴露头文件） 中 #import “Person.h” 1234567891011#import &lt;UIKit/UIKit.h&gt;//! Project version number for MyDynamicFramework.FOUNDATION_EXPORT double MyDynamicFrameworkVersionNumber;//! Project version string for MyDynamicFramework.FOUNDATION_EXPORT const unsigned char MyDynamicFrameworkVersionString[];// In this header, you should import all the public headers of your framework using statements like #import &lt;MyDynamicFramework/PublicHeader.h&gt;#import &quot;Person.h&quot; 点击工程 -&gt; Targets -&gt; Build Phases -&gt; Headers。 动态库中新建的文件会自动添加到 project 列表，MyDynamicFramework.h 文件是处于 Public 列表中。由于动态库外部使用者需要调用 Person.h 中的方法，所以也需要将 Person.h 拖拽到 Public 列表。 编译动态库 选择动态库对应的 Scheme，选择 Generic iOS Device 或真机编译出对应真机的动态库，Command + B 编译。在 Xcode 工程中的 Products（这个目录不是工程源文件目录，而是编译后生成对应的沙盒目录）找到 MyDynamicFramework.framework 文件，右键 show in finder。 利用 lipo -info 查看动态库所支持的 CPU 指令集。 新建工程后所编译出来的动态库所支持的 CPU 指令集是 arm 7、arm64。 需要注意： 1lipo -info [文件] 后面跟的是文件路径，而不是 .framework 路径。 指令集种类 armv7｜armv7s｜arm64 都是 ARM 处理器的指令集 i386｜x86_64 是 iOS 模拟器的指令集 理论上指令集是向下兼容的，比如连接设备为 arm64，那么是有可能编译出的动态库所支持的指令集为 armv7s 或者是 armv7。但是向下兼容并不是说一个 armv7s 的动态库可以用在 arm64 架构的设备上，如果连接的设备是 arm64 的，而导入的动态库是没有支持 arm64，那么在编译阶段即会报错。 Xcode 指令集的编译选项 打开 Target -&gt; Build Setting -&gt; Architectures Architectures：指明选定 Target 要求被编译生成的二进制包所支持的指令集 Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集，如果为 YES，那么只编译出连接设备所对应的指令集；如果为 NO，则编译出所有其它有效的指令集（由 Architectures 和 Valid Architectures决定） Valid Architectures：指明可能支持的指令集并非 Architectures 列表中指明的指令集都会被支持 编译产生的动态库所支持的指令集将由上面三个编译选项所影响，首先一个动态库要成功编译，则需要这三个编译选项的交集不为空。 制作支持各机型的动态库 Build Active Architecture Only 统一为 NO Architectures 和 Valid Architectures 都设置为 armv7、armv7s、arm64、arm64e 真机 Command + B 则生成支持 armv7、armv7s、arm64 的动态库，模拟器运行，则生成支持 i386、x86_64 的动态库。 合并模拟器和真机动态库 使用 lipo -create -output 命令合动态库，注意路径是文件路径，不是 .framework 的路径。 使用脚本合并 新建一个 target 脚本。 粘贴以下脚本内容到指定位置 1234567891011121314151617181920212223242526if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]thenINSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.frameworkDEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.frameworkif [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]thenrm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;fimkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;#ditto &quot;$&#123;DEVICE_DIR&#125;/Headers&quot; &quot;$&#123;INSTALL_DIR&#125;/Headers&quot;# 使用lipo命令将其合并成一个通用framework # 最后将生成的通用framework放置在工程根目录下新建的Products目录下 lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot;#open &quot;$&#123;DEVICE_DIR&#125;&quot;#open &quot;$&#123;SRCROOT&#125;/Products&quot;fi 编译新 target 编译完成后生成的 framework 位于工程源代码根目录下的 Products 文件夹下面，通过 lipo -info 可以看到动态库已经支持 i386、x86_64、armv7、armv7s、arm64。 注意：是工程目录，不是沙盒目录。 使用动态库 在新工程的 target -&gt; General -&gt; Embedded Binaries 中添加 MyDynamicFramework.framework。 二、动态使用2.1 使用别人提供的动态库遇到的坑①、第三方库所支持的 CPU 指令集不全。②、运行过程中出现 image not found 异常或者控制台没有异常输出。原因：没有往 Embedded Binaries 中添加 xxx.framework 2.2 动态库动态更新问题能否用动态库来动态更新 AppStore 上的版本呢？ framework 本来是苹果专属的内部提供的动态库文件格式，但是自从 2014 年 WWDC 之后，开发者也可以自定义创建framework 实现动态更新（绕过 apple store 审核，从服务器发布更新版本）的功能，这与苹果限定的上架的 app 必须经过apple store 的审核制度是冲突的，所以含有自定义的 framework 的 app 是无法在商店上架的，但是如果开发的是企业内部应用，就可以考虑尝试使用动态更新技术来将多个独立的 app 或者功能模块集成在一个 app 上面。 企业内部使用的 app，将企业官网中的板块开发成 4 个独立的 app，然后将其改造为 framework 文件最终集成在一款平台级的 app 当中进行使用，这样就可以在一款 app 上面使用原本 4 个 app 的全部功能。 使用自定义的动态库的方式来动态更新只能用在 in house（企业发布）和 develop 模式却但不能在使用到 AppStore，因为在上传打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有 Embedded 的动态库。因此，只要你修改了某个动态库的代码，并重新签名，那么 MD5 的哈希值就会不一样，在加载动态库的时候，苹果会检验这个 hash 值，当苹果监测到这个动态库非法时，就会造成 Crash。 2.3 iOS 如何使用 framework 来进行动态更新？重要参考文档：iOS 利用 Framework 进行动态更新 2.4 谈谈 Mach-O 在制作 framework 的时候需要选择这个 Mach-O Type，确定 static、dynamic 类型库. 为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码、动态库、内核转储的文件格式。作为 a.out 格式的替代，Mach-O 提供了更强的扩展性，并提升了符号表中信息的访问速度。 2.5 自己创建的动态库自建的动态库和系统的动态库有什么区别呢？ 我们创建的动态库是在自己应用的 .app 目录里面，只能自己的 App Extension 和 APP 使用。而系统的动态库是在系统目录里面，所有的程序都能使用。 可执行文件和自己创建的动态库位置： 一般我们得到的 iOS 程序包是 .ipa 文件。其实就是一个压缩包，解压缩 .ipa 后里面会有一个 payload 文件夹，文件夹里有一个 .app 文件，右键显示包内容，然后找到一个一般体积最大的、与 .app 同名的文件，那个文件就是可执行文件。 在模拟器上运行的时候用 [[NSBundle mainBundle] bundlePath]; 就能得到 .app 的路径。可执行文件就在 .app 里面。 而我们自己创建的动态库就在 .app 目录下的 Framework 文件夹里。 我们可以看一下可执行文件中对动态库的链接地址。用MachOView查看可执行文件。其中 @rpth 这个路径表示的位置可以查看Xcode 中的链接路径问题，而现在表示的其实就是 .app 下的 Framework 文件夹。 下图表示了静态库、自建的动态库和系统动态库： 三、文章iOS 动态库制作以及遇到的坑","tags":[]},{"title":"iOS 编译过程原理(2)","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 编译过程原理(2)/","text":"一、前言《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚： Clang 和 LLVM 究竟是什么 源文件到机器码的细节 Linker 做了哪些工作 编译顺序如何确定 头文件是什么？XCode 是如何找到头文件的？ Clang Module 签名是什么？为什么要签名 为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。 二、编译器 把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做编译器。 大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swift，后端都是 LLVM。 三、LLVMLLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。 LLVM 的核心库提供了现代化的 source-target-independent 优化器和支持诸多流行 CPU 架构的代码生成器，这些核心代码是围绕着 LLVM IR（中间代码）建立的。 基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。 四、clangclang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程： 接下来，从代码层面看一下具体的转化过程，新建一个 main.c： 123456789101112#include &lt;stdio.h&gt;#define DEBUG 1int main() &#123;#ifdef DEBUG printf(&quot;hello debug\\\\n&quot;);#else printf(&quot;hello world\\\\n&quot;);#endif return 0;&#125; 五、预处理（preprocessor）预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。 #include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，这个过程是递归的：因为 stdio.h 也有可能包含其他头文件。 用 clang 查看预处理的结果： 1$ xcrun clang -E main.c 预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。 123456789101112131415$ xcrun clang -E main.c......extern int __vsnprintf_chk (char * restrict, size_t, int, size_t, const char * restrict, va_list);# 412 &quot;/usr/include/stdio.h&quot; 2 3 4# 10 &quot;main.c&quot; 2int main() &#123; printf(&quot;hello debug\\n&quot;); return 0;&#125; 可以看到，在预处理的时候，注释被删除，条件编译被处理。 六、词法分析（lexical anaysis）词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。 1$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 输出： 123456789101112131415161718192021222324$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.cannot_module_include &apos;#include &lt;stdio.h&gt;// 一点注释#define DEBUG 1int main() &#123;#ifdef DEBUG printf(&quot;hello debug\\n&quot;);#else printf&apos; Loc=&lt;main.c:9:1&gt;int &apos;int&apos; [StartOfLine] Loc=&lt;main.c:14:1&gt;identifier &apos;main&apos; [LeadingSpace] Loc=&lt;main.c:14:5&gt;l_paren &apos;(&apos; Loc=&lt;main.c:14:9&gt;r_paren &apos;)&apos; Loc=&lt;main.c:14:10&gt;l_brace &apos;&#123;&apos; [LeadingSpace] Loc=&lt;main.c:14:12&gt;identifier &apos;printf&apos; [StartOfLine] [LeadingSpace] Loc=&lt;main.c:16:5&gt;l_paren &apos;(&apos; Loc=&lt;main.c:16:11&gt;string_literal &apos;&quot;hello debug\\n&quot;&apos; Loc=&lt;main.c:16:12&gt;r_paren &apos;)&apos; Loc=&lt;main.c:16:27&gt;semi &apos;;&apos; Loc=&lt;main.c:16:28&gt;return &apos;return&apos; [StartOfLine] [LeadingSpace] Loc=&lt;main.c:20:5&gt;numeric_constant &apos;0&apos; [LeadingSpace] Loc=&lt;main.c:20:12&gt;semi &apos;;&apos; Loc=&lt;main.c:20:13&gt;r_brace &apos;&#125;&apos; [StartOfLine] Loc=&lt;main.c:21:1&gt;eof &apos;&apos; Loc=&lt;main.c:21:2&gt; Loc=\\main.c:9:1\\ 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。 七、语法分析（semantic analysis）词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。 1$ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f main 函数 AST 的结构： 123456789101112131415[0;1;32mTranslationUnitDecl\u001b[0m\u001b[0;33m 0x7fd9a18166e8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816c60\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __int128_t\u001b[0m \u001b[0;32m&apos;__int128&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816980\u001b[0m \u001b[0;32m&apos;__int128&apos;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816cd0\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __uint128_t\u001b[0m \u001b[0;32m&apos;unsigned __int128&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a18169a0\u001b[0m \u001b[0;32m&apos;unsigned __int128&apos;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816fa8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __NSConstantString\u001b[0m \u001b[0;32m&apos;struct __NSConstantString_tag&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mRecordType\u001b[0m\u001b[0;33m 0x7fd9a1816db0\u001b[0m \u001b[0;32m&apos;struct __NSConstantString_tag&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;1;32mRecord\u001b[0m\u001b[0;33m 0x7fd9a1816d28\u001b[0m\u001b[0;1;36m &apos;__NSConstantString_tag&apos;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817040\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __builtin_ms_va_list\u001b[0m \u001b[0;32m&apos;char *&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mPointerType\u001b[0m\u001b[0;33m 0x7fd9a1817000\u001b[0m \u001b[0;32m&apos;char *&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816780\u001b[0m \u001b[0;32m&apos;char&apos;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817308\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit referenced\u001b[0;1;36m __builtin_va_list\u001b[0m \u001b[0;32m&apos;struct __va_list_tag [1]&apos;\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mConstantArrayType\u001b[0m\u001b[0;33m 0x7fd9a18172b0\u001b[0m \u001b[0;32m&apos;struct ... 有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。 AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST。 八、CodeGenCodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。 1xcrun clang -S -emit-llvm main.c -o main.ll main.ll 文件内容： 12345678910111213141516; ModuleID = &apos;main.c&apos;source_filename = &quot;main.c&quot;target datalayout = &quot;e-m:o-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-apple-macosx10.13.0&quot;@.str = private unnamed_addr constant [13 x i8] c&quot;hello debug\\0A\\00&quot;, align 1; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 &#123; %1 = alloca i32, align 4 store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret i32 0&#125;... Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。 LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass。 九、生成汇编代码LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。 生成 arm 64 汇编： 1$ xcrun clang -S main.c -o main.s 查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：iOS汇编快速入门。 12345678910111213141516171819202122232425262728293031 .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp leaq L_.str(%rip), %rdi movl $0, -4(%rbp) movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz &quot;hello debug\\n&quot; .subsections_via_symbols 十、汇编器汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 1$ xcrun clang -fmodules -c main.c -o main.o 还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号 123$ xcrun nm -nm main.o (undefined) external _printf0000000000000000 (\\_\\_TEXT,\\_\\_text) external _main _printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。 10.1 什么是符号（Symbols）?符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。 十一、链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。 1$ xcrun clang main.o -o main 就得到了一个 mach o 格式的可执行文件 123456789101112$ file mainmain: Mach-O 64-bit executable x86_64$ ./mainhello debug再用 nm 命令，查看可执行文件的符号表：$ nm -nm main (undefined) external _printf (from libSystem) (undefined) external dyld\\_stub\\_binder (from libSystem)0000000100000000 (\\_\\_TEXT,\\_\\_text) \\[referenced dynamically\\] external \\_\\_mh\\_execute_header0000000100000f60 (\\_\\_TEXT,\\_\\_text) external _main _printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。 十二、XCode 编译通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？ 新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志： 详细的步骤： 创建 Product.app 的文件夹 把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。 创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。 执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。 编译 .m 文件，生成 .o 文件。 链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。 编译 assets，编译 storyboard，链接 storyboard 拷贝动态库 Logger.framework，并且对其签名 执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework 对 Demo.App 签名，并验证（validate） 生成 Product.app 生成 dYSM 文件 Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。 十三、编译顺序编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？ 答案是：依赖关系。 还是以刚刚的 Demo 项目为例，整个依赖关系如下： 可以从 XCode 的 Report Navigator 看到 Target 的编译顺序： XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。 那么，XCode 又从哪里得到了这些依赖关系呢？ Target Dependencies - 显式声明的依赖关系 Linked Frameworks and Libraries - 隐式声明的依赖关系 Build Phase - 定义了编译一个 Target 的每一步 十四、增量编译日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？ 因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。 比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。 十五、头文件C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。 头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。 当只有声明，没有实现的时候，链接器就会报错。 12345Undefined symbols for architecture arm64:“_umimplementMethod”, referenced from:-\\[ClassA method\\] in ClassA.old: symbol(s) not found for architecture arm64clang: error: linker command failed with exit code 1 (use -v to see invocation) Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。 日常开发中，两种常见的头文件引入方式： 12#include &quot;CustomClass.h&quot; // 自定义#include &lt;Foundation/Foundation.h&gt; // 系统或者内部 framework 引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？ 回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志： 把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的： 12345678910111213141516171819#include &quot;...&quot; search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap) /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers #include &lt;...&gt; search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources /Users/.../Build/Products/Debug-iphoneos (framework directory) /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory) /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory) /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include $SDKROOT/usr/include $SDKROOT/System/Library/Frameworks (framework directory) End of search list. 这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。 可以通过一个辅助的小工具 hmap 查看 hmap 中的内容： 1234567$ ./hmap print Demo-project-headers.hmap AppDelegate.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.hDemo-Bridging-Header.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.hDummy.h -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.hFramework.h -&gt; Framework/Framework.hTestView.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.hViewController.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h 这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。 clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找： 12/Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/TestView.h/Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers/TestView.h 系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。 以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时： 首先查找 framework 是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework 如果 framework 存在，再在 headers 目录里查找头文件是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework/headers/Foundation.h 十六、Clang Module传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的： 大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。 文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。 边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。 clang module 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。 XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。 #import &lt;Foundation/NSString.h&gt; 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。 那么，如何定义一个 module 呢？答案是：modulemap 文件，这个文件描述了一组头文件如何转换为一个 module，举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546framework module Foundation \\[extern_c\\] \\[system\\] &#123; umbrella header &quot;Foundation.h&quot; // 所有要暴露的头文件 export * module * &#123; export * &#125; explicit module NSDebug &#123; //submodule header &quot;NSDebug.h&quot; export * &#125; &#125;``` swift 是可以直接 import 一个 clang module 的，比如你有一些 C 库，需要在 Swift 中使用，就可以用 modulemap 的方式。## 十七、Swift 编译现代化的语言几乎都抛弃了头文件，swift 也不例外。问题来了，swift 没有头文件又是怎么找到声明的呢？&gt; 编译器干了这些脏活累活。编译一个 Swift 头文件，需要解析 module 中所有的 Swift 文件，找到对应的声明。![29](https://upload-images.jianshu.io/upload_images/5294842-bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)当开发中难免要有 Objective-C 和 Swift 相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？### 17.1 Swift 引用 Objective-CSwift 的编译器内部使用了 clang，所以 swift 可以直接使用 clang module，从而支持直接 import Objective-C 编写的framework。![30](https://upload-images.jianshu.io/upload_images/5294842-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) swift 编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：* Bridging-Header.h 中暴露给 swfit 的头文件* framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。XCode 提供了宏定义 NS\\_SWIFT\\_NAME 来让开发者定义 Objective-C =&gt; Swift的符号映射，可以通过 Related Items -&gt; Generate Interface 来查看转换后的结果：![31](https://upload-images.jianshu.io/upload_images/5294842-bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 17.2 Objective-C 引用 swiftxcode 会以 module 为单位，为 swift 自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-Swift.h。swift 提供了关键词 @objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。 @objc public class MyClass12345678910111213141516171819## 十八、深入理解 Linker&gt; &lt;font color=#cc0000&gt;链接器会把编译器编译生成的多个文件，链接成一个可执行文件&lt;/font&gt;。链接并不会产生新的代码，只是在现有代码的基础上做&lt;font color=#cc0000&gt;移动和补丁&lt;/font&gt;。链接器的输入可能是以下几种文件：* object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。* 动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载* 静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。* tbd，只包含符号的库文件这里提到了一个概念：符号（Symbols），那么符号是什么呢？&gt; 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。以一段代码为例，看看链接时究竟发生了什么？源代码： (void)log{ printf(“hello world\\n”);}12.o 文件： #代码adrp x0, l.str@PAGEadd x0, x0, l.str@PAGEOFFbl _printf #字符串符号l_.str: ; @.str .asciz “hello world\\n”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172在 .o 文件中，字符串 &quot;hello world\\\\n&quot; 作为一个符号（l\\_.str）被引用，汇编代码读取的时候按照 l\\_.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：1. l_.str 在可执行文件的哪个位置？2. printf 函数来自哪里？再来看看链接之后的 mach o 文件：![32](https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)链接器如何解决这两个问题呢？1. 链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。2. 链接后，不再是调用符号 \\_printf，而是在 DATA 段上创建了一个函数指针 \\_printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 _printf 地址。更多细节，可以参考这篇文章：[深入理解iOS App的启动过程](https://blog.csdn.net/Hello_Hwc/article/details/78317863)。Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。## 十九、理解签名### 19.1 基础回顾非对称加密在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。数字签名数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。![33](https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。![34](https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。&gt; 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。## 二十、iOS App 签名为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。除此之外，Apple 要严格控制 App 的分发：1. App 来自 Apple 信任的开发者2. 安装的设备是 Apple 允许的设备### 20.1 证书通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。![35](https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.2 Provisioning ProfileiOS App 安装到设备的途径（非越狱）有以下几种：* 开发包（插线，或者 archive 导出 develop 包）* Ad Hoc* App Store* 企业证书开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。![36](https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)可以通过以下命令来查看 Provisioning Profile 中的内容： security cms -D -i embedded.mobileprovision &gt; result.plistopen result.plist12345678910本质上就是一个编码过后的 plist。![37](https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.3 iOS 签名生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名 Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nibT2g5jlq7EVFHNzL/ip3fSoXKoOI= Info.plist5aVg/3m4y30m+GSB8LkZNNU3mug= PkgInfon57qDP4tZfLD1rCS43W0B4LQjzE= embedded.mobileprovisiontm/I1g+0u2Cx9qrPJeC0zgyuVUE=…` 代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名： 20.4 验证20.4.1 安装 App 的时候 从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者 证书验证通过后，从证书中取出 Leo 的公钥 读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确 文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证） 验证通过后，安装 App 20.4.2 启动 App 的时候 验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致 判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证 如果是企业证书，验证用户是否信任企业证书 App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。 以上都验证通过，App 才能正常启动","tags":[]},{"title":"iOS 静态库和动态库","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS/iOS原理/iOS 静态库和动态库/","text":"一、库1.1 什么是库？库就是程序代码的集合，将 N 个文件组织起来，是共享程序代码的一种方式。从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。 1.2 库的分类根据程序代码的开源情况，库可以分为两类 开源库 源代码是公开的，你可以看到具体实现。比如知名的第三方框架：AFNetworking、SDWebImage。 闭源库 不公开源代码，只公开调用的接口，看不到具体的实现，是一个编译后的二进制文件。这种常见于一些公司的 SDK 包，比如高德地图 SDK、环信即时通讯 SDK 等。而闭源库又分为两类：静态库和动态库。 1.3 从源代码到 app当我们点击了 build 之后，做了什么事情呢？ 预处理（Pre-process）：把宏替换、删除注释、展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对 .o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 1.4 iOS 设备的 CPU 架构模拟器： 4s-5: i386 5s-iPhone X（包括 iPhone SE）: x86_64 真机（iOS设备）： armv6：iPhone、iPhone 2、iPhone 3G、iPod Touch（第一代）、iPod Touch（第二代） armv7：iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2 armv7s：iPhone 5、iPhone 5c（静态库只要支持了 armv7，就可以在 armv7s 的架构上运行，向下兼容） arm64：iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3、iPhone 7、iPhone 7 Plus、iPhone 8、iPhone 8 Plus、iPhone X 二、静态库和动态库静态和动态是相对编译期和运行期而言的： 静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库；动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入。 存在形式： 静态库 以 “.a” 或者 “.framework” 为文件后缀名。 &lt;font color=#cc0000&gt;.a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件&lt;/font&gt;。.a 要有 .h 文件以及资源文件配合，.framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用 .framework 的形式。 动态库 以 “.dylib” 或者 “.framework” 为文件后缀名（Xcode7 之后 .tbd 代替了 .dylib） 使用区别： 静态库链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中。 它的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用。而且系统只加载一次，多个程序共用，节省内存。 相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 各自优点： 静态库： ①、模块化，分工合作，提高了代码的复用及核心技术的保密程度 ②、避免少量改动经常导致大量的重复编译连接 ③、也可以重用，注意不是共享使用 动态库： ①、可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小②、多个应用程序共享内存中得同一份库文件，节省资源③、可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的④、应用插件化⑤、软件版本实时模块升级⑥、在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。 在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，苹果系统专属的 framework 是共享的（如 UIKit），使用 Cocoa Touch Framework 制作的动态库在打包和提交 app 时会被放到 app main bundle 的根目录中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 三、静态库的处理方式 对于一个静态库而言，其实已经是编译好的了（类似一个 .o 的集合），这里并没有连接。在 build 的过程中只会参与链接的过程，而这个链接的过程简单的讲就是合并，并且链接器只会将静态库中被使用的部分合并到可执行文件中去。相比较于动态库，静态库的处理起来要简单的多，具体如下图： 链接器会将所有 .o 用到的 global symbol 和 unresolved symbol 放入一个临时表，而且是 global symbol 是不能重复的。 对于静态库的 .o，链接器会将没有任何 symbol 在 unresolved symbol table 的给忽略。 unresolved symbol 类似 extern int test(); — .h 的声明? global symbol 类似 void test() { print(“test”) } -- .m 的实现? 最后，链接器会用函数的实际地址来代替函数引用。 四、动态库的处理方式 首先，对于动态库而言其实分动态链接库和动态加载库两种的，这两个最本质的区别还是加载时间。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后】 但是不论是哪种动态库，相比较与静态库，动态库处理起来要棘手的多。由于动态库是动态的，所以你事先不知道某个函数的具体地址，因此动态链接器在链接函数的时候需要做大量的工作。 因为动态库在链接函数需要做大量的工作，而静态库已经实现处理好了。所以单纯的在所有都没有加载的情况下，静态库的加载速度会更快一点。而在 iOS 开发中的『库』(一) 提到的有所不妥，正确应该是，虽然动态库更加耗时，但是对于加载过的 share libraries 不需要再加载的这个前提下，使用动态库可以节省一些启动时间。 而实现这个动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果每个函数都被调用过的话，下一次调用就可以通过 PLT 直接跳转了，但是和静态库还是有点区别的是，每一个函数的调用还是需要通过一张 PLT。这也正是 sunny 所说的所有静态链接做的事情都搬到运行时来做了，会导致更慢的原因。 五、动态库的作用 应用插件化 每一个功能点都是一个动态库，在用户想使用某个功能的时候让其从网络下载，然后手动加载动态库，实现功能的的插件化。 虽然技术上来说这种动态更新是可行的，但是对于 AppStore 上上架的 app 是不可以的。iOS8 之后虽然可以上传含有动态库的 app，但是苹果不仅需要你动态库和 app 的签名一致，而且苹果会在你上架的时候再经过一次 AppStore 的签名。所以你想在线更新动态库，首先你得有苹果 AppStore 私钥，而这个基本不可能。 除非你的应用不需要通过 AppStore 上架，比如企业内部的应用，通过企业证书发布，那么就可以实现应用插件化在线更新动态库了。 共享可执行文件 在其它大部分平台上，动态库都可以用于不同应用间共享，这就大大节省了内存。从目前来看，iOS 仍然不允许进程间共享动态库，即 iOS 上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 六、签名系统在加载动态库时，会检查 framework 的签名，签名中必须包含 TeamIdentifier，并且 framework 和 host app 的 TeamIdentifier 必须一致。 我们在 Debug 测试的时候是不会报错的，在打包时如果有动态库，那么就会检查 TeamIdentifier。 如果不一致，否则会报下面的错误： 1Error loading /path/to/framework: dlopen(/path/to/framework, 265): no suitable image found. Did find:/path/to/framework: mmap() error 1 如果用来打包的证书是 iOS 8 发布之前生成的，则打出的包验证的时候会没有 TeamIdentifier 这一项。这时在加载 framework 的时候会报下面的错误： 1[deny-mmap] mapped file has no team identifier and is not a platform binary:/private/var/mobile/Containers/Bundle/Application/5D8FB2F7-1083-4564-94B2-0CB7DC75C9D1/YourAppNameHere.app/Frameworks/YourFramework.framework/YourFramework 可以通过 codesign 命令来验证。 123codesign -dv /path/to/YourApp.app或codesign -dv /path/to/YourFramework.framework 如果证书太旧，输出的结果如下： 12345678910Executable=/path/to/YourApp.app/YourAppIdentifier=com.company.yourappFormat=bundle with Mach-O thin (armv7)CodeDirectory v=20100 size=221748 flags=0x0(none) hashes=11079+5 location=embeddedSignature size=4321Signed Time=2015年10月21日 上午10:18:37Info.plist entries=42TeamIdentifier=not setSealed Resources version=2 rules=12 files=2451Internal requirements count=1 size=188 注意其中的 TeamIdentifier=not set。 我们在用 cocoapods 的 use_framework! 的时候生成的动态库也可以用 codesign -dv /path/to/youFramework.framework 查看到 TeamIdentifier=not set。 七、Framework7.1 什么是 FrameworkFramework 是 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。一般如果是静态 Framework 的话，资源打包进 Framework 是读取不了的。静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 下面的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 Cocoa/Cocoa Touch 开发框架本身提供了大量的 Framework，比如 Foundation.framework/UIKit.framework 等。需要注意的是，这些 Framework 无一例外都是动态库。 平时用的第三方 SDK 的 Framework 都是静态库，真正的动态库是上不了 AppStore（iOS8 之后能上 AppStore，因为 App Extension，需要动态库支持)。 Framework 为什么既是静态库又是动态库？ 系统的 .framework 是动态库，我们自己建立的 .framework 一般都是静态库。但是现在用 xcode 创建Framework 的时候默认是动态库，一般打包成 SDK 给别人用的话都使用的是静态库，可以修改 Build Settings的 Mach-O Type 为 Static Library。 八、Framework 目录 Headers 表示暴露的头文件，一般都会有一个和 Framework 同名的 .h 文件，在创建 Framework 的时候文件夹里也会默认生成这样一个文件。有这个和 Framework 同名的 .h 文件 @import 导入库的时候编译器才能找到这个库（@import 导入头文件可参考 iOS里的导入头文件）。 info.plist 主要就是这个 Framework 的一些配置信息。 Modules 这个文件夹里有个 module.modulemap 文件 123456framework module DynamicFramework &#123; umbrella header &quot;DynamicFramework.h&quot; export * module * &#123; export * &#125;&#125; 这里面有这样一句 umbrella header “DynamicFramework.h”，umbrella 有保护伞、庇护的意思。 也就是说 Headers 中暴露的 DynamicFramework.h 文件被放在 umbrella 雨伞下保护起来了，所以我们需要将其他的所有需要暴露的 .h 文件放到 DynamicFramework.h 文件中保护起来，不然会出现警告。@import 的时候也只能找到 umbrella 雨伞下保护起来的 .h 文件。 二进制文件（Unix 可执行文件） 这个就是你源码编译而成的二进制文件，主要的执行代码就在这个里面。 .bundle 文件 如果我们在 Build Phases -&gt; Copy Bundle Resources 里加入 .bundle 文件，那么创建出来的 .Framework 里就会有这个 .bundle 的资源文件夹。 九、Framework 的资源文件CocoaPods 如何生成 Framework 的资源文件？ 我们能看到用 cocoapods 创建 Framework 的时候，Framework 里面有一个 .bundle 文件，跟 Framework 同级目录里也有一个 .bundle文件。这两个文件其实是一样的。 那这两个 .bundle 是怎么来的呢？我们能看到用 use_frameworks! 生成的 pod 里面，pods 这个 PROJECT 下面会为每一个 pod 生成一个 target。 那么如果这个 pod 有资源文件的话，就会有一个叫 xxx-bundleName 的 target，最后这个 target 生成的就是 bundleName.bundle。 在 xxx 的 target 的 Build Phases -&gt; Copy Bundle Resources 里加入这个 .bundle，在 Framework 里面就会生成这样一个 bundle。在 xxx 的 target 的 Build Phases -&gt; Target Dependencies 里加入这个 target：xxx-bundleName，就会在 Framework 的同级目录里生成这样一个 bundle。 静态 Framework 里不需要加入资源文件。一般资源打包进静态 Framework 是读取不了的。 静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 你可以用 NSBundle * bundle = [[NSBundle mainBundle] bundlePath]; 得到 .app 目录，如果是动态库你能在 Framework 目录下看到这个动态库以及动态库里面资源文件。然后你只要用 NSBundle * bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;]; 得到这个动态库的路径就能读取到里面的资源了。但是如果是静态库的话，因为编译进了可执行文件里面，你也就没办法读到这个静态库了，你能看到 .app 下的 Framework 目录为空。 在 Framework 或子工程中使用 xib 十、问题 如果静态库中有 category 类，则在使用静态库的项目配置中【Other Linker Flags】需要添加参数[-ObjC] 或者 [-all_load]。 出现 Umbrella header for module ‘XXXX’ does not include header ‘XXXXX.h’ 因为把 xxxxx.h 错误的拖到了 public 中。 出现 dyld: Library not loaded:XXXXXX 是因为打包的 Framework 版本太高。比如打包 Framework 时，选择的是 iOS 9.0，而实际的工程环境是 iOS 8 开始的。需要到 iOS Deployment Target 设置对应版本。 报错 “Include of non-modular header inside framework module” 如果创建的 Framework 类中使用了 .dylib 或者 .tbd，首先需要在实际项目中导入 .dylib 或者 .tbd 动态库，然后需要设置 Allow Non-modular Includes In Framework Modules = YES 有时候我们会发现在使用的时候加载不了动态 Framework 里的资源文件，其实是加载方式不对，比如用 pod 的时候使用的是 use_frameworks!，那么资源是在 Framework 里面的，需要使用以下代码加载（具体可参考给pod添加资源文件）： 1234NSBundle * bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;];NSString * path = [bundle pathForResource:@&quot;imageName@2x&quot;(@&quot;bundleName.bundle/imageName@2x&quot;) ofType:@&quot;png&quot;];UIImage * image = [UIImage imageWithContentsOfFile:path]; 报错 Reason: image not found 如果直接在工程里使用创建的动态库时候会出现此错误，需要在工程的 General 里的 Embedded Binaries 添加这个动态库才能使用。 因为创建的这个动态库其实也不能给其他程序使用的，而你的 App Extension 和 APP 之间是需要使用这个动态库的。这个动态库可以 App Extension 和 APP 之间共用一份（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。 十一、Swift 支持跟着 iOS8/Xcode6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种：1、把代码拷贝到工程中；2、用动态 Framework。使用静态库是不支持的。 造成这个问题的原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的运行库（这是苹果自家的解释）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考这个问题的问题描述，也是来自苹果自家文档）。 十二、CocoaPods 的做法在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应着一个 Pod 的静态库。 当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 vendored_framework 选项来使用第三方 Framework。 对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持。通过 use_frameworks! 选项控制。对于 Swift 写的库来说，想通过 CocoaPods 引入工程，必须加入 use_frameworks! 选项。 十三、关于 use_frameworks!在使用 CocoaPods 的时候在 Podfile 里加入 use_frameworks!，那么你在编译的时候就会默认帮你生成动态库，我们能看到每个源码 Pod 都会在 Pods 工程下面生成一个对应的动态库 Framework 的 target，我们能在这个 target 的 Build Settings -&gt; Mach-O Type 看到默认设置是 Dynamic Library，也就是会生成一个动态 Framework，我们能在 Products 下面看到每一个 Pod 对应生成的动态库。 这些生成的动态库将链接到主项目给主工程使用，但是我们上面说过动态库需要在主工程 target 的 General -&gt; Embedded Binaries 中添加才能使用，而我们并没有在 Embedded Binaries 中看到这些动态库。那这是怎么回事呢，其实是 cocoapods 已经执行了脚本把这些动态库嵌入到了 .app 的 Framework 目录下，相当于在 Embedded Binaries 加入了这些动态库。我们能在主工程 target 的 Build Phase -&gt; Embed Pods Frameworks 里看到执行的脚本。 所以 Pod 默认是生成动态库，然后嵌入到 .app 下面的 Framework 文件夹里。我们去 Pods 工程的 target 里把 Build Settings -&gt; Mach-O Type 设置为 Static Library。那么生成的就是静态库，但是 cocoapods 也会把它嵌入到 .app 的Framework目录下，而因为它是静态库，所以会报错：unrecognized selector sent to instanceunrecognized selector sent to instance。 十四、参考创建一个 iOS Framework 项目Xcode7创建静态库和FrameworkiOS 静态库开发静态库与动态库的使用iOS 静态库，动态库与 Framework签名iOS打包静态库（完整篇）iOS armv7、armv7s、 arm64iOS 创建 .a 和 .framework 静态库，以及 Bundle 资源文件的使用iOS 静态库和动态库（库详解）齐滇大圣 &amp; iOS里的动态库和静态库","tags":[]},{"title":"HTTPS 单向认证和双向认证","date":"2019-05-23T10:19:03.941Z","path":"2019/05/23/计算机网络/HTTPS 单向认证和双向认证/","text":"一、HttpHyperText Transfer Protocol 超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准。HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。 使用 TCP 端口为：80 二、HttpsHyper Text Transfer Protocol over Secure Socket Layer 安全的超文本传输协议，网景公司设计了 SSL（Secure Sockets Layer） 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。 使用 TCP 端口默认：443 三、SSL 协议加密方式SSL 协议既用到了对称加密也用到了非对称加密（公钥加密），在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密。 对称加密 速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 四、单向认证Https 在建立 Socket 连接之前，需要进行握手，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 五、双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式，将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 六、文章Https单向认证和双向认证","tags":[]},{"title":"pthread_rwlock_t","date":"2019-05-23T10:19:03.941Z","path":"2019/05/23/iOS/iOS原理/pthread_rwlock_t/","text":"一、读写锁读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。 读操作可以共享，写操作是排他的，可以有多个在读（与 CPU 数相关），只能有唯一个在写，但不能同时既有读者又有写者。 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。 具有强读者同步和强写者同步两种形式： 强读者同步：当写者没有进行写操作，读者就可以访问； 强写者同步：当所有写者都写完之后，才能进行读操作。 在强写者情况，读者需要最新的信息，一些事实性较高的系统可能会用到该锁，比如定票之类的。 二、特性一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。 正因为这个特性，当读写锁是写加锁状态时，在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞。 当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁，它必须直到所有的线程释放锁。 通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞. 读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享，以写模式锁住时意味着独占，所以读写锁又叫共享-独占锁。 三、小结 互斥锁与读写锁的区别 当访问临界区资源时（访问的含义包括所有的操作：读和写），需要上互斥锁； 当对数据（互斥锁中的临界区资源）进行读取时，需要上读取锁，当对数据进行写入时，需要上写入锁。 读写锁的优点 对于读数据比修改数据频繁的应用，用读写锁代替互斥锁可以提高效率。因为使用互斥锁时，即使是读出数据（相当于操作临界区资源）都要上互斥锁，而采用读写锁，则可以在任一时刻允许多个读者存在，提供了更高的并发度，同时在某个写入者修改数据期间保护该数据，以免任何其它读出者或写入者的干扰。 读写锁描述： 获取一个读写锁用于读称为共享锁，获取一个读写锁用于写称为独占锁，因此这种对于某个给定资源的共享访问也称为共享-独占上锁。 四、使用读写锁配置读写锁的属性之后，即可初始化读写锁。以下函数用于初始化或销毁读写锁、锁定或解除锁定读写锁或尝试锁定读写锁。 初始化读写锁 使用 pthread_rwlock_init(3C) 通过 attr 所引用的属性初始化 rwlock 所引用的读写锁。 12345678910/** * @param attr 如果为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同 * * @return 如果成功，返回 0，否则将返回用于指明错误的错误号。 EINVAL : attr 或者 rwlock 指定的值无效 */int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 如果 attr 为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同。 初始化读写锁之后，该锁可以使用任意次数，而无需重新初始化。成功初始化之后，读写锁的状态会变为已初始化和未锁定。如果调用 pthread_rwlock_init() 来指定已初始化的读写锁，则结果是不确定的。如果读写锁在使用之前未初始化，则结果是不确定的。 如果缺省的读写锁属性适用，则 PTHREAD_RWLOCK_INITIALIZER 宏可初始化以静态方式分配的读写锁，其作用与通过调用pthread_rwlock_init() 并将参数 attr 指定为 NULL 进行动态初始化等效，区别在于不会执行错误检查。 如果 pthread_rwlock_init() 失败，将不会初始化 rwlock，并且 rwlock 的内容是不确定的。 获取读写锁中的读锁 pthread_rwlock_rdlock(3C) 可用来向 rwlock 所引用的读写锁应用读锁。 1234567#include &lt;pthread.h&gt;/** * @return 如果成功，返回 0。否则，将返回用于指明错误的错误号。 EINVAL : attr 或 rwlock 指定的值无效 * */int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 如果写入器未持有读锁，并且没有任何写入器基于该锁阻塞，则调用线程会获取读锁。如果写入器未持有读锁，但有多个写入器正在等待该锁时，调用线程是否能获取该锁是不确定的。如果某个写入器持有读锁，则调用线程无法获取该锁。如果调用线程未获取读锁，则它将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_rdlock() 返回。如果在进行调用时，调用线程持有 rwlock 中的写锁，则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 一个线程可以在 rwlock 中持有多个并发的读锁，该线程可以成功调用 pthread_rwlock_rdlock() n 次。该线程必须调用 pthread_rwlock_unlock() n 次才能执行匹配的解除锁定操作。 如果针对未初始化的读写锁调用 pthread_rwlock_rdlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行读取，就好像线程未中断一样。 读取非阻塞读写锁中的锁 pthread_rwlock_tryrdlock(3C)应用读锁的方式与 pthread_rwlock_rdlock() 类似，区别在于如果任何线程持有 rwlock 中的写锁或者写入器基于 rwlock 阻塞，则 pthread_rwlock_tryrdlock() 函数会失败。 123456789#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行读取的锁，返回 0。否则，返回用于指明错误的错误号 * * EBUSY : 无法获取读写锁以执行读取，因为写入器持有该锁或者基于该锁已阻塞 */int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); 写入读写锁中的锁 pthread_rwlock_wrlock(3C) 可用来向 rwlock 所引用的读写锁应用写锁。 1234567#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行写入的锁，返回 0。否则，返回指明错误的错误号 */int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); 如果没有其他读取器线程或写入器线程持有读写锁 rwlock，则调用线程将获取写锁，否则，调用线程将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_wrlock() 调用返回。如果在进行调用时，调用线程持有读写锁（读锁或写锁），则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 如果针对未初始化的读写锁调用 pthread_rwlock_wrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 写入非阻塞读写锁中的锁 pthread_rwlock_trywrlock(3C)应用写锁的方式与 pthread_rwlock_wrlock() 类似，区别在于如果任何线程当前持有用于读取和写入的 rwlock，则pthread_rwlock_trywrlock() 函数会失败。 1234567#include &lt;pthread.h&gt;/** * @return 如果获取了用于在 rwlock 引用的读写锁对象中执行写入的锁，则返回 0，否则，返回用于指明错误的错误号 * EBUSY : 无法为写入获取读写锁，因为已为读取或写入锁定该读写锁 */int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); 如果针对未初始化的读写锁调用 pthread_rwlock_trywrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 解除锁定读写锁 pthread_rwlock_unlock(3C) 可用来释放在 rwlock 引用的读写锁对象中持有的锁。 123456#include &lt;pthread.h&gt;/** * @return 如果成功返回 0，否则返回用于指明错误的错误号 */int pthread_rwlock_unlock (pthread_rwlock_t *rwlock); 如果调用线程未持有读写锁 rwlock，则结果是不确定的。 如果通过调用 pthread_rwlock_unlock() 来释放读写锁对象中的读锁，并且其他读锁当前由该锁对象持有，则该对象会保持读取锁定状态。如果 pthread_rwlock_unlock() 释放了调用线程在该读写锁对象中的最后一个读锁，则调用线程不再是该对象的属主。如果 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个读锁，则该读写锁对象将处于无属主、解除锁定状态。 如果通过调用 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个写锁，则该读写锁对象将处于无属主、解除锁定状态。 如果 pthread_rwlock_unlock() 解除锁定该读写锁对象，并且多个线程正在等待获取该对象以执行写入，则通过调度策略可确定获取该对象以执行写入的线程。如果多个线程正在等待获取读写锁对象以执行读取，则通过调度策略可确定等待线程获取该对象以执行写入的顺序。如果多个线程基于 rwlock 中的读锁和写锁阻塞，则无法确定读取器和写入器谁先获得该锁。 如果针对未初始化的读写锁调用 pthread_rwlock_unlock()，则结果是不确定的。 销毁读写锁 pthread_rwlock_destroy(3C) 可用来销毁 rwlock 引用的读写锁对象并释放该锁使用的任何资源。 12345678#include &lt;pthread.h&gt;/** * @return 如果成功，返回 0。否则，返回用于指明错误的错误号。EINVAL : attr 或者 rwlock 指定的值无效 */int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 再次调用 pthread_rwlock_init() 重新初始化该锁之前，使用该锁所产生的影响是不确定的。实现可能会导致 pthread_rwlock_destroy() 将 rwlock 所引用的对象设置为无效值。如果在任意线程持有 rwlock 时调用 pthread_rwlock_destroy()，则结果是不确定的。尝试销毁未初始化的读写锁会产生不确定的行为。已销毁的读写锁对象可以使用 pthread_rwlock_init() 来重新初始化。销毁读写锁对象之后，如果以其他方式引用该对象，则结果是不确定的。 五、文章百度百科","tags":[]},{"title":"Sql","date":"2019-05-23T10:19:03.925Z","path":"2019/05/23/数据结构/sql/","text":"一、SQL 语句 什么是 SQL SQL 全称 structured query language 结构化查询语言，是用于访问和处理数据库的标准的计算机语言。 - SQL 指结构化查询语言 - SQL 使我们有能力访问数据库 - SQL 是一种 [ANSI](https://www.ansi.org/) 的标准计算机语言 SQL 能做什么？ SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。 SQL 面向数据库执行查询 SQL 可从数据库取回数据 SQL 可在数据库中插入新的记录 SQL 可更新数据库中的数据 SQL 可从数据库删除记录 SQL 可创建新数据库 SQL 可在数据库中创建新表 SQL 可在数据库中创建存储过程 SQL 可在数据库中创建视图 SQL 可以设置表、存储过程和视图的权限 RDBMS RDBMS 指的是关系型数据库管理系统。 RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础。 RDBMS 中的数据存储在被称为表（tables）的数据库对象中。表是相关的数据项的集合，它由列和行组成。 什么是 SQL 语句 使用 SQL 语言编写出来的句子/代码，就是 SQL 语句。在程序运行过程中，要想操作数据库中的数据，必须使用 SQL 语句。 SQL 语句的特点 不区分大小写（比如数据库认为 user 和UsEr 是一样的） 每条语句都必须以分号 ‘;’ 结尾。分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。如果使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。 SQL 中的常用关键字 select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index 等等。数据库中不可以使用关键字来命名表、字段。 二、SQL 语句的种类 数据定义语句（DDL:Data Definition Language）可以用于对数据库中的表进行操作。包括 create、drop、alter。 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 数据操作语句（DML:Data Manipulation Language）可以用于对数据库中的数据进行操作。包括insert、update、delete。 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 数据查询语句（DQL:Data Query Language）可以用于查询获得表中的数据。关键字 select 是DQL(也是所有 SQL)用得最多的操作。其他 DQL 常用的关键字有 where、order by、group by 和 having。 三、基本操作 创建表 create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); 1create table t_st (id integer, name text, age integer, score real); 字段类型 SQLite 将数据划分为以下几种存储类型： text 文本字符串 real 浮点值 integer 整型值 blob 二进制数据(比如文件) 注意：实际上 SQLite 是无类型的，就算声明为 integer 类型，还是能存储字符串文本(主键除外)。建表时声明任何类型或者不声明类型都可以，也就意味着创表语句可以这么写： 1create table t_st(name, age); 提示：为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型。 删表 drop table 表名; drop table if exists 表名; 示例： 1drop table t_st; 插入数据 insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …); 示例： 1insert into t_st (name, age) values (&apos;mj&apos;, 10); 注意：数据库中的字符串内容应该用单引号括住。 更新数据 update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, …; 示例： 1update t_st set name = &apos;jack&apos;, age = 20; 注意：上面的示例会将 t_st 表中所有记录的 name 都改为 jack，age 都改为 20 删除数据 delete from 表名 ; 示例： 1delete from t_st ; 注意：上面的示例会将 t_st 表中所有记录都删掉。 条件语句 如果只想更新或者删除某些固定的记录，那就必须在 DML 语句后加上一些条件。 条件语句的常见格式： 1234567where 字段 = 某个值 ; // 不能用 ==where 字段 is 某个值 ; // is 相当于 =where 字段 != 某个值 ; where 字段 is not 某个值 ; // is not 相当于!= where 字段 &gt; 某个值 ; where 字段1 = 某个值 and 字段2 &gt; 某个值 ; // and 相当于 C 语言中的 &amp;&amp;where 字段1 = 某个值 or 字段2 = 某个值 ; // or 相当于 C 语言中的 || 示例： 1234567891011①、将 t_st 表中年龄大于 10 并且 姓名不是 jack 的记录，年龄都改为 5update t_st set age = 5 where age &gt; 10 and name != &apos;jack&apos; ;②、删除 t_st 表中年龄小于等于 10 或者年龄大于 30 的记录delete from t_st where age &lt;= 10 or age &gt; 30 ;③、将 t_st 表中名字等于 jack 的记录，score 字段的值都改为 age 字段的值update t_st set score = age where name = &apos;jack&apos; ; DQL 语句 12select 字段1, 字段2, ... from 表名 ;select * from 表名; // 查询所有的字段 示例： 1select name, age from t_st where age &gt; 10 ; 起别名(字段和表都可以起别名) 123select 字段1 别名, 字段2 别名, ... from 表名 别名 ;select 别名.字段1, 别名.字段2, ... from 表名 别名 ;select 字段1 别名, 字段2 as 别名, ... from 表名 as 别名 ; 示例： 1select name myname, s.age from t_st as s ; 计算记录的数量 12select count (字段) from 表名 ;select count ( * ) from 表名 ; 示例： 1select count (age) from t_st where score &gt;= 60; 排序 select * from t_st order by 字段 ; 默认是按照升序排序(由小到大)，也可以变为降序(由大到小) select * from t_st order by age desc ; // 降序 select * from t_st order by age asc ; // 升序(默认) 也可以用多个字段进行排序。 // 先按照年龄升序，相同年龄再按照身高降序 select * from t_st order by age asc, height desc ; limit 使用 limit 可以精确地控制查询结果的数量，比如每次只查询 10 条数据 select * from 表名 limit 数值1, 数值2 ; 示例： 1select * from t_st limit 4, 8 ; // 跳过最前面 4 条语句，然后取8 条记录 limit 常用来做分页查询，比如每页固定显示 5 条数据，那么应该这样取数据： 1第 n 页：limit 5*(n-1), 5 // limit 5 相当于limit 0, 5 取最前面的5 条 四、约束 简单约束 建表时可以给特定的字段设置一些约束条件，常见的约束有 not null 规定字段的值不能为 null unique 规定字段的值必须唯一 default 指定字段的默认值 建议：尽量给字段设定严格的约束，以保证数据的规范性。 示例： 1create table st (id integer, name text not null unique, age integer not null default 1) ; // name 字段不能为null，并且唯一；age 字段不能为null，并且默认为 1 主键约束 ①、简单说明 如果 t_st 表中就 name 和 age 两个字段，而且有些记录的 name 和 age 字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据。 良好的数据库编程规范应该要保证每条记录的唯一性。为此，增加了主键约束，也就是说，每张表都必须有一个主键，用来标识记录的唯一性 ②、什么是主键？ 主键(Primary Key，简称 PK)用来唯一地标识某一条记录。例如：t_st 可以增加一个 id 字段作为主键，相当于人的身份证。主键可以是一个字段或多个字段。 ③、主键的设计原则 主键应当是对用户没有意义的 永远也不要更新主键 主键不应包含动态变化的数据 主键应当由计算机自动生成 ④、主键的声明 在创表的时候用 primary key 声明一个主键 123// integer 类型的id 作为t_st 表的主键create table t_st (id integer primary key, name text, age integer); 只要声明为 primary key，就说明是一个主键字段。主键字段默认就包含了 not null 和 unique 两个约束。 如果想要让主键自动增长(必须是 integer 类型)，应该增加 autoincrement 1create table t_st (id integer primary key autoincrement, ...) ; 外键约束 利用外键约束可以用来建立表与表之间的联系。外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段。 新建一个外键： 123// 以下外键的作用是用 t_st 表中的 class_id 字段引用 t_class 表的 id 字段create table t_st (id integer primary key autoincrement, name text, age integer, class_id integer, constraint fk_student_class foreign key (class_id) references t_class (id)); // t_st 表中有一个叫做 fk_t_student_class_id_t_class_id 的外键 表连接查询 需要联合多张表才能查到想要的数据 表连接的类型： 内连接：inner join 或者join(显示的是左右表都有完整字段值的记录) 左外连接：left outer join(保证左表数据的完整性) 示例： 123// 查询 0316iOS 班的所有学生select s.name, s.age from t_st s, t_class c where s.class_id = c.id and c.name = &apos;0316iOS&apos;; 五、文章W3school菜鸟教程","tags":[]},{"title":"iOS 内存管理：从 MRC 到 ARC 实践","date":"2019-05-23T09:43:10.193Z","path":"2019/05/23/iOS/iOS原理/iOS 内存管理：从 MRC 到 ARC 实践/","text":"对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。 iOS 内存管理的核心是引用计数。 接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？ 同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？ 12NSString * str1 = [NSString stringWithFormat:&quot;qqstock&quot;];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding]; 属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。 12self.name = @&quot;qqstock&quot;; _name = @&quot;qqstock&quot;; 一、MRC 的初衷和实现方式苹果为什么要做这个？ 首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。 当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。 尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了。要么，自己写许许多多的代码，频繁对容器进行主动操作。 于是，苹果要解决这个问题。初衷就是：任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责。 苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。 与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。 另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。” 那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。 OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。 二、MRC 的优点和无奈总结： MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题 为了应对各种复杂的场景，很无奈的留了一个口子； 两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。 难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。 略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。 系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！ 引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。 再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。 三、编程语言和编译器的发展方向由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。 然而，编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？ 许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？ 更何况，人，总有打盹的时候。 四、ARC 的适时推出随着硬件的升级，条件已经成熟了，ARC 到来了！ ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。 之前对 C++ 程序员头疼的问题变得异常简单： 1234NSString * str1 = [NSString stringWithFormat:&quot;qqstock&quot;];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding];self.name = @&quot;qqstock&quot;;_name = @&quot;qqstock&quot;; 到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。 许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。 逻辑其实很简单。 首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低； 其次，一旦出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。 总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！ 五、总结如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。 许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。 ①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。 ②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。 ③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。 ④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。","tags":[]}]