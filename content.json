[{"title":"iOS 编译过程原理(2)","date":"2019-05-23T10:19:03.942Z","path":"2019/05/23/iOS 编译过程原理(2)/","text":"原文：黄文臣/深入浅出iOS编译 一、前言《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚： Clang 和 LLVM 究竟是什么 源文件到机器码的细节 Linker 做了哪些工作 编译顺序如何确定 头文件是什么？XCode 是如何找到头文件的？ Clang Module 签名是什么？为什么要签名 为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。 二、编译器 把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做编译器。 大多数编译器由两部分组成：前端和后端。 前端负责词法分析、语法分析、生成中间代码； 后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。 前后端依赖统一格式的中间代码（IR），使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。 Objective-C/C/C++ 使用的编译器前端是clang，swift 是 swift，后端都是 LLVM。 三、LLVMLLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。 LLVM 的核心库提供了现代化的 source-target-independent 优化器和支持诸多流行 CPU 架构的代码生成器，这些核心代码是围绕着 LLVM IR（中间代码）建立的。 基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。 四、clangclang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程： 接下来，从代码层面看一下具体的转化过程，新建一个 main.c： 123456789101112#include &lt;stdio.h&gt;#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\\\n\");#else printf(\"hello world\\\\n\");#endif return 0;&#125; 五、预处理（preprocessor）预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。 #include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，这个过程是递归的：因为 stdio.h 也有可能包含其他头文件。 用 clang 查看预处理的结果： 1$ xcrun clang -E main.c 预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。 123456789101112131415$ xcrun clang -E main.c......extern int __vsnprintf_chk (char * restrict, size_t, int, size_t, const char * restrict, va_list);# 412 \"/usr/include/stdio.h\" 2 3 4# 10 \"main.c\" 2int main() &#123; printf(\"hello debug\\n\"); return 0;&#125; 可以看到，在预处理的时候，注释被删除，条件编译被处理。 六、词法分析（lexical anaysis）词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。 1$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c 输出： 123456789101112131415161718192021222324$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.cannot_module_include '#include &lt;stdio.h&gt;// 一点注释#define DEBUG 1int main() &#123;#ifdef DEBUG printf(\"hello debug\\n\");#else printf' Loc=&lt;main.c:9:1&gt;int 'int' [StartOfLine] Loc=&lt;main.c:14:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.c:14:5&gt;l_paren '(' Loc=&lt;main.c:14:9&gt;r_paren ')' Loc=&lt;main.c:14:10&gt;l_brace '&#123;' [LeadingSpace] Loc=&lt;main.c:14:12&gt;identifier 'printf' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:16:5&gt;l_paren '(' Loc=&lt;main.c:16:11&gt;string_literal '\"hello debug\\n\"' Loc=&lt;main.c:16:12&gt;r_paren ')' Loc=&lt;main.c:16:27&gt;semi ';' Loc=&lt;main.c:16:28&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.c:20:5&gt;numeric_constant '0' [LeadingSpace] Loc=&lt;main.c:20:12&gt;semi ';' Loc=&lt;main.c:20:13&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.c:21:1&gt;eof '' Loc=&lt;main.c:21:2&gt; Loc=\\main.c:9:1\\ 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。 七、语法分析（semantic analysis）词法分析的 Token 流会被解析成一颗抽象语法树（abstract syntax tree - AST）。 1$ xcrun clang -fsyntax-only -Xclang -ast-dump main.c | open -f main 函数 AST 的结构： 123456789101112131415[0;1;32mTranslationUnitDecl\u001b[0m\u001b[0;33m 0x7fd9a18166e8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816c60\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __int128_t\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816980\u001b[0m \u001b[0;32m'__int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816cd0\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __uint128_t\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a18169a0\u001b[0m \u001b[0;32m'unsigned __int128'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1816fa8\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __NSConstantString\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mRecordType\u001b[0m\u001b[0;33m 0x7fd9a1816db0\u001b[0m \u001b[0;32m'struct __NSConstantString_tag'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;1;32mRecord\u001b[0m\u001b[0;33m 0x7fd9a1816d28\u001b[0m\u001b[0;1;36m '__NSConstantString_tag'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817040\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit\u001b[0;1;36m __builtin_ms_va_list\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mPointerType\u001b[0m\u001b[0;33m 0x7fd9a1817000\u001b[0m \u001b[0;32m'char *'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mBuiltinType\u001b[0m\u001b[0;33m 0x7fd9a1816780\u001b[0m \u001b[0;32m'char'\u001b[0m\u001b[0;34m|-\u001b[0m\u001b[0;1;32mTypedefDecl\u001b[0m\u001b[0;33m 0x7fd9a1817308\u001b[0m &lt;\u001b[0;33m&lt;invalid sloc&gt;\u001b[0m&gt; \u001b[0;33m&lt;invalid sloc&gt;\u001b[0m implicit referenced\u001b[0;1;36m __builtin_va_list\u001b[0m \u001b[0;32m'struct __va_list_tag [1]'\u001b[0m\u001b[0;34m| `-\u001b[0m\u001b[0;32mConstantArrayType\u001b[0m\u001b[0;33m 0x7fd9a18172b0\u001b[0m \u001b[0;32m'struct ... 有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。 AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：Introduction to the Clang AST。 八、CodeGenCodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。 1xcrun clang -S -emit-llvm main.c -o main.ll main.ll 文件内容： 12345678910111213141516; ModuleID = 'main.c'source_filename = \"main.c\"target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"target triple = \"x86_64-apple-macosx10.13.0\"@.str = private unnamed_addr constant [13 x i8] c\"hello debug\\0A\\00\", align 1; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 &#123; %1 = alloca i32, align 4 store i32 0, i32* %1, align 4 %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0)) ret i32 0&#125;... Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。 LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 Pass 类的子类，每个节点负责做特定的优化，更多细节：Writing an LLVM Pass。 九、生成汇编代码LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。 生成 arm 64 汇编： 1$ xcrun clang -S main.c -o main.s 查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：iOS汇编快速入门。 12345678910111213141516171819202122232425262728293031 .section __TEXT,__text,regular,pure_instructions .macosx_version_min 10, 13 .globl _main ## -- Begin function main .p2align 4, 0x90_main: ## @main .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp subq $16, %rsp leaq L_.str(%rip), %rdi movl $0, -4(%rbp) movb $0, %al callq _printf xorl %ecx, %ecx movl %eax, -8(%rbp) ## 4-byte Spill movl %ecx, %eax addq $16, %rsp popq %rbp retq .cfi_endproc ## -- End function .section __TEXT,__cstring,cstring_literalsL_.str: ## @.str .asciz \"hello debug\\n\" .subsections_via_symbols 十、汇编器汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。 1$ xcrun clang -fmodules -c main.c -o main.o 还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号 123$ xcrun nm -nm main.o (undefined) external _printf0000000000000000 (\\_\\_TEXT,\\_\\_text) external _main _printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。 10.1 什么是符号（Symbols）?符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。 十一、链接连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。 1$ xcrun clang main.o -o main 就得到了一个 mach o 格式的可执行文件 123456789101112$ file mainmain: Mach-O 64-bit executable x86_64$ ./mainhello debug再用 nm 命令，查看可执行文件的符号表：$ nm -nm main (undefined) external _printf (from libSystem) (undefined) external dyld\\_stub\\_binder (from libSystem)0000000100000000 (\\_\\_TEXT,\\_\\_text) \\[referenced dynamically\\] external \\_\\_mh\\_execute_header0000000100000f60 (\\_\\_TEXT,\\_\\_text) external _main _printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。 十二、XCode 编译通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？ 新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志： 详细的步骤： 创建 Product.app 的文件夹 把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。 创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。 执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。 编译 .m 文件，生成 .o 文件。 链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。 编译 assets，编译 storyboard，链接 storyboard 拷贝动态库 Logger.framework，并且对其签名 执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework 对 Demo.App 签名，并验证（validate） 生成 Product.app 生成 dYSM 文件 Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。 十三、编译顺序编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？ 答案是：依赖关系。 还是以刚刚的 Demo 项目为例，整个依赖关系如下： 可以从 XCode 的 Report Navigator 看到 Target 的编译顺序： XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。 那么，XCode 又从哪里得到了这些依赖关系呢？ Target Dependencies - 显式声明的依赖关系 Linked Frameworks and Libraries - 隐式声明的依赖关系 Build Phase - 定义了编译一个 Target 的每一步 十四、增量编译日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？ 因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。 比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。 十五、头文件C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。 头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。 当只有声明，没有实现的时候，链接器就会报错。 12345Undefined symbols for architecture arm64:“_umimplementMethod”, referenced from:-\\[ClassA method\\] in ClassA.old: symbol(s) not found for architecture arm64clang: error: linker command failed with exit code 1 (use -v to see invocation) Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。 日常开发中，两种常见的头文件引入方式： 12#include \"CustomClass.h\" // 自定义#include &lt;Foundation/Foundation.h&gt; // 系统或者内部 framework 引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？ 回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志： 把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的： 12345678910111213141516171819#include \"...\" search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap) /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers #include &lt;...&gt; search starts here: /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap) /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources /Users/.../Build/Products/Debug-iphoneos (framework directory) /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory) /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory) /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/10.0.0/include /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include $SDKROOT/usr/include $SDKROOT/System/Library/Frameworks (framework directory) End of search list. 这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。 可以通过一个辅助的小工具 hmap 查看 hmap 中的内容： 1234567$ ./hmap print Demo-project-headers.hmap AppDelegate.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.hDemo-Bridging-Header.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.hDummy.h -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.hFramework.h -&gt; Framework/Framework.hTestView.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.hViewController.h -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h 这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。 clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找： 12/Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers/TestView.h/Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers/TestView.h 系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。 以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时： 首先查找 framework 是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework 如果 framework 存在，再在 headers 目录里查找头文件是否存在 1$SDKROOT/System/Library/Frameworks/Foundation.framework/headers/Foundation.h 十六、Clang Module传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的： 大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。 文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。 边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。 clang module 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。 XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。 #import &lt;Foundation/NSString.h&gt; 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。 那么，如何定义一个 module 呢？答案是：modulemap 文件，这个文件描述了一组头文件如何转换为一个 module，举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546framework module Foundation \\[extern_c\\] \\[system\\] &#123; umbrella header \"Foundation.h\" // 所有要暴露的头文件 export * module * &#123; export * &#125; explicit module NSDebug &#123; //submodule header \"NSDebug.h\" export * &#125; &#125;``` swift 是可以直接 import 一个 clang module 的，比如你有一些 C 库，需要在 Swift 中使用，就可以用 modulemap 的方式。## 十七、Swift 编译现代化的语言几乎都抛弃了头文件，swift 也不例外。问题来了，swift 没有头文件又是怎么找到声明的呢？&gt; 编译器干了这些脏活累活。编译一个 Swift 头文件，需要解析 module 中所有的 Swift 文件，找到对应的声明。![29](https://upload-images.jianshu.io/upload_images/5294842-bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)当开发中难免要有 Objective-C 和 Swift 相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？### 17.1 Swift 引用 Objective-CSwift 的编译器内部使用了 clang，所以 swift 可以直接使用 clang module，从而支持直接 import Objective-C 编写的framework。![30](https://upload-images.jianshu.io/upload_images/5294842-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) swift 编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：* Bridging-Header.h 中暴露给 swfit 的头文件* framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。XCode 提供了宏定义 NS\\_SWIFT\\_NAME 来让开发者定义 Objective-C =&gt; Swift的符号映射，可以通过 Related Items -&gt; Generate Interface 来查看转换后的结果：![31](https://upload-images.jianshu.io/upload_images/5294842-bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 17.2 Objective-C 引用 swiftxcode 会以 module 为单位，为 swift 自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-Swift.h。swift 提供了关键词 @objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。 @objc public class MyClass12345678910111213141516171819## 十八、深入理解 Linker&gt; &lt;font color=#cc0000&gt;链接器会把编译器编译生成的多个文件，链接成一个可执行文件&lt;/font&gt;。链接并不会产生新的代码，只是在现有代码的基础上做&lt;font color=#cc0000&gt;移动和补丁&lt;/font&gt;。链接器的输入可能是以下几种文件：* object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。* 动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载* 静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。* tbd，只包含符号的库文件这里提到了一个概念：符号（Symbols），那么符号是什么呢？&gt; 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。以一段代码为例，看看链接时究竟发生了什么？源代码： (void)log{ printf(“hello world\\n”);}12.o 文件： #代码adrp x0, l.str@PAGEadd x0, x0, l.str@PAGEOFFbl _printf #字符串符号l_.str: ; @.str .asciz “hello world\\n”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172在 .o 文件中，字符串 \"hello world\\\\n\" 作为一个符号（l\\_.str）被引用，汇编代码读取的时候按照 l\\_.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：1. l_.str 在可执行文件的哪个位置？2. printf 函数来自哪里？再来看看链接之后的 mach o 文件：![32](https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)链接器如何解决这两个问题呢？1. 链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。2. 链接后，不再是调用符号 \\_printf，而是在 DATA 段上创建了一个函数指针 \\_printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 _printf 地址。更多细节，可以参考这篇文章：[深入理解iOS App的启动过程](https://blog.csdn.net/Hello_Hwc/article/details/78317863)。Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。## 十九、理解签名### 19.1 基础回顾非对称加密在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。数字签名数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。![33](https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。![34](https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。&gt; 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。## 二十、iOS App 签名为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。除此之外，Apple 要严格控制 App 的分发：1. App 来自 Apple 信任的开发者2. 安装的设备是 Apple 允许的设备### 20.1 证书通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。![35](https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.2 Provisioning ProfileiOS App 安装到设备的途径（非越狱）有以下几种：* 开发包（插线，或者 archive 导出 develop 包）* Ad Hoc* App Store* 企业证书开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。![36](https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)可以通过以下命令来查看 Provisioning Profile 中的内容： security cms -D -i embedded.mobileprovision &gt; result.plistopen result.plist12345678910本质上就是一个编码过后的 plist。![37](https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 20.3 iOS 签名生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名 Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nibT2g5jlq7EVFHNzL/ip3fSoXKoOI= Info.plist5aVg/3m4y30m+GSB8LkZNNU3mug= PkgInfon57qDP4tZfLD1rCS43W0B4LQjzE= embedded.mobileprovisiontm/I1g+0u2Cx9qrPJeC0zgyuVUE=…` 代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名： 20.4 验证20.4.1 安装 App 的时候 从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者 证书验证通过后，从证书中取出 Leo 的公钥 读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确 文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证） 验证通过后，安装 App 20.4.2 启动 App 的时候 验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致 判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证 如果是企业证书，验证用户是否信任企业证书 App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。 以上都验证通过，App 才能正常启动","tags":[]},{"title":"BFPRT 算法","date":"2019-05-23T10:19:03.937Z","path":"2019/05/23/BFPRT算法/","text":"https://blog.csdn.net/qingdujun/article/details/85255119","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://yoursite.com/tags/排序算法/"}]},{"title":"全排列","date":"2019-05-23T10:19:03.935Z","path":"2019/05/23/全排列/","text":"问题：有 n 个数或字符，有多少种排列方法。 思路：采用分治法把大问题分解成很多的子问题。大问题是所有的排列方法，分解得到的小问题就是以 1 开头的排列，以 2 开头的排列，以 a 开头的排列，以 b 开头的排列…把这些问题继续分解，以 12 开头的排列，以 123 开头的排列…将余下的看成大问题，一直分解下去，直到分解成的子问题只有一个数字或字符的时候，不再分解。 因为 1 个数字或字符肯定只有一种排列方式，现在将每个解决了的小问题合并，合并成一个大点的问题，合并之后这个大点的问题也解决了，再将这些大点的问题合并成一个更大的问题，直到最大的问题解决为止。 先固定一个字符，然后将固定的字符与它后面的每一个进行交换，一直递归下去，直到固定的字符后面只有一个字符。 下图中，红色字符是被固定的字符，白色字符的没有被固定的字符。具体做法就是每次将没有固定的第一个字符与其他未固定的字符交换（第 1 个与第 1个交换，第 1 个与第 2 个交换，… 第 1 个与第 n 个交换），直到只剩下一个没有被固定的字符时，输出此时的字符排列，但是输出之后要将字符的位置还原。 全排列可以看做固定前 i 位，对第 i+1 位之后的再进行全排列，比如固定第一位，后面跟着 n-1 位的全排列。那么解决 n-1 位元素的全排列就能解决 n 位元素的全排列了。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;string.h&gt;char temp;void swapChar(char a[], int i, int k)&#123; temp = a[i]; a[i] = a[k]; a[k] = temp;&#125;void algorithm(char a[], int start, unsigned long count)&#123; // 深度控制。此时只剩一个没有固定的字符，直接输出 if(start == count - 1) &#123; puts(a); return; &#125; for(int i = start; i &lt; count; i++) &#123; swapChar(a, i, start); // 交换 algorithm(a, start + 1, count); swapChar(a, i, start); // 复原 &#125;&#125;int main()&#123; char arr[100] = &#123; 'a', 'b', 'c' &#125;; // gets(a); algorithm(arr, 0, strlen(arr)); return 0;&#125;","tags":[{"name":"分治法","slug":"分治法","permalink":"http://yoursite.com/tags/分治法/"}]},{"title":"直接插入排序","date":"2019-05-23T10:19:03.934Z","path":"2019/05/23/直接插入排序/","text":"一、减治法（增量法） 减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。 增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。 减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。 很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式： 减去一个常量。（直接插入排序） 减去一个常量因子。（二分查找法） 减去的规模可变。（辗转相除法） 二、直接插入排序直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下： 对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。 考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n-1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。 很显然，基于增量法的思想在解决这个问题上拥有更高的效率。 直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。 当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序） 直接插入排序的时间复杂度是 O(n^2)，空间复杂度是 O(1)，同时也是稳定排序。 三、优化 设置哨兵位 仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。 不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：记录上一次插入的值和位置，与当前插入值比较。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。 二分查找法 优化直接插入排序的核心在于：快速定位当前数字待插入的位置。 在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。 这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会打破排序算法的稳定性，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？ 四、简单的性能比较 结论： 在某些特定场景下，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。 对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。 大规模数组，二分查找优化效率明显。 五、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#define ARRAY_LENGTH 10void insertSort(int list[])&#123; // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int j = 0; int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置 // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位 for (j = i - 1; j &gt; -1 &amp;&amp; temp &lt; list[j]; j--) &#123; list[j + 1] = list[j]; &#125; list[j + 1] = temp; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", list[i]); &#125;&#125;// 根据上一次的位置，简化下一次定位static void optimized_1(int array[]) &#123; // 记录上一个插入值的位置和数值 int checkValue = array[0]; int checkIndex = 0; // 循环插入 for (int i = 1; i &lt; ARRAY_LENGTH; i++) &#123; int cur = array[i]; int start = i - 1; int j = 0; // 根据上一个值，定位开始遍历的位置 if (cur &lt; checkValue) &#123; start = checkIndex; for (int j = i - 1; j &gt; start - 1; j--) &#123; array[j + 1] = array[j]; &#125; &#125; // 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的 // 循环判断 + 插入 for (j = start; j &gt; -1; j--) &#123; if (cur &lt; array[j]) &#123; array[j + 1] = array[j]; &#125; else &#123; break; &#125; &#125; array[j + 1] = cur; checkValue = cur; checkIndex = j + 1; &#125; for (int i = 0; i &lt; ARRAY_LENGTH; i++) &#123; printf(\"%d \", array[i]); &#125;&#125; 六、学习文章Gerrard_Feng 排序算法(三) 直接插入排序","tags":[]},{"title":"0-1 背包","date":"2019-05-23T10:19:03.934Z","path":"2019/05/23/01-背包/","text":"01 背包问题是用来介绍动态规划算法最经典的例子。 一、解释 1①、状态方程 f[i, j] = Max{ f[i-1, j-Wi] + Pi, f[i-1,j] } ( j &gt;= Wi ) f[i,j] 表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。Pi 表示第 i 件物品的价值。 决策：为了背包中物品总价值最大化，第 i 件物品应该放入背包中吗 ？ ②、实例 假设山洞里共有 a、b、c、d、e 等 5 件宝物，重量分别是 2、2、6、5、4，价值分别是 6、3、5、4、6，现在有一个承重为 10 的背包，怎么装背包，可以才能带走最多的财富。 只要你能通过找规律手工填写出上面这张表就算理解了 01 背包的动态规划算法。 首先要明确这张表是至底向上，从左到右生成的。 用 e2 单元格表示 e 行 2 列的单元格。它表示只有物品 e 时，有个承重为 2 的背包，那么这个背包的最大价值是 0，因为背包装不下。 对于 d2 单元格，表示只有物品 e、d 时，承重为 2 的背包，所能装入的最大价值，仍然是 0，因为物品 e、d 都不是这个背包能装的。 同理 c2 = 0，b2 = 3，a2 = 6。 对于承重为 8 的背包，a8 = 15 是怎么得出的呢？ 根据 01 背包的状态转换方程，需要考察两个值：一个是 f[i-1, j]（这里是 b8 = 9），另一个是 f[i-1, j-Wi] + Pi。 f[i-1, j] 表示有一个承重为 8 的背包，当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 f[i-1, j-Wi] 表示有一个承重为 6 的背包（当前背包承重减去物品 a 的重量），当只有物品 b、c、d、e 四件可选时，这个背包能装入的最大价值。 Pi 指的是 a 物品的价值，即 6。 由于 f[i-1, j-Wi] + Pi = 9 + 6 = 15 大于 f[i-1, j] = 9，所以物品 a 应该放入承重为 8 的背包。 ③、代码 物品信息类 123456789101112131415161718192021222324@interface PackageItem : NSObject@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger weight;@property (nonatomic, assign) NSInteger value;- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value;@end@implementation PackageItem- (instancetype)initWithName:(NSString *)name weight:(NSInteger)weight value:(NSInteger)value&#123; if (self = [super init]) &#123; self.name = name; self.weight = weight; self.value = value; &#125; return self;&#125;@end 非递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&#123; NSArray * nameArr = @[ @\"a\", @\"b\", @\"c\", @\"d\", @\"e\" ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:ARRAY_LENGTH]; for(int i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; &#125; [self packageAlgorithm:bagItems bagSize:10];&#125;/** * @brief 01 背包算法 */- (void)packageAlgorithm:(NSArray *)bagItems bagSize:(NSInteger)bagSize&#123; if (bagSize == 0 || bagItems.count == 0) return; NSInteger bagMatrix[bagSize][bagItems.count]; // 是否选中数组 PackageItem * item; NSInteger i = 0; // 背包容量，列数 NSInteger j = 0; // 物品数量，行数 // 初始化数组 for (; i &lt;= bagSize; i++) &#123; for (j = 0; j &lt; bagItems.count; j++) bagMatrix[i][j] = 0; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(\"%ld \", (long)bagMatrix[i][j]); printf(\"\\n\"); &#125; printf(\"\\n\"); for (i = 0; i &lt;= bagSize; i++) &#123; // 因为 item 数组是按照 a、b、c、d、e 的顺序排列的，所以这里需要倒着取 for (j = bagItems.count - 1; j &gt; -1; j--) &#123; item = bagItems[j]; // 装不下 if (item.weight &gt; i) &#123; // 价值总和为 0 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = 0; &#125; // 价值总和为之前项的和 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = bagMatrix[i][j+1]; &#125; &#125; // 能装下 else &#123; // 是第一个物品，保存起来 if (j == bagItems.count - 1) &#123; bagMatrix[i][j] = item.value; &#125; // 非第一个物品，求最大值 else &#123; // 因为 j 是倒着取的，所以这里 - 1 变成了 + 1 bagMatrix[i][j] = MAX(bagMatrix[i][j+1], bagMatrix[i - item.weight][j+1] + item.value); &#125; &#125; &#125; &#125; // 打印二维数组内容 for (j = 0; j &lt; bagItems.count; j++) &#123; for (i = 0; i &lt;= bagSize; i++) printf(\"%ld \", (long)bagMatrix[i][j]); printf(\"\\n\"); &#125; NSInteger curSize = bagSize; // 当前能装的空间 NSMutableArray * answer = [NSMutableArray arrayWithCapacity:bagItems.count]; // 以 a、b、c、d、e 的顺序获取 for (j = 0; j &lt; bagItems.count; j++) &#123; item = bagItems[j]; // 剩下能装的空间为 0 if (curSize == 0) &#123; break; &#125; // 根据变换公式从上至下获得物品 if (bagMatrix[curSize][j] - bagMatrix[curSize-item.weight][j+1] == item.value) &#123; [answer addObject:item.name]; curSize -= item.weight; &#125; &#125; NSLog(@\"%@\", answer);&#125;0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 6 9 9 12 12 15 15 15 0 0 3 3 6 6 9 9 9 10 11 0 0 0 0 6 6 6 6 6 10 11 0 0 0 0 6 6 6 6 6 10 10 0 0 0 0 6 6 6 6 6 6 6 2019-01-25 22:12:03.795695+0800 Demo[1750:32295] ( a, b, e) 二、解释 2①、状态方程 max.F(n,C,x). x∈0,1 展开公式： F(n,C,x) = x1∗v1 + x2∗v2 + … + xn∗vn x1∗w1 + x2∗w2 + … + xn∗wn ≤ C xi∈0,1 x 的取值范围为 0 或者 1，代表着这个物品选择拿或者不拿，最终找出这样的组合如：（1, 1, 1, 0, 0, 1）或（1, 1, 1, 0, 0, 1）使得 F(n,C,x) 最大。 我们假设一个函数 B(n,C) = max.F(n,c,x)，也就是说 B 函数是一个能够自动组合 x 的取值使得 F(n,c,x) 达到最大。 再次理解这个 B(n,C) 这个函数的意义：从 n 个物品里面选取，容量为 C，能达到的最大价值。 如果想要在 n 个商品里选择，得到最大总价值，那么肯定得先在 n-1 个物品里面选择，得到最大价值后，然后考虑第 n 个物品要不要放进去？放进去会不会超过容量限制，会不会得到一个最大价值。我们就得到了一个函数。 B(n, C) = B(n−1, C); 没有多余的空间去放置最后一个物品 B(n, C) = max{ B(n−1, C), B(n−1, C−wn) + vn }; 如果有多余的空间去放置，则考虑是否要放置 B(n−1, C) 与 B(n−1, C−wn) 所对应的 F(n,c,x) 中的 x 的组合不一定相同，因为容量约束条件变了，一个是 C 一个是 C-wn。 ②、实例 w = {1, 2} v = {1, 2} C = 2 解：B(2, 2) 为最大价值，如果我们拿最后物品 w = 2、v = 2，因为 w = 2 = C , 所以可以选择拿或者不拿。 拿：如果确定拿走最后一个物品，则 B(2, 2) = B(2-1, 2-2) + 2 = B(1, 0) + 2 不拿：如果确定不拿走最后一个物品，则 B(2, 2) = B(1, 2); 因为最后一个物品选择不拿，所以情景肯定变为从 1 个物品里面选，容量为 2，是否达到最大值，因此等式左右两边相等。 然后比较 B(1, 0) + 2 与B(1, 2) 哪个大，很明显，对于 B(1, 0) 已经没有容量去放置下一个物品，就相当于从 0 个物品里面选 B(1, 0) = B(0, 0) = 0, B(1, 0) + 2 = 2 则求解 B(1, 2) 代表着只能去选择第一件（w = 1, v = 1），不拿结果为 0，拿结果价值就为 1。 B(2, 2) = max{ B(1, 0) + 2, B(1, 2) } = max{ 2, 1 } = 2 ③、递归代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; NSArray * nameArr = @[ @\"a\", @\"b\", @\"c\", @\"d\", @\"e\" ]; NSArray * weightArr = @[ @(2), @(2), @(6), @(5), @(4) ]; NSArray * valueArr = @[ @(6), @(3), @(5), @(4), @(6) ]; selectedArray = [NSMutableArray arrayWithCapacity:nameArr.count]; NSMutableArray&lt;PackageItem *&gt; * bagItems = [NSMutableArray&lt;PackageItem *&gt; arrayWithCapacity:nameArr.count]; for(NSInteger i = 0; i &lt; nameArr.count; i++) &#123; PackageItem * item = [[PackageItem alloc] initWithName:nameArr[i] weight:[weightArr[i] integerValue] value:[valueArr[i] integerValue]]; bagItems[i] = item; // a、b、c、d、e selectedArray[i] = @(0); &#125; NSLog(@\"%ld\", (long)[self packageAlgorithm:bagItems bagNo:bagItems.count bagSize:10]); [selectedArray enumerateObjectsUsingBlock:^(NSNumber * obj, NSUInteger idx, BOOL * stop) &#123; if (obj.integerValue) &#123; NSLog(@\"%@ \", nameArr[idx]); &#125; &#125;];&#125;/** * @brief 01 背包算法。递归方式 */- (NSInteger)packageAlgorithm:(NSArray *)bagItems bagNo:(NSInteger)bagNo bagSize:(NSInteger)bagSize&#123; if (bagItems.count == 0 || bagSize == 0 || bagNo == 0) return 0; PackageItem * item = bagItems[bagNo - 1]; // 装不下 if (bagSize &lt; item.weight) &#123; // 在剩余的物品中查找 return [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; &#125; else &#123; NSInteger more = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize]; NSInteger less = [self packageAlgorithm:bagItems bagNo:bagNo - 1 bagSize:bagSize - item.weight] + item.value; if (more &lt; less) &#123; selectedArray[bagNo - 1] = @(1); // 拿 &#125; else &#123; selectedArray[bagNo - 1] = @(0); // 不拿 &#125; return MAX(more, less); &#125;&#125;2019-01-26 00:11:13.897795+0800 Demo[3618:88346] 152019-01-26 00:11:13.897903+0800 Demo[3618:88346] a2019-01-26 00:11:13.897979+0800 Demo[3618:88346] b2019-01-26 00:11:13.898040+0800 Demo[3618:88346] e 三、DP 优于递归的好处动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划的基本思想大致是：若要解一个给定问题，需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增速时特别有用。 四、学习文章动态规划之 01 背包问题（最易理解的讲解）一文彻底搞懂01背包算法DP——01背包问题使用迭代和动态规划","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"armv7、armv7s、arm64","date":"2019-05-23T10:19:03.933Z","path":"2019/05/23/armv7、armv7s、arm64/","text":"一、前言ARM 处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于 ARM，在嵌入式系统中应用广泛。 armv6｜armv7｜armv7s｜arm64 都是 ARM 处理器的指令集，这些指令集都是向下兼容的，例如 armv7 指令集兼容 armv6，只是使用 armv6 的时候无法发挥出其性能，无法使用 armv7 的新特性，从而会导致程序执行效率没那么高。 二、介绍 armv7｜armv7s｜arm64 都是 ARM 处理器的指令集 i386｜x86_64 是 Mac 处理器的指令集 |:————-:|:————-:|:—–:||arm64|iPhone6s | iphone6s plus | iPhone6 | iPhone6 plus | iPhone5S | iPad Air | iPad mini2 | 真机 64 位 ||armv7s|iPhone5 | iPhone5C | iPad4|真机 32 位||armv7|iPhone4|iPhone4S|iPad|iPad2|iPad3|iPad mini|iPod Touch 3G|iPod Touch4|真机 32 位||i386|针对 intel 通用微处理器 32 位处理器|模拟器 32 位||x86_64|是针对 x86 架构的 64 位处理器|模拟器 64 位| 模拟器并不运行 arm 代码，软件会被编译成 x86 可以运行的指令。所以生成静态库时都是会先生成两个 .a，一个是 i386 的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个 .a 合并成一个。 三、Xcode 的指令集选项3.1 Architectures Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. 指定工程被编译成可支持哪些指令集类型。支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是 ipa 包会变大。 3.2 Valid Architectures Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. 限制可能被支持的指令集的范围，也就是 Xcode 编译出来的二进制包类型最终从这些类型产生。而编译出哪种指令集的包，将由Architectures 与 Valid Architectures 的交集来确定。 ①、Valid Architectures 支持 arm 指令集版本设置为：armv7/armv7s/arm64，对应的 Architectures 支持 arm 指令集版本为：armv7s，这时 Xcode 只会生成一个 armv7s 指令集的二进制包。 ②、将 Architectures 支持 arm 指令集设置为：armv7/armv7s，对应的 Valid Architectures 的支持的指令集设置为：armv7s/arm64，那么此时，XCode 生成二进制包所支持的指令集只有 armv7s。 (3)、Build Active Architecture Only 指定是否只对当前连接设备所支持的指令集编译。 debug 时设置成 YES 是为了编译速度更快，它只编译当前的 architecture 版本；而 release 时设置为 NO 会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如设置为 YES，用 iphone4 编译出来的是 armv7 版本的，iphone5 也可以运行，但是 armv6 的设备就不能运行。 所以，一般 debug 的时候可以选择设置为 YES，release 的时候要改为 NO，以适应不同设备。 情况 Architectures ValidArchitectures 结果 分析 ① armv7、armv7s、arm64 armv6、armv7s、arm64 arm64 取交集 arm64 和 armv7s，但 iPhone5S 匹配指令集 arm64，所以为 arm64 ② armv6、armv7、armv7s armv6、armv7s、arm64 armv7s 取交集 armv6 和 armv7s，但 iPhone5S 匹配指令集 arm64，但同时支持 armv7s，同时XCode4.5 开始，就不再支持 armv6 指令集，所以为 arm64 ③ armv6、armv7 armv6、armv7s、arm64 armv7 无交集。但是因为 ValidArchitectures支 持armv7s 则必然支持 armv7，所以最终生成二进制指令集 armv7 ④ armv6 armv6、armv7s、arm64 无响应 虽然编译成功了，但是并没有任何目标生成。因为从 XCode4.5 开始，就不再支持 armv6 指令集，所以列表中写了也是白写。 ⑤ armv7、armv7s、arm64 armv7、armv7s error报错 生成二进制包支持的指令集编译出错 error 信息：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=arm64, VALID_ARCHS=armv7 如果你对 ipa 安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。 $(ARCHS_STANDARD)默认值，以各版本实际的值为准。XCode5 中值为 armv7 armv7s，在 XCode5.1 时，强制加入了对 arm64 的编译，于是该值为 armv7,armv7s,arm64。当前 Xcode10.1 默认为 Standard architectures(armv7,arm64)。 $(ARCHS_STANDARD_32_BIT)Xcode5 和 5.1 都为 armv7,armv7s，旧一点的版本中应该对应的就只有 armv7。（待验证） $(ARCHS_STANDARD_INCLUDING_64_BIT)XCode5 和 5.1 都为 armv7,armv7s,arm64 使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有 32 位、64 位两份代码，在iPhone5s（64 位）下，会首选运行 64 位代码包。包含两种架构的代码包，只有运行在 iOS6、iOS7 系统上。 而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有 32 位代码， iPhone5s 可以兼容 32 位代码，但是这会降低 iPhone5s 的性能。 开启 arm64 支持后，不能开发 iOS 5.1.1 之前的版本，要强制将 deployment target 设置为 5.1.1 或之后。Xcode4.5 中移除了对 arm6 的支持。 查看 .a/framework 库支持的指令集通过 lipo 命令查看 .a 库所支持的指令集。 $ lipo -info AFNetworking$ lipo -info AFNetworking.framework/AFNetworkingNon-fat file: AFNetworking.framework/AFNetworking is architecture: x86_64$ lipo -info *.aArchitectures in the fat file: libPods-AFNetworking.a are: armv7 armv7sArchitectures in the fat file: libPods.a are: armv7 armv7s$ lipo -info libBloodTester.aArchitectures in the fat file: libBloodTester.a are: armv7 i386 x86_64 arm64 CocoaPods与Architecture出现问题 ld: library not found for -lAFNetworking，需要将 pods 的 Architectures 设置成与工程 targets 里的相同。 如何选择支持的指令集？如果你的软件对安装包大小非常敏感，你可以减少安装包中的指令集数据包，而且这能达到立竿见影的效果。 很久前 xcode 支持的指令集是 armv7/armv7s，后来改成只支持 armv7 后，比原来小了 10MB 左右。目前 AppStore 上的一些知名应用，比如百度地图、腾讯地图通过反汇编工具查看后，也都只支持 armv7 指令集。（待验证） 根据向下兼容原则，armv7 指令集的应用是可以正常在支持 armv7s/arm64 指令集的机器上运行的。","tags":[]},{"title":"Archives 配置","date":"2019-05-23T10:19:03.932Z","path":"2019/05/23/Archives配置/","text":"一、Archive iOS App Store 保存到本地，准备上传 App Store 或者在越狱的 iOS 设备上使用，利用的是 Distribution 描述文件，关联 production 证书； Ad Hoc 保存到本地，准备在开发者账户下添加了 UDID 的设备上使用，利用的是 Distribution 描述文件，关联 production 证书； 官方解释：Ad Hoc 模式的包和将来发布到 App Store 的包在各种功能测试上是一样的，只要 Ad Hoc 模式下测试（推送、内购等）没有问题，发布到 App Store 也是没有问题的。 Enterprise 主要针对企业级账户下准备本地服务器分发的 app。利用的是 Distribution 描述文件，关联 production 证书； Development 保存到本地，给添加了 UDID 的设备使用，开发者模式打包 ipa，通过 development 描述文件，关联 development 证书。 Rebuild from Bitcode 如果工程 Bitcode 为 NO，则不会有此选项。 Strip Swift symbols 去除 swift 符号，勾选后会让 ipa 包内存小一些，对包进行了一个压缩。如果项目中未包含 swift 代码，则没有此选项。 Include manifest for over-the-air installation 勾选后用户可以在 safari 中下载应用，而不必移步 App Store。 Upload your app’s symbols to receive symbolicated reports from Apple 上传应用程序的符号以接收来自苹果的符号化报告。 二、学习文章https://developer.apple.com/library/archive/technotes/tn2151/_index.html","tags":[]},{"title":"App Thinning","date":"2019-05-23T10:19:03.932Z","path":"2019/05/23/App-Thinning/","text":"App Thinning 可以译成”应用瘦身”。指的是 App Store 和操作系统在安装 iOS 或者 watchOS 的 app 的时候通过一系列的优化，尽可能减少安装包的大小，使得 app 以最小的合适的大小被安装到你的设备上。而这个过程包括了三个过程：slicing、bitcode、on-demand resources。 一、slicingApp Slicing 在节省应用所需资源中发挥着最重要的作用。 很多应用需要在不同尺寸的设备上运行，针对这些不同的设备，它们内含不同的独立资源，而大部分是你的设备不需要的。所以App Store 会针对不同的设备制作不同的”简化版 App”，当你下载 app 时候只需要下载不同的”简化版 app”就可以了。 比如用户使用的是 iPhone 5c，它运行的是 32 位 CPU 和 GPU，并不支持 Metal API。但如果用户下载的是一款最新的通用游戏应用，它的二进制中含有 64 位代码，iPad 和”@3x”iPhone 6 Plus 资源以及 Metal API 代码，这些都是你的设备用不上的。它只需要 32 位代码，”@2x”iPhone 尺寸资源以及 OpenGL 图形代码。 Note : Sliced apps are supported on devices running 9.0 and later; Slicing 的主要的工作流程如下： 在 Xcode 中选择好目标设备并且使用 asset catalog 提供多分辨率的图片资源；只有使用 asset catalog 才能正确使Slicing 作用于资源文件。 在模拟器或者设备上编译并运行 app； Xcode 会自动构建针对你运行设备的”简化版 app”，同时也是为了减少编译时间和进行本地的测试； 打包 app（为了及时发现不同目标设备的配置错误，可以在本地为目标设备导出”简化版 app”，测试无误后再打包) 上传打包好的 app 到 iTunes connect。App Store 将会为上传的 app 归档创建不同的”简化版 app”。 在 iTunes Connect 中，发布一个预览版给合格的测试者进行测试； 测试者通过 TestFlight 下载预览版。TestFlight 会自动根据测试者的设备下载合适的”简化版 app”。 二、Bitcode (iOS, watchOS)Bitcode 是一个编译好的程序的中间表示形式。上传到 iTunes Connect 中的包含 Bitcode 的 app 将会在 App Store 中进行链接和编译。苹果会对包含 Bitcode 的二进制 app 进行二次优化，而不需要提交一个新的 app 版本到 App Store 中。 三、On-Demand Resources (iOS)ODR（on-demand resources 随需应变资源)是 iOS 减少应用资源消耗的另外一种方法。比如多级游戏，用户需要的通常都是他们当前的级数以及下一级。ODR 意味着用户可以下载他们需要的几级游戏。随着你的级数不断增加，应用再下载其他级数，并将用户成功过关的级数删掉。 当用户点击应用内容的时候，就会动态从 App Store 上进行下载，也就是说用户只会在需要的时候占用存储空间。这项功能有趣之处还在于当将这些内容在后台进行下载之后，当存储空间紧张的时候会自动进行删除。 On-Demand Resources 可以是除了可执行代码外的任意类型。 在开发过程中，你可以通过分配一个或多个 tag 来识别 On-Demand Resources。你可以使用 tag 的别名来确定什么时候将它加载到你的 App 中。 好处： Smaller app size. app 体积更小。 Lazy loading of app resources. 懒加载应用资源。 Remote storage of rarely used resources. 远端存储较少使用的资源。 Remote storage of in-app purchase resources. 远端存储内购资源。 下图展示了一个在 App 中保持最小资源占用的例子。 可以给资源设置优先级，比如当 App 从 AppStore 安装后就立即加载。 A _tag_ is a string identifier you create. Apps request tags, not individual resources. On-Demand Resources 的生命周期 ①、App 向操作系统请求资源。操作系统将请求发送给包含所有所需资源的 asset packs。 ②、asset packs 检查请求的资源本地是否存在。如果存在，则直接提供 App 使用。 ③、如果请求的资源本地不存在，则它们被保存在 App Store。 ④、操作系统开始下载本地不存在的资源 ⑤、远程资源下载完毕 ⑥、当资源下载成功或监测到资源包已经被下载，资源包内存计数将会被 ＋1，并通知 App 此资源可用。 ⑦、当请求的资源可用，App 使用资源标签对应的资源。 ⑧、操作系统在本地释放资源标签 ⑨、操作系统在本地清除资源缓存。当一个缓存资源不与任何请求相关联时，操作系统会在一定时间后将它释放掉。 完整的生命周期如下图所示： 四、实际处理方法①、iOS9 以后 Xcode 默认开启 On-Demand Resources 功能，可以在下图所示位置进行设置。 ②、在 App 中创建 Tags ③、给文件设置 tag ④、给图片设置 tag ⑤、给 tag 设置加载的优先级 加载优先级 Initial install tags.资源和 App 同时下载。在 App Store 中，App 的大小计算已经包含了这部分资源。当没有NSBundleResourceRequest 对象访问它们时，它们将会从设备上清除。 Prefetch tag order. 在 App 安装后开始下载，按照预加载列表中的顺序依次下载。 Dowloaded only on demand. 只有在 App 中发出请求时才会下载。 资源大小限制 五、学习文章What is app thinning? (iOS, tvOS, watchOS)On-Demand Resources Essentialshttps://www.jianshu.com/p/789df0adaac2","tags":[]},{"title":"AFNetworking","date":"2019-05-23T10:19:03.925Z","path":"2019/05/23/AFNetworking/","text":"一、架构 AFNetworking 实际上是对 NSURLSession 高度地封装，提供一些简单易用的 api，方便开发者在 iOS 开发中发出网络请求并在其上更快地构建网络层组件以及提供合理的接口。 AFNetworking 默认接收 json 格式的响应。 二、AFURLSessionManagerAFURLSessionManager 遵守 \\&lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying> 协议，根据指定的 NSURLSessionConfiguration 对象创建和管理 NSURLSession 对象。 负责创建和管理 NSURLSession 管理 NSURLSessionTask 实现 NSURLSessionDelegate 等协议中的代理方法 使用 AFURLSessionManagerTaskDelegate 管理进度 使用 _AFURLSessionTaskSwizzling 调剂方法 引入 AFSecurityPolicy 保证请求的安全 引入 AFNetworkReachabilityManager 监控网络状态 三、AFURLResponseSerialization 文件 3.1 AFURLResponseSerialization 协议遵守协议的对象根据详细的服务器响应，将数据转换成更有用的对象表达。响应序列化程序可以对输入的响应和数据进行验证，例如：一个 JSON 响应序列化程序可以检查一个可接受的状态代码(‘2xx’范围)和内容类型(‘application/json’)，然后决定将一个有效的 JSON 响应解码成一个对象。 3.2 AFHTTPResponseSerializer遵守 AFURLRequestSerialization、AFURLResponseSerialization 协议，提供一个查询字符串或 URL 类型编码的参数序列化和默认请求头具体的实现，以及响应状态码和内容类型的验证。鼓励使用 AFHTTPResponseSerializer 的子类来解析请求或相应序列化。 3.3 AFJSONResponseSerializer继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型： - ‘application/json’- ‘text/json’- ‘text/javascript’ 3.4 AFXMLParserResponseSerializer继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型： - ‘application/xml’- ‘text/xml’ 3.5 AFPropertyListResponseSerializer继承自 AFHTTPResponseSerializer，验证和解析 XML 响应，如同 NSXMLDocument 对象。可解析的 MIME 类型： - ‘application/x-plist’ 3.6 AFImageResponseSerializer继承自 AFHTTPResponseSerializer，验证和解析 image 响应，解析成 UIImage 或 NSImage，可解析的 MIME 类型： - ‘image/tiff’- ‘image/jpeg’- ‘image/gif’- ‘image/png’- ‘image/ico’- ‘image/x-icon’- ‘image/bmp’- ‘image/x-bmp’- ‘image/x-xbitmap’- ‘image/x-win-bitmap’ 3.7 AFCompoundResponseSerializer继承自 AFHTTPResponseSerializer，将用 AFURLResponseSerialization 的方法解析完成的对象，转成 AFHTTPResponseSerializer 行为的对象。这对于用单个序列化处理多种可能的响应类型来说很有用。This is useful for supporting multiple potential types and structures of server responses with a single serializer. 3.8 全局方法AFErrorWithUnderlyingError() 处理 NSError 对象 AFJSONObjectByRemovingKeysWithNullValues() 递归处理空值，返回可变或不可变对象 3.9 AFHTTPResponseSerializer 方法- validateResponse:data:error: 通过 MIME 类型和状态码验证响应是否有效，并记录错误信息 - responseObjectForResponse:data:error: AFURLResponseSerializer 协议方法 … 其他协议方法 3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法- init 设置可解析的类型 - responseObjectForResponse:data:error: AFURLResponseSerializer 协议方法，执行步骤： ①、验证 MIME 类型和状态码 ②、检查内容（JSON 序列化类检查内容是否为一个空格） ③、调用系统的序列化方法 ④、存储错误信息 ⑤、移除空值 3.11 AFImageResponseSerialize 方法+ af_safeImageWithData: 使用锁来保证数据安全 AFImageWithDataAtScale() 将图片按比例缩放 AFInflatedImageFromResponseWithDataAtScale() 获取图片数据，执行步骤： ①、判断数据是否存在，没有返回 nil ②、使用 CGDataProvider 对象，获取不同响应类型图片文件的内容，其中 JPEG 类型颜色空间为 kCGColorSpaceModelCMYK 的数据不采用此种方式，原因：CGImageCreateWithJPEGDataProvider does not properly handle CMKY ③、如果 CGDataProvider 没有获取到内容，则使用 AFImageWithDataAtScale 方法进行缩放后直接返回 ④、使用位图对象 CGBitmapContextCreate 重新绘图后缩放，并返回 AFCompoundResponseSerializer 分派给以上类进行解析。 四、AFURLRequestSerialization 文件 请求序列化器从 URL 字符串创建请求，将参数编码为查询字符串或 HTTP 正文。 12NSString * URLString = @\"http://example.com\";NSDictionary * parameters = @&#123; @\"foo\": @\"bar\", @\"baz\": @[@1, @2, @3 ]&#125;; Query String Parameter Encoding - 查询字符串参数编码 123[[AFHTTPRequestSerializer serializer] requestWithMethod:@\"GET\" URLString:URLString parameters:parameters error:nil];GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3 URL Form Parameter Encoding - URL 表单参数编码 123456[[AFHTTPRequestSerializer serializer] requestWithMethod:@\"POST\" URLString:URLString parameters:parameters error:nil];POST http://example.com/Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3 JSON Parameter Encoding - JSON 参数编码 123456[[AFJSONRequestSerializer serializer] requestWithMethod:@\"POST\" URLString:URLString parameters:parameters error:nil];POST http://example.com/Content-Type: application/json&#123;\"foo\": \"bar\", \"baz\": [1,2,3]&#125; 4.1 AFURLRequestSerialization 协议遵守协议的对象为指定的 HTTP 请求的参数进行编码，参数包含查询字符串、HTTP bodies、必要设置的合适的 HTTP 头字段。例如：一个 JSON 请求序列化可以将请求的 HTTP 主体设置为JSON 表示，并将 HTTP 头字段 ‘Content-Type’ 设置为 ‘application/json’。 4.2 AFMultipartFormData 协议该协议定义了一些方法。在 AFHTTPRequestSerializer 的 multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock: 方法中，block 参数返回遵守该协议的对象。 4.3 AFHTTPRequestSerializer遵守 AFURLRequestSerialization 协议。主要作用： ①、处理查询的 URL 参数 ②、设置 HTTP 头部字段 ③、设置请求的属性 ④、分块上传 - init 初始化属性，设置可解析的语言，用户信息，对属性添加观察 - dealloc 移除观察 SET、GET 属性的 setter、getter 方法。注意观察者模式的问题 - multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock: 创建 NSMutableURLRequest 对象，设置相关参数(请求方法，缓存策略等)，设置请求头字段，拼接查询字符串到 URL 或者放入 body 中 4.4 AFStreamingMultipartFormData遵守 AFMultipartFormData 协议 4.5 AFHTTPBodyPart inputStream 根据不同 body 内容设置不同的输入流 stringForHeaders 将 headers 字典的内容进行拼接 contentLength 求出请求内容的长度，包括：初始边界、 例子： 1234567891011121314151617--$&#123;bound&#125; // 该 bound 表示pdf 的文件名 Content-Disposition: form-data; name=\"Filename\" HTTP.pdf --$&#123;bound&#125; // 该 bound 表示pdf 的文件内容 Content-Disposition: form-data; name=\"file000\"; filename=\"HTTP协议详解.pdf\" Content-Type: application/octet-stream %PDF-1.5 file content %%EOF --$&#123;bound&#125; // 该 bound 表示字符串 Content-Disposition: form-data; name=\"Upload\" Submit Query --$&#123;bound&#125;— // 表示 body 结束了 4.6 AFQueryStringPair输出字段 - 值对的信息。 五、Network Reachability ManagerAFNetworkReachabilityManager 监控域的可达性，以及 WWAN 和 WiFi 网络接口的地址。 不要使用 Reachability 来确定是否应发送原始请求。 你应该尝试发送它。 可以使用 Reachability 来确定何时应该自动重试请求。 虽然它可能仍然失败，但是连接可用的可达性通知是重试某件事的好时机。 网络可达性是确定请求失败原因的有用工具。 在网络请求失败后，告诉用户他们处于离线状态比向他们提供更加技术性但准确的错误（如“请求超时”）要好。 可以参考 WWDC 2012 session 706, “Networking Best Practices. Shared Network Reachability 12345[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@\"Reachability: %@\", AFStringFromNetworkReachabilityStatus(status));&#125;];[[AFNetworkReachabilityManager sharedManager] startMonitoring]; 六、Security PolicyAFSecurityPolicy 通过安全连接评估针对固定的 X.509 证书和公钥的服务器信任。 将固定的 SSL 证书添加到您的应用程序有助于防止中间人攻击和其他漏洞。 强烈建议处理敏感客户数据或财务信息的应用程序通过 HTTPS 连接路由所有通信，并配置启用 SSL pinning。 Allowing Invalid SSL Certificates - 允许无效的 SSL 证书 12AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];manager.securityPolicy.allowInvalidCertificates = YES; // not recommended for production 在二进制的文件中获取公钥的过程是这样 ①、NSData *certificate -&gt; CFDataRef -&gt; (SecCertificateCreateWithData) -&gt; SecCertificateRefallowedCertificate ②、判断 SecCertificateRef allowedCertificate 是不是空，如果为空，直接跳转到后边的代码； ③、根据函数 SecPolicyCreateBasicX509() -&gt; SecPolicyRef policy ④、SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust) -&gt; 生成 SecTrustRef allowedTrust； ⑤、SecTrustEvaluate(allowedTrust, &amp;result) 校验证书； ⑥、(__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust) -&gt; 得到公钥 id, allowedPublicKey 这里边值得学习的地方是：__Require_Quiet 和 __Require_noErr_Quiet 这两个宏定义。 我们看看他们内部是怎么定义的 12345678910#ifndef __Require_Quiet #define __Require_Quiet(assertion, exceptionLabel) \\ do \\ &#123; \\ if ( __builtin_expect(!(assertion), 0) ) \\ &#123; \\ goto exceptionLabel; \\ &#125; \\ &#125; while ( 0 )#endif 可以看出这个宏的用途是：当条件返回 false 时，执行标记以后的代码 12345678910#ifndef __Require_noErr_Quiet #define __Require_noErr_Quiet(errorCode, exceptionLabel) \\ do \\ &#123; \\ if ( __builtin_expect(0 != (errorCode), 0) ) \\ &#123; \\ goto exceptionLabel; \\ &#125; \\ &#125; while ( 0 )#endif 可以看出这个宏的用途是：当条件抛出异常时，执行标记以后的代码。 这样就有很多使用场景了。当必须要对条件进行判断的时候，我们有下边几种方案了 ①、#ifdef 这个是编译特性 ②、if-else 代码层次的判断 ③、__Require_XXX 宏 1234567&#123; __Require_Quiet(0, _out); ..._out: ...&#125; _out 就是一个标记，这段代码 __Require_Quiet 到 _out 之间的代码不会执行。 七、单元测试AFNetworking 在 Tests 子目录中包含一套单元测试。 这些测试可以运行，只需在您想测试的平台框架上执行测试操作即可。 八、学习文章AFNetworking 概述（一）AFNetworking源码探究（一）– 基本介绍AFNetworking 3.0 源码解读（一）之 AFNetworkReachabilityManagersocket通信AFNetworking 3.0 源码解读（二）之 AFSecurityPolicyiOS 9之适配ATSAFNetworking 3.0 源码解读（三）之 AFURLRequestSerializationurl 编码（percentcode 百分号编码）AFNetworking 3.0 源码解读（四）之 AFURLResponseSerializationAFNetworking 3.0 源码解读（五）之 AFURLSessionManagerAFNetworking 3.0 源码解读（六）之 AFHTTPSessionManagerAFNetworking 3.0 源码解读（七）之 AFAutoPurgingImageCacheAFNetworking 3.0 源码解读（八）之 AFImageDownloaderAFNetworking 3.0 源码解读（九）之 AFNetworkActivityIndicatorManagerAFNetworking 3.0 源码解读（十）之 UIActivityIndicatorView/UIRefreshControl/UIImageView + AFNetworkingAFNetworking 3.0 源码解读（十一）之 UIButton/UIProgressView/UIWebView + AFNetworking","tags":[]},{"title":"iOS 内存管理：从 MRC 到 ARC 实践","date":"2019-05-23T09:43:10.193Z","path":"2019/05/23/iOS 内存管理：MRC、ARC/","text":"对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。 iOS 内存管理的核心是引用计数。 接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？ 同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？ 12NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding]; 属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。 12self.name = @\"qqstock\"; _name = @\"qqstock\"; 一、MRC 的初衷和实现方式苹果为什么要做这个？ 首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。 当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。 尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了。要么，自己写许许多多的代码，频繁对容器进行主动操作。 于是，苹果要解决这个问题。初衷就是：任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责。 苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。 与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。 另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。” 那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。 OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。 二、MRC 的优点和无奈总结： MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题 为了应对各种复杂的场景，很无奈的留了一个口子； 两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。 难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。 略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。 系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！ 引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。 再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。 三、编程语言和编译器的发展方向由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。 然而，编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？ 许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？ 更何况，人，总有打盹的时候。 四、ARC 的适时推出随着硬件的升级，条件已经成熟了，ARC 到来了！ ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。 之前对 C++ 程序员头疼的问题变得异常简单： 1234NSString * str1 = [NSString stringWithFormat:\"qqstock\"];NSString * str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding];self.name = @\"qqstock\";_name = @\"qqstock\"; 到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。 许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。 逻辑其实很简单。 首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低； 其次，一旦出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。 总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！ 五、总结如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。 许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。 ①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。 ②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。 ③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。 ④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。","tags":[]},{"title":"iOS 内存监控","date":"2019-05-23T09:27:05.583Z","path":"2019/05/23/iOS 内存监控/","text":"一、导读目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于 App 上线后发现内存问题。 FOOM(Foreground Out Of Memory) 是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。Facebook 早在 2015 年 8 月提出 FOOM 检测办法。 微信自 15 年年底上线 FOOM 上报，从最初数据来看，每天 FOOM 次数与登录用户数比例接近 3%，同期 crash 率 1% 不到。而后发现 kv 上报频繁打 log 引起 FOOM。接着分析大量日志还是不能找到 FOOM 原因。微信急需一个有效的内存监控工具来发现问题。 二、实现原理微信内存监控最初版本是使用 Facebook 的 FBAllocationTracker 工具监控 OC 对象分配，用 fishhook 工具 hook malloc/free 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP200 最大堆内存及其分配堆栈，用文本 log 输出到本地。该方案实现简单，一天内完成，通过给用户下发 TestFlight，最终发现联系人模块因迁移 DB 加载大量联系人导致FOOM。 不过这方案有不少缺点： ①、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用； ②、输出 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io 频繁等性能问题； ③、上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。 所以二期版本以 Instruments 的 Allocations 为参考，着重四个方面优化：数据收集、存储、上报及展现。 2.1 数据收集16 年 9 月底为了解决 ios10 nano crash，研究了 libmalloc 源码，无意中发现这几个接口： 123456789typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *__syscall_logger; // use this to set up syscall logging (e.g., vm_allocate, vm_deallocate, mmap, munmap) malloc_logger_t *malloc_logger = NULL; 当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。 有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址 = 堆栈地址 - slide。 另外为了更好的归类数据，每个内存对象应该有它所属的分类 Category。如上图所示。对于堆内存对象，它的 Category 名是 “Malloc” +分配大小，如 “Malloc 48.00KiB”。 对于虚拟内存对象，调用 vm_allocate 创建时，最后的参数 flags 代表它是哪类虚拟内存，而这个 flags 正对应于上述函数指针 __syscall_logger 的第一个参数 type，每个 flag 具体含义可以在头文件 \\&lt;mach/vm_statistics.h> 找到； 对于 OC 对象，它的 Category 名是 OC 类名，我们可以通过 hook OC方法 +[NSObject alloc] 来获取： 12345678910111213141516171819202122232425262728@implementation NSObject (Logger)+ (void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originSEL = @selector(alloc); SEL swizzeSEL = @selector(event_logging_alloc); Method originMethod = class_getClassMethod(self.class, originSEL); Method swizzeMethod = class_getClassMethod(self.class, swizzeSEL); method_exchangeImplementations(originMethod, swizzeMethod); &#125;);&#125;+ (instancetype)event_logging_alloc&#123; id object = [self event_logging_alloc]; // 对于 NSAutoreleasePool 对象会崩掉 nsobject_set_last_allocation_event_name(object, class_getName(self.class)); return object;&#125;void nsobject_set_last_allocation_event_name(id obj, const char * clsName)&#123; NSLog(@\"%s\", clsName); // 输出类名&#125; 但后来发现，NSData 创建对象的类静态方法没有调用 +[NSObject alloc]，里面实现是调用 C 方法 NSAllocateObject 来创建对象，也就是说类方式创建的 OC 对象无法通过 hook 来获取 OC 类名。最后在苹果开源代码 CF-1153.18 找到了答案，当__CFOASafe=true 并且 __CFObjectAllocSetLastAllocEventNameFunction != NULL 时，CoreFoundation 创建对象后通过这个函数指针告诉上层当前对象是什么类型： 1234// CFRuntime.cbool __CFOASafe = false;void (*__CFObjectAllocSetLastAllocEventNameFunction)(void *, const char *) = NULL; 通过上面方式，我们的监控数据来源基本跟 Allocations 一样了，当然是借助了私有 API，这是可能会被苹果打回的。只能退而求其次，修改 malloc_default_zone 函数返回的 malloc_zone_t 结构体里的 malloc、free 等函数指针，也是可以监控堆内存分配，效果等同于 malloc_logger；而虚拟内存分配只能通过 fishhook 方式。 2.2 数据存储①、存活对象管理 APP 在运行期间会大量申请/释放内存。以上图为例，微信启动 10 秒内，已经创建了 80 万对象，释放了 50 万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了 sqlite，改用了更轻量级的平衡二叉树来存储。 伸展树 Splay Tree，也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是 O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过 “伸展” 操作搬移到离树根更近的地方。 大部分情况下，内存申请很快又被释放，如 autoreleased 对象、临时变量等；而 OC 对象申请内存后紧接着会更新它所属 Category。所以用伸展树管理最适合不过了。 传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。 ②、堆栈存储 据统计，微信运行期间，backtrace 的堆栈有成百万上千万种，在捕获最大栈长 64 情况下，平均栈长 35。如果 36bits 存储一个地址（armv8 最大虚拟内存地址 48bits，实际上 36bits 够用了），一个堆栈平均存储长度 157.5bytes，1M 个堆栈需要157.5M 存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后 7 个地址是一样的： 为此，可以用 Hash Table 来存储这些堆栈。思路是整个堆栈以链表的方式插入到 table 里，链表结点存放当前地址和上一个地址所在 table 的索引。每插入一个地址，先计算它的 hash 值，作为在 table 的索引，如果索引对应的 slot 没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash 命中，继续处理下一个地址；数据不一致，意味着 hash 冲突，需要重新计算 hash 值，直到满足存储条件。举个例子（简化了 hash 计算）： Stack1 的 G、F、E、D、C、A 依次插入到哈希表，索引 1～6 结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1 索引入口是 6 轮到插入 Stack2，由于 G、F、E、D、C 结点数据跟 Stack1 前 5 个结点一致，hash 命中；B 插入新的 7 号位置 (B, 5)。Stack2 索引入口是 7 最后插入 Stack3，G、F、E、D 结点 hash 命中；但由于 Stack3 的 A 的上一个地址 D 索引是 4，而不是已有的 (A, 5)，hash 不命中，查找下一个空白位置 8，插入结点 (A, 4)；B 上一个地址 A 索引是 8，而不是已有的 (B, 5)，hash 不命中，查找下一个空白位置 9，插入结点 (B, 9)。Stack3 索引入口是 9 经过这样的后缀压缩存储，平均栈长由原来的 35 缩短到 5 不到。而每个结点存储长度为 64bits（36bits 存储地址，28bits 储存 parent 索引），hashTable 空间利用率 60%+，一个堆栈平均存储长度只需要 66.7bytes，压缩率高达 42%。 ③、性能数据 经过上述优化，内存监控工具在 iPhone6Plus 运行占用 CPU 占用率 13% 不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量 20M 左右，都用 mmap 方式把文件映射到内存。有关 mmap 好处可自行google。 三、数据上报由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现 FOOM 时，不可能全量上报，而是按某些规则有选择性的上报。 首先把所有对象按 Category 进行归类，统计每个 Category 的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对 Category 下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些 Category，如分配大小 TOP N，或者UI相关的（如 UIViewController、UIView 之类的），它里面分配大小 TOP M 的堆栈才做上报。上报格式类似这样： 123456789101112131415&#123; \"items\" : [&#123; \"name\" : \"NSObject\", # 分类名字 \"size\" : 123456, # 该分类下分配内存总大小 \"count\" : 123, \"stacks\" : [&#123; \"size\" : 21313, # 总大小 \"count\" : 123, # 对象个数 \"frames\" : [&#123; \"uuid\" : uuid1, # 地址所在 image 的 uuid \"offset\" : offset1 # 地址所在 image 的偏移 &#125;] &#125;] &#125;]&#125; 四、页面展现页面展现参考了 Allocations，可看出有哪些 Category，每个 Category 分配大小和对象数，某些 Category 还能看分配堆栈。 为了突出问题，提高解决问题效率，后台先根据规则找出可能引起 FOOM 的 Category（如上面的 Suspect Categories），规则有： UIViewController 数量是否异常 UIView 数量是否异常 UIImage 数量是否异常 其它 Category 分配大小是否异常，对象个数是否异常 接着对可疑的 Category 计算特征值，也就是 OOM 原因。特征值是由 “Caller1”、”Caller2” 和 “Category, Reason” 组成。Caller1 是指申请内存点，Caller2 是指具体场景或业务，它们都是从 Category 下分配大小第一的堆栈提取。Caller1 提取尽量是有意义的，并不是分配函数的上一地址。例如： 所有 report 计算出特征值后，可以对它们进行归类了。一级分类可以是 Caller1，也可以是 Category，二级分类是与Caller1/Category 有关的特征聚合。效果如下： 4.1 一级分类 4.2 二级分类 五、运营策略上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概 300K 左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做 100% 开启。本地最多只保留最近三次数据。 六、降低误判先回顾 Facebook 如何判定上一次启动是否出现 FOOM： App 没有升级 App 没有调用 exit() 或 abort() 退出 App 没有出现 crash 用户没有强退 App 系统没有升级/重启 App 当时没有后台运行 App 出现 FOOM 1、2、4、5 比较容易判断，3 依赖于自身 CrashReport 组件的 crash 回调，6、7 依赖于 ApplicationState 和前后台切换通知。微信自上线 FOOM 数据上报以来，出现不少误判，主要情况有： 6.1 ApplicationState 不准部分系统会在后台短暂唤起 app，ApplicationState 是 Active，但又不是 BackgroundFetch；执行完 didFinishLaunchingWithOptions 就退出了，也有收到 BecomeActive 通知，但很快也退出；整个启动过程持续 5～8 秒不等。解决方法是收到 BecomeActive 通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。 6.2 群控类外挂这类外挂是可以远程控制 iPhone 的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。 6.3 CrashReport 组件出现 crash 没有回调上层微信曾经在 17 年 5 月底爆发大量 GIF crash，该 crash 由内存越界引起，但收到 crash 信号写 crashlog 时，由于内存池损坏，组件无法正常写 crashlog，甚至引起二次 crash；上层也无法收到 crash 通知，因此误判为 FOOM。目前改成不依赖 crash回调，只要本地存在上一次 crashlog（不管是否完整），就认为是 crash 引起的 APP 重启。 6.4 前台卡死引起系统 watchdog 强杀也就是常见的 0x8badf00d，通常原因是前台线程过多，死锁，或 CPU 使用率持续过高等，这类强杀无法被 App 捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被 watchdog 强杀。同时我们从 FOOM 划分出新的重启原因叫“App 前台卡死导致重启”，列入重点关注。 七、成果微信自 2017 年三月上线内存监控以来，解决了 30 多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM 率由 17 年年初 3%，降到目前 0.67%，而前台卡死率由 0.6% 下降到 0.3%，效果特别明显。 八、常见问题1、UIGraphicsEndImageContext UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode的 Analyze 也能扫出这类问题。 2、UIWebView 无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 APP 大量内存。而 WKWebView 不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。 3、autoreleasepool 通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。 4、互相引用 比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer的target、CAAnimation 的 delegate，是对 Obj 强引用。目前微信通过自己实现的 MMNoRetainTimer 和MMDelegateCenter 来规避这类问题。 5、大图片处理 举个例子，以往图片缩放接口是这样写的： 123456789- (UIImage *)scaleImage:(UIImage *)originIamge newSize:(CGSize)newSize&#123; UIGraphicsBeginImageContextWithOptions(originIamge.size, NO, 0); [originIamge drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很耗内存的。解决方法是使用更低层的 ImageIO 接口，避免中间 bitmap 产生： 1234567891011+ (UIImage *)scaleImageWithData:(NSData *)data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation&#123; CGFloat maxPixelSize = MAX(size.width, size.height); CGImageSourceRef sourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, nil); NSDictionary * options = @&#123; (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceThumbnailMaxPixelSize : @(maxPixelSize)&#125;; CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options); UIImage * resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation]; CGImageRelease(imageRef); CFRelease(sourceRef); return resultImage; 6、大视图 大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。 九、学习文章iOS微信内存监控Memory Usage Performance GuidelinesNo pressure, Mon!","tags":[]},{"title":"property","date":"2019-05-23T08:46:45.820Z","path":"2019/05/23/property/","text":"一、简介属性 property 是 Objective-C 的一项特性，用于封装对象中的数据。这一特性可以令编译器自动编写与属性存取方法，并且保存为各种实例变量。 属性的本质是实例变量与存取方法的结合。@property = ivar + getter + setter 二、特质2.1 原子性 atomic/noatomic 原子性：并发编程中确保其操作具备整体性，系统其它部分无法观察到中间步骤，只能看到操作前后的结果。 由于要保证操作完整，atomic 速度比较慢，线程相对安全；nonatomic 速度比较快，但是线程不安全。 atomic 也不是绝对的线程安全，当多个线程同时调用 set 和 get 时，就会导致获取的值不一样。由于锁定机制开销较大，一般 iOS 开发中会使用 nonatomic，而 macOS 中使用 atomic 通常不会有性能瓶颈。 要想线程绝对安全，就要使用 @synchronized 同步锁。但是由于同步锁有等待操作，会降低代码效率。为了兼顾线程安全和提升效率，可采用 GCD 并发队列进行优化改进。get 使用同步派发，set 使用异步栅栏。 12345678910111213141516171819202122232425262728293031// 同步锁-(NSString *)some&#123; @synchronized(self) &#123; return _some; &#125; &#125;-(void)setSome:(NSString *)some&#123; @synchronized(self) &#123; _some = some; &#125;&#125;// 并发队列_queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);-(NSString *)some&#123; __block NSString *localSome; dispatch_sync(_queue, ^ &#123; localSome = _some; &#125;); return localSome;&#125;-(void)setSome:(NSString *)some&#123; dispatch_barrier_async(_queue, ^&#123; _some = some; &#125;);&#125; 2.2 读写权限 readwrite/readonly默认为 readwrite。一般可在 .h 里写成 readonly，对外只提供读取方法，在 .m 的 Extension 中再设置为 readwrite 可进行写入。 12345// .h 文件@property (nonatomic, readonly, strong) AModel * model;// .m 文件@property (nonatomic, readwrite, strong) AModel * model; 2.3 内存管理语义 assign、strong、copy、weak、unsafe_unretained2.3.1 关键词strong：指向并拥有该对象。其修饰的对象引用计数会 +1，该对象只要引用计数不为 0 就不会销毁，置为 nil 可以销毁它，一般用于修饰对象类型、字符串和集合类的可变版本。 1234567891011121314151617// .h 文件@property (nonatomic, strong) NSMutableArray * nArr;// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-10-16 19:29:27.550029+0800 Demo[64192:936916] ( a, b, c, d) 0x60000005bc60 0x60000005bc60 // 地址相同 copy：与 strong 类似，设置方法会拷贝一份副本。一般用于修饰字符串和集合类的不可变版，block 用 copy 修饰。自定义对象需要实现 NSCoping 协议。 12345678910111213141516// .h 文件@property (nonatomic, copy) NSArray * nArr;// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-10-16 19:27:27.678093+0800 Demo[63966:933713] ( a, b, c) 0x60000024e070 0x60000024c960 // 地址不同 自定义对象实现 NSCoping 协议 1234567- (instancetype)copyWithZone:(NSZone *)zone&#123; AModel * model = [[[self class] allocWithZone:zone] init]; model.title = self.title; model.desc = self.desc; return model;&#125; weak：指向但不拥有该对象。其修饰的对象引用计数不会增加，属性所指的对象遭到摧毁时值会清空。ARC 环境下一般用于修饰可能会引起循环引用的对象，delegate、xib 控件用 weak 修饰。 assign：主要用于修饰基本数据类型，如 NSInteger、CGFloat 等，这些数值主要存在于栈中。 unsafe_unretained：与 weak 类型，但是销毁时不自动清空，容易形成野指针。 2.3.2 比较 copy 和 strong相同：用于修饰表示拥有关系的对象； 不同：strong 赋值是多个指针指向同一个地址，而 copy 的赋值是每次会在内存中赋值一份对象，指针指向不同的地址。 NSString、NSArray、NSDictionary 等不可变对象用 copy 修饰，因为有可能赋值一个可变类型的指针，此时能保证属性值不会受外界影响。 注意：若用 strong 修饰 NSArray，当数组接收一个可变数组，可变数组若发生变化，被修饰的属性数组也会发生变化，也就是说属性值容易被篡改；若用 copy 修饰 NSMutableArray，当试图修改属性数组里的值时，程序会崩溃，因为数组被复制成了一个不可变的版本。 123456789101112131415161718// .h 文件@property (nonatomic, strong) NSArray * nArr; // strong 修改不可变属性// .m 文件&#123; NSMutableArray * mArr = [[NSMutableArray alloc] initWithObjects:@\"a\", @\"b\", @\"c\", nil]; self.nArr = mArr; // 赋值 [mArr addObject:@\"d\"]; NSLog(@\"%@ %p %p\", self.nArr, self.nArr, mArr);&#125;2018-11-02 11:12:25.479726+0800 DemoDemo[11401:1924103] ( a, b, c, d) 0x60000045bed0 0x60000045bed0 // 地址相同 2.3.3 比较 assign、weak、unsafe_unretained相同点：都不是强引用 不同点：weak 引用的 OC 对象被销毁时，指针会被自动清空，不再指向销毁的对象，不会产生野指针错误；unsafe_unretained 引用的 OC 对象被销毁时，指针并不会被自动清空，依然指向销毁的对象，很容易产生野指针错误：EXC_BAD_ACCESS；assign 修饰基本数据类型，内存在栈上由系统自动回收，修饰对象类型时，也可能存在野指针。 在使用 delegate 时，需要注意：MRC 时是使用 assign，到了 ARC 环境，都建议使用 weak，这样更安全。 不管是 MRC 还是 ARC，使用 assign 时，都需要注意释放。如果在 ARC 下，没有做这个逻辑的话，当页面销毁的时候，很可能出现delegate 对象无效，导致程序 crash。 2.4 方法 setter= 与 getter=&lt;&gt; 中为方法名，通过此特质来指定存取方法的名称。 123456@property (nonatomic, assign, getter=isOn) BOOL on;-(BOOL)isOn&#123; return self.on;&#125; 三、默认设置基本数据类型：(atomic, readwrite, assign)对象类型：(atomic, readwrite, strong) 注意：考虑到代码可读性以及日常代码修改频率，规范的编码风格中关键词的顺序是：原子性、读写权限、内存管理语义、setter/getter。 四、延伸@property 会使编译器自动编写访问这些属性所需的方法，此过程在编译期完成，称为自动合成（autosynthesis）。与此相关的还有两个关键词：@dynamic 和 @synthesize。 4.1 @dynamic告诉编译器不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。即使编译器发现没有定义存取方法也不会报错，运行期会导致崩溃。 4.2 @synthesize在类的实现文件里可以通过 @synthesize 指定实例变量的名称。 注意：Xcode4.4 之前，@property 配合 @synthesize 使用，@property 负责声明属性，@synthesize 负责让编译器生成带下划线的实例变量并且自动生成 setter、getter 方法；在 Xcode4.4 之后 @property 得到增强，直接一并替代了@synthesize 的工作。 五、学习文章《Effective Objective-C 2.0》","tags":[]},{"title":"ARC","date":"2019-05-23T08:17:05.311Z","path":"2019/05/23/ARC/","text":"一、ARCARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果修改了一些内存管理代码的书写方式，干脆编译器在编译时把内存管理的代码都自动补上。 ARC 是编译器特性，而不是运行时特性，更不是垃圾回收器（GC）。 Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. 程序在编译的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，编译器帮我们在合适的地方插入retain、release 等代码以管理对象的引用计数，从而达到自动管理对象生命周期的目的。 所以 ARC 是工作在编译期的一种技术方案，这样的好处： 编译之后，ARC 与 MRC 代码是没有什么差别的，所以二者可以在源码中共存。 相对于垃圾回收这类内存管理方案，ARC 不会带来运行时的额外开销，所以对于应用的运行效率不会有影响。相反的，由于ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。 只有编译器是无法单独完成这一工作的，还需要 OC 运行时库的配合协助，因此 ARC 的实现工具主要包括： LLVM 编译器（clang 3.0 以上） OC 运行时库 493.9 以上 weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。 ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外 10% 的内存管理问题是需要开发者处理的，这主要是与底层 Core Foundation 对象交互的部分，底层 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。 二、ARC 的开启和关闭在 Targets -》Build Settings 中搜索 Automatic Reference Counting，可以修改它的布尔值，yes - 开启 no - 关闭。 如果需要对特定文件开启或关闭 ARC，可以在 Targets -》Build Phases -》Compile Sources，在里面找到对应文件，添加flag： 开启：-fobjc-arc 关闭：-fno-objc-arc 三、ARC 的修饰符主要提供了 4 种修饰符，他们分别是：__strong、__weak、__autoreleasing、__unsafe_unretained。 3.1 __strong强引用。相当于 @property 的 “strong”。所有对象只有当没有任何一个强引用指向（引用计数为 0）时，才会被释放。 注意：如果在声明引用时不加修饰符，那么将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置 nil。 使用 __strong 修饰变量的程序运行过程。 123&#123; id __strong object = [[NSObject alloc] init];&#125; 转换后的模拟源代码为： 1234/*编译器的模拟代码*/id object = objc_msgSend(NSObjct, @selector(alloc));objc_msgSend(object, @selector(init));objc_release(object); 对象变量生成时，分别调用 alloc 和 init 方法，对象变量作用域结束时调用 objc_release 方法释放对象变量，虽然 ARC 情况下不能使用 release 方法，但是由此可见编译器编译时在合适的地方插入了 release。 在使用 alloc、new、copy、mutableCopy 以外的方法生成对象变量方法时会有什么不同 123&#123; id __strong object = [NSMutableArray array];&#125; 调用 array 的类方法转换后： 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); objc_release(object);&#125; objc_retainAutoreleasedReturnValue(object) 函数的作用：最优化程序运行。 自己持有（retain）对象的函数，但它持有的应为返回注册在 autoreleasepool 中对象的方法或函数的返回值。 objc_retainAutoreleasedReturnValue 函数与 objc_autoreleasedReturnValue 是成对出现的，现在看看 NSMutableArray 类的 array 类方法的编译器实现。 123+ (id)array &#123; return [[NSMutableArray alloc] init];&#125; 转换后的源代码。 1234567+ (id)array&#123; /*编译器的模拟代码*/ id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 通过 objc_autoreleaseReturnValue 函数将对象注册在自动释放池 autoreleasepool 中并返回，但是与 objc_autorelease 函数不同的是，objc_autoreleaseReturnValue 函数一般不仅限于注册对象到 autoreleasepool 中去。 objc_autoreleaseReturnValue 与 objc_retainAutoreleasedReturnValue 的配合使用，可以不将对象注册到autoreleasepool 中而直接传递，达到最优化。 objc_autoreleaseReturnValue 函数会检查使用该函数的方法或者函数的调用方的执行命令列表，如果调用方在调用该函数或方法之后，紧接着调用了 objc_retainAutoreleasedReturnValue 函数，那么不再将对象注册到 autoreleasepool 中去，而直接将对象传递给调用方。 相比于 objc_retain 函数来说 objc_retainAutoreleasedReturnValue 函数在返回一个即使没有注册到autoreleasepool 中的对象，也能正确的获取对象。 3.2 __weak弱引用。相当于 @property 的 “weak”。弱引用不会影响对象的引用计数，即只要对象没有任何强引用指向，即使有 n 个弱引用对象指向也没用，该对象依然会被释放。 对象在被释放的同时，指向它的弱引用（weak）会自动被置 nil，这个技术叫 zeroing weak pointer。这样有效的防止无效指针、野指针的产生。__weak 一般用在 delegate 关系中防止循环引用或者用来修饰指向由 Interface Builder 编辑与生成的 UI 控件。 123&#123; id _weak object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id object; id tmp = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(tmp, @selector(init)); objc_initWeak(&amp;object, tmp); objc_release(tmp); objc_destoryWeak(&amp;object);&#125; 自己生成并且持有的对象通过 objc_initWeak 函数赋值给 __weak 修饰符的变量，但是编译器判断并没有对其进行持有，因此该对象通过 objc_release 函数被释放和废弃。 随后通过 objc_destoryWeak 将引用废弃对象的附有 __weak 修饰符的变量置为 nil。 如果不是直接赋值，而是通过使用 __weak 修饰符来引用变量时。 1234&#123; id __weak object = obj; NSLog(@\"%@\", object);&#125; 转换后的模拟源代码。 123456789/*编译器的模拟代码*/&#123; id object; objc_initWeak(&amp;object, obj); id temp = objc_loadWeakRetained(&amp;object); objc_autorelease(temp); NSLog(@\"%@\", temp); objc_destoryWeak(&amp;object);&#125; 明显增加了 objc_loadWeakRetained 与 objc_autorelease 函数调用，他们的主要作用是： objc_loadWeakRetained 函数取出 __weak 修饰符变量引用的对象并且 retain objc_autorelease 函数将引用的对象注册到 autoreleasepool 中。 因此，使用 __weak 修饰符引用的对象都被注册到 autoreleasepool 中，在 @autoreleasepool 块结束之前都可以放心使用，大量使用 __weak 修饰符的变量，导致注册到 autoreleasepool 中的对象也大量地增加。所以在使用 __weak 修饰符引用的变量时，最好先暂时用 __strong 修饰符的变量进行引用后再使用。 2 种不能使用 __weak 修饰符的情况： 重写了 retain/release 的类，例如 NSMachPort 类； 当 allowsWeakReference/retainWeakReference 实例方法返回 NO 时。 3.3 __autoreleasing对象被加入到 autorelease pool，是会自动释放的引用，与 MRC 中 autorelease 的用法相同。定义 @property 时不能使用这个修饰符。 对于 alloc、new、copy、mutableCopy 的实现。 123@autoreleasepool&#123; id __autoreleasing object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSObjct, @selector(alloc)); objc_msgSend(object, @selector(init)); // 调用autorelease方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; NSMutableArray 类中的 array 方法如何实现 autorelease 功能。 123@autoreleasepool&#123; id __autoreleasing object = [NSMutableArray array];&#125; 转化后的模拟源代码。 123456789&#123; /* 编译器的模拟代码 */ id pool = objc_autoreleasePoolPush(); id object = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(object); // 调用 autorelease 方法 objc_autorelease(object); id pool = objc_autoreleasePoolPop();&#125; 除了持有对象的方法从 alloc 变成了 objc_retainAutoreleasedReturnValue 函数，但是注册到 autoreleasepool 的方法没有变化，都是调用了 objc_autorelease 函数。 一个常见的误解是，在 ARC 中没有 autorelease，因为这样一个“自动释放”看起来好像有点多余。 这个误解可能源自于将 ARC 的“自动” 和 autorelease “自动” 的混淆。其实你只要看一下每个 iOS App 的 main.m 文件就能知道，autorelease 不仅好好的存在着，并且不需要再手工被创建，也不需要再显式得调用 [pool drain] 方法释放内存池。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 以下两行代码的意义是相同的。 12NSString * str = [[[NSString alloc] initWithFormat:@\"China\"] autorelease]; // MRCNSString * __autoreleasing str = [[NSString alloc] initWithFormat:@\"China\"]; // ARC __autoreleasing 在 ARC 中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。 __autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 比如常见的 NSError 的使用： 123456NSError * __autoreleasing error; // writeToFile方法中 error 参数的类型为 (NSError *__autoreleasing *)）￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123; NSLog(@\"Error: %@\", error.localizedDescription); &#125; 注意：如果 error 的修饰符为 strong，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个 __autoreleasing 类型的引用。 12345678NSError * error; NSError * __autoreleasing tempError = error; // 编译器添加 if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) ￼&#123; error = tempError; // 编译器添加 NSLog(@\"Error: %@\", error.localizedDescription); &#125; 为了避免这种情况，提高效率，一般在定义 error 的时候将其声明为__autoreleasing 类型的： 1NSError *__autoreleasing error; 加上 __autoreleasing 之后，相当于在 MRC 中对返回值 error 做了如下事情： 1*error = [[[NSError alloc] init] autorelease]; *error 指向的对象在创建出来后，被放入到了 autoreleasing pool 中，等待使用结束后的自动释放，函数外 error 的使用者并不需要关心 *error 指向对象的释放。 另外，在 ARC 中，所有这种指针的指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 __autoreleasing 类型。 比如下面的两段代码是等同的： 12345678- (NSString *)doSomething:(NSNumber **)value&#123; // do something &#125;- (NSString *)doSomething:(NSNumber * __autoreleasing *)value&#123; // do something &#125; 除非显式得给 value 声明了 __strong，否则 value 默认就是 __autoreleasing 的。 最后一点，某些类的方法会隐式地使用自己的 autorelease pool，在这种时候使用 __autoreleasing 类型要特别小心。 比如 NSDictionary 的 - enumerateKeysAndObjectsUsingBlock: 方法会隐式地创建一个 autorelease pool. 123456789- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; // do stuff if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; &#125;];￼&#125; 上面代码实际类似于： 123456789101112- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; @autoreleasepool // 被隐式创建 &#123; if (...) &#123; *error = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125;￼ &#125; &#125;]; // *error 在这里已经被dict的做枚举遍历时创建的 autorelease pool 释放掉了 ￼&#125; 为了能够正常的使用 *error，我们需要一个 strong 型的临时引用，在 dict 的枚举 block 中使用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 block 后被释放，正确的方式如下： 123456789101112131415- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; __block NSError * tempError; // 加 __block 保证可以在 Block 内被修改 [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (...) &#123; *tempError = [NSError errorWithDomain:@\"Not Found\" ￼code:404 userInfo:nil]; &#125; ￼ &#125;] if (error != nil) &#123; *error = tempError; &#125; ￼&#125; 3.4 __unsafe_unretainedARC 是在 iOS 5 引入的，而这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些低版本的设备没有 weak pointer system，这个系统简单的理解就是上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil。 相当于 @property 的 “unsafe_unretained”，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然指向原来被释放的对象（所在的内存区域）。所以非常不安全。 现在可以完全忽略掉这个修饰符了，因为 iOS 4 早已退出历史舞台很多年。 123&#123; id __unsafe_unretained object = [[NSObject alloc] init];&#125; 转换后的模拟源代码。 123456&#123; /*编译器的模拟代码*/ id object = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(object, @selector(init)); objc_release(tmp);&#125; 可见通过 __unsafe_unretained 修饰的变量引用了对象但是并不持有对象，对象在释放和废弃后，并没有调用被 __unsafe_unretained 修饰的变量的 objc_destoryWeak 函数，因此该对象的悬垂指针被赋值给变量 object，导致引用变量 object 时发生崩溃。 3.5 正确使用修饰符苹果的文档中明确地写道： You should decorate variables correctly. When using qualifiers in an object variable declaration,the correct format is: ClassName * qualifier variableName; 按照这个说明，要定义一个 weak 修饰的 NSString 引用，它的写法应该是： 1NSString * __weak str = @\"Hello\"; // 正确 而不应该是： 1__weak NSString *str = @\"Hello\"; // 错误 那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道： Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see http://cdecl.org/. 看来是苹果考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符。 3.6 栈中指针默认值为 nil无论是被 strong、weak 还是 autoreleasing 修饰，声明在栈中的指针默认值都会是 nil。所有这类型的指针不用再初始化的时候置 nil 了。这个特性更加降低了“野指针”出现的可能性。 在 ARC 中，以下代码会输出 null 而不是 crash。 12345- (void)myMethod &#123; NSString * name; NSLog(@\"%@\", name);&#125; 四、ARC 与 Block在手动管理内存时代，block 会隐式地对进入其作用域内的对象（或者说被 block 捕获的指针指向的对象）执行 retain 操作，来确保 block 使用到该对象时，能够正确的访问。 123456789101112131415161718192021222324MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; // 隐式地调用 [myController retain]; 造成循环引用 [myController dismissViewControllerAnimated:YES completion:nil];&#125;;[self presentViewController:myController animated:YES completion:^&#123; // 调用[myController release];是在 MRC 中的一个常规写法，并不能解决上面循环引用的问题 [myController release]; &#125;];@interface SecondVC : UIViewController@property (nonatomic, copy) void (^ block)(void);@end&#123; SecondVC * vc = [[SecondVC alloc] init]; NSLog(@\"%lu\", (unsigned long)vc.retainCount); vc.block = ^ &#123; NSLog(@\"%lu\", (unsigned long)vc.retainCount); &#125;; vc.block();&#125;2018-11-16 10:26:05.872092+0800 Demo[49289:1083433] 12018-11-16 10:26:05.872214+0800 Demo[49289:1083433] 2 dismissBlock 调用了 [myController dismiss..] 方法，这时 dismissBlock 会对 myController 执行 retain 操作。 而作为 myController 的属性，myController 对 dismissBlock 也至少有一个 retain（一般准确讲是 copy），这时就出现了在内存管理中最糟糕的情况：循环引用。也就是说：相互持有对方。循环引用导致了 myController 和 dismissBlock 最终都不能被释放。 对 delegate 指针用 weak 就是为了避免这种问题。 不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题： 我们一般用如下方法解决：给进入 block 的指针加一个 __block 修饰符。 这个 __block 在 MRC 时代有两个作用： 说明变量可改 说明指针指向的对象不做隐式的 retain 操作 除了静态变量和全局变量不需要加 __block 就可以在 block 中修改外，其他变量不加则不能在 block 中修改。 对代码做出修改，解决了循环引用的问题： 12345MyViewController * __block myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;; // 之后正常的 release 或者 retain 在 ARC 环境下，没有了 retain 和 release 等操作，情况也发生了改变： 在任何情况下，__block 修饰符的作用只有上面的第一条：说明变量可改。即使加上了 __block 修饰符，一个被 block 捕获的强引用也依然是一个强引用。 所以在 ARC 下，如果还按照 MRC 下的写法，添加 __block 是没有解决循环引用的问题。 代码修改如下： 12345__block MyViewController * myController = [[MyViewController alloc] init…]; myController.dismissBlock = ^(NSString * result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; // 注意这里，保证了 block 结束对 myController 强引用的解除&#125;; 在 block 中将捕获的指针置为 nil，保证了 dismissBlock 对 myController 强引用的解除，不过也同时解除了myController 指针对 myController 对象的强引用。 更好的方法就是使用 weak。（或者为了考虑 iOS4 的兼容性用 unsafe_unretained，具体用法和 weak 相同） 为了保证 dismissBlock 对 myController 没有强引用，我们可以定义一个临时的弱引用 weakMyViewController 来指向原myController 的对象，并把这个弱引用传入到 dismissBlock 内，这样就保证了 dismissBlock 对 myController 持有的是一个弱引用，而不是一个强引用。如此，继续修改代码如下： 1234MyViewController * __weak weakMyViewController = myController;myController.dismissBlock = ^(NSString * result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 这样循环引用的问题就解决了，但是却引入了一个新的问题：由于传入 dismissBlock 的是一个弱引用，那么当 myController指向的对象在 dismissBlock 被调用前释放，那么 dismissBlock 就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。 为了保证在 dismissBlock 内能够访问到正确的 myController，我们在 dismissBlock 内新定义一个强引用strongMyController 来指向 weakMyController 指向的对象，这样多了一个强引用，就能保证这个 myController 对象不会在 dismissBlock 被调用前释放掉了。于是，对代码再次做出修改： 1234567891011MyViewController * __weak weakMyController = myController;// __weak typeof(myController) weakMyController = myController;myController.dismissBlock = ^(NSString * result) &#123; MyViewController * strongMyController = weakMyController; // __strong typeof(weakMyController) strongMyController = weakMyController; if (strongMyController) &#123; [strongMyController dismissViewControllerAnimated:YES completion:nil]; &#125; else &#123; &#125;&#125;; 很多读者会有疑问，不是不希望 block 对原 myController 对象增加强引用么，这里为什么堂而皇之地在 block 内新定义了一个强引用，这个强引用不会造成循环引用么？ 理解这个问题的关键在于被 block 捕获的引用和在 block 内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block 的实现原理，详细的内容可以参考其他的文章：谈Objective-C block的实现、block 实现、正确使用Block避免Cycle Retain和Crash。 为了更清楚地说明问题，这里用一个简单的程序举例。如下程序： 123456789101112#include &lt;stdio.h&gt;int main()&#123; int b = 10; int *a = &amp;b; void (^ block)() = ^() &#123; int *c = a; &#125;; block(); return 1;&#125; 程序中，同为 int 型的指针，a 变量被 block 捕获，而 c 变量是在 block 内定义的。用 clang -rewrite-objc 命令处理后，可以看到如下代码。 原 main 函数： 12345678910int main()&#123; int b = 10; int *a = &amp;b; void (*block)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 1;&#125; block 的结构： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *a; // 被捕获的引用 a 出现在了 block 的结构体里面 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 实际执行的函数： 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *a = __cself-&gt;a; // bound by copy int *c = a; // 在 block 中声明的引用 c 在函数中声明，存在于函数栈上&#125; 可以清楚的看到，a 和 c 存在的位置完全不同，如果 block 存在于堆上（在 ARC 下 block 默认在堆上），那么 a 作为 block 结构体的一个成员，也自然会存在于堆上，而 c 无论如何，永远位于 block 内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c 在 block 的函数运行完毕，即会被释放，而 a 只有在 block 被从堆上释放的时候才会释放。 回到之前的示例，如果直接让 dismissBlock 捕获 myController 引用，那么这个引用会被复制后作为 dismissBlock 的成员变量存在于其所在的堆空间中，也就是为 dismissBlock 增加了一个指向 myController 对象的强引用，这就是造成循环引用的本质原因。 对于 MyViewController 的例子，dismissBlock 的结构体大概是这个样子： 123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __strong myController; // 被捕获的强引用 myController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而给 dismissBlock 传入一个弱引用 weakMyController，这时 dismissBlock 的结构： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __weak weakMyController; // 被捕获的弱引用 weakMyController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 在 dismissBlock 内声明的强引用 strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，一直持有 myController 对象，但当函数执行完毕，strongMyController 即被销毁，于是它对 myController 对象的强引用被解除，这时 dismissBlock 对 myController 对象就不存在强引用关系了！ 加入了 strongMyController 的函数大体会是这个样子： 123static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; MyViewController * __strong strongMyController = __cself-&gt;weakMyController;&#125; 在 ARC 中，block 捕获的引用和 block 内声明的引用，存储空间与生命周期都是不同的。 实际上，在自动引用计数环境下，对 block 捕获对象的内存管理已经简化了很多，由于没有了 retain 和 release 等操作，实际只需要考虑循环引用的问题就行了。 五、ARC 与 Toll-Free Bridging There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的示例： 12345678910NSLocale * gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_GB\"];CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);NSLog(@\"cfIdentifier: %@\", (NSString *)cfIdentifier); // logs: \"cfIdentifier: en_GB\"CFRelease((CFLocaleRef) gbNSLocale);CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale * myNSLocale = (NSLocale *) myCFLocale;[myNSLocale autorelease];NSString * nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef) [@\"nsIdentifier: \" stringByAppendingString:nsIdentifier]); // logs identifier for current locale 在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 retain 和 release 操作规则，所以Toll-Free Bridging 的使用比较简单，但是自从 ARC 加入后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。 这个时候就必须要考虑一个问题，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership 的改变。 If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined in NSObject.h) 于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。 5.1 __bridge 只是声明类型转变，但是不做内存管理规则的转变。 示例： 1CFStringRef s = (__bridge CFStringRef)[[NSString alloc] initWithFormat:@\"Hi, %@!\", name]; 只是 NSString 到 CFStringRef 的类型转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s，不能用CFRelease() 去释放 s。 5.2 __bridge_retained、CFBridgingRetain() 将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给 Core Foundation 来处理，也就是，将 ARC 转变为 MRC。 示例： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (__bridge_retained CFStringRef)s1;...￼CFRelease(s2); // 注意在使用结束后释放 在第二行做了转化，这时内存管理规则由 ARC 变成了 MRC，需要手动的来管理 s2 的内存，而对于 s1，即使将其置为 nil，也不能释放内存。 也可以写成： 1234NSString * s1 = [[NSString alloc] initWithFormat:@\"Hi, %@!\", name];￼CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);...￼CFRelease(s2); // 注意在使用结束后释放 5.3 __bridge_transfer、CFBridgingRelease() 功能与 __bridge_retained 相反，表示将管理的责任由 Core Foundation 转交给 Objective-C，即将管理方式由MRC 转变为 ARC。 比如： 1234CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);￼NSString * s = (__bridge_transfer NSString *)result; // 或 NSString * s = (NSString *)CFBridgingRelease(result);￼return s; 这里将 result 的管理责任交给了 ARC 来处理，就不需要再显式地调用 CFRelease() 了。 这里和 ARC 中 4 个主要的修饰符 __strong、__weak、__autoreleasing… 不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但最好与官方的相同。 六、ARC下获取引用计数6.1 使用 KVC1[obj valueForKey:@\"retainCount\"]; 6.2 使用私有 API123OBJC_EXTERN int _objc_rootRetainCount(id);_objc_rootRetainCount(obj); 这个不一定完全可信。Xcode 10.1 用的示例一直返回 1。 6.3 使用 CFGetRetainCount1CFGetRetainCount((__bridge CFTypeRef)(obj)) 使用 Toll-Free-Bridging 将 OC 对象的内容管理转为 Core Foundation 对象。 七、学习文章iOS 开发ARC内存管理技术要点谈 Objective-C block的实现block 的实现正确使用 Block 避免Cycle Retain和CrashARC 的实现原理","tags":[]},{"title":"引用计数","date":"2019-05-23T07:16:48.623Z","path":"2019/05/23/引用计数/","text":"一、简介 OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。 OC 在内存管理上采用了引用计数，它是一个简单而有效管理对象生命周期的方式。在对象内部保存一个用来表示被引用次数的数字，init、new 和 copy 都会让计数 +1，调用 release 让计数 -1。当计数等于 0 的时候，系统调用 dealloc 方法来销毁对象。 123A * a = [[A alloc] init]; // retain count = 1A * b = a; // 指针赋值时，retain count 不会自动增加[b retain]; // retain count = 2 12345678910111213141516171819&#123; OBJC_EXTERN int _objc_rootRetainCount(id); NSObject * obj = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj)); NSObject * obj1 = [[NSObject alloc] init]; // 创建对象并引用，引用计数为 1 NSLog(@\"obj1 retainCount:%lu\", (unsigned long)_objc_rootRetainCount(obj1)); // obj 指向了 obj1 所指的对象 B，失去了对原来对象A的引用,所以对象A的引用计数-1，为 0。A 被销毁 // 对于 B，obj 引用了它，所以引用计数 +1，为 2 obj = obj1; // self.obj 又引用了 A,所以引用计数 +1，为 3 self.obj = obj; NSLog(@\"strong obj1 retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj1)); NSLog(@\"strong obj retainCount:%lu\",(unsigned long)_objc_rootRetainCount(obj));&#125; 引用计数分为自动引用计数「ARC : Automatic Reference Counting」和手动引用计数「MRC : Manual Reference Counting」。 二、原理 三、示例1234567891011121314151617NSObject * obj1 = [NSObject new];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);NSObject * obj2 = [obj1 retain];NSObject * obj3 = [obj1 retain];NSLog(@\"引用计数: %lu\", (unsigned long)[obj1 retainCount]);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);[obj1 release];NSLog(@\"引用计数: %lu %@\", (unsigned long)[obj1 retainCount], obj1);引用计数：1引用计数：3引用计数：2 &lt;NSObject：0x60400001ecd0&gt;引用计数：1 &lt;NSObject：0x60400001ecd0&gt;*** -[NSObject retainCount]: message sent to deallocated instance 0x60400001ecd0 根据 Debug 输出可以看到：obj1 可以调用多次 release 方法。 从两次打印 obj1 的地址相同可以猜测，在 [obj1 release] 执行之后对象的引用计数 -1，不再强引用对象，但 obj1 仍然指向对象所在的那片内存空间。在第三次执行 release 后，对象的引用计数为 0，对象所在的内存空间被销毁，但是 obj1 指针仍然存在，此时调用 retainCount 会报野指针错误。可以通过置 obj1 = nil 解决这个问题。 对 Linux 文件系统比较了解的可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于 retain），当删除一个文件时（相当于 release），系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 四、僵尸对象、野指针、空指针僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用。 野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC_BAD_ACCESS）。 空指针：没有指向任何对象的指针（存储的是 nil、NULL），给空指针发送消息不会报错；空指针的一个经典使用场景就是在开发中获取服务器 API 数据时，转换野指针为空指针，避免发送消息报错。 五、为什么需要引用计数？引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。 举个例子： 对象 A 生成了一个对象 O，需要调用对象 B 的某个方法，并将对象 O 作为参数传递过去。 1[objB doSomething:O]; 在没有引用计数的情况下，一般内存管理的原则是「谁申请谁释放」。 那么对象 A 就需要在对象 B 不再需要 O 的时候，将 O 销毁。但对象 B 可能临时用一下 O，也可能将它设置为自己的一个成员变量，在这种情况下，什么时候销毁就成了一个难题了。 对于以上情况有两种做法： ①、对象 A 在调用完对象 B 的某个方法之后，马上销毁参数 O；然后对象 B 需要将对象 O 复制一份，生成另一个对象 O2，同时自己来管理对象 O2 的生命周期。 这种做法带来更多的内存申请、复制、释放的工作。本来可以复用的对象，因为不方便管理它的生命周期，就简单地把它销毁，又重新构造一份一样的，实在太影响性能。 ②、对象 A 只负责生成 O，之后就由对象 B 负责完成 O 的销毁工作。如果对象 B 只是临时用一下 O，就可以用完后马上销毁；如果对象 B 需要长时间使用 O，就不销毁它。 这种做法看似解决了对象复制的问题，但是它强烈依赖于 A 和 B 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于 O 的生成和释放在不同对象中，使得它的内存管理代码分散在不同对象中，管理起来也很费劲。如果这个时候情况更加复杂一些，例如对象 B 需要再向对象 C 传递参数 O，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方法带来的复杂度更高，更加不可取。 引用计数的出现很好地解决这个问题，在参数 O 的传递过程中，哪些对象需要长时间使用它，就把它的引用计数 +1，使用完就-1。所有对象遵守这个规则，对象的生命周期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 六、ARC 下的内存管理问题问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要手工管理它们的引用计数时，显得一筹莫展。 6.1 循环引用引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁又依赖于对象 A 的销毁，这样就造成了循环引用 Reference Cycle 的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 6.2 主动断开循环引用解决循环引用问题主要有两个办法。第一个办法：明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存，所以这种解决方法并不常用，更常见的办法是使用弱引用的办法。 6.3 使用弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。如下所示： 6.4 弱引用的实现原理弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： ①、在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 ②、大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 ③、早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 6.5 检测循环引用 七、学习文章iOS 内存管理iOS 的内存管理","tags":[]},{"title":"weak","date":"2019-05-23T06:43:21.310Z","path":"2019/05/23/weak/","text":"一、基本用法weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候自动被设置为 nil，大大避免了野指针访问坏内存引起崩溃的情况，另外 weak 还可以用于解决循环引用。 二、原理概括 weak 表其实是一个 hash（哈希）表。 key：所引用对象的地址；value：weak 指针的地址数组（这个地址的值是指向对象的指针的地址）。 weak 的底层实现的原理是什么？ runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表是由单个自旋锁管理的散列表。 为什么 value 是数组？ 因为一个对象可能被多个弱引用指针指向。 三、实现步骤weak 的实现原理可概括三步： ①、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 ②、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 ③、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 四、详细过程1、初始化时：runtime 会调用 objc_initWeak 函数，objc_initWeak 函数会初始化一个新的 weak 指针指向对象的地址。 123NSObject * obj = [[NSObject alloc] init];id __weak obj1 = obj; 当初始化一个 weak 变量时，runtime 会调用 NSObject.mm 中的 objc_initWeak 函数。 这个函数在 Clang 中的声明如下： 1id objc_initWeak(id *object, id value); 而对于 objc_initWeak() 方法的实现如下： 123456789101112id objc_initWeak(id *location, id newObj)&#123; // 查看对象实例是否有效，无效对象直接导致指针释放 if (!newObj) &#123; *location = nil; return nil; &#125; // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt;(location, (objc_object*)newObj);&#125; 这里先判断了其指针指向的类对象是否有效，无效直接释放返回，不再往深层调用函数。否则 object 将被注册为一个指向 value 的 __weak 对象，而这事应该是 objc_storeWeak 函数干的。可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断）。 注意：objc_initWeak 函数有一个前提条件：就是 object 必须是一个没有被注册为 __weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 objc_storeWeak() 的函数声明如下： 1id objc_storeWeak(id *location, id value); objc_storeWeak() 的具体实现如下，请参考 weak弱引用实现的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// HaveOld: true - 变量有值// false - 需要被及时清理，当前值可能为 nil// HaveNew: true - 需要被分配的新值，当前值可能为 nil// false - 不需要分配新值// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停// false - 用 nil 替代存储template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj) &#123; // 该过程用来更新弱引用指针的指向 // 初始化 previouslyInitializedClass 指针 Class previouslyInitializedClass = nil; id oldObj; // 声明两个 SideTable // ①、创建新旧散列 SideTable *oldTable; SideTable *newTable; // 获得新值和旧值的锁存位置（用地址作为唯一标示） // 通过地址来建立索引标志，防止桶重复 // 下面指向的操作会改变旧值retry: if (HaveOld) &#123; // 如果 HaveOld 为 true，更改指针，获得以 oldObj 为索引所存储的值地址 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // 更改新值指针，获得以 newObj 为索引所存储的值地址 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁操作，防止多线程中竞争冲突 SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 避免线程冲突重处理 // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // 防止弱引用间死锁 // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向 if (HaveNew &amp;&amp; newObj) &#123; // 获得新对象的 isa 指针 Class cls = newObj-&gt;getIsa(); // 判断 isa 非空且已经初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; // 解锁 SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 对其 isa 指针进行初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // 如果该类已经完成执行 +initialize 方法是最理想情况 // 如果该类 +initialize 在线程中 // 例如 +initialize 正在调用 storeWeak 方法 // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; // 重新尝试 goto retry; &#125; &#125; // ② 清除旧值 if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // ③ 分配新值 if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // 如果弱引用被释放 weak_register_no_lock 方法返回 nil // 在引用计数表中设置若引用标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // 弱引用位初始化操作 // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用 newObj-&gt;setWeaklyReferenced_nolock(); &#125; // 之前不要设置 location 对象，这里需要更改指针指向 *location = (id)newObj; &#125; else &#123; // 没有新值，则无需更改 &#125; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 撇开源码中各种锁操作，来看看这段代码都做了些什么。 ①、SideTable SideTable 这个结构体，我给它起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable。实例在 NSObject.mm 中声明其数据结构： 12345678struct SideTable &#123; // 保证原子操作的自旋锁 spinlock_t slock; // 引用计数的 hash 表 RefcountMap refcnts; // weak 引用全局 hash 表 weak_table_t weak_table;&#125; slock 是为了防止竞争选择的自旋锁，用来保证线程安全； refcnts 是协助对象的 isa 指针的 extra_rc 共同引用计数的变量，每个对象的引用计数保存在全局的引用计数表中，一个对象地址对应一个引用计数； weak_table 就是接下来要讲的 weak 表，所有的 weak 变量会被加入到全局的 weak 表中，表的 key 是 weak 修饰的变量指向的对象， value 值就是 weak 修饰的变量。这里主要看 weak 全局 hash 表的结构与作用。 ②、weak 表 weak 表是一个弱引用表，实现为一个 weak_table_t 结构体，存储了某个对象相关的所有的弱引用信息。其定义如下（具体定义在 objc-weak.h 中）： 12345678910struct weak_table_t &#123; // 保存了所有指向指定对象的 weak 指针 weak_entry_t * weak_entries; // 存储空间，即 entries 的数目 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;&#125;; 这是一个全局弱引用 hash 表，它的作用就是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。使用不定类型对象的地址的 hash 化后的数值作为 key，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。 weak_entry_t 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下： 12345678910111213141516171819typedef objc_object ** weak_referrer_t;// 存储在弱引用表中的一个内部结构体struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 封装 objc_object 指针，即 weak 修饰的变量指向的对象 union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; // LSB 最低有效元。当标志位为0时，增加引用表指针纬度，当其为0的时候， weak_referrer_t 成员将扩展为静态数组型的 hash table uintptr_t num_refs : PTR_MINUS_1; // 引用数值，这里记录弱引用表中引用有效数字，即里面元素的数量 uintptr_t mask; uintptr_t max_hash_displacement; // hash 元素上限阀值 &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;&#125; 在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题，其内容可以理解为对象的内存地址。 从注释中写 out_of_line 成员为最低有效位，当其为 0 的时候， weak_referrer_t 成员将扩展为一个静态数组型的 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。 那么在有效位未生效的时候，out_of_line、num_refs、mask、max_hash_displacement 有什么作用？以下是笔者自身的猜测： out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。 num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。 mask：计数辅助量。 max_hash_displacement：hash 元素上限阀值。 其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT。 每个对象的 SideTable 中的 weak_table_t 都是全局 weak 表的入口，以引用计数对象为键找到其所记录的 weak 修饰的对象。 weak_entry_t 中的 referrers 有两种形式：当 out_of_line 为 0 的时候，referrers 是一个静态数组型的表，数组大小默认为 WEAK_INLINE_COUNT 大小；当 out_of_line 不为 0 的时候，referrers 是一个动态数组，内容随之增加。 StripedMap[] 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。 ③、旧对象解除注册操作 weak_unregister_no_lock 123456789101112131415161718192021222324252627282930313233void weak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out_of_line &amp;&amp; entry-&gt;num_refs != 0) &#123; empty = false; &#125; else &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i]) &#123; empty = false; break; &#125; &#125; &#125; if (empty) &#123; weak_entry_remove(weak_table, entry); &#125; &#125; // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.&#125; 该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。 来看看这个函数的逻辑： 首先参数是 weak_table_t 表、键和值。声明 weak_entry_t 变量，如果 key，也就是引用计数对象为空，直接返回。根据全局入口表和键获取对应的 weak_entry_t 对象，也就是 weak 表记录。获取到记录后，将记录表以及 weak 对象作为参数传入 remove_referrer 函数中，这个函数就是解除操作。然后判断这个 weak 记录是否为空，如果为空，从全局记录表中清除相应的引用计数对象的 weak 记录表。 从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。 再来了解一下解除对象的函数： 123456789101112131415161718192021222324252627282930313233343536static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer)&#123; if (! entry-&gt;out_of_line) &#123; for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == old_referrer) &#123; entry-&gt;inline_referrers[i] = nil; return; &#125; &#125; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; size_t index = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != old_referrer) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; _objc_inform(\"Attempted to unregister unknown __weak variable \" \"at %p. This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", old_referrer); objc_weak_error(); return; &#125; &#125; entry-&gt;referrers[index] = nil; entry-&gt;num_refs--;&#125; 这个函数传入的是 weak 对象，当 out_of_line 为 0 时，遍历数组，找到对应的对象，置 nil，如果未找到，报错并返回。当 out_of_line 不为 0 时，根据对象的地址 hash 化并和 mask 做与操作作为下标，查找相应的对象，若没有，报错并返回，若有，相应的置为 nil，并减少元素数量，即 num_refs 减 1。 ④、新对象添加注册操作 weak_register_no_lock 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123; deallocating = referent-&gt;rootIsDeallocating(); &#125; else &#123; BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) &#123; return nil; &#125; deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); &#125; if (deallocating) &#123; if (crashIfDeallocating) &#123; _objc_fatal(\"Cannot form weak reference to instance (%p) of \" \"class %s. It is possible that this object was \" \"over-released, or is in the process of deallocation.\", (void*)referent, object_getClassName((id)referent)); &#125; else &#123; return nil; &#125; &#125; // now remember it and where it is being stored weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; append_referrer(entry, referrer); &#125; else &#123; weak_entry_t new_entry; new_entry.referent = referent; new_entry.out_of_line = 0; new_entry.inline_referrers[0] = referrer; for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_entry.inline_referrers[i] = nil; &#125; weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); &#125; // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;&#125; 这一步与上一步相反，通过 weak_register_no_lock 函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。 一大堆 if-else 主要是为了判断该对象是不是 taggedPoint 以及是否正在调用 dealloc 等。下面操作开始，同样是先获取 weak 表记录，如果获取到，则调用 append_referrer 插入对象，若没有，则新建一个 weak 表记录，默认为 out_of_line，然后将新对象放到 0 下标位置，其他位置置为 nil 。下面两个函数 weak_grow_maybe 是用来判断是否需要重申请内存重 hash，weak_entry_insert 函数是用来将新建的 weak 表记录插入到全局 weak 表中。插入时同样是以对象地址的 hash 化和 mask 值相与作为下标来记录的。 接下来看看 append_referrer 函数，源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)&#123; if (! entry-&gt;out_of_line) &#123; // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; // Couldn't insert inline. Allocate out of line. weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = 1; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; &#125; assert(entry-&gt;out_of_line); if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer); &#125; size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; &#125; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement; &#125; weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;&#125; ⑤、初始化弱引用对象流程一览 弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图： 这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然，storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？当释放对象时，其基本流程如下： ①、调用 objc_release②、因为对象的引用计数为 0，所以执行 dealloc③、在 dealloc 中，调用了_objc_rootDealloc 函数④、在 _objc_rootDealloc 中，调用了 object_dispose 函数⑤、调用 objc_destructInstance⑥、最后调用 objc_clear_deallocating，详细过程如下： a. 从 weak 表中获取废弃对象的地址为键值的记录 b. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nil c. 将 weak 表中该记录删除 d. 从引用计数表中删除废弃对象的地址为键值的记录 重点看对象被释放时调用的 objc_clear_deallocating 函数。该函数实现如下： 123456789void objc_clear_deallocating(id obj) &#123; assert(obj); assert(!UseGC); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating();&#125; 这个函数只是做一些判断以及更深层次的函数调用。 123456789101112131415161718void objc_object::sidetable_clearDeallocating()&#123; SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); // 迭代器 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) &#123; if (it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED) &#123; weak_clear_no_lock(&amp;table.weak_table, (id)this); &#125; table.refcnts.erase(it); &#125; table.unlock();&#125; 也就是调用了 clearDeallocating()，继续追踪可以发现，它最终是使用了迭代器来取 weak 表的 value，然后调用 weak_clear_no_lock，然后查找对应的 value，将该 weak 指针置空，weak_clear_no_lock 函数的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id)&#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; 简单来说，这个方法首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组，把每个地址存储的数据设为 nil ，最后把这个 key-value entry 从 weak 表中删除。 注意： ①、从实现中可以看出，weak 指针的使用涉及到 hash 表的增删改查，存在一定的性能开销。②、使用 weak 指针的时候，应首先获取一个 Strong 指针再使用。倒不是为了防止在使用过程中对象被回收，形成野指针。这个不用担心，因为你使用了 weak 指针，对象就会被加入到 autoreleasepool 中，可以放心使用。但是要注意的是，如果在一个代码块中频繁使用 weak 指针，还是应首先获取一个 Strong 指针，否则这个对象会被一次又一次的加入 autoreleasepool 中，也存在一定的性能开销。 五、拓展补充weak、__unsafe_unretained、unowned 与 assign 区别 __unsafe_unretained：不会对对象进行 retain，当对象销毁时，会依然指向之前的内存空间（野指针） weak：不会对对象进行 retain，当对象销毁时，会自动置为 nil __unsafe_unretained 可以修饰代表基础数据类型的 property，weak 不能修饰基础数据类型的 property。 使用 weak 是有代价的，因为通过上面的原理可知，__weak 需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况，因此 __unsafe_unretained 比 __weak 快。所以当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，__unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。 unowned 使用在 Swift 中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。 假如很明确的知道对象的生命期，也可以选择 unowned。 assign：实质与 __unsafe_unretained 等同 通过上面的描述，我们基本能了解一个 weak 引用从生到死的过程。从这个流程可以看出，一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 __weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 __weak 修饰符。 六、学习文章 weak 弱引用的实现方式iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）iOS weak 的底层实现weak 的生命周期：具体实现方法iOS 中 weak 的实现","tags":[]},{"title":"深拷贝和浅拷贝","date":"2019-05-22T10:52:52.721Z","path":"2019/05/22/深拷贝和浅拷贝/","text":"深拷贝和浅拷贝的本质区别是地址是否相同。 浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址； 深拷贝是真正的复制了一份，复制的对象指向了新的地址。 一、非容器类对象对象的 copy 是浅拷贝，mutableCopy 是深拷贝。 1、不可变 12345678910NSString * s1 = @\"AAA\";NSString * s2 = [s1 copy];NSString * s3 = [s1 mutableCopy]; NSLog(@\"%p %@\", s1, s1.class);NSLog(@\"%p %@\", s2, s2.class);NSLog(@\"%p %@\", s3, s3.class);0x1083a40e8 __NSCFConstantString0x1083a40e8 __NSCFConstantString0x60400044f840 __NSCFString 结论： ①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 2、可变 12345678910NSMutableString * ms1 = [NSMutableString stringWithString:@\"1\"];NSMutableString * ms2 = [ms1 copy];NSString * ms3 = [ms1 mutableCopy]; NSLog(@\"%p %@\", ms1, ms1.class);NSLog(@\"%p %@\", ms2, ms2.class);NSLog(@\"%p %@\", ms3, ms3.class);0x6040004500b0 __NSCFString0xa000000000000311 NSTaggedPointerString0x60400044fc60 __NSCFString 结论： ①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝； ②、copy 和 mutableCopy 返回对象都为可变对象。 二、容器对象1、不可变 123456789101112NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSArray * arr1 = [NSArray arrayWithObjects:ms, @\"2\", nil];NSArray * arr2 = [arr1 copy];NSArray * arr3 = [arr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]); 0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025a940 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 ③、容器内的元素始终都是浅拷贝。 2、可变 1234567891011NSMutableString * ms = [NSMutableString stringWithString:@\"1\"];NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:ms, @\"2\", nil];NSMutableArray * mArr2 = [mArr1 copy];NSMutableArray * mArr3 = [mArr1 mutableCopy]; NSLog(@\"%p %@ %p %@ %p %@\", mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);NSLog(@\"%p %@ %p %@ %p %@\", mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]);0x60000025aeb0 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x600000037640 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString0x60000025ae80 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；②、copy 返回不可变对象，mutableCopy 返回可变对象；③、容器内的元素始终是浅拷贝。 三、自定义类对象的深浅拷贝自定义的类需要遵循 才支持 copy，遵循 支持 mutableCopy。 12345678910111213141516171819202122@interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@end@implementation Person- (instancetype)copyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone]; // return self;&#125;- (instancetype)mutableCopyWithZone:(NSZone *)zone&#123; return [Person allocWithZone:zone];&#125;@endPerson * p1 = [[Person alloc] init];Person * p2 = [p1 copy];Person * p3 = [p1 mutableCopy]; NSLog(@\"%p %@\", p1, p1.class);NSLog(@\"%p %@\", p2, p2.class);NSLog(@\"%p %@\", p3, p3.class);0x600000011e30 Person0x600000011f70 Person0x600000011f90 Person 四、实现容器对象的完全拷贝1234567891011NSMutableString * ms = [NSMutableString stringWithFormat:@\"1\"];NSArray * arr = [NSArray arrayWithObjects:ms, @\"2\", nil];NSLog(@\"%p %p\", arr[0], arr[1]);NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];NSLog(@\"%p %p\", mArr[0], mArr[1]);NSData * data = [NSKeyedArchiver archivedDataWithRootObject:mArr];NSMutableArray * newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];NSLog(@\"%p %p\", newMutableArr[0], newMutableArr[1]);0x6040004434b0 0x109c931000xa000000000000311 0x109c931000xa000000000000311 0xa000000000000321 由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。 自定义类对象需要遵循 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。 123456789- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self.xxx = [aDecoder decodeObjectForKey:@\"key\"]; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.xxx forKey:@\"key\"];&#125; 五、总结只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。 六、学习文章深刻理解iOS中的“深拷贝”和“浅拷贝”","tags":[]},{"title":"String","date":"2019-05-22T10:48:05.651Z","path":"2019/05/22/String/","text":"一、字符串常量123456789101112131415161718@property (nonatomic, copy) NSString * string1;@property (nonatomic, weak) NSString * string2;&#123; NSString * temp = @\"AAAA\"; self.s1 = temp; NSLog(@\"temp -&gt; %p\", temp); self.s2 = self.s1; self.s1 = nil; NSLog(@\"s1 = %@，s2 = %@\", self.s1, self.s2); NSLog(@\"s1 -&gt; %p，s2 -&gt; %p\", self.s1, self.s2); NSLog(@\"retainCount = %@\", [temp valueForKey:@\"retainCount\"]);&#125;temp -&gt; 0x108551118s1 = (null)，s2 = AAAAs1 -&gt; 0x0，s2 -&gt; 0x108551118retainCount = 18446744073709551615 解释 1 temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。 即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。 另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子： 1NSString ** s2 = s1; // 需要关闭 arc 才能使用二级指针 这样 s1 = nil 后 s2 也是 nil 了。 解释 2 @”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。 self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。 字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。 致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。 12345678910&#123; NSString * temp1 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp2 = [[NSString alloc] initWithFormat:@\"%@\", @\"AAAAAAA\"]; NSString * temp3 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSString * temp4 = [[NSString alloc] initWithFormat:@\"%@\", @\"BBBBBBBBBBBB\"]; NSLog(@\"%p %p\", temp1, temp2); NSLog(@\"%p %p\", temp3, temp4);&#125;0xa414141414141417 0xa4141414141414170x60000022a3a0 0x60000022a260 通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区： 如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。 二、Copy 和 strong@interface ViewController () @property (nonatomic, strong) NSString * sString; @property (nonatomic, copy) NSString * cString; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSMutableString * mString = [NSMutableString string]; [mString appendFormat:@&quot;AA&quot;]; self.sString = mString; self.cString = mString; NSLog(@&quot;mString -&gt; %p, sString -&gt; %p, cString -&gt; %p&quot;, mString, _sString, _cString); // mString -&gt; 0x600002565b30, sString -&gt; 0x600002565b30, cString -&gt; 0xcac34ab7cb397e8b NSLog(@&quot;%@&quot;, self.sString); // AA NSLog(@&quot;%@&quot;, self.cString); // AA [mString appendFormat:@&quot;BB&quot;]; NSLog(@&quot;%@&quot;, self.sString); // AABB NSLog(@&quot;%@&quot;, self.cString); // AA } @end 结果分析: 使用 strong 修饰 NSString 类型属性，指针指向可变字符串对象的地址，当可变字符串内容发生变化时，self.sStrong 相对应的也发生变化；使用 copy 修饰，会将可变字符串重新拷贝一份，重新开辟内存空间，修改 mutableString 的值不会对 self.cString 造成影响。","tags":[]},{"title":"atomic","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/atomic/","text":"参考文章：http://blog.csdn.net/kangguang/article/details/79194563 atomic 在 set 方法里加了锁，防止了多线程一直去写这个 property，造成难以预计的数值。 当属性使用 atomic 修饰时，它的读和写是原子性的：当线程 A 进行写操作，这时其他线程的读或者写操作会因为该操作而等待。当 A 线程的写操作结束后，B 线程进行写操作，然后当 A 线程需要读操作时，获得了在 B 线程中修改的值。如果有 C 线程在 A 线程读操作之前 release了该属性，可能导致程序崩溃。 导致崩溃并不是线程安全问题。所谓线程安全是保证同一时间只有一个线程对该内存进行访问。只要我们使用 getter、setter 方法来访问，上面的表述中的每一个步骤都只有一条线程在访问该内存，哪个线程会获得锁完全取决于代码顺序，这个崩溃就是程序员自身的问题了。如果绕开 getter、setter 方法访问这个属性，才会造成线程不安全，比如使用 KVC。 一、atomic 是绝对安全的在 64 位的操作系统下，所有类型的指针(包括 void *)都是占用 8 个字节的。超过 4 个字节的基本类型数据都会有线程并发的问题。 那所有的指针类型都会有这个问题。 以 Objective-C 的 NSArray * 为例子，如果一个多线程操作这个数据，会有两个层级的并发问题： ①、指针本身 ②、指针所指向的内存 指针本身也是占用内存的，并且一定是 8 个字节。第二部分，指针所指向的内存，有可能非常大，有可能也就 1 个字节。 所以考虑 NSArray * array 这个数据在进行多线程操作的时候，必须分成两部分来描述，一个是 &amp;array 这个指针本身，另一个则是它所指向的内存 array。想象现在有两块内存，一块是 8 字节，一块 n 字节，8 字节里面放的值，就是 n 字节内存的首地址。 如果用 atomic 修饰之后，会有什么影响？ 从内存的角度来解释这个过程。atomic 其实修饰的是这个指针 &amp;array，与指针指向的第二部分 n 字节数据没有任何关系，被atomic 修饰之后，你不可能随意去多线程操作这个 8 字节，但是对 8 字节里面所指向的 n 字节没有任何限制！ atomic 已经完美的履行了它的指责，你不可能对这个 8 字节进行无序的多线程操作，这就够了呀！有问题的是程序员，程序员并未对 n 字节做任何的限制。 二、NSMutableArray 本身是线程不安全的简单来说，线程安全就是多个线程访问同一段代码，程序不会异常、不 Crash。而编写线程安全的代码主要依靠线程同步。 1、不使用 atomic 修饰属性。原因有二： ①、atomic 的内存管理语义是原子性的，仅保证了属性的 setter 和 getter 方法是原子性的、线程安全的，但是属性的其他方法，如数组添加/移除元素等并不是原子操作，所以不能保证属性是线程安全的。 ②、atomic 虽然保证了 getter、setter 方法线程安全，但是付出的代价很大，执行效率要比 nonatomic 慢很多倍(有说法是慢 10-20 倍)。 总之：使用 nonatomic 修饰 NSMutableArray 对象就可以了，而使用锁、dispatch_queue 来保证 NSMutableArray 对象的线程安全。 2、打造线程安全的 NSMutableArray 在《Effective Objective-C 2.0..》书中第 41 条：多用派发队列，少用同步锁中指出：使用“串行同步队列”(serial synchronization queue)，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。而通过并发队列，结合GCD 的栅栏块(barrier)来不仅实现数据同步线程安全，还比串行同步队列方式更高效。 GCD 的栅栏块作用示意图 说明：栅栏块单独执行，不能与其他块并行。直到当前所有并发块都执行完毕，才会单独执行这个栅栏块 线程安全实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@interface QSThreadSafeMutableArray()@property (nonatomic, strong) NSMutableArray * MDataArray;@property (nonatomic, strong) dispatch_queue_t MSyncQueue;@end@implementation QSThreadSafeMutableArray- (instancetype)initCommon&#123; if (self = [super init]) &#123; // %p 以 16 进制的形式输出内存地址，附加前缀 0x NSString * uuid = [NSString stringWithFormat:@\"com.jzp.array_%p\", self]; // 注意：_MSyncQueue 是并行队列 _MSyncQueue = dispatch_queue_create([uuid UTF8String], DISPATCH_QUEUE_CONCURRENT); &#125; return self;&#125;- (instancetype)init&#123; if (self = [self initCommon]) &#123; _MDataArray = [NSMutableArray array]; &#125; return self;&#125;- (id)objectAtIndex:(NSUInteger)index&#123; __block id obj; dispatch_sync(_MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; obj = _MDataArray[index]; &#125; &#125;); return obj;&#125;- (NSEnumerator *)objectEnumerator&#123; __block NSEnumerator * enu; dispatch_sync( _MSyncQueue, ^&#123; enu = [_MDataArray objectEnumerator]; &#125;); return enu;&#125;- (void)insertObject:(id)anObject atIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray insertObject:anObject atIndex:index]; &#125; &#125;);&#125;- (void)addObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if(anObject)&#123; [_MDataArray addObject:anObject]; &#125; &#125;);&#125;- (void)removeObjectAtIndex:(NSUInteger)index&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (index &lt; [_MDataArray count]) &#123; [_MDataArray removeObjectAtIndex:index]; &#125; &#125;);&#125;- (void)removeLastObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; [_MDataArray removeLastObject]; &#125;);&#125;- (void)replaceObjectAtIndex:(NSUInteger)index withObject:(id)anObject&#123; dispatch_barrier_async( _MSyncQueue, ^&#123; if (anObject &amp;&amp; index &lt; [_MDataArray count]) &#123; [_MDataArray replaceObjectAtIndex:index withObject:anObject]; &#125; &#125;);&#125;- (NSUInteger)indexOfObject:(id)anObject&#123; __block NSUInteger index = NSNotFound; dispatch_sync( _MSyncQueue, ^&#123; for (int i = 0; i &lt; [_MDataArray count]; i ++) &#123; if ([_MDataArray objectAtIndex:i] == anObject) &#123; index = i; break; &#125; &#125; &#125;); return index;&#125;- (void)dealloc&#123; if (_MSyncQueue) &#123; _MSyncQueue = NULL; &#125;&#125;@end 说明 ①：使用 dispatch queue 实现线程同步；将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，又不会阻塞执行异步派发的线程；使用同步队列及栅栏块，可以令同步行为更加高效。 说明 ②：NSMutableDictionary 本身也是线程不安全的，实现线程安全的 NSMutableDictionary 原理同线程安全的NSMutableArray。(代码见 QSUseCollectionDemo) 3、线程安全的 NSMutableArray 使用 123456789101112131415161718192021- (void)testQsMutableArray&#123; _MSafeArray = [[QSThreadSafeMutableArray alloc] init]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); for (NSInteger i = 0; i &lt; 10; i++) &#123; dispatch_async(queue, ^&#123; NSString * str = [NSString stringWithFormat:@\"数组%d\", (int)i+1]; [_MSafeArray addObject:str]; &#125;); &#125; sleep(1); NSEnumerator * enu = [_MSafeArray objectEnumerator]; for (NSObject * object in enu) &#123; NSLog(@\"value: %@\", object); &#125;&#125; 三、atomic 与 nonatomic 的区别在默认情况下，由编译器生成的属性的 set、get 方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不需要同步锁。 尽管没有指明 atomic 的特质（如果某属性不具备 nonatomic 特质，那它就是”原子的”(atomic)），仍然可以在属性特质中写明这一点，编译器是不会报错的。 一般 iOS 程序中，所有属性都声明为 nonatomic。这样做的原因是： ①、在 iOS 中使用同步锁的开销比较大， 会带来性能问题。 ②、一般情况下并不要求属性必须是”原子的”，因为这并不能保证线程安全。若要实现线程安全的操作，还需采用更为深层的锁的机制。 一个线程在连续多次读取某个属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic 也还是会读取到不同的属性值。 因此，iOS 程序一般都会使用 nonatomic 属性。但在 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。 nonatomic 的实现： 12345678910111213- (void)setImage:(UIImage *)image&#123; if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125;&#125;- (UIImage *)image&#123; return _image;&#125; atomic 的实现： 123456789101112131415161718- (void)setImage:(UIImage *)image&#123; @synchronized(self) &#123; // 锁 if (_image != image) &#123; [_image release]; _image = [image retain]; ... &#125; &#125;&#125;- (UIImage *)image&#123; @synchronized(self) &#123; return _image; &#125;&#125; @synchronized 的介绍： The @synchronized directive is a convenient way to create mutex locks on the fly in Objective-C code. The @synchronized directive does what any other mutex lock would do—it prevents different threads from acquiring the same lock at the same time. In this case, however, you do not have to create the mutex or lock object directly. Instead, you simply use any Objective-C object as a lock token, as shown in the following example: - (void)myMethod:(id)anObj{ @synchronized(anObj) { // Everything between the braces is protected by the @synchronized directive. } } The object passed to the @synchronized directive is a unique identifier used to distinguish the protected block. If you execute the preceding method in two different threads, passing a different object for the anObj parameter on each thread, each would take its lock and continue processing without being blocked by the other. If you pass the same object in both cases, however, one of the threads would acquire the lock first and the other would block until the first thread completed the critical section. As a precautionary measure, the @synchronized block implicitly adds an exception handler to the protected code. This handler automatically releases the mutex in the event that an exception is thrown. This means that in order to use the @synchronized directive, you must also enable Objective-C exception handling in your code. If you do not want the additional overhead caused by the implicit exception handler, you should consider using the lock classes. For more information about the @synchronized directive, see The Objective-C Programming Language. 更准确的说应该是读写安全，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。","tags":[]},{"title":"malloc","date":"2019-05-22T09:54:44.720Z","path":"2019/05/22/malloc/","text":"原文：iOS内存管理和malloc源码解读 在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。 与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？ 和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。 如上所述，iOS 在外存没有交换区，没有内存页换出的过程。 一、malloc 基本原理在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。 创建新对象 [NSObject alloc]; 释放对象 [Object release]; 而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。 从苹果公开的 malloc 源码上来看，它的原理大致如下： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone。在 64 位环境下，会初始化 default zone 为 nano zone，同时初始化一个 scalable zone 作为 helper zone。nano zone 负责 nano 大小的分配，scalable zone 则负责 tiny、small 和 large内存的分配。 每次 malloc 时，根据传入的 size 参数，优先交给 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。 二、nano malloc在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为Magazine、Band 和 Slot 几个级别。 Magazine 范围对应于 CPU，CPU0 对应 Mag0，CPU1 对应 Mag1，依次类推 Band 范围为 2M，连续内存分配当内存不够时以 Band 为单位向内核请求 Slot 则对应于每个 Band 中 128K 大小的范围，每个 Band 都分为 16 个 Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配 分配过程： 确定当前 cpu 对应的 mag 和通过 size 参数计算出来的 slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 Band 中当前 Slot 耗尽则向系统申请新的 Band(每个 Band 固定大小 2M，容纳了 16 个 128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是 16 个)的二维数组形式，放在 nanozone_t 的 meta_data 字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。 除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data上挂着的空闲链表上内存区块回收来完成。 三、scalable zone 上内存分配简要分析对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。 在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为-1 的 magazine 作为后备之用。 下面是一个简图。 分配时(以 tiny 的情况为例)： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。这里需要注意的是，在一般情况下 free list 分为 64 个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63 为所有更大的内存区块挂载的地方。 上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。 如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 要是再不行就没招了，系统也给不到内存，就报错返回。 free 时： 检查指针指向地址是否有问题。 如果 last free 指针上没有挂载内存区块，则放到 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上(在挂载的 free list 前，会先根据 region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。 合并后所在的 region 如果空闲字节超过一定条件，则将把此 region 放到后备的 magazine 中(-1)。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。","tags":[]},{"title":"iOS 证书","date":"2019-05-22T08:51:44.499Z","path":"2019/05/22/iOS 证书/","text":"一、引言 什么是 App ID？Explicit/Wildcard App ID 有何区别？什么是 App Group ID？ 什么是证书（Certificate）？如何申请？有啥用？ 什么是Key Pair（公钥/私钥）？有啥用？与证书有何关联？ 什么是签名（Signature）？如何签名（CodeSign）？怎样校验（Verify）？ 什么是（Team）Provisioning Profiles？有啥用？ Xcode如何配置才能使用iOS真机进行开发调试？ 多台机器如何共享开发者账号或证书？ 遇到证书配置问题怎么办？ Xcode 7免证书调试真机调试 二、App ID（bundle identifier） App ID 即 Product ID，用于标识一个或者一组 App。 App ID应该和Xcode中的Bundle Identifier是一致（Explicit）的或匹配（Wildcard）的。 App ID字符串通常以反域名（reverse-domain-name）格式的Company Identifier（Company ID）作为前缀（Prefix/Seed），一般不超过 255 个 ASCII 字符。 App ID全名会被追加Application Identifier Prefix（一般为TeamID.），分为两类： Explicit App ID：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为“com.apple.garageband”的App。 Wildcard App ID：含有通配符的App ID，用于标识一组应用程序。例如“*”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.*”可以表示Bundle Identifier以“com.apple.”开头的所有应用程序。 用户可在Developer MemberCenter网站上注册或删除已注册的App IDs。 App ID 被配置到【Target-&gt;Info-&gt;Bundle Identifier】下；对于 Wildcard App ID，只要 bundle identifier 包含其作为 Prefix/Seed 即可。 三、设备（Device） Device 就是运行 iOS 系统用于开发调试 App 的设备。每台Apple设备使用 UDID 来唯一标识。 iOS设备连接Mac后，可通过 iTunes-&gt;Summary 或者 Xcode-&gt;Window-&gt;Devices 获取 iPhone 的 UDID。 Apple Member Center 网站个人账号下的 Devices 中包含了注册过的所有可用于开发和测试的设备，普通个人开发账号每年累计最多只能注册 100 个设备。 Apps signed by you or your team run only on designated development devices. Apps run only on the test devices you specify. 用户可在网站上注册或启用/禁用（Enable/Disable）已注册的 Device。本文的 Devices 是指连接到 Xcode 被授权用于开发测试的 iOS 设备（iPhone/iPad）。 四、开发证书（Certificates）4.1 证书 证书是由公证处或认证机关开具的证明资格或权力的证件，它是表明（或帮助断定）事理的一个凭证。证件或凭证的尾部通常会烙印公章。 每个中国人一生可能需要 70 多个证件，含 15 种身份证明。 4.2 数字证书 数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在 Internet 上验证通信实体身份的方式，其作用类似于司机的驾驶执照或日常生活中的身份证。 它是由一个由权威机构——CA机构，又称为证书授权中心（Certificate Authority）发行的，人们可以在网上用它来识别对方的身份。 数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。 数字证书还有一个重要的特征就是时效性：只在特定的时间段内有效。 数字证书中的公开密钥（公钥）相当于公章。 某一认证领域内的根证书是CA认证中心给自己颁发的证书，是信任链的起始点。安装根证书意味着对这个CA认证中心的信任。 为了防止 GFW 进行中间人攻击(MitM)，例如篡改 github 证书，导致无法访问 github 网站等问题，可选择不信任根证书。 在【钥匙串】中输入 ROOT 进行搜索，可以找到很多根证书，在【简介】|【使用此证书时】下拉选择【永不信任】。 4.3 iOS（开发）证书 iOS 证书是用来证明 iOS App 内容（executable code）的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序（App），只有经过签名验证（Signature Validated）才能确保来源可信，并且保证 App 内容是完整、未经篡改的。 iOS证书分为两类：Development 和 Production（Distribution）。 Development 证书用来开发和调试应用程序：A development certificate identifies you, as a team member, in a development provisioning profile that allows apps signed by you to launch on devices. Production 主要用来分发应用程序（根据证书种类有不同作用）：A distribution certificate identifies your team or organization in a distribution provisioning profile and allows you to submit your app to the store. Only a team agent or an admin can create a distribution certificate. 普通个人开发账号最多可注册 iOS Development/Distribution 证书各 2 个，用户可在网站上删除（Revoke）已注册的Certificate。 下文主要针对 iOS App 开发调试过程中的开发证书（Certificate for Development）。 4.4 iOS（开发）证书的根证书那么，iOS 开发证书是谁颁发的呢？或者说我们是从哪个 CA 申请到用于 Xcode 开发调试 App 的证书呢？ iOS 以及 Mac OS X 系统（在安装 Xcode 时）将自动安装 AppleWWDRCA.cer 这个中间证书（Intermediate Certificates），它实际上就是 iOS（开发）证书的证书，即根证书（Apple Root Certificate）。 AppleWWDRCA（Apple Root CA）类似注册管理户籍的公安机关户政管理机构，AppleWWDRCA.cer 之于 iOS（开发）证书则好比户籍证之于身份证。 如果 Mac Keychain Access 证书助理在申请证书时尚未安装过该证书，请先下载安装（Signing requires that you have both the signing identity and the intermediate certificate installed in your keychain）。 4.5 申请证书（CSR：Certificate Signing Request）可以在缺少证书时通过 Xcode Fix Issue 自动请求证书，这里通过 Keychain 证书助理从证书颁发机构请求证书：填写开发账号邮件和常用名称，勾选【存储到磁盘】。 keychain 将生成一个包含开发者身份信息的 CSR（Certificate Signing Request）文件；同时，Keychain Access|Keys 中将新增一对 Public/Private Key Pair（This signing identity consists of a public-private key pair that Apple issues）。 private key始终保存在 Mac OS 的 Keychain Access 中，用于签名（CodeSign）对外发布的 App；public key一般随证书（Provisioning Profile）散布出去，对 App 签名进行校验认证。用户必须保护好本地 Keychain 中的 private key，以防伪冒。 Keep a secure backup of your public-private key pair. If the private key is lost, you’ll have to create an entirely new identity to sign code. Worse, if someone else has your private key, that person may be able to impersonate you. 在 Apple 开发网站上传该 CSR 文件来添加证书（Upload CSR file to generate your certificate）： Apple 证书颁发机构 WWDRCA(Apple Worldwide Developer Relations Certification Authority) 将使用private key 对 CSR 中的 public key 和一些身份信息进行加密签名生成数字证书（ios_development.cer）并记录在案（Apple Member Center）。 从 Apple Member Center 网站下载证书到 Mac 上双击即可安装（当然也可在 Xcode 中添加开发账号自动同步证书和【生成】配置文件）。证书安装成功后，在 KeychainAccess|Keys 中展开创建 CSR 时生成的 Key Pair 中的私钥前面的箭头，可以查看到包含其对应公钥的证书（Your requested certificate will be the public half of the key pair.）；在 Keychain Access|Certificates 中展开安装的证书（ios_development.cer）前面的箭头，可以看到其对应的私钥。 Certificate 被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Identity】下，下拉选择 Identities from Profile。 五、供应配置文件（Provisioning Profiles）5.1 Provisioning Profile的概念 Provisioning Profile文件包含了上述的所有内容：证书、App ID 和设备。 一个 Provisioning Profile 对应一个 Explicit App ID 或 Wildcard App ID（一组相同Prefix/Seed的App IDs）。 在网站上手动创建一个Provisioning Profile时，需要依次指定 App ID（单选）、证书（Certificates，可多选）和设备（Devices，可多选）。用户可在网站上删除（Delete）已注册的 Provisioning Profiles。 Provisioning Profile 决定 Xcode 用哪个证书（公钥）/私钥组合（Key Pair/Signing Identity）来签署应用程序（Signing Product），将在应用程序打包时嵌入到 .ipa 包里。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备也通过它来认证安装的程序。 如果要打包或者在真机上运行一个APP，一般要经历以下三步： 首先，需要指明它的 App ID，并且验证 Bundle ID 是否与其一致； 其次，需要证书对应的私钥来进行签名，用于标识这个 APP 是合法、安全、完整的； 然后，如果是真机调试，需要确认这台设备是否授权运行该 APP。 Provisioning Profile 把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。 Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate 一样。Distribution版本的ProvisioningProfile主要用于提交App Store审核，其中不指定开发测试的Devices（0，unlimited），App ID 为 Wildcard App ID（*）。App Store审核通过上架后，允许所有iOS设备（Deployment Target）上安装运行该App。 Xcode将全部供应配置文件（包括用户手动下载安装的和Xcode自动创建的Team Provisioning Profile）放在目录 ~/Library/MobileDevice/Provisioning Profiles 下。 5.2 Provisioning Profile的构成以下为典型供应配置文件 *.mobileprovision 的 构成简析： （1）Name：该mobileprovision的文件名。（2）UUID：该mobileprovision文件的真实文件名。（3）TeamName：Apple ID账号名。（4）TeamIdentifier：Team Identity。（5）AppIDName：explicit/wildcard App ID name（ApplicationIdentifierPrefix）。（6）ApplicationIdentifierPrefix：完整 App ID 的前缀（TeamIdentifier.*）。（7）DeveloperCertificates：包含了可以为使用该配置文件应用签名的所有证书。 证书是基于 Base64 编码，符合 PEM（PrivacyEnhanced Mail, RFC 1848）格式的，可使用OpenSSL来处理（opensslx509 -text -in file.pem）。 从 DeveloperCertificates 提取之间的内容到文件cert.cer（cert.perm）： —–BEGIN CERTIFICATE—– 将之间的内容拷贝至此 —–END CERTIFICATE—– Mac下右键QuickLook查看cert.cer（cert.perm），在Keychain Access中右键Get Info查看对应证书ios_development.cer，正常情况（公私钥 KeyPair 配对）应吻合；Windows 下没有足够信息（WWDRCA.cer），无法验证该证书。 如果你用了一个不在这个列表中的证书进行签名，无论这个证书是否有效，这个应用都将CodeSign Fail。 （8）Entitlements键对应的： keychain-access-groups：$(AppIdentifierPrefix)，参见Code Signing Entitlements(*.entitlements)。 每个应用程序都有一个可以用于安全保存一些如密码、认证等信息的 keychain，一般而言自己的程序只能访问自己的keychain。通过对应用签名时的一些设置，还可以利用keychain的方式实现同一开发者签证（就是相同bundle seed）下的不同应用之间共享信息的操作。比如你有一个开发者帐户，并开发了两个不同的应用A和B，然后通过对A和B的keychain access group这个东西指定共用的访问分组，就可以实现共享此keychain中的内容。 application-identifier：带前缀的全名，例如$(AppIdentifierPrefix)com.apple.garageband。 com.apple.security.application-groups：App Group ID（group. com.apple），参见Code Signing Entitlements(*.entitlements)。 com.apple.developer.team-identifier：同Team Identifier。 （9）ProvisionedDevices：该mobileprovision授权的开发设备的UDID 。 Provisioning Profile 被配置到【XcodeTarget-&gt;Build Settings-&gt;Code Signing-&gt;Provisioning Profile】下，然后在Code Signing Identity下拉可选择Identities from Profile “…”（即Provisioning Profile中包含的Certificates）。 六、开发组供应配置文件（Team Provisioning Profiles）6.1 Team Provisioning Profile的概念每个Apple开发者账号都对应一个唯一的 Team ID， Xcode3.2.3 预发布版本中加入了Team Provisioning Profile这项新功能。 在Xcode中添加Apple Developer Account时，它将与Apple Member Center后台勾兑自动生成iOS Team Provisioning Profile（Managed by Xcode）。 Team Provisioning Profile包含一个为Xcode iOS Wildcard App ID(*)生成的iOS Team Provisioning Profile:*（匹配所有应用程序），账户里所有的Development Certificates和Devices都可以使用它在这个team注册的所有设备上调试所有的应用程序（不管bundle identifier是什么）。同时，它还会为开发者自己创建的Wildcard/Explicit App IDs创建对应的iOS Team Provisioning Profile。 6.2 Team Provisioning Profile生成/更新时机 Add an Apple ID account to Xcode Fix issue “No Provisioning Profiles with a valid signing identity” in Xcode Assign Your App to a Team in Xcode project settings of General|Identity Register new device on the apple development website or Xcode detected new device connected 利用Xcode生成和管理的iOS Team Provisioning Profile来进行开发非常方便，可以不需要上网站手动生成下载Provisioning Profile。 Team Provisioning Profile同Provisioning Profile，只不过是由Xcode自动生成的，也被配置到【XcodeTarget|Build Settings|Code Signing|Provisioning Profile】下。 七、App Group（ID）7.1 App Group的概念WWDC14除了发布了OS X v10.10和 Swift 外，iOS 8.0也开始变得更加开放了。说到开放，当然要数应用扩展（App Extension）了。顾名思义，应用扩展允许开发者扩展应用的自定义功能和内容，能够让用户在使用其他应用程序时使用该项功能，从而实现各个应用程序间的功能和资源共享。可以将扩展理解为一个轻量级（nimble and lightweight）的分身。 扩展和其Containing App各自拥有自己的沙盒，虽然扩展以插件形式内嵌在Containing App中，但是它们是独立的二进制包，不可以互访彼此的沙盒。为了实现Containing App与扩展的数据共享，苹果在iOS 8中引入了一个新的概念——App Group，它主要用于同一Group下的APP实现数据共享，具体来说是通过以App Group ID标识的共享资源区——App Group Container。 App Group ID同App ID一样，一般不超过255个ASCII字符。用户可在网站上编辑Explicit App IDs的App Group Assignment；可以删除（Delete）已注册的AppGroup （ID）。 7.2 App Group的配置Containing App与Extension的Explicit App ID必须Assign到同一App Group下才能实现数据共享，并且Containing App与Extension的App ID命名必须符合规范： 置于同一App Group下的App IDs必须是唯一的（Explicit，not Wildcard） Extension App ID以Containing App ID为Prefix/Seed 假如Garageband这个App ID为“com.apple.garageband”，则支持从语音备忘录导入到Garageband应用的插件的App ID可能形如“com.apple.garageband.extImportRecording”。 关于Provisioning Profile，可以使用自己手动生成的，也可以使用Xcode自动生成的Team Provisioning Profile。 App Group会被配置到【Xcode Target-&gt;Build Settings-&gt;Code Signing-&gt;Code Signing Entitlements】文件（*.entitlements）的键com.apple.security.application-groups下，不影响Provisioning Profile生成流程。 八、证书与签名（Certificate&amp; Signature）8.1 Code Signing Identity Xcode中配置的Code Signing Identity（entitlements、certificate）必须与Provisioning Profile匹配，并且配置的Certificate必须在本机Keychain Access中存在对应Public／Private Key Pair，否则编译会报错。 Xcode所在的Mac设备（系统）使用CA证书（WWDRCA.cer）来判断Code Signing Identity中Certificate的合法性： 若用WWDRCA公钥能成功解密出证书并得到公钥（Public Key）和内容摘要（Signature），证明此证书确乃AppleWWDRCA发布，即证书来源可信； 再对证书本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此证书未被篡改过，即证书完整。 8.2 Code Signing每个证书（其实是公钥）对应Key Pair中的私钥会被用来对内容（executable code，resources such as images and nib files aren’t signed）进行数字签名（CodeSign）——使用哈希算法生成内容摘要（digest）。 Xcode使用指定证书配套的私钥进行签名时需要授权，选择【始终允许】后，以后使用该私钥进行签名便不会再弹出授权确认窗口。 8.3 Verify Code Signature with Certificate上面已经提到，公钥被包含在数字证书里，数字证书又被包含在描述文件(Provisioning File)中，描述文件在应用被安装的时候会被拷贝到iOS设备中。 第一步，App在Mac／iOS真机上启动时，需要对配置的bundle ID、entitlements和certificate与Provisioning Profile进行匹配校验： 第二步，iOS/Mac真机上的ios_development.cer被AppleWWDRCA.cer中的 public key解密校验合法后，获取每个开发证书中可信任的公钥对App的可靠性和完整性进行校验。 iOS/Mac设备（系统）使用App Provisioning Profile （Code Signing Identity） 中的开发证书来判断App的合法性： 若用证书公钥能成功解密出App（executable code）的内容摘要（Signature），证明此App确乃认证开发者发布，即来源可信； 再对App（executable code）本身使用哈希算法计算摘要，若与上一步得到的摘要一致，则证明此App（executable code）未被篡改过，即内容完整。 小结： 基于Provisioning Profile校验了CodeSign的一致性； 基于Certificate校验App的可靠性和完整性； 启动时，真机的device ID（UUID）必须在Provisioning Profile的ProvisionedDevices授权之列。 九、在多台机器上共享开发账户/证书9.1 Xcode导出开发者账号(*.developerprofile)或PKCS12文件(*.p12)进入Xcode Preferences|Accounts： 选中Apple IDs列表中对应Account的的Email，点击+-之后的☸|Export Accounts，可导出包含account/code signing identity/provisioning profiles信息的*.developerprofile（Exporting a Developer Profile）文件供其他机器上的Xcode开发使用（Import该Account）。 选中右下列表中某行Account Name条目|ViewDetails，可以查看Signing Identities和Provisioning Profiles。 选中欲导出的Signing Identity条目，点击栏底+之后的☸|Export，必须输入密码，并需授权export key “privateKey” from keychain，将导出Certificates.p12。** 点击左下角的刷新按钮可从Member Center同步该账号下所有的Provisioning Profile到本地。 选中右击列表中某个Provisioning Profile可以【Show in Finder】到[~/Library/MobileDevice/Provisioning\\ Profiles]目录，其中Provisioning Profile的真实名称为$(UUID).mobileprovision，名如”2488109f-ff65-442e-9774-fd50bd6bc827.mobileprovision”，其中Name中为Xcode中看到的描述性别名。 9.2 Keychain Access导出PKCS12文件(*.p12)在Keychain Access|Certificates中选中欲导出的certificate或其下private key，右键Export或者通过菜单File|Export Items导出Certificates.p12——PKCS12 file holds the private key and certificate。 其他Mac机器上双击Certificates.p12（如有密码需输入密码）即可安装该共享证书。有了共享证书之后，在开发者网站上将欲调试的iOS设备注册到该开发者账号名下，并下载对应证书授权了iOS调试设备的Provisioning Profile文件，方可在iOS真机设备上开发调试。 十、证书配置常见错误 no such provisioning profile was found Xcode Target -&gt; Genera -&gt; Identity Team下提示”Your build settings specify a provisioning profile with the UUID “xxx”,howerver, no such provisioning profile was found.” Xcode Target|BuildSettings|Code Signing|当前配置的指定UDID的provisioning profile在本地不存在，此时需要更改Provisioning Profile。必要时手动去网站下载或重新生成Provisioning Profile或直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）！ No identities from profile Build Settings|CodeSigning的Provisioning Profile中选择了本地安装的provisioning profile之后，Code Signing Identity中下拉提示No identities from profile “…”or No identities from keychain. Xcode配置指定UDID的provisioning profile中的DeveloperCertificates在本地KeyChain中不存在（No identities are available）或不一致（KeyPair中的Private Key丢失），此时需去网站检查ProvisioningProfile中的App ID-Certificate-Device配置是否正确。如果是别人提供的共享账号（.developerprofile）或共享证书(.p12)，请确保导出了对应Key Pair中的Private Key。必要时也直接在Xcode中Fix issue予以解决（可能自动生成iOS Team ProvisioningProfile）。 Code Signing Entitlements file do not match profile “Invalid application-identifier Entitlement“ or “Code Signing Entitlements file do not match those specified in your provisioning profile.(0xE8008016).” （1） 检查对应版本（Debug）指定的*.entitlements文件中的“Keychain Access Groups”键值是否与ProvisioningProfile中的Entitlements项相吻合（后者一般为前者的Prefix/Seed）。（2） 也可以将Build Settings|Code Signing的Provisioning Profile中对应版本（Debug）的Entitlements置空。 Xcode配置反应有时候不那么及时 可刷新、重置相关配置项开关（若有）或重启Xcode试试。 十一、Xcode7 免证书真机调试在 Xcode 7 中，苹果改变了自己在许可权限上的策略： 此前 Xcode 只开放给注册开发者下载，现在 Xcode 7 改变了这种惯有的做法，无需注册开发者账号，仅使用普通的Apple ID就能下载和上手体验。 此前开发者需每年支付99美元的费用成为注册开发者才能在 iPhone/iPad 真机上运行调试APP，苹果新的开发者计划则放宽要求，无需购买，只要你感兴趣同样可以在设备上测试app。——Developers would be able to test apps on devices without a paid Apple developer account in Xcode 7. 所谓“免证书”真机调试，并不是真的不需要证书，Xcode真机调试原有的证书配置体系仍在——All iOS, tvOS, and watchOS apps must be code signed and provisioned to launch on a device. 所以，上文啰嗦几千字还是有点用的。 自 Xcode7 开始，原来基于付费开发者账号及自助生成证书及配置文件的繁琐过程被苹果简化，Xcode将针对任何普通账号自动为联调真机生成所需相关的证书及配置文件。当你打算向 App Store 提交发布应用，才需要付费。 第一步：进入 Xcode Preferences|Accounts，添加自己的 Apple ID 账号。 第二步：Build Settings|Code Signing 下的 Provisioning Profile 选择 Automatic，Code Signing Identity 选择 Automatic 下的iOS Developer。 第三步：General 配置 Bundle identifier，Team 下拉选择苹果Member Center自动为你的账号生成的Personal Team ID。 自己的账号在调试公司或其他第三方APP代码时，若填写 Bundle identifier 为他人账号注册的 APP ID（例如苹果相机应用 com.apple.camera），会报错： No provisioning profiles with a valid signing identity (i.e. certificate and private key pair) matching the bundle identifier “com.apple.camera” were found. 即使编译通过了，可能运行时APP自身与服务器校验也可能会报签名错误，肿么办？？？ Her skill：此时，可以在他人原有App ID基础上添加后缀（例如com.apple.camera.extension），配置成应用的衍生插件（相当于置于同一 App Group 下）就可以快乐的玩耍了。 如果启动APP时，Xcode报错“process launch failed: Security”或iPhone报错【不受信任的开发者】，此时需要到iPhone通用配置中的描述文件（最新系统中可能叫设备管理）中，在描述文件（开发商应用）中选择对应的描述文件（你的Apple ID）点击 信任 或 验证 即可。 十二、推送证书APNS远程推送证书的申请和制作——详细解析APNS推送服务证书制作 图文详解教程 十三、学习文章《iOS开发各种证书问题》《iPhone真机调试应用程序》《iOS Developer：真机测试》《Xcode5 &amp; iOS 7 及以下版本免证书真机调试记录》《iOS Development–Certificates, Provisioning Profiles》《关于Certificate、Provisioning Profile、App ID的介绍及其关系》《数字签名和数字证书》《iOS keyChain 研究》《苹果开发者账号那些事儿》《iOS关于Provisioning Profiles這些事》《iOS Code Signing 学习笔记》《代码签名探析/Inside Code Signing》《iOS Code Signing: 解惑/iOS Code Signing: Under The Hood》《iOS行货自动打包》《解决Xcode无法生成Archive的问题》《iOS程序完成后如何生成ipa进行真机测试》《发布iOS应用程序(Application Loader)》《iOS发布遇到的一些问题》《Xcode打包ipa包》《iOS程序生成ipa进行真机测试》","tags":[]},{"title":"iOS Push","date":"2019-05-22T06:31:14.236Z","path":"2019/05/22/iOS Push/","text":"1、前言早期 iOS 设备的内存和 CPU 资源都很有限，为了让前台活跃的 app 拥有尽可能多的系统资源，以及节约设备电量，iOS 一开始就“不允许”普通 app 的进程常驻后台。这个决定很大程度上保障了用户体验和延长了手机的待机时间，但 app 的开发商需要和他们的用户保持联系，需要有一个稳定的网络通道能每隔一段时间推送新的内容到用户设备。Apple 决定自己来搭建维护这个通道，也就是我们今天所说的APNs。 2、push流程 Provider 是指某个 iPhone 软件的 Push 服务器，APNs 是 Apple Push Notification Service的缩写，是苹果的服务器。 上图可以分为三个阶段：①、应用程序把要发送的消息、目的iPhone的标识打包，发给 APNs。②、APNs 在自身的已注册 Push 服务的 iPhone 列表中查找有相应标识的 iPhone，并把消息发送到 iPhone。③、iPhone把发来的消息传递给相应的应用程序，并且按照设定弹出Push通知。 从上图可以看到： ①、在程序上注册远程通知，这是通知的前提（程序员的工作）；1234 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [[UIApplication sharedApplication] registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];&#125; ②、注册好后，当用户下载完并打开 app 时，app 会弹出一个 alertView，询问是否允许该应用向你发送通知；③、当用户选择“好”之后，ios 操作系统将会告诉 APNs 服务器，这样一来，当程序运行时，APNs 就会给程序发送那一台设备的 device token（唯一），这时候要做的操作就是获取这个 token 值；如果用户选择“不允许”，ios 操作系统将不会告诉 APNs 服务器，那么到这一步也就完结了；123456789101112-(void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;#if !TARGET_IPHONE_SIMULATOR //注意：拿到的 deviceToken 是带有空格的，交给服务器时，要将空格去掉（也可以交给服务器来做） self.deviceToken = [[[[devToken description] stringByReplacingOccurrencesOfString:@\"&lt;\"withString:@\"\"] stringByReplacingOccurrencesOfString:@\"&gt;\" withString:@\"\"] stringByReplacingOccurrencesOfString: @\" \" withString: @\"\"];#endif // 一般进行的是 post 请求，将 deviceToken 值发给服务器。这里采用极光推送 [JPUSHService registerDeviceToken:devToken];&#125; ④、将这个 token 值发送到公司的服务器上去，存储下来。⑤、公司的服务器拿到 token 值后也不是随意就能向设备发送推送的，还需要一个证明身份的文件–推送证书，有了这个推送证书后，当有事情发生时，服务器便可以主动向用户发送远程推送了。 3、APNs的限制APNs虽然允许开发商推送消息到用户设备，但考虑到消息的量级和成本，这个由Apple维护的长链接通道就不可能是无限制使用的。APNs有着诸多的限制： 可靠性。一般情况下，Apple会保证这个通道的Qaulity of Service，也就是推送的消息能及时稳定到达设备。不过一旦用户的设备处于offline状态，Apple只会存储发送给用户的最新一条push，之前发送的push会被直接丢掉。而且这最后一条离线push也是有过期时间的。一些用户应该有过这种经历，在使用微信的时候，明明对方发送了多条消息，却只收到了一条push。 Payload Size。每一条push消息的包体大小是有最大限制的。Apple在文档里清楚的说明，push只应该用来通知用户有新的内容，而不应该用来承载内容本身。理论上payload size越小，push到达设备的概率就越高。在iOS8之前max payload size是256字节，到iOS8发布这个最大值被调整到了2048字节，再到最近的iOS9发布，引入了HTTP2.0，payload size又被设为4KB了。老版本的256字节实在有点捉襟见肘，连塞一个链接进去都要考虑再三。到2KB的时候就宽裕多了，已经有不少开发商开始尝试往里面放少量的业务数据了，如果能减少打开app之后的一次网络请求何乐而不为呢。当然4KB的想象空间会更大。Apple一直在调整这个数值，为的是给开发商更多的空间去提升用户体验。push慢慢变的不仅仅是一条“alert”那么简单了。 成功率并不高。Apple虽然保证了push通道一定程度的可靠性，但push由于各种各样的原因并不能保证较高水平的到达率。push需要向用户申请权限，即使当时赋予了权限，后面也可能由于push过于频繁被用户又关掉。在夜间模式下push虽然能到达通知栏，可用户没有任何感知，更不用说点击push启动app了。还有server端token失效，这点可以通过feedback service来清理失效的token。Apple的APNs server据说每天会发送超过百亿条push，在某个时间段出现峰值的时候，开发商server和Apple server连接的成功率也会降低。还有客户端设备所处网络环境并不稳定等等因素，使得通过push成功启动app的成功率并不怎么高。 理解了上面这些限制，就能按照Apple的规范向用户推送内容了。但push里面的门道远不止这么简单，Apple也从没有停止过对APNs体验的优化，类似payload size调整，interactive notification等等，每一个新的feature增加，哪怕是细微的改动，都能被聪明的开发者加以利用，以四两拨千斤提升产品的体验。下面就介绍一些笔者所了解到的“隐蔽门道”。 4、不仅仅是Local Push很多个人开发者不具备搭建server的条件，一般会设置一个定时的local push来提醒用户唤醒自己的app。Local push看起来似乎是个廉价的折中方案，事实上它可以更强大。APNs（一般也叫做remote push）因为有上面的各种限制，并不能很好的契合业务需要。而Local Push则不同，拥有完整的app业务上下文，还可以对push进行定制化。如果可以用Local Push替代Remote Push对体验的提升是不言而喻的。 Local push的限制在于app必须处于运行状态才能发起，很多聪明的开发商会开启background task，在用户按了home键之后再争取到几分钟的运行时间，在这期间所有的remote push都被替换成了local push。不要小看了这几分钟的时间，对于很多活跃度高的app来说，按home键之后马上又产生新的用户内容的概率并不小。微信、WhatsApp都采用了这种机制来提升体验。 5、叫醒你的App开启background task之后虽然能够再多运行一会，但时间一到，app还是会被挂起或者kill。大部分多时候你的 app 是处于非活跃状态。很多 app 都需要预先获取内容，或者后台下载文件等来减少用户的等待时间。iOS7引入的Silent Notification和Background Fetch机制可以一定程度上满足这种需要。silent push实现比较简单，开启相关后台权限之后发送如下特定格式的json就能启用。 唤醒app之后能处理的业务就多了，这对不少app来说是个非常实用的拓展，预加载内容也好，生成local push也好，都能提升体验。但这种唤醒机制并不总是可靠，有时候会“叫不醒”。app如果被手动kill叫不醒，如果background fetch被用户关闭也叫不醒，但这两种情况在手机充电的时候又可以被叫醒。Apple有一套自己的“智能”策略。 6、前台消息通道大部分时候APNs都被用来通知用户某个处于background的app有新内容。但其实说白了APNs不过就是一条基于长链接的数据通道，在app处于foreground的时候也是能收到push消息的，不过不会有任何UI展示提醒而已。处理回调的位置也是在12345678// iOS 10 Support- (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler&#123;&#125;- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler &#123;&#125; 也就是说APNs其实还是个免费的前台消息通道。而且有时候走APNs通道会比自己的server通道更快，如果客户端做好数据去重，多一个辅助的数据通道当然能提升体验。 7、PushKitAPNs设计的初衷是避免app常驻后台，只在用户点收到push的时候主动去启动app。前面提到的silent push可以在有限的场景下，无需用户感知启动app。但到iOS8引入PushKit framework之后，app就可以通过push随时唤醒了，不过这个新的特性暂时还只限于voip类应用。 之前在社区看到有人提问，说微信电话本可以在用户挂掉电话的时候，把呼叫中的push改成未接电话，好奇是怎么办到的。因为大家都知道remote push是无法通过server动态修改push内容的，所以答案只有一个可能，app被后台唤醒了。用户看到的push其实是local push，而local push是可以在客户端随意调整的。唤醒到方式就是利用PushKit。 当然好处不仅仅是修改push内容这么简单。WhatsApp的用户在iOS8之后应该会有明显的感觉，好像很少看到启动页面了。看起来似乎是WhatsApp开启了voip后台常驻运行模式，但这种模式会比较费电，一些用户会有顾虑。真相也并非如此，WhatsApp并没有常驻后台，只不过是开启了PushKit的push唤醒机制。每次用户有新的离线消息，普通文本或者是voip call，app都会先被后台唤醒，再从server拉取离线消息，最后生成local push。等用户点击local push启动app的时候，没有启动页面，没有connecting和loading，所有的数据已经准备就绪，就好像WhatsApp一直在后台运行一样。也就是说，WhatsApp其实已经把所有的push都换成了local push。 微信不知道是出于什么考虑，既没有开启voip后台常驻模式，也没有利用PushKit唤醒机制。每次收到消息之后打开app，都是先看到地球，连接中，收取中，到真正看到最新消息经常需要3s以上。PushKit已经没有电量方面的额外损耗了，对voip类应用的体验提升非常之大。 8、总结关于push这条长链接通道，Apple几乎在每次的iOS新版本里都会增加一些feature。为了控制新feature带来的影响，每次改动都不多。对用户体验带来的改变远不止官方文档上介绍的那么简单，只有多思考，时刻关注行业最新动态，才能发掘更多的隐藏“门道”。 9、学习文章MrPeak杂货铺 &amp; iOS Push的门道Silent Push实现PushKit实现APNS推送服务证书制作 图文详解教程APNS远程推送证书的申请和制作——详细解析","tags":[]},{"title":"iOS 时间","date":"2019-05-21T08:15:20.020Z","path":"2019/05/21/iOS 时间/","text":"1、时间的形式在开始深入讨论之前，我们需要确信一个前提：时间是线性的。即任意一个时刻，这个地球上只有一个绝对时间值存在，只不过因为时区或者文化的差异，处于同一时空的我们对同一时间的表述或者理解不同。这个看似简单明了的道理，是我们理解各种与时间相关的复杂概念的基石。就像UTF-8和UTF-16其实都是Unicode一样，北京的20：00和东京的21：00其实是同一个绝对的时间值。 1.1、GMT人类对于时间的理解还很有限，但至少能确定一点：时间的变化是匀速的。时间前进的速度是均匀的，不会忽快忽慢，所以为了描述时间，我们也需要找到一个值，它的变化也是以均匀的速度向前变化的。 前人发现抬头看太阳是个好办法，太阳总是按规律的“早起晚落”，而且“亘古不变”，可以用太阳在一天当中所处的位置来描述当前的时间。后来不同地区的文化需要交流，你这里太阳正高空照，我这可能已经下山了，所以需要有一个公共的大家都认可的地方，以这个地方太阳的位置来做参考，沟通起来就会方便很多。最后选择的是英国伦敦的格林尼治天文台所在地，以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。 1.2、UTC太阳所处的位置变化跟地球的自转相关，过去人们认为地球自转的速率是恒定的，但在1960年这一认知被推翻了，人们发现地球自转的速率正变得越来越慢，而时间前进的速率还是恒定的，所以GMT不再被认为可以用来精准的描述时间了。 我们需要继续寻找一个匀速前进的值。抬头看天是我们从宏观方向去寻找答案，科技的发展让我们在微观方面取得了更深的认识，于是有聪明人根据微观粒子原子的物理属性，建立了原子钟，以这种原子钟来衡量时间的变化，原子钟50亿年才会误差1秒，这种精读已经远胜于GMT了。这个原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。 接下来看下iOS里，五花八门的记录时间的方式。 2、NSDateNSDate是我们平时使用较多的一个类，先看下它的定义： NSDate objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001). NSDate对象描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年1月1日00：00：00这一刻的时间绝对值。 这里有个概念很重要，我们用编程语言描述时间的时候，都是以一个时间线上的绝对值为参考点，参考点再加上偏移量（以秒或者毫秒、微秒、纳秒为单位）来描述另外的时间点。 理解了这一点，再看NSDate的一些API调用就非常清楚了，比如：12NSDate* date = [NSDate date];NSLog(@\"current date interval: %f\", [date timeIntervalSinceReferenceDate]); timeIntervalSinceReferenceDate返回的是距离参考时间的偏移量，这个偏移量的值为502945767秒，502945767/86400/365=15.9483056507，86400是一天所包含的秒数，365大致是一年的天数，15.94当然就是年数了，算出来的是此刻距离2001年的差值。 又比如，此刻我写文章的时候，当前时间为北京时间上午11:29，看看下面代码的输出：12NSDate* date = [NSDate date];NSLog(@\"current date: %@\", date); current date: 2016-12-09 03:29:09 +0000。可见NSDate输出的是绝对的UTC时间，而北京时间的时区为UTC+8，上面的输出+8个小时，刚好就是我当前的时间了。 NSDate 与市区、文化无关，所以要展示具体格式的时间，我们需要NSDateFormatter和NSTimeZone的辅助。 另外关于NSDate最重要的一点是：NSDate是受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。在我们做App的时候，明白这一点，就知道NSDate并不可靠，因为用户可能会修改它的值。 3、CFAbsoluteTimeGetCurrent()官方定义如下： Absolute time is measured in seconds relative to the absolute reference date of Jan 1 2001 00:00:00 GMT. A positive value represents a date after the reference date, a negative value represents a date before it. For example, the absolute time -32940326 is equivalent to December 16th, 1999 at 17:54:34. Repeated calls to this function do not guarantee monotonically increasing results. The system time may decrease due to synchronization with external time references or due to an explicit user change of the clock. 从上面的描述不难看出CFAbsoluteTimeGetCurrent()的概念和NSDate非常相似，只不过参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。 同样CFAbsoluteTimeGetCurrent()也会跟着当前设备的系统时间一起变化，也可能会被用户修改。 4、gettimeofday这个API也能返回一个描述当前时间的值，代码如下：1234struct timeval now;struct timezone tz;gettimeofday(&amp;now, &amp;tz);NSLog(@\"gettimeofday: %ld\", now.tv_sec); 使用gettimeofday获得的值是Unix time。Unix time又是什么呢？ Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。上述API返回的值是1481266031，表示当前时间距离UTC 1970年1月1号 00：00：00一共过了1481266031秒。 Unix time也是平时我们使用较多的一个时间标准，在Mac的终端可以通过以下命令转换成可阅读的时间：1date -r 1481266031 实际上NSDate也有一个API能返回Unix time：12NSDate* date = [NSDate date];NSLog(@\"timeIntervalSince1970: %f\", [date timeIntervalSince1970]); gettimeofday和NSDate，CFAbsoluteTimeGetCurrent()一样，都是受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。 5、mach_absolute_time()mach_absolute_time()可能用到的同学比较少，但这个概念非常重要。 前面提到我们需要找到一个均匀变化的属性值来描述时间，而在我们的iPhone上刚好有一个这样的值存在，就是CPU的时钟周期数（ticks）。这个tick的数值可以用来描述时间，而mach_absolute_time()返回的就是CPU已经运行的tick的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。 不过这个tick数，在每次手机重启之后，会重新开始计数，而且iPhone锁屏进入休眠之后tick也会暂停计数。 mach_absolute_time()不会受系统时间影响，只受设备重启和休眠行为影响。 6、CACurrentMediaTime()CACurrentMediaTime()可能接触到的同学会多一些，先看下官方定义：123/* Returns the current CoreAnimation absolute time. This is the result of * calling mach_absolute_time () and converting the units to seconds. */CFTimeInterval CACurrentMediaTime (void) CACurrentMediaTime()就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。以下代码：12double mediaTime = CACurrentMediaTime();NSLog(@\"CACurrentMediaTime: %f\", mediaTime); 返回的就是开机后设备一共运行了(设备休眠不统计在内)多少秒，另一个API也能返回相同的值：12NSTimeInterval systemUptime = [[NSProcessInfo processInfo] systemUptime];NSLog(@\"systemUptime: %f\", systemUptime); CACurrentMediaTime()也不会受系统时间影响，只受设备重启和休眠行为影响。 7、sysctliOS系统还记录了上次设备重启的时间。可以通过如下API调用获取：123456789101112131415161718#include &lt;sys/sysctl.h&gt;- (long)bootTime&#123;#define MIB_SIZE 2 int mib[MIB_SIZE]; size_t size; struct timeval boottime; mib[0] = CTL_KERN; mib[1] = KERN_BOOTTIME; size = sizeof(boottime); if (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, 0) != -1) &#123; return boottime.tv_sec; &#125; return 0;&#125; 返回的值是上次设备重启的Unix time。 这个API返回的值也会受系统时间影响，用户如果修改时间，值也会随着变化。 有了以上获取时间的各种手段，我们再来看看一些场景之下的具体应用。 8、场景一，时间测量我们做性能优化的时候，经常需要对某个方法执行的时间做记录，就必然会用到上面提到的一些获取时间的方法。 在做方法执行时间的benchmark的时候，我们获取时间的方法要满足两个要求，一是精读要高，而是API本身几乎不耗CPU时间。 客户端做性能优化一般是为了主线程的流畅性，而我们知道UI线程如果遇到超过16.7ms的阻塞，就会出现掉帧现象，所以我们关注的时间的精读实际上是在毫秒（ms）级别。我们写客户端代码的时候，基本上都是处于ms这一维度，如果一个方法损耗是0.1ms，我们可以认为这个方法对于流畅性来说是安全的，如果经常看到超过1ms或者几个ms的方法，主线程出现卡顿的几率就会变高。 上面几种获取时间的方式精读上都是足够的，比如一个NSDateAPI调用返回的精读是0.000004 S，也就是4微秒，CACurrentMediaTime()返回的精读也在微秒级别，精读上都符合要求。不过有一种看法，认为NSDate属于类的封装，OOP高级语言本身所带来的损耗可能会影响最后的实际结果，在做benchmark的时候不如C函数调用精准，为了验证这一说法，我写了一段简单的测试代码：1234567891011121314151617int testCount = 10000;double avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; NSDate* begin = [NSDate date]; NSLog(@\"a meaningless log\"); avgCost += -[begin timeIntervalSinceNow];&#125;NSLog(@\"benchmark with NSDate: %f\", avgCost/testCount);avgCost = 0;for (int i = 0; i &lt; testCount; i ++) &#123; double startTime = CACurrentMediaTime(); NSLog(@\"a meaningless log\"); double endTime = CACurrentMediaTime(); avgCost += (endTime - startTime);&#125;NSLog(@\"benchmark with CACurrentMediaTime: %f\", avgCost/testCount); 输出结果为：12benchmark with NSDate: 0.000046benchmark with CACurrentMediaTime: 0.000037 可以看出CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：12#define TICK NSDate *startTime = [NSDate date]#define TOCK NSLog(@\"Time Cost: %f\", -[startTime timeIntervalSinceNow]) 9、场景二：客户端和服务器之间的时间同步这也是我们经常遇到的场景，比如电商类App到零点的时候开始抢购，比如商品限购倒计时等等，这种场景下需要我们将客户端的时间与服务器保持一致，最重要的是，要防止用户通过断网修改系统时间，来影响客户端的逻辑。 比较普遍的做法是，在一些常用的Server接口里面带上服务器时间，每调用一次接口，客户端就和服务器时间做一次同步并记录下来，但问题是如何防止用户修改呢？ 上面提到的NSDate，CFAbsoluteTimeGetCurrent，gettimeofday，sysctl都是跟随系统时间变化的，mach_absolute_time和CACurrentMediaTime虽然是依据CPU时钟数，不受系统时间影响，但在休眠和重启的时候还是会被影响。看上去都不太适合，这里介绍下我个人的做法。 首先还是会依赖于接口和服务器时间做同步，每次同步记录一个serverTime（Unix time），同时记录当前客户端的时间值lastSyncLocalTime，到之后算本地时间的时候先取curLocalTime，算出偏移量，再加上serverTime就得出时间了：1234567uint64_t realLocalTime = 0;if (serverTime != 0 &amp;&amp; lastSyncLocalTime != 0) &#123; realLocalTime = serverTime + (curLocalTime - lastSyncLocalTime);&#125;else &#123; realLocalTime = [[NSDate date] timeIntervalSince1970]*1000;&#125; 如果从来没和服务器时间同步过，就只能取本地的系统时间了，这种情况几乎也没什么影响，说明客户端还没开始用过。 关键在于如果获取本地的时间，可以用一个小技巧来获取系统当前运行了多长时间，用系统的运行时间来记录当前客户端的时间：1234567891011121314151617181920//get system uptime since last boot- (NSTimeInterval)uptime&#123; struct timeval boottime; int mib[2] = &#123;CTL_KERN, KERN_BOOTTIME&#125;; size_t size = sizeof(boottime); struct timeval now; struct timezone tz; gettimeofday(&amp;now, &amp;tz); double uptime = -1; if (sysctl(mib, 2, &amp;boottime, &amp;size, NULL, 0) != -1 &amp;&amp; boottime.tv_sec != 0) &#123; uptime = now.tv_sec - boottime.tv_sec; uptime += (double)(now.tv_usec - boottime.tv_usec) / 1000000.0; &#125; return uptime;&#125; gettimeofday和sysctl都会受系统时间影响，但他们二者做一个减法所得的值，就和系统时间无关了。这样就可以避免用户修改时间了。当然用户如果关机，过段时间再开机，会导致我们获取到的时间慢与服务器时间，真实场景中，慢于服务器时间往往影响较小，我们一般担心的是客户端时间快于服务器时间。 多和服务器做时间同步，再把关键的时间校验逻辑放在Server端，就不会出现什么意外的bug了。 10、学习文章MrPeak杂货铺iOS倒计时的探究与选择","tags":[]},{"title":"hexo+pages建站","date":"2019-05-14T07:42:50.947Z","path":"2019/05/14/hexo+pages建站/","text":"hexo史上最全搭建教程 解决用Hexo和GitHub搭建博客时hexo d命令报错问题 hexo d后 ERROR Deployer not found: git git-ssh 配置和使用 给博客添加文章目录 https://hexo.io/zh-cn/ Hexo博客多台电脑设备同步管理 博客从WordPress转到Hexo从wordpress迁移到hexo填坑","tags":[]},{"title":" ","date":"2019-05-05T05:51:01.000Z","path":"2019/05/05/trashed/","text":"Toll-Free Bridged __bridge 改变指针的索引，在Objective-C和Core Foundation之间，但不改变所有权 __bridge_retained或者CFBridgingRetain将Objective-C指针类型转变为Core Foundation指针类型，并且改变所有权，必须调用CFRelease来释放 __bridge_transfer或者CFBridgingRelease将一个非non-Objective-C指针转变为Objective-C指针类型，并且改变所有权，启用ARC，即不需要自己去Release。 内存管理所有权原则基本规则 如果创建一个对象（亦或是从别的对象复制而得），将持有这个对象 如果只是去引用这个对象，不会有所有权，如果为了避免这个对象被释放，可以通过（CFRetain）去添加引用计数。 对于对象持有者，当对象不再使用的时候释放它（CFRelease) 创建规则 创建方法名中包含”Create”，创建时持有对象 创建方法名中包含”Copy”，拷贝时持有对象 CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT (CFAllocatorRef allocator, CFTimeInterval ti); CFDictionaryRef CFTimeZoneCopyAbbreviationDictionary (void); CFBundleRef CFBundleCreate (CFAllocatorRef allocator, CFURLRef bundleURL); CF_EXPORT CFBagRef CFBagCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFBagCallBacks *callBacks); CF_EXPORT CFMutableBagRef CFBagCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBagRef bag); Get Rule如果是通过get方法获得的对象，将不持有这个对象，必须通过CFRetain去持有，但使用结束的时候也应该去CFRelease，不然会造成内存泄露 CFStringRef CFAttributedStringGetString (CFAttributedStringRef aStr); 实例变量和参数传递当一个对象作为参数传递的时候，接收者并没有持有这个对象，对象有可能在任意时刻被释放掉，从而导致接收者出错，因此接收者需要对这个可能被释放的对象CFRetain。当接收者使用完毕后，再去释放它。 生命周期Core Foundation的生命周期取决于它自身的引用计数，当被创建或者复制的时候，新的对象的引用计数为1，CFRetain引用计数加1，CFRelease引用计数减1，当引用计数为0的时候，该对象将被释放掉。 /* myString is a CFStringRef received from elsewhere */ myString = (CFStringRef)CFRetain(myString); CFRelease(myString); CFIndex count = CFGetRetainCount(myString);//获取引用计数 复制在Core Foundation中，对象之间利用等号来进行赋值是不进行复制的，只是复制了引用，并没有真正持有该对象。例如myCFString2 = myCFString1。如果是对不可变的对象，这种赋值会比较方便简洁，但是如果是可变对象，这种赋值方式就很危险了，因为变量随时会改变，造成想要获取的结果与预计不和。 浅复制在复制复合对象的时候，类似集合对象CFArray、CFSet.如果只是单纯的用等号来复制，复制的只是引用（如上所述）。如果通过浅复制，那么新的集合对象将被创建，但是集合里面的数据并没有被复制，而只是增加了引用而已。 深复制如果想要创建一个完全全新的复合对象，那么就必须使用深复制。深复制比浅复制多的就是将集合里面的所有对象也都会复制一份。 CFPropertyListRef CFPropertyListCreateDeepCopy ( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption ); 在构造函数中使用Allocators每个Core Foundation不透明类型都有一个或多个构造方法。所有的构造函数的第一个传入参数都是 allocator object(CFAllocatorRef类型)。一些函数也会有allocator参数来进行分配和销毁。 如何获取一个allocator： 利用常量 kCFAllocatorSystemDefault，定义一个默认的allocator。 NULL或者kCFAllocatorDefault，定义常用的allocator，或者是默认的allocator。 设置为常量 kCFAllocatorNull，说明allocator并没有被分配 也可以通过CFGetAllocator从别的对象获取 使用Allocator Context每个分配器都会有一个Core Foundation的context。context是由函数指针构成，定义了对象的操作环境。 定义如下： typedef struct { CFIndex version; void * info; const void *(\\*retain)(const void \\*info); void (\\*release)(const void \\*info); CFStringRef (\\*copyDescription)(const void \\*info); void * (\\*allocate)(CFIndex size, CFOptionFlags hint, void \\*info); void * (\\*reallocate)(void \\*ptr, CFIndex newsize, CFOptionFlags hint, void *info); void (\\*deallocate)(void \\*ptr, void *info); CFIndex (\\*preferredSize)(CFIndex size, CFOptionFlags hint, void \\*info); } CFAllocatorContext; 如果有一些用户自定义的数据，可以通过CFAllocatorGetContext函数来获取CFAllocatorContext的内容 static int numOutstandingAllocations(CFAllocatorRef alloc) { CFAllocatorContext context; context.version = 0; CFAllocatorGetContext(alloc, &amp;context); return ((int )(context.info)); } 作者：c_xiaoqiang 链接：https://www.jianshu.com/p/bf1596e012aa 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","tags":[]},{"title":" LOGIC - Block\t\t","date":"2019-04-09T16:15:26.000Z","path":"2019/04/10/logic-block/","text":"一、block 的种类{ int a = 10; // 栈 // \\_\\_NSGlobalBlock\\_\\_ 全局 block（没有引入外部变量） void (^ block)(void) = ^ { NSLog(@&quot;哈哈哈&quot;); }; NSLog(@&quot;%@&quot;, block); // %@ -》 对象 -》 NSObject -》objc_object // \\_\\_NSMallocBlock\\_\\_ 堆 block void (^ block2) (void) = ^ { NSLog(@&quot;哈哈哈 ：%d&quot;, a); }; NSLog(@&quot;%@&quot;, block2); // \\_\\_NSStackBlock\\_\\_ 栈 block NSLog(@&quot;%@&quot;, ^ { NSLog(@&quot;哈哈哈 ：%d&quot;, a); }); } ①、全局 block 在 data 段； ②、a 在栈上，跨域请求就把全局的 block 放入栈中； ③、重写操作符 “c”，执行 copy 操作，objc 源码中的 _block_copy() 方法； // 全局（data） -》栈 -》重写 “=”运算符 -》堆id objc_retainBlock(id x) { return (id)_Block_copy(x);} 二、解决循环引用typedef void(^Block)(void); @interface ViewController ()@property (nonatomic, copy) Block block;@property (nonatomic, copy) NSString * name;@end - (void)viewDidLoad{ [super viewDidLoad]; self.name = @&quot;哈哈哈&quot;; self.block = ^ { NSLog(@&quot;%@&quot;, self.name); // 产生循环引用 }; self.block(); } - (void)dealloc{ NSLog(@”dealloc”);} 错误解决实例： __weak typeof(self) weakSelf = self; self.block = ^ { weakSelf.name = @&quot;哈哈哈&quot;; dispatch\\_after(dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(2 * NSEC\\_PER\\_SEC)), dispatch\\_get\\_main\\_queue(), ^{ NSLog(@&quot;%@&quot;, weakSelf.name); }); }; self.block(); self 调用 dealloc 之后，NSLog(@”%@”, weakSelf.name); 将输出 (null)。 解决方法 1： __weak typeof(self) weakSelf = self; self.block = ^ { weakSelf.name = @&quot;哈哈哈&quot;; dispatch\\_after(dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(2 * NSEC\\_PER\\_SEC)), dispatch\\_get\\_main\\_queue(), ^{ __strong typeof(self) strongSelf = weakSelf; NSLog(@&quot;%@&quot;, strongSelf.name); }); }; self.block(); 使用 strong 与 weak。 解决方法 2： __block ViewController * blkVC = self; self.block = ^ { blkVC.name = @&quot;哈哈哈&quot;; dispatch\\_after(dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(2 * NSEC\\_PER\\_SEC)), dispatch\\_get\\_main\\_queue(), ^{ NSLog(@&quot;%@&quot;, blkVC.name); blkVC = nil; // 关键，不然 dealloc 不会调用 }); }; self.block(); __block 将栈区的数据 copy 一份到堆区。 解决方法 3： 循环引用的实质：self -&gt; block -&gt; self。 typedef void(^Block)(ViewController *); self.block = ^ (ViewController * vc){ vc.name = @&quot;哈哈哈&quot;; dispatch\\_after(dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(2 * NSEC\\_PER\\_SEC)), dispatch\\_get\\_main\\_queue(), ^{ NSLog(@&quot;%@&quot;, vc.name); }); }; self.block(self); // 传值 block 内不使用 self，使用传递的值。 三、操作捕获的变量int a = 10; // 栈 // block 在堆中 self.block = ^ { a++; }; self.block(); 使用 __block。 __block int a = 10; // 栈 NSLog(@&quot;1 --- %p&quot;, &amp;a); self.block = ^ { a++; NSLog(@&quot;2 ---- %p&quot;, &amp;a); }; self.block(); NSLog(@&quot;3 ---- %p&quot;, &amp;a); 1 — 0x7ffeed8438e82 —- 0x6000020595783 —- 0x600002059578 经验： 0x7 在栈，0x6 在堆，0x1 在全局静态区（区分已初始化和未初始化的）。 __block 的作用是从栈区复制到堆区。","tags":[]},{"title":" LLDB\t\t","date":"2019-04-03T06:46:42.000Z","path":"2019/04/03/lldb-2/","text":"官网：The LLDB Debugger、JoySeeDog/iOS开发断点调试高级技巧、Xcode 常用 LLDB 指令 一、breakpoint1、给某个文件的某一行设置断点 (lldb) breakpoint set –file ViewController.m –line 123Breakpoint 14: where = Demo`-[ViewController viewDidLoad] + 87 at ViewController.m:139, address = 0x00000001029b1de7 给 ViewController.m 文件的 123 行设置断点，出现提示则说明设置断点成功。 也可以使用简写的形式： (lldb) breakpoint set -f ViewController.m -l 145Breakpoint 15: where = Demo`-[ViewController viewDidLoad] + 125 at ViewController.m:146, address = 0x00000001029b1e0d 2、给某个函数设置断点 (lldb) breakpoint set –name MyDesignRetainBreakpoint 16: where = Demo`MyDesignRetain + 16 at ViewController.m:94, address = 0x00000001029b2080 简写形式： (lldb) breakpoint set -n MyDesignReleaseBreakpoint 18: where = Demo`MyDesignRelease + 16 at ViewController.m:99, address = 0x00000001029b20a0 也可以在一次命令中为多个函数设置断点： (lldb) breakpoint set –name MyDesignRetain –name MyDesignReleaseBreakpoint 19: 2 locations. 如果是 C 的方法，可以使用如下两种的方法打断点，第二种 M 需要大写。 /** * 自定义的 c 方法没有设置成功 */void cfunc(int i) { printf(“%d”, i);} (lldb) breakpoint set –method cfuncBreakpoint 10: no locations (pending).WARNING: Unable to resolve breakpoint to any actual locations.(lldb) breakpoint set -M cfuncBreakpoint 11: no locations (pending).WARNING: Unable to resolve breakpoint to any actual locations.(lldb) breakpoint set -M mainBreakpoint 12: where = JavaScriptCoreWTF::RunLoop::main(), address = 0x000000011e18b060 (lldb) breakpoint set --method main Breakpoint 17: where = JavaScriptCoreWTF::RunLoop::main(), address = 0x000000011e18b060 如果是 OC 的方法，可以使用以下两种方式打断点，第二种 S 需要大写。 - (UIImage )drawImage:(UIImage )image{ return nil;} (lldb) breakpoint set –selector drawImageBreakpoint 20: no locations (pending).WARNING: Unable to resolve breakpoint to any actual locations.(lldb) breakpoint set –selector drawImage:Breakpoint 21: where = Demo-\\[ViewController drawImage:\\] + 23 at ViewController.m:65, address = 0x000000010d6cba97 (lldb) breakpoint set -S drawImage: Breakpoint 22: where = Demo-[ViewController drawImage:] + 23 at ViewController.m:65, address = 0x000000010d6cba97 (lldb) breakpoint set –selector viewDidLoadBreakpoint 23: 104 locations.(lldb) breakpoint set -S viewDidLoadBreakpoint 24: 104 locations. 如果是 C 语言，还是只能使用上面介绍的 –name 的方式，不能直接指定对应的方法。 (lldb) breakpoint set –name cfuncBreakpoint 27: where = Demo`cfunc + 18 at ViewController.m:118, address = 0x000000010d6cbd72 还可以使用正则匹配要打断点的函数，这个不限语言。 (lldb) breakpoint set -r cfuncBreakpoint 28: where = Demo`cfunc + 18 at ViewController.m:118, address = 0x000000010d6cbd72(lldb) breakpoint set -r drawImageBreakpoint 29: 43 locations. 3、指定加载的动态库 (lldb) breakpoint set –shlib libobjc.A.dylib –name allocBreakpoint 12: where = libobjc.A.dylib+\\[NSObject alloc\\], address = 0x000000010de6c179 (lldb) breakpoint set -s libobjc.A.dylib --name alloc Breakpoint 13: where = libobjc.A.dylib+[NSObject alloc], address = 0x000000010de6c179 简写形式： (lldb) breakpoint set -n “[RACStream zipWith:]“Breakpoint 33: where = Demo-\\[RACStream zipWith:\\] + 47 at RACStream.m:46, address = 0x000000010d73088f (lldb) br s -n &quot;\\[RACStream zipWith:\\]&quot; Breakpoint 34: where = Demo-[RACStream zipWith:] + 47 at RACStream.m:46, address = 0x000000010d73088f 4、查看有多少断点可以使用 (lldb) breakpoint listCurrent breakpoints:1: file = ‘/Users/cykj/Desktop/Demo/Demo/ImageSource/HookTool.m’, line = 172, exact_match = 0, locations = 0 (pending) 2: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 205, exact_match = 0, locations = 4, resolved = 4, hit count = 0 2.1: where = Demo-\\[SDWebImageDownloaderOperation start\\] + 218 at SDWebImageDownloaderOperation.m:205, address = 0x000000010d75771a, resolved, hit count = 0 2.2: where = Demo-[SDWebImageDownloaderOperation start] + 761 at SDWebImageDownloaderOperation.m:205, address = 0x000000010d757939, resolved, hit count = 0 2.3: where = Demo-\\[SDWebImageDownloaderOperation start\\] + 1797 at SDWebImageDownloaderOperation.m:205, address = 0x000000010d757d45, resolved, hit count = 0 2.4: where = Demo-[SDWebImageDownloaderOperation start] + 3999 at SDWebImageDownloaderOperation.m:205, address = 0x000000010d7585df, resolved, hit count = 0 3: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 400, exact_match = 0, locations = 1, resolved = 1, hit count = 0 3.1: where = Demo`-[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:] + 660 at SDWebImageDownloaderOperation.m:400, address = 0x000000010d75ad04, resolved, hit count = 0 4: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 444, exact_match = 0, locations = 2, resolved = 2, hit count = 0 4.1: where = Demo-\\[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:\\] + 1345 at SDWebImageDownloaderOperation.m:445, address = 0x000000010d75afb1, resolved, hit count = 0 4.2: where = Demo-[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:] + 1986 at SDWebImageDownloaderOperation.m:445, address = 0x000000010d75b232, resolved, hit count = 0 5: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 176, exact_match = 0, locations = 1, resolved = 1, hit count = 0 5.1: where = Demo`__65-[SDWebImageManager loadImageWithURL:options:progress:completed:]_block_invoke + 615 at SDWebImageManager.m:176, address = 0x000000010d761d67, resolved, hit count = 0 6: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 342, exact_match = 0, locations = 1, resolved = 1, hit count = 0 6.1: where = Demo`-[SDWebImageManager callCompletionBlockForOperation:completion:image:data:error:cacheType:finished:url:] + 283 at SDWebImageManager.m:344, address = 0x000000010d76447b, resolved, hit count = 0 7: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 201, exact_match = 0, locations = 1, resolved = 1, hit count = 0 7.1: where = Demo`__65-[SDWebImageManager loadImageWithURL:options:progress:completed:]_block_invoke_2 + 168 at SDWebImageManager.m:201, address = 0x000000010d762548, resolved, hit count = 0 8: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 243, exact_match = 0, locations = 1, resolved = 1, hit count = 0 8.1: where = Demo`__65-[SDWebImageManager loadImageWithURL:options:progress:completed:]_block_invoke_2 + 1855 at SDWebImageManager.m:244, address = 0x000000010d762bdf, resolved, hit count = 0 9: file = ‘/Users/cykj/Desktop/Demo/Demo/ViewController.m’, line = 123, exact_match = 0, locations = 1, resolved = 1, hit count = 1 9.1: where = Demo`-[ViewController viewDidLoad] + 23 at ViewController.m:123, address = 0x000000010d6cbda7, resolved, hit count = 1 10: name = ‘cfunc’, locations = 0 (pending) 11: name = ‘cfunc’, locations = 0 (pending) 12: name = ‘main’, locations = 1, resolved = 1, hit count = 0 12.1: where = JavaScriptCore`WTF::RunLoop::main(), address = 0x000000011e18b060, resolved, hit count = 0… 我们可以对断点进行相关的操作，比如在执行到 2.1 断点的时候打印追踪轨迹。 (lldb) breakpoint command add 2.1Enter your debugger command(s). Type ‘DONE’ to end.> bt> DONE 除了 add，还要 delete 等命令，使用 help 命令查找这些命令。 (lldb) help break command Commands for adding, removing and listing LLDB commands executed when a breakpoint is hit. Syntax: command [] The following subcommands are supported: add -- Add LLDB commands to a breakpoint, to be executed whenever the breakpoint is hit. If no breakpoint is specified, adds the commands to the last created breakpoint. delete -- Delete the set of commands from a breakpoint. list -- List the script or set of commands to be executed when the breakpoint is hit. For more help on any particular subcommand, type ‘help ‘. 要查看更详细的命令用途，使用 help 。比如查看 add 命令用法 help break command add Add LLDB commands to a breakpoint, to be executed whenever the breakpoint is hit. If no breakpoint is specified, adds the commands to the last created breakpoint. Syntax: breakpoint command add [] Command Options Usage: breakpoint command add [-D] [-o ] [-e ] [-s ] [] breakpoint command add [-D] [-e ] [-s ] [-F ] [] -D ( --dummy-breakpoints ) Sets Dummy breakpoints - i.e. breakpoints set before a file is provided, which prime new targets. -F &lt;python-function&gt; ( --python-function &lt;python-function&gt; ) Give the name of a Python function to run as command for this breakpoint. Be sure to give a module name if appropriate. -e &lt;boolean&gt; ( --stop-on-error &lt;boolean&gt; ) Specify whether breakpoint command execution should terminate on error. -o &lt;one-line-command&gt; ( --one-liner &lt;one-line-command&gt; ) Specify a one-line breakpoint command inline. Be sure to surround it with quotes. -s &lt;none&gt; ( --script-type &lt;none&gt; ) Specify the language for the commands - if none is specified, the lldb command interpreter will be used. Values: command | python | default-script General information about entering breakpoint commands------------------------------------------------------ This command will prompt for commands to be executed when the specifiedbreakpoint is hit. Each command is typed on its own line following the ‘&gt; ‘prompt until ‘DONE’ is entered. Syntactic errors may not be detected when initially entered, and many malformedcommands can silently fail when executed. If your breakpoint commands do notappear to be executing, double-check the command syntax. Note: You may enter any debugger command exactly as you would at the debuggerprompt. There is no limit to the number of commands supplied, but do NOT entermore than one command per line. Special information about PYTHON breakpoint commands---------------------------------------------------- You may enter either one or more lines of Python, including functiondefinitions or calls to functions that will have been imported by the time thecode executes. Single line breakpoint commands will be interpreted ‘as is’when the breakpoint is hit. Multiple lines of Python will be wrapped in agenerated function, and a call to the function will be attached to thebreakpoint. This auto-generated function is passed in three arguments: frame: an lldb.SBFrame object for the frame which hit breakpoint. bp_loc: an lldb.SBBreakpointLocation object that represents the breakpoint location that was hit. dict: the python session dictionary hit. When specifying a python function with the –python-function option, you needto supply the function name prepended by the module name: --python-function myutils.breakpoint_callback The function itself must have the following prototype: def breakpoint_callback(frame, bp_loc, dict): Your code goes hereThe arguments are the same as the arguments passed to generated functions asdescribed above. Note that the global variable ‘lldb.frame’ will NOT beupdated when this function is called, so be sure to use the ‘frame’ argument.The ‘frame’ argument can get you to the thread via frame.GetThread(), thethread can get you to the process via thread.GetProcess(), and the process canget you back to the target via process.GetTarget(). Important Note: As Python code gets collected into functions, access to globalvariables requires explicit scoping using the ‘global’ keyword. Be sure to usecorrect Python syntax, including indentation, when entering Python breakpointcommands. Example Python one-line breakpoint command: (lldb) breakpoint command add -s python 1Enter your Python command(s). Type ‘DONE’ to end.> print “Hit this breakpoint!”> DONE As a convenience, this also works for a short Python one-liner: (lldb) breakpoint command add -s python 1 -o ‘import time; print time.asctime()’(lldb) runLaunching ‘…/a.out’ (x86_64)(lldb) Fri Sep 10 12:17:45 2010Process 21778 Stopped* thread #1: tid = 0x2e03, 0x0000000100000de8 a.out`c + 7 at main.c:39, stopreason = breakpoint 1.1, queue = com.apple.main-thread 36 37 int c(int val) 38 { 39 -&gt; return val + 3; 40 } 41 42 int main (int argc, char const *argv[]) Example multiple line Python breakpoint command: (lldb) breakpoint command add -s p 1Enter your Python command(s). Type ‘DONE’ to end.> global bp_count> bp_count = bp_count + 1> print “Hit this breakpoint “ + repr(bp_count) + “ times!”> DONE Example multiple line Python breakpoint command, using function definition: (lldb) breakpoint command add -s python 1Enter your Python command(s). Type ‘DONE’ to end.> def breakpoint_output (bp_no):> out_string = “Hit breakpoint number “ + repr (bp_no)> print out_string> return True> breakpoint_output (1)> DONE In this case, since there is a reference to a global variable, ‘bp_count’, youwill also need to make sure ‘bp_count’ exists and is initialized: (lldb) script > bp_count = 0> quit() Your Python code, however organized, can optionally return a value. If thereturned value is False, that tells LLDB not to stop at the breakpoint to whichthe code is associated. Returning anything other than False, or even returningNone, or even omitting a return statement entirely, will cause LLDB to stop. Final Note: A warning that no breakpoint command was generated when there areno syntax errors may indicate that a function was declared but never called. This command takes options and free-form arguments. If your arguments resemble option specifiers (i.e., they start with a - or --), you must use &apos; \\-\\- &apos; between the end of the command options and the beginning of the arguments. 这里面的命令大部分是 Python 脚本。 5、删除断点 breakpoint delete [-Df] [] 用 breakpoint list 查进程中所有的断点。 (lldb) breakpoint listCurrent breakpoints:1: file = ‘/Users/cykj/Desktop/Demo/Demo/ImageSource/HookTool.m’, line = 172, exact_match = 0, locations = 0 (pending) 2: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 205, exact_match = 0, locations = 4, resolved = 4, hit count = 0 2.1: where = SDWebImage-\\[SDWebImageDownloaderOperation start\\] + 218 at SDWebImageDownloaderOperation.m:205, address = 0x000000010293d44a, resolved, hit count = 0 2.2: where = SDWebImage-[SDWebImageDownloaderOperation start] + 761 at SDWebImageDownloaderOperation.m:205, address = 0x000000010293d669, resolved, hit count = 0 2.3: where = SDWebImage-\\[SDWebImageDownloaderOperation start\\] + 1797 at SDWebImageDownloaderOperation.m:205, address = 0x000000010293da75, resolved, hit count = 0 2.4: where = SDWebImage-[SDWebImageDownloaderOperation start] + 3999 at SDWebImageDownloaderOperation.m:205, address = 0x000000010293e30f, resolved, hit count = 0 3: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 400, exact_match = 0, locations = 1, resolved = 1, hit count = 0 3.1: where = SDWebImage`-[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:] + 660 at SDWebImageDownloaderOperation.m:400, address = 0x0000000102940a34, resolved, hit count = 0 4: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageDownloaderOperation.m’, line = 444, exact_match = 0, locations = 2, resolved = 2, hit count = 0 4.1: where = SDWebImage-\\[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:\\] + 1345 at SDWebImageDownloaderOperation.m:445, address = 0x0000000102940ce1, resolved, hit count = 0 4.2: where = SDWebImage-[SDWebImageDownloaderOperation URLSession:task:didCompleteWithError:] + 1986 at SDWebImageDownloaderOperation.m:445, address = 0x0000000102940f62, resolved, hit count = 0 5: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 176, exact_match = 0, locations = 1, resolved = 1, hit count = 0 5.1: where = SDWebImage`__65-[SDWebImageManager loadImageWithURL:options:progress:completed:]_block_invoke + 615 at SDWebImageManager.m:176, address = 0x0000000102947a97, resolved, hit count = 0 6: file = ‘/Users/cykj/Desktop/Demo/Pods/SDWebImage/SDWebImage/SDWebImageManager.m’, line = 342, exact_match = 0, locations = 1, resolved = 1, hit count = 0 6.1: where = SDWebImage`-[SDWebImageManager callCompletionBlockForOperation:completion:image:data:error:cacheType:finished:url:] + 283 at SDWebImageManager.m:344, address = 0x000000010294a1ab, resolved, hit count = 0 … 11: name = ‘alloc’, locations = 113, resolved = 113, hit count = 0 11.1: where = Foundation+\\[NSHashTable alloc\\], address = 0x00000001029ef758, resolved, hit count = 0 11.2: where = Foundation+[NSMapTable alloc], address = 0x0000000102a2a8cc, resolved, hit count = 0 11.3: where = Foundation`+[NSProxy alloc], address = 0x0000000102a579d6, resolved, hit count = 0 … 若要删除 11.1 断点（无法删除？）： (lldb) breakpoint delete 11.10 breakpoints deleted; 1 breakpoint locations disabled. 删除 11 下面所有的断点，这样 11.1 和 11.2 都会删除。 (lldb) breakpoint delete 111 breakpoints deleted; 0 breakpoint locations disabled. 删除所有的断点： (lldb) breakpoint deleteAbout to delete all breakpoints, do you want to do that?: [Y/n] yAll breakpoints removed. (10 breakpoints) 二、watchpoint1、观察变量值的具体变化。 @interface ViewController (){ NSInteger _num; // 观察的对象} (lldb) watchpoint set variable _numWatchpoint created: Watchpoint 1: addr = 0x7fcdab864a28 size = 8 state = enabled type = w watchpoint spec = ‘_num’ new value: 0 也可以在这里添加： 当执行到修改 _num 值的代码时，会输出： - (void)viewDidLoad{ [super viewDidLoad]; _num = 10; } Watchpoint 1 hit:old value: 0new value: 10 我们可以设置在 _num 的值变化为某个特定值之后触发： - (void)viewDidLoad{ // xcode 左侧设置断点 p1 [super viewDidLoad]; _num = 10; _num = 20; // xcode 左侧设置断点 p2 _num = 200; _num = 100; } (lldb) watchpoint set variable _numWatchpoint created: Watchpoint 1: addr = 0x7f87c103d428 size = 8 state = enabled type = w watchpoint spec = ‘_num’ new value: 0 Watchpoint 1 hit:old value: 0new value: 10 Watchpoint 1 hit:old value: 10new value: 20(lldb) watchpoint modify -c ‘(_num==100)’ Watchpoint 1 hit:old value: 20new value: 100 断点 p1 时在 lldb 执行 watchpoint set variable _num，继续向下执行，此时没有条件限制，每次设置 _num 都会触发观察；到达断点 p2 时 lldb 执行 watchpoint modify -c ‘(_num==100)’，向下执行，此时有了条件 _num == 100 才会触发，所以跳过了 _num = 200 的控制输出。 2、查看具体断点的参数 (lldb) watchpoint listNumber of supported hardware watchpoints: 4Current watchpoints:Watchpoint 1: addr = 0x7f87c103d428 size = 8 state = enabled type = w watchpoint spec = ‘_num’ old value: 20 new value: 100 condition = ‘(_num==100)’ 可以看到我们观察的变量的地址，声明变量的代码在第几行，以及具体的变量名是 _num，当前的值是 100，触发的条件是 ‘(_num==100)’。 然后我们执行如下命令，就可以看到断点到 _num 的值变为 100 的地方。 (lldb) cProcess 95917 resuming Watchpoint 1 hit:old value: 0new value: 100 可以看到这个地方 _num 的值已经发生改变。我们可以再使用 watchpoint list 命令看看具体值的变化 (lldb) watchpoint listNumber of supported hardware watchpoints: 4Current watchpoints:Watchpoint 1: addr = 0x7f9d4884b628 size = 8 state = enabled type = w watchpoint spec = ‘_num’ old value: 0 new value: 100 condition = ‘(_num = 100)’ 注意这里用的 _num = 100，不是上面的 _num==100，两个条件不同。 watchpoint list 命令包括了三个可选参数，我们可以使用 help 命令查看具体的值。 (lldb) help watchpoint list List all watchpoints at configurable levels of detail. Syntax: watchpoint list [] Command Options Usage: watchpoint list [-b] [] watchpoint list [-f] [] watchpoint list [-v] [] -b ( --brief ) Give a brief description of the watchpoint (no location info). -f ( --full ) Give a full description of the watchpoint and its locations. -v ( --verbose ) Explain everything we know about the watchpoint (for debugging debugger bugs). This command takes options and free-form arguments. If your arguments resemble option specifiers (i.e., they start with a - or --), you must use &apos; \\-\\- &apos; between the end of the command options and the beginning of the arguments. -b 是比较简略的信息，-f 是比较全面的信息，-v 是完整的信息。经过实验，watchpoint list 默认的是 -f。 3、用 bt 命令来追踪程序运行的过程 (lldb) bt* thread #1, queue = ‘com.apple.main-thread’, stop reason = watchpoint 1 * frame #0: 0x0000000106cc43fd Demo-\\[ViewController viewDidLoad\\](self=0x00007f9d4884b200, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:0 frame #1: 0x00000001153d24e1 UIKitCore-[UIViewController loadViewIfRequired] + 1186 frame #2: 0x0000000115332104 UIKitCore-\\[UINavigationController _updateScrollViewFromViewController:toViewController:\\] + 68 frame #3: 0x00000001153323f8 UIKitCore-[UINavigationController _startTransition:fromViewController:toViewController:] + 147 frame #4: 0x000000011533348b UIKitCore-\\[UINavigationController _startDeferredTransitionIfNeeded:\\] + 896 frame #5: 0x00000001153347e0 UIKitCore-[UINavigationController viewWillLayoutSubviews] + 150 frame #6: 0x0000000115314600 UIKitCore-\\[UILayoutContainerView layoutSubviews\\] + 217 frame #7: 0x0000000115edb795 UIKitCore-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1441 frame #8: 0x000000010ecc7b19 QuartzCore-\\[CALayer layoutSublayers\\] + 175 frame #9: 0x000000010eccc9d3 QuartzCoreCA::Layer::layout_if_needed(CA::Transaction) + 395 frame #10: 0x000000010ec457ca QuartzCore`CA::Context::commit_transaction(CA::Transaction) + 342 frame #11: 0x000000010ec7c97e QuartzCoreCA::Transaction::commit() + 576 frame #12: 0x0000000115a0c2d0 UIKitCore__34-[UIApplication _firstCommitBlock]_block_invoke_2 + 139 frame #13: 0x000000010813f62c CoreFoundation\\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_ + 12 frame #14: 0x000000010813ede0 CoreFoundationCFRunLoopDoBlocks + 336 frame #15: 0x0000000108139654 CoreFoundation__CFRunLoopRun + 1284 frame #16: 0x0000000108138e11 CoreFoundationCFRunLoopRunSpecific + 625 frame #17: 0x000000010eb4a1dd GraphicsServicesGSEventRunModal + 62 frame #18: 0x00000001159f181d UIKitCoreUIApplicationMain + 140 frame #19: 0x0000000106cc4c70 Demomain(argc=1, argv=0x00007ffee8f3c068) at main.m:17 frame #20: 0x000000010a7a3575 libdyld.dylibstart + 1 frame #21: 0x000000010a7a3575 libdyld.dylib`start + 1 4、使用 frame 命令查看变量 _num 的具体值 (lldb) frame variable _num(NSInteger) _num = 100 三、process使用 process 命令也可以做很多有趣的操作。具体能做什么，我们也可使用 help 命令查看 (lldb) help process Commands for interacting with processes on the current platform. Syntax: process [] The following subcommands are supported: attach -- Attach to a process. connect -- Connect to a remote debug service. continue -- Continue execution of all threads in the current process. detach -- Detach from the current target process. handle -- Manage LLDB handling of OS signals for the current target process. Defaults to showing current policy. interrupt -- Interrupt the current target process. kill -- Terminate the current target process. launch -- Launch the executable in the debugger. load -- Load a shared library into the current process. plugin -- Send a custom command to the current target process plug-in. save-core -- Save the current process as a core file using an appropriate file type. signal -- Send a UNIX signal to the current target process. status -- Show status and stop location for the current target process. unload -- Unload a shared library from the current process using the index returned by a previous call to &quot;process load&quot;. For more help on any particular subcommand, type ‘help ‘. 查看更详细的命令使用 help 。比如 (lldb) help process attach Attach to a process. Syntax: process attach Command Options Usage: process attach [-c] [-P ] [-p ] process attach [-ciw] [-P ] [-n ] -P &lt;plugin&gt; ( --plugin &lt;plugin&gt; ) Name of the process plugin you want to use. -c ( --continue ) Immediately continue the process once attached. -i ( --include-existing ) Include existing processes when doing attach -w. -n &lt;process-name&gt; ( --name &lt;process-name&gt; ) The name of the process to attach to. -p &lt;pid&gt; ( --pid &lt;pid&gt; ) The process ID of an existing process to attach to. -w ( --waitfor ) Wait for the process with &lt;process-name&gt; to launch. 四、thread其实这个功能主要就是断点调试里面的如下这个功能。 我们可以使用 thread 命令来做一些断点的操作，具体有那些命令我们可以使用 thread help 进行查看。 (lldb) thread help Commands for operating on one or more threads in the current process. Syntax: thread [] The following subcommands are supported: backtrace -- Show thread call stacks. Defaults to the current thread, thread indexes can be specified as arguments. Use the thread-index &quot;all&quot; to see all threads. Use the thread-index &quot;unique&quot; to see threads grouped by unique call stacks. continue -- Continue execution of the current target process. One or more threads may be specified, by default all threads continue. info -- Show an extended summary of one or more threads. Defaults to the current thread. jump -- Sets the program counter to a new address. list -- Show a summary of each thread in the current target process. plan -- Commands for managing thread plans that control execution. return -- Prematurely return from a stack frame, short-circuiting execution of newer frames and optionally yielding a specified value. Defaults to the exiting the current stack frame. Expects &apos;raw&apos; input (see &apos;help raw-input&apos;.) select -- Change the currently selected thread. step-in -- Source level single step, stepping into calls. Defaults to current thread unless specified. step-inst -- Instruction level single step, stepping into calls. Defaults to current thread unless specified. step-inst-over -- Instruction level single step, stepping over calls. Defaults to current thread unless specified. step-out -- Finish executing the current stack frame and stop after returning. Defaults to current thread unless specified. step-over -- Source level single step, stepping over calls. Defaults to current thread unless specified. step-scripted -- Step as instructed by the script class passed in the -C option. until -- Continue until a line number or address is reached by the current or specified thread. Stops when returning from the current function as a safety measure. The target line number(s) are given as arguments, and if more than one is provided, stepping will stop when the first one is hit. For more help on any particular subcommand, type ‘help ‘. 用得比较多的应该是 step 前缀的几个命令，使用起来很容易。个人感觉比用鼠标点击断点好用多了。 EXAMINING THREAD STATE 这个使用的也主要还是 thread 命令，主要是使用以下几个命令。 1、检查当前进程的状态 (lldb) thread listProcess 97464 stopped* thread #1: tid = 0x788f30, 0x000000010016a3c8 Demo-\\[ViewController viewDidLoad\\](self=0x00007fde09024c00, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:125, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1 thread #2: tid = 0x788f6c, 0x000000010402728a libsystem\\_kernel.dylib__workq_kernreturn + 10 thread #3: tid = 0x788f6d, 0x000000010402728a libsystem_kernel.dylib\\_\\_workq_kernreturn + 10 thread #4: tid = 0x788f6e, 0x000000010402728a libsystem\\_kernel.dylib__workq_kernreturn + 10 thread #5: tid = 0x788f6f, 0x000000010402728a libsystem_kernel.dylib\\_\\_workq_kernreturn + 10 thread #6: tid = 0x788f76, 0x000000010401d20a libsystem\\_kernel.dylibmach_msg_trap + 10, name = ‘com.apple.uikit.eventfetch-thread’ thread #7: tid = 0x788f79, 0x000000010405cbdc libsystem_pthread.dylib`start_wqthread *表明的就是当前的线程。 2、当前线程的堆栈（回溯、追踪） (lldb) thread backtrace* thread #1, queue = ‘com.apple.main-thread’, stop reason = breakpoint 1.1 * frame #0: 0x000000010016a3c8 Demo-\\[ViewController viewDidLoad\\](self=0x00007fde09024c00, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:125 frame #1: 0x000000010e8764e1 UIKitCore-[UIViewController loadViewIfRequired] + 1186 frame #2: 0x000000010e7d6104 UIKitCore-\\[UINavigationController _updateScrollViewFromViewController:toViewController:\\] + 68 frame #3: 0x000000010e7d63f8 UIKitCore-[UINavigationController _startTransition:fromViewController:toViewController:] + 147 frame #4: 0x000000010e7d748b UIKitCore-\\[UINavigationController _startDeferredTransitionIfNeeded:\\] + 896 frame #5: 0x000000010e7d87e0 UIKitCore-[UINavigationController viewWillLayoutSubviews] + 150 frame #6: 0x000000010e7b8600 UIKitCore-\\[UILayoutContainerView layoutSubviews\\] + 217 frame #7: 0x000000010f37f795 UIKitCore-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1441 frame #8: 0x000000010820bb19 QuartzCore-\\[CALayer layoutSublayers\\] + 175 frame #9: 0x00000001082109d3 QuartzCoreCA::Layer::layout_if_needed(CA::Transaction) + 395 frame #10: 0x00000001081897ca QuartzCore`CA::Context::commit_transaction(CA::Transaction) + 342 frame #11: 0x00000001081c097e QuartzCoreCA::Transaction::commit() + 576 frame #12: 0x000000010eeb02d0 UIKitCore__34-[UIApplication _firstCommitBlock]_block_invoke_2 + 139 frame #13: 0x00000001015e562c CoreFoundation\\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_ + 12 frame #14: 0x00000001015e4de0 CoreFoundationCFRunLoopDoBlocks + 336 frame #15: 0x00000001015df654 CoreFoundation__CFRunLoopRun + 1284 frame #16: 0x00000001015dee11 CoreFoundationCFRunLoopRunSpecific + 625 frame #17: 0x000000010808e1dd GraphicsServicesGSEventRunModal + 62 frame #18: 0x000000010ee9581d UIKitCoreUIApplicationMain + 140 frame #19: 0x000000010016ac70 Demomain(argc=1, argv=0x00007ffeefa96068) at main.m:17 frame #20: 0x0000000103cec575 libdyld.dylibstart + 1 frame #21: 0x0000000103cec575 libdyld.dylib`start + 1 3、查看所有线程的 backtrace (lldb) thread backtrace all* thread #1, queue = ‘com.apple.main-thread’, stop reason = breakpoint 1.1 * frame #0: 0x000000010016a3c8 Demo-\\[ViewController viewDidLoad\\](self=0x00007fde09024c00, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:125 frame #1: 0x000000010e8764e1 UIKitCore-[UIViewController loadViewIfRequired] + 1186 frame #2: 0x000000010e7d6104 UIKitCore-\\[UINavigationController _updateScrollViewFromViewController:toViewController:\\] + 68 frame #3: 0x000000010e7d63f8 UIKitCore-[UINavigationController _startTransition:fromViewController:toViewController:] + 147 frame #4: 0x000000010e7d748b UIKitCore-\\[UINavigationController _startDeferredTransitionIfNeeded:\\] + 896 frame #5: 0x000000010e7d87e0 UIKitCore-[UINavigationController viewWillLayoutSubviews] + 150 frame #6: 0x000000010e7b8600 UIKitCore-\\[UILayoutContainerView layoutSubviews\\] + 217 frame #7: 0x000000010f37f795 UIKitCore-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1441 frame #8: 0x000000010820bb19 QuartzCore-\\[CALayer layoutSublayers\\] + 175 frame #9: 0x00000001082109d3 QuartzCoreCA::Layer::layout_if_needed(CA::Transaction) + 395 frame #10: 0x00000001081897ca QuartzCore`CA::Context::commit_transaction(CA::Transaction) + 342 frame #11: 0x00000001081c097e QuartzCoreCA::Transaction::commit() + 576 frame #12: 0x000000010eeb02d0 UIKitCore__34-[UIApplication _firstCommitBlock]_block_invoke_2 + 139 frame #13: 0x00000001015e562c CoreFoundation\\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_ + 12 frame #14: 0x00000001015e4de0 CoreFoundationCFRunLoopDoBlocks + 336 frame #15: 0x00000001015df654 CoreFoundation__CFRunLoopRun + 1284 frame #16: 0x00000001015dee11 CoreFoundationCFRunLoopRunSpecific + 625 frame #17: 0x000000010808e1dd GraphicsServicesGSEventRunModal + 62 frame #18: 0x000000010ee9581d UIKitCoreUIApplicationMain + 140 frame #19: 0x000000010016ac70 Demomain(argc=1, argv=0x00007ffeefa96068) at main.m:17 frame #20: 0x0000000103cec575 libdyld.dylibstart + 1 frame #21: 0x0000000103cec575 libdyld.dylibstart + 1 thread #2 frame #0: 0x000000010402728a libsystem\\_kernel.dylib__workq_kernreturn + 10 frame #1: 0x000000010405d009 libsystem_pthread.dylib\\_pthread_wqthread + 1035 frame #2: 0x000000010405cbe9 libsystem\\_pthread.dylibstart_wqthread + 13 thread #3 frame #0: 0x000000010402728a libsystem_kernel.dylib\\_\\_workq_kernreturn + 10 frame #1: 0x000000010405d009 libsystem\\_pthread.dylib_pthread_wqthread + 1035 frame #2: 0x000000010405cbe9 libsystem_pthread.dylibstart\\_wqthread + 13 thread #4 frame #0: 0x000000010402728a libsystem\\_kernel.dylib__workq_kernreturn + 10 frame #1: 0x000000010405d009 libsystem_pthread.dylib\\_pthread_wqthread + 1035 frame #2: 0x000000010405cbe9 libsystem\\_pthread.dylibstart_wqthread + 13 thread #5 frame #0: 0x000000010402728a libsystem_kernel.dylib\\_\\_workq_kernreturn + 10 frame #1: 0x000000010405d009 libsystem\\_pthread.dylib_pthread_wqthread + 1035 frame #2: 0x000000010405cbe9 libsystem_pthread.dylibstart\\_wqthread + 13 thread #6, name = &#39;com.apple.uikit.eventfetch-thread&#39; frame #0: 0x000000010401d20a libsystem\\_kernel.dylibmach_msg_trap + 10 frame #1: 0x000000010401c724 libsystem_kernel.dylibmach\\_msg + 60 frame #2: 0x00000001015e51b4 CoreFoundationCFRunLoopServiceMachPort + 212 frame #3: 0x00000001015df7e9 CoreFoundation`CFRunLoopRun + 1689 frame #4: 0x00000001015dee11 CoreFoundationCFRunLoopRunSpecific + 625 frame #5: 0x00000001006a2322 Foundation-[NSRunLoop(NSRunLoop) runMode:beforeDate:] + 277 frame #6: 0x00000001006a24f4 Foundation-\\[NSRunLoop(NSRunLoop) runUntilDate:\\] + 79 frame #7: 0x000000010ef8cbcb UIKitCore-[UIEventFetcher threadMain] + 118 frame #8: 0x00000001006b7732 Foundation\\_\\_NSThread\\_\\_start__ + 1221 frame #9: 0x000000010405d661 libsystem\\_pthread.dylib_pthread_body + 340 frame #10: 0x000000010405d50d libsystem_pthread.dylib\\_pthread_start + 377 frame #11: 0x000000010405cbf9 libsystem\\_pthread.dylibthread_start + 13 thread #7 frame #0: 0x000000010405cbdc libsystem_pthread.dylib`start_wqthread 4、单独查看某个线程 (lldb) thread select 3(lldb) thread backtrace* thread #3 * frame #0: 0x000000010402728a libsystem_kernel.dylib\\_\\_workq_kernreturn + 10 frame #1: 0x000000010405d009 libsystem\\_pthread.dylib_pthread_wqthread + 1035 frame #2: 0x000000010405cbe9 libsystem_pthread.dylib`start_wqthread + 13 五、FrameEXAMINING STACK FRAME STATE 1、观测架构参数和本地变量 如果什么参数也不加，将会把所有的参数和本地变量到打印出来。 (lldb) thread select 1(lldb) frame variable(ViewController ) self = 0x00007fde09024c00(SEL) _cmd = “viewDidLoad”(CFBinaryHeapCallBacks) callBacks = { version = 0 retain = 0x0000000000000000 release = 0x4084d80000000000 (0x4084d80000000000) copyDescription = 0x0000000000000000 compare = 0x4090480000000000 (0x4090480000000000)}(__NSTaggedDate ) p1 = 0x8000000000000000(NSTaggedPointerString ) p2 = 0xc145315880000000 @”pgrI0tf031”(Person ) p3 = nil(Person ) p4 = nil(NSInteger) count = 0(const void **) list = 0x0000000000000000(CFArrayRef) objects = 0x8000000000000000(NSArray ) arr = 0x0000000000000001 注意：如果之前执行了 thread select x，那么是在 x 线程执行 frame 命令。 2、打印某个变量及它的子元素 (lldb) frame variable(ViewController ) self = 0x00007fde09024c00(SEL) _cmd = “viewDidLoad”(CFBinaryHeapCallBacks) callBacks = { version = 0 retain = 0x0000000000000000 release = 0x4084d80000000000 (0x4084d80000000000) copyDescription = 0x0000000000000000 compare = 0x4090480000000000 (0x4090480000000000)}(__NSTaggedDate ) p1 = 0x8000000000000000(NSTaggedPointerString ) p2 = 0xc145315880000000 @”pgrI0tf031”(Person ) p3 = nil(Person ) p4 = nil(NSInteger) count = 0(const void **) list = 0x0000000000000000(CFArrayRef) objects = 0x8000000000000000(NSArray ) arr = 0x0000000000000001(lldb) frame variable self(ViewController *) self = 0x00007fde09024c00(lldb) frame variable self-&gt;isa(Class) self-&gt;isa = ViewController 命令虽然不是完整的表达式解释器，但可以识别一些基本的操作，比如 &amp;, *, -&gt;, []，不是重载运算符，数组也可以使用，因为数组本身也是指针。 (lldb) frame variable self(ViewController) self = { UIViewController = { UIResponder = { NSObject = { isa = ViewController } } _overrideTransitioningDelegate = nil _view = 0x00007fde0740c230 _tabBarItem = 0x00007fde0750a530 _navigationItem = 0x00007fde0770f8e0 _toolbarItems = nil _title = nil _nibName = 0x000060000101aee0 @”BYZ-38-t0r-view-8bC-Xf-vdC” _nibBundle = 0x0000600003d40b90 @”/Users/cykj/Library/Developer/CoreSimulator/Devices/5EA7E32E-0543-406C-A9D1-1917DEB0F3A3/data/Containers/Bundle/Application/0FF04E7A-851D-4E4D-970F-F6D775E759FF/Demo.app” _parentViewController = 0x00007fde09043000 _childModalViewController = nil _parentModalViewController = nil _previousRootViewController = nil _modalTransitionView = nil _modalPreservedFirstResponder = nil _dimmingView = nil _dropShadowView = nil _currentAction = nil _storyboard = 0x0000600000b01980 _externalObjectsTableForViewLoading = 0x0000600001c54080 _topLevelObjectsToKeepAliveFromStoryboard = nil _savedHeaderSuperview = nil _savedFooterSuperview = nil _editButtonItem = nil _searchDisplayController = nil _strongSearchDisplayController = nil _modalTransitionStyle = 0 _modalPresentationStyle = 0 _lastKnownInterfaceOrientation = 0 _popoverController = nil _containerViewInSheet = nil _recordedContentScrollView = nil _afterAppearance = nil _explicitAppearanceTransitionLevel = 0 _interfaceBuilderKeyCommands = nil _addedKeyCommands = nil _overrideTraitCollectionsForChildren = nil _previewSourceViews = nil _retainCount = 10 _ignoreAppSupportedOrientations = false _viewHostsLayoutEngine = false _storyboardIdentifier = 0x0000600001e15540 @”ViewController” _transitioningDelegate = nil _frozenTraitCollection = nil _overrideTraitCollection = nil _accessibilityHUD = nil overrideUseCustomPresentation = false _modalPresentationCapturesStatusBarAppearance = false _ignoresParentMargins = false _childViewControllers = nil _customNavigationInteractiveTransitionDuration = 0 _customNavigationInteractiveTransitionPercentComplete = 0 _customTransitioningView = nil _lastNotifiedTraitCollection = nil _presentationController = nil _navigationControllerContentOffsetAdjustment = 0 _leftContentMargin = 0 _rightContentMargin = 0 _contentMargin = 16 _topLayoutGuide = 0x00007fde07408bb0 _bottomLayoutGuide = 0x00007fde07404080 _topBarInsetGuideConstraint = 0x0000600003d76800 _bottomBarInsetGuideConstraint = 0x0000600003d75130 _storyboardSegueTemplates = nil _segueResponsibleForModalPresentation = nil _sourceViewControllerIfPresentedViaPopoverSegue = nil _modalSourceViewController = nil _expectedWindow = nil _presentedStatusBarViewController = nil _presentedUserInterfaceStyleViewController = nil _edgesForExtendedLayout = 15 childControllerToIgnoreWhileLookingForTransitionCoordinator = nil _presentingFocusedItem = nil _navigationInsetAdjustment = nil _storyboardPreviewSegueTemplates = nil _storyboardCommitSegueTemplates = nil _storyboardPreviewingRegistrants = nil embeddedView = nil embeddingView = nil embeddedDelegate = nil _originalPresentationController = nil _temporaryPresentationController = nil _preferredFocusedItem = nil } _heap = 0x0000000000000000 _dict = nil _rwlock = (__sig = 0, __opaque = “”) _num = 0 _needRegister = NO _data = nil _thread = nil} 3、选择另外的一个 frame (lldb) frame select 9frame #9: 0x00000001082109d3 QuartzCoreCA::Layer::layout\\_if\\_needed(CA::Transaction*) + 395 QuartzCoreCA::Layer::layout_if_needed: 0x1082109d3 &lt;+395&gt;: movq 0x8(%rbx), %rbx 0x1082109d7 &lt;+399&gt;: testq %rbx, %rbx 0x1082109da &lt;+402&gt;: jne 0x1082109b0 ; &lt;+360&gt; 0x1082109dc &lt;+404&gt;: testq %r14, %r14 六、expression看更复杂的数据 (lldb) frame select 0frame #0: 0x000000010016a3c8 Demo`-[ViewController viewDidLoad](self=0x00007fde09024c00, _cmd=”viewDidLoad”) at ViewController.m:125 122 123 - (void)viewDidLoad 124 {-> 125 \u001b[4m[\u001b[0msuper viewDidLoad]; 126 127 _num = 10; 128(lldb) expression self(ViewController *) $0 = 0x00007fde09024c00 更复杂一些，可以用来输出一个表达式： (lldb) expr (int) printf (“I have a pointer 0x%llx.\\n”, self)I have a pointer 0x7fde09024c00.(int) $1 = 33 继续以之前的命令来操作： (lldb) expr self = $0(ViewController *) $2 = 0x00007fde09024c00 七、call其实这个命令完全可以使用 po 进行替代，call 一般可以用来调用不需要返回值的调试命令，比如更改 View 的背景颜色。以下两个命令都可以达到相似的作用，更改当前 View 的背景颜色值。 (lldb) po [self.view setBackgroundColor:[UIColor redColor]](lldb) call [self.view setBackgroundColor:[UIColor greenColor]] 原本没有设置颜色的视图，会被设置成颜色。 八、image这是一个比较重要也比较实用的命令。命令可用于寻址。比较实用的用法是用于寻找栈地址对应的代码位置。 NSArray * arr = [[NSArray alloc] initWithObjects:@”1”, @”2”, nil]; NSLog(@”%@”, arr[2]); 可以很明显的看到数组越界了。运行程序，程序崩溃报如下错误： 2019-04-03 14:10:13.975574+0800 Demo[97853:7915627] Terminating app due to uncaught exception ‘NSRangeException’, reason: ‘ -[NSArrayI objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1]‘*** First throw call stack:( 0 CoreFoundation 0x000000010e1b31bb exceptionPreprocess + 331 1 libobjc.A.dylib 0x000000010d751735 objc_exception_throw + 48 2 CoreFoundation 0x000000010e0ff4ec _CFThrowFormattedException + 194 3 CoreFoundation 0x000000010e235b00 +[NSArrayI allocWithZone:] + 0 4 Demo 0x000000010cc9d4c5 -[ViewController viewDidLoad] + 181 5 UIKitCore 0x000000011b3aa4e1 -[UIViewController loadViewIfRequired] + 1186 6 UIKitCore 0x000000011b30a104 -[UINavigationController _updateScrollViewFromViewController:toViewController:] + 68 7 UIKitCore 0x000000011b30a3f8 -[UINavigationController _startTransition:fromViewController:toViewController:] + 147 8 UIKitCore 0x000000011b30b48b -[UINavigationController _startDeferredTransitionIfNeeded:] + 896 9 UIKitCore 0x000000011b30c7e0 -[UINavigationController viewWillLayoutSubviews] + 150 10 UIKitCore 0x000000011b2ec600 -[UILayoutContainerView layoutSubviews] + 217 11 UIKitCore 0x000000011beb3795 -[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1441 12 QuartzCore 0x0000000114de9b19 -[CALayer layoutSublayers] + 175 13 QuartzCore 0x0000000114dee9d3 _ZN2CA5Layer16layout_if_neededEPNS_11TransactionE + 395 14 QuartzCore 0x0000000114d677ca _ZN2CA7Context18commit_transactionEPNS_11TransactionE + 342 15 QuartzCore 0x0000000114d9e97e ZN2CA11Transaction6commitEv + 576 16 UIKitCore 0x000000011b9e42d0 \\_34-[UIApplication _firstCommitBlock]_block_invoke_2 + 139 17 CoreFoundation 0x000000010e11862c __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12 18 CoreFoundation 0x000000010e117de0 CFRunLoopDoBlocks + 336 19 CoreFoundation 0x000000010e112654 CFRunLoopRun + 1284 20 CoreFoundation 0x000000010e111e11 CFRunLoopRunSpecific + 625 21 GraphicsServices 0x000000011394d1dd GSEventRunModal + 62 22 UIKitCore 0x000000011b9c981d UIApplicationMain + 140 23 Demo 0x000000010cc9dc80 main + 112 24 libdyld.dylib 0x000000011077c575 start + 1)libc++abi.dylib: terminating with uncaught exception of type NSException 我们大概可以猜测程序是崩溃在第四行 log，也就是地址为 0x000000010cc9d4c5的地方。因为工程名叫 Demo，其他的名字很明显是系统的库。虽然 log 的 23 行也有 Demo，但它是 main 函数，不在考虑范围之内。 我们使用 image 的 lookup 命令，可以很快的定位到具体的代码行。 (lldb) image lookup –address 0x000000010cc9d4c5 Address: Demo[0x00000001000024c5] (Demo.__TEXT.__text + 2661) Summary: Demo`-[ViewController viewDidLoad] + 181 at ViewController.m:128 当然还有很多的命令我们可以探索，使用 image help 可以查看。 (lldb) image help Commands for accessing information for one or more target modules. Syntax: target modules … The following subcommands are supported: add -- Add a new module to the current target&apos;s modules. dump -- Commands for dumping information about one or more target modules. list -- List current executable and dependent shared library images. load -- Set the load addresses for one or more sections in a target module. lookup -- Look up information within executable and dependent shared library images. search-paths -- Commands for managing module search paths for a target. show-unwind -- Show synthesized unwind instructions for a function. For more help on any particular subcommand, type ‘help ‘. 九、为命令设置别名比如 p 是 frame variable 的别名，p view 实际上是 frame variable view。除了系统自建的 LLDB 别名，你也可以自定义别名。 掌握了规律之后，任何的命令我们都可以自己设置别名。 1、设置别名 (lldb) command alias bfl breakpoint set -f %1 -l %2(lldb) bfl ViewController.m 128Breakpoint 1: where = Demo`-[ViewController viewDidLoad] + 161 at ViewController.m:128, address = 0x000000010cc9d4b1 2、撤销别名 (lldb) command unalias bfl(lldb) bfl ViewController.m 128error: ‘bfl’ is not a valid command.error: Unrecognized command ‘bfl’. 十、memory内存操作，无非就是读写操作。 1、修改内存内的值 memory write [内存地址] [数值] 2、读取内存的操作 memory read/[数量_格式_字节数] [内存地址] 或者 x/[数量_格式_字节数] [内存地址] 3、格式 x ：代表 16 进制 f ：代表浮点数 d ：代表 10 进制 4、字节大小 b ：byte 代表 1 个字节 h ：half word 代表 2 个字节 w ：word 代表 4 个字节 如： memory read/1wx 0x7ffee14a5ba8memory read/1wd 0x7ffee14a5ba8 寓意是：读取 0x7ffee14a5ba8 中 4 个字节的内容。 (lldb) expr NSLog(@”%p”, &amp;_num)2019-04-03 14:39:41.334140+0800 Demo[98334:7932911] 0x7fef6484cc30(lldb) memory write 0x7fef6484cc30 18(lldb) p _num(NSInteger) $0 = 24(lldb) memory read/1wd 0x7fef6484cc300x7fef6484cc30: 24(lldb) memory read/1wx 0x7fef6484cc300x7fef6484cc30: 0x00000018(lldb) x/1wx 0x7fef6484cc300x7fef6484cc30: 0x00000018 十一、打印指令 p、pop 通常用于打印基本数据类型的值。这个指令会默认生出一个临时变量，如 $1。po 打印变量的内容，如果是对象，它打印的内容由 -debugDescription 决定。 (lldb) p self(ViewController *) $0 = 0x00007fe85f858600(lldb) po self&lt;ViewController: 0x7fe85f858600&gt; 使用： Class cls = NSClassFromString(@”ViewController”);id obj = [[cls alloc] init];NSLog(@”%@, %@”, cls, obj); 运行代码发现： cls 没有显示具体的地址值。 obj 没有看到 isa 这个成员变量。 使用简单的 p 或者 po 指令都是不可以的。需要借助上面说的操作内存的指令。 (lldb) p/x cls(Class) $2 = 0x000000010c258098 ViewController(lldb) p/x obj-&gt;isa(Class) $3 = 0x000000010c258098 ViewController 十二、btbt 返回所有的调用栈。 (lldb) bt* thread #1, queue = ‘com.apple.main-thread’, stop reason = breakpoint 1.1 * frame #0: 0x000000010282e4e2 Demo-\\[ViewController viewDidLoad\\](self=0x00007fef6484c800, _cmd=&quot;viewDidLoad&quot;) at ViewController.m:131 frame #1: 0x0000000110f3b4e1 UIKitCore-[UIViewController loadViewIfRequired] + 1186 frame #2: 0x0000000110e9b104 UIKitCore-\\[UINavigationController _updateScrollViewFromViewController:toViewController:\\] + 68 frame #3: 0x0000000110e9b3f8 UIKitCore-[UINavigationController _startTransition:fromViewController:toViewController:] + 147 frame #4: 0x0000000110e9c48b UIKitCore-\\[UINavigationController _startDeferredTransitionIfNeeded:\\] + 896 frame #5: 0x0000000110e9d7e0 UIKitCore-[UINavigationController viewWillLayoutSubviews] + 150 frame #6: 0x0000000110e7d600 UIKitCore-\\[UILayoutContainerView layoutSubviews\\] + 217 frame #7: 0x0000000111a44795 UIKitCore-[UIView(CALayerDelegate) layoutSublayersOfLayer:] + 1441 frame #8: 0x000000010a8d0b19 QuartzCore-\\[CALayer layoutSublayers\\] + 175 frame #9: 0x000000010a8d59d3 QuartzCoreCA::Layer::layout_if_needed(CA::Transaction) + 395 frame #10: 0x000000010a84e7ca QuartzCore`CA::Context::commit_transaction(CA::Transaction) + 342 frame #11: 0x000000010a88597e QuartzCoreCA::Transaction::commit() + 576 frame #12: 0x00000001115752d0 UIKitCore__34-[UIApplication _firstCommitBlock]_block_invoke_2 + 139 frame #13: 0x0000000103ca962c CoreFoundation\\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_ + 12 frame #14: 0x0000000103ca8de0 CoreFoundationCFRunLoopDoBlocks + 336 frame #15: 0x0000000103ca3654 CoreFoundation__CFRunLoopRun + 1284 frame #16: 0x0000000103ca2e11 CoreFoundationCFRunLoopRunSpecific + 625 frame #17: 0x000000010a7531dd GraphicsServicesGSEventRunModal + 62 frame #18: 0x000000011155a81d UIKitCoreUIApplicationMain + 140 frame #19: 0x000000010282eca0 Demomain(argc=1, argv=0x00007ffeed3d2068) at main.m:17 frame #20: 0x00000001063b1575 libdyld.dylibstart + 1 frame #21: 0x00000001063b1575 libdyld.dylib`start + 1","tags":[]},{"title":" iOS 生成静态库\t\t","date":"2019-04-02T01:33:43.000Z","path":"2019/04/02/e9-9d-99-e6-80-81-e5-ba-93/","text":".a 文件静态库打包 1、打开 Xcode 创建一个新的 Static Library 工程，取名 MyStaticLibrary。 2、创建工程完毕后，系统自动创建了一个同名类，添加一个方法用于测试。 #import &lt;Foundation/Foundation.h&gt; @interface MyStaticLibrary : NSObject + (void)test; @end @implementation MyStaticLibrary + (void)test{ NSLog(@”sssss”);} @end 3、Command + B 运行工程进行打包。运行完毕后，在工程中 Products 文件夹下的 libMyStaticLibrary.a 文件由红色变成了黑色。右键 show in finder 可以在其目录下找到它。这就是我们打包好的 .a 静态文件。 接下来公开些接口或者头文件供人调用。 4、公开接口头文件 targets -&gt; Build Phases -&gt; Copy Files -&gt; “+” 添加你需要公开的头文件。可以多添加几个类。 公开头文件后，Command + B 重新运行打包，我们会得到一个 include 文件夹和一个 .a 静态库。 5、新建一个可运行的工程，把这两个打包好的文件拖入项目测试。 选择 iPhone7 模拟器运行，运行程序，看到日志输出没有问题，即打包.a静态库大功告成。 别高兴的太早。当把模拟器切换成 iPhone5 运行时，编译直接不通过，报错如下： Undefined symbols for architecture i386 的意思是 libMyStaticLibrary.a 静态库不支持 i386 架构，即 32 位模拟器。 iPhone5 模拟器正好是 i386 架构，打包的静态库不支持。但是 iPhone7 模拟器运行却没有问题，这说明打包的静态库支持 iPhone7 模拟器的 cpu 架构 x86_64。如何查看静态库所支持的架构，请看下一步。 6、终端查看静态库所支持的架构 终端 -> cd 进入库文件路径 -&gt; lipo -info 库名 可以看到静态库仅支持 x86_64 架构，所以运行 iPhone5 模拟器时，编译会报错。 7、设置适配所有模拟器架构 project -&gt; buildSeting -&gt; Build Active Architecture Only 设为 NO，Valid Architectures 添加 arm7、arm7s 等架构，注意工程 iOS Deployment Target 设置为较低版本，如 8.0，不然不会有 i386。 设置完成后，重新 Command + B 运行打包静态库文件（这时你可随便选一个模拟器），按照上述第 6 步终端查看其支持的架构，我们可以看到终端输出的结果是同时支持 i386 和 x86_64，这也就意味着同时支持所有模拟器。 到这里打包 .a 静态库已经告一段落，但是按上述流程打包的只能在模拟器上跑，真机是不能运行的，因为 ios 真机设备跟模拟器的架构又不一样，继续处理。 8、打包支持真机架构的静态库 所有流程都跟上面的一样，只是我们运行打包时要选择真机运行，如下图你可以选择自己插上去的真机，也可以选择 Generic ios Devices。当然不要忘记了设置支持所有真机机型架构： Build Active Architecture Only 设为 NO。 看下打包出来的终端查看结果如下： 可以看到同时支持 armv7 和 arm64，也就是支持所有 ios 设备。好了到此打包 .a 静态库算是告一段落。 如果要同时支持模拟器和真机，请使用命令合成 .a 静态库： lipo -create [name1.a 所在路径] [name2.a 所在路径] -output [newname.a] .frameworke 文件静态库打包 1、Xcode 创建一个新的工程 MyFrameworkLib，选择工程如下： 创建完成后我们可以看到，工程本身自带一个 MyFrameworkLib.h 文件，这是类似一个主头文件一样的东西 2、创建需要测试的类。 #import &lt;Foundation/Foundation.h&gt; @interface MyFramework : NSObject + (void)test; @end @implementation MyFramework + (void)test{ NSLog(@”sssss”);} @end 3、设置支持所有模拟器架构或真机架构（和打包 .a 第 7 步骤一样） 4、公开头文件 target -&gt; Build Phases -&gt; Headers -&gt; 把需要公开的头文件从 project 拖入 Public。 5、设置打包的是静态库。 因为动态库也可以是以 framework 形式存在，所以需要设置，否则默认打出来的是动态库（注意：如果要上线 AppSotre，一定要改成静态库，否则审核通不过） target -&gt; BuildSetting -&gt; 搜索关键字 mach-&gt; Mach-o Type 设为 Static Library（这个默认选项是动态的） 6、选中真机或模拟器运行设备打包（与打包 .a 一样），完成后 Products 文件夹下的 MyFrameworkLib.framework 文件由红色变成了黑色，右键 show in finder 显示如下： MyFrameworkLib.framework 拖入项目便可直接使用。此外还要补充的一点是，打包静态库的时候还需注意打包的是测试版（Debug）还是发布版（Release），这个根据你自己的需求决定，而如何进行设置请下一步骤。 7、设置打包静态库的测试版和发布版（.a 和 .frameworke） product -&gt; scheme -&gt; Edit scheme -&gt; Run -&gt; 选择 Debug 或 Release。 如果要同时支持多种架构，和 .a 类似，需要设置 Build Activ Architecture Only = NO 和 iOS Deployment Target。 如果要同时支持模拟器和真机，和 .a 类似，使用命令合成 framework 库：lipo -create [.framework/] [.framework/] -output newname 将生成的 MyLib 替换掉任何一个里面的 MyFrameworkLib 文件。","tags":[]},{"title":" iOS 响应链\t\t","date":"2019-03-31T15:57:38.000Z","path":"2019/03/31/ios-e5-93-8d-e5-ba-94-e9-93-be/","text":"官方文档：Using Responders and the Responder Chain to Handle Events 文章：iOS开发 - 事件传递响应链、iOS响应链（Responder Chain） 一、UIResponderapp 使用响应者对象接收和处理事件，只有继承 UIResponder 的类，才能处理事件。 UIApplication、UIView、UIViewController 都是继承自 UIResponder 类，可以响应和处理事件。CALayer 继承自 NSObject，不是 UIResponder 的子类，无法处理事件。 响应者接收到原始事件数据，必须处理事件或者转发到另一个响应者对象。当 App 接收到一个事件时，UIKit 自动引导事件到最合适的响应者对象，也叫做第一响应者。 有时候可能会通过 UIResponder 来查找控件的父视图。 /** * 通过遍历 UIView 上的响应链来查找当前顶部 vc */- (UIViewController )firstVC{ for (UIView next = self; next; next = next.superview) { UIResponder nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) { return (UIViewController )nextResponder; } } return nil;} /** * 通过遍历 button 上的响应链来查找 cell */- (MyCell )buttonTaped:(UIButton )button{ UIResponder * responder = button.nextResponder; while (responder) { if (\\[responder isKindOfClass:\\[MyCell class\\]\\]) { MyCell * cell = (MyCell *)responder; break; } responder = responder.nextResponder; } } 二、事件的第一响应者事件的每个类型，UIKit 指定一个第一响应者，然后最先发送事件到这个对象。第一响应者基于事件的类型而变化。 Touch event 第一响应者是触摸事件产生的 view Press event 第一响应者是焦点响应者。 Shake-motion events,Remote-control events,Editing menu messages 第一响应者是你或者UIKit指定的对象 注意：运动事件相关的加速度计、陀螺仪、磁强计都不属于响应者链。而是由 CoreMotion 传递事件给你指定的对象。 控件直接与它相关的 target 对象使用 action 消息通信。 当用户与控件交互时，控件调用 target 对象的 action 方法。换句话说，控件发送 action 消息到目标对象。Action 消息不是事件，但是它仍然可以利用响应链。当控件的 target 对象为 nil，UIKit 从 target 对象和响应链走，直到找到一个对象实现了合适的 action 方法。 如果视图有添加手势识别器，手势识别器接收 touch 和 press 事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图处理。如果视图不能处理它们，UIKit 传递事件到响应链。 三、事件的分发和传递 当iOS程序中发生触摸事件后，系统会将事件加入到 UIApplication 管理的一个任务队列中； UIApplication 将处于任务队列最前端的事件向下分发，即 UIWindow。 UIWindow 将事件向下分发，即 UIView。 UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。 遍历子控件，重复以上两步。 如果没有找到，那么自己就是事件处理者。 如果自己不能处理，那么不做任何处理。 其中 UIView 不接受事件处理的情况主要有以下三种 alpha &lt; 0.01 userInteractionEnabled = NO hidden ＝ YES 这个从父控件到子控件寻找处理事件最合适的 view 的过程，如果父视图不接受事件处理，那么子视图也不能接收事件。事件只要触摸了就会产生，关键在于是否有最合适的 view 来处理和接收事件，如果遍历到最后都没有最合适的 view 来接收事件，则该事件被废弃。 四、hitTest:withEvent:/** * @return 本次点击事件需要的最佳 View */- (UIView )hitTest:(CGPoint)point withEvent:(UIEvent )event UIKit 使用基于视图的 hit-testing 来确定 Touch 事件在哪里产生。UIKit 将 Touch 位置与视图层级中的视图对象的边界进行了比较。UIView 的 hitTest:withEvent: 方法在视图层级中执行，寻找最深的包含指定 Touch 的子视图，这个视图将成为 Touch 事件的第一响应者。 注意：如果 Touch 位置超过视图边界，hitTest:withEvent 方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds 属性为 NO，子视图超过视图边界也不会返回，即使它们包含发生的 Touch。 当 touch 第一次产生时 UIKit 创建 UITouch 对象，在 touch 结束时释放这个 UITouch对象。当 touch 位置或者其他参数改变时，UIKit 更新 UITouch 对象新的信息。 把父视图的 userInteractionEnabled 设置为 NO，按钮 1 和按钮 2 都不会响应了。 如果点击按钮 2 视图，响应的是按钮 2，那么为什么点击按钮 2 和按钮 1 的交界处会是按钮 2 响应呢? 事件传递给窗口或控件的后，就调用 hitTest:withEvent: 方法寻找更合适的 view。如果子控件是合适的 view，则在子控件再调用 hitTest:withEvent: 查看子控件是不是合适的 view，一直遍历，直到找到最合适的 view 或者废弃事件。 - (UIView )hitTest:(CGPoint)point withEvent:(UIEvent )event{ // ①、判断当前控件能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil; // ②、判断触摸点在不在当前控件内 if ([self pointInside:point withEvent:event] == NO) return nil; // ②、倒序遍历自己的子控件 NSInteger count = self.subviews.count; for (NSInteger i = count - 1; i &gt;= 0; i–) { UIView * childView = self.subviews\\[i\\]; // 把当前控件上的坐标系转换成子控件上的坐标系 CGPoint childP = \\[self convertPoint:point toView:childView\\]; UIView * fitView = \\[childView hitTest:childP withEvent:event\\]; if (fitView) { return fitView; // 找到了最合适的 view } } // 循环结束，表示没有比自己更合适的 view return self;} 所有当父视图 userInteractionEnabled 关闭时，return nil，子视图无法继续寻找最合适的 view。 从后往前遍历子控件，图中按钮 2 在按钮 1 视图层级之上，所以按钮 2 是最合适的 view，还没有轮到按钮 1。 视图层级从后往前依次是 C-&gt;D-&gt;A、E-&gt;F-&gt;B-&gt;父视图，父视图的 subviews = @[ B, A ]。当点击界面发生触摸事件时，遍历父视图的子视图，倒序遍历，先遍历的 A 视图。 如果 A 视图 alpha &lt; 0.01 || userInteractionEnabled = YES || hidden ＝ NO，则 A 视图不是合适的View，返回 nil。开始遍历父视图的另一个子视图 B。 如果 A 视图 alpha &gt; 0.01 &amp;&amp; userInteractionEnabled = YES &amp;&amp; hidden ＝ NO，则 A 视图可以接收触摸事件，并且触摸点在 A 视图内，则 A 视图为一个合适的 View，但还要继续从后往前遍历 A 视图的子视图；如果 A 视图的所有子视图返回 nil，则 A 视图则为最终合适的 view。 如果 C 视图可以接收触摸事件且触摸点在 C 视图中，并且 C 视图的所有子视图返回 nil。 如果 C 视图调用 hitTest:withEvent: 处理返回 nil，则查看 B 视图满足条件。以此类推。 四、pointInside:withEvent:判断触摸点是否在视图内。 /** * @brief 判断一个点是否落在范围内 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event 如果现在要扩大按钮 2 的点击范围怎么办？如果要让按钮 1 只点击左右区域 40 像素有效，其他地方都不响应呢? 扩大响应范围。 - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent )event{ /\\ Inset `rect’ by `(dx, dy)’ – i.e., offset its origin by (dx, dy)&#39;, and decrease its size by(2*dx, 2*dy)’. CGRectInset 效果为 origin.x/y + dx/dy，size.width/height - 2 * dx/dy，这里 dx = -10，dy = -10 */ bounds = CGRectInset(self.bounds, -10, -10); return CGRectContainsPoint(bounds, point); } 不规则的点击区域 /** * @brief 改变图片的点击范围 */- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent )event{ // 控件范围宽度 +40，高度 +40 CGRect bounds = CGRectInset(self.bounds, -20, -20); UIBezierPath path1 = [UIBezierPath bezierPathWithRect:CGRectMake(-20, 0, 40, 120)]; UIBezierPath * path2 = [UIBezierPath bezierPathWithRect:CGRectMake(self.frame.size.width - 20, 0, 40, 120)]; if (([path1 containsPoint:point] || [path2 containsPoint:point])&amp;&amp; CGRectContainsPoint(bounds, point)){ return YES; // 如果在 path 区域内返回 YES } return NO; } 可以看出： 在不规则区域内（红框）点击，[self pointInside:point withEvent:event] == YES，按钮 1 是最合适的 view，调用按钮 1 的点击事件。 不在不规则区域内点击，无法调用按钮 1 的点击事件，[self pointInside:point withEvent:event] == NO。 在按钮 1 和按钮 2 重合区域（绿框）内点击，调用按钮 2 的点击事件，因为按钮 2 图层在按钮 1 之上，遍历 subviews 时，从后往前遍历，先查看按钮 2，按钮 2 调用 -hitTest:withEvent: 返回是最合适的 view，调用按钮 2 的点击方法。 五、响应者链响应链是从最合适的 view 开始传递，处理事件传递给下一个响应者，响应者链的传递方法是事件传递的反方法，如果所有响应者都不处理事件，则事件被丢弃。我们通常用响应者链来获取上几级响应者，方法是 UIResponder 的 nextResponder。 在 App 中没有单一的响应链，UIKit 定义了默认的规则关于对象如何从一个响应者传递到另一个响应者，但是你可以重写响应者对象的方法来改变这些规则。 1、改变响应链 可以通过重写响应对象的 nextResponder 属性改变响应链。许多 UIKit 的类已经重写了这个属性然后返回了指定的对象。 UIView 如果视图是 ViewController 的根视图，下一个响应者为 ViewController，否则是视图的父视图。 UIViewController 如果视图控制器是 window 的根视图下一个响应者为 window 对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。 -UIWindow 下一个响应者为 UIApplication 对象。 UIApplication 下一个响应者为 app delegate，但是代理应该是 UIResponder 的一个实例，而不是 UIView、UIViewController 或者 app 对象本身。","tags":[]},{"title":" iOS 生成动态库\t\t","date":"2019-03-31T10:41:47.000Z","path":"2019/03/31/ios-e5-8a-a8-e6-80-81-e5-ba-93/","text":"文章：iOS 动态库制作以及遇到的坑 1、创建一个动态库 MyDynamicFramework 2、创建一个测试类 3、在 MyDynamicFramework.h（默认生成，可统一暴露头文件） 中 #import “Person.h” #import &lt;UIKit/UIKit.h&gt; //! Project version number for MyDynamicFramework.FOUNDATION_EXPORT double MyDynamicFrameworkVersionNumber; //! Project version string for MyDynamicFramework.FOUNDATION_EXPORT const unsigned char MyDynamicFrameworkVersionString[]; // In this header, you should import all the public headers of your framework using statements like #import &lt;MyDynamicFramework/PublicHeader.h&gt; #import “Person.h” 4、点击工程 -&gt; Targets -&gt; Build Phases -&gt; Headers。 动态库中新建的文件会自动添加到 project 列表，MyDynamicFramework.h 文件是处于 Public 列表中。由于动态库外部使用者需要调用 Person.h 中的方法，所以也需要将 Person.h 拖拽到 Public 列表。 5、编译动态库 选择动态库对应的 Scheme，选择 Generic iOS Device 或真机编译出对应真机的动态库，Command + B 编译。在 Xcode 工程中的 Products（这个目录不是工程源文件目录，而是编译后生成对应的沙盒目录）找到 MyDynamicFramework.framework 文件，右键 show in finder。 6、利用 lipo -info 查看动态库所支持的 CPU 指令集。 新建工程后所编译出来的动态库所支持的 CPU 指令集是 arm 7、arm64。 需要注意： lipo -info [文件] 后面跟的是文件路径，而不是 .framework 路径。 7、指令集种类 armv7｜armv7s｜arm64 都是 ARM 处理器的指令集 i386｜x86_64 是 iOS 模拟器的指令集 理论上指令集是向下兼容的，比如连接设备为 arm64，那么是有可能编译出的动态库所支持的指令集为 armv7s 或者是 armv7。但是向下兼容并不是说一个 armv7s 的动态库可以用在 arm64 架构的设备上，如果连接的设备是 arm64 的，而导入的动态库是没有支持 arm64，那么在编译阶段即会报错。 8、Xcode 指令集的编译选项 打开 Target -&gt; Build Setting -&gt; Architectures Architectures：指明选定 Target 要求被编译生成的二进制包所支持的指令集 Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集，如果为 YES，那么只编译出连接设备所对应的指令集；如果为 NO，则编译出所有其它有效的指令集（由 Architectures 和 Valid Architectures决定） Valid Architectures：指明可能支持的指令集并非 Architectures 列表中指明的指令集都会被支持 编译产生的动态库所支持的指令集将由上面三个编译选项所影响，首先一个动态库要成功编译，则需要这三个编译选项的交集不为空。 9、制作支持各机型的动态库 Build Active Architecture Only 统一为 NO Architectures 和 Valid Architectures 都设置为 armv7、armv7s、arm64、arm64e 真机 Command + B 则生成支持 armv7、armv7s、arm64 的动态库，模拟器运行，则生成支持 i386、x86_64 的动态库。 10、合并模拟器和真机动态库 使用 lipo -create -output 命令合动态库，注意路径是文件路径，不是 .framework 的路径。 11、使用脚本合并 新建一个 target 脚本。 粘贴以下脚本内容到指定位置 if [ “${ACTION}” = “build” ]thenINSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework if [ -d “${INSTALL_DIR}” ]thenrm -rf “${INSTALL_DIR}”fi mkdir -p “${INSTALL_DIR}” cp -R “${DEVICE_DIR}/“ “${INSTALL_DIR}/“ #ditto “${DEVICE_DIR}/Headers” “${INSTALL_DIR}/Headers” # 使用lipo命令将其合并成一个通用framework# 最后将生成的通用framework放置在工程根目录下新建的Products目录下lipo -create “${DEVICE_DIR}/${PROJECT_NAME}” “${SIMULATOR_DIR}/${PROJECT_NAME}” -output “${INSTALL_DIR}/${PROJECT_NAME}” #open “${DEVICE_DIR}” #open “${SRCROOT}/Products”fi 编译新 target 编译完成后生成的 framework 位于工程源代码根目录下的 Products 文件夹下面，通过 lipo -info 可以看到动态库已经支持 i386、x86_64、armv7、armv7s、arm64。 注意：是工程目录，不是沙盒目录。 12、使用动态库 在新工程的 target -&gt; General -&gt; Embedded Binaries 中添加 MyDynamicFramework.framework。 13、使用别人提供的动态库遇到的坑 ①、第三方库所支持的 CPU 指令集不全。 ②、运行过程中出现 image not found 异常或者控制台没有异常输出。 原因：没有往 Embedded Binaries 中添加 xxx.framework 14、动态库动态更新问题 能否用动态库来动态更新 AppStore 上的版本呢？ framework 本来是苹果专属的内部提供的动态库文件格式，但是自从 2014 年 WWDC 之后，开发者也可以自定义创建framework 实现动态更新（绕过 apple store 审核，从服务器发布更新版本）的功能，这与苹果限定的上架的 app 必须经过apple store 的审核制度是冲突的，所以含有自定义的 framework 的 app 是无法在商店上架的，但是如果开发的是企业内部应用，就可以考虑尝试使用动态更新技术来将多个独立的 app 或者功能模块集成在一个 app 上面。 企业内部使用的 app，将企业官网中的板块开发成 4 个独立的 app，然后将其改造为 framework 文件最终集成在一款平台级的 app 当中进行使用，这样就可以在一款 app 上面使用原本 4 个 app 的全部功能。 使用自定义的动态库的方式来动态更新只能用在 in house（企业发布）和 develop 模式却但不能在使用到 AppStore，因为在上传打包的时候，苹果会对我们的代码进行一次 Code Singing，包括 app 可执行文件和所有 Embedded 的动态库。因此，只要你修改了某个动态库的代码，并重新签名，那么 MD5 的哈希值就会不一样，在加载动态库的时候，苹果会检验这个 hash 值，当苹果监测到这个动态库非法时，就会造成 Crash。 15、iOS 如何使用 framework 来进行动态更新？ 重要参考文档：iOS 利用 Framework 进行动态更新 16、谈谈 Mach-O 在制作 framework 的时候需要选择这个 Mach-O Type，确定 static、dynamic 类型库. 为 Mach Object 文件格式的缩写，它是一种用于可执行文件，目标代码、动态库、内核转储的文件格式。作为 a.out 格式的替代，Mach-O 提供了更强的扩展性，并提升了符号表中信息的访问速度。 17、自己创建的动态库 自建的动态库和系统的动态库有什么区别呢？ 我们创建的动态库是在自己应用的 .app 目录里面，只能自己的 App Extension 和 APP 使用。而系统的动态库是在系统目录里面，所有的程序都能使用。 可执行文件和自己创建的动态库位置： 一般我们得到的 iOS 程序包是 .ipa 文件。其实就是一个压缩包，解压缩 .ipa 后里面会有一个 payload 文件夹，文件夹里有一个 .app 文件，右键显示包内容，然后找到一个一般体积最大的、与 .app 同名的文件，那个文件就是可执行文件。 在模拟器上运行的时候用 [[NSBundle mainBundle] bundlePath]; 就能得到 .app 的路径。可执行文件就在 .app 里面。 而我们自己创建的动态库就在 .app 目录下的 Framework 文件夹里。 我们可以看一下可执行文件中对动态库的链接地址。用MachOView查看可执行文件。其中 @rpth 这个路径表示的位置可以查看Xcode 中的链接路径问题，而现在表示的其实就是 .app 下的 Framework 文件夹。 下图表示了静态库、自建的动态库和系统动态库：","tags":[]},{"title":" iOS 静态库和动态库\t\t","date":"2019-03-31T08:04:51.000Z","path":"2019/03/31/ios-e9-9d-99-e6-80-81-e5-ba-93/","text":"文章：iOS打包静态库（完整篇）、iOS armv7、armv7s、 arm64、iOS 创建 .a 和 .framework 静态库，以及 Bundle 资源文件的使用、iOS 静态库和动态库（库详解）、齐滇大圣/iOS里的动态库和静态库 一、前言1、 什么是库？ 库就是程序代码的集合，将 N 个文件组织起来，是共享程序代码的一种方式。从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。 2、 库的分类 根据程序代码的开源情况，库可以分为两类 开源库 源代码是公开的，你可以看到具体实现。比如知名的第三方框架：AFNetworking、SDWebImage。 闭源库 不公开源代码，只公开调用的接口，看不到具体的实现，是一个编译后的二进制文件。这种常见于一些公司的SDK包，比如高德地图 SDK、环信即时通讯 SDK 等。而闭源库又分为两类：静态库和动态库。 3、从源代码到 app 当我们点击了 build 之后，做了什么事情呢？ 预处理（Pre-process）：把宏替换、删除注释、展开头文件，产生.i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s 文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对 .o 文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 4、iOS 设备的 CPU 架构 模拟器： 4s-5: i386 5s-iPhone X（包括 iPhone SE）: x86_64 真机（iOS设备）： armv6：iPhone、iPhone 2、iPhone 3G、iPod Touch（第一代）、iPod Touch（第二代） armv7：iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2 armv7s：iPhone 5、iPhone 5c（静态库只要支持了 armv7，就可以在 armv7s 的架构上运行，向下兼容） arm64：iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3、iPhone 7、iPhone 7 Plus、iPhone 8、iPhone 8 Plus、iPhone X 二、静态库和动态库静态和动态是相对编译期和运行期而言的：静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要该静态库；动态库在程序编译时并不会被链接到目标代码中，只是在程序运行时才被载入。 存在形式： 静态库 以“.a”或者“.framework”为文件后缀名。 .a 是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件。 .a 要有 .h 文件以及资源文件配合， .framework 文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用 .framework 的形式。 动态库 以“.dylib”或者“.framework”为文件后缀名（Xcode7 之后 .tbd 代替了 .dylib） 使用区别： 静态库链接时会被完整的复制到可执行文件中，被多次使用就有多份拷贝。 利用静态函数库编译成的文件比较大，因为整个函数库的所有数据都会被整合进目标代码中。 它的优点就显而易见了，即编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用。而且系统只加载一次，多个程序共用，节省内存。 相对于静态函数库，动态函数库在编译的时候 并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。 各自优点： 静态库： ①、模块化，分工合作，提高了代码的复用及核心技术的保密程度 ②、避免少量改动经常导致大量的重复编译连接 ③、也可以重用，注意不是共享使用 动态库： ①、可以将最终可执行文件体积缩小，将整个应用程序分模块，团队合作，进行分工，影响比较小 ②、多个应用程序共享内存中得同一份库文件，节省资源 ③、可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的 ④、应用插件化 ⑤、软件版本实时模块升级 ⑥、在其它大部分平台上，动态库都可以用于不同应用间共享， 共享可执行文件，这就大大节省了内存。 在 iOS8 之前，苹果不允许第三方框架使用动态方式加载，从 iOS8 开始允许开发者有条件地创建和使用动态框架，这种框架叫做 Cocoa Touch Framework。虽然同样是动态框架，但是和系统 framework 不同，苹果系统专属的 framework 是共享的（如 UIKit），使用 Cocoa Touch Framework 制作的动态库在打包和提交 app 时会被放到 app main bundle 的根目录中，运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名、打包和加载。不过 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 三、静态库的处理方式 对于一个静态库而言，其实已经是编译好的了（类似一个 .o 的集合），这里并没有连接。在 build 的过程中只会参与链接的过程，而这个链接的过程简单的讲就是合并，并且链接器只会将静态库中被使用的部分合并到可执行文件中去。相比较于动态库，静态库的处理起来要简单的多，具体如下图： 链接器会将所有 .o 用到的 global symbol 和 unresolved symbol 放入一个临时表，而且是 global symbol 是不能重复的。 对于静态库的 .o，链接器会将没有任何 symbol 在 unresolved symbol table 的给忽略。 unresolved symbol 类似 extern int test(); — .h 的声明? global symbol 类似 void test() { print(“test”) } -- .m 的实现? 最后，链接器会用函数的实际地址来代替函数引用。 四、动态库的处理方式 首先，对于动态库而言其实分动态链接库和动态加载库两种的，这两个最本质的区别还是加载时间。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后】 但是不论是哪种动态库，相比较与静态库，动态库处理起来要棘手的多。由于动态库是动态的，所以你事先不知道某个函数的具体地址，因此动态链接器在链接函数的时候需要做大量的工作。 因为动态库在链接函数需要做大量的工作，而静态库已经实现处理好了。所以单纯的在所有都没有加载的情况下，静态库的加载速度会更快一点。而在 iOS 开发中的『库』(一) 提到的有所不妥，正确应该是，虽然动态库更加耗时，但是对于加载过的 share libraries 不需要再加载的这个前提下，使用动态库可以节省一些启动时间。 而实现这个动态链接是使用了 Procedure Linkage Table (PLT)。首先这个 PLT 列出了程序中每一个函数的调用，当程序开始运行，如果动态库被加载到内存中，PLT 会去寻找动态的地址并记录下来，如果每个函数都被调用过的话，下一次调用就可以通过 PLT 直接跳转了，但是和静态库还是有点区别的是，每一个函数的调用还是需要通过一张 PLT。这也正是 sunny 所说的所有静态链接做的事情都搬到运行时来做了，会导致更慢的原因。 五、动态库的作用应用插件化： 每一个功能点都是一个动态库，在用户想使用某个功能的时候让其从网络下载，然后手动加载动态库，实现功能的的插件化。 虽然技术上来说这种动态更新是可行的，但是对于 AppStore 上上架的 app 是不可以的。iOS8 之后虽然可以上传含有动态库的 app，但是苹果不仅需要你动态库和 app 的签名一致，而且苹果会在你上架的时候再经过一次 AppStore 的签名。所以你想在线更新动态库，首先你得有苹果 AppStore 私钥，而这个基本不可能。 除非你的应用不需要通过 AppStore 上架，比如企业内部的应用，通过企业证书发布，那么就可以实现应用插件化在线更新动态库了。 共享可执行文件： 在其它大部分平台上，动态库都可以用于不同应用间共享，这就大大节省了内存。从目前来看，iOS 仍然不允许进程间共享动态库，即 iOS 上的动态库只能是私有的，因为我们仍然不能将动态库文件放置在除了自身沙盒以外的其它任何地方。 iOS8 上开放了 App Extension 功能，可以为一个应用创建插件，这样主 app 和插件之间共享动态库还是可行的。 六、签名系统在加载动态库时，会检查 framework 的签名，签名中必须包含 TeamIdentifier，并且 framework 和 host app 的 TeamIdentifier 必须一致。 我们在 Debug 测试的时候是不会报错的，在打包时如果有动态库，那么就会检查 TeamIdentifier。 如果不一致，否则会报下面的错误： Error loading /path/to/framework: dlopen(/path/to/framework, 265): no suitable image found. Did find:/path/to/framework: mmap() error 1 如果用来打包的证书是 iOS 8 发布之前生成的，则打出的包验证的时候会没有 TeamIdentifier 这一项。这时在加载 framework 的时候会报下面的错误： [deny-mmap] mapped file has no team identifier and is not a platform binary:/private/var/mobile/Containers/Bundle/Application/5D8FB2F7-1083-4564-94B2-0CB7DC75C9D1/YourAppNameHere.app/Frameworks/YourFramework.framework/YourFramework 可以通过 codesign 命令来验证。 codesign -dv /path/to/YourApp.app或codesign -dv /path/to/YourFramework.framework 如果证书太旧，输出的结果如下： Executable=/path/to/YourApp.app/YourAppIdentifier=com.company.yourappFormat=bundle with Mach-O thin (armv7)CodeDirectory v=20100 size=221748 flags=0x0(none) hashes=11079+5 location=embeddedSignature size=4321Signed Time=2015年10月21日 上午10:18:37Info.plist entries=42TeamIdentifier=not setSealed Resources version=2 rules=12 files=2451Internal requirements count=1 size=188 注意其中的 TeamIdentifier=not set。 我们在用 cocoapods 的 use_framework! 的时候生成的动态库也可以用 codesign -dv /path/to/youFramework.framework 查看到 TeamIdentifier=not set。 七、关于 Framework 什么是 Framework Framework 是 Cocoa/Cocoa Touch 程序中使用的一种资源打包方式，可以将代码文件、头文件、资源文件、说明文档等集中在一起，方便开发者使用。一般如果是静态 Framework 的话，资源打包进 Framework 是读取不了的。静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 下面的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 Cocoa/Cocoa Touch 开发框架本身提供了大量的 Framework，比如 Foundation.framework/UIKit.framework 等。需要注意的是，这些 Framework 无一例外都是动态库。 平时用的第三方 SDK 的 Framework 都是静态库，真正的动态库是上不了 AppStore（iOS8 之后能上 AppStore，因为 App Extension，需要动态库支持)。 Framework 为什么既是静态库又是动态库？ 系统的 .framework 是动态库，我们自己建立的 .framework 一般都是静态库。但是现在用 xcode 创建Framework 的时候默认是动态库，一般打包成 SDK 给别人用的话都使用的是静态库，可以修改 Build Settings的 Mach-O Type 为 Static Library。 八、Framework 目录 Headers 表示暴露的头文件，一般都会有一个和 Framework 同名的 .h 文件，在创建 Framework 的时候文件夹里也会默认生成这样一个文件。有这个和 Framework 同名的 .h 文件 @import 导入库的时候编译器才能找到这个库（@import 导入头文件可参考 iOS里的导入头文件）。 info.plist 主要就是这个 Framework 的一些配置信息。 Modules 这个文件夹里有个 module.modulemap 文件 framework module DynamicFramework { umbrella header “DynamicFramework.h” export module { export * }} 这里面有这样一句 umbrella header “DynamicFramework.h”，umbrella 有保护伞、庇护的意思。 也就是说 Headers 中暴露的 DynamicFramework.h 文件被放在 umbrella 雨伞下保护起来了，所以我们需要将其他的所有需要暴露的 .h 文件放到 DynamicFramework.h 文件中保护起来，不然会出现警告。@import 的时候也只能找到 umbrella 雨伞下保护起来的 .h 文件。 二进制文件（Unix 可执行文件） 这个就是你源码编译而成的二进制文件，主要的执行代码就在这个里面。 .bundle 文件 如果我们在 Build Phases -&gt; Copy Bundle Resources 里加入 .bundle 文件，那么创建出来的 .Framework 里就会有这个 .bundle 的资源文件夹。 九、Framework 的资源文件CocoaPods 如何生成 Framework 的资源文件？ 我们能看到用 cocoapods 创建 Framework 的时候，Framework 里面有一个 .bundle 文件，跟 Framework 同级目录里也有一个 .bundle文件。这两个文件其实是一样的。 那这两个 .bundle 是怎么来的呢？我们能看到用 use_frameworks! 生成的 pod 里面，pods 这个 PROJECT 下面会为每一个 pod 生成一个 target。 那么如果这个 pod 有资源文件的话，就会有一个叫 xxx-bundleName 的 target，最后这个 target 生成的就是 bundleName.bundle。 在 xxx 的 target 的 Build Phases -&gt; Copy Bundle Resources 里加入这个 .bundle，在 Framework 里面就会生成这样一个 bundle。在 xxx 的 target 的 Build Phases -&gt; Target Dependencies 里加入这个 target：xxx-bundleName，就会在 Framework 的同级目录里生成这样一个 bundle。 静态 Framework 里不需要加入资源文件。一般资源打包进静态 Framework 是读取不了的。 静态 Framework 和 .a 文件都是编译进可执行文件里面的。只有动态 Framework 能在 .app 的 Framework 文件夹下看到，并读取 .framework 里的资源文件。 你可以用 NSBundle bundel = [[NSBundle mainBundle] bundlePath]; 得到 .app 目录，如果是动态库你能在 Framework 目录下看到这个动态库以及动态库里面资源文件。然后你只要用 NSBundle bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;]; 得到这个动态库的路径就能读取到里面的资源了。但是如果是静态库的话，因为编译进了可执行文件里面，你也就没办法读到这个静态库了，你能看到 .app 下的 Framework 目录为空。 在 Framework 或子工程中使用 xib 十、问题 如果静态库中有 category 类，则在使用静态库的项目配置中【Other Linker Flags】需要添加参数【-ObjC]或者【-all_load】。 出现 Umbrella header for module ‘XXXX’ does not include header ‘XXXXX.h’ 因为把 xxxxx.h 错误的拖到了 public 中。 出现 dyld: Library not loaded:XXXXXX 是因为打包的 Framework 版本太高。比如打包 Framework 时，选择的是 iOS 9.0，而实际的工程环境是 iOS 8 开始的。需要到 iOS Deployment Target 设置对应版本。 报错 “Include of non-modular header inside framework module” 如果创建的 Framework 类中使用了 .dylib 或者 .tbd，首先需要在实际项目中导入 .dylib 或者 .tbd 动态库，然后需要设置 Allow Non-modular Includes In Framework Modules = YES 有时候我们会发现在使用的时候加载不了动态 Framework 里的资源文件，其实是加载方式不对，比如用 pod 的时候使用的是 use_frameworks!，那么资源是在 Framework 里面的，需要使用以下代码加载（具体可参考给pod添加资源文件）： NSBundle * bundle = [NSBundle bundleForClass:&lt;#ClassFromFramework#&gt;]; NSString path = [bundle pathForResource:@”imageName@2x”(@”bundleName.bundle/imageName@2x”) ofType:@”png”];UIImage image = [UIImage imageWithContentsOfFile:path]; 报错 Reason: image not found 如果直接在工程里使用创建的动态库时候会出现此错误，需要在工程的 General 里的 Embedded Binaries 添加这个动态库才能使用。 因为创建的这个动态库其实也不能给其他程序使用的，而你的 App Extension 和 APP 之间是需要使用这个动态库的。这个动态库可以 App Extension 和 APP 之间共用一份（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。 十一、Swift 支持跟着 iOS8/Xcode6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种：1、把代码拷贝到工程中；2、用动态 Framework。使用静态库是不支持的。 造成这个问题的原因主要是 Swift 的运行库没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的运行库（这是苹果自家的解释）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了（参考这个问题的问题描述，也是来自苹果自家文档）。 十二、CocoaPods 的做法在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应着一个 Pod 的静态库。 当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 vendored_framework 选项来使用第三方 Framework。 对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持。通过 use_frameworks! 选项控制。对于 Swift 写的库来说，想通过 CocoaPods 引入工程，必须加入 use_frameworks! 选项。 十三、关于 use_frameworks!在使用 CocoaPods 的时候在 Podfile 里加入 use_frameworks!，那么你在编译的时候就会默认帮你生成动态库，我们能看到每个源码 Pod 都会在 Pods 工程下面生成一个对应的动态库 Framework 的 target，我们能在这个 target 的 Build Settings -&gt; Mach-O Type 看到默认设置是 Dynamic Library，也就是会生成一个动态 Framework，我们能在 Products 下面看到每一个 Pod 对应生成的动态库。 这些生成的动态库将链接到主项目给主工程使用，但是我们上面说过动态库需要在主工程 target 的 General -&gt; Embedded Binaries 中添加才能使用，而我们并没有在 Embedded Binaries 中看到这些动态库。那这是怎么回事呢，其实是 cocoapods 已经执行了脚本把这些动态库嵌入到了 .app 的 Framework 目录下，相当于在 Embedded Binaries 加入了这些动态库。我们能在主工程 target 的 Build Phase -&gt; Embed Pods Frameworks 里看到执行的脚本。 所以 Pod 默认是生成动态库，然后嵌入到 .app 下面的 Framework 文件夹里。我们去 Pods 工程的 target 里把 Build Settings -&gt; Mach-O Type 设置为 Static Library。那么生成的就是静态库，但是 cocoapods 也会把它嵌入到 .app 的Framework目录下，而因为它是静态库，所以会报错：unrecognized selector sent to instanceunrecognized selector sent to instance。 十四、参考创建一个 iOS Framework 项目 Xcode7创建静态库和Framework iOS 静态库开发 静态库与动态库的使用 iOS 静态库，动态库与 Framework 签名","tags":[]},{"title":" Xcode Build Setting\t\t","date":"2019-03-31T04:50:52.000Z","path":"2019/03/31/xcode-build-setting/","text":"一、Other linker flagsOther linker flags 用来填写 XCode 的链接器参数。 从 C 代码到可执行文件经历的步骤是： 源代码 -&gt; 预处理器 -&gt; 编译器 -&gt; 汇编器 -&gt; 机器码 -&gt; 链接器 -> 可执行文件 在最后一步需要把 .o 文件和 C 语言运行库链接起来，这时候需要用到 ld 命令。 源文件经过一系列处理以后，会生成对应的 .obj 文件，然后一个项目必然会有许多 .obj 文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。 Other linker flags 设置的值实际上就是 ld 命令执行时后面所加的参数。 The “selector not recognized” runtime exception occurs due to an issue between the implementation of standard UNIX static libraries, the linker and the dynamic nature of Objective-C. Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. If you extend a pre-existing class with categories, the linker does not know to associate the object code of the core class implementation and the category implementation. This prevents objects created in the resulting application from responding to a selector that is defined in the category. 运行时的异常是由于标准 XNIX 静态库、链接器与 OC 语言的动态的特性之间的问题，OC 语言并不是对每一个函数或者方法建立链接器符号表，而只是对每一个类创建了符号表。如果一个类有了分类，那么链接器就不知道将核心类与分类之间的代码实现联系起来，这就导致最终的应用程序中的可执行文件缺失了分类中的代码，这样函数调用就失败了。 常用参数： －ObjC 链接器就会把静态库中所有的 Objective-C 类和分类都加载到最后的可执行文件中。 这样编译之后的 app 会变大，因为加载了很多不必要的文件而导致可执行文件变大。但是如果静态库中有类和 category 的话只有加入这个 flag 才行。但是 Objc 也不是万能的，当静态库中只有分类而没有类的时候，Objc 就失效了，这就需要使用 -all_load 或者 -force_load 了。 @implementation MyStaticLib+ (void)test{ NSLog(@”sssss”);} @end @implementation MyStaticLib (Cate)/** * 重写方法 */+ (void)test{ NSLog(@”哈哈哈”);} @end 静态库中分类重写了方法，导入工程中，设置 -Objc 参数将打印：哈哈哈；不设置将打印：sssss。 －all_load 会让链接器把所有找到的目标文件都加载到可执行文件中，即使没有 objc 代码。但是这个参数也有一个弊端，假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到 ld: duplicate symbol 错误，因为不同的库文件里面可能会有相同的目标文件，有两种方法解决：1、用命令行进行拆包；2、使用 -force_load 参数。 -force_load 适用于 Xcode3.2+ 版本，它允许 finer 得到文档加载的控制，所做的事情跟 -all_load 其实是一样的，但是每一个 -force_load 操作必须跟着一个文档路径，文档中的每一个对象文件将会被加载，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。 -lstdc++ OC 和 C++ 混编时，在 Compile 阶段一切顺利，Clang 会根据后缀（.m .cpp）选择编译器进行编译，产物都是 Object File（.o 文件）。如果一个文件调用另一个文件的方法，编译出的 Object File 中会出现 undefined symbol 去代表这个方法。在链接阶段，Linker 通过把依赖的文件也加到最终的 executable 中 resolve undefined symbol。 Linker 没有主动的去 link stdc++ 库，解决方案 1：在 Other Linker Flags 中新增标志 -lstdc++；解决方案2：在 Linked Framework and Libraries 中添加 libstdc++.tbd。 总结： 建议 -ObjC 与 -force_load 搭配使用比较好。 包含静态库时需要在 Target 的 Other linker flags 里面加上值：-objC、-all_load、-force_load 对于 64 位机器和 iPhone O S应用，解决方法是使用 -all_load 或者 -force_load。 文章： Xcode 中 other linker flags 的作用、当我们在设置 Other Linker Flags -lstdc++时，我们到底在设置什么？","tags":[]},{"title":" isa 和 Class\t\t","date":"2019-03-28T10:34:34.000Z","path":"2019/03/28/isa-e5-92-8c-class/","text":"文章：一缕殇流化隐半边冰霜/神经病院Objective-C Runtime入院第一天–isa和Class 目录 Runtime 简介 NSObject 起源 isa_t 结构体的具体实现 cache_t 的具体实现 class_data_bits_t 的具体实现 测试题 一、Runtime 简介Runtime 又叫运行时，是一套底层的 C 语言 API，是 iOS 系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。 C 语言中，函数的调用在编译期就会决定调用哪个函数。 而 OC 的函数属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。 Objective-C 是一个动态语言，不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。 Objc 在三种层面上与 Runtime 系统进行交互： 1、通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime 系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码，在运行时确定对应的数据结构和调用具体哪个方法。 2、通过 Foundation 框架的 NSObject 类定义的方法 在 OC 中，除了 NSProxy 类以外，所有的类都是 NSObject 的子类。在 Foundation 框架下，NSObject 和 NSProxy 两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy 是专门用于实现代理对象的类，暂且不提。这两个类都遵循了 NSObject 协议。在 NSObject 协议中，声明了所有 OC 对象的公共方法。 在 NSObject 协议中，有以下 5 个方法是可以从 Runtime 中获取信息，让对象进行自我检查。 /** * 返回对象的类 */- (Class)class OBJC_SWIFT_UNAVAILABLE(“use ‘anObject.dynamicType’ instead”); /** * 检查对象是否存在于指定类的继承体系中，是否是为某个类或它的子类 */- (BOOL)isKindOfClass:(Class)aClass; /** * 检查对象是否是某个类的实例 */- (BOOL)isMemberOfClass:(Class)aClass; /** * 检查对象能否响应指定的消息 */- (BOOL)conformsToProtocol:(Protocol *)aProtocol; /** * 检查对象是否实现了指定协议类的方法 */- (BOOL)respondsToSelector:(SEL)aSelector; 在 NSObject 的类中还定义了一个方法 /** * 返回指定方法实现的地址 IMP */- (IMP)methodForSelector:(SEL)aSelector; 3、通过对 Runtime 库函数的直接调用 关于库函数可以在 Objective-C Runtime Reference 中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了 objc/Runtime.h 和 objc/message.h 两个头文件之后，我们查找到了Runtime 的函数之后，写代码时发现没有代码提示，那些函数里面的参数和描述都没有了。对于熟悉 Runtime 的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从 iOS6 开始开发的同学，依稀可能能感受到，关于 Runtime 的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从 Xcode5 开始，苹果就不建议开发者手动调用 Runtime 的 API，也同样希望我们不要知道具体底层实现。所以 IDE 上面默认带了一个参数，禁止了 Runtime 的代码提示，源码和文档方面也删除了一些解释。 具体设置如下： 如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成 NO，即可。 二、NSObject 起源与 Runtime 交互有 3 种方式，前两种方式都与 NSObject 有关，那我们就从 NSObject 基类开始说起。以下源码分析均来自objc4-680 NSObject 的定义如下： typedef struct objc_class *Class; @interface NSObject { Class isa OBJC_ISA_AVAILABILITY;} 在 Objc2.0 之前，objc_class 源码如下： struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list ivars OBJC2_UNAVAILABLE; // 指向成员变量列表的指针 struct objc_method_list *methodLists OBJC2_UNAVAILABLE; // 指向方法列表指针的指针 struct objc_cache cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针、类名、版本的信息。 动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。 关于 Category，推荐 2 篇文章可以仔细研读：深入理解Objective-C：Category、结合 Category 工作原理分析 OC2.0 中的 runtime 然后在 2006 年苹果发布 Objc 2.0 之后，objc_class 的定义就变成下面这个样子了，源码 objc_private。 typedef struct objc_class Class;typedef struct objc_object id; @interface Object { Class isa;} @interface NSObject { Class isa OBJC_ISA_AVAILABILITY;} struct objc_object {private: isa_t isa;} struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags} union isa_t{ } 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在 objc2.0 中，所有的对象都会包含一个 isa_t 类型的结构体。 objc_object 被源码 typedef 成了 id 类型，这也就是我们平时遇到的 id 类型。这个结构体中就只包含了一个 isa_t 类型的结构体。这个结构体在下面会详细分析。 objc_class 继承于 objc_object。所以在 objc_class 中也会包含 isa_t 类型的结构体 isa。至此，可以得出结论： Objective-C 中类也是一个对象。在 objc_class 中，除了 isa 之外，还有 3 个成员变量，一个是父类的指针，一个是方法缓存，最后一个是这个类的实例方法链表。 object 类和 NSObject 类里面分别都包含一个 objc_class 类型的 isa。 1、isa union isa_t{ isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; # if __arm64__ struct { uintptr_t indexed : 1; // 是否开启 isa 指针优化。index = 1 表示开启 isa 指针优化 uintptr_t has_assoc : 1; // 是否有设置过关联对象，如果没有，释放时会更快 uintptr_t has_cxx_dtor : 1; // 是否有 C++ 的析构函数（.cxx_destruct），如果没有，释放时会更快 uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 存储着Class、Meta-Class对象的内存地址信息 uintptr_t magic : 6; // 用于在调试时分辨对象是否未完成初始化 uintptr_t weakly_referenced : 1; // 是否有被弱引用指向过，如果没有，释放时会更快 uintptr_t deallocating : 1; // 对象是否正在释放 uintptr_t has_sidetable_rc : 1; // 引用计数器是否过大无法存储在 isa 中。如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中 uintptr_t extra_rc : 19; // 里面存储的值是引用计数 - 1 }; # elif __x86_64__ struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; }; # else # endif} isa 详解 在 arm64 之前 isa 就是普通的指针，只存储类对象、元类对象的指针。但是 arm64 之后 isa 做了优化，采取了共用体结构，将一个 64 位的内存数据分开存储了很多东西，其中 33 位用来存储地址值。 当一个对象的实例方法被调用的时候，会通过 isa 找到相应的类，然后在该类的 class_data_bits_t 中去查找方法。class_data_bits_t 是指向了类对象的数据区域，在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的 isa 里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类（meta-class）的概念。关于元类，更多具体可以研究这篇文章 What is a meta-class in Objective-C? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。 对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。 类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 meta-class 之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的 meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系： 实线是 super_class 指针，虚线是 isa 指针。 Root class（class） 其实就是 NSObject，NSObject 是没有超类的，所以 Root class（class）的 superclass 指向 nil。 每个 Class 都有一个 isa 指针指向唯一的 Meta class Root class（meta）的 superclass 指向 Root class（class），也就是 NSObject，形成一个回路。 每个 Meta class 的 isa 指针都指向 Root class（meta）。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在 main 方法执行之前，从 dyld 到 runtime 这期间，类对象和元类对象在这期间被创建。具体可看 sunnyxx 这篇 iOS 程序 main 函数之前发生了什么 isa_t 结构体的具体实现 接下来我们就该研究研究 isa 的具体实现了。objc_object 里面的 isa 是 isa_t 类型。通过查看源码，我们可以知道 isa_t 是一个 union 联合体。 struct objc_object {private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor); …｝ 那就从 initIsa 方法开始研究。下面以 arm64 为例，源码 objc_object。 inline voidobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor){ initIsa(cls, true, hasCxxDtor);} inline voidobjc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor){ if (!indexed) { isa.cls = cls; } else { isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; }} initIsa 第二个参数传入了一个 true，所以 initIsa 就会执行 else 里面的语句。 # if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) }; # elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) }; ISA_MAGIC_VALUE = 0x000001a000000001ULL 转换成二进制是 11010000000000000000000000000000000000001，结构如下图： 参数的说明： index 代表是否开启 isa 指针优化。index = 1 代表开启 isa 指针优化。 在 2013 年 9 月，苹果推出了 iPhone5s，与此同时，iPhone5s 配备了首个采用 64 位架构的 A7 双核处理器，为了节省内存和提高执行效率，苹果提出了 Tagged Pointer 的概念。对于 64 位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。 在 WWDC2013 的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer 的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在 32 位系统中，一个指针的大小是 32 位（4 字节），而在 64 位系统中，一个指针的大小将是 64 位（8 字节）。 假设我们要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有 Tagged Pointer 对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示： 苹果提出了 Tagged Pointer 对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：231 = 2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了 Tagged Pointer 对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样： 关于 Tagged Pointer 技术详细的，可以看上面链接那个文章。 has_assoc 对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor 表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls 类的指针。arm64 架构中有 33 位可以存储类指针。 源码中 isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解 isa这篇文章里面的 shiftcls 分析。 magic 判断对象是否初始化完成，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced 对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating 对象是否正在释放内存 has_sidetable_rc 判断该对象的引用计数是否过大，如果过大则需要其他散列表来进行存储。 extra_rc 存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个里面，如果引用计数为 10，extra_rc 的值就为 9。 ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取 MAGIC 值和 isa 类指针。 inline Classobjc_object::ISA(){ assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);} 关于 x86_64 的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。 2、cache_t 的具体实现 继续看源码 struct cache_t { struct bucket_t *_buckets; mask_t _mask; // 分配用来缓存 bucket 的总数 mask_t _occupied; // 表明实际占用的缓存 bucket 的个数} typedef unsigned int uint32_t;typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t;typedef uintptr_t cache_key_t; struct bucket_t {private: cache_key_t _key; IMP _imp;} 根据源码，我们可以知道 cache_t 中存储了一个 bucket_t 的结构体，和两个 unsigned int 的变量。 bucket_t 的结构体中存储了一个 unsigned long 和一个 IMP。IMP 是一个函数指针，指向了一个方法的具体实现。 cache_t 中的 bucket_t *_buckets 其实就是一个散列表，用来存储 Method 的链表。 Cache 的作用主要是为了优化方法调用的性能。当对象 receiver 调用方法 message 时，首先根据对象 receiver 的 isa 指针查找到它对应的类，然后在类的 methodLists 中搜索方法，如果没有找到，就使用 super_class 指针到父类中的 methodLists 查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有 20% 的方法经常被调用，占总调用次数的 80%。所以使用 Cache 来缓存经常调用的方法，当调用方法时，优先在 Cache 查找，如果没有找到，再到 methodLists 查找。 3、class_data_bits_t 的具体实现 源码实现： struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; } struct class_rw_t { uint32_t flags; uint32_t version; const class\\_ro\\_t *ro; method\\_array\\_t methods; property\\_array\\_t properties; protocol\\_array\\_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; } struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name; method\\_list\\_t * baseMethodList; protocol\\_list\\_t * baseProtocols; const ivar\\_list\\_t * ivars; const uint8_t * weakIvarLayout; property\\_list\\_t *baseProperties; method\\_list\\_t *baseMethods() const { return baseMethodList; } }; 在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。 class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags 它为我们提供了便捷方法用于返回其中的 class_rw_t * 指针： class_rw_t *data() { return bits.data();} Objc 的类的属性、方法、以及遵循的协议在 obj 2.0 的版本之后都放在 class_rw_t 中。class_ro_t 是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite、ro-readonly 在编译期，类的结构中的 class_data_bits_t data 指向的是一个 class_ro_t 指针： 在运行时调用 realizeClass方法，会做以下 3 件事情： 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后调用 methodizeClass 方法，把类里面的属性、协议、方法都加载进来。 struct method_t { SEL name; // 方法名字 const char *types; // Type Encoding 类型编码 IMP imp; struct SortBySELAddress : public std::binary\\_function&lt;const method\\_t&amp;, const method_t&amp;, bool&gt; { bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) { return lhs.name &lt; rhs.name; } }; }; 方法 method 的定义如上。里面包含 3 个成员变量。Type Encoding 类型编码可参考 Type Encoding。 IMP 是一个函数指针，指向的是函数的具体实现。在 runtime 中消息传递和转发的目的就是为了找到 IMP，并执行函数。 整个运行时过程描述如下： 更加详细的分析，请看@Draveness 的这篇文章深入解析 ObjC 中方法的结构 到此，总结 objc_class 1.0 和 2.0 的差别。 三、测试题1、[self class] 与 [super class] @implementation Son : Father - (id)init{ if (self = [super init]) { NSLog(@”%@”, NSStringFromClass([self class])); NSLog(@”%@”, NSStringFromClass([super class])); } return self;}@end self 和 super 的区别： self 是类的一个隐藏参数，每个方法的实现的第一个参数即为 self。 super 并不是隐藏参数，它实际上只是一个“编译器标示符”，它负责告诉编译器：当调用方法时，去调用父类的方法，而不是本类中的方法。 在调用 [super class] 的时候，runtime 会去调用 objc_msgSendSuper 方法，而不是 objc_msgSend。 OBJC_EXPORT void objc_msgSendSuper(void / struct objc_super \\super, SEL op, … */ ) /// Specifies the superclass of an instance.struct objc_super { /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class; #else __unsafe_unretained Class super_class; #endif /* super_class is the first class to search */}; 在 objc_msgSendSuper 方法中，第一个参数是一个 objc_super 的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是当前类的父类 super_class。 objc_msgSendSuper 的工作原理应该是这样的： 从 objc_super 结构体指向的 superClass 父类的方法列表开始查找 selector，找到后以 objc-&gt;receiver 去调用父类的这个 selector。注意，最后的调用者是 objc-&gt;receiver，而不是 super_class。 那么 objc_msgSendSuper 最后就转变成 // 注意这里是从父类开始 msgSend，而不是从本类开始。objc_msgSend(objc_super-&gt;receiver, @selector(class)) /// Specifies an instance of a class. 这是类的一个实例 __unsafe_unretained id receiver; // 由于是实例调用，所以是减号方法- (Class)class { return object_getClass(self);} 由于找到了父类 NSObject 里面的 class 方法的 IMP，又因为传入的入参 objc_super-&gt;receiver = self。self 就是 son，调用 class，所以父类的方法 class 执行 IMP 之后，输出还是 son，最后输出两个都一样，都是输出 son。 2、isKindOfClass 与 isMemberOfClass @interface Sark : NSObject@end @implementation Sark@end int main(int argc, const char * argv[]) { @autoreleasepool { BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); } return 0; } 先来分析一下源码这两个函数的对象实现 + (Class)class { return self;} - (Class)class { return object_getClass(self);} Class object_getClass(id obj){ if (obj) return obj-&gt;getIsa(); else return Nil;} inline Classobjc_object::getIsa(){ if (isTaggedPointer()) { uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; } return ISA();} inline Classobjc_object::ISA(){ assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);} + (BOOL)isKindOfClass:(Class)cls { for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;} - (BOOL)isKindOfClass:(Class)cls { for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;} + (BOOL)isMemberOfClass:(Class)cls { return object_getClass((id)self) == cls;} - (BOOL)isMemberOfClass:(Class)cls { return [self class] == cls;} 首先题目中 NSObject 和 Sark 分别调用了 class 方法。 + (BOOL)isKindOfClass:(Class)cls 方法内部，会先去获得 object_getClass 的类，而 object_getClass 的源码实现是去调用当前类的 obj-&gt;getIsa()，最后在 ISA() 方法中获得 meta class 的指针。 接着在 isKindOfClass 中有一个循环，先判断 class 是否等于 meta class，不等就继续循环判断是否等于 super class，不等再继续取 super class，如此循环下去。 [NSObject class] 执行完之后调用 isKindOfClass，第一次判断先判断 NSObject 和 NSObject 的 meta class 是否相等，之前讲到 meta class 的时候放了一张很详细的图，从图上我们也可以看出，NSObject 的 meta class 与本身不等。接着第二次循环判断 NSObject 与 meta class 的 superclass 是否相等。还是从那张图上面我们可以看到：Root class(meta) 的 superclass 就是 Root class（class），也就是 NSObject 本身。所以第二次循环相等，于是第一行 res1 输出应该为YES。 同理，[Sark class] 执行完之后调用 isKindOfClass，第一次 for 循环，Sark 的 Meta Class 与 [Sark class] 不等，第二次 for 循环，Sark Meta Class 的 super class 指向的是 NSObject Meta Class，和 Sark Class 不相等。第三次 for 循环，NSObject Meta Class 的 super class 指向的是 NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的 super class 指向 nil， 和 Sark Class 不相等。第四次循环之后，退出循环，所以第三行的 res3 输出为 NO。 如果把这里的 Sark 改成它的实例对象，[sark isKindOfClass:[Sark class]]，那么此时就应该输出 YES 了。因为在 isKindOfClass 函数中，判断 sark 的 isa 指向是否是自己的类 Sark，第一次 for 循环就能输出 YES 了。 isMemberOfClass 的源码实现是拿到自己的 isa 指针和自己比较，是否相等。 第二行 isa 指向 NSObject 的 Meta Class，所以和 NSObject Class 不相等。第四行，isa 指向 Sark 的 Meta Class，和 Sark Class 也不等，所以第二行 res2 和第四行 res4 都输出 NO。 3、Class 与内存地址 下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface Sark : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end @implementation Sark- (void)speak { NSLog(@”my name’s %@”, self.name);}@end @implementation ViewController - (void)viewDidLoad{ [super viewDidLoad]; id cls = \\[Sark class\\]; void *obj = &amp;cls; \\[(__bridge id)obj speak\\]; }@end 这道题有两个难点。难点一，obj 调用 speak 方法到底会不会崩溃。难点二，如果 speak 方法不崩溃，应该输出什么？ 首先需要谈谈隐藏参数 self 和 _cmd 的问题。 当 [receiver message] 调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数 self 和 _cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self 在上面已经讲解明白了，接下来就来说说 _cmd。_cmd 表示当前调用方法，其实它就是一个方法选择器 SEL。 难点一：能不能调用 speak 方法？ id cls = [Sark class];void *obj = &cls; 答案是可以的。obj 被转换成了一个指向 Sark Class 的指针，然后使用 id 转换成了 objc_object 类型。obj 现在已经是一个 Sark 类型的实例对象了。当然接下来可以调用 speak 的方法。 难点二：如果能调用 speak，会输出什么呢？ 很多人可能会认为会输出 sark 相关的信息。这样答案就错误了。 正确的答案会输出 my name is &lt;ViewController: 0x7ff6d9f31c50&gt; 内存地址每次运行都不同，但是前面一定是 ViewController。why？ 我们把代码改变一下，打印更多的信息出来。 - (void)viewDidLoad{ [super viewDidLoad]; NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self); id cls = \\[Sark class\\]; NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls); void *obj = &amp;cls; NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj, &amp;obj); \\[(__bridge id)obj speak\\]; Sark *sark = \\[\\[Sark alloc\\]init\\]; NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark, &amp;sark); \\[sark speak\\]; } 我们把对象的指针地址都打印出来。输出结果： ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8Sark class = Sark 地址 = 0x7fff543f5a88Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80 my name is &lt;ViewController: 0x7fb570e2ad00&gt; Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78my name is (null) // objc_msgSendSuper2() takes the current search class, not its superclass.OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, …) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0); objc_msgSendSuper2 方法入参是一个 objc_super *super。 /// Specifies the superclass of an instance.struct objc_super { /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class; #else __unsafe_unretained Class super_class; #endif /* super_class is the first class to search */}; #endif 所以按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、super_class（等同于 self.class）、receiver（等同于 self）、obj。 第一个 self 和第二个 _cmd 是隐藏参数。第三个 self.class 和第四个 self 是 [super viewDidLoad] 方法执行时候的参数。 在调用 self.name 的时候，本质上是 self 指针在内存向高位地址偏移一个指针。 从打印结果我们可以看到，obj 就是 cls 的地址。在 obj 向上偏移一个指针就到了 0x7fff543f5a90，这正好是 ViewController 的地址。所以输出为 my name is &lt;ViewController: 0x7fb570e2ad00&gt;。 至此，Objc 中的对象到底是什么呢？ 实质：Objc 中的对象是一个指向 ClassObject 地址的变量，即 id obj = &amp;ClassObject，而对象的实例变量 void *ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ - (void)viewDidLoad { [super viewDidLoad]; NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self); NSString *myName = @&quot;halfrost&quot;; id cls = \\[Sark class\\]; NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls); void *obj = &amp;cls; NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj,&amp;obj); \\[(__bridge id)obj speak\\]; Sark *sark = \\[\\[Sark alloc\\]init\\]; NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark,&amp;sark); \\[sark speak\\]; } ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78Sark class = Sark 地址 = 0x7fff56a48a50Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48 my name is halfrost Sark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak]; 这句话会输出“my name is halfrost”。 原因还是和上面的类似。按 viewDidLoad 执行时各个变量入栈顺序从高到底为 self、_cmd、self.class（super_class）、self（receiver）、myName、obj。obj 往上偏移一个指针，就是 myName 字符串，所以输出变成了输出 myName 了。 这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController： my name is &lt;ViewController: 0x7fb570e2ad00&gt; 其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了 4 个到最下面的 self 呢？ obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占 8 个字节，所以从 obj 到 self 中间确实有 4 个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。 LLDB 调试中，可以使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示： x/ n、f、u 是可选的参数。 n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是 s，如果是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB 默认是 4 个 bytes。 u 参数可以用下面的字符来代替，b 表示单字节，h 表示双字节，w 表示四字节，g 表示八字节。当我们指定了字节长度后，GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。 这两个 self 的地址不同，里面存储的内容是相同的。所以 obj 是偏移了一个指针，而不是偏移到最下面的 self。","tags":[]},{"title":" if-else、switch、while、for\t\t","date":"2019-03-28T06:55:33.000Z","path":"2019/03/28/if-else-e3-80-81switch-e3-80-81while-e3-80-81for/","text":"文章：用if else,switch,while,for颠覆你的编程认知 文章主要会涉及如下几个问题： if-else 和 switch-case 两者相比谁的效率会高些？在日常开发中该如何抉择？ 如何基于赫夫曼树结构减少 if-else 分支判断次数？ 如何巧妙的应用 do…while(0) 改善代码结构？ 哨兵是什么东西？如何利用哨兵提高有序数组查找效率？ 如何降低 for 循环嵌套的时间复杂度？ 如何利用策略模式替换繁琐的 if-else 分支？ 一、if-else 和 switch-case 效率问题https://www.dzliving.com/2019/03/19/switch-%E4%B8%8E-if-else-%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98/ 二、用 do-while(0) 改善代码结构先看一段代码，要重点注意代码中的注释。 - (NSString )handleString:(NSString )str{ if (![str isKindOfClass:[NSString class]]) { return nil; } if(str.length &lt;= 0) { return nil; } // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1…code1 // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果)，无论判断是否通过都要执行 code2...code2 } 试问，怎样做才能巧妙的满足上述注释代码的需求，因为上述代码中存在 return nil，一旦执行到此处，逻辑一和逻辑二处的伪代码都不会再执行。为了满足上述要求，我们可以巧妙的利用 break 退出临时构造的代码块，但不退出整个函数。 - (NSString )handleString:(NSString )str { do { if (![str isKindOfClass:[NSString class]]) { break; } if(str.length &lt;= 0) { break; } // 第一部分逻辑依赖于前面的判断，只有判断通过的时候才执行 code1…code2 } while (0); // 第二部分逻辑不依赖于前面的判断(第二部分中的逻辑可能会依赖第一部分逻辑处理结果),无论判断是否通过都要执行 code2...code2 } 三、有序数组查找操作中的哨兵正常的查找处理。 NSArray *arr = @\\[@1, @2, @3, @4, @5\\]; for (NSInteger i = 0; i &lt; arr.count; i++) { if (\\[arr\\[i\\] integerValue\\] == 2) { NSLog(@&quot;for 找到了&quot;); } } 利用哨兵进行查找处理。 - (BOOL)search:(NSNumber )key array:(NSMutableArray )arr{ if (arr.count &lt;= 0) { return NO; } NSNumber * firstObj = (NSNumber *)arr\\[0\\]; if (\\[firstObj integerValue\\] == \\[key integerValue\\]) { return YES; } NSInteger i = arr.count - 1; NSLock * lock = \\[\\[NSLock alloc\\]init\\]; \\[lock lock\\]; arr\\[0\\] = key; // 同上面 for 循环相比，i &lt; arr.count 的判断，在处理大批量数据时候，对性能提升比较大 while (\\[arr\\[i\\] integerValue\\] != \\[key integerValue\\]) { i--; } arr\\[0\\] = firstObj; \\[lock unlock\\]; return (i != 0); } 仔细观察上述两段代码，同样是在有序数组中查找目标为 2 的元素，第一段代码是常规迭代处理，第二段代码是将要查找的元素设置为哨兵。同第一段代码相比第二种方式少了 i &lt; arr.count 的判断，在小批量有序数组查询中对效率的提升并无明显影响，但是在处理大批量数据时候，对性能提升还是比较明显的。 四、多层 for 嵌套处理实际开发中应尽量避免使用双层 for 循环，客户端数据量比较小可能实际开发中并不是很注意这些。但是后端开发过程中，数据量比较大, 为了提升性能，有些公司后端开发中可能会直接规定避免使用多层 for 循环嵌套的形式。一般第二层或更深层的 for 循环可以使用字典替换。双层 for 循环嵌套的时间复杂度是 n 的二次方。但如果内部 for 循环用字典代替时间复杂度为 O(2n)（实际是 O(n)）。如：两个数组中有且只有一个相同元素，寻找该元素。其中一个数组就可以先用字典做保存，遍历第一个数组的时候，同字典中的数据做比较即可。 NSArray *arr1 = @\\[@1, @2, @3, @4, @5\\]; NSArray *arr2 = @\\[@5, @6, @7, @8\\]; NSMutableDictionary * dict = \\[NSMutableDictionary dictionary\\]; for (NSInteger i = 0; i &lt; arr2.count; i++) { \\[dict setObject:arr2\\[i\\] forKey:\\[NSString stringWithFormat:@&quot;%ld&quot;, i\\]\\]; } for (NSInteger i= 0 ; i &lt; arr1.count; i++) { NSNumber * number = \\[dict objectForKey:\\[NSString stringWithFormat:@&quot;%ld&quot;, i\\]\\]; if (\\[arr1\\[i\\] integerValue\\] == \\[number integerValue\\]) { NSLog(@&quot;相同的数据为:%@&quot;, number); break; } } 五、用策略模式替换 if-elsehttps://www.jianshu.com/p/98fa80eebc52","tags":[]},{"title":" iOS 页面流畅技巧\t\t","date":"2019-03-28T03:14:49.000Z","path":"2019/03/28/ios-e9-a1-b5-e9-9d-a2-e6-b5-81-e7-95-85-e6-8a-80-e5-b7-a7/","text":"文章：幸运的芳1990/浅谈iOS页面流畅技巧 一、屏幕显示图像原理首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。 二、卡顿产生的原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次再显示，而这时显示屏会保留之前的内容不变，这就是卡顿的原因。 三、CPU 资源消耗的原因和解决方案1、对象的创建 对象的创建会分配内存、调整属性、甚至还有读取文件的操作，比较消耗 CPU 资源。因此可以： ①、尽量用轻量的对象代替重量的对象。如 CALayer 比 UIView 轻量的多，在不需要响应触摸事件时，用 CALayer 显示更合适； ②、如果对象不涉及 UI 操作，尽量放到后台线程去创建； ③、通过 storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，所以尽量避免使用； ④、尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去； ⑤、如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 2、对象调整 对象的调整也是经常消耗 CPU 资源的地方。尤其是 CALayer： ①、CALayer 内部没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 中，同时还会告知 delegate、创建动画等，非常消耗资源； ②、UIView 关于显示相关的属性（比如 frame/bouds/transform 等）实际上都是 CALayer 属性映射出来的，所以对UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性，因此应该尽量减少类似的不必要的属性的修改； ③、当视图层次调整时，UIView、CALayer 之间会出现很多调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 3、对象销毁 当容器类持有大量对象时，其销毁时的资源消耗就非常明显。所以，尽量去后台线程释放对象。可以这么做：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译警告，就可以让对象在后台线程销毁了： NSArray * tmp = self.arr_data;self.arr_data = nil;dispatch_async(queue, ^{ [tmp class];}); 4、对象布局 在后台线程提前计算好视图布局、并对视图的布局进行缓存。 不论通过何种技术对视图进行布局，最终都会落到对 UIView.frame/bounds/center 等属性的调整上。 5、Autolayout 这是苹果本身提倡的技术，在大部分情况下能很好的提升开发效率，但对于复杂视图来说常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级增长。 6、文本计算 如果一个界面中包含大量的文本，文本的宽高计算会占用很大一部分资源，并且不可避免。 7、文本渲染 屏幕上能看到的所有的文本内容控件包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的，并且该排版、绘制都是在主线程进行的。 显示大量文本时，CPU 的压力非常大，可以通过自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制，尽管麻烦但优势强大： ①、CoreText 对象能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）； ②、CoreText 对象占用内存较小，可以缓存下来以备稍后多次渲染。 8、图片解码 用 UIImage 或者 CGImageSource 的方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中，并且 CALayer 被提到 GPU 前，CGImage 中的数据才会得到解码。 该步是发生在主线程，并且不可避免。如果想绕开这个机制，常见的方法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 9、图像的绘制 是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示。常见的就是 [UIView drawRect: ]。CoreGraphic 方法通常是线程安全的，所以图像的绘制可以放到后台线程运行。如下：（实际情况比这个复杂，但原理基本一致） - (void)display{ dispatch_async(backgroundQueue, ^{ CGContextRef ctx = CGBitmapContextCreate(…); // draw in context… CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^{ layer.contents = img; }); });} 四、GPU 资源消耗原因和解决方案GPU 能干的事情比较单一：接受提交的纹理（Texture）和顶点描述（三角形）、应用变换（transform）、混合并渲染，然后输出到屏幕上。看到的内容通常主要是纹理（图片）和形状（三角模拟的矢量图形）两类。 1、纹理的渲染 所有的 Bitmap，包括图片、文字、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。 当在短时间内显示大量图片时（如 TableView），CPU 占用率很低，GPU 占用非常高，界面会掉帧。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 跟 GPU 都会带来额外的消耗。 2、视图的混合（Composing） 当多个视图（或者 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多的 GPU 资源。 所以应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 也可以把多个视图预先渲染为一张图片来显示。 3、图形的生成 CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染，而离屏渲染通常发生在 GPU 中。 当列表中出现大量圆角的 CALayer 并且快速滑动时，GPU 资源可能几近占满，而 CPU 资源消耗很少，这时候界面仍能正常滑动但平均帧数降到很低。这时候可以尝试开启 CALayer.shouldRaster 属性，但这会离屏渲染操作转嫁到 CPU 上。 对于只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原视图上来模拟出相同的视觉效果。 最彻底的做法：把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。","tags":[]},{"title":" 心跳保活\t\t","date":"2019-03-27T11:08:11.000Z","path":"2019/03/27/e5-bf-83-e8-b7-b3-e4-bf-9d-e6-b4-bb/","text":"文章：JackJiang2011/为什么说基于TCP的移动端IM仍然需要心跳保活？ 一、前言TCP 协议自身有 KeepAlive 机制，为何基于它的通讯链接，仍然需要在应用层实现额外的心跳保活？本文将从移动端 IM 实践的角度说明，即使使用 TCP 协议，应用层的心跳保活仍旧必不可少。有关 TCP 协议的权威理论介绍，请参见《TCP/IP详解》。 移动端IM开发推荐文章：《新手入门一篇就够：从零开发移动端IM》 二、参考资料《TCP/IP详解-第11章·UDP：用户数据报协议》 《TCP/IP详解-第17章·TCP：传输控制协议》 《TCP/IP详解-第18章·TCP连接的建立与终止》 《TCP/IP详解-第21章·TCP的超时与重传》 《通俗易懂-深入理解TCP协议（上）：理论基础》 《通俗易懂-深入理解TCP协议（下）：RTT、滑动窗口、拥塞处理》 《理论经典：TCP协议的3次握手与4次挥手过程详解》 《计算机网络通讯协议关系图（中文珍藏版）》 《NAT详解：基本原理、穿越技术（P2P 打洞）、端口老化等》 三、心跳保活在使用 TCP 长连接的 IM 服务设计中，往往都会涉及到心跳。心跳一般是指某端（绝大多数情况下是客户端）每隔一定时间向对端发送自定义指令，以判断双方是否存活，因其按照一定间隔发送，类似于心跳，故被称为心跳指令。 有兴趣了解 IM/推送的心跳保活技术的文章，请参见：《Android进程保活详解：一篇文章解决你的所有疑问》《Android端消息推送总结：实现原理、心跳保活、遇到的问题等》《微信团队原创分享：Android版微信后台保活实战分享(进程保活篇)》《微信团队原创分享：Android版微信后台保活实战分享(网络保活篇)》《移动端IM实践：实现Android版微信的智能心跳机制》《移动端IM实践：WhatsApp、Line、微信的心跳策略分析》&gt;&gt;更多同类文章 …… 四、TCP 协议的 KeepAlive为什么需要在应用层做心跳，难道 TCP 不是个可靠连接吗？我们不能够依赖 TCP 做断线检测吗？比如使用 TCP 的 KeepAlive 机制来实现。应用层心跳是目前的最佳实践吗？怎么样的心跳才是最佳实践。很多做移动端 IM 的同行，以前确实没有仔细考虑过这些问题，潜意识里想当然的认为这仅仅只是个简单的心跳而已啊。事实并非这么简单。 五、IM 中保持有效长连接的重要性对于客户端而言，使用 TCP 长连接来实现业务的最大驱动力在于：在当前连接可用的情况下，每一次请求都只是简单的数据发送和接受，免去了 DNS 解析，连接建立等时间，大大加快了请求的速度，同时也有利于接受服务器的实时消息。但前提是连接可用。 如果连接无法很好地保持，每次请求就会变成撞大运：运气好，通过长连接发送请求并收到反馈。运气差，当前连接已失效，请求迟迟没有收到反馈直到超时，又需要一次连接建立的过程，其效率甚至还不如 HTTP。而连接保持的前提必然是检测连接的可用性，并在连接不可用时主动放弃当前连接并建立新的连接。 基于这个前提，必须要有一种机制用于检测连接可用性。同时移动网络的特殊性也要求客户端需要在空余时间发送一定的信令，避免连接被回收。详见微信和运营商的撕B（另一篇针对微信的信令风暴技术研究文章请见：《微信对网络影响的技术试验及分析》）。而对于服务器而言，能够及时获悉连接可用性也非常重要：一方面服务器需要及时清理无效连接以减轻负载，另一方面也是业务的需求，如游戏副本中服务器需要及时处理玩家掉线带来的问题。 六、TCP 的 KeepAlive 无法替代应用层心跳保活机制的原因说了保持连接的重要性，那么回到具体实现上。为什么我们需要使用应用层心跳来做检测，而不是直接使用 TCP 的特性呢？ TCP 是一个基于连接的协议，其连接状态是由一个状态机进行维护，连接完毕后，双方都会处于 established 状态，这之后的状态并不会主动进行变化。这意味着如果上层不进行任何调用，一直使 TCP 连接空闲，那么这个连接虽然没有任何数据，但仍是保持连接状态，一天、一星期，甚至一个月，即使在这期间中间路由崩溃重启无数次。举个现实中经常遇到的栗子：当我们 ssh 到自己的 VPS 上，然后不小心踢掉网线，此时的网络变化并不会被 TCP 检测出，当我们重新插回网线，仍旧可以正常使用 ssh，同时此时并没有发生任何 TCP 的重连。 有人会说 TCP 不是有 KeepAlive 机制么，通过这个机制来实现不就可以了吗？但是事实上，TCP KeepAlive 的机制其实并不适用于此。Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200s（详情请参见《TCP/IP详解》中第23章），失败后重试 10 次，每次超时时间 75s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。 因为 TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：检测通讯双方的存活状态。两者听起来似乎是一个意思，但实际上却大相径庭。 考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。 从上面可以知道，KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。 七、心跳保活机制的实现方案参考 从上面可以得出结论，目前而言，应用层心跳的确是检测连接有效性，双方是否存活的最佳实践，那么剩下的问题就是怎么实现。 最简单粗暴做法当然是定时心跳，如每隔 30 秒心跳一次，15 秒内没有收到心跳回包则认为当前连接已失效，断开连接并进行重连。这种做法最直接，实现也简单。缺点是比较耗电和耗流量。以一个协议包 5 个字节计算，一天收发 2880 个心跳包，一个月就是 5 2 2880 * 30 = 0.8M 的流量，如果手机上多装几个 IM 软件，每个月只心跳就好几兆流量没了，更不用说频繁的心跳带来的电量损耗。 既然频繁心跳会带来耗电和耗流量的弊端，改进的方向自然是减少心跳频率，但也不能过于影响连接检测的实时性。基于这个需求，一般可以将心跳间隔根据程序状态进行调整，当程序在后台时（这里主要考虑安卓），尽量拉长心跳间隔，5 分钟、甚至 10 分钟都可以。 而当 App 在前台时则按照原来规则操作。连接可靠性的判断也可以放宽，避免一次心跳超时就认为连接无效的情况，使用错误积累，只在心跳超时 n 次后才判定当前连接不可用。当然还有一些小 trick 比如从收到的最后一个指令包进行心跳包周期计时而不是固定时间，这样也能够一定程度减少心跳次数。","tags":[]},{"title":" iOS 编译过程原理(1)\t\t","date":"2019-03-27T07:53:13.000Z","path":"2019/03/27/ios-e7-bc-96-e8-af-91-e8-bf-87-e7-a8-8b-e5-8e-9f-e7-90-86/","text":"文章：iOS编译过程的原理和应用 一、前言一般可以将编程语言分为两种，编译语言和直译式语言。 像 C++、Objective-C 都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率较高。 像 JavaScript、Python 都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为 CPU 可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。 iOS 开发目前的常用语言：Objective 和 Swift。二者都是编译语言，换句话说都是需要编译才能执行的。它们的编译都是依赖于 Clang(swift) + LLVM。本文只关注 Objective-C，原理上大同小异。 充分理解了编译的过程，会对你的开发大有帮助。本文的最后，会以以下几个例子，来讲解如何合理利用 XCode 和编译 __attribute__ Clang 警告处理 预处理 插入编译期脚本 提高项目编译速度 对于不想看我啰里八嗦讲一大堆原理的同学，可以直接跳到本文的最后一个章节。 二、iOS 编译Objective-C 采用 Clang 作为前端，而 Swift 则采用 swift() 作为前端，都是 LLVM（Low level vritual machine）作为编译器后端。所以简单的编译过程如图： 其中，swift 的编译命令可以在这里找到 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift 可以通过 Clang，来查看一个文件的编译具体过程，新建 Demo.m #import &lt;Foundation/Foundation.h&gt; int main(){ @autoreleasepool { NSLog(@”%@”,@”Hello Leo”); } return 0;} 然后终端输入： ~ $ cd /Users/dubin/Desktop/Demo/DemoDemo $Demo $ clang -ccc-print-phases -framework Foundation Demo.m -o Demo0: input, “Foundation”, object1: input, “Demo.m”, objective-c2: preprocessor, {1}, objective-c-cpp-output // 预处理3: compiler, {2}, ir // 编译生成 IR（中间代码）4: backend, {3}, assembler // 汇编器生成汇编代码5: assembler, {4}, object // 生成机器码6: linker, {0, 5}, image // 链接7: bind-arch, “x86_64”, {6}, image // 生成 Image，也就是最后的可执行文件 在终端运行这个程序： Demo $ gcc -framework Foundation Demo.m -o Demo$ ./Demo2019-03-27 13:55:30.426 Demo[14155:5478670] Hello Leo 另一种终端运行 OC 程序的顺序： Demo $ cc -c Demo.mDemo $ cc Demo.o -framework Foundationld: warning: text-based stub file /System/Library/Frameworks//Foundation.framework/Foundation.tbd and library file /System/Library/Frameworks//Foundation.framework/Foundation are out of sync. Falling back to library file for linking.ld: warning: text-based stub file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation.tbd and library file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation are out of sync. Falling back to library file for linking.Demo $ ./a.out2019-03-27 14:01:52.933 a.out[14413:5483194] Hello Leo cc -c tst.m 编译：生成 tst.o文件 cc -c man.m 编译： 生成 man.o 文件 cc tst.o man.o -framework Foundation 链接、合并：生成 a.out 可执行文件 ./a.out 运行 当然 OC 程序还可以混编 C 程序，格式为：cc -c x.m x.c，或者直接将编译和链接合在一起：cc x.m x.c 1、编译器前端 编译器前端的任务是：语法分析、语义分析、生成中间代码（intermediate representation）。在这个过程中会进行类型检查，如果发现错误或者警告会标注出来在哪一行。 2、编译器后端 编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS 的编译过程，后端的处理如下 ①、LVVM 优化器会进行 BitCode 的生成，链接期优化等等。 ②、LLVM 机器码生成器会针对不同的架构，比如 arm64 等生成不同的机器码。 三、执行一次 XCode build 的流程当你在 XCode 中，选择 build 的时候（快捷键 command+B），会执行如下过程 编译信息写入辅助文件，创建编译后的文件架构（name.app） 处理文件打包信息，例如在 debug 环境下 Entitlements:{ “application-identifier” = “app的bundleid”; “aps-environment” = development;} 执行 CocoaPod 编译前脚本。例如对于使用 CocoaPod 的工程会执行 CheckPods Manifest.lock 编译各个 .m 文件，使用 CompileC 和 clang 命令。 CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compilerexport LANG=en_US.US-ASCIIexport PATH=”…”clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I 上文提到的文件 -F 所需要的Framework -iquote 所需要的Framework … -c ClassName.c -o ClassName.o 通过这个编译的命令，我们可以看到 clang是实际的编译命令-x objective-c 指定了编译的语言-arch x86_64制定了编译的架构，类似还有arm7等-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本-I 把编译信息写入指定的辅助文件-F 链接所需要的Framework-c ClassName.c 编译文件-o ClassName.o 编译产物 链接需要的 Framework，例如 Foundation.framework、AFNetworking.framework、AliPay.framework 编译 xib 文件 拷贝 xib，图片等资源文件到结果目录 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝 Swift 标准库 创建 .app 文件和对其签名 四、ipa 包的内容例如，通过 iTunes Store 下载微信，获得 ipa 安装包，然后实际看看其安装包的内容。 右键 ipa，重命名为 .zip 双击 zip 文件，解压缩后会得到一个文件夹。所以，ipa 包就是一个普通的压缩包。 右键图中的 `WeChat`，选择显示包内容，然后就能够看到实际的 ipa 包内容了。 五、二进制文件的内容通过 XCode 的 Link Map File，我们可以窥探二进制文件中布局。在 XCode -&gt; Build Settings -&gt; 搜索 map -&gt; 开启Write Link Map File。 开启后，在编译，我们可以在对应的 Debug/Release 目录下看到对应的 link map 的 text 文件。 默认的目录： ~/Library/Developer/Xcode/DerivedData/-对应ID/Build/Intermediates/.build/Debug-iphoneos/.build/ 例如 TargetName是 Demo 的目录： /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build 这个映射文件的主要包含以下部分： 1、Object files 这个部分包括的内容： .o 文文件，也就是上文提到的 .m 文件编译后的结果。 .a 文件 需要 link 的 framework # Arch: x86_64# Object files:[ 0] linker synthesized[ 1] dtrace[ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o[ 3] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/ViewController.o[ 4] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/Person.o[ 5] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyOperation.o[ 6] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/main.o [130] /Applications/Xcode10.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//CoreGraphics.framework/CoreGraphics.tbd 这个区域的存储内容比较简单：前面是文件的编号，后面是文件的路径。文件的编号在后续会用到。 2、Sections 这个区域提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小。这个区域完整的描述了可执行文件中的全部内容。其中，段分为两种： __TEXT 代码段 __DATA 数据段 从 Sections 区域可以看到，代码段的 text 节的地址是 0x100001000，大小是 0x000A5FF9，而二者相加的下一个位置正好是 stubs 的位置 0x1000A6FFA。 # Sections:# 位置 大小 段 节# Address Size Segment Section0x100001000 0x000A5FF9 __TEXT __text // 代码0x1000A6FFA 0x000003D8 __TEXT __stubs0x1000A73D4 0x00000678 __TEXT __stub_helper0x1000A7A4C 0x0000794A __TEXT __objc_methname // OC 方法名0x1000AF396 0x000079F4 __TEXT __cstring // 字符串0x1000B6D8A 0x0000092C __TEXT __objc_classname // OC 类名0x1000B76B6 0x00002293 __TEXT __objc_methtype // OC 方法类型0x1000B9950 0x000000E8 __TEXT __const // 常量0x1000B9A38 0x000043DC __TEXT __gcc_except_tab0x1000BDE14 0x0000004A __TEXT __ustring0x1000BDE5E 0x00000166 __TEXT __entitlements0x1000BDFC4 0x0000037B __TEXT __dof_RACSignal0x1000BE33F 0x000002E8 __TEXT __dof_RACCompou0x1000BE628 0x000009CC __TEXT __unwind_info0x1000BF000 0x00000010 __DATA __nl_symbol_ptr0x1000BF010 0x000001B8 __DATA __got0x1000BF1C8 0x00000520 __DATA __la_symbol_ptr0x1000BF6E8 0x00005D28 __DATA __const0x1000C5410 0x00002E80 __DATA __cfstring0x1000C8290 0x00000268 __DATA __objc_classlist // OC 方法列表0x1000C84F8 0x000001C0 __DATA __objc_catlist0x1000C86B8 0x00000098 __DATA __objc_protolist // OC 协议列表0x1000C8750 0x00000008 __DATA __objc_imageinfo0x1000C8758 0x0000F0C0 __DATA __objc_const // OC 常量0x1000D7818 0x00001B28 __DATA __objc_selrefs0x1000D9340 0x00000040 __DATA __objc_protorefs0x1000D9380 0x00000360 __DATA __objc_classrefs0x1000D96E0 0x00000170 __DATA __objc_superrefs // OC 父类引用0x1000D9850 0x00000610 __DATA __objc_ivar // OC ivar0x1000D9E60 0x00001810 __DATA __objc_data0x1000DB670 0x00000768 __DATA __data0x1000DBDD8 0x0000015F __DATA __bss 3、Symbols Section 部分将二进制文件进行了一级划分。而 Symbols 对 Section 中的各个段进行了二级划分，例如，对于 __TEXT __text 表示代码段中的代码内容。 0x100001000 0x000A5FF9 __TEXT __text // 代码 而对应的 Symbols，起始地址也是 0x1000021B0。其中，文件编号和上文的编号对应 0x100001000 0x000000A0 [ 2] +[MyProxy proxyWithObj:] [ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o 具体内容： # Symbols:# 地址 大小 文件编号 方法名# Address Size File Name0x100001000 0x000000A0 [ 2] +[MyProxy proxyWithObj:]0x1000010A0 0x00000040 [ 2] -[MyProxy methodSignatureForSelector:]0x1000010E0 0x000003F0 [ 2] -[MyProxy forwardInvocation:]0x1000014D0 0x00000040 [ 2] -[MyProxy .cxx_destruct]0x100001510 0x00000048 [ 2] -[Dog barking:]0x100001560 0x00000060 [ 3] -[ViewController dealloc]0x1000015C0 0x000001C0 [ 3] -[ViewController drawImage:… 到这里，我们知道 OC 的方法是如何存储的，再来看看 ivar 是如何存储的。 首先找到数据栈中 __DATA __objc_ivar 0x1000D9850 0x00000610 __DATA __objc_ivar 然后，搜索这个地址 0x1000D9850，就能找到 ivar 的存储区域。 0x1000D9850 0x00000008 [ 2] _OBJC_IVAR_$_MyProxy.__innerObj 值得一提的是，对于 String，会显式的存储到数据段中，例如： 0x1000AF3F2 0x00000004 [ 3] literal string: http://www.baidu.com 所以，若果你的加密 Key 以明文的形式写在文件里，是一件很危险的事情。 六、dSYM 文件在每次编译过后，都会生成一个 dsym 文件。dsym 文件中，存储了 16 进制的函数地址映射。 在 App 实际执行的二进制文件中，是通过地址来调用方法的。在 App crash 的时候，第三方工具（Fabric、友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含 crash 地址的调用信息。然后通过 dSYM 文件，我们就可以由地址映射到具体的函数位置。 XCode 中选择 Window -&gt; Organizer 可以看到生成的 archier 文件。 然后 右键 -> 在 finder 中显示。 右键 -> 查看包内容。 关于如何用 dsym 文件来分析崩溃位置，查看另一篇博客：iOS 如何调试第三方统计到的崩溃报告 七、应用场景1、__attribute__ 或多或少都会在第三方库或者 iOS 的头文件中，见到过 __attribute__。比如 __attribute__ ((warn_unused_result)) // 如果没有使用返回值，编译的时候给出警告 __attribtue__ 是一个高级的的编译器指令，它允许开发者指定更多的编译检查和一些高级的编译期优化。 分为三种： 函数属性（Function Attribute） 类型属性（Variable Attribute） 变量属性（Type Attribute） 语法结构 __attribute__ 语法格式为：__attribute__ ((attribute-list)) 放在声明分号 “;” 前面。 比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了。 @property (nonatomic, strong) CLASSNAME * property __deprecated; 好处： 给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的 API，但是被 __deprecated 的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新 Pod 的时候，代码无法运行了。 __attribtue__ 的使用场景很多，本文只列举 iOS 开发中常用的几个： // 弃用 API，用作 API 更新 #define __deprecated __attribute__((deprecated)) // 带描述信息的弃用 #define __deprecated_msg(_msg) __attribute__((deprecated(_msg))) // 遇到 __unavailable 的变量/方法，编译器直接抛出 Error #define __unavailable __attribute__((unavailable)) // 告诉编译器，即使这个变量/方法没被使用，也不要抛出警告 #define __unused __attribute__((unused)) // 和 __unused 相反 #define __used __attribute__((used)) // 如果不使用方法的返回值，进行警告 #define __result_use_check __attribute__((__warn_unused_result__)) // OC 方法在 Swift 中不可用 #define __swift_unavailable(_msg) __attribute__((__availability__(swift, unavailable, message=_msg))) 2、Clang 警告处理 你一定还见过如下代码： #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wundeclared-selector”/// 代码 #pragma clang diagnostic pop 这段代码的作用是 对当前编译环境进行压栈 忽略 -Wundeclared-selector（未声明的）Selector 警告 编译代码 对编译环境进行出栈 通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。 在另一篇文章：iOS 合理利用 Clang 警告来提高代码质量，详细的介绍了 XCode 的警告相关内容。 3、预处理 所谓预处理，就是在编译之前的处理。预处理能够让你定义编译器变量，实现条件编译。 比如，这样的代码很常见 #ifdef DEBUG//… #else//… #endif 我们同样也可以定义其他预处理变量，在 XCode -&gt; 选中 Target -&gt; build settings 中，搜索 preprocessor。可以分别为 Debug 和 Release 两种模式设置预处理宏。 比如加上：TESTMODE = 1，表示在这个宏中的代码运行在测试服务器。 然后，配合多个 Target（右键 Target，选择 Duplicate），单独一个 Target 负责测试服务器。这样就不用每次切换测试服务器都要修改代码了。 #ifdef TESTMODE// 测试服务器相关的代码 #else// 生产服务器相关代码 #endif 4、插入脚本 通常，如果你使用 CocoaPod 来管理三方库，那么你的 Build Phase 是这样子的： 其中：[CP] 开头的就是 CocoaPod 插入的脚本。 Check Pods Manifest.lock，用来检查 cocoapod 管理的三方库是否需要更新 Embed Pods Framework，运行脚本来链接三方库的静态/动态库 Copy Pods Resources，运行脚本来拷贝三方库的资源文件 而这些配置信息都存储在这个文件（.xcodeproj）里。 到这里，CocoaPod 的原理也就大致搞清楚了，通过修改 xcodeproject，然后配置编译期脚本，来保证三方库能够正确的编译连接。 同样，我们也可以插入自己的脚本来做一些额外的事情。比如，每次进行 archive 的时候，我们都必须手动调整 target 的 build 版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。 buildNumber=$(/usr/libexec/PlistBuddy -c “Print CFBundleVersion” “${PROJECT_DIR}/${INFOPLIST_FILE}”)buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c “Set :CFBundleVersion $buildNumber” “${PROJECT_DIR}/${INFOPLIST_FILE}” 这段脚本其实很简单，读取当前 plist 的 build 版本号，然后对其 +1，重新写入。 使用起来也很简单： Xcode -&gt; 选中 Target -&gt; 选中 build phase 选择添加 Run Script Phase 然后把这段脚本拷贝进去，并且勾选 Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为 Auto Increase build number 然后，拖动这个脚本的到 Link Binary With Libraries 下面。 5、脚本编译打包 脚本化编译打包对于 CI（持续集成）来说，十分有用。iOS 开发中，编译打包必备的两个命令是： // 编译成.appxcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDir// 打包xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa // 通过 info 命令，可以查看到详细的文档info xcodebuild 在本文最后的附录中，提供一个自动打包的脚本。 6、提高项目编译速度 通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了 XCode 的编译过程后，我们可以从以下角度来优化编译速度。 ①、查看编译时间 我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。 对于 XCode 8，关闭 XCode，终端输入以下指令 $ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 然后，重启 XCode，再编译，你会在这里看到编译时间。 ②、代码层面的优化 forward declaration 所谓 forward declaration，就是 @class CLASSNAME，而不是 #import CLASSNAME.h。这样，编译器能大大提高 #import 的替换速度。 对常用的工具类进行打包（Framework/.a） 打包成 Framework 或者静态库，这样编译的时候这部分代码就不需要重新编译了。 常用头文件放到预编译文件里 pch 文件是预编译文件，这里的内容在执行 XCode build 之前就已经被预编译，并且引入到了每一个 .m 文件里。 ③、编译器选项优化 Debug 模式下，不生成 dsym 文件 上文提到了，dysm 文件里存储了调试信息，在 Debug 模式下，我们可以借助 XCode 和 LLDB 进行调试。所以，不需要生成额外的 dsym 文件来降低编译速度。 Debug 开启 Build Active Architecture Only 在 XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为 YES。这样做，可以只编译当前的版本，比如 arm7/arm64 等等，记得只开启 Debug 模式。这个选项在高版本的 XCode 中自动开启了。 Debug 模式下，关闭编译器优化 八、附录自动编译打包脚本 export LC_ALL=zh_CN.GB2312;export LANG=zh_CN.GB2312buildConfig=”Release” //这里是build模式projectName=`find . -name *.xcodeproj | awk -F “[/.]“ ‘{print $(NF-1)}’`projectDir=`pwd`wwwIPADir=~/Desktop/$projectName-IPAisWorkSpace=trueecho “~~~~~开始编译~~~~~”if [ -d “$wwwIPADir” ]; thenecho $wwwIPADirecho “文件目录存在”elseecho “文件目录不存在”mkdir -pv $wwwIPADirecho “创建${wwwIPADir}目录成功”ficd $projectDirrm -rf ./buildbuildAppToDir=$projectDir/buildinfoPlist=”$projectName/Info.plist”bundleVersion=/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlistbundleIdentifier=/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlistbundleBuildVersion=/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist if $isWorkSpace ; then #是否用CocoaPodecho “开始编译workspace….”xcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirelseecho “开始编译target….”xcodebuild -target $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDirfi if test $? -eq 0thenecho “~~~~~编译成功~~~“elseecho “~~~编译失败~~~~~”exit 1fi ipaName=`echo $projectName | tr “[:upper:]“ “[:lower:]“` #将项目名转小写findFolderName=`find . -name “$buildConfig-*” -type d |xargs basename` #查找目录appDir=$buildAppToDir/$findFolderName/ #app所在路径echo “开始打包$projectName.app成$projectName.ipa…..”xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa if [ -f “$appDir/$ipaName.ipa” ]thenecho “打包$ipaName.ipa成功.”elseecho “打包$ipaName.ipa失败.”exit 1fi path=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipacp -f -p $appDir/$ipaName.ipa $path #拷贝ipa文件echo “复制$ipaName.ipa到${wwwIPADir}成功”echo “~~~~~结束编译，处理成功~~~~~”","tags":[]},{"title":" Runtime(2)\t\t","date":"2019-03-27T03:21:59.000Z","path":"2019/03/27/runtime2/","text":"文章：iOS开发-Runtime 详解、iOS RunTime 之数据结构、iOS 模块分解—「Runtime面试、工作」、Runtime 源码 一、简介C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。函数标识与函数实现之间的关联可以动态修改。Runtime 是 Objective 不可缺少的重要一部分。 Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事： 1、封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。 2、传递消息，找出方法的最终执行代码。 ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）；②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 => 备用接收者 => 签名+打包+完整转发） 动态加载：NSBundle类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。 [receiver message];// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)[receiver message:(id)arg…];// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, …) 也就是说，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，我们还需要一个运行时系统（Runtime system）来处理编译后的代码。 二、作用Objc 与 Runtime 相关： ①、通过 Objective-C 源代码②、通过 Foundation 框架的 NSObject 类定义的方法③、通过对 Runtime 库函数的直接调用 1、Objective-C 源代码 多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。 2、通过 Foundation 框架的 NSObject 类定义的方法 Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类） NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。 一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如： -class 方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中 -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol: 检查对象是否实现了指定协议类的方法； -methodForSelector: 返回指定方法实现的地址。 3、通过对 Runtime 库函数的直接调用 Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。 许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。 三、术语及其数据结构SEL 它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度。它的数据结构是： typedef struct objc_selector *SEL; // An opaque type that represents a method selector. 可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。 注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 id id 是一个参数类型，它是指向某个类的实例的指针。定义如下： typedef struct objc_object *id;struct objc_object { Class isa; }; objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。 Direct access to Objective-C’s isa is deprecated in favor of object_getClass() KVO 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。 Class typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ /* 父类 / Class _Nullable super_class OBJC2_UNAVAILABLE; /\\ 类名 / const char _Nonnull name OBJC2_UNAVAILABLE; /\\* 类的版本信息，默认为 0 */ long version OBJC2_UNAVAILABLE; /\\* 类信息，供运行时期使用的一些位标识。 如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量; CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; */ long info OBJC2_UNAVAILABLE; /\\* 实例变量大小（包括从父类继承下来的实例变量）*/ long instance\\_size OBJC2\\_UNAVAILABLE; /\\* 成员变量地址列表 */ struct objc\\_ivar\\_list * \\_Nullable ivars OBJC2\\_UNAVAILABLE; /\\* 方法地址列表，与 info 的一些标志位有关。 如 CLS\\_CLASS (0x1L)，则存储实例方法；CLS\\_META (0x2L)，则存储类方法; */ struct objc\\_method\\_list * \\_Nullable * \\_Nullable methodLists OBJC2_UNAVAILABLE; /\\* 缓存最近使用的方法地址，用于提升效率 */ struct objc\\_cache * \\_Nonnull cache OBJC2_UNAVAILABLE; /\\* 存储该类声明遵守的协议的列表 */ struct objc\\_protocol\\_list * \\_Nullable protocols OBJC2\\_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表： // 成员变量列表struct objc_ivar_list { int ivar_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;} OBJC2_UNAVAILABLE; // 方法列表struct objc_method_list { struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method\\_count OBJC2\\_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;} 由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。深入理解 Objective-C: Category。 objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。 值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。 实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）； 类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。 为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。 [NSObject.class alloc]; // [NSObject alloc] 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。 最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。 Method 代表类中某个方法的类型。 typedef struct objc_method *Method; struct objc_method { SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法名 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法实现} method_name 类型为 SEL method_types 是个 char 指针，存储方法的参数类型和返回值类型 method_imp 指向了方法的实现，本质是一个函数指针 Ivar 表示成员变量的类型。 typedef struct objc_ivar *Ivar; struct objc_ivar { char _Nullable ivar_name OBJC2_UNAVAILABLE; char _Nullable ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节 #ifdef __LP64__ int space OBJC2_UNAVAILABLE; // 占用空间 #endif} IMP objc.h 中定义如下： // 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针typedef id (*IMP)(id, SEL, …); 它就是一个由编译器生成的函数指针，指向方法实现的首地址。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。 如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。 你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。 Cache runtime.h 中定义如下： typedef struct objc_cache *Cache struct objc_cache { /* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。/ unsigned int mask / total = mask + 1 */ OBJC2_UNAVAILABLE; /\\* 实际占用cache buckets的总数 */ unsigned int occupied OBJC2_UNAVAILABLE; /\\* 指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。 指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长 */ Method \\_Nullable buckets\\[1\\] OBJC2\\_UNAVAILABLE; }; Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。 Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。 Property typedef struct objc_property Property;typedef struct objc_property objc_property_t; // 这个更常用 可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性： OBJC_EXPORT objc_property_t _Nonnull _Nullableclass_copyPropertyList(Class _Nullable cls, unsigned int _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); OBJC_EXPORT objc_property_t _Nonnull _Nullableprotocol_copyPropertyList(Protocol _Nonnull proto, unsigned int * _Nullable outCount) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。 property_getName() 用来查找属性的名称，返回 c 字符串。property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。 四、消息体会官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。 这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤： ①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数； ②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。 ③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。 ④、如果 cache 找不到就找类的方法列表中是否有对应的方法。 ⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。 ⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。 在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。 1、方法中的隐藏参数 我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？ 其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。 当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数： self 当前方法的对象指针，接受消息的对象 _cmd 当前方法的 SEL 指针，方法选择器 因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。 这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。 这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体： struct objc_super { /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class; #else __unsafe_unretained _Nonnull Class super_class; #endif /* super_class is the first class to search */}; 这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现： NSLog(@”%@”, NSStringFromClass([super class])); 2018-11-05 11:30:25.082134+0800 Demo[22838:128408] ViewController // 当前类 2、获取方法地址 NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP： { CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) { \\[self fail:YES\\]; } NSLog(@&quot;%f&quot;, CFAbsoluteTimeGetCurrent() - ti); } - (void)fail:(BOOL)value{ } 2018-11-05 13:06:22.683838+0800 Demo[36187:211037] 4.104993 { void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(fail:)]; CFTimeInterval ti = CFAbsoluteTimeGetCurrent(); for (int i = 0; i &lt; 10000; i++) { setter(self, @selector(fail:), YES); } NSLog(@&quot;%f&quot;, CFAbsoluteTimeGetCurrent() - ti); } 2018-11-05 13:05:48.480498+0800 Demo[36095:209893] 3.751424 虽然是更高效的调用方法，但这种做法很少用，除非是需要持续大量重复调用某个方法的情况，才会选择使用，以免消息发送泛滥。 注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性 五、动态方法解析如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。 @dynamic propertyName; 这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。 Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。 void dynamicIMP(id self, SEL _cmd) { // implementation ….} @implementation MyClass + (BOOL)resolveInstanceMethod:(SEL)aSEL{ if (aSEL == @selector(resolveThisMethodDynamically)) { class_addMethod([self class], aSEL, (IMP) dynamicIMP, “v@:”); return YES; } return [super resolveInstanceMethod:aSEL];} @end 上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：Type Encoding 动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。 六、消息转发 ①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步； ②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步； ③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步； ④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。 1、重定向 消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。 - (id)forwardingTargetForSelector:(SEL)aSelector{ if(aSelector == @selector(xxx:)){ return otherObj; } return [super forwardingTargetForSelector:aSelector];} 如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。 2、转发 当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑： - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ return [otherObj methodSignatureForSelector:aSelector];} /** * @param anInvocation 封装了原始的消息和消息的参数 */- (void)forwardInvocation:(NSInvocation *)anInvocation{ // 判断 otherObj 对象是否实现了方法 if ([otherObj respondsToSelector:[anInvocation selector]]) { [anInvocation invokeWithTarget:otherObj]; } else { [super forwardInvocation:anInvocation]; }} 开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。 参数 anInvocation 是从哪来的？ 在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。 当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。 forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。 forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。 3、转发和多继承 转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。 在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。 4、转发与继承 虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。 如果判断上图中的 Warrior 对象是否能响应 negotiate 消息： if ( [aWarrior respondsToSelector:@selector(negotiate)] ) … 尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。 如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法： - (BOOL)respondsToSelector:(SEL)aSelector{ if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can \\ be forwarded to another object and whether that \\ object can respond to it. Return YES if it can. */ } return NO;} 除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。 如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。 七、健壮的实例变量(Non Fragile ivars)在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。 当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移： 上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了： 我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？ 在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。 需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。","tags":[]},{"title":" Runtime(1)\t\t","date":"2019-03-27T02:26:39.000Z","path":"2019/03/27/runtime1/","text":"文章：Mike_zh/iOS-Runtime知识点整理、ian/Objective-C Runtime 1小时入门教程 一、简介OC 是一门动态语言，所以它会把一些决定工作从编译链接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。 Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。 当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。runtime源码，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。 二、Runtime 相关的头文件ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件 List.hNSObjCRuntime.hNSObject.hObject.hProtocol.ha.txthashtable.hhashtable2.hmessage.hmodule.mapobjc-api.hobjc-auto.hobjc-class.hobjc-exception.hobjc-load.hobjc-runtime.hobjc-sync.hobjc.hruntime.h 都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括： 1、操作对象的类型的定义 /// An opaque type that represents a method in a class definition. 一个类型，代表着类定义中的一个方法typedef struct objc_method *Method; /// An opaque type that represents an instance variable. 代表实例(对象)的变量typedef struct objc_ivar *Ivar; /// An opaque type that represents a category. 代表一个分类typedef struct objc_category *Category; /// An opaque type that represents an Objective-C declared property. 代表OC声明的属性typedef struct objc_property *objc_property_t; // Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list _Nullable _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list _Nullable protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取： Class cls = obj.class;// NSLog(@”%s”, cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLEconst char * clsName = class_getName(cls);NSLog(@”%s”, clsName); 2、函数的定义 操作对象的方法一般以 object_ 开头操作类的方法一般以 class_ 开头操作类或对象的方法的方法一般以 method_ 开头操作成员变量的方法一般以 ivar_ 开头操作属性的方法一般以 property_ 开头操作协议的方法一般以 protocol_ 开头 以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。 根据以上的函数的前缀可以大致了解到层级关系。 // 使用 runtime 对当前的应用中加载的类进行打印- (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ unsigned int count = 0; Class * clsList = objc_copyClassList(&amp;count); for (int i = 0; i &lt; count; i++) { const char * clsName = class_getName(clsList\\[i\\]); NSLog(@&quot;%s&quot;, clsName); } } 三、技术点// 简单的定义了一个成员变量和两个属性@interface Person : NSObject{ @private CGFloat _height;}@property (nonatomic, copy) NSString * name;@property (nonatomic, assign) NSInteger age; @end 1、获取属性/成员变量列表 使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表： - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ Class cls = NSClassFromString(@”Person”); // Class cls = Person.class; unsigned int count = 0; // 获取成员变量数组 Ivar * ivarList = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) { // 获取成员变量名 const char * ivarName = ivar_getName(ivarList\\[i\\]); NSLog(@&quot;%s&quot;, ivarName); } // 获取属性数组 objc\\_property\\_t * ptyList = class_copyPropertyList(cls, &amp;count); for (int i = 0; i &lt; count; i++) { const char * ptyName = property_getName(ptyList\\[i\\]); NSLog(@&quot;%s&quot;, ptyName); } } 2018-11-04 17:28:03.905326+0800 Demo[5894:1444503] _height2018-11-04 17:28:03.905486+0800 Demo[5894:1444503] _name2018-11-04 17:28:03.905616+0800 Demo[5894:1444503] _age2018-11-04 17:28:03.905745+0800 Demo[5894:1444503] name2018-11-04 17:28:03.905877+0800 Demo[5894:1444503] age 从这里就可以看出 @property 做了三件事： ①、生成一个带下划线的成员变量②、生成这个成员变量的 set 方法③、生成这个成员变量的 get 方法 因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。 @property (nonatomic, copy, readonly) NSString * name; // 只读属性 - (NSString *)name{ return @”job”;} 2018-11-04 17:52:52.690815+0800 Demo[6025:1474196] _height2018-11-04 17:52:52.691025+0800 Demo[6025:1474196] _age2018-11-04 17:52:52.691159+0800 Demo[6025:1474196] name2018-11-04 17:52:52.691308+0800 Demo[6025:1474196] age 当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。 一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好? 大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。 在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？ 首先要了解 setValue:forKeyPath: 方法的底层实现： ①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]②、查找有没有成员变量 _XX，如果有 _XX = value；③、查找有没有成员变量 XX，如果有 XX = value；④、如果都没有找到，直接报错。 Terminating app due to uncaught exception ‘NSUnknownKeyException’,reason: ‘[ setValue:forUndefinedKey:]:this class is not key value coding-compliant for the key name.’ 首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。 另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc； 使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。 要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。 @property (nonatomic, weak) NSTimer timer;@property (nonatomic, strong) NSThread thread;@property (nonatomic, strong, readonly) AModel * a; // 自定义对象 { unsigned int count = 0; objc_property_t * propertyList = class_copyPropertyList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) { NSLog(@&quot;%s&quot;, property_getAttributes(propertyList\\[i\\])); } } 2018-11-05 15:09:37.839596+0800 Demo[39749:288880] T@”NSTimer”,W,N,V_timer2018-11-05 15:09:37.839692+0800 Demo[39749:288880] T@”NSThread”,&amp;,N,V_thread2018-11-05 15:09:37.839771+0800 Demo[39749:288880] T@”AModel”,R,N,V_a 通过 property_getAttributes() 方法获取属性的参数。 四、应用场景1、KVC字典转模型 获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue: forKeyPath: 方法设置值。 为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程： ①、遍历字典里面的所有 key，取出 key；②、取出 key 的 value，即 dict[key]；③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。 因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。 因此使用逐一为属性赋值的方法进行 KVC： - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ Class cls = Person.class; unsigned int count = 0; Person * person = \\[\\[Person alloc\\] init\\]; NSDictionary * dict = @{ @&quot;name&quot; : @&quot;Tom&quot;, @&quot;age&quot; : @19, @&quot;height&quot;: @175 }; Ivar * ivars = class_copyIvarList(cls, &amp;count); for (int i = 0; i &lt; count; i++) { const char * clsName = ivar_getName(ivars\\[i\\]); NSString * name = \\[NSString stringWithUTF8String:clsName\\]; NSString * key = \\[name substringFromIndex:1\\]; // 去掉&apos;_&apos; \\[person setValue:dict\\[key\\] forKey:key\\]; } } 2018-11-04 19:42:16.964474+0800 Demo[6425:1574210] height:175.0000，name:Tom，age:19，time:(null) 使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。 但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。 setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。 解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。 runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。Type Encodings for (int i = 0; i &lt; count; i++) { const char ivarName = ivar_getName(ivars[i]); NSString name = [NSString stringWithUTF8String:ivarName]; NSString * key = [name substringFromIndex:1]; const char * coding = ivar_getTypeEncoding(ivars\\[i\\]); // 获取类型 NSString * strCode = \\[NSString stringWithUTF8String:coding\\]; id value = dict\\[key\\]; if (\\[strCode isEqualToString:@&quot;f&quot;\\]) { // 判断类型是否是 float value = @(0.0); } \\[person setValue:value forKey:key\\]; } method_getTypeEncoding() 函数可以获取到方法类型编码 { Method m = class_getInstanceMethod(self.class, @selector(do:at:on:)); NSLog(@&quot;%s&quot;, method_getTypeEncoding(m)); }- (BOOL)do:(NSString *)something at:(char)place on:(int)count; 2018-11-05 14:42:30.891829+0800 Demo[38588:270099] B32@0:8@16c24i28 property_getAttributes() 函数可以获取到属性的参数。Declared Properties 2、NSCoding 归档和解档 获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样： - (void)encodeWithCoder:(NSCoder )aCoder{ unsigned int count = 0; Ivar ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) { const char * ivarName = ivar_getName(ivars\\[i\\]); NSString * name = \\[NSString stringWithUTF8String:ivarName\\]; NSString * key = \\[name substringFromIndex:1\\]; id value = \\[self valueForKey:key\\]; // 取出 key 对应的 value \\[aCoder encodeObject:value forKey:key\\]; // 编码 } } - (id)initWithCoder:(NSCoder *)aDecoder{ if (self = [super init]) { unsigned int count = 0; Ivar * ivars = class_copyIvarList(self.class, &amp;count); for (int i = 0; i &lt; count; i++) { const char * ivarName = ivar_getName(ivars\\[i\\]); NSString * name = \\[NSString stringWithUTF8String:ivarName\\]; NSString * key = \\[name substringFromIndex:1\\]; id value = \\[aDecoder decodeObjectForKey:key\\]; // 解码 \\[self setValue:value forKey:key\\]; // 设置 key 对应的 value } } return self; } 3、交换方法实现 交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。 + (void)load{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Method orginalMethod = class_getClassMethod(\\[UIImage class\\], @selector(imageNamed:)); Method swizzleMethod = class\\_getClassMethod(\\[UIImage class\\], @selector(my\\_imageNamed:)); //方法交换 method_exchangeImplementations(orginalMethod, swizzleMethod); }); } + (UIImage )my_imageNamed:(NSString )name{ return [self my_imageNamed:name];} 注意的是 ①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。 任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。 4、类/对象的关联对象 关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联 /* 参数 1 : 关联到对象 参数 2 : 关联的 key，可以是任意类型 参数 3 : 被关联的对象 参数 4 : 关联引用的规则 enum { OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403 };*/objc_setAssociatedObject(self, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC); id value = objc_getAssociatedObject(self, key); 5、动态添加方法，拦截未实现的方法 每个类都有继承自 NSObject 的两个类方法 + (BOOL)resolveClassMethod:(SEL)sel;+ (BOOL)resolveInstanceMethod:(SEL)sel; 一个适用于类方法，一个适用于对象方法。 在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。 // 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmdvoid method(id self, SEL _cmd) { } + (BOOL)resolveInstanceMethod:(SEL)sel{ if ([NSStringFromSelector(sel) isEqualToString:@”doSomething”]) { /\\* 参数 4 : const char *types 方法的类型 要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。 如果想要再增加参数，就可以从实现的第三个参数算起： class_addMethod(self, sel, method, &quot;v@:@&quot;); // 多一个对象类型参数增加了 @ void method(id self, SEL _cmd, NSString * name) { } 返回值：YES if the method was found and added to the receiver, otherwise NO. */ class_addMethod(self, sel, method, &quot;v@:&quot;); // 为 sel 指定实现为 method } return YES; } 6、动态创建一个类 动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象： #import &lt;objc/message.h&gt; void sayFunction(id self, SEL _cmd, id param) { NSLog(@”%ld岁的%@在%@说%@”, [object_getIvar(self, class_getInstanceVariable([self class], “_age”)) integerValue], object_getIvar(self, class_getInstanceVariable([self class], “_name”)), object_getIvar(self, class_getInstanceVariable([self class], “schoolName”)), param);} - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ // 创建 Student 类。参数 1 : 父类 参数 2 : 类名 参数 3 : 通常为 0 Class StudentClass = objc_allocateClassPair(NSObject.class, “Student”, 0); // 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型 // 必须在 objc\\_allocateClassPair and 和 objc\\_registerClassPair 之间调用 if (class_addIvar(StudentClass, &quot;schoolName&quot;, sizeof(NSString *), 0, &quot;@&quot;)) { NSLog(@&quot;添加成员变量成功&quot;); } // 添加 NSString * _name 成员变量 class\\_addIvar(StudentClass, &quot;\\_name&quot;, sizeof(NSString *), 0, @encode(NSString *)); // 添加 int _age 成员变量 class\\_addIvar(StudentClass, &quot;\\_age&quot;, sizeof(int), 0, @encode(int)); // 为 Student 类添加方法 &quot;v@:&quot; 这种写法见参数类型连接 SEL sel = sel_registerName(&quot;sayFunction:&quot;); if (class_addMethod(StudentClass, sel, (IMP)sayFunction, &quot;v@:@&quot;)) { NSLog(@&quot;添加方法成功&quot;); } // 注册这个类到 runtime 系统中就可以使用了 objc_registerClassPair(StudentClass); // 使用创建的类 id student = \\[\\[StudentClass alloc\\] init\\]; // 给刚刚添加的变量赋值 // object_setInstanceVariable(student, &quot;schoolName&quot;, (void *)&amp;str);在ARC下不允许使用 \\[student setValue:@&quot;清华大学&quot; forKey:@&quot;schoolName&quot;\\]; // KVC 动态改变实例变量 \\[student setValue:@&quot;Tom&quot; forKey:@&quot;name&quot;\\]; // 从类中获取成员变量Ivar Ivar ageIvar = class\\_getInstanceVariable(StudentClass, &quot;\\_age&quot;); // 为peopleInstance的成员变量赋值 object_setIvar(StudentClass, ageIvar, @18); // 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息 objc_msgSend(student, &quot;sayFunction:&quot;, @&quot;你好~&quot;); // \\[student performSelector:sel withObject:@&quot;你好~&quot;\\]; // 动态调用未显式在类中声明的方法 student = nil; StudentClass = nil; // objc_disposeClassPair(StudentClass);} 直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO","tags":[]},{"title":" TCP/IP 协议\t\t","date":"2019-03-26T10:41:17.000Z","path":"2019/03/26/tcp-ip-e5-8d-8f-e8-ae-ae/","text":"技术往事：改变世界的 TCP/IP 协议","tags":[]},{"title":" iOS 内存管理：从 MRC 到 ARC 实践\t\t","date":"2019-03-26T09:48:45.000Z","path":"2019/03/26/ios-e5-86-85-e5-ad-98-e7-ae-a1-e7-90-86-ef-bc-9a-e4-bb-8e-mrc-e5-88-b0-arc-e5-ae-9e-e8-b7-b5/","text":"对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。 iOS 内存管理的核心是引用计数。 接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？ 同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？ NSString str1 = [NSString stringWithFormat:”qqstock”];NSString str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding]; 属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。 self.name = @”qqstock”;_name = @”qqstock”; 一、MRC 的初衷和实现方式苹果为什么要做这个？ 首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。 当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了 crash。 尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了。要么，自己写许许多多的代码，频繁对容器进行主动操作。 于是，苹果要解决这个问题。初衷就是：任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责。 苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。 与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。 另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。” 那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。 OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。 二、MRC 的优点和无奈总结： MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题 为了应对各种复杂的场景，很无奈的留了一个口子； 两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。 难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。 略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。 系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！ 引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。 再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。 三、编程语言和编译器的发展方向由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。 然而，编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？ 许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？ 更何况，人，总有打盹的时候。 四、ARC 的适时推出随着硬件的升级，条件已经成熟了，ARC 到来了！ ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。 之前对 C++ 程序员头疼的问题变得异常简单： NSString str1 = [NSString stringWithFormat:”qqstock”];NSString str2 = [[NSString alloc] initWithData:recvData encoding:NSUTF8StringEncoding];self.name = @”qqstock”;_name = @”qqstock”; 到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。 许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。 逻辑其实很简单。 首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低； 其次，一旦出现弱引用，则将内存对象在系统中建立映射表；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。 总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！ 五、总结如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。 许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。 ①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。 ②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。 ③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。 ④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。","tags":[]},{"title":" GCDAsyncSocket 的封装与使用\t\t","date":"2019-03-26T09:10:13.000Z","path":"2019/03/26/gcdasyncsocket-e7-9a-84-e5-b0-81-e8-a3-85-e4-b8-8e-e4-bd-bf-e7-94-a8/","text":"文章：iOS Socket重构设计、Github：GCDAsyncSocketManager CocoaAsyncSocket 第三方库的用途： CocoaAsyncSocket provides easy-to-use and powerful asynchronous socket libraries for Mac and iOS. CocoaAsyncSocket 为 Mac 和 iOS 提供了易于使用且强大的异步通信库。 它已经支持 IPv4 和 IPv6。 简单的 Socket 通信包括了创建连接、断开连接、发送 socket 业务请求、重连这四个基本功能。 1、创建连接 GCDAsyncSocket 提供了四种初始化的方法 /** * GCDAsyncSocket uses the standard delegate paradigm, * but executes all delegate callbacks on a given delegate dispatch queue. * This allows for maximum concurrency, while at the same time providing easy thread safety. * * You MUST set a delegate AND delegate dispatch queue before attempting to * use the socket, or you will get an error. * * The socket queue is optional. * If you pass NULL, GCDAsyncSocket will automatically create it’s own socket queue. * If you choose to provide a socket queue, the socket queue must not be a concurrent queue. * If you choose to provide a socket queue, and the socket queue has a configured target queue, * then please see the discussion for the method markSocketQueueTargetQueue. * * The delegate queue and socket queue can optionally be the same.**/- (id)init;- (id)initWithSocketQueue:(dispatch_queue_t)sq;- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq;/** * @param aDelegate socket 的代理 * @param dq delegate 的线程 * @param sq socket 的线程。可选的设置，如果传入 null，GCDAsyncSocket 内部会创建一个它自己的 socket 线程，如果你要自己提供一个 socket 线程，千万不要提供一个并发线程，在频繁 socket 通信过程中，可能会阻塞掉 */- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq; @property (atomic, weak, readwrite) id delegate; #if OS_OBJECT_USE_OBJC@property (atomic, strong, readwrite) dispatch_queue_t delegateQueue; #else@property (atomic, assign, readwrite) dispatch_queue_t delegateQueue; #endif 必须要需要设置 socket 的代理以及代理的线程，否则接收不到 socket 的回调。比如： self.socket = [[GCDAsyncSocket alloc] initWithDelegate:delegate delegateQueue:dispatch_get_main_queue()]; 在设置代理之后，你需要尝试连接到相应的地址来确定你的 socket 是否能连通了。 - (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr; host 是主机地址，port 是端口号。 如果建连成功之后，会收到 socket 成功的回调，在成功里面可以做需要做的一些事情，比如：做了心跳的处理。 - (void)socket:(GCDAsyncSocket )sock didConnectToHost:(NSString )host port:(uint16_t)port; 如果建连失败了，会收到失败的回调，在失败里面做重连的操作。 - (void)socketDidDisconnect:(GCDAsyncSocket )sock withError:(NSError )err; 2、重连 重连操作其实比较简单，只需要再调用一次建连请求，重连规则是重连次数为 5 次，每次的时间间隔为 2 的 n 次方，超过次数之后，就不再去重连了。 - (void)socketDidDisconnect:(GCDAsyncSocket)sock withError:(NSError)err{ self.status= -1; if(self.reconnection\\_time &gt;= 0 &amp;&amp; self.reconnection\\_time &lt;= kMaxReconnection_time) { \\[self.timer invalidate\\]; self.timer = nil; int time = pow(2, self.reconnection_time); self.timer = \\[NSTimer scheduledTimerWithTimeInterval:time target:selfselector:@selector(reconnection) userInfo:nil repeats:NO\\]; self.reconnection_time++; NSLog(@&quot;socket did reconnection, after %ds try again&quot;, time); } else { self.reconnection_time = 0; NSLog(@&quot;socketDidDisconnect:%p withError: %@&quot;, sock, err); } } 这里用 status 来标记 socket 的连接状态。 3、socket 通信 需要和后端开发人员商定好 socket 协议格式，比如： [NSString stringWithFormat:@”{\\“version\\“:%d,\\“reqType\\“:%d,\\“body\\“:\\“%@\\“}\\r\\n”, PROTOCOL_VERSION, reqType, reqBody]; 为什么后面需要加上 \\r\\n 呢？ 这个 \\r\\n 是 socket 消息的边界符，是为了防止发生消息黏连。没有 \\r\\n，可能由于某种原因，后端会收到两条 socket 请求，但是后端不知道怎么拆分这两个请求。同理，在收到 socket 请求回调时，也会根据这个边界符去拆分。 那为什么要用 \\r\\n 呢？ GCDAsyncSocket 不支持自定义边界符，它提供了四种边界符供你使用 \\r\\n、\\r、\\n、空字符串。 在拼装好 socket 请求之后，你需要调用 GCDAsyncSocket 的写方法，来发送请求，然后在写完成之后会收到写的回调。 [self.socket writeData:requestData withTimeout:-1 tag:0]; timeout 是超时时间，这个根据实际的需要去设置。 /** * @brief 写的回调 */- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag； 在写之后，需要再调用读方法，这样才能收到你发出请求后从服务器那边收到的数据。 [self.socket readDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:50000 tag:0]; [GCDAsyncSocket CRLFData] 是设置边界符，maxLength 是设置你收到的请求数据内容的最大值。 在读回调里面，你可以根据不同业务来执行不同的操作 - (void)socket:(GCDAsyncSocket )sock didReadData:(NSData )data withTag:(long)tag; 最后一个则是断开连接，这个只需要调用 [self.socket disconnect]; 这样的话，最简单基础的 socket 通信，就已经大致能完成了。 4、在网络环境以及其他因素下，很有可能会造成客户端或者后端没有接收到回调或者请求，那该怎么办？ 需要加上消息回执的处理。客户端发出请求的时候，可以将该请求放到存到数组里面，等到后端的相应回调再移除，如果该请求超时或者在一段时间内没有收到确认返回，说明后端没有接收到客户端的请求，可以将该请求重新发送。 客户端接收请求的时候，后端将数据发给客户端，客户端需要增加回执处理，告诉后端，客户端接收到数据了，如果后端没接收到，也重新推一遍数据，客户端和后端双向保护来解决丢失问题。 5、问题排查 不能定位是否是后端问题还是客户端/SDK 问题时，可以用命令行抓一下 socket 包看看（Charles 只能抓 http、https 包） ~ $ sudo tcpdump -i any -n -X port 6969Password:tcpdump: data link type PKTAPtcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on any, link-type PKTAP (Apple DLT_PKTAP), capture size 262144 bytes15:46:02.776970 IP 127.0.0.1.65211 &gt; 127.0.0.1.6969: Flags [P.], seq 260276795:260276835, ack 1931027326, win 12752, options [nop,nop,TS val 844986136 ecr 844981142], length 40 0x0000: 0200 0000 4500 005c 0000 4000 4006 0000 ….E..\\..@.@… 0x0010: 7f00 0001 7f00 0001 febb 1b39 0f83 823b ………..9…; 0x0020: 7319 237e 8018 31d0 fe50 0000 0101 080a s.#~..1..P…… 0x0030: 325d 7718 325d 6396 7b22 7573 6572 5f6d 2]w.2]c.{“user_m 0x0040: 6964 223a 302c 2272 6571 5479 7065 223a id”:0,”reqType”: 0x0050: 312c 2276 6572 7369 6f6e 223a 357d 0d0a 1,”version”:5}..15:46:02.777010 IP 127.0.0.1.65211 &gt; 127.0.0.1.6969: Flags [P.], seq 0:40, ack 1, win 12752, options [nop,nop,TS val 844986136 ecr 844981142], length 40 0x0000: 0200 0000 4500 005c 0000 4000 4006 0000 ….E..\\..@.@… 0x0010: 7f00 0001 7f00 0001 febb 1b39 0f83 823b ………..9…; 0x0020: 7319 237e 8018 31d0 fe50 0000 0101 080a s.#~..1..P…… 0x0030: 325d 7718 325d 6396 7b22 7573 6572 5f6d 2]w.2]c.{“user_m 0x0040: 6964 223a 302c 2272 6571 5479 7065 223a id”:0,”reqType”: 0x0050: 312c 2276 6572 7369 6f6e 223a 357d 0d0a 1,”version”:5}..15:46:02.777045 IP 127.0.0.1.6969 &gt; 127.0.0.1.65211: Flags [.], ack 40, win 12751, options [nop,nop,TS val 844986136 ecr 844986136], length 0 0x0000: 0200 0000 4500 0034 0000 4000 4006 0000 ....E..4..@.@… 0x0010: 7f00 0001 7f00 0001 1b39 febb 7319 237e ………9..s.#~ 0x0020: 0f83 8263 8010 31cf fe28 0000 0101 080a …c..1..(…… 0x0030: 325d 7718 325d 7718 2]w.2]w. 6969 是端口号，根据实际的调试端口号修改。 0x00 拆分 SocketManager拆分 socket 相关的、业务相关的操作。 在 SocketManager 里只保留服务器读写数据、断开连接、心跳、重连、GCDAsyncSocket 回调设置。 // .h@interface GCDAsyncSocketManager : NSObject @property (nonatomic, assign, readonly) NSInteger connectStatus; // 连接状态：-1 未连接，0 连接中，1 已连接@property (nonatomic, assign, readonly) NSInteger reconnectionCount; // 建连失败重连次数 @end // .mstatic const NSInteger TIMEOUT = 30;static const NSInteger kBeatLimit = 3; @interface GCDAsyncSocketManager () @property (nonatomic, strong) GCDAsyncSocket * socket; @property (nonatomic, assign) NSInteger connectStatus; // 连接状态@property (nonatomic, assign) NSInteger reconnectionCount; // 建连失败重连次数@property (nonatomic, assign) NSInteger beatCount; // 发送心跳次数，用于重连@property (nonatomic, strong) NSTimer beatTimer; // 心跳定时器@property (nonatomic, strong) NSTimer reconnectTimer; // 重连定时器@property (nonatomic, copy) NSString * host; // Socket 连接的host地址@property (nonatomic, assign) uint16_t port; // Sokcet 连接的端口 @end/** * @brief 单例 */+ (nullable GCDAsyncSocketManager )sharedInstance{ static GCDAsyncSocketManager instance = nil; static dispatch_once_t once; dispatch_once(&amp;once, ^{ instance = [[self alloc] init]; }); return instance;} - (instancetype)init{ if (self = [super init]) { self.connectStatus = -1; } return self;} /** * @brief 连接 socket */- (void)connectSocketWithDelegate:(nonnull id)delegate{ if (self.connectStatus != -1) { NSLog(@”Socket Connect: YES”); return; } self.connectStatus = 0; // 创建 socket self.socket = \\[\\[GCDAsyncSocket alloc\\] initWithDelegate:delegate delegateQueue:dispatch\\_get\\_main_queue()\\]; NSError * error = nil; // 连接服务器 if (!\\[self.socket connectToHost:self.host onPort:self.port withTimeout:TIMEOUT error:&amp;error\\]) { self.connectStatus = -1; NSLog(@&quot;connect error: --- %@&quot;, error); } } /** * @brief socket 连接成功后发送心跳 */- (void)socketDidConnectBeginSendBeat:(nonnull NSString *)beatBody{ self.connectStatus = 1; self.reconnectionCount = 0; if (!self.beatTimer) { self.beatTimer = \\[NSTimer scheduledTimerWithTimeInterval:5.0 target:self selector:@selector(sendBeat:) userInfo:beatBody repeats:YES\\]; \\[\\[NSRunLoop mainRunLoop\\] addTimer:self.beatTimer forMode:NSRunLoopCommonModes\\]; } } /** * socket 连接失败后重连的操作 */- (void)socketDidDisconectBeginSendReconnect:(nonnull NSString *)reconnectBody{ self.connectStatus = -1; if (self.reconnectionCount &gt;= 0 &amp;&amp; self.reconnectionCount &lt;= kBeatLimit) { NSTimeInterval time = pow(2, self.reconnectionCount); if (!self.reconnectTimer) { self.reconnectTimer = \\[NSTimer scheduledTimerWithTimeInterval:time target:self selector:@selector(reconnection:) userInfo:reconnectBody repeats:NO\\]; \\[\\[NSRunLoop mainRunLoop\\] addTimer:self.reconnectTimer forMode:NSRunLoopCommonModes\\]; } self.reconnectionCount++; } else { \\[self.reconnectTimer invalidate\\]; self.reconnectTimer = nil; self.reconnectionCount = 0; } } /** * @brief 向服务器发送数据 */- (void)socketWriteData:(nonnull NSString )data{ NSData requestData = [data dataUsingEncoding:NSUTF8StringEncoding]; \\[self.socket writeData:requestData withTimeout:-1 tag:0\\]; \\[self socketBeginReadData\\]; } /** * @brief socket 读取数据 */- (void)socketBeginReadData{ [self.socket readDataToData:[GCDAsyncSocket CRLFData] withTimeout:10 maxLength:0 tag:0];} /** * socket 主动断开连接 */- (void)disconnectSocket{ self.reconnectionCount = -1; \\[self.socket disconnect\\]; \\[self.beatTimer invalidate\\]; self.beatTimer = nil; } /** * 重设心跳次数 */- (void)resetBeatCount{ self.beatCount = 0;} /** * 设置连接的 host 和 port */- (void)changeHost:(nullable NSString *)host port:(NSInteger)port{ self.host = host; self.port = port;} - (void)sendBeat:(NSTimer *)timer{ if (self.beatCount &gt;= kBeatLimit) { [self disconnectSocket]; return; } else { self.beatCount++; } if (timer != nil) { \\[self socketWriteData:timer.userInfo\\]; } } /** * @brief 重连 */- (void)reconnection:(NSTimer )timer{ NSError error = nil; if (!\\[self.socket connectToHost:self.host onPort:self.port withTimeout:TIMEOUT error:&amp;error\\]) { self.connectStatus = -1; } } 0x01 业务接口改为通用接口将不同的业务请求以枚举的方式列出来，方便外部调用的时候查看，并且最好在枚举后面加上注释，例如： /** * 业务类型 */typedef NS_ENUM(NSInteger, GACRequestType) { GACRequestType_Beat = 1, //心跳 GACRequestType_GetConversationsList, //获取会话列表 GACRequestType_ConnectionAuthAppraisal = 7, //连接鉴权}; 这样就可以将业务接口用一个通用的接口替换掉，根据不同的 type 处理不同的业务，body 请求体和 callback 回调。 /** * @brief 向服务器发送数据 * * @param type 请求类型 * @param body 请求体 */- (void)socketWriteDataWithRequestType:(GACRequestType)type requestBody:(nonnull NSDictionary *)body completion:(nullable SocketDidReadBlock)callback; 使用示例： NSDictionary * requestBody = @{ @”limit”: @(10), @”offset”: @(0) }; [[FIMCommunicationManager sharedInstance] socketWriteDataWithRequestType:FIMRequestType_GetConversationsList requestBody:requestBody completion:^(NSError * error, id data) { // do something }\\]; 0x02 使用 Blcok之前会对不同的业务请求，设定相应的 delegate 回调，但是数量一多，使用起来很槽糕，所以参考 AFNetworking 的做法，发起请求时将 block 与一个唯一标识进行绑定，同时将这个唯一标识放到请求里面发给服务器（服务器对该标识不做任何处理），等到 GCDAsyncSocket 回调回来时，通过服务器返回的这个标识，找到对应的 block 回调出去。 这样对业务方来说，socket 接口用起来其实和 HTTP 请求接口是一模一样的，将请求的上下文也关联了起来。 具体实现： /** * @brief 发起请求 */- (void)socketWriteDataWithRequestType:(GACRequestType)type requestBody:(nonnull NSDictionary *)body completion:(nullable SocketDidReadBlock)callback{ if (self.socketManager.connectStatus == -1) { NSLog(@”socket 未连通”); if (callback) { callback([GACErrorManager errorWithErrorCode:2003], nil); } return; } // 生成唯一标识 NSString * blockRequestID = \\[self createRequestID\\]; if (callback) { // 将 block 与标识绑定，存在一个全局变量里 \\[self.requestsMap setObject:callback forKey:blockRequestID\\]; } GACSocketModel * socketModel = \\[\\[GACSocketModel alloc\\] init\\]; socketModel.version = PROTOCOL_VERSION; socketModel.reqType = type; socketModel.reqId = blockRequestID; socketModel.requestChannel = self.currentCommunicationChannel; socketModel.body = body; \\[self.socketManager socketWriteData:\\[socketModel socketModelToJSONString\\]\\]; } /** * @brief 接收到数据回调 */- (void)socket:(GCDAsyncSocket )sock didReadData:(NSData )data withTag:(long)tag{ // 分界符号处理 NSString * jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; jsonString = [jsonString stringByReplacingOccurrencesOfString:@”\\r\\n” withString:@””]; NSData * jsonData = \\[jsonString dataUsingEncoding:NSUTF8StringEncoding\\]; NSError * jsonError; // 解析 json 数据 NSDictionary * json = \\[NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:&amp;jsonError\\]; NSLog(@&quot;socket - receive data %@&quot;, json); if (jsonError) { // 重新读取数据 \\[self.socketManager socketBeginReadData\\]; NSLog(@&quot;json 解析错误: --- error %@&quot;, jsonError); return; } NSInteger requestType = \\[json\\[@&quot;reqType&quot;\\] integerValue\\]; NSInteger errorCode = \\[json\\[@&quot;status&quot;\\] integerValue\\]; NSDictionary * body = @{}; NSString * requestID = json\\[@&quot;reqId&quot;\\]; NSString * requestChannel = nil; if (\\[\\[json allKeys\\] containsObject:@&quot;requestChannel&quot;\\]) { requestChannel = json\\[@&quot;requestChannel&quot;\\]; } // 获取唯一标识 SocketDidReadBlock didReadBlock = self.requestsMap\\[requestID\\]; if (errorCode != 0) { NSError *error = \\[GACErrorManager errorWithErrorCode:errorCode\\]; if (requestType == GACRequestType_ConnectionAuthAppraisal &amp;&amp; \\[self.socketDelegate respondsToSelector:@selector(connectionAuthAppraisalFailedWithErorr:)\\]) { \\[self.socketDelegate connectionAuthAppraisalFailedWithErorr:\\[GACErrorManager errorWithErrorCode:1005\\]\\]; } if (didReadBlock) { didReadBlock(error, body); } return; } switch (requestType) { case GACRequestType_ConnectionAuthAppraisal: { \\[self didConnectionAuthAppraisal\\]; NSDictionary * systemTimeDic = \\[body mutableCopy\\]; \\[self differenceOfLocalTimeAndServerTime:\\[systemTimeDic\\[@&quot;system_time&quot;\\] longLongValue\\]\\]; } break; case GACRequestType_Beat: { \\[self.socketManager resetBeatCount\\]; } break; case GACRequestType_GetConversationsList: { if (didReadBlock) { didReadBlock(nil, body); } } break; default: { if (\\[self.socketDelegate respondsToSelector:@selector(socketReadedData:forType:)\\]) { \\[self.socketDelegate socketReadedData:body forType:requestType\\]; } } break; } \\[self.socketManager socketBeginReadData\\]; } 0x03 使用模拟服务器时间，来解决缓存消息保序问题在 socket 模块里面，基于 FMDB 实现了一套缓存机制。但是聊天页面对数据库读写操作的场景非常复杂，而且对发送失败的消息也进行了缓存，如果使用 msgID 对消息进行保序，你要考虑发送成功和失败消息的排序，以及重发消息之后的排序等场景，这样实现起来比较困难。 所以我们采用消息的创建时间来进行保序。这样不管消息是怎么操作的，从数据库里面读出来的数据，我们只需要根据创建时间来排下序返回给业务层，如果业务层对数据进行修改的时候，我们更新消息的创建时间，这样下次取出来的顺序和 UI 展示的顺序也还是一样的。 这个创建时间是由服务器生成的，而且消息发送成功之后，服务器也不会返回给我们这条消息的创建时间，而且失败的消息服务器那边是不会存的，所以就需要我们本地模拟服务器来生成这个时间。 因为考虑到本地时间和服务器时间存在偏差，所以我们在 socket 建立连接成功之后，返回服务器时间给我们，拿到服务器时间之后和手机的本地时间做个比较，记录下这个偏差值，然后业务层在调用发送消息的接口时，socket 内部模拟出服务器创建时间赋值给该消息，然后存到数据库里面，这样就可以基本保证数据库存储消息的顺序和服务器的顺序是一致的。 0x04 监听网络状态来改变 socket 连接状态对 socket 连接状态也做了微调，通过测试微信的连接，发现以下两点： ①、网络断开后，socket 直接断开，显示“未连接”； ②、有网但是 socket 连接不上时，socket 会一直重连，重连 n 次不成功后，休眠几秒，再重连，如此循环。 用 AFNetWorking 库里面监测网络状态类 AFNetworkReachabilityManager：在无网时，判断如果 socket 正在连接或者已连接时，主动调用 disconnect 断开连接；如果有网，判断如果 socket 未连接，主动建立连接，建立连接不成功时，走重连的流程，只是我们依旧保持了重连 n 次后，n 次失败后不再重连了，这个是与微信不同的地方。 0x05 使用 FIMSocketModel因为请求的数据结构基本一样，所以定义了 FIMSocketModel 类来方便对数据的转化，定义几个必传的字段，以及可能请求不同所需的一些非必传字段，由于之前我们 body 体里面的内容是做了 2 次 JSON 转化处理的，所以业务层传入 body 内容时叫苦连天，FIMSocketModel 也增加了 - socketModelToJSONString 方法，方便 Socket 内部转化成 JSON 处理，这样业务层只需要传一个字典进来，Socket 内部就会处理好一切，使用起来就方便了。 - (NSString )socketModelToJSONString{ NSAssert(self.body != nil, @”Argument must be non-nil”); if (![self.body isKindOfClass:[NSDictionary class]]) { return nil; } // 实际指向的内容为字符串 self.body = [self dictionnaryObjectToString:self.body]; NSString jsonString = [self toJSONString]; jsonString = [jsonString stringByAppendingString:@”\\r\\n”]; return jsonString;} /** * NSDictionary -&gt; NSString */- (NSString )dictionnaryObjectToString:(NSDictionary )object{ NSError error = nil; NSData stringData = [NSJSONSerialization dataWithJSONObject:object options:NSJSONWritingPrettyPrinted error:&amp;error]; if (error) { return nil; } NSString * jsonString = \\[\\[NSString alloc\\] initWithData:stringData encoding:NSUTF8StringEncoding\\]; // 字典对象用系统 JSON 序列化之后得到的 data，经过转 UTF-8 后的 jsonString 里面会包含 &quot;\\\\n&quot; 及 &quot; &quot;，需要替换掉 jsonString = \\[jsonString stringByReplacingOccurrencesOfString:@&quot;\\\\n&quot; withString:@&quot;&quot;\\]; jsonString = \\[jsonString stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;\\]; return jsonString; } 数据传输层用 protobuf 更方便，比 json 好。","tags":[]},{"title":" TCP 的断包、粘包\t\t","date":"2019-03-26T06:59:09.000Z","path":"2019/03/26/tcp-e7-9a-84-e6-96-ad-e5-8c-85-e3-80-81-e7-b2-98-e5-8c-85/","text":"以太网中存在一个对于帧的有效数据大小的限制，即 MTU，以太网的 MTU 为 1500 字节。 断包 就是说发送端一次发送的消息长度过大，如果超过了 MTU，那么 ip 会对其进行分片。 在网络编程中，要避免出现 IP 分片。因为是 IP 层是没有超时重传机制的，如果 IP 层对一个数据包进行了分片，只要有一个分片丢失了，只能依赖于传输层进行重传，结果是所有的分片都要重传一遍，这个代价有点大。由此可见，IP 分片会大大降低传输层传送数据的成功率，所以要避免 IP 分片。 对于 UDP 包，我们需要在应用层去限制每个包的大小，一般不要超过 1472 字节，即以太网 MTU（1500）- UDP 首部（8）- IP 首部（20）。 对于 TCP 数据，应用层就不需要考虑这个问题了，因为传输层已经做了。在建立连接的三次握手的过程中，连接双方会相互通告MSS（Maximum Segment Size，最大报文段长度），一般 MSS = MTU - IP 首部（20）- TCP 首部（20），每次发送的 TCP 数据都不会超过双方 MSS 的最小值，所以就保证了 IP 数据报不会超过 MTU，避免了 IP 分片。 而断包就是因为 MSS 的存在，当消息长度过大，例如超过了 1460 字节（因为 tcp 首部一般为 20 个字节，ip 首部为 20 个字节），那么 tcp 就会将其分片，然后每片被 tcp 封装，然后由 ip 封装，最后被传输到接收端，这样子当接收端接收到消息后，就会不清楚这是不是一个完整的消息。 粘包 为了提高网络利用率，当传输层发现传输的数据长度太小时，会等待多个消息一起发送，这时候就会提高网络利用率，但是当接收端接收过以后，会不知道这是一个完整的消息，还是多个消息在一起。从而有可能将其作为一个消息来处理。nagle 算法就是实现的这个功能。 对于断包和粘包的通常处理方法为将消息封装为一定的格式，例如每个消息头部为 aa，尾部为 55，或者将整个消息的有效长度标明，这样子当接收端接收到消息之后，就可以以此来分辨消息是不是我完整的。","tags":[]},{"title":" iOS IM\t\t","date":"2019-03-26T01:12:34.000Z","path":"2019/03/26/iosim/","text":"原文：涂耀辉/iOS即时通讯，从入门到“放弃”？、github：iOS即时通讯，从入门到“放弃”？（demo） 本文会用实例的方式，将 iOS 各种 IM 的方案都简单的实现一遍。并且提供一些选型、实现细节以及优化的建议。 一、实现 IM 的方式1、使用第三方 IM 服务 对于短平快的公司，完全可以采用第三方 SDK 来实现。国内 IM 的第三方服务商有：云信、环信、融云、LeanCloud，当然还有其它的很多。 第三方服务商 IM 底层协议基本上都是 TCP。他们的 IM 方案很成熟，有了它们，我们甚至不需要自己去搭建 IM 后台，什么都不需要去考虑。 如果你足够懒，甚至连 UI 都不需要自己做，这些第三方有各自一套 IM 的 UI，拿来就可以直接用。 缺点： ①、定制化程度太高，很多东西我们不可控。 ②、太贵。作为真正以社交为主打的 APP，仅此一点，就足以让我们望而却步。当然，如果 IM 对于 APP 只是一个辅助功能，那么用第三方服务也无可厚非。 2、自己实现 实现时也有很多选择： ①、首先面临的就是传输协议的选择，TCP 还是 UDP？ ②、其次是需要去选择使用哪种聊天协议： 基于 Scoket 或者 WebScoket 或者其他的私有协议？ MQTT ？ 还是广为人诟病的 XMPP? ③、是自己去基于 OS 底层 Socket 进行封装还是在第三方框架的基础上进行封装？ ④、传输数据的格式，是用 Json、XML、还是谷歌推出的 ProtocolBuffer？ ⑤、还有一些细节问题需要考虑，例如 TCP 的长连接如何保持、心跳机制、Qos 机制、重连机制等。当然，除此之外，我们还有一些安全问题需要考虑。 二、传输协议的选择接下来我们可能需要自己考虑去实现 IM，首先从传输层协议来说，我们有两种选择：TCP or UDP？ 这个问题已经被讨论过无数次了，对深层次的细节感兴趣的朋友可以看看这篇文章： 移动端 IM/推送系统的协议选型：UDP 还是 TCP？ 结论： 对于小公司或者技术不那么成熟的公司，IM 一定要用 TCP 来实现，因为如果你要用 UDP 的话，需要做的事太多。 当然 QQ 就是用的 UDP 协议，当然不仅仅是 UDP，腾讯还用了自己的私有协议，来保证了传输的可靠性，杜绝了 UDP 下各种数据丢包、乱序等等一系列问题。 总之一句话，如果你觉得团队技术很成熟，那么你用 UDP 也行，否则还是用 TCP 为好。 三、聊天协议首先我们以实现方式来切入，基本上有以下四种实现方式： 当然，以上四种方式我们都可以不使用第三方框架，直接基于 OS 底层 Scoket 去实现我们的自定义封装。下面会给出一个基于 Scoket 原生而不使用框架的例子，供大家参考一下。 首先需要搞清楚的是，其中 MQTT 和 XMPP 为聊天协议，它们是最上层的协议，而 WebScoket 是传输通讯协议，它是基于 Socket 封装的一个协议。而通常我们所说的腾讯 IM 的私有协议，就是基于 WebScoket 或者 Scoket 原生进行封装的一个聊天协议。 具体这 3 种聊天协议的对比优劣如下： 所以说，iOS 要做一个真正的 IM 产品，一般都是基于 Scoket 或者 WebScoket 等，再之上加上一些私有协议来保证的。 四、直接用 OS 底层 Socket 来实现一个简单的 IM客户端的实现思路也是很简单，创建 Socket -&gt; 和服务器的 Socket 对接上 -> 开始传输数据。 Socket 是什么呢，简单的来说，就是我们使用 TCP/IP 或者 UDP/IP 协议的一组编程接口。如下图所示： 我们在应用层，使用 socket 轻易的实现了进程之间的通信（跨网络的）。想想，如果没有 socket，我们要直面 TCP/IP 协议，需要去写多少繁琐而又重复的代码。 如果有对 socket 概念仍然有所困惑的，可以看看这篇文章：从问题看本质，socket 到底是什么？。 但是这篇文章关于并发连接数的认识是错误的，正确的认识可以看看这篇文章：单台服务器并发 TCP 连接数到底可以有多少 我们接着可以开始着手去实现 IM 了，首先我们不基于任何框架，直接去调用 OS 底层-基于 C 的 BSD Socket 去实现，它提供了这样一组接口： /** * socket 创建并初始化 socket，返回该 socket 的文件描述符，如果描述符为 -1 表示创建失败。 /int socket(int addressFamily, int type,int protocol)/\\* * 关闭 socket 连接 /int close(int socketFileDescriptor)/\\* * 将 socket 与特定主机地址与端口号绑定，成功绑定返回 0，失败返回 -1。 /int bind(int socketFileDescriptor,sockaddr addressToBind,int addressStructLength) /** * 接受客户端连接请求并将客户端的网络地址信息保存到 clientAddress 中。 /int accept(int socketFileDescriptor,sockaddr clientAddress, int clientAddressStructLength)/** * 客户端向特定网络地址的服务器发送连接请求，连接成功返回 0，失败返回 -1。 /int connect(int socketFileDescriptor,sockaddr serverAddress, int serverAddressLength) /** * 使用 DNS 查找特定主机名字对应的 IP 地址。如果找不到对应的 IP 地址则返回 NULL。 /hostent gethostbyname(char *hostname) /** * 通过 socket 发送数据，发送成功返回成功发送的字节数，否则返回 -1。 /int send(int socketFileDescriptor, char buffer, int bufferLength, int flags) /** * 从 socket 中读取数据，读取成功返回成功读取的字节数，否则返回 -1。 /int receive(int socketFileDescriptor,char buffer, int bufferLength, int flags) /** * 通过 UDP socket 发送数据到特定的网络地址，发送成功返回成功发送的字节数，否则返回 -1。 /int sendto(int socketFileDescriptor,char \\buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength) /** * 从 UDP socket 中读取数据，并保存发送者的网络地址信息，读取成功返回成功读取的字节数，否则返回 -1 。 /int recvfrom(int socketFileDescriptor,char \\buffer, int bufferLength, int flags, sockaddr *fromAddress, int *fromAddressLength) 可以对 socket 进行各种操作，首先我们来用它写个客户端。总结一下，简单的 IM 客户端需要做如下 4 件事： 客户端调用 socket(…) 创建 socket； 客户端调用 connect(…) 向服务器发起连接请求以建立连接； 客户端与服务器建立连接之后，就可以通过 send(…)/receive(…) 向客户端发送或从客户端接收数据； 客户端调用 close 关闭 socket； 根据上面 4 条大纲，我们封装了一个单例类来对 socket 相关方法进行调用： #import &lt;Foundation/Foundation.h&gt; @interface SocketManager : NSObject+ (instancetype)sharedInstance;- (void)connect;- (void)disConnect;- (void)sendMsg:(NSString *)msg;@end #import “SocketManager.h” #import &lt;sys/types.h&gt; #import &lt;sys/socket.h&gt; #import &lt;netinet/in.h&gt; #import &lt;arpa/inet.h&gt; @interface SocketManager()@property (nonatomic, assign) int clientScoket;@end @implementation SocketManager /** * @brief 单例 */+ (instancetype)sharedInstance{ static dispatch_once_t onceToken; static SocketManager * instance = nil; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; [instance initScoket]; [instance pullMsg]; }); return instance;} /** * @brief 初始化 socket，并发起连接 */- (void)initScoket{ // 每次连接前先断开连接 if (_clientScoket != 0) { [self disConnect]; _clientScoket = 0; } _clientScoket = CreateClinetSocket(); // 服务器 IP const char * server_ip = &quot;127.0.0.1&quot;; // 服务器端口 short server_port = 6969; // 等于 0 说明连接失败 if (ConnectionToServer(\\_clientScoket, server\\_ip, server_port) == 0) { NSLog(&quot;Connect to server error&quot;); return; } // 连接成功 NSLog(&quot;Connect to server ok&quot;); } /** * @brief 创建一个 socket，返回值为 Int。（注：scoket 其实就是 Int 类型） */static int CreateClinetSocket(){ int ClinetSocket = 0; /* 参数 1 : IPv4(AF\\_INET) 或 IPv6(AF\\_INET6)。 参数 2 : type 表示 socket 的类型，通常是流 stream(SOCK\\_STREAM) 或数据报文 datagram(SOCK\\_DGRAM) 参数 3 : protocol 参数通常设置为 0，以便让系统自动为我们选择合适的协议。对于 stream socket 来说会是 TCP 协议(IPPROTO\\_TCP)，而对于 datagram 来说会是 UDP 协议(IPPROTO\\_UDP)。 */ ClinetSocket = socket(AF\\_INET, SOCK\\_STREAM, 0); return ClinetSocket; } /** * @breif 与服务器连接 /static int ConnectionToServer(int client_socket,const char server_ip,unsigned short port){ // 生成一个 sockaddr_in 类型结构体 struct sockaddr_in sAddr = {0}; sAddr.sin_len = sizeof(sAddr); // 设置 IPv4 sAddr.sin\\_family = AF\\_INET; /\\* inet_aton 是一个改进的方法来将一个字符串IP地址转换为一个32位的网络序列IP地址 如果这个函数成功，函数的返回值非零，如果输入地址不正确则会返回零。 */ inet\\_aton(server\\_ip, &amp;sAddr.sin_addr); // htons 是将整型变量从主机字节顺序转变成网络字节顺序，赋值端口号 sAddr.sin_port = htons(port); /\\* 用 scoket 和服务端地址，发起连接。 客户端向特定网络地址的服务器发送连接请求，连接成功返回0，失败返回 -1。 注意：该接口调用会阻塞当前线程，直到服务器返回。 */ if (connect(client_socket, (struct sockaddr *)&amp;sAddr, sizeof(sAddr))==0) { return client_socket; } return 0; } #pragma mark - Thread/** * 开启新线程来接收消息 */- (void)pullMsg{ [[[NSThread alloc] initWithTarget:self selector:@selector(recieveAction) object:nil] start];} #pragma mark - 对外逻辑 - (void)connect{ [self initScoket];}- (void)disConnect{ close(self.clientScoket);} - (void)sendMsg:(NSString )msg{ const char send_Message = [msg UTF8String]; send(self.clientScoket, send_Message, strlen(send_Message) + 1, 0);} - (void)recieveAction{ while (1) { char recv_Message[1024] = {0}; recv(self.clientScoket, recv_Message, sizeof(recv_Message), 0); NSLog(“%s”, recv_Message); }} 如上所示： 调用了 initScoket 方法，利用 CreateClinetSocket 方法创建了一个 scoket，就是调用了原生 socket 函数； 然后调用了 ConnectionToServer 函数与服务器连接，IP 地址为 127.0.0.1 也就是本机 localhost 和端口 6969 相连。在该函数中，我们绑定了一个 sockaddr_in 类型的结构体，该结构体内容如下： /* * Socket address, internet style. */struct sockaddr_in { __uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8];}; 里面包含了我们需要连接的服务端的 scoket 的一些基本参数，具体赋值细节可以见注释。 连接成功之后，就可以调用 send函数和 recv函数进行消息收发了，在这里，新开辟了一个常驻线程，一个死循环里去不停的调用 recv 函数，这样服务端有消息发送过来，第一时间便能接收到。 就这样客户端便简单的可以用了，接着我们来看看服务端的实现。 服务端需要做的工作简单的总结下： 服务器调用 socket(…) 创建 socket； 服务器调用 listen(…) 设置缓冲区； 服务器通过 accept(…) 接受客户端请求建立连接； 服务器与客户端建立连接之后，就可以通过 send(…)/receive(…) 向客户端发送或从客户端接收数据； 服务器调用 close 关闭 socket； OS 底层的函数是支持我们去实现服务端的，但是我们一般不会用iOS去这么做（试问真正的应用场景，有谁用iOS做scoket服务器么…），如果还是想用这些函数去实现服务端，可以参考下这篇文章： 深入浅出Cocoa-iOS网络编程之Socket。 在这里我用 node.js 去搭了一个简单的 scoket 服务器。源码如下： var net = require(‘net’);var HOST = ‘127.0.0.1’;var PORT = 6969; // 创建一个TCP服务器实例，调用listen函数开始监听指定端口// 传入net.createServer()的回调函数将作为”connection“事件的处理函数// 在每一个“connection”事件中，该回调函数接收到的socket对象是唯一的net.createServer(function(sock) { // 我们获得一个连接 \\- 该连接自动关联一个socket对象 console.log(&apos;CONNECTED: &apos; + sock.remoteAddress + &apos;:&apos; + sock.remotePort); sock.write(&apos;服务端发出：连接成功&apos;); // 为这个socket实例添加一个&quot;data&quot;事件处理函数 sock.on(&apos;data&apos;, function(data) { console.log(&apos;DATA &apos; + sock.remoteAddress + &apos;: &apos; + data); // 回发该数据，客户端将收到来自服务端的数据 sock.write(&apos;You said &quot;&apos; + data + &apos;&quot;&apos;); }); // 为这个socket实例添加一个&quot;close&quot;事件处理函数 sock.on(&apos;close&apos;, function(data) { console.log(&apos;CLOSED: &apos; + sock.remoteAddress + &apos; &apos; + sock.remotePort); }); }).listen(PORT, HOST); console.log(‘Server listening on ‘ + HOST +’:’+ PORT); 可以使用 c/c++/java/oc 语言等去实现后台，这里是为了验证之前写的客户端 scoket 的效果。如果本机有 node 的解释器，那么直接在终端进入该源代码文件目录中输入：node fileName ~ $ node /Users/cykj/Desktop/IM_iOS-master/Server.jsServer listening on 127.0.0.1:6969 即可运行该脚本（fileName 为保存源代码的文件名）。 如果没有 node 解释器，Mac 系统在终端执行 brew install node 可以下载。 运行效果： ~ $ node /Users/cykj/Desktop/IM_iOS-master/Server.jsServer listening on 127.0.0.1:6969CONNECTED: 127.0.0.1:61179DATA 127.0.0.1: haha1CONNECTED: 127.0.0.1:61183CLOSED: 127.0.0.1 61179DATA 127.0.0.1: haha2CLOSED: 127.0.0.1 61183CONNECTED: 127.0.0.1:61184DATA 127.0.0.1: haha3 从上面可以看到，客户端每次点击连接时，关闭了之前的 socket，重新建立了一个连接，服务端一直在监听 6969 端口。 You said “haha1 Connect to server ok服务端发出：连接成功You said “haha2 Connect to server ok服务端发出：连接成功You said “haha3 客户端打印显示连接成功，而运行的服务器也打印了连接成功。接着我们发了一条消息，服务端成功的接收到了消息后，把该消息再发送回客户端，绕了一圈客户端又收到了这条消息。至此我们用 OS 底层 scoket 实现了简单的 IM。 目前的实现很简单，仅仅是实现了 Scoket 的连接，信息的发送与接收，除此之外什么都没有做，现实中，需要做的处理远不止于此，我们先接着往下看。接下来，我们就一起看看第三方框架是如何实现 IM 的。 五、基于 Socket 原生的 CocoaAsyncSocket这个框架实现了 TCP 和 UDP 传输协议，分别对应 GCDAsyncSocket 和 GCDAsyncUdpSocket，重点讲 GCDAsyncSocket。 这里 Socket 服务器延续上一个例子，因为同样是基于原生 Scoket 的框架，所以之前的 Node.js 的服务端，该例仍然适用。这里只需要去封装客户端的实例。 #import &lt;Foundation/Foundation.h&gt; @interface SocketManager : NSObject+ (instancetype)sharedInstance;- (BOOL)connect;- (void)disConnect;- (void)sendMsg:(NSString *)msg;- (void)pullTheMsg;@end #import “SocketManager.h” #import “GCDAsyncSocket.h” // for TCP static NSString * Khost = @”127.0.0.1”;static const uint16_t Kport = 6969; @interface SocketManager() { GCDAsyncSocket * gcdSocket;}@end @implementation SocketManager/** * 单例 */+ (instancetype)sharedInstance{ static dispatch_once_t onceToken; static SocketManager * instance = nil; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc]init]; [instance initSocket]; }); return instance;} /** * 初始化 socket */- (void)initSocket{ gcdSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];} #pragma mark - 对外接口 - (BOOL)connect{ return [gcdSocket connectToHost:Khost onPort:Kport error:nil];} - (void)disConnect{ [gcdSocket disconnect];} - (void)sendMsg:(NSString *)msg { NSData * data = [msg dataUsingEncoding:NSUTF8StringEncoding]; // 第二个参数，请求超时时间 [gcdSocket writeData:data withTimeout:-1 tag:110];} /** * 监听最新的消息 */- (void)pullTheMsg{ // 监听读数据的代理 -1 永远监听，不超时，但是只收一次消息，所以每次接受到消息还得调用一次 [gcdSocket readDataWithTimeout:-1 tag:110]; } #pragma mark - GCDAsyncSocketDelegate/** * @brief 连接成功调用 */- (void)socket:(GCDAsyncSocket )sock didConnectToHost:(NSString )host port:(uint16_t)port{ NSLog(@”连接成功, host:%@, port:%d”, host, port); \\[self pullTheMsg\\]; // 心跳写在这... } /** * @brief 断开连接的时候调用 */- (void)socketDidDisconnect:(GCDAsyncSocket )sock withError:(nullable NSError )err{ NSLog(@”断开连接, host:%@, port:%d”, sock.localHost, sock.localPort); //断线重连写在这... } /** * @brief 写成功的回调 */- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag{// NSLog(@”写的回调, tag:%ld”, tag);} /** * @brief 收到消息的回调 */- (void)socket:(GCDAsyncSocket )sock didReadData:(NSData )data withTag:(long)tag{ NSString * msg = \\[\\[NSString alloc\\]initWithData:data encoding:NSUTF8StringEncoding\\]; NSLog(@&quot;收到消息：%@&quot;, msg); \\[self pullTheMsg\\]; } /** * @brief 分段去获取消息的回调 *///- (void)socket:(GCDAsyncSocket *)sock didReadPartialDataOfLength:(NSUInteger)partialLength tag:(long)tag//{//// NSLog(@”读的回调,length:%ld,tag:%ld”,partialLength,tag);////} /** * @brief 为上一次设置的读取数据代理续时 (如果设置超时为 -1，则永远不会调用到) ///-(NSTimeInterval)socket:(GCDAsyncSocket )sock shouldTimeoutReadWithTag:(long)tag elapsed:(NSTimeInterval)elapsed bytesDone:(NSUInteger)length//{// NSLog(@”来延时，tag:%ld,elapsed:%f,length:%ld”,tag,elapsed,length);// return 10;//} @end 这个框架使用起来也十分简单，它基于 Scoket 进行了一层封装，提供了 OC 的接口给我们使用。至于使用方法，大家看看注释应该就能明白，这里唯一需要说的就是这个方法： [gcdSocket readDataWithTimeout:-1 tag:110]; 这个方法的作用就是去读取当前消息队列中的未读消息。记住，这里不调用这个方法，消息回调的代理是永远不会被触发的。而且必须是 tag 相同，如果 tag 不同，这个收到消息的代理也不会被触发。 每调用一次这个方法，只能触发一次读取消息的代理，如果我们调用的时候没有未读消息，它就会等在那，直到消息来了被触发。一旦被触发一次代理后，我们必须再次调用这个方法，否则，之后的消息到了仍旧无法触发我们读取消息的代理。就像我们在例子中使用的那样，在每次读取到消息之后我们都去调用： /** * 收到消息的回调 */- (void)socket:(GCDAsyncSocket )sock didReadData:(NSData )data withTag:(long)tag{ NSString * msg = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;收到消息：%@&quot;,msg); \\[self pullTheMsg\\]; }/** * 监听最新的消息 */- (void)pullTheMsg{ // 监听读数据的代理，只能监听 10 秒，10 秒过后调用代理方法 -1 永远监听，不超时，但是只收一次消息，所以每次接受到消息还得调用一次 [gcdSocket readDataWithTimeout:-1 tag:110];} 超时 timeout 如果设置 10 秒，那么就只能监听 10 秒，10 秒过后调用是否续时的代理方法： -(NSTimeInterval)socket:(GCDAsyncSocket *)sockshouldTimeoutReadWithTag:(long)tag elapsed:(NSTimeInterval)elapsed bytesDone:(NSUInteger)length; 如果我们选择不续时，那么 10 秒到了还没收到消息，那么 Scoket 会自动断开连接。看到这里有些小伙伴要吐槽了，怎么一个方法设计的这么麻烦，当然这里这么设计是有它的应用场景的，后面再来细讲。 至此我们也用 CocoaAsyncSocket 这个框架实现了一个简单的 IM。 六、基于 webScoket 的 IM这个例子我们会把心跳、断线重连，以及 PingPong 机制进行简单的封装，所以我们先来谈谈这三个概念： 1、什么是心跳 简单的来说，心跳就是用来检测 TCP 连接的双方是否可用。那又会有人要问了，TCP 不是本身就自带一个 KeepAlive 机制吗？ 这里需要说明的是 TCP 的 KeepAlive 机制只能保证连接的存在，但是并不能保证客户端以及服务端的可用性。比如会有以下一种情况： 某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态。 这个时候心跳机制就起到作用了： 客户端发起心跳 Ping（一般都是客户端），假如设置在 10 秒后如果没有收到回调，那么说明服务器或者客户端某一方出现问题，这时候我们需要主动断开连接。 服务端也是一样，会维护一个 socket 的心跳间隔，当约定时间内，没有收到客户端发来的心跳，我们会知道该连接已经失效，然后主动断开连接。 参考文章：为什么说基于TCP的移动端IM仍然需要心跳保活？ 其实做过 IM 的小伙伴们都知道，我们真正需要心跳机制的原因其实主要是在于国内运营商 NAT 超时。 那么究竟什么是 NAT 超时呢？ 原来这是因为 IPV4 引起的。我们上网很可能会处在一个 NAT 设备（无线路由器之类）之后。NAT 设备会在 IP 封包通过设备时修改源/目的 IP 地址。对于家用路由器来说，使用的是网络地址端口转换（NAPT），它不仅改 IP，还修改 TCP 和 UDP 协议的端口号，这样就能让内网中的设备共用同一个外网 IP。举个例子，NAPT 维护一个类似下表的 NAT 表： NAT 设备会根据 NAT 表对出去和进来的数据做修改, 比如将 192.168.0.3:8888 发出去的封包改成 120.132.92.21:9202，外部就认为它们是在和 120.132.92.21:9202 通信。同时 NAT 设备会将 120.132.92.21:9202 收到的封包的 IP 和端口改成192.168.0.3:8888，再发给内网的主机，这样内部和外部就能双向通信了。但如果其中 192.168.0.3:8888 == 120.132.92.21:9202 这一映射因为某些原因被 NAT 设备淘汰了, 那么外部设备就无法直接与 192.168.0.3:8888 通信了。 我们的设备经常是处在 NAT 设备的后面，比如在大学里的校园网，查一下自己分配到的 IP，其实是内网 IP，表明我们在 NAT 设备后面，如果我们在寝室再接个路由器，那么我们发出的数据包会多经过一次 NAT。 国内移动无线网络运营商在链路上一段时间内没有数据通讯后，会淘汰 NAT 表中的对应项，造成链路中断。 而国内的运营商一般 NAT 超时的时间为 5 分钟，所以通常我们心跳设置的时间间隔为 3-5 分钟。 2、接着我们来讲讲 PingPong 机制 很多小伙伴可能又会感觉到疑惑了，那么我们在这心跳间隔的 3-5 分钟如果连接假在线（例如在地铁电梯这种环境下）。那么我们岂不是无法保证消息的即时性么？这显然是我们无法接受的，所以业内的解决方案是采用双向的 PingPong 机制。 当服务端发出一个 Ping，客户端没有在约定的时间内返回响应的 ack，则认为客户端已经不在线，这时我们 Server 端会主动断开 Scoket 连接，并且改由 APNS 推送的方式发送消息。 同样的，当客户端去发送一个消息，因为我们迟迟无法收到服务端的响应 ack 包，则表明客户端或者服务端已不在线，我们也会显示消息发送失败，并且断开 Scoket 连接。 还记得我们之前 CocoaSyncSocket 的例子讲的获取消息超时就断开吗？其实它就是一个 PingPong 机制的客户端实现。我们每次可以在发送消息成功后，调用这个超时读取的方法，如果一段时间没收到服务器的响应，那么说明连接不可用，则断开 Scoket 连接。 3、最后就是重连机制 理论上，用户主动去断开的 Scoket 连接（例如退出账号、APP 退出到后台等），不需要重连。其他的连接断开，我们都需要进行断线重连。 一般解决方案是尝试重连几次，如果仍旧无法重连成功，那么不再进行重连。 接下来的 WebScoket 的例子，我会封装一个重连时间指数级增长的一个重连方式，可以作为一个参考。 看完上面三个概念之后，来讲一个 WebScoket 最具代表性的一个第三方框架 SocketRocket。 首先来看看它对外封装的一些方法： @interface SRWebSocket : NSObject @property (nonatomic, weak) id delegate; @property (nonatomic, readonly) SRReadyState readyState;@property (nonatomic, readonly, retain) NSURL *url; @property (nonatomic, readonly) CFHTTPMessageRef receivedHTTPHeaders; // Optional array of cookies (NSHTTPCookie objects) to apply to the connections@property (nonatomic, readwrite) NSArray * requestCookies; // This returns the negotiated protocol.// It will be nil until after the handshake completes.@property (nonatomic, readonly, copy) NSString *protocol; // Protocols should be an array of strings that turn into Sec-WebSocket-Protocol.- (id)initWithURLRequest:(NSURLRequest )request protocols:(NSArray )protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates;- (id)initWithURLRequest:(NSURLRequest )request protocols:(NSArray )protocols;- (id)initWithURLRequest:(NSURLRequest *)request; // Some helper constructors.- (id)initWithURL:(NSURL )url protocols:(NSArray )protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates;- (id)initWithURL:(NSURL )url protocols:(NSArray )protocols;- (id)initWithURL:(NSURL *)url; // Delegate queue will be dispatch_main_queue by default.// You cannot set both OperationQueue and dispatch_queue.- (void)setDelegateOperationQueue:(NSOperationQueue*) queue;- (void)setDelegateDispatchQueue:(dispatch_queue_t) queue; // By default, it will schedule itself on +[NSRunLoop SR_networkRunLoop] using defaultModes.- (void)scheduleInRunLoop:(NSRunLoop )aRunLoop forMode:(NSString )mode;- (void)unscheduleFromRunLoop:(NSRunLoop )aRunLoop forMode:(NSString )mode; // SRWebSockets are intended for one-time-use only. Open should be called once and only once.- (void)open; - (void)close;- (void)closeWithCode:(NSInteger)code reason:(NSString *)reason; // Send a UTF8 String or Data.- (void)send:(id)data; // Send Data (can be nil) in a ping message.- (void)sendPing:(NSData *)data; @end #pragma mark - SRWebSocketDelegate @protocol SRWebSocketDelegate // message will either be an NSString if the server is using text// or NSData if the server is using binary.- (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message; @optional - (void)webSocketDidOpen:(SRWebSocket )webSocket;- (void)webSocket:(SRWebSocket )webSocket didFailWithError:(NSError )error;- (void)webSocket:(SRWebSocket )webSocket didCloseWithCode:(NSInteger)code reason:(NSString )reason wasClean:(BOOL)wasClean;- (void)webSocket:(SRWebSocket )webSocket didReceivePong:(NSData *)pongPayload; // Return YES to convert messages sent as Text to an NSString. Return NO to skip NSData -&gt; NSString conversion for Text messages. Defaults to YES.- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket; @end 方法也很简单，分为两个部分： 一部分是 SRWebSocket 的初始化、连接、关闭连接、发送消息等方法。 另一部分是 SRWebSocketDelegate，其中包括一些回调：收到消息、连接失败、关闭连接、收到 pong 、是否需要把 data 消息转换成 string 的代理方法。 接着我们还是举个例子来实现以下： #import &lt;Foundation/Foundation.h&gt; typedef enum : NSUInteger { disConnectByUser , disConnectByServer,} DisConnectType; @interface SocketManager : NSObject+ (instancetype)sharedInstance;- (void)connect;- (void)disConnect;- (void)sendMsg:(NSString *)msg;- (void)ping;@end #import “SocketManager.h” #import “SocketRocket.h” #define dispatch_main_async_safe(block)\\ if ([NSThread isMainThread]) {\\ block();\\ } else {\\ dispatch_async(dispatch_get_main_queue(), block);\\ } static NSString * Khost = @”127.0.0.1”;static const uint16_t Kport = 6969; @interface SocketManager() { SRWebSocket webSocket; NSTimer heartBeat; NSTimeInterval reConnectTime;} @end @implementation TYHSocketManager + (instancetype)sharedInstance{ static dispatch_once_t onceToken; static SocketManager * instance = nil; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc]init]; [instance initSocket]; }); return instance;} /** * @brief 初始化连接 */- (void)initSocket{ if (webSocket) { return; } // 注意：url 的格式 webSocket = \\[\\[SRWebSocket alloc\\] initWithURL:\\[NSURL URLWithString:\\[NSString stringWithFormat:@&quot;ws://%@:%d&quot;, Khost, Kport\\]\\]\\]; webSocket.delegate = self; // 设置代理线程 queue NSOperationQueue * queue = \\[\\[NSOperationQueue alloc\\]init\\]; queue.maxConcurrentOperationCount = 1; \\[webSocket setDelegateOperationQueue:queue\\]; // 连接 \\[webSocket open\\]; } /** * @brief 初始化心跳 */- (void)initHeartBeat{ dispatch_main_async_safe(^{ \\[self destoryHeartBeat\\]; __weak typeof(self) weakSelf = self; // 心跳设置为 3 分钟，NAT 超时一般为 5 分钟 heartBeat = \\[NSTimer scheduledTimerWithTimeInterval:3\\*60 repeats:YES block:^(NSTimer \\* _Nonnull timer) { NSLog(@&quot;heart&quot;); // 和服务端约定好发送什么作为心跳标识，尽可能的减小心跳包的大小 \\[weakSelf sendMsg:@&quot;heart&quot;\\]; }\\]; \\[\\[NSRunLoop currentRunLoop\\]addTimer:heartBeat forMode:NSRunLoopCommonModes\\]; }) } /** * @brief 取消心跳 */- (void)destoryHeartBeat{ dispatch_main_async_safe(^{ if (heartBeat) { [heartBeat invalidate]; heartBeat = nil; } })} #pragma mark - 对外的一些接口/** * @brief 建立连接 */- (void)connect{ [self initSocket]; // 每次正常连接的时候清零重连时间 reConnectTime = 0; } /** * @brief 断开连接 */- (void)disConnect{ if (webSocket) { [webSocket close]; webSocket = nil; }} /** * @brief 发送消息 */- (void)sendMsg:(NSString *)msg{ [webSocket send:msg];} /** * @brief 重连机制 */- (void)reConnect{ [self disConnect]; // 超过一分钟就不再重连 所以只会重连 5 次，2^5 = 64 if (reConnectTime &gt; 64) { return; } dispatch\\_after( dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(reConnectTime * NSEC\\_PER_SEC)), dispatch\\_get\\_main_queue(), ^{ webSocket = nil; \\[self initSocket\\]; }); // 重连时间 2 的指数级增长 if (reConnectTime == 0) { reConnectTime = 2; } else { reConnectTime *= 2; } } /** * @brief pingPong */- (void)ping{ [webSocket sendPing:nil];} #pragma mark - SRWebSocketDelegate - (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message{ NSLog(@”服务器返回收到消息:%@”, message);} - (void)webSocketDidOpen:(SRWebSocket *)webSocket{ NSLog(@”连接成功”); // 连接成功了开始发送心跳 \\[self initHeartBeat\\]; } /** * @brief open 失败的时候调用 */- (void)webSocket:(SRWebSocket )webSocket didFailWithError:(NSError )error{ NSLog(@”连接失败…..\\n%@”,error); // 失败了就去重连 \\[self reConnect\\]; } /** * @brief 网络连接中断被调用 */- (void)webSocket:(SRWebSocket )webSocket didCloseWithCode:(NSInteger)code reason:(NSString )reason wasClean:(BOOL)wasClean{ NSLog(@”被关闭连接，code:%ld,reason:%@,wasClean:%d”,code,reason,wasClean); // 如果是被用户自己中断的那么直接断开连接，否则开始重连 if (code == disConnectByUser) { \\[self disConnect\\]; } else{ \\[self reConnect\\]; } // 断开连接时销毁心跳 \\[self destoryHeartBeat\\]; } /** * @brief sendPing 的时候，如果网络通的话，则会收到回调，但是必须保证 ScoketOpen，否则会 crash */- (void)webSocket:(SRWebSocket )webSocket didReceivePong:(NSData )pongPayload{ NSLog(@”收到 pong 回调”);} /** * @brief 将收到的消息，是否需要把 data 转换为 NSString，每次收到消息都会被调用，默认 YES *///- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket//{// NSLog(@”webSocketShouldConvertTextFrameToString”);//// return NO;//} .m 文件有点长，可以参照 github 中的 demo 进行阅读，这回添加了一些细节的东西，包括一个简单的心跳、重连机制，还有 webScoket 封装好的一个 pingpong 机制。 代码非常简单，配合着注释读一读，应该很容易理解。 需要说一下的是这个心跳机制是一个定时的间隔，往往可能会有更复杂实现，比如我们正在发送消息的时候，可能就不需要心跳。当不在发送的时候再开启心跳之类的。微信有一种更高端的实现方式，有兴趣的小伙伴可以看看：微信的智能心跳实现方式 还有一点需要说的就是这个重连机制，demo 中采用的是 2 的指数级别增长，第一次立刻重连，第二次 2 秒，第三次 4 秒，第四次 8 秒…直到大于 64 秒就不再重连。而任意的一次成功的连接，都会重置这个重连时间。 最后一点需要说的是，这个框架给我们封装的 webscoket 在调用它的 sendPing 方法之前，一定要判断当前 scoket 是否连接，如果不是连接状态，程序则会 crash。 客户端的实现就大致如此，接着同样我们需要实现一个服务端，来看看实际通讯效果。 七、webScoket 服务端实现在这里无法沿用之前的 node.js 例子了，因为这并不是一个原生的 scoket，服务端同样需要遵守 webScoket 协议，两者才能实现通信。 其实这里实现也很简单，采用 node.js 的 ws 模块，只需要用 npm 去安装 ws 即可。 什么是 npm 呢？ 举个例子，npm 之于 Node.js 相当于 cocoaPods 之于 iOS，它就是一个拓展模块的一个管理工具。这篇文章：npm 的使用 我们进入当前脚本目录，输入终端命令，即可安装 ws 模块： $ npm install ws 如果懒得去看 npm，直接下载 github 中的 WSServer.js 文件运行即可。 该源文件代码如下： var WebSocketServer = require(‘ws’).Server, wss = new WebSocketServer({ port: 6969 });wss.on(‘connection’, function (ws) { console.log(‘client connected’); ws.send(&apos;你是第&apos; + wss.clients.length + &apos;位&apos;); //收到消息回调 ws.on(&apos;message&apos;, function (message) { console.log(message); ws.send(&apos;收到:&apos;+message); }); // 退出聊天 ws.on(&apos;close&apos;, function(close) { console.log(&apos;退出连接了&apos;); }); });console.log(‘开始监听6969端口’); 代码逻辑就是监听了本机 6969 端口，在客户端连接时打印 lient connected，并且向客户端发送：你是第几位。如果收到客户端消息后，打印消息，并且向客户端发送这条收到的消息。 八、MQTTMQTT 是一个聊天协议，它比 webScoket 更上层，属于应用层。 它的基本模式是简单的发布订阅，也就是说当一条消息发出去的时候，谁订阅了谁就会收到。其实它并不适合 IM 的场景，例如用来实现有些简单 IM 场景，却需要很大量的、复杂的处理。 比较适合它的场景为订阅发布这种模式的，例如微信的实时共享位置、滴滴的地图上小车的移动、客户端推送等功能。 首先我们来看看基于 MQTT 协议的框架 MQTTKit。 这个框架是 c 来写的，把一些方法公开在 MQTTKit 类中，对外用 OC 来调用，我们来看看这个类： @interface MQTTClient : NSObject { struct mosquitto *mosq;} @property (readwrite, copy) NSString clientID;@property (readwrite, copy) NSString host;@property (readwrite, assign) unsigned short port;@property (readwrite, copy) NSString username;@property (readwrite, copy) NSString password;@property (readwrite, assign) unsigned short keepAlive;@property (readwrite, assign) BOOL cleanSession;@property (nonatomic, copy) MQTTMessageHandler messageHandler; + (void) initialize;+ (NSString*) version; - (MQTTClient) initWithClientId: (NSString )clientId;- (void) setMessageRetry: (NSUInteger)seconds; #pragma mark - Connection - (void) connectWithCompletionHandler:(void (^)(MQTTConnectionReturnCode code))completionHandler;- (void) connectToHost: (NSString)host completionHandler:(void (^)(MQTTConnectionReturnCode code))completionHandler;- (void) disconnectWithCompletionHandler:(void (^)(NSUInteger code))completionHandler;- (void) reconnect;- (void)setWillData:(NSData )payload toTopic:(NSString )willTopic withQos:(MQTTQualityOfService)willQos retain:(BOOL)retain;- (void)setWill:(NSString )payload toTopic:(NSString *)willTopic withQos:(MQTTQualityOfService)willQos retain:(BOOL)retain;- (void)clearWill; #pragma mark - Publish - (void)publishData:(NSData )payload toTopic:(NSString )topic withQos:(MQTTQualityOfService)qos retain:(BOOL)retain completionHandler:(void (^)(int mid))completionHandler;- (void)publishString:(NSString )payload toTopic:(NSString )topic withQos:(MQTTQualityOfService)qos retain:(BOOL)retain completionHandler:(void (^)(int mid))completionHandler; #pragma mark - Subscribe - (void)subscribe:(NSString )topicwithCompletionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;- (void)subscribe:(NSString )topic withQos:(MQTTQualityOfService)qoscompletionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;- (void)unsubscribe: (NSString *)topicwithCompletionHandler:(void (^)(void))completionHandler; 这个类一共分为 4 个部分：初始化、连接、发布、订阅，具体方法的作用可以先看看方法名理解下，接下来用这个框架封装一个实例。 #import &lt;Foundation/Foundation.h&gt; @interface MQTTManager : NSObject + (instancetype)sharedInstance; - (void)connect;- (void)disConnect; - (void)sendMsg:(NSString *)msg; @end #import “MQTTManager.h” #import “MQTTKit.h” static NSString Khost = @”127.0.0.1”;static const uint16_t Kport = 6969;static NSString KClientID = @”tuyaohui”; @interface MQTTManager(){ MQTTClient * client;} @end @implementation MQTTManager + (instancetype)sharedInstance{ static dispatch_once_t onceToken; static MQTTManager *instance = nil; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc]init]; }); return instance;} /** * @brief 初始化连接 */- (void)initSocket{ if (client) { [self disConnect]; } client = \\[\\[MQTTClient alloc\\] initWithClientId:KClientID\\]; client.port = Kport; \\[client setMessageHandler:^(MQTTMessage *message) { // 收到消息的回调，前提是得先订阅 NSString * msg = \\[\\[NSString alloc\\] initWithData:message.payload encoding:NSUTF8StringEncoding\\]; NSLog(@&quot;收到服务端消息：%@&quot;,msg); }\\]; \\[client connectToHost:Khost completionHandler:^(MQTTConnectionReturnCode code) { switch (code) { case ConnectionAccepted: NSLog(@&quot;MQTT连接成功&quot;); // 订阅自己 ID 的消息，这样收到消息就能回调 \\[client subscribe:client.clientID withCompletionHandler:^(NSArray *grantedQos) { NSLog(@&quot;订阅 tuyaohui 成功&quot;); }\\]; break; case ConnectionRefusedBadUserNameOrPassword: NSLog(@&quot;错误的用户名密码&quot;); //.... default: NSLog(@&quot;MQTT连接失败&quot;); break; } }\\]; } #pragma mark - 对外的一些接口/** * @brief 建立连接 */- (void)connect{ [self initSocket];} /** * @brief 断开连接 */- (void)disConnect{ if (client) { // 取消订阅 [client unsubscribe:client.clientID withCompletionHandler:^{ NSLog(@”取消订阅 tuyaohui 成功”); }\\]; // 断开连接 \\[client disconnectWithCompletionHandler:^(NSUInteger code) { NSLog(@&quot;断开MQTT成功&quot;); }\\]; client = nil; } } /** * @brief 发送消息 */- (void)sendMsg:(NSString *)msg{ // 发送一条消息，发送给自己订阅的主题 [client publishString:msg toTopic:KClientID withQos:ExactlyOnce retain:YES completionHandler:^(int mid) { }\\]; }@end 实现代码很简单，需要说一下的是： ①、当我们连接成功了，需要去订阅自己 clientID 的消息，这样才能收到发给自己的消息。②、这个框架为我们实现了一个 QOS 机制。 那什么是 QOS 呢？ QoS（Quality of Service 服务质量）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。 在这里，它提供了三个选项： typedef enum MQTTQualityOfService : NSUInteger { AtMostOnce, // 最多发送一次：如果消息没有发送过去，那么就直接丢失 AtLeastOnce, // 至少发送一次：保证消息一定发送过去，但是发几次不确定 ExactlyOnce // 精确只发送一次：它内部会有一个很复杂的发送机制，确保消息送到，而且只发送一次} MQTTQualityOfService; 更详细的关于该机制可以看看这篇文章：MQTT协议笔记之消息流QOS。 同样的我们需要一个用 MQTT 协议实现的服务端，我们还是 node.js 来实现，这次我们还是需要用 npm 来新增一个模块 mosca。 服务端代码： var mosca = require(‘mosca’); var MqttServer = new mosca.Server({ port: 6969}); MqttServer.on(‘clientConnected’, function(client){ console.log(‘收到客户端连接，连接ID：’, client.id);}); /** * 监听MQTT主题消息 **/MqttServer.on(‘published’, function(packet, client) { var topic = packet.topic; console.log(‘有消息来了’,’topic为：’+topic+’,message为：’+ packet.payload.toString()); }); MqttServer.on(‘ready’, function(){ console.log(‘mqtt服务器开启，监听6969端口’);}); 服务端代码没几行，开启了一个服务，并且监听本机 6969 端口，同时监听了客户端连接、发布消息等状态。 至此，实现了一个简单的 MQTT 封装。 九、XMPP：XMPPFramework 框架个人感觉 XMPP 对于 IM 来说实在是不堪重用，仅仅只能作为一个玩具 demo，给大家练练手。 网上有太多 XMPP 的内容了，相当一部分用 openfire 来做服务端，这一套东西实在是太老了。如果仍然感兴趣的可以看这篇文章：iOS 的 XMPPFramework 简介。 十、IM 传输格式引用陈宜龙大神文章（iOS程序犭袁 ）中一段：使用 ProtocolBuffer 减少 Payload。 滴滴打车 40%； 携程之前分享过，说是采用新的 Protocol Buffer 数据格式 + Gzip压缩后的 Payload 大小降低了 15%-45%。数据序列化耗时下降了 80%-90%。 采用高效安全的私有协议，支持长连接的复用，稳定省电省流量。 【高效】 提高网络请求成功率，消息体越大，失败几率随之增加。 【省流量】 流量消耗极少，省流量。一条消息数据用 Protobuf 序列化后的大小是 JSON 的 1/10、XML 格式的 1/20、是二进制序列化的 1/10。同 XML 相比， Protobuf 性能优势明显。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。 【省电】 【高效心跳包】 同时心跳包协议对 IM 的电量和流量影响很大，对心跳包协议上进行了极简设计：仅 1 Byte。 【易于使用】 开发人员通过按照一定的语法定义结构化的消息格式，然后发送给命令行工具，工具将自动生成相关的类，可以支持java、c++、python、Objective-C 等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。语言支持：原生支持 c++、java、python、Objective-C 等多达 10 余种语言。 2015-08-27 Protocol Buffers v3.0.0-beta-1 中发布了 Objective-C(Alpha) 版本，2016-07-28 3.0 Protocol Buffers v3.0.0 正式版发布，正式支持 Objective-C。 【可靠】 微信和手机 QQ 这样的主流 IM 应用也早已在使用它（采用的是改造过的 Protobuf 协议） github 验证 Protobuf 的高性能：对数据分别操作 100、1000、10000 和 100000 次进行了测试。 纵坐标是完成时间，单位是毫秒。下图依次：1、反序列化 2、序列化 3、字节长度。数据来源。 数据来自：项目 thrift-protobuf-compare，测试项为 Total Time，也就是 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好。 缺点： 可能会造成 APP 的包体积增大，通过 Google 提供的脚本生成的 Model，会非常“庞大”，Model 多了，包体积也就会跟着变大。 Model 过多，可能导致 APP 打包后的体积骤增，但 IM 服务所使用的 Model 非常少，比如在 ChatKit-OC 中只用到了一个 Protobuf 的 Model:Message 对象，对包体积的影响微乎其微。 在使用过程中要合理地权衡包体积以及传输效率的问题，据说去哪儿网，就曾经为了减少包体积，减少了 Protobuf 的使用。 综上所述，我们选择传输格式的时候：ProtocolBuffer &gt; Json &gt; XML 如果大家对 ProtocolBuffer 用法感兴趣可以参考下这两篇文章：ProtocolBuffer for Objective-C 运行环境配置及使用 、iOS之ProtocolBuffer搭建和示例demo 十一、IM 的其它问题1、IM 的可靠性 之前穿插在例子中提到过：心跳机制、PingPong 机制、断线重连机制、还有后面所说的 QOS 机制。这些被用来保证连接的可用，消息的即时与准确的送达等。 上述内容保证了 IM 服务时的可靠性，其实我们能做的还有很多：比如在大文件传输的时候使用分片上传、断点续传、秒传技术等来保证文件的传输。 2、安全性 通常还需要一些安全机制来保证 IM 通信安全。例如：防止 DNS 污染、帐号安全、第三方服务器鉴权、单点登录等。 3、一些其他的优化 类似微信，服务器不做聊天记录的存储，只在本机进行缓存，这样可以减少对服务端数据的请求，一方面减轻了服务器的压力，另一方面减少客户端流量的消耗。 进行 http 连接的时候尽量采用上层 API，类似 NSUrlSession。而网络框架尽量使用 AFNetWorking3。因为这些上层网络请求都用的是 HTTP/2 ，我们请求的时候可以复用这些连接。 更多优化相关内容可以参考参考这篇文章：IM 即时通讯技术在多应用场景下的技术实现，以及性能调优 十二、音视频通话IM 应用中的实时音视频技术，几乎是 IM 开发中的最后一道高墙。原因在于：实时音视频技术 = 音视频处理技术 + 网络传输技术的横向技术应用集合体，而公共互联网不是为了实时通信设计的。 实时音视频技术上的实现内容主要包括：音视频的采集、编码、网络传输、解码、播放等环节。这么多项并不是简单的技术应用，如果把握不当，将会在在实际开发过程中遇到一个又一个的坑。 相关系列的文章：《即时通讯音视频开发（一）：视频编解码之理论概述》《即时通讯音视频开发（二）：视频编解码之数字视频介绍》《即时通讯音视频开发（三）：视频编解码之编码基础》《即时通讯音视频开发（四）：视频编解码之预测技术介绍》《即时通讯音视频开发（五）：认识主流视频编码技术H.264》《即时通讯音视频开发（六）：如何开始音频编解码技术的学习》《即时通讯音视频开发（七）：音频基础及编码原理入门》《即时通讯音视频开发（八）：常见的实时语音通讯编码标准》《即时通讯音视频开发（九）：实时语音通讯的回音及回音消除�概述》《即时通讯音视频开发（十）：实时语音通讯的回音消除�技术详解》《即时通讯音视频开发（十一）：实时语音通讯丢包补偿技术详解》《即时通讯音视频开发（十二）：多人实时音视频聊天架构探讨》《即时通讯音视频开发（十三）：实时视频编码H.264的特点与优势》《即时通讯音视频开发（十四）：实时音视频数据传输协议介绍》《即时通讯音视频开发（十五）：聊聊P2P与实时音视频的应用情况》《即时通讯音视频开发（十六）：移动端实时音视频开发的几个建议》《即时通讯音视频开发（十七）：视频编码H.264、V8的前世今生》","tags":[]},{"title":" php 开启 socket 服务\t\t","date":"2019-03-25T07:55:18.000Z","path":"2019/03/25/php-e5-bc-80-e5-90-af-socket-e6-9c-8d-e5-8a-a1/","text":"mac 环境下搭建socket通信","tags":[]},{"title":" python 开启 socket 服务器\t\t","date":"2019-03-25T06:34:39.000Z","path":"2019/03/25/socket-e6-9c-8d-e5-8a-a1-e5-99-a8-e7-9a-84-e6-90-ad-e5-bb-ba/","text":"socket 服务器可通过 Python 来搭建。 1、安装 zope.interface ope.interface 官网、github 方式一： ~ $ pip install zope.interfaceDEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7.Requirement already satisfied: zope.interface in /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python (4.1.1)Requirement already satisfied: setuptools in /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python (from zope.interface) (18.5) 这种方式下载的 zope.interface 没有作为 python 的组件。 方式二： 去 github 下载压缩包，下载好后点击打开，会看到文件夹下有个“setup.py”文件，右击-&gt;打开方式-&gt;BuildApplet，然后再在命令行下输入“python setup.py install”。这样就安装了 zope.interface。 如果报错 [Errno 13] Permission denied: ‘/Library/Python/2.7/s，是权限问题，在命令前加上 sudo，相当于管理员操作了。 zope.interface-master $ sudo python setup.py installPassword:/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: ‘python_requires’ warnings.warn(msg)running installChecking .pth file support in /Library/Python/2.7/site-packages//usr/bin/python -E -c passTEST PASSED: /Library/Python/2.7/site-packages/ appears to support .pth filesrunning bdist_egg Using /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/pythonFinished processing dependencies for zope.interface==4.6.1.dev0 2、安装 twisted twisted 官网 方式一： ~ $ pip install TwistedDEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7.Collecting Twisted Downloading https://files.pythonhosted.org/packages/5d/0e/a72d85a55761c2c3ff1cb968143a2fd5f360220779ed90e0fadf4106d4f2/Twisted-18.9.0.tar.bz2 (3.1MB) 100% |████████████████████████████████| 3.1MB 6.1MB/sCollecting zope.interface&gt;=4.4.2 (from Twisted) Downloading https://files.pythonhosted.org/packages/28/39/0b5a168621fadd822810e8f3e2b9502b279aca07d6911ad06495ac9dff97/zope.interface-4.6.0-cp27-cp27m-macosx\\_10\\_6_intel.whl (140kB) 100% |████████████████████████████████| 143kB 506kB/sCollecting constantly&gt;=15.1 (from Twisted) Downloading https://files.pythonhosted.org/packages/b9/65/48c1909d0c0aeae6c10213340ce682db01b48ea900a7d9fce7a7910ff318/constantly-15.1.0-py2.py3-none-any.whlCollecting incremental&gt;=16.10.1 (from Twisted) 如果报错可试试用 pip3 命令。 ~ $ pip3 install TwistedCollecting Twisted Using cached https://files.pythonhosted.org/packages/5d/0e/a72d85a55761c2c3ff1cb968143a2fd5f360220779ed90e0fadf4106d4f2/Twisted-18.9.0.tar.bz2Collecting zope.interface&gt;=4.4.2 (from Twisted) Downloading https://files.pythonhosted.org/packages/14/22/ca298e4c576981830be5e706049e9a3c091edf9dc489a00e3c1ec8c501d3/zope.interface-4.6.0-cp37-cp37m-macosx\\_10\\_6_intel.whl (140kB) 100% |████████████████████████████████| 143kB 249kB/sCollecting constantly&gt;=15.1 (from Twisted) 这种方式下载的 Twisted没有作为 python 的组件。 方式二： 与 zone.interface 的方式二相同。如果你的 MAC OS 版本高于 10.5，就下载 tarball 的那个版本。安装完成之后再用 “import twisted” 测试一下即可。 Twisted-18.9.0 $ sudo python setup.py installno previously-included directories found matching ‘.travis’no previously-included directories found matching ‘tests’warning: no previously-included files found matching ‘examplesetup.py’no previously-included directories found matching ‘src/exampleproj’no previously-included directories found matching ‘src/incremental/newsfragments’ Installed /Users/cykj/Desktop/Twisted-18.9.0/.eggs/incremental-17.5.0-py2.7.eggrunning installChecking .pth file support in /Library/Python/2.7/site-packages//usr/bin/python -E -c passTEST PASSED: /Library/Python/2.7/site-packages/ appears to support .pth filesrunning bdist_egg Installing easy_install script to /usr/local/binInstalling easy_install-2.7 script to /usr/local/bin Using /System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/pythonFinished processing dependencies for Twisted==18.9.0 检查下 MAC 有没有 twisted。 检查方法：打开 python 命令行，输入“import twisted”，如果没有任何提示，说明已经有 twisted 了，若提示没有模块，则需要安装 twisted。 $ pythonPython 2.7.10 (default, Oct 6 2017, 22:29:07)[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.31)] on darwinType “help”, “copyright”, “credits” or “license” for more information. > import TwistedTraceback (most recent call last): File ““, line 1, in ImportError: No module named Twisted> import twisted> 之后就可以用命令开启服务了。 3、开启 socket 服务 chatserver.py 下载地址。这里设置的端口号为 12345。 from twisted.internet.protocol import Protocol, Factoryfrom twisted.internet import reactor class IphoneChat(Protocol): def connectionMade(self): #self.transport.write(&quot;&quot;&quot;connected&quot;&quot;&quot;) self.factory.clients.append(self) print &quot;clients are &quot;, self.factory.clients def connectionLost(self, reason): self.factory.clients.remove(self) def dataReceived(self, data): #print &quot;data is &quot;, data a = data.split(&apos;:&apos;) if len(a) &gt; 1: command = a\\[0\\] content = a\\[1\\] msg = &quot;&quot; if command == &quot;iam&quot;: self.name = content msg = self.name + &quot; has joined&quot; elif command == &quot;msg&quot;: msg = self.name + &quot;: &quot; + content print msg for c in self.factory.clients: c.message(msg) def message(self, message): self.transport.write(message + &apos;\\\\n&apos;) factory = Factory()factory.protocol = IphoneChatfactory.clients = [] reactor.listenTCP(12345, factory)print “Iphone Chat server started”reactor.run() 终端 cd 到 .py 文件目录，执行以下命令。 ~ $ cd DesktopDesktop $ python chatserver.pyIphone Chat server started 看到提示：Iphone Chat server started 表示创建成功。 如果看到的提示是：No module named twisted.internet.protocol。表示本机上没有安装 twisted。","tags":[]},{"title":" Mac 安装/卸载 pip\t\t","date":"2019-03-25T05:33:44.000Z","path":"2019/03/25/mac-e5-ae-89-e8-a3-85-e5-8d-b8-e8-bd-bd-pip/","text":"查看本机 Python 版本 ~ $ python –versionPython 2.7.10 使用 brew 安装 python ~ $ brew install pythonUpdating Homebrew…==> Installing dependencies for python: gdbm, openssl, readline and sqlite==> Installing python dependency: gdbm==> Downloading https://homebrew.bintray.com/bottles/gdbm-1.18.1.high_sierra.bottle.1.tar.gz curl: (22) The requested URL returned error: 502 Bad GatewayError: Failed to download resource “gdbm”Download failed: https://homebrew.bintray.com/bottles/gdbm-1.18.1.high_sierra.bottle.1.tar.gzWarning: Bottle installation failed: building from source.==> Downloading https://ftp.gnu.org/gnu/gdbm/gdbm-1.18.1.tar.gz ######################################################################## 100.0%==> ./configure –disable-silent-rules –without-readline –prefix=/usr/local/Cellar/gdbm/1.18.1==> make install🍺 /usr/local/Cellar/gdbm/1.18.1: 20 files, 590.8KB, built in 36 seconds==> Installing python dependency: openssl==> Downloading https://homebrew.bintray.com/bottles/openssl-1.0.2r.high_sierra.bottle.tar.gz ######################################################################## 100.0%==> Pouring openssl-1.0.2r.high_sierra.bottle.tar.gz==> Caveats If you need Homebrew’s Python 2.7 run brew install python@2 You can install Python packages with pip3 install They will install into the site-package directory /usr/local/lib/python3.7/site-packages See: https://docs.brew.sh/Homebrew-and-Python 检测是否已安装 pip ~ $ pip-bash: pip: command not found 如果出现 -bash: /usr/local/bin/pip: No such file or directory 或如上的提示，说明还未安装 pip。 安装好 Python 环境的本地都有 easy_install 执行程序，这里主要使用 easy_install 来安装。 ~ $ sudo easy_install pipSearching for pipReading https://pypi.python.org/simple/pip/Best match: pip 19.0.3Downloading https://files.pythonhosted.org/packages/36/fa/51ca4d57392e2f69397cd6e5af23da2a8d37884a605f9e3f2d3bfdc48397/pip-19.0.3.tar.gz#sha256=6e6f197a1abfb45118dbb878b5c859a0edbdd33fd250100bc015b67fded4b9f2Processing pip-19.0.3.tar.gzWriting /tmp/easy_install-Msnup9/pip-19.0.3/setup.cfgRunning pip-19.0.3/setup.py -q bdist_egg –dist-dir /tmp/easy_install-Msnup9/pip-19.0.3/egg-dist-tmp-nqVuBi/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py:267: UserWarning: Unknown distribution option: ‘python_requires’ warnings.warn(msg)warning: no files found matching ‘docs/docutils.conf’warning: no previously-included files found matching ‘.coveragerc’warning: no previously-included files found matching ‘.mailmap’warning: no previously-included files found matching ‘.appveyor.yml’warning: no previously-included files found matching ‘.travis.yml’warning: no previously-included files found matching ‘tox.ini’warning: no files found matching ‘Makefile’ under directory ‘docs’warning: no files found matching ‘.bat’ under directory ‘docs’warning: no previously-included files found matching ‘src/pip/_vendor/six’warning: no previously-included files found matching ‘src/pip/_vendor/six/moves’warning: no previously-included files matching ‘.pyi’ found under directory ‘src/pip/_vendor’no previously-included directories found matching ‘.github’no previously-included directories found matching ‘.azure-pipelines’no previously-included directories found matching ‘docs/build’no previously-included directories found matching ‘news’no previously-included directories found matching ‘tasks’no previously-included directories found matching ‘tests’no previously-included directories found matching ‘tools’creating /Library/Python/2.7/site-packages/pip-19.0.3-py2.7.eggExtracting pip-19.0.3-py2.7.egg to /Library/Python/2.7/site-packagesAdding pip 19.0.3 to easy-install.pth fileInstalling pip script to /usr/local/binInstalling pip2.7 script to /usr/local/binInstalling pip2 script to /usr/local/bin Installed /Library/Python/2.7/site-packages/pip-19.0.3-py2.7.eggProcessing dependencies for pipFinished processing dependencies for pip 这里一定要使用 sudo 方式安装，不然会报错，因为会没权限。输入密码后，只要最后是 Finished 结尾就说明安装完成了。 查看 pip 版本 ~ $ pip –versionpip 19.0.3 from /Library/Python/2.7/site-packages/pip-19.0.3-py2.7.egg/pip (python 2.7) 卸载 pip 只需要一个命令 sudo pip uninstall pip 然后会提示你是否确认卸载，输入 y 就可以了。 ~ $ sudo pip uninstall pipPassword:DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won’t be maintained after that date. A future version of pip will drop support for Python 2.7.The directory ‘/Users/cykj/Library/Caches/pip/http’ or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo’s -H flag.Uninstalling pip-19.0.3: Would remove: /Library/Python/2.7/site-packages/pip-19.0.3-py2.7.egg /usr/local/bin/pip /usr/local/bin/pip2 /usr/local/bin/pip2.7Proceed (y/n)? y Successfully uninstalled pip-19.0.3 最后出现 Successfully uninstalled 的字样就说明卸载完成。","tags":[]},{"title":" RACStream\t\t","date":"2019-03-22T10:54:56.000Z","path":"2019/03/22/racstream/","text":"RACStream 继承自 NSObject，是 RACSignal 和 RACSequence 的父类，定义了一些流的操作方法。从名字上可以看出来，这个对象就像流一样可以往任何一个出口流，同时也可以给这个流设计一道道关卡，改变流（既包括流的内容，也包括融合，也包括流的筛选等）。 一、.h 文件@class RACStream; /// A block which accepts a value from a RACStream and returns a new instance of the same stream class.////// Setting `stop` to `YES` will cause the bind to terminate after the returned value. Returning `nil` will result in immediate termination./** * @param value 表示接收到信号的原始值，还未作处理 * @param *stop 用于控制绑定 block，如果 *stop = YES，那么就会结束绑定 * * @return 信号。做好处理后，再通过这个信号返回出去，一般使用 RACReturnSignal /typedef RACStream (^RACStreamBindBlock)(id value, BOOL *stop); 接受来自 RACStream 的值并返回 RACStream 类的新实例的 block。将 stop 设置为 YES 将导致绑定在返回值之后终止。返回 nil 将立即终止。 /// An abstract class representing any stream of values.////// This class represents a monad, upon which many stream-based operations can be built.////// When subclassing RACStream, only the methods in the main @interface body need to be overridden.@interface RACStream : NSObject 表示任何数据流的抽象类。 这个类表示一个 monad，在这个 monad 上可以构建许多基于流的操作。当继承 RACStream 时，只需要重写这个主要类的方法。 /// This extension contains functionality to support naming streams for debugging.////// Subclasses do not need to override the methods here.@interface RACStream () 此扩展包含支持调试的对流进行命名的功能。子类不需要重写方法。 /// The name of the stream. This is for debugging/human purposes only.@property (copy) NSString *name; 流的名称，用于调试目的。 /// Operations built on the RACStream primitives.////// These methods do not need to be overridden, although subclasses may occasionally gain better performance from doing so.@interface RACStream (Operations) 基于 RACStream 构建的操作。这些方法不需要被重写，尽管有时子类可以通过重写获得更好的性能。 /// Zips streams using +zip:, then reduces the resulting tuples into a single value using -reduceEach:////// streams - The streams to combine. These must all be instances of the/// same concrete class implementing the protocol. If this/// collection is empty, the returned stream will be empty./// reduceBlock - The block which reduces the values from all the streams/// into one value. It must take as many arguments as the/// number of streams given. Each argument will be an object/// argument. The return value must be an object. This argument/// must not be nil.////// Example:////// [RACStream zip:@[ stringSignal, intSignal ] reduce:^(NSString *string, NSNumber *number) {/// return [NSString stringWithFormat:@”%@: %@”, string, number];/// }];////// Returns a new stream containing the results from each invocation of/// `reduceBlock`.+ (instancetype)zip:(id)streams reduce:(id (^)())reduceBlock; 使用 zip: 方法打包多个流，然后使用 -reduceEach: 将生成的元组 tuples 缩减为单个值。 /// Returns a stream obtained by concatenating `streams` in order.+ (instancetype)concat:(id)streams; 返回按顺序连接 streams 而获得的流对象。 /// Combines values in the receiver from left to right using the given block.////// The algorithm proceeds as follows:////// 1. `startingValue` is passed into the block as the `running` value, and the/// first element of the receiver is passed into the block as the `next` value./// 2. The result of the invocation is added to the returned stream./// 3. The result of the invocation (`running`) and the next element of the/// receiver (`next`) is passed into `block`./// 4. Steps 2 and 3 are repeated until all values have been processed.////// startingValue - The value to be combined with the first element of the/// receiver. This value may be `nil`./// reduceBlock - The block that describes how to combine values of the/// receiver. If the receiver is empty, this block will never be/// invoked. Cannot be nil.////// Examples////// RACSequence numbers = @[ @1, @2, @3, @4 ].rac_sequence;////// // Contains 1, 3, 6, 10/// RACSequence \\sums = [numbers scanWithStart:@0 reduce:^(NSNumber *sum, NSNumber *next) {/// return @(sum.integerValue + next.integerValue);/// }];////// Returns a new stream that consists of each application of `reduceBlock`. If the receiver is empty, an empty stream is returned.- (instancetype)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock; 在 bind 基础上封装的改变方法，用同样的 block 执行每次流中的值，并将结果用于后一次执行当中，每次都把 block 执行后的值变成新的流中的对象。 /// Takes values until the given block returns `YES`.////// Returns a stream of the initial values in the receiver that fail `predicate`./// If `predicate` never returns `YES`, a stream equivalent to the receiver is returned.- (instancetype)takeUntilBlock:(BOOL (^)(id x))predicate; 在 bind 基础上封装的改变方法，取当前流的对象值，直到当前值满足提供的 block，就会将当前流变为空（不是空流）。 /// Takes values until the given block returns `NO`.////// Returns a stream of the initial values in the receiver that pass `predicate`./// If `predicate` never returns `NO`, a stream equivalent to the receiver is returned.- (instancetype)takeWhileBlock:(BOOL (^)(id x))predicate; 在 bind 基础上封装的改变方法，取当前流的对象值，直到当前值不满足提供的 block，就会将当前流变为空（不是空流）。 /// Skips values until the given block returns `YES`.////// Returns a stream containing the values of the receiver that follow any initial values failing `predicate`. If `predicate` never returns `YES`, an empty stream is returned.- (instancetype)skipUntilBlock:(BOOL (^)(id x))predicate; 在 bind 基础上封装的改变方法，忽略当前流的对象值（变为空流），直到当前值满足提供的 block。 /// Skips values until the given block returns `NO`.////// Returns a stream containing the values of the receiver that follow any initial values passing `predicate`. If `predicate` never returns `NO`, an empty stream is returned.- (instancetype)skipWhileBlock:(BOOL (^)(id x))predicate; 在 bind 基础上封装的改变方法，忽略当前流的对象值（变为空流），直到当前值不满足提供的 block /// Returns a stream of values for which -isEqual: returns NO when compared to the previous value.- (instancetype)distinctUntilChanged; 在 bind 基础上封装的改变方法，当流中后一次的值和前一次的值不同的时候，才会返回当前值的流，否则返回空流（第一次默认被忽略）。 1、empty/ Returns an empty stream. \\/+ (instancetype)empty{ return nil;} 返回一个空的流对象。由子类定义行为。 2、bind:/* Lazily binds a block to the values in the receiver. This should only be used if you need to terminate the bind early, or close over some state. -flattenMap: is more appropriate for all other cases. block - A block returning a RACStreamBindBlock. This block will be invoked each time the bound stream is re-evaluated. This block must not be nil or return nil. Returns a new stream which represents the combined result of all lazy applications of `block`. */- (instancetype)bind:(RACStreamBindBlock (^)(void))block{ return nil;} 只改变当前流对象的方法。 bind 函数的作用： 会订阅原始的信号。 任何时刻原始信号发送一个值，都会绑定的 block 转换一次。 一旦绑定的 block 转换了值变成信号，就立即订阅，并把值发给订阅者 subscriber。 一旦绑定的 block 要终止绑定，原始的信号就 complete。 当所有的信号都 complete，发送 completed 信号给订阅者 subscriber。 如果中途信号出现了任何 error，都要把这个错误发送给 subscriber 3、return:/* Lifts `value` into the stream monad. Returns a stream containing only the given value. */+ (instancetype)return:(id)value{ return nil;} 返回一个仅包含 value 数据的流对象。由子类定义行为。 4、concat:/* Appends the values of `stream` to the values in the receiver. stream - A stream to concatenate. This must be an instance of the same concrete class as the receiver, and should not be `nil`. Returns a new stream representing the receiver followed by `stream`. */- (instancetype)concat:(RACStream *)stream{ return nil;} 在当前响应流已经完成后，紧接着注入新的响应流。抽象方法未实现，由子类定义行为。 5、zipWith:/* Zips the values in the receiver with those of the given stream to create RACTuples. The first value of each stream will be combined, then the second value, and so forth, until at least one of the streams is exhausted. stream - The stream to zip with. This must be an instance of the same concrete class as the receiver, and should not be `nil`. Returns a new stream of RACTuples, representing the zipped values of the two streams. */- (instancetype)zipWith:(RACStream *)stream{ return nil;} 将不同的流进行打包合成一个流。抽象方法未实现，由子类定义行为。 6、setNameWithFormat:/* Sets the name of the receiver to the given format string. This is for debugging purposes only, and won’t do anything unless the RAC_DEBUG_SIGNAL_NAMES environment variable is set. Returns the receiver, for easy method chaining. */- (instancetype)setNameWithFormat:(NSString *)format, …{ if (getenv(“RAC_DEBUG_SIGNAL_NAMES”) == NULL) return self; NSCParameterAssert(format != nil); va_list args; va_start(args, format); NSString *str = \\[\\[NSString alloc\\] initWithFormat:format arguments:args\\]; va_end(args); self.name = str; return self; } 将流的名称设置为给定的格式字符串，这仅用于调试目的，除非设置了 rac_debug_signal_names 环境变量，否则不会执行任何操作。返回流对象用于方法链的调用。 这里值得学习的是可变参数的使用，va_list 是在 C 语言中解决变参问题的一组宏。 va_list 的用法： ①、首先在函数里定义一个 va_list 型的变量，这个变量是指向参数的指针； ②、然后用 va_start 宏初始化变量刚定义的 va_list 变量，va_start 的第 2 个参数是可变参数的前一个参数； ③、最后用 va_end 宏结束可变参数的获取。 7、flattenMap:要分析这个方法，先看看一个例子。 // 1\\. 创建信号 RACSignal * signal = \\[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;111&quot;\\]; return nil; }\\]; // 2\\. 调用 flattenMap RACSignal * flattenSignal = \\[signal flattenMap:^RACStream *(id value) { value = \\[NSString stringWithFormat:@&quot;Flatten Map %@&quot;, value\\]; return \\[RACReturnSignal return:value\\]; }\\]; // 3\\. 订阅信号。flattenSignal 为 RACDynamicSignal 类型 \\[flattenSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x); }\\]; Flatten Map 111 从输出 Flatten Map 111 可以看到，订阅的 block 里输出的是 flattenMap: 处理过的数据。 /* Maps `block` across the values in the receiver and flattens the result. Note that operators applied _after_ -flattenMap: behave differently from operators _within_ -flattenMap:. See the Examples section below. This corresponds to the `SelectMany` method in Rx. block - A block which accepts the values in the receiver and returns a new instance of the receiver’s class. Returning `nil` from this block is equivalent to returning an empty signal. Examples [signal flattenMap:^(id x) { // Logs each time a returned signal completes. return [[RACSignal return:x] logCompleted]; }]; [[signal flattenMap:^(id x) { return [RACSignal return:x]; }] // Logs only once, when all of the signals complete. logCompleted]; Returns a new stream which represents the combined streams resulting from mapping `block`.*/- (instancetype)flattenMap:(RACStream (^)(id value))block{ Class class = self.class; return [[self bind:^{ return ^(id value, BOOL stop) { id stream = block(value) ?: \\[class empty\\]; NSCAssert(\\[stream isKindOfClass:RACStream.class\\], @&quot;%@&quot;, stream); return stream; }; }\\] setNameWithFormat:@&quot;\\[%@\\] -flattenMap:&quot;, self.name\\]; } 从方法的源码可以看到 flattenMap 是在 bind 基础上封装的。 flattenMap 调用 bind 方法传入 block，RACSignal 的 bind 方法内部会执行 block 的返回值 RACStreamBindBlock，它也是一个 block，最后会调用最内层代码。内层代码将 value 数据传给 flattenMap 参数的 block，这里进行了数据的处理并返回一个 RACStream 对象（通常是 RACReturnSignal 对象），RACStream 向上传递，在 bind 的 block 里被包装成 RACDynamicSignal 类（被添加到了 signals 数组中）。 总结：flattenMap 根据前一个信号的参数创建一个新的信号。 8、flatten/* Flattens a stream of streams. This corresponds to the `Merge` method in Rx. Returns a stream consisting of the combined streams obtained from the receiver.*/- (instancetype)flatten{ __weak RACStream *stream __attribute__((unused)) = self; return \\[\\[self flattenMap:^(id value) { return value; }\\] setNameWithFormat:@&quot;\\[%@\\] -flatten&quot;, self.name\\]; } 在 flattenMap 基础上封装的改变方法，就是函数式编程中的聚合 Merge。 要了解这个方法需要结合 RACSignal 中的 merge: 方法。 - (RACSignal )merge:(RACSignal )signal{ // 调用类方法，传入信号数组 return [[RACSignal merge:@[ self, signal ]] setNameWithFormat:@”[%@] -merge: %@”, self.name, signal];} + (RACSignal )merge:(id)signals{ NSMutableArray copiedSignals = [[NSMutableArray alloc] init]; // 数组持有多个信号 for (RACSignal *signal in signals) { \\[copiedSignals addObject:signal\\]; } return \\[\\[\\[RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) { // 订阅者发送内容，内容为信号 self 和 signal for (RACSignal *signal in copiedSignals) { \\[subscriber sendNext:signal\\]; } \\[subscriber sendCompleted\\]; return nil; }\\] flatten\\] setNameWithFormat:@&quot;+merge: %@&quot;, copiedSignals\\]; } 过程图： RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; return nil; }\\]; RACSignal \\*signalB = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalB&quot;\\]; return nil; }\\]; RACSignal * mergeSignal = \\[signalA merge:signalB\\]; \\[mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; signalAsignalB 当执行 merge 的时候创建了 C、D 两个内部信号，这里的 mergeSignal 实际为 D 信号。当订阅 D 信号后，执行上图右侧的流程，一直会执行到 A 的 merge 方法里 createSignal: 的 block，循环发送 signal 信号，最终的结果是执行各个信号的 sendNext: 方法。 merge 看起来就是把多个信号（signalA、signalB）合并成一个信号 mergeSignal，只要其中任何一个信号发送数据，合并的信号 mergeSignal 都能接收到事件。 ReactiveCocoa 源码阅读之攻略 flatten 9、map:/* Maps `block` across the values in the receiver. This corresponds to the `Select` method in Rx. Returns a new stream with the mapped values. */- (instancetype)map:(id (^)(id value))block{ NSCParameterAssert(block != nil); Class class = self.class; return \\[\\[self flattenMap:^(id value) { return \\[class return:block(value)\\]; }\\] setNameWithFormat:@&quot;\\[%@\\] -map:&quot;, self.name\\]; } 在 flattenMap 基础上封装的改变方法，就是函数式编程中的 Select。在 flattenMap 中的 block 中返回的值必须也是流对象，而 map 则不需要，它是将流中的对象执行 block 后，用流的 return 方法将值变成流对象。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; return nil; }\\]; RACSignal *mergeSignal = \\[signalA map:^id(id value) { return @&quot;aaa&quot;; }\\]; \\[mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; aaa 要理解 map 需要结合 return: 方法，return: 方法在 RACReturnSignal 类中实现。 + (RACSignal )return:(id)value{ RACReturnSignal signal = [[self alloc] init]; signal-&gt;_value = value; return signal; } 删除了在 map 流程中执行不到的代码。由上可以看到：return 方法是保存了 value 值，然后返回一个 RACReturnSignal 对象。所以 map 方法可以理解成： - (instancetype)map:(id (^)(id value))block{ return [self flattenMap:^(id value) { return [[RACReturnSignal alloc] init]; // 新建 return 信号，这里已经执行了 block(value)，获取到了 block 的返回值 }];} 经由 flattenMap 向外返回的是 RACReturnSignal 类型对象。当 RACReturnSignal 对象被订阅时： - (RACDisposable *)subscribe:(id)subscriber{ NSCParameterAssert(subscriber != nil); return \\[RACScheduler.subscriptionScheduler schedule:^{ \\[subscriber sendNext:self.value\\]; \\[subscriber sendCompleted\\]; }\\]; } 将属性 value 向外传递，所以这样导致会替换原来信号发送的内容。 flattenMap 与 map 的理解： map 方法根据原信号创建了一个新的信号，并且变换了信号的输出值，这两个信号具有明显的先后顺序关系。而 flattenMap 方法，直接生成了一个新的信号，这两个信号并没有先后顺序关系，属于同层次的平行关系。 FlatternMap中的 Block 返回信号；Map中的 Block 返回对象。 开发中，如果信号发出的值不是信号，映射一般使用 Map；如果信号发出的值是信号，映射一般使用 FlatternMap。 ReactiveCocoa框架菜鸟入门（五）–信号的FlattenMap与Map、FlatternMap和Map的区别 10、mapReplace:/* Replaces each value in the receiver with the given object. Returns a new stream which includes the given object once for each value in the receiver. */- (instancetype)mapReplace:(id)object{ return [[self map:^(id _) { return object; }] setNameWithFormat:@”[%@] -mapReplace: %@”, self.name, [object rac_description]];} 在 map 的基础上封装的改变方法，直接替换当前流中的对象，形成一个新的对象流。 RACSignal * signalA = \\[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; return nil; }\\]; RACSignal * mergeSignal = \\[signalA mapReplace:@&quot;aaa&quot;\\]; \\[mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x); }\\]; aaa 与 map: 的功能一样，替换流输出的内容，mapReplace: 采用直接传值的方式，map: 采用 block。 11、combinePreviousWithStart:reduce:/* Combines each previous and current value into one object. This method is similar to -scanWithStart:reduce:, but only ever operates on the previous and current values (instead of the whole stream), and does not pass the return value of `reduceBlock` into the next invocation of it. start - The value passed into `reduceBlock` as `previous` for the first value. reduceBlock - The block that combines the previous value and the current value to create the reduced value. Cannot be nil. Examples RACSequence *numbers = @\\[ @1, @2, @3, @4 \\].rac_sequence; // Contains 1, 3, 5, 7 RACSequence \\*sums = \\[numbers combinePreviousWithStart:@0 reduce:^(NSNumber \\*previous, NSNumber *next) { return @(previous.integerValue + next.integerValue); }\\]; Returns a new stream consisting of the return values from each application of `reduceBlock`.*/- (instancetype)combinePreviousWithStart:(id)start reduce:(id (^)(id previous, id next))reduceBlock{ NSCParameterAssert(reduceBlock != NULL); return \\[\\[\\[self scanWithStart:RACTuplePack(start) reduce:^(RACTuple *previousTuple, id next) { id value = reduceBlock(previousTuple\\[0\\], next); return RACTuplePack(next, value); }\\] map:^(RACTuple *tuple) { return tuple\\[1\\]; }\\] setNameWithFormat:@&quot;\\[%@\\] -combinePreviousWithStart: %@ reduce:&quot;, self.name, \\[start rac_description\\]\\]; } 通过官方的示例，数组的内容由 @[1, 2, 3, 4] 变成了 @[1, 3, 5, 7]，可以猜测 combinePreviousWithStart:reduce: 方法是将旧数组的两个相邻的值通过 reduce:^{} 处理产生新的值。 在 RACSequence 的 bind:passingThroughValuesFromSequence: 调用 bind: 传入的 block。实际上 block 的传递流程是： 最终会调用到用户处理的 RACSequence *sums = [numbers combinePreviousWithStart:@0 reduce:^(NSNumber *previous, NSNumber *next) { return @(previous.integerValue + next.integerValue); }]; 第一次时 previous = @0，就是第一个参数。在这里有对 start 进行 RACTuplePack 包装。 传入的数组为 @[ 1, 2, 3, 4 ]、start = 2，那么调用顺序是：1 + 2(start) = 3，2 + 1(pre) = 3，3 + 2(pre) = 5，4 + 3(pre) = 7。归纳：该方法传入 start 数值，可以理解索引为 -1，然后相邻的数据相加。 12、filter:/* Filters out values in the receiver that don’t pass the given test. This corresponds to the `Where` method in Rx. Returns a new stream with only those values that passed. */- (instancetype)filter:(BOOL (^)(id value))block{ NSCParameterAssert(block != nil); Class class = self.class; return \\[\\[self flattenMap:^ id (id value) { if (block(value)) { return \\[class return:value\\]; } else { return class.empty; } }\\] setNameWithFormat:@&quot;\\[%@\\] -filter:&quot;, self.name\\]; } 在 flattenMap: 基础上封装的改变方法，过滤掉当前流中不符合要求的对象，将之变为空流。 当 block(value) 返回 YES 时，使用 RACReturnSignal 对象保存 value 值，订阅时打印出来；如果返回 NO，则返回空流，订阅时也就打印不出来东西。 - (RACDisposable *)subscribe:(id)subscriber{ NSCParameterAssert(subscriber != nil); return \\[RACScheduler.subscriptionScheduler schedule:^{ \\[subscriber sendCompleted\\]; }\\]; } RACEmptySignal 直接调用 sendCompleted 方法，不会 sendNext。 13、ignore:/* Filters out values in the receiver that equal (via -isEqual:) the provided value. value - The value can be `nil`, in which case it ignores `nil` values. Returns a new stream containing only the values which did not compare equal to `value`. */- (instancetype)ignore:(id)value{ return [[self filter:^ BOOL (id innerValue) { return innerValue != value &amp;&amp; ![innerValue isEqual:value]; }] setNameWithFormat:@”[%@] -ignore: %@”, self.name, [value rac_description]];} 在 filter 基础封装的改变方法，忽略和当前值一样的对象，将之变为空流。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; return nil; }\\]; RACSignal * ignoreSignal = \\[signalA ignore:@&quot;signalB&quot;\\]; // 如果是 ignore:@&quot;signalA&quot; 则不会输出 \\[ignoreSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; signalA 如果 sendNext: 的内容与 ignore: 的内容相同，filter 的 block 返回 NO，否则返回 YES。即达到了忽略值的功能。 14、reduceEach:/* Unpacks each RACTuple in the receiver and maps the values to a new value. reduceBlock - The block which reduces each RACTuple’s values into one value. It must take as many arguments as the number of tuple elements to process. Each argument will be an object argument. The return value must be an object. This argument cannot be nil. Returns a new stream of reduced tuple values. */- (instancetype)reduceEach:(id (^)())reduceBlock{ NSCParameterAssert(reduceBlock != nil); \\_\\_weak RACStream *stream \\_\\_attribute__((unused)) = self; return \\[\\[self map:^(RACTuple *t) { NSCAssert(\\[t isKindOfClass:RACTuple.class\\], @&quot;Value from stream %@ is not a tuple: %@&quot;, stream, t); return \\[RACBlockTrampoline invokeBlock:reduceBlock withArguments:t\\]; }\\] setNameWithFormat:@&quot;\\[%@\\] -reduceEach:&quot;, self.name\\]; } 解包接收器中的每个 RACTuple，并将所有的值映射为一个新值。 RACSignal * signalA = \\[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { RACTuple * tuple = RACTuplePack(@&quot;signalA&quot;); \\[subscriber sendNext:tuple\\]; // 传递的数据需要是 RACTuple 类型，否则会触发断言 return nil; }\\]; RACSignal * reduceEachSignal = \\[signalA reduceEach:^id{ return @&quot;aaa&quot;; }\\]; \\[reduceEachSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; aaa 15、startWith:/* Returns a stream consisting of `value`, followed by the values in the receiver. */- (instancetype)startWith:(id)value{ return [[[self.class return:value] concat:self] setNameWithFormat:@”[%@] -startWith: %@”, self.name, [value rac_description]];} 在 contact 基础上封装的多流之间的顺序方法，在当前流的值流出之前，加入一个初始值。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { RACTuple * tuple = RACTuplePack(@&quot;signalA&quot;); \\[subscriber sendNext:tuple\\]; return nil; }\\]; RACSignal * startWithSignal = \\[signalA startWith:@&quot;1&quot;\\]; \\[startWithSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; 1&lt;RACTuple: 0x6000017eaf30&gt; ( signalA ) 在输出 tuple(signalA) 之前先输出 1，这段逻辑在 RACSignal 的 concat: 方法中。 - (RACSignal )concat:(RACSignal )signal { RACDisposable *sourceDisposable = \\[self subscribeNext:^(id x) { \\[subscriber sendNext:x\\]; // 输出 1 } error:^(NSError *error) { \\[subscriber sendError:error\\]; } completed:^{ RACDisposable *concattedDisposable = \\[signal subscribe:subscriber\\]; // 输出 tuple(signalA) serialDisposable.disposable = concattedDisposable; }\\]; } 16、skip:/* Skips the first `skipCount` values in the receiver. Returns the receiver after skipping the first `skipCount` values. If `skipCount` is greater than the number of values in the stream, an empty stream is returned. */- (instancetype)skip:(NSUInteger)skipCount{ Class class = self.class; return \\[\\[self bind:^{ __block NSUInteger skipped = 0; return ^(id value, BOOL *stop) { if (skipped &gt;= skipCount) return \\[class return:value\\]; skipped++; return class.empty; }; }\\] setNameWithFormat:@&quot;\\[%@\\] -skip: %lu&quot;, self.name, (unsigned long)skipCount\\]; } 在 bind 基础上封装的改变方法，忽略当前流前 n 次的对象值，将之变为空流，不输出。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; \\[subscriber sendNext:@&quot;signalB&quot;\\]; \\[subscriber sendNext:@&quot;signalC&quot;\\]; \\[subscriber sendNext:@&quot;signalD&quot;\\]; return nil; }\\]; RACSignal * skipSignal = \\[signalA skip:2\\]; \\[skipSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; signalCsignalD 跳过了第一、二次的输出。 17、take:/ Returns a stream of the first `count` values in the receiver. If `count` is greater than or equal to the number of values in the stream, a stream equivalent to the receiver is returned. \\/- (instancetype)take:(NSUInteger)count{ Class class = self.class; if (count == 0) return class.empty; return \\[\\[self bind:^{ __block NSUInteger taken = 0; return ^ id (id value, BOOL *stop) { if (taken &lt; count) { ++taken; if (taken == count) *stop = YES; return \\[class return:value\\]; } else { return nil; } }; }\\] setNameWithFormat:@&quot;\\[%@\\] -take: %lu&quot;, self.name, (unsigned long)count\\]; } 在 bind 基础上封装的改变方法，只取当前流中的前 n 次对象值，之后将流变为空（不是空流）。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; \\[subscriber sendNext:@&quot;signalB&quot;\\]; \\[subscriber sendNext:@&quot;signalC&quot;\\]; \\[subscriber sendNext:@&quot;signalD&quot;\\]; return nil; }\\]; RACSignal *mergeSignal = \\[signalA take:2\\]; \\[mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; signalAsignalB 与 skip: 相对，只取第一、二条数据。 18、join:block:/* Combines a list of streams using the logic of the given block. streams - The streams to combine. block - An operator that combines two streams and returns a new one. The returned stream should contain 2-tuples of the streams’ combined values. Returns a combined stream. */+ (instancetype)join:(id)streams block:(RACStream (^)(id, id))block{ RACStream current = nil; // Creates streams of successively larger tuples by combining the input streams one-by-one. for (RACStream *stream in streams) { // For the first stream, just wrap its values in a RACTuple. That way, if only one stream is given, the result is still a stream of tuples. if (current == nil) { current = \\[stream map:^(id x) { return RACTuplePack(x); // 生成 RACReturnSignal 对象，value = RACTuplePack(x) }\\]; continue; } current = block(current, stream); } if (current == nil) return \\[self empty\\]; // 如果为 nil，返回空流 return \\[current map:^(RACTuple *xs) { /\\* Right now, each value is contained in its own tuple, sorta like: (((1), 2), 3) We need to unwrap all the layers and create a tuple out of the result. */ NSMutableArray *values = \\[\\[NSMutableArray alloc\\] init\\]; while (xs != nil) { \\[values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0\\]; xs = (xs.count &gt; 1 ? xs.first : nil); } return \\[RACTuple tupleWithObjectsFromArray:values\\]; }\\]; } 使用给定 block 的逻辑组合流列表。 for 循环部分：如果信号数组里只有 1 个信号，那么通过 map，最终获取的结果被放进一个 tuple 里，比如 [value1]；如果数组里信号多于 1 个，那么第一个信号和第二信号就要做 zipWith（此时 block 就是 zipWith）操作，参考上面zipWith，得到的返回结果是 [[value1], value2]；如果还有第 3 个信号，那么将信号 1 和信号 2 zipWith 的结果与信号 3 继续 zipWith，得到的结果就是 [[[value1]，value2], value3]； return 部分：for 循环得到的信号最后 sendNext 的值是一个 [[[value1], value2], value3] 之类的 tuple，如同注释里的“(((1), 2), 3)”一样，需要转换成 [value1, value2, value3]。 19、zip:/* Zips the values in the given streams to create RACTuples. The first value of each stream will be combined, then the second value, and so forth, until at least one of the streams is exhausted. streams - The streams to combine. These must all be instances of the same concrete class implementing the protocol. If this collection is empty, the returned stream will be empty. Returns a new stream containing RACTuples of the zipped values from the streams. */+ (instancetype)zip:(id)streams{ return [[self join:streams block:^(RACStream *left, RACStream *right) { return [left zipWith:right]; }] setNameWithFormat:@”+zip: %@”, streams];} 打包多流，将多个流中的值包装成一个 RACTuple 对象。 RACSignal \\*signalA = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalA&quot;\\]; return nil; }\\]; RACSignal \\*signalB = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalB&quot;\\]; return nil; }\\]; RACSignal \\*signalC = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@&quot;signalC&quot;\\]; return nil; }\\]; RACSequence * sequence = @\\[signalA, signalB, signalC\\].rac_sequence; RACSignal * zipSignal = \\[RACSignal zip:sequence\\]; \\[zipSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;,x); }\\]; &lt;RACTuple: 0x600002ae00d0&gt; ( signalA, signalB, signalC) 3. RACStream子类策略 RACStream是RACSignal和RACSequence的父类，但是，RACSignal和RACSequence都自己实现了一套bind，zipWith和contât方法，所以在不同的子类中，RACStream中定义的各种操作对应到各种子类，就会有不同的涵义。---------------------作者：chenyin10011991来源：CSDN原文：https://blog.csdn.net/chenyin10011991/article/details/51971388版权声明：本文为博主原创文章，转载请附上博文链接！","tags":[]},{"title":" RACSignal\t\t","date":"2019-03-22T06:59:18.000Z","path":"2019/03/22/racsignal/","text":"文章：一缕殇流化隐半边冰霜 https://www.jianshu.com/p/d7d951a99db8 ReactiveCocoa 中最核心的概念之一就是信号 RACStream。RACStream 中有两个子类：RACSignal、RACSequence。 RACSiganl：信号类，一般表示将来有数据传递。只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 当数据改变时，信号内部会发出数据，RACSiganl 本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，就是值改变了也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号 RACSignal 的 subscribeNext 就能订阅。 订阅的信号只有一次有效性。当向第二个订阅者发送数据时，第一个订阅者是收不到信息的。 RACSiganl 简单使用： /* RACSignal 底层实现： 1.创建信号，首先把 didSubscribe 保存到信号中，还不会触发。 2.当信号被订阅，也就是调用 signal 的 subscribeNext:nextBlock 2.2 subscribeNext 内部会创建订阅者 subscriber，并且把 nextBlock 保存到 subscriber 中。 2.1 subscribeNext 内部会调用 siganl 的 didSubscribe 3.siganl 的 didSubscribe 中调用 [subscriber sendNext:@1]; 3.1 sendNext 底层其实就是执行 subscriber 的 nextBlock/// 1.创建信号RACSignal siganl = [RACSignal createSignal:^RACDisposable *(id subscriber) { // block 调用时机：每当有订阅者订阅信号，就会调用 block // 2.发送信号 \\[subscriber sendNext:@1\\]; // 如果不再发送数据，最好发送信号完成，内部会自动调用 \\[RACDisposable disposable\\] 取消订阅信号 \\[subscriber sendCompleted\\]; return \\[RACDisposable disposableWithBlock:^{ // block 调用时机：当信号发送完成或者发送错误，就会自动执行这个 block，取消订阅信号 // 执行完 Block 后，当前信号就不再被订阅了 NSLog(@&quot;信号被销毁&quot;); }\\]; }]; // 3.订阅信号，才会激活信号[siganl subscribeNext:^(id x) { // block 调用时机：每当有信号发出数据，就会调用 block NSLog(@”接收到数据：%@”, x);}]; 这是一个 RACSignal 被订阅的完整过程。被订阅的过程中，究竟发生了什么？ + (RACSignal )createSignal:(RACDisposable (^)(id subscriber))didSubscribe { return [RACDynamicSignal createSignal:didSubscribe];} RACSignal 调用 createSignal 的时候，会调用 RACDynamicSignal 的 createSignal 的方法。而 RACDynamicSignal 是 RACSignal 的子类。","tags":[]},{"title":" Websocket\t\t","date":"2019-03-22T05:48:33.000Z","path":"2019/03/22/websocket/","text":"原文：微信、QQ这类 IM app 怎么做–谈谈Websocket、微信开源的跨平台终端组件 目录 WebSocket 使用场景 WebSocket 诞生由来 WebSocket 协议原理 WebSocket 和 Socket 的区别与联系 iOS 平台有哪些 WebSocket 和 Socket 的开源框架 iOS 平台如何实现 WebSocket 协议 总结 一、WebSocket 的使用场景1、社交聊天 这类聊天 app 的特点是低延迟，高即时。即时性是要求最高的。 2、弹幕 发弹幕需要实时显示，也需要和聊天一样，需要即时。 3、多玩家游戏 4、协同编辑 现在很多开源项目都是分散在世界各地的开发者一起协同开发，此时就会用到版本控制系统，比如 Git、SVN 去合并冲突。但是如果有一份文档，支持多人实时在线协同编辑，那么此时就会用到比如 WebSocket 了，它可以保证各个编辑者都在编辑同一个文档，此时不需要用到 Git、SVN 这些版本控制，因为在协同编辑界面就会实时看到对方编辑了什么。 5、股票基金实时报价 如果采用的网络架构无法满足实时性，那么就会给客户带来巨大的损失。 6、体育实况更新 7、视频会议/聊天 8、基于位置的应用 越来越多的开发者借用移动设备的 GPS 功能来实现他们基于位置的网络应用。如果你一直记录用户的位置（比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。 9、在线教育 Websocket 是个不错的选择，可以视频聊天、即时聊天以及其与别人合作一起在网上讨论问题。 10、智能家居 总结：从上面我列举的这些场景来看，一个共同点就是，高实时性！ 二、WebSocket 诞生由来1、最开始的轮询 Polling 阶段 这种方式是不适合获取实时信息的，客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。客户端会轮询，有没有新消息。这种方式连接数会很多，一个接受，一个发送。而且每次发送请求都会有 Http 的 Header，会很耗流量，也会消耗 CPU 的利用率。 2、改进版的长轮询 Long polling 阶段 长轮询是对轮询的改进版，客户端发送 HTTP 给服务器之后，有没有新消息。如果没有新消息，就一直等待；当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和 CPU 利用率等问题。 但是这种方式还是有一种弊端：假设服务器端的数据更新速度很快，服务器在传送一个数据包给客户端后必须等待客户端的下一个 Get 请求到来，才能传递第二个更新的数据包给客户端，那么这样的话，客户端显示实时数据最快的时间为 2×RTT（往返时间），而且如果在网络拥塞的情况下，这个时间用户是不能接受的，比如在股市的的报价上。另外，由于 http 数据包的头部数据量往往很大（通常有 400 多个字节），但是真正被服务器需要的数据却很少（有时只有 10 个字节左右），这样的数据包在网络上周期性的传输，难免对网络带宽是一种浪费。 3、WebSocket 诞生 现在急需的需求是能支持客户端和服务器端的双向通信，而且协议的头部又没有 HTTP 的 Header 那么大。 上图就是 Websocket 和 Polling 的区别，从图中可以看到 Polling 里面客户端发送了好多 Request，而下图，只有一个Upgrade，非常简洁高效。消耗方面的比较： 蓝色的柱状图，是 Polling 轮询消耗的流量，这次测试，HTTP 请求和响应头信息开销总共包括 871 字节。当然每次测试不同的请求，头的开销不同。这次测试都以 871 字节的请求来测试。 **Use case A: **1,000 clients polling every second: Network throughput is (871 x 1,000) = 871,000 bytes = 6,968,000 bits per second (6.6 Mbps)**Use case B: **10,000 clients polling every second: Network throughput is (871 x 10,000) = 8,710,000 bytes = 69,680,000 bits per second (66 Mbps)**Use case C: **100,000 clients polling every 1 second: Network throughput is (871 x 100,000) = 87,100,000 bytes = 696,800,000 bits per second (665 Mbps) 而 Websocket 的 Frame 是 just two bytes of overhead instead of 871，仅仅用 2 个字节就代替了轮询的 871 字节！ **Use case A: **1,000 clients receive 1 message per second: Network throughput is (2 x 1,000) = 2,000 bytes = 16,000 bits per second (0.015 Mbps)**Use case B: **10,000 clients receive 1 message per second: Network throughput is (2 x 10,000) = 20,000 bytes = 160,000 bits per second (0.153 Mbps)**Use case C: **100,000 clients receive 1 message per second: Network throughput is (2 x 100,000) = 200,000 bytes = 1,600,000 bits per second (1.526 Mbps) 相同的每秒客户端轮询的次数，当次数高达 10W/s 的高频率次数的时候，Polling 轮询需要消耗 665Mbps，而 Websocket 仅仅只花费了 1.526Mbps，将近 435 倍。 三、谈谈 WebSocket 协议原理Websocket 是应用层第七层上的一个应用层协议，它必须依赖 HTTP 协议进行一次握手，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。 “它必须依赖 HTTP 协议进行一次握手” 其他的 Socket 都是通过 ip + 端口连接，但是客户端写死 ip 和端口是很不明智的，通过域名解析在客户端与服务端之间建立桥梁，服务端就能更加灵活。WebSocket 里能通过 url 建立连接，http 一次握手有可能是用来域名解析用的。（待验证） Websocket 的数据传输是以 frame 形式传输的，比如会将一条消息分为几个 frame，按照先后顺序传输出去。这样做会有几个好处： 大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。 和 http 的 chunk 一样，可以边生成数据边传递消息，即提高传输效率。 0 1 2 30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+——-+-+————-+——————————-+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +——————————-+| |Masking-key, if MASK set to 1 |+——————————-+——————————-+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued … :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued … |+—————————————————————+ FIN 1bit 表示信息的最后一帧，flag，也就是标记符 RSV 1-3 1bit each 以后备用的 默认都为 0 Opcode 4bit 帧类型，稍后细说 Mask 1bit 掩码，是否加密数据，默认必须置为1 （这里很蛋疼） Payload 7bit 数据的长度 Masking-key 1 or 4 bit 掩码 Payload data (x + y) bytes 数据 Extension data x bytes 扩展数据 Application data y bytes 程序数据 具体的规范，还请看官网的RFC 6455文档给出的详细定义。这里还有一个翻译版本 四、WebSocket 和 Socket 的区别与联系首先 Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第 5 层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket 是对 TCP/IP 协议的封装，Socket本身并不是协议，而是一个调用接口（API）。 Socket 通常也称作”套接字”，用于描述 IP 地址和端口，是一个通信链的句柄。 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket，一个 Socket 由一个 IP 地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 Socket 在通讯过程中，服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端也都可以相互发送消息与对方进行通讯，直到双方连接断开。 所以基于 WebSocket 和基于 Socket 都可以开发出 IM 社交聊天类的 app。 五、iOS 平台的 WebSocket 和 Socket 开源框架Socket 开源框架有：CocoaAsyncSocket，socketio/socket.io-client-swiftWebSocket 开源框架有：facebook/SocketRocket，tidwall/SwiftWebSocket 六、iOS 平台如何实现 WebSocket 协议来看看 facebook/SocketRocket 的实现方法。首先这是 SRWebSocket 定义的一些成员变量 @property (nonatomic, weak) id delegate;/** A dispatch queue for scheduling the delegate calls. The queue doesn’t need be a serial queue. If `nil` and `delegateOperationQueue` is `nil`, the socket uses main queue for performing all delegate method calls. */@property (nonatomic, strong) dispatch_queue_t delegateDispatchQueue;/** An operation queue for scheduling the delegate calls. If `nil` and `delegateOperationQueue` is `nil`, the socket uses main queue for performing all delegate method calls. /@property (nonatomic, strong) NSOperationQueue delegateOperationQueue;@property (nonatomic, readonly) SRReadyState readyState;@property (nonatomic, readonly, retain) NSURL url;@property (nonatomic, readonly) CFHTTPMessageRef receivedHTTPHeaders;// Optional array of cookies (NSHTTPCookie objects) to apply to the connections@property (nonatomic, copy) NSArray&lt;NSHTTPCookie &gt; *requestCookies; // This returns the negotiated protocol.// It will be nil until after the handshake completes.@property (nonatomic, readonly, copy) NSString *protocol; SRWebSocket 的一些方法： // Protocols should be an array of strings that turn into Sec-WebSocket-Protocol.- (instancetype)initWithURLRequest:(NSURLRequest )request;- (instancetype)initWithURLRequest:(NSURLRequest )request protocols:(NSArray )protocols;- (instancetype)initWithURLRequest:(NSURLRequest )request protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; // Some helper constructors.- (instancetype)initWithURL:(NSURL )url;- (instancetype)initWithURL:(NSURL )url protocols:(NSArray )protocols;- (instancetype)initWithURL:(NSURL )url protocols:(NSArray *)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates; // By default, it will schedule itself on +[NSRunLoop SR_networkRunLoop] using defaultModes.- (void)scheduleInRunLoop:(NSRunLoop )aRunLoop forMode:(NSString )mode;- (void)unscheduleFromRunLoop:(NSRunLoop )aRunLoop forMode:(NSString )mode; // SRWebSockets are intended for one-time-use only. Open should be called once and only once.- (void)open;- (void)close;- (void)closeWithCode:(NSInteger)code reason:(NSString *)reason; ///————————————– #pragma mark Send///————————————– //下面是4个发送的方法/** Send a UTF-8 string or binary data to the server. @param message UTF-8 String or Data to send. @deprecated Please use `sendString:` or `sendData` instead. */- (void)send:(id)message __attribute__((deprecated(“Please use `sendString:` or `sendData` instead.”)));- (void)sendString:(NSString )string;- (void)sendData:(NSData )data;- (void)sendPing:(NSData *)data; @end 5 种状态的代理方法： ///————————————– #pragma mark - SRWebSocketDelegate///————————————–@protocol SRWebSocketDelegate - (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message; @optional- (void)webSocketDidOpen:(SRWebSocket )webSocket;- (void)webSocket:(SRWebSocket )webSocket didFailWithError:(NSError )error;- (void)webSocket:(SRWebSocket )webSocket didCloseWithCode:(NSInteger)code reason:(NSString )reason wasClean:(BOOL)wasClean;- (void)webSocket:(SRWebSocket )webSocket didReceivePong:(NSData *)pongPayload; // Return YES to convert messages sent as Text to an NSString. Return NO to skip NSData -&gt; NSString conversion for Text messages. Defaults to YES.- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket;@end didReceiveMessage 方法是必须实现的，用来接收消息的。下面 4 个 did 方法分别对应着 Open、Fail、Close、ReceivePong 不同状态的代理方法。 方法就上面这些了，实际来看看代码怎么写 { /* 先初始化 Websocket 连接，注意此处 ws:// 或者 wss:// 连接有且最多只能有一个，这个是 Websocket 协议规定的 / NSURL url = [NSURL URLWithString:[NSString stringWithFormat:@”%@://%@:%zd/ws”, serverProto, serverIP, serverPort]]; self.ws = \\[\\[SRWebSocket alloc\\] initWithURLRequest:\\[NSURLRequest requestWithURL:url\\]\\]; self.ws.delegate = delegate; \\[self.ws open\\]; // 发送消息 \\[self.ws send:message\\]; } /// 接收消息以及其他 3 个代理方法/** * @brief 接受消息。这里接受服务器返回的数据，方法里面就应该写处理数据，存储数据的方法。 */- (void)webSocket:(SRWebSocket )webSocket didReceiveMessage:(id)message{ NSDictionary data = [NetworkUtils decodeData:message]; if (!data) return;} /** * @brief Websocket 刚刚 Open * @discussion 就像微信刚刚连接中，会显示连接中，当连接上了，就不显示连接中了，取消显示连接的方法就应该写在这里面 */- (void)webSocketDidOpen:(SRWebSocket *)webSocket{ // Open = silent ping [self.ws receivedPing];} /** * @brief 关闭 Websocket */- (void)webSocket:(SRWebSocket )webSocket didCloseWithCode:(NSInteger)code reason:(NSString )reason wasClean:(BOOL)wasClean{ [self failedConnection:NSLS(Disconnected)];} /** * @brief 连接 Websocket 失败，这里面一般都会写重连的方法 */- (void)webSocket:(SRWebSocket )webSocket didFailWithError:(NSError )error{ [self failedConnection:NSLS(Disconnected)];} 七、问题对于 websocket 的优点上面解释得很清楚。 1、它的缺点呢？ 其中一个：因为其连接的 persistent（保持）特点，必然占据大量的资源（服务器以及客户端），因此对于并发量大的情况下，资源的消耗是很可观的。这个需要根据实际情况抉择，损耗相对于优点来说，是否可以忽略。 2、webSocket 心跳，怎么处理？ 每隔几秒发一次，和 socket 差不多。 3、Websocket 实现视频通话，语音通话，有什么好的解决方案吗？ 可以看看 webRTC 4、websocket 可以正常连接，不过连接成功两分钟后就会断掉，后台没有提供心跳接口，像这样的问题应该怎么处理？目前临时处理是断开后置空 websocket，然后重新连接，感觉这样太不好了，而且会有较低概率出现闪退，回复是由于 NSAssert(_readyState == SR_CONNECTING, @”Cannot call -(void)open on SRWebSocket more than once”); 要搞清楚为什么会断开，是服务器的问题还是客户端的问题。 一般都是需要用心跳来维持的，直接置空确实是有闪退的危险的。 自定义了心跳机制，服务器会周期性的发心跳包，客户端收到心跳后，再把心跳发给服务器，服务器和客户端以此来判断是否处于链接状态，如果服务器在连续 3 个周期没有收到心跳包的话，可以认为客户端丢失，可以断开链接。 5、断网重连问题：在断网后 WebSocket 也会断开，然后用了一个监听网络状态的库，如果网络重新打开了，进行重连，但也会出现 NSAssert(_readyState == SR_CONNECTING, @”Cannot call -(void)open on SRWebSocket more than once”); WebSocket 记得是有重新连接的机制的。单独去监听的话，需要拿到之前那个连接，不然会出现这个错误。 SRWebSocket 有 didFailWithError 和 didCloseWithCode 的回调，可以在这两个回调里边进行重连。 6、还有一种情况，如果网络正常，服务器崩了，我应该怎么处理呢？是直接断开，还是定时重连呢？ 服务器崩了，应该先定时重连，尝试 3 次以后就断开。这样做才比较合理，QQ 和微信都是这么做。","tags":[]},{"title":" HTTPS 单向认证和双向认证\t\t","date":"2019-03-22T02:56:04.000Z","path":"2019/03/22/https-e5-8d-95-e5-90-91-e8-ae-a4-e8-af-81-e5-92-8c-e5-8f-8c-e5-90-91-e8-ae-a4-e8-af-81/","text":"原文：Https单向认证和双向认证 一、HttpHyperText Transfer Protocol 超文本传输协议，是互联网上使用最广泛的一种协议，所有 WWW 文件必须遵循的标准。HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。 使用 TCP 端口为：80 二、HttpsHyper Text Transfer Protocol over Secure Socket Layer 安全的超文本传输协议，网景公式设计了 SSL（Secure Sockets Layer） 协议用于对 Http 协议传输的数据进行加密，保证会话过程中的安全性。 使用 TCP 端口默认：443 三、SSL 协议加密方式SSL 协议既用到了对称加密也用到了非对称加密（公钥加密），在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL 对传输内容使用对称加密。 对称加密 速度高，可加密内容较大，用来加密会话过程中的消息 公钥加密 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥 四、单向认证Https 在建立 Socket 连接之前，需要进行握手，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。 服务器将选择好的加密方案通过明文方式返回给客户端 客户端接收到服务端返回的加密方式后，使用该加密方式生成随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。 在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。 五、双向认证双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下： 客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。 服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书 客户端使用服务端返回的信息验证服务器的合法性，包括： 证书是否过期 发行服务器证书的 CA 是否可靠 返回的公钥是否能正确解开返回证书中的数字签名 服务器证书上的域名是否和服务器的实际域名相匹配 验证通过后，将继续进行通信，否则，终止通信 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端 验证客户端的证书，通过验证后，会获得客户端的公钥 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式，将加密方案通过使用之前获取到的公钥进行加密，返回给客户端 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。","tags":[]},{"title":" pthread_rwlock_t\t\t","date":"2019-03-22T02:38:54.000Z","path":"2019/03/22/pthread-rwlock-t/","text":"百度百科 一、读写锁读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。 读操作可以共享，写操作是排他的，可以有多个在读（与 CPU 数相关），只能有唯一个在写，但不能同时既有读者又有写者。 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。 具有强读者同步和强写者同步两种形式： 强读者同步：当写者没有进行写操作，读者就可以访问； 强写者同步：当所有写者都写完之后，才能进行读操作。 在强写者情况，读者需要最新的信息，一些事实性较高的系统可能会用到该锁，比如定票之类的。 二、特性一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。 正因为这个特性，当读写锁是写加锁状态时，在这个锁被解锁之前, 所有试图对这个锁加锁的线程都会被阻塞。 当读写锁在读加锁状态时, 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是如果线程希望以写模式对此锁进行加锁，它必须直到所有的线程释放锁。 通常, 当读写锁处于读模式锁住状态时，如果有另外线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求长期阻塞. 读写锁适合于对数据结构的读次数比写次数多得多的情况。因为读模式锁定时可以共享，以写模式锁住时意味着独占，所以读写锁又叫共享-独占锁。 三、小结互斥锁与读写锁的区别： 当访问临界区资源时（访问的含义包括所有的操作：读和写），需要上互斥锁； 当对数据（互斥锁中的临界区资源）进行读取时，需要上读取锁，当对数据进行写入时，需要上写入锁。 读写锁的优点： 对于读数据比修改数据频繁的应用，用读写锁代替互斥锁可以提高效率。因为使用互斥锁时，即使是读出数据（相当于操作临界区资源）都要上互斥锁，而采用读写锁，则可以在任一时刻允许多个读者存在，提供了更高的并发度，同时在某个写入者修改数据期间保护该数据，以免任何其它读出者或写入者的干扰。 读写锁描述： 获取一个读写锁用于读称为共享锁，获取一个读写锁用于写称为独占锁，因此这种对于某个给定资源的共享访问也称为共享-独占上锁。 四、使用读写锁配置读写锁的属性之后，即可初始化读写锁。以下函数用于初始化或销毁读写锁、锁定或解除锁定读写锁或尝试锁定读写锁。 1、初始化读写锁 使用 pthread_rwlock_init(3C) 通过 attr 所引用的属性初始化 rwlock 所引用的读写锁。 /** * @param attr 如果为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同 * * @return 如果成功，返回 0，否则将返回用于指明错误的错误号。 EINVAL : attr 或者 rwlock 指定的值无效 /int pthread_rwlock_init(pthread_rwlock_t \\rwlock, const pthread_rwlockattr_t *attr); pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 如果 attr 为 NULL，则使用缺省的读写锁属性，其作用与传递缺省读写锁属性对象的地址相同。 初始化读写锁之后，该锁可以使用任意次数，而无需重新初始化。成功初始化之后，读写锁的状态会变为已初始化和未锁定。如果调用 pthread_rwlock_init() 来指定已初始化的读写锁，则结果是不确定的。如果读写锁在使用之前未初始化，则结果是不确定的。 如果缺省的读写锁属性适用，则 PTHREAD_RWLOCK_INITIALIZER 宏可初始化以静态方式分配的读写锁，其作用与通过调用pthread_rwlock_init() 并将参数 attr 指定为 NULL 进行动态初始化等效，区别在于不会执行错误检查。 如果 pthread_rwlock_init() 失败，将不会初始化 rwlock，并且 rwlock 的内容是不确定的。 2、获取读写锁中的读锁 pthread_rwlock_rdlock(3C) 可用来向 rwlock 所引用的读写锁应用读锁。 #include &lt;pthread.h&gt; /** * @return 如果成功，返回 0。否则，将返回用于指明错误的错误号。 EINVAL : attr 或 rwlock 指定的值无效 /int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); 如果写入器未持有读锁，并且没有任何写入器基于该锁阻塞，则调用线程会获取读锁。如果写入器未持有读锁，但有多个写入器正在等待该锁时，调用线程是否能获取该锁是不确定的。如果某个写入器持有读锁，则调用线程无法获取该锁。如果调用线程未获取读锁，则它将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_rdlock() 返回。如果在进行调用时，调用线程持有 rwlock 中的写锁，则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 一个线程可以在 rwlock 中持有多个并发的读锁，该线程可以成功调用 pthread_rwlock_rdlock() n 次。该线程必须调用 pthread_rwlock_unlock() n 次才能执行匹配的解除锁定操作。 如果针对未初始化的读写锁调用 pthread_rwlock_rdlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行读取，就好像线程未中断一样。 3、读取非阻塞读写锁中的锁 pthread_rwlock_tryrdlock(3C)应用读锁的方式与 pthread_rwlock_rdlock() 类似，区别在于如果任何线程持有 rwlock 中的写锁或者写入器基于 rwlock 阻塞，则 pthread_rwlock_tryrdlock() 函数会失败。 #include &lt;pthread.h&gt; /** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行读取的锁，返回 0。否则，返回用于指明错误的错误号 * * EBUSY : 无法获取读写锁以执行读取，因为写入器持有该锁或者基于该锁已阻塞 /int pthread_rwlock_tryrdlock(pthread_rwlock_t rwlock); 4、写入读写锁中的锁 pthread_rwlock_wrlock(3C) 可用来向 rwlock 所引用的读写锁应用写锁。 #include &lt;pthread.h&gt; /** * @return 如果获取了用于在 rwlock 所引用的读写锁对象中执行写入的锁，返回 0。否则，返回指明错误的错误号 /int pthread_rwlock_wrlock(pthread_rwlock_t rwlock); 如果没有其他读取器线程或写入器线程持有读写锁 rwlock，则调用线程将获取写锁，否则，调用线程将阻塞。调用线程必须获取该锁之后，才能从 pthread_rwlock_wrlock() 调用返回。如果在进行调用时，调用线程持有读写锁（读锁或写锁），则结果是不确定的。 为避免写入器资源匮乏，允许在多个实现中使写入器的优先级高于读取器。 如果针对未初始化的读写锁调用 pthread_rwlock_wrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 5、写入非阻塞读写锁中的锁 pthread_rwlock_trywrlock(3C)应用写锁的方式与 pthread_rwlock_wrlock() 类似，区别在于如果任何线程当前持有用于读取和写入的 rwlock，则pthread_rwlock_trywrlock() 函数会失败。 #include &lt;pthread.h&gt; /** * @return 如果获取了用于在 rwlock 引用的读写锁对象中执行写入的锁，则返回 0，否则，返回用于指明错误的错误号 * EBUSY : 无法为写入获取读写锁，因为已为读取或写入锁定该读写锁 /int pthread_rwlock_trywrlock(pthread_rwlock_t rwlock); 如果针对未初始化的读写锁调用 pthread_rwlock_trywrlock()，则结果是不确定的。 线程信号处理程序可以处理传送给等待读写锁以执行写入的线程的信号。从信号处理程序返回后，线程将继续等待读写锁以执行写入，就好像线程未中断一样。 6、解除锁定读写锁 pthread_rwlock_unlock(3C) 可用来释放在 rwlock 引用的读写锁对象中持有的锁。 #include &lt;pthread.h&gt; /** * @return 如果成功返回 0，否则返回用于指明错误的错误号 /int pthread_rwlock_unlock (pthread_rwlock_t rwlock); 如果调用线程未持有读写锁 rwlock，则结果是不确定的。 如果通过调用 pthread_rwlock_unlock() 来释放读写锁对象中的读锁，并且其他读锁当前由该锁对象持有，则该对象会保持读取锁定状态。如果 pthread_rwlock_unlock() 释放了调用线程在该读写锁对象中的最后一个读锁，则调用线程不再是该对象的属主。如果 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个读锁，则该读写锁对象将处于无属主、解除锁定状态。 如果通过调用 pthread_rwlock_unlock() 释放了该读写锁对象的最后一个写锁，则该读写锁对象将处于无属主、解除锁定状态。 如果 pthread_rwlock_unlock() 解除锁定该读写锁对象，并且多个线程正在等待获取该对象以执行写入，则通过调度策略可确定获取该对象以执行写入的线程。如果多个线程正在等待获取读写锁对象以执行读取，则通过调度策略可确定等待线程获取该对象以执行写入的顺序。如果多个线程基于 rwlock 中的读锁和写锁阻塞，则无法确定读取器和写入器谁先获得该锁。 如果针对未初始化的读写锁调用 pthread_rwlock_unlock()，则结果是不确定的。 7、销毁读写锁 pthread_rwlock_destroy(3C) 可用来销毁 rwlock 引用的读写锁对象并释放该锁使用的任何资源。 #include &lt;pthread.h&gt; /** * @return 如果成功，返回 0。否则，返回用于指明错误的错误号。EINVAL : attr 或者 rwlock 指定的值无效 /int pthread_rwlock_destroy(pthread_rwlock_t rwlock); pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; 再次调用 pthread_rwlock_init() 重新初始化该锁之前，使用该锁所产生的影响是不确定的。实现可能会导致 pthread_rwlock_destroy() 将 rwlock 所引用的对象设置为无效值。如果在任意线程持有 rwlock 时调用 pthread_rwlock_destroy()，则结果是不确定的。尝试销毁未初始化的读写锁会产生不确定的行为。已销毁的读写锁对象可以使用 pthread_rwlock_init() 来重新初始化。销毁读写锁对象之后，如果以其他方式引用该对象，则结果是不确定的。","tags":[]},{"title":" RAC 入门\t\t","date":"2019-03-21T14:48:23.000Z","path":"2019/03/21/rac/","text":"原文：了解这些，学习RAC不再难 ReactiveCocoa 是 github 开源的一个函数式响应式编程框架，是在 iOS 平台上对 FRP 的实现。FRP 的核心是信号，信号在 RAC 中是通过 RACSignal 来表示的，信号是数据流，可以被绑定和传递。主要吸取了 .Net 的 Reactive Extensions 的设计和实现。 函数式编程 Functional Programming、响应式编程 Reactive Programming。 一、作用在 iOS 开发过程中，当某些事件响应时需要处理某些业务逻辑，这些事件都用不同的方式来处理。比如按钮的点击使用 action，Scroll 滚动使用 delegate，属性值改变使用 KVO 等系统提供的方式。 其实这些事件，都可以通过 RAC 处理。ReactiveCocoa 为事件提供了很多处理方法，而且利用 RAC 处理事件很方便，可以把要处理的事情和监听事件的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合开发中高聚合、低耦合的思想。 ReactiveCocoa 主要解决了以下这些问题： UI 数据绑定 UI 控件通常需要绑定一个事件，RAC 可以很方便的绑定任何数据流到控件上。 用户交互事件绑定 RAC 为可交互的 UI 控件提供了一系列能发送 Signal 信号的方法。这些数据流会在用户交互中相互传递。 解决状态以及状态之间依赖过多的问题 有了 RAC 的绑定之后，可以不用再关心各种复杂的状态，isSelect，isFinish…也解决了这些状态在后期维护的问题。 消息传递机制的统一 OC 中编程原来消息传递机制有以下几种：Delegate、Block Callback、Target-Action、Timers、KVO，现在有了RAC 之后，以上这 5 种方式都可以统一用 RAC 来处理。objc 上有一篇关于 OC 中这 5 种消息传递方式该如何选择的文章Communication Patterns，推荐大家阅读。 使用 RAC 解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 ReactiveCocoa 比较复杂，在正式开始介绍它的核心组件前，我们先来看看它的类图，以便从宏观上了解它的层次结构： ReactiveCocoa 主要包含四个组件： 信号源：RACStream 及其子类； 订阅者：RACSubscriber 的实现类及其子类； 调度器：RACScheduler 及其子类； 清洁工：RACDisposable 及其子类。 而信号源是最核心的部分，其它所有组件都是围绕它运作的。 二、信号源信号分为冷信号与热信号，理解冷信号与热信号的区别，对于 RAC 的理解有非常大的帮助，所以这篇文章也重点讲解这里。 ①、Hot Observable 是主动的，尽管你并没有订阅事件，但是它会时刻推送；Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。 ②、Hot Observable 可以有多个订阅者，是一对多，集合可以与订阅者共享信息；Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。 在 RAC 中除了 RACSubject 及其子类是热信号外，其它都是冷信号。subject 类似“直播”，错过了就不再处理。而 signal 类似“点播”，每次订阅都会从头开始。所以我们有理由认定 subject 天然就是热信号。 Subject 具备如下三个特点： Subject 是“可变”的。 Subject 是非 RAC 到 RAC 的一个桥梁。 Subject 可以附加行为，例如 RACReplaySubject 具备为未来订阅者缓冲事件的能力。 为了了解热信号与冷信号的区别，用两段代码来展示一下： // 创建热信号 RACSubject *subject = \\[RACSubject subject\\]; // 立即发送 1 \\[subject sendNext:@1\\]; // 0.5 秒后发送 2 \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.5 schedule:^{ \\[subject sendNext:@2\\]; }\\]; // 2 秒后发送 3 \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:2 schedule:^{ \\[subject sendNext:@3\\]; }\\]; // 0.1秒后 subject1 订阅了 \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.1 schedule:^{ \\[subject subscribeNext:^(id x) { NSLog(@&quot;subject1接收到了%@&quot;,x); }\\]; }\\]; // 1 秒后 subject2 订阅了 \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:1 schedule:^{ \\[subject subscribeNext:^(id x) { NSLog(@&quot;subject2接收到了%@&quot;,x); }\\]; }\\]; // 创建冷信号 RACSignal \\*signal = \\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@1\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.5 schedule:^{ \\[subscriber sendNext:@2\\]; }\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:2 schedule:^{ \\[subscriber sendNext:@3\\]; }\\]; return nil; }\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.1 schedule:^{ \\[signal subscribeNext:^(id x) { NSLog(@&quot;signal1接收到了%@&quot;, x); }\\]; }\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:1 schedule:^{ \\[signal subscribeNext:^(id x) { NSLog(@&quot;signal2接收到了%@&quot;, x); }\\]; }\\]; 上面两段代码的输出 2018-02-20 11:02:24.980462+0800 RACTest[14912:16295891] subject1接收到了22018-02-20 11:02:26.480232+0800 RACTest[14912:16295891] subject1接收到了32018-02-20 11:02:26.480408+0800 RACTest[14912:16295891] subject2接收到了3 2018-02-20 11:20:53.952995+0800 RACTest[15075:16311621] signal1接收到了12018-02-20 11:20:54.456881+0800 RACTest[15075:16311621] signal1接收到了22018-02-20 11:20:54.457046+0800 RACTest[15075:16311621] signal2接收到了12018-02-20 11:20:54.853391+0800 RACTest[15075:16311621] signal2接收到了22018-02-20 11:20:55.356641+0800 RACTest[15075:16311621] signal1接收到了32018-02-20 11:20:55.356851+0800 RACTest[15075:16311621] signal2接收到了3 从输出中我们可以发现： 0.1 秒后订阅的 subject1 接收到了 0.5 秒后、2 秒后发送的信号，没有接收到立即发送的信号。 1 秒后订阅的 subject2 接收到了 2 秒后发送的信号，也没有接收到立即发送的信号。 signal1 和 signal2 都接收到了所有信号。 从中可以得出结论： 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。如上面没有接收到的信号都是因为在没有订阅者的时候，它也会推送出去。而冷信号是被动的，只有当你订阅的时候，它才会发送消息。如第二段代码，订阅后才把信号推送出去。 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。如第一段代码，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。 二、将冷信号转变为热信号RAC 库中对于冷信号转化成热信号有如下标准的封装： - (RACMulticastConnection )publish;- (RACMulticastConnection )multicast:(RACSubject )subject;- (RACSignal )replay;- (RACSignal )replayLast;- (RACSignal )replayLazily; 如上面的第一段代码，我们可以用如下来达到同样的效果： RACMulticastConnection \\*connection = \\[\\[RACSignal createSignal:^RACDisposable \\*(id&lt;RACSubscriber&gt; subscriber) { \\[subscriber sendNext:@1\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.5 schedule:^{ \\[subscriber sendNext:@2\\]; }\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:2 schedule:^{ \\[subscriber sendNext:@3\\]; }\\]; return nil; }\\] publish\\]; \\[connection connect\\]; RACSignal * signal = connection.signal; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:0.1 schedule:^{ \\[signal subscribeNext:^(id x) { NSLog(@&quot;这里是热信号1，接收到了%@&quot;, x); }\\]; }\\]; \\[\\[RACScheduler mainThreadScheduler\\] afterDelay:1 schedule:^{ \\[signal subscribeNext:^(id x) { NSLog(@&quot;这里是热信号2，接收到了%@&quot;, x); }\\]; }\\]; 2018-02-20 11:45:38.331464+0800 RACTest[15171:16331870] 这里是热信号1，接收到了22018-02-20 11:45:39.830300+0800 RACTest[15171:16331870] 这里是热信号1，接收到了32018-02-20 11:45:39.830870+0800 RACTest[15171:16331870] 这里是热信号2，接收到了3 可以看到，现在已经是热信号了，和前面的 RACSubject 相同。 - (RACMulticastConnection )multicast:(RACSubject )subject 是将冷信号转换为热信号的核心。其实它的本质就是使用一个 Subject 来订阅原始信号，并让其他订阅者订阅这个 Subject，这个 Subject 就是热信号。","tags":[]},{"title":" Premultiplied Alpha\t\t","date":"2019-03-20T15:23:57.000Z","path":"2019/03/20/premultiplied-alpha/","text":"Xcode 的工程选项里有一项 Compress PNG Files，会对 PNG 进行 Premultiplied Alpha。游戏开发中会更加关注这个格式，省一些运行时计算。 Premultiplied Alpha 是什么呢？ Alpha Blending: To Pre or Not To Pre 这篇文章其实说的很清楚。还有《Real Time Rendering》 一、Alpha Blending要搞清楚这个问题，先得理解 Alpha 通道的工作原理。 最常见的像素表示格式是 RGBA8888 即 （r, g, b, a），每个通道 8 位，0~255。例如红色 60% 透明度就是（255, 0, 0, 153），为了表示方便 alpha 通道一般记成正规化后的 0~1 的浮点数，也就是（255, 0, 0, 0.6）。而 Premultiplied Alpha 则是把 RGB 通道乘以透明度也就是（r a, g a, b * a, a），50% 透明红色就变成了（153, 0, 0, 0.6）。 透明通道在渲染的时候通过 Alpha Blending 产生作用，如果一个透明度为 as 的颜色 Cs 渲染到颜色 Cd 上，混合后的颜色通过以下公式计算： Co = asCs + (1−as)Cd 以 60% 透明的红色渲染到白色背景为例： Co = (255, 0, 0) * 0.6 + (255, 255, 255) *(1 − 0.6) = (255, 102, 102) 也就是说，从视觉上（255, 0, 0, 0.6）渲染到白色背景上和（255, 102, 102）是同一个颜色。如果颜色以 Premultiplied Alpha 形式存储，也就是 Cs 已经乘以透明度了，所以混合公式变成了： Co = Cs′ + (1−as)Cd 二、为什么要 Premultiplied Alpha？Premultiplied Alpha 后的像素格式变得不直观，因为在画图的时候都是先从调色板中选出一个 RGB 颜色，再单独设置透明度，如果 RGB 乘以透明度就搞不清楚原色是什么了。从前面的 Alpha Blending 公式可以看出，Premultiplied Alpha 之后，混合的时候可以少一次乘法，这可以提高一些效率，但这并不是最主要的原因。最主要的原因是： 没有 Premultiplied Alpha 的纹理无法进行 Texture Filtering（除非使用最近邻插值）。 以最常见的 filtering 方式线性插值为例，一个宽 2px 高 1px 的图片，左边的像素是红色，右边是绿色 10% 透明度，如果把这个图片缩放到 1x1 的大小，那么缩放后 1 像素的颜色就是左右两个像素线性插值的结果，也就是把两个像素各个通道加起来除以2。如果使用没有 Premultiplied Alpha 的颜色进行插值，那么结果就是： ((255, 0, 0, 1) + (0, 255, 0, 0.1)) * 0.5 = (127, 127, 0, 0.55) 如果绿色 Premultiplied Alpha，也就是（0, 255 * 0.1, 0, 0.1），和红色混合后： ((255, 0, 0, 1) + (0, 25, 0, 0.1)) * 0.5 = (127, 25, 0, 0.55) Premultiplied Alpha 最重要的意义是使得带透明度图片纹理可以正常的进行线性插值。这样旋转、缩放或者非整数的纹理坐标才能正常显示，否则就会像上面的例子一样，在透明像素边缘附近产生奇怪的颜色。 三、纹理处理我们使用的 PNG 图片纹理，一般是不会 Premultiplied Alpha 的。游戏引擎在载入 PNG 纹理后会手动处理，然后再 glTexImage2D 传给 GPU，比如 Cocos2D-x 中的 CCImage::premultipliedAlpha： void Image::premultipliedAlpha() { unsigned int fourBytes = (unsigned int)_data; for (int i = 0; i &lt; _width _height; i++) { unsigned char p = _data + i * 4; fourBytes[i] = CC_RGB_PREMULTIPLY_ALPHA(p[0], p[1], p[2], p[3]); } _hasPremultipliedAlpha = true;} 而 GPU 专用的纹理格式，比如 PVR、ETC 一般在生成纹理都是默认 Premultiplied Alpha 的，这些格式一般是 GPU 硬解码，引擎用 CPU 处理会很慢。 总之 glTexImage2D 传给 GPU 的纹理数据最好都是 Multiplied Alpha 的，要么在生成纹理时由纹理工具 Pre-multiplied，要么载入纹理后由游戏引擎或 UI 框架 Post-multiplied。 四、iOS 中的 Premultiplied AlphaCore Graphics 的 CGImage.h 对图像透明度信息有如下定义 typedef CF_ENUM(uint32_t, CGImageAlphaInfo){ // … /* For example, premultiplied RGBA / kCGImageAlphaPremultipliedLast, /\\ For example, premultiplied ARGB */ kCGImageAlphaPremultipliedFirst, // …}; 预乘透明度（Premultiplied Alpha）图像简单地说，即每个颜色分量都乘以 alpha 通道值作为结果值： color.rgb *= color.alpha 为什么关注预乘透明度图像？微信团队因 AR 抢红包场景的 OpenGL 混色结果出错引起注意。 Premultiplied alpha is better than conventional blending for several reasons: It works properly when filtering alpha cutouts (see below) It works properly when doing image composition (stay tuned for my next post) It is a superset of both conventional and additive blending. If you set alpha to zero while RGB is non zero, you get an additive blend. This can be handy for particle systems that want to smoothly transition from additive glowing sparks to dark pieces of soot as the particles age. It plays nice with DXT compression, which only supports transparent pixels with an RGB of zero. 摘自：Premultiplied alpha","tags":[]},{"title":" 组件化方案\t\t","date":"2019-03-20T09:06:37.000Z","path":"2019/03/20/e7-bb-84-e4-bb-b6-e5-8c-96-e6-96-b9-e6-a1-88/","text":"文章：iOS 组件化方案的几种实现、iOS 的组件化开发 大致讨论组件化的三种方案：url-block、protocol-class（和 url-controller 类似)、target-action，以及应用这三种组件化方案的时机、步骤、利弊等。 一、为什么需要组件化随着公司业务的不断发展，项目的功能越来越复杂，各个业务代码耦合越来越多，代码量急剧增加，传统的 MVC 或者 MVVM 架构已经无法高效的管理工程代码，因此需要用一种技术来更好地管理工程，而组件化是一种能够解决代码耦合的技术。项目经过组件化的拆分，不仅可以解决代码耦合的问题，还可以增强代码的复用性，工程的易管理性等。 二、什么时候做组件开发 项目管理：项目的业务线超过 2 条以上，需要独立拆分。随着业务的拆分，对应的业务组件也就很自然的独立出来。 人员管理：过多人对同一块代码的进行修改，产生 bug 的可能性上升，所以需要重新分配人员和其维护的功能。 测试维度：随着项目的业务量增大，很难做单元测试。每个小功能修改，都需要对 App 进行测试，严重增加测试工作量。 当 App 业务之间交叉耦合，bug 率难以下降，测试每天做大量重复工作。开发人员之间修改相互影响时，你需要考虑进行组件化。 组件化是项目架构层面的技术，不是所有项目都适合组件化，组件化一般针对的是大中型的项目，并且是多人开发。如果，项目比较小，开发人员比较少，确实不太适合组件化，因为这时的组件化可能带来的不是便捷，而是增加了开发的工作量。另外，组件化过程也要考虑团队的情况，总之，根据目前项目的情况作出最合适的技术选型。 三、组件化的过程1、url-block 这是蘑菇街中使用的一种页面间调用的方式，通过在启动时注册组件提供的服务，把调用组件使用的 url 和组件提供的服务 block 对应起来，保存到内存中。在使用组件的服务时，通过 url 找到对应的 block，然后获取服务。 url-block 的架构图： 注册： [MGJRouter registerURLPattern:@”mgj://detail?id=:id” toHandler:^(NSDictionary routerParameters) { NSNumber id = routerParameters[@”id”]; // create view controller with id. push view controller}]; 调用： [MGJRouter openURL:@”mgj://detail?id=404”] 蘑菇街为了统一 iOS 和 Android 的平台差异性，专门用后台来管理 url，然后针对不同的平台生成不同类型的文件。 使用 url-block 的方案的确可以组件间解耦，但是还是存在其它明显的问题，比如： 需要在内存中维护 url-block 的表，组件多了可能会有内存问题； url 的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如 UIImage、NSData 等类型； 没有区分本地调用和远程调用的情况，尤其是远程调用会因为 url 参数受限，导致一些功能受限； 组件本身依赖了中间件，且分散注册使的耦合较多 2、protocol-class 针对方案 1 的问题，蘑菇街又提出了另一种组件化的方案，就是通过 protocol 定义服务接口，组件通过实现该接口来提供接口定义的服务，具体实现就是把 protocol 和 class 做一个映射，同时在内存中保存一张映射表，使用的时就通过 protocol 找到对应的 class 来获取需要的服务。 protocol-class 的架构图： 注册： [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 调用： [ModuleManager classForProtocol:ProtocolA] 蘑菇街的这种方案确实解决了方案 1 中无法传递非常规参数的问题，使得组件间的调用更为方便，但是它依然没有解决组件依赖中间件、内存中维护映射表、组件的分散调用的问题。设计思想和方案 1 类似，都是通过给组件加了一层 wrapper，然后给使用者调用。 3、url-controller 这是 LDBusMediator 的组件化方案。它是通过组件实现公共协议的接口，来对外提供服务。 具体就是通过单例来维护 url-controller 的映射关系表，根据调用者的 url，以及提供的参数（字典类型，所以参数类型不受约束）来返回对应的 controller 来提供服务；同时，为了增强组件提供服务的多样性，又通过服务协议定义了其它的服务。整体来看，LDBusMediator 解决了蘑菇街的这两种组件化方案的不足，比如：通过注册封装件 connector 而不是 block 来降低了内存占用；通过字典传递参数，解决了 url 参数的限制性。但是，由于使用了 connector 来提供服务而不是组件本身，把 connector 作为组件的一部分，依然有组件依赖中间件的问题。 LDBusMediator 的架构图： 4、target-action target-action 的方案是通过给组件包装一层 wrapper 来给外界提供服务，然后调用者通过依赖中间件来使用服务；其中，中间件是通过 runtime 来调用组件的服务，是真正意义上的解耦，也是该方案最核心的地方。具体实施过程是给组件封装一层 target 对象来对外提供服务，不会对原来组件造成入侵；然后，通过实现中间件的 category 来提供服务给调用者，这样使用者只需要依赖中间件，而组件则不需要依赖中间件。 target-action 的架构图： - (UIViewController *)CTMediator_viewControllerForDetail{ return [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@{ @”key” : @”value” } shouldCacheTarget:NO];} 但是 target-action 方案有个问题就是在中间件的 category 里有 hardcode，casa 的解释是在组件间调用时，最好是去 model 化，所以不可避免的引入了 hardcode，并且所有的 hardcode 只存在于分类中。 针对这个问题，有人提议把所有的 model 做成组件化下沉，然后让所有的组件都可以自由的访问 model。这种方案虽然解决了组件间传递 model 的依赖问题，但是为了解决这个问题，直接把整个 model 层组件化后暴露给所有组件，容易造成数据泄露，付出的代价有点大。 针对这个问题，经过和网友讨论，一致觉得组件间调用时用字典传递数据，组件内调用时用 model 传递数据，这样既减少组件间数据对 model 的耦合，又方便了组件内使用 model 传递数据的便捷性。 - (UIViewController )CTMediator_viewControllerForDetail:(NSDictionary )dict{ return [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:dict shouldCacheTarget:NO];} hardCode ①、官方解释：将可变变量用一个固定值来代替的方法。用这种方法编译后，如果以后需要更改此变量就非常困难了。 ②、hard code 是指“硬编码”，即将数据直接写在代码中。也就是，在程序中直接给变量赋值。指的是在软件实现上，把输出或输入的相关参数（例如：路径、输出的形式、格式）直接硬编码在源代码中，而非在运行时期由外界指定的设置、资源、数据、或者格式做出适当回应。 ③、hard code 的双重性： a. 直接将数据填写在源代码中，数据发生变化时，并不利于数据的修改，会造成程序的质量降低； b. 保护一些数据，直接赋值，避免其发生变化。 四、组件化实施的方式组件化可以利用 git 的源代码管理工具的便利性来实施，具体就是建立一个项目工程的私有化仓库，然后把各个组件的 podspec 上传到私有仓库，在需要用到组件时，直接从仓库里面取。 1、壳工程 main AppDelegate 工程配置 Debug 页面 2、封装公共库和基础 UI 库 在具体的项目开发过程中，我们常会用到三方库和自己封装的 UI 库，我们可以把这些库封装成组件，然后在项目里用 pod 进行管理。其中，针对三方库，最好再封装一层，使我们的项目部直接依赖三方库，方便后续开发过程中的更换。 3、独立业务模块化 在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。 3、服务接口最小化 在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。这时，就可以选择具体应用哪种组件化方案来实施组件化了。 公共组件： 埋点组件 Common 组件（聚合工具类） 启动组件 性能监控组件 定位组件 图片处理组件 UIKit 封装和扩展组件 业务生命周期及通信组件 网络组件： 基于 AFNetworking 进行封装，提供 JSON 转 Model、缓存功能 DNS 加速组件 持久化组件 基于 FMDB 进行封装组件 第三方业务组件 分享组件 推送组件 基础业务组件 User 组件，保存用户信息，登陆，登出状态","tags":[]},{"title":" 图片的解压缩、渲染\t\t","date":"2019-03-20T01:57:12.000Z","path":"2019/03/20/e5-9b-be-e7-89-87-e7-9a-84-e8-a7-a3-e5-8e-8b-e7-bc-a9-e3-80-81-e6-b8-b2-e6-9f-93/","text":"文章：探讨 iOS 中图片的解压缩到渲染过程、SDWebImage、YYImage 一、图像从文件到屏幕过程首先明确两个概念：水平同步信号、垂直同步信号。 CRT 的电子枪按照上图中的方式，从上到下一行一行的扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次的扫描。当电子枪切换到新的一行准备扫描时，显示器会发送一个水平同步信号（Horizonal Synchronization），简称HSync；完成一帧画面绘制后，电子枪会回到原位，显示器会发送一个垂直同步信号（Vertical Synchronization），简称VSync。 CPU/GPU 等在这样一次渲染过程中的具体分工： CPU：计算视图 frame、图片解码、需要绘制纹理图片通过数据总线交给 GPU GPU：纹理混合、顶点变换与计算、像素点的填充计算、渲染到帧缓冲区 时钟信号：垂直同步信号 V-Sync / 水平同步信号 H-Sync iOS 设备双缓冲机制：显示系统通常会引入两个帧缓冲区，双缓冲机制 CUP 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，之后视频控制器按照 VSync 信号逐行读取帧缓冲区中的数据，最后经过各种数模转换传递给显示器显示。通常计算机显示图片到屏幕是 CPU 与 GPU 协同合作完成一次渲染。 对应用来说，图片是最占用手机内存的资源，将一张图片从磁盘中加载出来，并最终显示到屏幕上，中间经过了一系列复杂的处理过程。 二、图片加载的工作流程 假设使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩； 然后将生成的 UIImage 赋值给 UIImageView； 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 在主线程的下一个 runloop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤： 分配内存缓冲区用于管理文件 IO 和解压缩操作； 将文件数据从磁盘读到内存中； 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作； 最后 Core Animation 中 CALayer 使用未压缩的位图数据渲染 UIImageView 的图层。 CPU 计算好图片的 Frame，对图片解压之后就会交给 GPU 来做图片渲染 渲染流程 GPU 获取获取图片的坐标 将坐标交给顶点着色器（顶点计算） 将图片光栅化（获取图片对应屏幕上的像素点） 片元着色器计算（计算每个像素点的最终显示的颜色值） 从帧缓存区中渲染到屏幕上 图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。 三、为什么要解压缩图片既然图片的解压缩需要消耗大量的 CPU 时间，那么是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。 位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。 NSString * filePath = \\[\\[NSBundle mainBundle\\] pathForResource:@&quot;Large&quot; ofType:@&quot;png&quot;\\]; UIImage * image = \\[UIImage imageWithContentsOfFile:filePath\\]; CFDataRef rawData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage)); &lt;00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00007c54 540a540a 540a540a 540a540a 7c000000 00000000 250a5454 0a540a54 0a540a0f 00000000 2554540a 540a540a 540a540a 540a5459 0000258c 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f2f2f2f 2f8c0101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010170 13131313 13131313 13131313 13131313 13131313 13131301 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 16161616 16161616 16161670 70701616 70137070 70707070 70131313 13131313 13131313 13131370 70161616 01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101 010101a2 03032525 00007c54 540a540a 540a540a 543f0000 00000000 00000000 00000000 00000000 5254540a 540a540a 540a540a 547c0000 00000000 00000000 0000000a 54540a54 0a540a54 0a520000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 0000283d 48074848 事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片： // return image as PNG. May return nil if image has no CGImageRef or invalid bitmap formatUIKIT_EXTERN NSData __nullable UIImagePNGRepresentation(UIImage __nonnull image); // return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)UIKIT_EXTERN NSData __nullable UIImageJPEGRepresentation(UIImage __nonnull image, CGFloat compressionQuality); 在磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么要对图片解压缩。 四、解压缩原理既然图片的解压缩不可避免，又不想让它在主线程执行，影响应用的响应性，那么是否有比较好的解决方案呢？ 前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。 强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是： /** * data : 如果不为 NULL，它应该指向一块大小至少为 bytesPerRow height 字节的内存；如果为 NULL，系统会自动分配和释放所需的内存 \\ * width : 位图的宽度。传入图片的像素宽度即可 * height : 位图的高度。传入图片的像素高度即可 * * bitsPerComponent : 像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可 * * bytesPerRow : 位图的每一行使用的字节数，大小至少为 width bytes per pixel 字节。 当指定 0/NULL 时，系统不仅会自动计算，而且还会进行 cache line alignment 的优化。 \\ * space : 颜色空间，一般使用 RGB * bitmapInfo : 位图的布局信息。kCGImageAlphaPremultipliedFirst /CG_EXTERN CGContextRef __nullable CGBitmapContextCreate( void __nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 五、YYImage\\SDWebImage 开源框架实现YYImage 用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 YYImageCoder 类中，核心代码： CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay){ … if (decodeForDisplay) { // decode with redraw (may lose some precision) CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } // BGRA8888 (premultiplied) or BGRX8888 // same as UIGraphicsBeginImageContext() and -\\[UIView drawRect:\\] CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; CGContextRef context = CGBitmapContextCreate( NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo); if (!context) return NULL; // decode CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef newImage = CGBitmapContextCreateImage(context); CFRelease(context); return newImage; } else { ... } } 它接受一个原始的位图参数 imageRef ，最终返回一个解压缩后的位图 newImage ，中间主要经过了以下三个步骤： 使用 CGBitmapContextCreate 函数创建一个位图上下文； 使用 CGContextDrawImage 函数将原始位图绘制到上下文中； 使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。 事实上，SDWebImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别。 性能对比： 解压 PNG 图片 SDWebImage &gt; YYImage 解压 JPEG 图片 SDWebImage &lt; YYImage 六、总结①、图片文件只有在确认要显示时 CPU 才会对其进行解压缩，因为解压非常消耗性能。解压过的图片就不会重复解压，会缓存。 ②、图片渲染到屏幕的过程： 读取文件 -> 计算 Frame -&gt; CPU 图片解码 -> 解码后纹理图片位图数据通过数据总线交给 GPU -&gt; GPU 获取图片 Frame -&gt; 顶点变换计算 -> 光栅化 -> 根据纹理坐标获取每个像素点的颜色值（如果出现透明值需要将每个像素点的颜色*透明度值） -> 渲染到帧缓存区 -> 渲染到屏幕 ③、细究离屏渲染和渲染中的细节处理，就需要掌握 OpenGL ES/Metal 这 2 个图形处理 API。","tags":[]},{"title":" NSOperation、NSOperationQueue\t\t","date":"2019-03-19T11:09:14.000Z","path":"2019/03/19/nsoperation-e3-80-81nsoperationqueue/","text":"原文：iOS 多线程：『NSOperation、NSOperationQueue』详尽总结 一、NSOperation 和 NSOperationQueue 简介NSOperation、NSOperationQueue 是苹果提供给开发者使用的一套多线程解决方案。实际上是基于 GCD 的更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。 为什么要使用 NSOperation、NSOperationQueue？ 添加在操作完成后执行的代码； 添加操作之间的依赖关系，方便的控制执行顺序； 设定操作执行的优先级； 可以很方便的取消一个操作的执行。 使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 二、NSOperation 和 NSOperationQueue 操作和操作队列GCD 的一些概念同样适用于 NSOperation、NSOperationQueue，也有类似的任务（操作）和队列（操作队列）的概念。 操作（Operation） 在 GCD 中，任务是放在 block 里的。在 NSOperation 中，使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation 或者自定义子类来封装操作。 操作队列（Operation Queues） 即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 三、NSOperation 和 NSOperationQueue 使用步骤NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时是同步执行操作，配合 NSOperationQueue 能更好的实现异步执行。NSOperation 实现多线程的使用步骤分为三步： 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 创建队列：创建 NSOperationQueue 对象。 将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 四、NSOperation 和 NSOperationQueue 基本使用1、创建操作 NSOperation 是个抽象类，不能用来封装操作。只有使用它的子类来封装操作，有三种方式来封装操作。 使用子类 NSInvocationOperation 使用子类 NSBlockOperation 自定义继承于 NSOperation 的子类，通过实现内部相应的方法来封装操作。 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下是同步执行操作。 NSInvocationOperation - (void)useInvocationOperation{ NSInvocationOperation * operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil]; [operation start];} - (void)task{ for (int i = 0; i &lt; 2; i++) { NSLog(@”%@”, [NSThread currentThread]); }} 2019-03-19 18:03:18.840607+0800 Demo[46957:3117389] &lt;NSThread: 0x600001ffd400&gt;{number = 1, name = main}2019-03-19 18:03:20.842158+0800 Demo[46957:3117389] &lt;NSThread: 0x600001ffd400&gt;{number = 1, name = main} 在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，没有开启新线程。 \\[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil\\]; 2019-03-19 18:06:22.667818+0800 Demo[46995:3119165] &lt;NSThread: 0x6000025e4b40&gt;{number = 3, name = (null)}2019-03-19 18:06:22.668057+0800 Demo[46995:3119165] &lt;NSThread: 0x6000025e4b40&gt;{number = 3, name = (null)} 在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。 NSBlockOperation - (void)useBlockOperation{ NSBlockOperation * operation = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@”%@”, [NSThread currentThread]); } }]; \\[operation start\\]; } 2019-03-19 18:09:56.666612+0800 Demo[47047:3121571] &lt;NSThread: 0x600003222940&gt;{number = 1, name = main}2019-03-19 18:09:56.666754+0800 Demo[47047:3121571] &lt;NSThread: 0x600003222940&gt;{number = 1, name = main} 在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中并发执行。只有当所有相关的操作已经完成执行时，才视为完成。如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在非当前线程执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。 - (void)useBlockOperationAddExecutionBlock{ NSBlockOperation * op = [NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@”1---%@”, [NSThread currentThread]); } }]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;2---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;3---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;4---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;5---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;6---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;7---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;8---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op start\\]; } 2019-03-19 18:14:55.099519+0800 Demo[47115:3124684] 2—&lt;NSThread: 0x600002d51f80&gt;{number = 4, name = (null)}2019-03-19 18:14:55.099548+0800 Demo[47115:3124683] 3—&lt;NSThread: 0x600002d5cb00&gt;{number = 5, name = (null)}2019-03-19 18:14:55.099549+0800 Demo[47115:3124621] 4—&lt;NSThread: 0x600002d3e880&gt;{number = 1, name = main}2019-03-19 18:14:55.099555+0800 Demo[47115:3124682] 1—&lt;NSThread: 0x600002d51f40&gt;{number = 3, name = (null)}2019-03-19 18:14:55.099717+0800 Demo[47115:3124621] 4—&lt;NSThread: 0x600002d3e880&gt;{number = 1, name = main}2019-03-19 18:14:55.099720+0800 Demo[47115:3124684] 2—&lt;NSThread: 0x600002d51f80&gt;{number = 4, name = (null)}2019-03-19 18:14:55.099730+0800 Demo[47115:3124682] 1—&lt;NSThread: 0x600002d51f40&gt;{number = 3, name = (null)}2019-03-19 18:14:55.099735+0800 Demo[47115:3124683] 3—&lt;NSThread: 0x600002d5cb00&gt;{number = 5, name = (null)}2019-03-19 18:14:55.099873+0800 Demo[47115:3124684] 5—&lt;NSThread: 0x600002d51f80&gt;{number = 4, name = (null)}2019-03-19 18:14:55.099873+0800 Demo[47115:3124682] 6—&lt;NSThread: 0x600002d51f40&gt;{number = 3, name = (null)}2019-03-19 18:14:55.099878+0800 Demo[47115:3124683] 7—&lt;NSThread: 0x600002d5cb00&gt;{number = 5, name = (null)}2019-03-19 18:14:55.100183+0800 Demo[47115:3124621] 8—&lt;NSThread: 0x600002d3e880&gt;{number = 1, name = main}2019-03-19 18:14:55.100414+0800 Demo[47115:3124684] 5—&lt;NSThread: 0x600002d51f80&gt;{number = 4, name = (null)}2019-03-19 18:14:55.100590+0800 Demo[47115:3124682] 6—&lt;NSThread: 0x600002d51f40&gt;{number = 3, name = (null)}2019-03-19 18:14:55.100763+0800 Demo[47115:3124683] 7—&lt;NSThread: 0x600002d5cb00&gt;{number = 5, name = (null)}2019-03-19 18:14:55.100968+0800 Demo[47115:3124621] 8—&lt;NSThread: 0x600002d3e880&gt;{number = 1, name = main} 使用 NSBlockOperation 并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock: 方法中的操作和 addExecutionBlock: 中的操作是在不同的线程中异步执行的，包括主线程一共有 4 个线程。而且，这次执行结果中 blockOperationWithBlock: 方法中的操作也不是在当前线程（主线程）中执行的。 一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线 程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 自定义继承自 NSOperation 的子类 如果 NSInvocationOperation、NSBlockOperation 不能满足日常需求，可以自定义继承于 NSOperation 的子类。 可以通过重写 main 或者 start 方法来定义自己的 NSOperation 对象。重写 main 方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。 先定义一个继承自 NSOperation 的子类，重写 main 方法。 #import &lt;Foundation/Foundation.h&gt; @interface MyOperation : NSOperation@end @implementation MyOperation - (void)main{ if (!self.isCancelled) { for (int i = 0; i &lt; 2; i++) { NSLog(@”%@”, [NSThread currentThread]); } }} @end { [[[MyOperation alloc] init] start];}2019-03-19 18:25:22.022105+0800 Demo[47221:3129776] &lt;NSThread: 0x600003486940&gt;{number = 1, name = main}2019-03-19 18:25:22.022289+0800 Demo[47221:3129776] &lt;NSThread: 0x600003486940&gt;{number = 1, name = main} 在主线程单独使用自定义继承于 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。 2、创建队列 NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列 除使用 addExecutionBlock: 添加的额外操作外，凡是添加到主队列中的操作都会放到主线程中执行。 NSOperationQueue * queue = [NSOperationQueue mainQueue]; 自定义队列（非主队列） 添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; 3、将操作加入到队列 NSOperation 需要配合 NSOperationQueue 来实现多线程。那么我们需要将创建好的操作加入到队列。总共有两种方法： /** * 使用 addOperation: 将操作加入到操作队列中 */- (void)addOperationToQueue{ // 1.创建队列 NSOperationQueue * queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSInvocationOperation * op1 = \\[\\[NSInvocationOperation alloc\\] initWithTarget:self selector:@selector(task1) object:nil\\]; NSInvocationOperation * op2 = \\[\\[NSInvocationOperation alloc\\] initWithTarget:self selector:@selector(task2) object:nil\\]; NSBlockOperation * op3 = \\[NSBlockOperation blockOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;3---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[op3 addExecutionBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;4---%@&quot;, \\[NSThread currentThread\\]); } }\\]; // 3.添加 \\[queue addOperation:op1\\]; // \\[op1 start\\] \\[queue addOperation:op2\\]; // \\[op2 start\\] \\[queue addOperation:op3\\]; // \\[op3 start\\] } - (void)task1{ for (int i = 0; i &lt; 2; i++) { NSLog(@”1---%@”, [NSThread currentThread]); }} - (void)task2{ for (int i = 0; i &lt; 2; i++) { NSLog(@”2---%@”, [NSThread currentThread]); }} 2019-03-19 18:34:24.016396+0800 Demo[47313:3134164] 3—&lt;NSThread: 0x6000000d2840&gt;{number = 5, name = (null)}2019-03-19 18:34:24.016394+0800 Demo[47313:3134163] 2—&lt;NSThread: 0x6000000d2800&gt;{number = 3, name = (null)}2019-03-19 18:34:24.016400+0800 Demo[47313:3134165] 4—&lt;NSThread: 0x6000000da480&gt;{number = 6, name = (null)}2019-03-19 18:34:24.016423+0800 Demo[47313:3134162] 1—&lt;NSThread: 0x6000000da3c0&gt;{number = 4, name = (null)}2019-03-19 18:34:24.016590+0800 Demo[47313:3134164] 3—&lt;NSThread: 0x6000000d2840&gt;{number = 5, name = (null)}2019-03-19 18:34:24.016609+0800 Demo[47313:3134163] 2—&lt;NSThread: 0x6000000d2800&gt;{number = 3, name = (null)}2019-03-19 18:34:24.016620+0800 Demo[47313:3134165] 4—&lt;NSThread: 0x6000000da480&gt;{number = 6, name = (null)}2019-03-19 18:34:24.016624+0800 Demo[47313:3134162] 1—&lt;NSThread: 0x6000000da3c0&gt;{number = 4, name = (null)} 使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。 /** * 使用 addOperationWithBlock: 将操作加入到操作队列中 */- (void)addOperationWithBlockToQueue{ // 1. 创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2\\. 添加 \\[queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;1---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;2---%@&quot;, \\[NSThread currentThread\\]); } }\\]; \\[queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;3---%@&quot;, \\[NSThread currentThread\\]); } }\\]; } 2019-03-19 18:36:28.275696+0800 Demo[47351:3135582] 1—&lt;NSThread: 0x600002d0df40&gt;{number = 5, name = (null)}2019-03-19 18:36:28.275818+0800 Demo[47351:3135583] 2—&lt;NSThread: 0x600002d0df00&gt;{number = 3, name = (null)}2019-03-19 18:36:28.275846+0800 Demo[47351:3135581] 3—&lt;NSThread: 0x600002d06440&gt;{number = 4, name = (null)}2019-03-19 18:36:28.275899+0800 Demo[47351:3135582] 1—&lt;NSThread: 0x600002d0df40&gt;{number = 5, name = (null)}2019-03-19 18:36:28.275973+0800 Demo[47351:3135583] 2—&lt;NSThread: 0x600002d0df00&gt;{number = 3, name = (null)}2019-03-19 18:36:28.275977+0800 Demo[47351:3135581] 3—&lt;NSThread: 0x600002d06440&gt;{number = 4, name = (null)} 使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。 五、NSOperationQueue 控制串行执行、并发执行NSOperationQueue 有个关键属性 maxConcurrentOperationCount 叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 maxConcurrentOperationCount 默认情况下为 -1 表示不进行限制，可进行并发执行。= 1 为串行队列；> 1 为并发队列。 当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 MIN{ 自定的值，系统默认最大值 }。 六、NSOperation 操作依赖NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。 通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了 3 个接口供开发者管理和查看依赖。 - (void)addDependency:(NSOperation )op; // 添加依赖，使当前操作依赖于操作 op 的完成- (void)removeDependency:(NSOperation )op; // 移除依赖，取消当前操作对操作 op 的依赖 @property (readonly, copy) NSArray *dependencies; // 在当前操作开始执行之前完成执行的所有操作对象数组 有 A、B 两个操作，A 执行完操作，B 才能执行操作。如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。 // op2 依赖于 op1。先执行 op1，再执行 op2 [op2 addDependency:op1]; 七、NSOperation 优先级queuePriority 属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是 NSOperationQueuePriorityNormal。但是我们可以通过 setQueuePriority: 方法来改变当前操作在同一队列中的执行优先级。 // 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) { NSOperationQueuePriorityVeryLow = -8L, NSOperationQueuePriorityLow = -4L, NSOperationQueuePriorityNormal = 0, NSOperationQueuePriorityHigh = 4, NSOperationQueuePriorityVeryHigh = 8}; 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序由操作之间相对的优先级决定。那么，什么样的操作才是进入就绪状态的操作呢？ 当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。 举个例子，现在有 4 个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1、op2、op3、op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3-&gt;op2-&gt;op1。现在将这 4 个操作添加到队列中并发执行。 因为 op1 和 op4 都没有需要依赖的操作，所以在 op1、op4 执行之前，就是处于准备就绪状态的操作。 而 op3 和 op2 都有依赖的操作，所以 op3 和 op2 都不是准备就绪状态下的操作。 理解了进入就绪状态的操作，那么就理解了queuePriority 属性的作用对象。 queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。 如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。如果 op1 和 op4 是不同优先级的操作，那么就会先执行两者中优先级高的操作。 如果一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。 八、NSOperation 和 NSOperationQueue 线程间的通信/** * 线程间通信 */- (void)communication{ // 1\\. 创建队列 NSOperationQueue *queue = \\[\\[NSOperationQueue alloc\\]init\\]; // 2\\. 添加操作 \\[queue addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;1---%@&quot;, \\[NSThread currentThread\\]); } // 回到主线程 \\[\\[NSOperationQueue mainQueue\\] addOperationWithBlock:^{ for (int i = 0; i &lt; 2; i++) { NSLog(@&quot;2---%@&quot;, \\[NSThread currentThread\\]); } }\\]; }\\]; } 2019-03-19 18:58:11.699590+0800 Demo[47501:3143587] 1—&lt;NSThread: 0x600003c44c40&gt;{number = 3, name = (null)}2019-03-19 18:58:11.699836+0800 Demo[47501:3143587] 1—&lt;NSThread: 0x600003c44c40&gt;{number = 3, name = (null)}2019-03-19 18:58:11.705709+0800 Demo[47501:3143542] 2—&lt;NSThread: 0x600003c1d400&gt;{number = 1, name = main}2019-03-19 18:58:11.706378+0800 Demo[47501:3143542] 2—&lt;NSThread: 0x600003c1d400&gt;{number = 1, name = main} 通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。 九、NSOperation 和 NSOperationQueue 线程同步和线程安全线程安全 线程可能会同时运行一段代码，如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步 线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 十、NSOperation 和 NSOperationQueue 常用属性和方法归纳/** * NSOperation */- (void)cancel; // 取消操作，实质是标记 isCancelled 状态。- (void)waitUntilFinished; // 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。- (void)setCompletionBlock:(void (^)(void))block; // 会在当前操作执行完毕时执行 block。取消/暂停/恢复操作- (void)cancelAllOperations; 可以取消队列的所有操作。 /** * NSOperationQueue */- (void)waitUntilAllOperationsAreFinished; // 阻塞当前线程，直到队列中的操作全部执行完毕。- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; // 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 这里的暂停和取消（操作和队列）并不代表可以将当前的操作立即取消，而是在当前的操作执行完毕之后不再执行新的操作。 暂停和取消的区别：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法继续执行。 十一、参考资料苹果官方–并发编程指南：Operation Queues 苹果官方文档：NSOperation Objc 中国：并发编程：API 及挑战","tags":[]},{"title":" GCD 深入\t\t","date":"2019-03-19T09:34:10.000Z","path":"2019/03/19/deep-gcd/","text":"原文：深入理解 GCD、GCD 源码 一、知识储备阅读 GCD 源码之前，需要了解一些相关知识。 1、DISPATCH_DECL GCD 中对变量的定义大多遵循如下格式: #define DISPATCH_DECL(name) typedef struct name##_s *name##_t 如 DISPATCH_DECL(dispatch_queue); 的展开形式是：typedef struct dispatch_queue_s *dispatch_queue_t; 这行代码定义了一个 dispatch_queue_t 类型的指针，指向一个 dispatch_queue_s 类型的结构体。 2、TSD TSD（Thread-Specific Data）表示线程私有数据。在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。在不同线程中，虽然名字相同，但是获取到的数据随线程不同而不同。通常我们可以利用 POSIX 库提供的 API 来实现 TSD： int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *)) 此函数用来创建一个 key，在线程退出时会将 key 对应的数据传入 destr_function 函数中进行清理。我们分别使用 get/set 方法来访问/修改 key 对应的数据： int pthread_setspecific(pthread_key_t key, const void *pointer) void * pthread_getspecific(pthread_key_t key) 在 GCD 中定义了六个 key，根据名字大概能猜出各自的含义： pthread_key_t dispatch_queue_key;pthread_key_t dispatch_sema4_key;pthread_key_t dispatch_cache_key;pthread_key_t dispatch_io_key;pthread_key_t dispatch_apply_key;pthread_key_t dispatch_bcounter_key; 3、fastpath &amp;&amp; slowpath 这是定义在 internal.h 中的两个宏： #define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l)) #define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l)) 为了理解所谓的快路径和慢路径，需要先学习一点计算机基础知识。比如这段非常简单的代码： if (x) return 1;else return 39; 由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是： if (!x) return 39;else return 1; 然而对程序员来说，每次都做这样的判断非常烧脑，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect： long __builtin_expect (long EXP, long C) 它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写： if (__builtin_expect(x, 0)) return 1;else return 39; 虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。 二、dispatch_queue_t以 dispatch_queue_create 的源码为例： dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) { // 省略 label 相关的操作 dispatch\\_queue\\_t dq; dq = \\_dispatch\\_alloc(DISPATCH_VTABLE(queue), sizeof(struct dispatch\\_queue\\_s) - DISPATCH\\_QUEUE\\_MIN\\_LABEL\\_SIZE - DISPATCH\\_QUEUE\\_CACHELINE\\_PAD + label\\_len + 1); \\_dispatch\\_queue_init(dq); if (fastpath(!attr)) { return dq; } if (fastpath(attr == DISPATCH\\_QUEUE\\_CONCURRENT)) { dq-&gt;dq\\_width = UINT32\\_MAX; dq-&gt;do\\_targetq = \\_dispatch\\_get\\_root_queue(0, false); } else { dispatch\\_debug\\_assert(!attr, &quot;Invalid attribute&quot;); } return dq; } 我们知道创建队列时， attr 属性有三个值可选，nil、DISPATCH_QUEUE_SERIAL（实际上就是 nil）或 DISPATCH_QUEUE_CONCURRENT。 第一个 if 判断中，苹果认为串行队列或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。 第二个判断中，参数几乎只可能是 DISPATCH_QUEUE_CONCURRENT，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断几乎不会为 0，依然与 fastpath 的作用一致。 _dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载（overcommit）。这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务（比如下文介绍的定时器），3 这个序列号暂时没有使用。队列 的 dq_width 被设置为 UINT32_MAX，表示这些队列不限制并发数。作为对比，在 _dispatch_queue_init 中，并发数限制为 1，也就是串行队列的默认设置： static inline void _dispatch_queue_init(dispatch_queue_t dq) { dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS; dq-&gt;do_targetq = _dispatch_get_root_queue(0, true); dq-&gt;dq_running = 0; dq-&gt;dq_width = 1;} 注意这行代码：dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);，它涉及到 GCD 队列与 block 的一个重要模型，target_queue。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。借用 objc 的文章 中的图片来表示： 二、dispatch_async直接上函数实现： dispatch_async(dispatch_queue_t queue, dispatch_block_t block) { dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);} 队列其实就是一个用来提交 block 的对象，当 block 提交到队列中后，将按照 “先入先出（FIFO）” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。block 参数的类型是 dispatch_block_t，它是一个没有参数，没有返回值的 block： typedef void (^dispatch_block_t)(void); dispatch_async 的函数很简单，它将 block 复制了一份，然后调用另一个函数 dispatch_async_f： dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work); work 参数是一个函数，在实际调用时，会把第二参数 context 作为参数传入，以 _dispatch_call_block_and_release 为例： void _dispatch_call_block_and_release(void *block) { void (^b)(void) = block; b(); Block_release(b);} 省略各种分支后的 dispatch_async_f 函数实现如下： void dispatch_async_f(dispatch_queue_t dq, void ctxt, dispatch_function_t func) { dispatch_continuation_t dc; if (dq-&gt;dq_width == 1) { return dispatch_barrier_async_f(dq, ctxt, func); } dc-&gt;do_vtable = (void )DISPATCH_OBJ_ASYNC_BIT; dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; if (dq-&gt;do_targetq) { return _dispatch_async_f2(dq, dc); } _dispatch_queue_push(dq, dc);} 可见如果是串行队列（dq_width = 1），会调用 dispatch_barrier_async_f 函数处理。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。这里的 dispatch_continuation_t 其实是对 block 的封装，然后调用 _dispatch_queue_push 这个宏将封装好的 block 放入队列中。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下: _dispatch_queue_push└──_dispatch_trace_queue_push └──_dispatch_queue_push └──_dispatch_queue_push_slow └──_dispatch_queue_push_list_slow2 └──_dispatch_wakeup └──dx_probe 队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法，调用栈如下 _dispatch_queue_wakeup_global└──_dispatch_queue_wakeup_global2 └──_dispatch_queue_wakeup_global_slow 在 _dispatch_queue_wakeup_global_slow 我们见到了熟悉的老朋友 pthread 线程： static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) { // 如果线程池已满，则直接调用 \\_dispatch\\_worker_thread // 否则创建线程池 pthread_t pthr; while ((r = pthread\\_create(&amp;pthr, NULL, \\_dispatch\\_worker\\_thread, dq))) { if (r != EAGAIN) { (void)dispatch\\_assume\\_zero(r); } sleep(1); } r = pthread_detach(pthr); (void)dispatch\\_assume\\_zero(r); } 由此可见这里确实使用了线程池。创建线程后会执行 _dispatch_worker_thread 回调: _dispatch_worker_thread└──_dispatch_worker_thread4 └──_dispatch_continuation_pop 在 pop 函数中，我们拿到了最早加入的任务，然后执行： static inline void _dispatch_continuation_pop(dispatch_object_t dou) { // … _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func); if (dg) { dispatch_group_leave(dg); _dispatch_release(dg); }} dispatch_async 的实现比较复杂，主要是因为其中的数据结构较多，分支流程控制比较复杂。但思路其实很简单，用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。如果熟悉了相关数据结构和调用流程，接下来研究 GCD 的其他 API 就比较轻松了。 三、dispatch_sync同步方法的实现相对来说和异步类似，而且更简单，调用栈如下: dispatch_sync└──dispatch_sync_f └──_dispatch_sync_f2 └──_dispatch_sync_f_slow static void _dispatch_sync_f_slow(dispatch_queue_t dq, void ctxt, dispatch_function_t func) { _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore(); struct dispatch_sync_slow_s { DISPATCH_CONTINUATION_HEADER(sync_slow); } dss = { .do_vtable = (void)DISPATCH_OBJ_SYNC_SLOW_BIT, .dc_ctxt = (void)sema, }; _dispatch_queue_push(dq, (void )&amp;dss); \\_dispatch\\_thread\\_semaphore\\_wait(sema); \\_dispatch\\_put\\_thread\\_semaphore(sema); // ... } 这里利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。 四、dispatch_semaphore关于信号量的 API 不多，主要是三个：create、wait 和 signal。信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value，一个是当前的 value，一个是记录初始 value。信号的 wait 和 signal 是互逆的两个操作。如果 value &gt; 0，前者将 value - 1，此时如果 value &lt; 0 就一直等待。初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。 1、dispatch_semaphore_wait 首先从源码看起： long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) { long value = dispatch_atomic_dec2o(dsema, dsema_value); dispatch_atomic_acquire_barrier(); if (fastpath(value &gt;= 0)) { return 0; } return _dispatch_semaphore_wait_slow(dsema, timeout);} 第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将 dsema 的值 -1，并把新的值赋给 value。如果减一后的 value ≥ 0 就立刻返回，没有任何操作，否则进入等待状态。_dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑： case DISPATCH_TIME_NOW: while ((orig = dsema-&gt;dsema_value) &lt; 0) { if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) { return KERN_OPERATION_TIMED_OUT; } } 这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value + 1（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。实际上 while 判断一定会成立，因为如果 value 大于等于 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。 第二种情况是 DISPATCH_TIME_FOREVER 这个 case： case DISPATCH_TIME_FOREVER: do { kr = semaphore_wait(dsema-&gt;dsema_port); } while (kr == KERN_ABORTED); break; 进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。整个函数的框架如下： static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) {again: while ((orig = dsema-&gt;dsema_sent_ksignals)) { if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig, orig - 1)) { return 0; } } switch (timeout) { default: / semaphore_timedwait / case DISPATCH_TIME_NOW: / KERN_OPERATION_TIMED_OUT / case DISPATCH_TIME_FOREVER: / semaphore_wait / } goto again;} 可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。 2、dispatch_semaphore_signal 这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下： long dispatch_semaphore_signal(dispatch_semaphore_t dsema) { long value = dispatch_atomic_inc2o(dsema, dsema_value); if (fastpath(value &gt; 0)) { return 0; } return _dispatch_semaphore_signal_slow(dsema);} 首先会调用原子方法让 value + 1，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow： long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) { (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals); _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port); kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port); return 1;} 它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：“如果唤醒了线程，返回非 0，否则返回 0”。 五、dispatch_group有了上面的铺垫，group 是一个非常容易理解的概念，我们先看看如何创建 group： dispatch_group_t dispatch_group_create(void) { dispatch_group_t dg = _dispatch_alloc(DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s)); _dispatch_semaphore_init(LONG_MAX, dg); return dg;} 没错，group 就是一个 value 为 LONG_MAX 的信号量。 1、dispatch_group_async 它仅仅是 dispatch_group_async_f 的封装： void dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, dispatch_function_t func) { dispatch_continuation_t dc; dispatch_group_enter(dg); dc = \\_dispatch\\_continuation_alloc(); dc-&gt;do\\_vtable = (void *)(DISPATCH\\_OBJ\\_ASYNC\\_BIT | DISPATCH\\_OBJ\\_GROUP_BIT); dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; dc-&gt;dc_data = dg; \\_dispatch\\_queue_push(dq, dc); } 这个函数和 dispatch_async_f 的实现高度一致，主要的不同在于调用了 dispatch_group_enter 方法： void dispatch_group_enter(dispatch_group_t dg) { dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; (void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);} 这个方法也没做什么，就是调用 wait 方法让信号量的 value 减一而已。 2、dispatch_group_wait 这个方法用于等待 group 中所有任务执行完成，可以理解为信号量 wait 的封装： long dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout) { dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) { return 0; } if (timeout == 0) { return KERN_OPERATION_TIMED_OUT; } return _dispatch_group_wait_slow(dsema, timeout);} 如果当前 value 和原始 value 相同，表明任务已经全部完成，直接返回 0，如果 timeout 为 0 也会立刻返回，否则调用 _dispatch_group_wait_slow。这个方法的等待部分和 _dispatch_semaphore_signal_slow 几乎一致，区别在于等待结束后它不是 return，而是调用 _dispatch_group_wake 去唤醒这个 group。 static long _dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) {again: _dispatch_group_wake(dsema); switch (timeout) {/ 三种情况分类 /} goto again;} 这里我们暂时跳过 _dispatch_group_wake，后面会有详细分析。只要知道这个函数在 group 中所有事件执行完后会被调用即可。 3、dispatch_group_notify 这个函数仅仅是封装了 dispatch_group_notify_f： void dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, void (*func)(void )) { dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; struct dispatch_sema_notify_s \\dsn, *prev; dsn-&gt;dsn_queue = dq; dsn-&gt;dsn_ctxt = ctxt; dsn-&gt;dsn_func = func; prev = dispatch\\_atomic\\_xchg2o(dsema, dsema\\_notify\\_tail, dsn); if (fastpath(prev)) { prev-&gt;dsn_next = dsn; } else {/* ... */} } 这种结构的代码已经遇到多次了，它其实就是在链表的尾部续上新的元素。所以 notify 方法并没有做过多的处理，只是用链表把所有回调通知保存起来，等待调用。 4、dispatch_group_leave 在介绍 dispatch_async 函数时，我们看到任务在被执行时，还会调用 dispatch_group_leave 函数： void dispatch_group_leave(dispatch_group_t dg) { dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg; long value = dispatch_atomic_inc2o(dsema, dsema_value); if (slowpath(value == dsema-&gt;dsema_orig)) { (void)_dispatch_group_wake(dsema); }} 当 group 的 value 变为初始值时，表示所有任务都已执行完，开始调用 _dispatch_group_wake 处理回调。 5、dispatch_group_wake static long _dispatch_group_wake(dispatch_semaphore_t dsema) { struct dispatch_sema_notify_s *next, *head, *tail = NULL; long rval; head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL); if (head) { tail = dispatch\\_atomic\\_xchg2o(dsema, dsema\\_notify\\_tail, NULL); } rval = dispatch\\_atomic\\_xchg2o(dsema, dsema\\_group\\_waiters, 0); if (rval) { \\_dispatch\\_semaphore\\_create\\_port(&amp;dsema-&gt;dsema\\_waiter\\_port); do { kern\\_return\\_t kr = semaphore\\_signal(dsema-&gt;dsema\\_waiter_port); } while (--rval); } if (head) { // async group notify blocks do { dispatch\\_async\\_f(head-&gt;dsn\\_queue, head-&gt;dsn\\_ctxt, head-&gt;dsn_func); next = fastpath(head-&gt;dsn_next); if (!next &amp;&amp; head != tail) { while (!(next = fastpath(head-&gt;dsn_next))) { \\_dispatch\\_hardware_pause(); } } free(head); } while ((head = next)); } return 0; } 这个函数主要分为两部分，首先循环调用 semaphore_signal 告知唤醒当初等待 group 的信号量，因此 dispatch_group_wait 函数得以返回。然后获取链表，依次调用 dispatch_async_f 异步执行在 notify 函数中注册的回调。 六、dispatch_oncedispatch_once 仅仅是一个包装，内部直接调用了 dispatch_once_f： void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) { struct _dispatch_once_waiter_s volatile \\vval = (struct _dispatch_once_waiter_s**)val; struct _dispatch_once_waiter_s dow = { NULL, 0 }; struct _dispatch_once_waiter_s *tail, *tmp; _dispatch_thread_semaphore_t sema; if (dispatch\\_atomic\\_cmpxchg(vval, NULL, &amp;dow)) { \\_dispatch\\_client_callout(ctxt, func); tmp = dispatch\\_atomic\\_xchg(vval, DISPATCH\\_ONCE\\_DONE); tail = &amp;dow; while (tail != tmp) { while (!tmp-&gt;dow_next) { \\_dispatch\\_hardware_pause(); } sema = tmp-&gt;dow_sema; tmp = (struct \\_dispatch\\_once\\_waiter\\_s*)tmp-&gt;dow_next; \\_dispatch\\_thread\\_semaphore\\_signal(sema); } } else { dow.dow\\_sema = \\_dispatch\\_get\\_thread_semaphore(); for (;;) { tmp = *vval; if (tmp == DISPATCH\\_ONCE\\_DONE) { break; } dispatch\\_atomic\\_store_barrier(); if (dispatch\\_atomic\\_cmpxchg(vval, tmp, &amp;dow)) { dow.dow_next = tmp; \\_dispatch\\_thread\\_semaphore\\_wait(dow.dow_sema); } } \\_dispatch\\_put\\_thread\\_semaphore(dow.dow_sema); } } 这段代码比较长，我们考虑三个场景： ①、第一次调用：此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。 首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。 ②、同一线程第二次调用：由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。 由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。 ③、多个线程同时调用：由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。 由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。 七、dispatch_barrier_async它调用了 dispatch_barrier_async_f 函数，实现原理也和 dispatch_async_f 类似： void dispatch_barrier_async_f(dispatch_queue_t dq, void ctxt, dispatch_function_t func) { dispatch_continuation_t dc; dc = fastpath(_dispatch_continuation_alloc_cacheonly()); dc-&gt;do_vtable = (void )(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT); dc-&gt;dc_func = func; dc-&gt;dc_ctxt = ctxt; _dispatch_queue_push(dq, dc);} 区别在于 do_vtable 被设置了两个标志位，多了一个 DISPATCH_OBJ_BARRIER_BIT 标记。这个标记在从队列中取出任务时被用到： static _dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_queue_t dq) { while (dq-&gt;dq_items_tail) { /* … / if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp; (long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) { if (dq-&gt;dq_running &gt; 1) { goto out; } } else { _dispatch_continuation_redirect(dq, dc); continue; } }out: /\\ 不完整的 drain，需要清理现场 */ return sema; // 返回空的信号量} 这里原来是一个循环，会拿出所有的任务，依次调用 _dispatch_continuation_redirect，最终并行处理。一旦遇到 DISPATCH_OBJ_BARRIER_BIT 这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行： void _dispatch_queue_invoke(dispatch_queue_t dq) { _dispatch_thread_semaphore_t sema = _dispatch_queue_drain(dq); if (sema) { _dispatch_thread_semaphore_signal(sema); } else if (tq) { return _dispatch_queue_push(tq, dq); }} 因此 barrier 方法能等待此前所有任务执行完以后执行 _dispatch_queue_push，同时保证自己执行完以后才执行后续的操作。 八、dispatch_sourcesource 是一种资源，类似于生产者/消费者模式中的生产者，而队列则是消费者。当有新的资源（source）产生时，它们被放到对应的队列上被执行（消费）。dispatch_source 最常见的用途之一就是用来实现定时器，举一个小例子： dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 每 10 秒触发 timer，误差 1 秒dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 10*NSEC_PER_SEC, 1*NSEC_PER_SEC); dispatch_source_set_event_handler(timer, ^{ // 定时器触发时执行的 block});dispatch_resume(timer); 使用 GCD Timer 的好处在于不依赖 runloop，因此任何线程都可以使用。由于使用了 block，不会忘记避免循环引用。此外，定时器可以自由控制精度，随时修改间隔时间等。 1、dispatch_source_create 下面从底层源码的角度来研究这几行代码的作用。首先是 dispatch_source_create 函数，它和之前见到的 create 函数都差不多，对 dispatch_source_t 对象做了一些初始化工作： dispatch_source_t ds = NULL;ds = _dispatch_alloc(DISPATCH_VTABLE(source), sizeof(struct dispatch_source_s));_dispatch_queue_init((dispatch_queue_t)ds);ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;ds-&gt;do_targetq = &amp;_dispatch_mgr_q;dispatch_set_target_queue(ds, q);return ds; 这里涉及到两个队列，其中 q 是用户指定的队列，表示事件触发的回调在哪个队列执行。而 _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写，也是上文提到的序列号为 2 的内部队列。 2、dispatch_source_set_timer 在这个函数中，首先会有参数处理，过滤掉不符合要求的参数。随后创建了 dispatch_set_timer_params 类型的指针 params： struct dispatch_set_timer_params { dispatch_source_t ds; uintptr_t ident; struct dispatch_timer_source_s values;}; 这个 params 负责绑定定时器对象与它的参数（存储在 values 属性中），最后调用： dispatch_barrier_async_f((dispatch_queue_t)ds, params, _dispatch_source_set_timer2); 这里是把 source 当做队列来使用，因此实际上是调用了 _dispatch_source_set_timer2(params) 方法： static void _dispatch_source_set_timer2(void context) { // Called on the source queue struct dispatch_set_timer_params params = context; dispatch_suspend(params-&gt;ds); dispatch_barrier_async_f(&amp;_dispatch_mgr_q, params, _dispatch_source_set_timer3);} 这里首先暂停了队列，避免了修改的过程中定时器被触发。然后在 manager 队列上执行 _dispatch_source_set_timer3(params)： static void _dispatch_source_set_timer3(void context) { struct dispatch_set_timer_params params = context; dispatch_source_t ds = params-&gt;ds; // … _dispatch_timer_list_update(ds); dispatch_resume(ds);} _dispatch_timer_list_update 函数的作用是根据下一次触发时间将 timer 排序。接下来，当初分发到 manager 队列的 block 将要被执行，走到 _dispatch_mgr_invoke 函数，其中有如下代码： timeoutp = _dispatch_get_next_timer_fire(&amp;timeout);r = select(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, NULL, sel_timeoutp); 可见 GCD 的定时器是由系统的 select 方法实现的。当内层的 manager 队列被唤醒后，还会进一步唤醒外层的队列（当初用户指定的那个），并在队列上执行 timer 触发时的 block。 九、dispatch_resume/suspendGCD 对象的暂停和恢复由 do_suspend_cnt 决定，暂停时通过原子操作将该属性的值加 2，对应的在恢复时通过原子操作将该属性减 2。它有两个默认值： #define DISPATCH_OBJECT_SUSPEND_LOCK 1u #define DISPATCH_OBJECT_SUSPEND_INTERVAL 2u 在唤醒队列时有如下代码： void _dispatch_queue_invoke(dispatch_queue_t dq) { if (!dispatch_atomic_sub2o(dq, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK)) { if (dq-&gt;dq_running == 0) { _dispatch_wakeup(dq); // verify that the queue is idle } }} 可见能够唤醒队列的前提是 dq-&gt;do_suspend_cnt - 1 = 0，也就是要求 do_suspend_cnt 的值就是 DISPATCH_OBJECT_SUSPEND_LOCK。观察 8 个全局队列和主队列的定义就会发现，他们的 do_suspend_cnt 值确实为 DISPATCH_OBJECT_SUSPEND_LOCK，因此默认处于启动状态。而 dispatch_source 的 create 方法中，do_suspend_cnt 的初始值为 DISPATCH_OBJECT_SUSPEND_INTERVAL，因此默认处于暂停状态，需要手动开启。 十、dispatch_afterdispatch_after 其实依赖于定时器的实现，函数内部调用了 dispatch_after_f： void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void ctxt, dispatch_function_t func) { uint64_t delta; struct _dispatch_after_time_s datc = NULL; dispatch_source_t ds; // 如果延迟为 0，直接调用 dispatch_async delta = \\_dispatch\\_timeout(when); if (delta == 0) { return dispatch\\_async\\_f(queue, ctxt, func); } ds = dispatch\\_source\\_create(DISPATCH\\_SOURCE\\_TYPE_TIMER, 0, 0, queue); dispatch_assert(ds); datc = malloc(sizeof(*datc)); dispatch_assert(datc); datc-&gt;datc_ctxt = ctxt; datc-&gt;datc_func = func; datc-&gt;ds = ds; dispatch\\_set\\_context(ds, datc); dispatch\\_source\\_set\\_event\\_handler\\_f(ds, \\_dispatch\\_after\\_timer_callback); dispatch\\_source\\_set\\_timer(ds, when, DISPATCH\\_TIME_FOREVER, 0); dispatch_resume(ds); } 首先将延迟执行的 block 封装在 _dispatch_after_time_s 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。到时以后，执行 _dispatch_after_timer_callback 回调，并取出上下文中的 block： static void _dispatch_after_timer_callback(void ctxt) { struct _dispatch_after_time_s datc = ctxt; _dispatch_client_callout(datc-&gt;datc_ctxt, datc-&gt;datc_func); // 清理工作} 十一、总结本文主要整理了 GCD 中常见的 API 以及底层的实现原理。 ①、对于队列来说，需要理解它的数据结构，转发机制，以及底层的线程池模型。 ②、dispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。在 wakeup 方法中，从线程池里取出工作线程（如果没有就新建），然后在工作线程中取出链表头部指向的 block 并执行。 ③、dispatch_sync 的实现略简单一些，它不涉及线程池（因此一般都在当前线程执行），而是利用与线程绑定的信号量来实现串行。分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性（表示在运行的任务数量）为 1，所以以下判断成立： if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) { return _dispatch_barrier_sync_f_slow(dq, ctxt, func);} 在 _dispatch_barrier_sync_f_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。如果向其它队列同步提交 block，最终进入 _dispatch_barrier_sync_f_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。 ④、对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。在调用 signal 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。 ⑤、dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。 ⑥、dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。 ⑦、dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。 ⑧、dispatch_source 可以用来实现定时器。所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。随后找到最近触发的定时器，调用内核的 select 方法等待。等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。 ⑨、GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。 ⑩、dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。 十二、参考资料Why do we use _builtinexpect when a straightforward way is to use if-else Posix线程编程指南(2) 线程私有数据 选择 GCD 还是 NSTimer？ 从NSTimer的失效性谈起（二）：关于GCD Timer和libdispatch 变态的libDispatch源码分析","tags":[]},{"title":" GCD\t\t","date":"2019-03-19T08:01:47.000Z","path":"2019/03/19/gcd/","text":"原文：iOS多线程：『GCD』详尽总结 一、GCD 简介 百度百科 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。在 Mac OSX 10.6 首次推出，也可在 iOS4 及以上版本使用。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。 使用 GCD 的好处： GCD 可用于多核的并行运算 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程），程序员只需要告诉 GCD 想要执行什么任务 二、GCD 任务和队列GCD 中两个核心概念：任务和队列。 1、任务 要执行的操作，也就是在线程中执行的那段代码。在 GCD 是放在 block 里。 执行任务有两种方式：同步执行（sync）和异步执行（async）。 主要区别：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。 同步执行 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。 只能在当前线程中执行任务，不具备开启新线程的能力。 异步执行： 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。 可以在新的线程中执行任务，具备开启新线程的能力。 注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程，这跟任务所指定的队列类型有关。 2、队列 指执行任务的等待队列，即用来存放任务的队列。 队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图： 在 GCD 中有两种队列：串行队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue）。两者都符合 FIFO（先进先出）的原则。 两者的主要区别是：执行顺序不同，以及开启线程数不同。 串行队列： 每次只执行一个任务，任务一个接一个执行。（只开启一个线程） 并发队列： 多个任务可以并发（同时）执行。（可以开启多个线程，并且同时执行任务） 注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效。 两者具体区别如下图： 三、GCD 的使用步骤GCD 的使用只有两步： ①、创建一个队列（串行队列或并发队列） ②、将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。 1、队列的创建方法/获取方法 使用 dispatch_queue_create 来创建队列。 / 参数 1 : 表示队列的唯一标识符，用于 DEBUG，可以为空，推荐使用应用 BundleId 的逆序全程域名 参数 2 : 用于识别是串行队列、并发队列。DISPATCH_QUEUE_SERIAL:串行 DISPATCH_QUEUE_CONCURRENT:并发 / // 串行队列dispatch_queue_t queue = dispatch_queue_create(“net.bujige.testQueue”, DISPATCH_QUEUE_SERIAL); // 并发队列dispatch_queue_t queue = dispatch_queue_create(“net.bujige.testQueue”, DISPATCH_QUEUE_CONCURRENT); GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue） 所有放在主队列中的任务，都会放到主线程中执行。 可使用 dispatch_get_main_queue() 获得主队列。 // 主队列dispatch_queue_t queue = dispatch_get_main_queue(); GCD 默认提供了全局并发队列（Global Dispatch Queue） /** * 全局并发队列 * * 参数 1 : 队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT * 参数 2 : 暂时没用，传 0 */dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 2、任务的创建方法 GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async。 // 同步dispatch_sync(queue, ^{ // do something}); // 异步dispatch_async(queue, ^{ // do something}); 虽然使用 GCD 只需两步，但是既然有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么就有了四种不同的组合方式。这四种不同的组合方式是： 同步执行 + 并发队列 异步执行 + 并发队列 同步执行 + 串行队列 异步执行 + 串行队列 还有两种特殊队列：全局并发队列、主队列。因为主队列特殊，所以就又多了两种组合方式。这样就有 6 种不同的组合方式了。 同步执行 + 主队列 异步执行 + 主队列 同步既然不会开辟新的线程，那同步阻塞的是当前线程还是当前队列？ 阻塞当前队列，造成线程死锁。 3、GCD 线程间的通信 在 iOS 开发过程中，通常把一些耗时的操作放在其他线程，然后在主线程进行 UI 刷新。而当有时候在其他线程完成了耗时操作时，需要回到主线程，就用到了线程之间的通讯。 /** * 线程间通信 */- (void)communication{ // 获取全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_async(queue, ^{ // 异步追加任务 for (int i = 0; i &lt; 2; ++i) { \\[NSThread sleepForTimeInterval:2\\]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, \\[NSThread currentThread\\]); // 打印当前线程 } // 回到主线程 dispatch_async(mainQueue, ^{ // 追加在主线程中执行的任务 \\[NSThread sleepForTimeInterval:2\\]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, \\[NSThread currentThread\\]); // 打印当前线程 }); }); } 1—&lt;NSThread: 0x600000271940&gt;{number = 3, name = (null)}1—&lt;NSThread: 0x600000271940&gt;{number = 3, name = (null)}2—&lt;NSThread: 0x60000007bf80&gt;{number = 1, name = main} 可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。 4、GCD 的其他方法 ①、GCD 栅栏方法：dispatch_barrier_async 有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样就需要有一个相当于栅栏一样的方法将两组异步执行的操作组（包含一个或多个任务）给分割开来。这就需要用到 dispatch_barrier_async 方法。 dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列。然后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。 具体如下图所示： // 并行队列 dispatch\\_queue\\_t queue = dispatch\\_queue\\_create(&quot;com.dubinbin.Demo&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch_async(queue, ^{ NSLog(@&quot;1111&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;2222&quot;); }); dispatch\\_barrier\\_async(queue, ^{ NSLog(@&quot;barrier&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;3333&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;4444&quot;); }); NSLog(@&quot;end&quot;); 2019-03-19 14:47:01.584536+0800 Demo[45246:3034531] end2019-03-19 14:47:01.584562+0800 Demo[45246:3034564] 22222019-03-19 14:47:01.584566+0800 Demo[45246:3034562] 11112019-03-19 14:47:01.584676+0800 Demo[45246:3034562] barrier2019-03-19 14:47:01.584755+0800 Demo[45246:3034562] 33332019-03-19 14:47:01.584765+0800 Demo[45246:3034564] 4444 dispatch_barrier_async 执行结果：在执行完栅栏前面的任务之后，才执行栅栏操作，最后再执行栅栏后边的任务。 ②、GCD 延时执行方法：dispatch_after 经常会遇到这样的需求：在指定时间（例如 3 秒）之后执行某个任务。可以用 GCD 的 dispatch_after 函数来实现。 注意：dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 函数是很有效的。 dispatch\\_after(dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(5 * NSEC\\_PER\\_SEC)), dispatch\\_get\\_main\\_queue(), ^{ NSLog(@&quot;Delay in Thread : %@&quot;, \\[NSThread currentThread\\]); }); NSLog(@&quot;end&quot;); 14:52:01.582676+0800 end14:52:06.583078+0800 Delay in Thread : &lt;NSThread: 0x600001026940&gt;{number = 1, name = main} dispatch_after 执行结果：打印 end 之后大约 5.0 秒打印了 Delay in Thread。 ③、GCD 一次性代码：dispatch_once 在创建单例或者整个程序运行过程中只执行一次的代码时，就用到了 GCD 的 dispatch_once 函数。使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行 1 次，并且即使在多线程的环境下，dispatch_once 也可以保证线程安全。 static dispatch\\_once\\_t onceToken; dispatch_once(&amp;onceToken, ^{ // code to be executed once }); ④、GCD 快速迭代方法：dispatch_apply 通常是用 for 循环遍历，但是 GCD 提供了快速迭代的函数 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。 如果是在串行队列（单线程）中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行，体现不出快速迭代的意义。 dispatch_apply 可以在多个线程中同时（异步）遍历多个数字。 注意：无论是串行队列，还是异步队列，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait 方法。 dispatch\\_apply(5, queue, ^(size\\_t index) { NSLog(@&quot;%zd---%@&quot;, index, \\[NSThread currentThread\\]); }); NSLog(@&quot;end&quot;); 1—&lt;NSThread: 0x6000031499c0&gt;{number = 3, name = (null)}3—&lt;NSThread: 0x600003149a00&gt;{number = 5, name = (null)}0—&lt;NSThread: 0x600003126fc0&gt;{number = 1, name = main}2—&lt;NSThread: 0x6000031414c0&gt;{number = 4, name = (null)}4—&lt;NSThread: 0x6000031414c0&gt;{number = 4, name = (null)}end 因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定，但是 end 一定在最后执行。 ⑤、GCD 队列组：dispatch_group 有时候会有这样的需求：分别异步执行 2 个耗时任务，然后当 2 个耗时任务都执行完毕后再回到主线程执行任务。这时候就可以用到 GCD 的队列组。 调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合来实现。 调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。 dispatch_group_notify 监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 并执行。 dispatch\\_queue\\_t queue = dispatch\\_queue\\_create(&quot;com.dubinbin.Demo&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch\\_group\\_t group = dispatch\\_group\\_create(); dispatch\\_group\\_async(group, queue, ^{ NSLog(@&quot;1111&quot;); }); dispatch\\_group\\_async(group, queue, ^ { NSLog(@&quot;2222&quot;); }); dispatch\\_group\\_notify(group, queue, ^{ NSLog(@&quot;group&quot;); }); dispatch\\_group\\_async(group, queue, ^{ NSLog(@&quot;3333&quot;); }); dispatch\\_group\\_async(group, queue, ^{ NSLog(@&quot;4444&quot;); }); NSLog(@&quot;end&quot;); 2019-03-19 15:07:48.576680+0800 Demo[45472:3045696] end2019-03-19 15:07:48.576680+0800 Demo[45472:3045738] 22222019-03-19 15:07:48.576687+0800 Demo[45472:3045736] 11112019-03-19 15:07:48.576702+0800 Demo[45472:3045735] 44442019-03-19 15:07:51.580427+0800 Demo[45472:3045737] 33332019-03-19 15:07:51.580874+0800 Demo[45472:3045737] group dispatch_group_notify 运行结果：当所有任务都执行完成之后，才执行 dispatch_group_notify block 中的任务。 注意：barrier 和 group 的区别，barrier 只等待之前的任务执行完，group 需要等待加入到 group 中所有的任务执行完。 dispatch_group_wait 暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。 dispatch\\_queue\\_t queue = dispatch\\_queue\\_create(&quot;com.dubinbin.Demo&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch\\_group\\_t group = dispatch\\_group\\_create(); dispatch\\_group\\_async(group, queue, ^{ NSLog(@&quot;1111&quot;); }); dispatch\\_group\\_async(group, queue, ^ { NSLog(@&quot;2222&quot;); }); dispatch\\_group\\_notify(group, queue, ^{ NSLog(@&quot;group&quot;); }); dispatch\\_group\\_async(group, queue, ^{ NSLog(@&quot;3333&quot;); }); dispatch\\_group\\_async(group, queue, ^{ \\[NSThread sleepForTimeInterval:5\\]; NSLog(@&quot;4444&quot;); }); dispatch\\_group\\_wait(group, DISPATCH\\_TIME\\_FOREVER); NSLog(@&quot;end&quot;); 2019-03-19 15:14:18.051069+0800 Demo[45564:3049581] 22222019-03-19 15:14:18.051069+0800 Demo[45564:3049578] 11112019-03-19 15:14:18.051089+0800 Demo[45564:3049579] 33332019-03-19 15:14:23.055943+0800 Demo[45564:3049580] 44442019-03-19 15:14:23.056329+0800 Demo[45564:3049532] end2019-03-19 15:14:23.056329+0800 Demo[45564:3049580] group dispatch_group_wait 运行结果：dispatch_group_wait 会阻塞当前线程，当所有任务执行完成再继续向下执行。 dispatch_group_enter、dispatch_group_leave dispatch_group_enter 标志着一个任务追加到 group，相当于 group 中未执行完毕任务数 +1 dispatch_group_leave 标志着一个任务离开了 group，相当于 group 中未执行完毕任务数 -1。 当 group 中未执行完毕任务数为 0 时，才会使 dispatch_group_wait 解除阻塞，并执行追加到 dispatch_group_notify 中的任务。 dispatch\\_queue\\_t queue = dispatch\\_queue\\_create(&quot;com.dubinbin.Demo&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch\\_group\\_t group = dispatch\\_group\\_create(); dispatch\\_group\\_enter(group); dispatch_async(queue, ^{ NSLog(@&quot;1111&quot;); dispatch\\_group\\_leave(group); }); dispatch\\_group\\_enter(group); dispatch_async(queue, ^{ NSLog(@&quot;2222&quot;); dispatch\\_group\\_leave(group); }); dispatch\\_group\\_notify(group, queue, ^{ NSLog(@&quot;group&quot;); }); dispatch\\_group\\_enter(group); dispatch_async(queue, ^{ \\[NSThread sleepForTimeInterval:5\\]; NSLog(@&quot;3333&quot;); dispatch\\_group\\_leave(group); }); dispatch\\_group\\_enter(group); dispatch_async(queue, ^{ NSLog(@&quot;4444&quot;); dispatch\\_group\\_leave(group); }); dispatch\\_group\\_wait(group, DISPATCH\\_TIME\\_FOREVER); NSLog(@&quot;end&quot;); 2019-03-19 15:45:32.294390+0800 Demo[45813:3061727] 11112019-03-19 15:45:32.294399+0800 Demo[45813:3061725] 22222019-03-19 15:45:32.294411+0800 Demo[45813:3061728] 44442019-03-19 15:45:37.299935+0800 Demo[45813:3061726] 33332019-03-19 15:45:37.300306+0800 Demo[45813:3061728] group2019-03-19 15:45:37.300309+0800 Demo[45813:3061668] end dispatch_group_enter、dispatch_group_leave 运行结果：这里的 dispatch_group_enter、dispatch_group_leave 组合等同于 dispatch_group_async。当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。 6、GCD 信号量：dispatch_semaphore GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。 在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为 0 时等待；计数 ≥ 1 时不等待。 Dispatch Semaphore 提供了三个函数。 dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量 dispatch_semaphore_signal：发送一个信号，让信号总量 +1 dispatch_semaphore_wait：使总信号量 -1，当信号总量为 0 时一直等待（阻塞所在线程），否则正常执行。 注意：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后才能使用信号量。 Dispatch Semaphore 在实际开发中主要用于： 保持线程同步，将异步执行任务转换为同步执行任务 保证线程安全，为线程加锁 ①、Dispatch Semaphore 线程同步 在开发中会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于将异步执行任务转换为同步执行任务。比如 AFNetworking 中 AFURLSessionManager.m 的 tasksForKeyPath: 方法，通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。 - (NSArray )tasksForKeyPath:(NSString )keyPath{ __block NSArray * tasks = nil; dispatch\\_semaphore\\_t semaphore = dispatch\\_semaphore\\_create(0); \\[self.session getTasksWithCompletionHandler:^( NSArray * dataTasks, NSArray * uploadTasks, NSArray * downloadTasks) { if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))\\]) { tasks = dataTasks; } else if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))\\]) { tasks = uploadTasks; } else if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))\\]) { tasks = downloadTasks; } else if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(tasks))\\]) { tasks = \\[@\\[dataTasks, uploadTasks, downloadTasks\\] valueForKeyPath:@&quot;@unionOfArrays.self&quot;\\]; } dispatch\\_semaphore\\_signal(semaphore); }\\]; dispatch\\_semaphore\\_wait(semaphore, DISPATCH\\_TIME\\_FOREVER); return tasks; } 下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。 ②、Dispatch Semaphore 线程安全和线程同步（为线程加锁） 线程安全 如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步 可以理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 7、dispatch_set_target_queue /** * 参数 1 : 要执行变更的队列（不能指定主队列和全局队列） * 参数 2 : 目标队列（指定全局队列） */dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue); dispatch_set_target_queue 函数有两个作用：①、变更队列的执行优先级；②、目标队列可以成为原队列的执行阶层。 // 串行队列，默认优先级 dispatch\\_queue\\_t serialQueue = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue.serialQueue&quot;, NULL); // 串行队列（参照），默认优先级 dispatch\\_queue\\_t serialDefaultQueue = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue.serialDefaultQueue&quot;, NULL); // 1\\. 变更前 dispatch_async(serialQueue, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(serialDefaultQueue, ^{ NSLog(@&quot;2&quot;); }); // 全局队列，后台优先级 dispatch\\_queue\\_t globalDefaultQueue = dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY\\_BACKGROUND, 0); // 2\\. 变更优先级 dispatch\\_set\\_target_queue(serialQueue, globalDefaultQueue); // 3\\. 变更后 dispatch_async(serialQueue, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(serialDefaultQueue, ^{ NSLog(@&quot;2&quot;); }); -------------------- 1 ——————–2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 22019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 12019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 22019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1 -------------------- 2 ——————–2019-03-19 23:25:27.663809+0800 Demo[41898:2730565] 12019-03-19 23:25:27.663825+0800 Demo[41898:2730566] 22019-03-19 23:25:27.664036+0800 Demo[41898:2730565] 22019-03-19 23:25:27.664039+0800 Demo[41898:2730566] 1 变更优先级前，serialQueue、serialDefaultQueue 打印随机；变更后，serialDefaultQueue 必定先于 serialQueue 打印。 dispatch\\_queue\\_t serialQueue1 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL); dispatch\\_queue\\_t serialQueue2 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL); dispatch\\_queue\\_t serialQueue3 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL); dispatch\\_queue\\_t serialQueue4 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL); dispatch\\_queue\\_t serialQueue5 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL); dispatch_async(serialQueue1, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(serialQueue2, ^{ NSLog(@&quot;2&quot;); }); dispatch_async(serialQueue3, ^{ NSLog(@&quot;3&quot;); }); dispatch_async(serialQueue4, ^{ NSLog(@&quot;4&quot;); }); dispatch_async(serialQueue5, ^{ NSLog(@&quot;5&quot;); }); 2019-03-19 23:31:27.856574+0800 Demo[41983:2736476] 12019-03-19 23:31:27.856583+0800 Demo[41983:2736474] 42019-03-19 23:31:27.856585+0800 Demo[41983:2736475] 22019-03-19 23:31:27.856586+0800 Demo[41983:2736477] 52019-03-19 23:31:27.856586+0800 Demo[41983:2736493] 3 未设置目标队列前，异步执行任务不阻塞，所以打印随机。 dispatch\\_queue\\_t serialQueue1 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL); dispatch\\_queue\\_t serialQueue2 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL); dispatch\\_queue\\_t serialQueue3 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL); dispatch\\_queue\\_t serialQueue4 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL); dispatch\\_queue\\_t serialQueue5 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL); dispatch\\_queue\\_t targetSerialQueue = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.targetSerialQueue&quot;, NULL); //设置执行阶层 dispatch\\_set\\_target_queue(serialQueue1, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue3, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue2, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue4, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue5, targetSerialQueue); dispatch_async(serialQueue1, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(serialQueue2, ^{ NSLog(@&quot;2&quot;); }); dispatch_async(serialQueue3, ^{ NSLog(@&quot;3&quot;); }); dispatch_async(serialQueue4, ^{ NSLog(@&quot;4&quot;); }); dispatch_async(serialQueue5, ^{ NSLog(@&quot;5&quot;); }); 2019-03-19 23:34:04.912115+0800 Demo[42048:2739515] 12019-03-19 23:34:04.912432+0800 Demo[42048:2739515] 22019-03-19 23:34:04.912573+0800 Demo[42048:2739515] 32019-03-19 23:34:04.912692+0800 Demo[42048:2739515] 42019-03-19 23:34:04.912874+0800 Demo[42048:2739515] 5 情况一：先设置目标队列，后添加任务，按顺序执行。 dispatch\\_queue\\_t serialQueue1 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue1&quot;, NULL); dispatch\\_queue\\_t serialQueue2 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue2&quot;, NULL); dispatch\\_queue\\_t serialQueue3 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue3&quot;, NULL); dispatch\\_queue\\_t serialQueue4 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue4&quot;, NULL); dispatch\\_queue\\_t serialQueue5 = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.serialQueue5&quot;, NULL); dispatch_async(serialQueue1, ^{ NSLog(@&quot;1&quot;); }); dispatch_async(serialQueue2, ^{ NSLog(@&quot;2&quot;); }); dispatch_async(serialQueue3, ^{ NSLog(@&quot;3&quot;); }); dispatch_async(serialQueue4, ^{ NSLog(@&quot;4&quot;); }); dispatch_async(serialQueue5, ^{ NSLog(@&quot;5&quot;); }); dispatch\\_queue\\_t targetSerialQueue = dispatch\\_queue\\_create(&quot;com.gcd.setTargetQueue2.targetSerialQueue&quot;, NULL); //设置执行阶层 dispatch\\_set\\_target_queue(serialQueue1, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue2, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue3, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue4, targetSerialQueue); dispatch\\_set\\_target_queue(serialQueue5, targetSerialQueue); 2019-03-19 23:36:07.791578+0800 Demo[42077:2741664] 12019-03-19 23:36:07.791620+0800 Demo[42077:2741665] 42019-03-19 23:36:07.791578+0800 Demo[42077:2741663] 32019-03-19 23:36:07.791578+0800 Demo[42077:2741666] 22019-03-19 23:36:07.791635+0800 Demo[42077:2741693] 5 情况二：先添加任务，后设置目标队列，乱序输出。 在必须将不可并行执行的处理追加到多个 Serial Dispatch Queue 中时，如果使用 dispatch_set_target_queue 函数将目标指定为某一个 Serial Dispatch Queue，即可防止处理并行执行。 四、参考资料iOS GCD之dispatch_semaphore（信号量） iOS多线程：『pthread、NSThread』详尽总结 iOS多线程：『NSOperation』详尽总结 iOS多线程：『RunLoop』详尽总结","tags":[]},{"title":" switch 与 if-else 的效率问题\t\t","date":"2019-03-19T03:51:36.000Z","path":"2019/03/19/switch-e4-b8-8e-if-else-e7-9a-84-e6-95-88-e7-8e-87-e9-97-ae-e9-a2-98/","text":"文章：switch 与 if-else 的效率问题 switch-case 与 if-else 的根本区别： switch 会生成一个跳转表来指示实际的 case 分支的地址，而这个跳转表的索引号与 switch 变量的值是相等的。 所以 switch-case 不用像 if-else 那样遍历条件分支直到命中条件，只需访问对应索引号的表项从而到达定位分支。 具体地说，switch-case 会生成一份大小（表项数）为最大 case 常量 +1 的跳转表，程序首先判断 switch 变量是否大于最大 case 常量，若大于，则跳到 default 分支处理；否则取得索引号为 switch 变量大小的跳表项的地址（即跳表的起始地址+表项大小 * 索引号），程序接着跳到此地址执行，到此完成了分支的跳转。 int main() { unsigned int i, j; i = 3; switch (i) { case 0: j = 0; break; case 1: j = 1; break; case 2: j = 2; break; case 3: j = 3; break; case 4: j = 4; break; default: j = 10; break; } } 用 gcc 编译器，生成汇编代码（不开编译器优化） _main: ## @mainLfunc_begin0: .loc 1 12 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:12:0 .cfi_startproc## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl $0, -4(%rbp)Ltmp0: .loc 1 14 7 prologue_end ## /Users/cykj/Desktop/Demo/Demo/MyC.c:14:7 movl $3, -8(%rbp) .loc 1 16 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:13 movl -8(%rbp), %eax movl %eax, %ecx movq %rcx, %rdx subq $4, %rdx .loc 1 16 5 is_stmt 0 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:16:5 movq %rcx, -24(%rbp) ## 8-byte Spill movq %rdx, -32(%rbp) ## 8-byte Spill ja LBB0_6## %bb.8: .loc 1 0 5 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:0:5 leaq LJTI0_0(%rip), %rax movq -24(%rbp), %rcx ## 8-byte Reload movslq (%rax,%rcx,4), %rdx addq %rax, %rdx jmpq *%rdxLBB0_1:Ltmp1: .loc 1 18 15 is_stmt 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:18:15 movl $0, -12(%rbp) .loc 1 19 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:19:13 jmp LBB0_7LBB0_2: .loc 1 22 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:22:15 movl $1, -12(%rbp) .loc 1 23 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:23:13 jmp LBB0_7LBB0_3: .loc 1 26 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:26:15 movl $2, -12(%rbp) .loc 1 27 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:27:13 jmp LBB0_7LBB0_4: .loc 1 30 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:30:15 movl $3, -12(%rbp) .loc 1 31 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:31:13 jmp LBB0_7LBB0_5: .loc 1 34 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:34:15 movl $4, -12(%rbp) .loc 1 35 13 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:35:13 jmp LBB0_7LBB0_6: .loc 1 38 15 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:38:15 movl $10, -12(%rbp)Ltmp2:LBB0_7: .loc 1 42 1 ## /Users/cykj/Desktop/Demo/Demo/MyC.c:42:1 movl -4(%rbp), %eax popq %rbp retqLtmp3:Lfunc_end0: .cfi_endproc .p2align 2, 0x90 .data_region jt32L0_0_set_1 = LBB0_1-LJTI0_0L0_0_set_2 = LBB0_2-LJTI0_0L0_0_set_3 = LBB0_3-LJTI0_0L0_0_set_4 = LBB0_4-LJTI0_0L0_0_set_5 = LBB0_5-LJTI0_0LJTI0_0: .long L0_0_set_1 .long L0_0_set_2 .long L0_0_set_3 .long L0_0_set_4 .long L0_0_set_5 .end_data_region ## \\-\\- End function 由此看来，switch 有点以空间换时间的意思，而事实上也的确如此。 1、当分支较多时，当时用 switch 的效率是很高的。因为 switch 是随机访问的，就是确定了选择值之后直接跳转到那个特定的分支，但是 if-else 是遍历所有的可能值，直到找到符合条件的分支。 但不总是那么好，因为每次计算会有一个二次查表过程。 具体需要看应用场景，举个例子：对于网络层的协议分析，99% 可能都是 IP 协议，因此基本上会在第一个 if 时就命中，只有一次计算。 总结：对于分支较多或分布相对均匀的情况，使用 switch 可以提高效率；对于分支较少或分布不均匀的情况，使用 if-else 更好。 2、由上面的汇编代码可知道，switch-case 占用较多的代码空间，因为它要生成跳转表，特别是当 case 常量分布范围很大但实际有效值又比较少的情况，switch-case 的空间利用率将变得很低。 3、switch-case 只能处理 case 为常量的情况，对非常量的情况是无能为力的。例如 if (a &gt; 1 &amp;&amp; a &lt; 100)，是无法使用 switch-case 来处理的。所以 if-else 能应用于更多的场合，比较灵活。","tags":[]},{"title":" GCD 实现\t\t","date":"2019-03-18T15:57:13.000Z","path":"2019/03/18/gcd-e5-ae-9e-e7-8e-b0/","text":"一、Dispatch Queue不难想象 GCD 的实现需要使用以下这些工具。 ①、用于管理追加的 Block 的 C 语言层实现的 FIFO 队列； ②、Atomic 函数中实现的用于排他控制的轻量级信号； ③、用于管理线程的 C 语言层实现的一些容器。 但如果只用了这些内容便可实现，那么就不需要内核级的实现了。官方说明： 通常，应用程序中编写的线程管理用的代码要在系统级实现。 在系统（iOS 和 OS X 的核心 XNU 内核）级上的实现。因此，无论编程人员如何努力编写管理线程的代码，在性能方面都不可能超过 XNU 内核级所实现的 GCD。 使用 GCD 不必编写线程的创建、销毁等管理代码，而可以在线程中集中实现处理内容。我们应该尽量多使用 GCD 或者使用了 Cocoa 框架 GCD 的 NSOperationQueue 类等 API。 用于实现 Dispatch Queue 而使用的软件组件。 编程人员所使用的 GCD 的 API 全部为包含在 libdispatch 库的 C 语言函数。Dispatch Queue 通过结构体和链表，被实现为 FIFO 队列。FIFO 队列管理通过 dispatch_async 等函数所追加的 block。 Block 并不直接加入 FIFO 队列，而是先加入 Dispatch Continuation 这一个 dispatch_continuation_t 类型结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记录 Block 所属的 Dispatch Group 和一些其他信息，相当于一般常说的上下文。 Dispatch Queue 可通过 dispatch_set_target_queue 函数设定执行该 Dispatch Queue 处理的 Dispatch Queue 为目标。该目标可像串珠子一样，设定多个连接在一起的 Dispatch Queue。但是在连接串的最后必须设定为 Main Dispatch Queue 或各种优先级的 Global Dispatch Queue，或者准备用于 Serial Dispatch Queue 的各种优先级的 Global Dispatch Queue。 Global Dispatch Queue 有 8 种： Global Dispatch Queue（High Priority） Global Dispatch Queue（Default Priority） Global Dispatch Queue（Low Priority） Global Dispatch Queue（Background Priority） Global Dispatch Queue（High Overcommit Priority） Global Dispatch Queue（Default Overcommit Priority） Global Dispatch Queue（Low Overcommit Priority） Global Dispatch Queue（Background Overcommit Priority） 优先级带有 Overcommit 的 Global Dispatch Queue 使用在 Serial Dispatch Queue 中。如 Overcommit 这个名称所示，不管系统状态如何，都会强制生成线程的 Dispatch Queue。 这 8 种 Global Dispatch Queue 各使用 1 个 pthread_workqueue。GCD 初始化时，使用 pthread_workqueue_create_np 函数生成 pthread_workqueue。 pthread_workqueue 包含在 Libc 提供的 pthreads API 中。其使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息。 XNU 内核持有 4 种 workqueue： WORKQUEUE_HIGH_PRIOQUEUE WORKQUEUE_DEFAULT_PRIOQUEUE WORKQUEUE_LOW_PRIOQUEUE WORKQUEUE_BG_PRIOQUEUE 该执行优先级和 Global Dispatch Queue 的 4 种优先级相同。 当在 Global Dispatch Queue 中执行 Block 时，libdispatch 从 Global Dispatch Queue 自身的 FIFO 队列取出 Dispatch Continuation，调用 pthread_workqueue_additem_np 函数，把该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数。 pthread_workqueue_additem_np 函数使用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目。根据该通知，XNU 内核基于系统状态判断是否要生成线程。如果是 Overcommit 优先级的 Global Dispatch Queue，workqueue 则始终生成线程。 该线程虽然与 iOS 和 OS X 中通常使用的线程大致相同，但是有一部分 pthread API 不能使用。详见苹果官方文档《并行编码指南》的“与 POSIX 线程的互换性”。 另外，因为 workqueue 生成的线程在实现用于 workqueue 的线程计划表中运行，所以与一般线程的上下文切换不同。 workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数。在该回调函数中执行加入到 Dispatch Continuation 的 Block。 Block 执行结束后，进行通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备执行加入到 Global Dispatch Queue 中的下一个 Block。 总结： ①、block、block 所属的 group、其他信息加入的 dispatch_continuation_t 结构体中； ②、将 dispatch_continuation_t 加入 FIFO 队列； ③、Dispatch_Queue 通过 dispatch_set_target_queue 设置目标 Queue； ④、GCD 初始化时，pthread_workqueue_create_np 生成 pthread_workqueue; ⑤、pthread_workqueue 使用 bsdthread_register 和 workq_open 系统调用，在初始化 XNU 内核的 workqueue 之后获取 workqueue 信息； ⑥、当在 Global Dispatch Queue 执行 Block 时 libdispatch 从 FIFO 队列中取出 Dispatch Continuation； ⑦、调用 pthread_workqueue_additem_np 函数，将该 Global Dispatch Queue 自身、符合其优先级的 workqueue 信息以及为执行 Dispatch Continuation 的回调函数等传递给参数； ⑧、pthread_workqueue_additem_np 内部调用 workq_kernreturn 系统调用，通知 workqueue 增加应当执行的项目； ⑨、XNU 内核基于系统状态判断是否要生成线程； ⑩、workqueue 的线程执行 pthread_workqueue 函数，该函数调用 libdispatch 的回调函数，在该回调函数中执行加入到 Dispatch Continuation 的 Block。Block 执行结束后，通知 Dispatch Group 结束、释放 Dispatch Continuation 等处理，开始准备下一个 Block 的执行。","tags":[]},{"title":" NullSafe\t\t","date":"2019-03-18T10:25:59.000Z","path":"2019/03/18/nullsafe/","text":"Github：NullSafe、QiSafeType 一、NullSafe.m这个文件是 NSNull 的分类，没有 .h 文件，用的是消息转发功能，逻辑较为简单。以下为代码： // https://github.com/nicklockwood/NullSafe #import &lt;objc/runtime.h&gt; #import &lt;Foundation/Foundation.h&gt; #ifndef NULLSAFE_ENABLED #define NULLSAFE_ENABLED 1 #endif #pragma clang diagnostic ignored “-Wgnu-conditional-omitted-operand” @implementation NSNull (NullSafe) #if NO #if NULLSAFE_ENABLED - (NSMethodSignature )methodSignatureForSelector:(SEL)selector{ //look up method signature NSMethodSignature signature = [super methodSignatureForSelector:selector]; // 如果没有方法签名 if (!signature) { for (Class someClass in @\\[ \\[NSMutableArray class\\], \\[NSMutableDictionary class\\], \\[NSMutableString class\\], \\[NSNumber class\\], \\[NSDate class\\], \\[NSData class\\] \\]) { @try { // 实例是否能够响应 selector（即在 class 中是否能找到该方法） if (\\[someClass instancesRespondToSelector:selector\\]) { signature = \\[someClass instanceMethodSignatureForSelector:selector\\]; break; } } @catch (__unused NSException *unused) { } } } return signature; } - (void)forwardInvocation:(NSInvocation *)invocation{ invocation.target = nil; // 调用 \\[invocation invoke\\]; } - (void)setValue:(id)value forUndefinedKey:(NSString *)key{ } - (id)valueForUndefinedKey:(NSString *)key{ return nil;} #endif #endif@end 二、QiSafeType1、NSNull+QiNullSafe.m 与 NullSafe.m 的代码逻辑基本一样，新增了一方法实现 for 循环的逻辑，比较明显的区别是没有用 try-catch。 - (Class)qiResponedClassForSelector:(SEL)selector { respondClasses = @\\[ \\[NSMutableArray class\\], \\[NSMutableDictionary class\\], \\[NSMutableString class\\], \\[NSNumber class\\], \\[NSDate class\\], \\[NSData class\\] \\]; for (Class someClass in respondClasses) { if (\\[someClass instancesRespondToSelector:selector\\]) { return someClass; } } return nil; } 2、QiAvoidCommonCrash 这部分功能可以查看 AvoidCrash。通过 runtime 的 method-swizzle 实现方法实现的替换，然后对参数进行判断纠错。","tags":[]},{"title":" 图片处理\t\t","date":"2019-03-18T10:01:30.000Z","path":"2019/03/18/e5-9b-be-e7-89-87-e5-a4-84-e7-90-86/","text":"一、ImageMagick使用 ImageMagick 对 png 图片做轻量压缩（基本没有减少体积），不损失图片质量，会改变图片文件 hash 值。方法： 安装 ImageMagick brew install imagemagick 压缩工程目录下所有 png 文件 find . -iname &quot;*.png&quot; -exec echo {} \\\\; -exec convert {} {} \\\\; 其他用法： 更改文件类型$ convert input.jpg output.png // 增加有色边 $ convert -bordercolor red -border 25x25 image.jpg image.gif // 加亮或变暗图片边缘，以增强3D效果 $ convert -raise 25 image.jpg image.gif // 在图片周围增加装饰性框架。 $ convert -mattecolor gray -frame 25x25 image.jpg image.gif // 在图片边缘增加升、降斜角 $ convert -mattecolor gray -frame 25x25+0+25 image.jpg image.gif$ convert -mattecolor gray -frame 25x25+25+0 image.jpg image.gif // 将 gif 文件分析为一系列的单个图片 $ convert animation.gif frame%02d.gif // 创建一张空白图片 $ convert -size 800x600 xc:”#ddddff” ltblue.ppm$ convert -size 800x600 null:white white.ppm$ convert in.png -threshold 100% black.ppm // 与 in.png 同大小 Mac：文件校验终端命令查看文件哈希值 `MD5`$ md5 文件路径 `SHA1`$ shasum 文件路径或者$ openssl dgst -sha1 文件路径 `SHA256`$ openssl dgst -sha256 文件路径 iOS 马甲包（一）图片轻量级压缩改变 hash 值","tags":[]},{"title":" 添加垃圾代码\t\t","date":"2019-03-18T08:35:54.000Z","path":"2019/03/18/e6-b7-bb-e5-8a-a0-e5-9e-83-e5-9c-be-e4-bb-a3-e7-a0-81/","text":"方式 1： #!/usr/bin/env python# _*_ coding:utf-8 _*_ #第一步:首先生成一个500位的数组 驼峰类型的元素 用作文件名 eg:AsdfdfGsdimport randomimport os,sysimport string first = “ABCDEFGHIJKLMNOPQRSTUVWXYZ”second = “abcdefghijklmnopqrstuvwxyz”number = “345”index = 0array = []for i in range(500): final=(random.choice(first)) index = random.randint(3, 5) for i in range(index): final+=(random.choice(second)) final += (random.choice(first)) for i in range(index): final+=(random.choice(second)) array.append(final) print (array) #第二步: #用上边生成的数组来创建对应的.h和.m文件# -- coding: utf-8 --import randomimport osimport string #创建.h文件def text_createH(fileNmae,msg,msg1,propertyNumber,methodArray,msg3): full_path = sys.path[0] + ‘/ReplaceDemo/‘ + fileNmae + ‘.h’ file = open(full_path, ‘w’) file.write(‘//\\n// ‘+fileNmae+’.h\\n// SajiaoShopping\\n\\n// Created by 某 波 bo on 15/10/23.\\n// Copyright © 2017年 阿里郎. All rights reserved.\\n//\\n\\n’) file.write(msg) file.write(msg1) propryNameArray = [] for index in range(1,propertyNumber): propryNameArray.append(random.choice(array)) propryNameArray = list(set(propryNameArray)) for propertyName in propryNameArray: file.write(‘@property(nonatomic,strong)’+random.choice(classArray)+’ ‘+propertyName+’;\\n’) file.write(‘\\n\\n’) for methodName in methodArray: file.write(‘- (void)pushTo’+methodName+’VC:(NSDictionary )info;\\n’) file.write(msg3) file.close() print(‘Done’) #创建.m文件def text_createM(fileNmae,msg,msg1,methodArray,msg3): full_path = sys.path[0] + ‘/ReplaceDemo/‘ + fileNmae + ‘.m’ file = open(full_path, ‘w’) file.write(‘//\\n// ‘+fileNmae+’.m\\n// SajiaoShopping\\n\\n// Created by 某 波 bo on 15/10/23.\\n// Copyright © 2017年 阿里郎. All rights reserved.\\n//\\n\\n’) file.write(msg) file.write(msg1) for methodName in methodArray: file.write(‘- (void)pushTo’+methodName+’VC:(NSDictionary )info\\n{\\n\\n NSMutableArray array = [NSMutableArray array];\\n’) number = random.randint(3, 10) for i in range(1,number): file.write(‘ [array addObject:@”‘+random.choice(array)+’”];\\n’) file.write(‘\\n}\\n\\n’) file.write(msg3) file.close() print(‘Done’) classArray = [‘NSString’,’UILabel’,’NSDictionary’,’NSData’,’UIScrollView’,’UIView’]array = [‘HwxrFvrj’, ‘QnzduQbtdd’, ‘PvcrwLtqhf’, ‘UvdhDbjn’, ‘SuntmyTxvyzg’, ‘CvlxwBipbp’, ‘GzrdyzIbimvz’, ‘CqsjqMmgsp’, ‘OxaaeuWjhasc’, ‘NjiardRvwgbi’, ‘NcculmLtpljq’, ‘ApoqQrll’, ‘GkgokDyvjb’, ‘EblldkVouplj’, ‘KfdrFvnw’, ‘SfhyhObftc’, ‘SmruByoc’, ‘YzcccvXmpmit’, ‘OmqvaHpxat’, ‘XzytsUyvyd’, ‘MjforNnnyi’, ‘ZvjhuIdogs’, ‘BzfrxzSeahxc’, ‘PycycwFjtpny’, ‘XvngtoSedljr’, ‘DktiaCbucd’, ‘AqbplNuodc’, ‘MzkvgZuala’, ‘KdwzIoej’, ‘AaynatUpqcfd’, ‘IyvwhZvtjc’, ‘UmijGmsy’, ‘AoayndXxghym’]array = list(set(array)) for name in array: number = random.randint(3, 10) methodArray = [] for i in range(1,5): methodArray.append(random.choice(array)) methodArray = list(set(methodArray))#数组去重 text_createH(name+’ViewController’, ‘#import &lt;UIKit/UIKit.h&gt;\\n’,‘@interface ‘+name+ ‘ViewController:’+ ‘UIViewController\\n\\n’,number,methodArray,’\\n\\n@end’) text_createM(name+’ViewController’, ‘#import “‘+name+’ViewController.h”\\n\\n’ ‘@interface ‘+ name+’ViewController()\\n\\n @end\\n\\n’,‘@implementation ‘+name+’ViewController\\n\\n- (void)viewDidLoad { \\n\\n [super viewDidLoad];\\n\\n}\\n\\n’,methodArray,’\\n\\n@end’) full_path 代表垃圾文件生成路径，第一次 file.write 的是类的注释，包含工程名、类名、作者，这种方式生成的内容无意义，所以很可能过不了审核。脚本原文 方式 2： 使用 KLGenerateSpamCode 扫描工程中的代码，生成同等数量的 Category 文件，文件中即是同等方法数量的垃圾代码。 KLGenerateSpamCode 工程 -> Edit scheme -&gt; Run -&gt; Arguments Passed On Launch 添加。 Trash 是放垃圾代码的文件夹，trash 是分类名。 或者用终端执行命令 ./GenerateSpamCode /Users/CJ/Desktop/ReplaceDemo/ReplaceDemo -spamCodeOut /Users/CJ/Desktop/Trash trash 第一条路径是马甲包工程，第二条路径是存放垃圾代码目录路径。 两种方式都会自动在指定路径下生成 Trash 文件夹。","tags":[]},{"title":" NSProxy\t\t","date":"2019-03-18T06:54:27.000Z","path":"2019/03/18/nsproxy/","text":"NSProxy 是一个实现了 NSObject 协议类似于 NSObject 的根类。 NS_ROOT_CLASS@interface NSProxy { Class isa;} 苹果的官方文档： Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information. 看了这些描述我们应该能对 NSProxy 有个初步印象，它仅仅是个转发消息的场所，至于如何转发，取决于派生类的具体实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了。甚至也可以不去创建这些对象，去做任何你想做的事情，但是必须要实现它的 forwardInvocation: 和 methodSignatureForSelector: 方法。 一、用途1、多继承 大致过程就是让它持有要实现多继承的类的对象，然后用多个接口定义不同的行为，并让 Proxy 去实现这些接口，然后在转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。注意：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用 NSObject 类来实现。 NSObject 寻找方法顺序：本类 -> 父类 -> 动态方法解析 -> 备用对象 -> 消息转发； NSproxy 寻找方法顺序：本类-> 消息转发； 同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间。 首先新建两个基类如下： @implementation classA-(void)infoA{ NSLog(@”classA 卖水”);}@end @implementation classB -(void)infoB{ NSLog(@”classB 卖饭”);} @end 代理如下： @interface ClassProxy : NSProxy@property(nonatomic, strong, readonly) NSMutableArray targetArray;-(void)target:(id)target;-(void)handleTargets:(NSArray )targets; @end NSProxy 必须以子类的形式出现。 因为考虑到很可能还有其他的卖衣服的、卖鞋子的需要 ClassProxy 来代理，这边做了一个数组来存放需要代理的类。 @interface ClassProxy()@property (nonatomic, strong) NSMutableArray targetArray; // 多个 targets 皆可代理@property (nonatomic, strong) NSMutableDictionary methodDic;@property (nonatomic, strong) id target;@end 然后 target 和相对应的 method name 做了一个字典来存储，方便获取。 -(void)registMethodWithTarget:(id)target{ unsigned int countOfMethods = 0; Method method_list = class_copyMethodList([target class], &amp;countOfMethods); for (int i = 0; i&lt;countOfMethods; i++) { Method method = method_list[i]; //得到方法的符号 SEL sel = method_getName(method); //得到方法的符号字符串 const char sel_name = sel_getName(sel); //得到方法的名字 NSString * method_name = [NSString stringWithUTF8String:sel_name]; self.methodDic[method_name] = target; } free(method_list);} 然后就是最主要的两个方法 -(void)forwardInvocation:(NSInvocation )invocation{ SEL sel = invocation.selector; NSString methodName = NSStringFromSelector(sel); id target = self.methodDic[methodName]; if (target) { [invocation invokeWithTarget:target]; }}-(NSMethodSignature )methodSignatureForSelector:(SEL)sel{ NSMethodSignature Method; NSString *methodName = NSStringFromSelector(sel); id target = self.methodDic[methodName]; if (target) { Method = [target methodSignatureForSelector:sel]; } else{ Method = [super methodSignatureForSelector:sel]; } return Method;} methodSignatureForSelector: 得到对应的方法签名，通过 forwardInvocation: 转发。 调用和打印结果： - (void)viewDidLoad{ [super viewDidLoad]; \\[self classInheritance\\]; } /** * 多继承 /-(void)classInheritance{ classA A = [[classA alloc]init]; classB B = [[classB alloc]init]; ClassProxy proxy = [ClassProxy alloc]; \\[proxy handleTargets:@\\[A, B\\]\\]; \\[proxy performSelector:@selector(infoA)\\]; \\[proxy performSelector:@selector(infoB)\\]; } 2018-12-27 18:02:34.445 NSProxyStudy[18975:4587631] classA 卖水2018-12-27 18:02:34.446 NSProxyStudy[18975:4587631] classB 卖饭 以上就是利用 NSProxy 实现多继承。 2、避免循环应用 举一个比较常见的例子 NSTimer。 由于苹果在 iOS10 以上给出了 timer 的 block 方式，已经可以解决循环引用的问题。所以这里只是说明利用 NSProxy 如何解决循环引用，实际情况可直接使用系统的方法。 首先因为 NSTimer 创建的时候需要传入一个 target，并且持有它，而 target 本身也会持有 timer 所以会造成循环引用。所以我们将 target 用 NSProxy 的子类代替。如下： -(void)viewDidLoad{ [super viewDidLoad]; self.timer = [NSTimer timerWithTimeInterval:1 target:[WeakProxy proxyWithTarget:self] selector:@selector(invoked:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];}- (void)invoked:(NSTimer *)timer{ NSLog(@”1”);} 在 WeakProxy 中我们设定 target 为弱引用。 @interface WeakProxy ()@property (nonatomic, weak) id target;@end @implementation WeakProxy+(instancetype)proxyWithTarget:(id)target{ return [[self alloc] initWithTarget:target];} -(instancetype)initWithTarget:(id)target{ self.target = target; return self;} -(NSMethodSignature )methodSignatureForSelector:(SEL)sel{ return [self.target methodSignatureForSelector:sel];}-(void)forwardInvocation:(NSInvocation )invocation{ SEL sel = invocation.selector; if ([self.target respondsToSelector:sel]) { [invocation invokeWithTarget:self.target]; }}@end 然后同样利用上述两个方法进行消息转发即可。 3、AOP 要重点介绍的功能就是 AOP（Aspect Oriented Programming），它是可以通过预编译方式和运行时动态代理实现在不修改源代码的情况下给程序动态添加功能的一种技术。 iOS 中面向切片编程一般有两种方式 ，一种是直接基于 runtime 的 method-Swizzling 机制来实现方法替换从而达到 hook 的目的，另一种就是基于 NSProxy。 OC 的动态语言的核心部分应该就是 objc_msgSend 方法的调用了。该函数的声明大致如下： /** * 参数 1：接受消息的 target * 参数 2：要执行的 selector * 参数 3：要调用的方法 * 可变参数：若干个要传给 selector 的参数 */id objc_msgSend(id self, SEL _cmd, …) 只要我们能够 Hook 到对某个对象的 objc_msgSend 的调用，并且可以修改其参数甚至于修改成任意其他 selector 的 IMP，我们就实现了 AOP。 @interface MyProxy : NSProxy { id _innerObject; // 在内部持有要 hook 的对象}+(instancetype)proxyWithObj:(id)object;@end @interface Dog : NSObject-(NSString *)barking:(NSInteger)months;@end 实现部分： @implementation MyProxy+(instancetype)proxyWithObj:(id)object{ MyProxy proxy = [MyProxy alloc]; // 持有要 hook 的对象 proxy-&gt;_innerObject = object; // 注意返回的值是 Proxy 对象 return proxy;}- (NSMethodSignature )methodSignatureForSelector:(SEL)sel{ // 这里可以返回任何 NSMethodSignature 对象，也可以完全自己构造一个 return [_innerObject methodSignatureForSelector:sel];}- (void)forwardInvocation:(NSInvocation )invocation{ if([_innerObject respondsToSelector:invocation.selector]){ NSString selectorName = NSStringFromSelector(invocation.selector); NSLog(@”Before calling %@”,selectorName); [invocation retainArguments]; NSMethodSignature *sig = [invocation methodSignature]; // 获取参数个数，注意在本例里这里的值是 3，因为 objc_msgSend 隐含了 self、selector 参数 NSUInteger cnt = [sig numberOfArguments]; // 本例只是简单的将参数和返回值打印出来 for (int i = 0; i &lt; cnt; i++) { // 参数类型 const char * type = \\[sig getArgumentTypeAtIndex:i\\]; if(strcmp(type, &quot;@&quot;) == 0){ NSObject *obj; \\[invocation getArgument:&amp;obj atIndex:i\\]; // 这里输出的是：&quot;parameter (0)&apos;class is MyProxy&quot;，也证明了这是 objc_msgSend 的第一个参数 NSLog(@&quot;parameter (%d)&apos;class is %@&quot;, i, \\[obj class\\]); } else if(strcmp(type, &quot;:&quot;) == 0){ SEL sel; \\[invocation getArgument:&amp;sel atIndex:i\\]; // 这里输出的是:&quot;parameter (1) is barking:&quot;，也就是 objc_msgSend 的第二个参数 NSLog(@&quot;parameter (%d) is %@&quot;, i, NSStringFromSelector(sel)); } else if(strcmp(type, &quot;q&quot;) == 0){ int arg = 0; \\[invocation getArgument:&amp;arg atIndex:i\\]; // 这里输出的是:&quot;parameter (2) is int value is 4&quot;，稍后会看到我们在调用 barking 的时候传递的参数就是 4 NSLog(@&quot;parameter (%d) is int value is %d&quot;, i, arg); } } // 消息转发 \\[invocation invokeWithTarget:_innerObject\\]; const char *retType = \\[sig methodReturnType\\]; if(strcmp(retType, &quot;@&quot;) == 0){ NSObject *ret; \\[invocation getReturnValue:&amp;ret\\]; //这里输出的是:&quot;return value is wang wang!&quot; NSLog(@&quot;return value is %@&quot;, ret); } NSLog(@&quot;After calling %@&quot;, selectorName); } }@end @implementation Dog-(NSString *)barking:(NSInteger)months{ return months &gt; 3 ? @”wang wang!” : @”eng eng!”;}@end 函数的调用如下： Dog * dog = [MyProxy proxyWithObj:[Dog alloc]];[dog barking:4]; 上面的代码中，可以任意更改参数、调用的方法，甚至转发给其他类型的对象，这确实达到了 Hook 对象的目的，也就是可以实现 AOP 的功能了。 typedef void(^proxyBlock)(id target,SEL selector); NS_ASSUME_NONNULL_BEGIN @interface AOPProxy : NSProxy+(instancetype)proxyWithTarget:(id)target;-(void)inspectSelector:(SEL)selector preSelTask:(proxyBlock)preTask endSelTask:(proxyBlock)endTask;@end @interface AOPProxy ()@property (nonatomic, strong) id target;@property (nonatomic, strong) NSMutableDictionary preSelTaskDic;@property (nonatomic, strong) NSMutableDictionary endSelTaskDic;@end -(void)inspect{ NSMutableArray targtArray = [AOPProxy proxyWithTarget:[NSMutableArray arrayWithCapacity:1]]; [(AOPProxy )targtArray inspectSelector:@selector(addObject:) preSelTask:^(id target, SEL selector) { [target addObject:@”——-“]; NSLog(@”%@ 我加进来之前”, target); } endSelTask:^(id target, SEL selector) { [target addObject:@”——-“]; NSLog(@”%@ 我加进来之后”, target); }]; [targtArray addObject:@”我是一个元素”];} ( “——-“ ) 我加进来之前( “——-“, “\\U6211\\U662f\\U4e00\\U4e2a\\U5143\\U7d20”, “——-“ )我加进来之后 。 4、实现延迟初始化（Lazy Initialization） 使用场景： ①、在 [SomeClass lazy] 之后调用 doSomthing，首先进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用 init 初始化对象，然后将消息转发给代理对象 _object； ②、在 [SomeClass lazy] 之后调用 initWithXXX:，首先进入 forwardingTargetForSelector 返回 nil，然后进入 methodSignatureForSelector: 和 forwardInvocation: 保存自定义初始化方法的调用，最后调用 doSomthing，进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用自定义初始化方法，然后将消息转发给代理对象 _object。 SomeClass *object = [SomeClass lazy]; // other thing … [object doSomething]; // 在这里 object 才会调用初始化方法，然后调用 doSomething","tags":[]},{"title":" AOMultiproxier、HJProtocolDispatcher\t\t","date":"2019-03-18T05:40:07.000Z","path":"2019/03/18/aomultiproxier-e3-80-81hjprotocoldispatcher/","text":"Github：AOMultiproxier、HJProtocolDispatcher 协议实现分发器，能够轻易实现将协议事件分发给多个实现者。 一、AOMultiproxier.h#define AOMultiproxierForProtocol(__protocol__, …) ((AOMultiproxier &lt;__protocol__&gt; )[AOMultiproxier multiproxierForProtocol:@protocol(__protocol__) withObjects:((NSArray )[NSArray arrayWithObjects:__VA_ARGS__,nil])]) 调用类方法的宏定义。 @interface AOMultiproxier : NSProxy @property (nonatomic, strong, readonly) Protocol protocol; // 协议@property (nonatomic, strong, readonly) NSArray attachedObjects; // 协议方法实现者 + (instancetype)multiproxierForProtocol:(Protocol)protocol withObjects:(NSArray)objects;@end AOMultiproxier 继承自 NSProxy 类，声明了两个只读属性和一个初始化方法。 NS_ROOT_CLASS@interface NSProxy { Class isa;} NSProxy 是一个类似于 NSObject 的根类，实现了 NSObject 协议。 苹果的官方文档是这样描述它的： Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create. NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information. 相信看了这些描述应该能对 NSProxy 有个初步印象，它仅仅是个转发消息的场所，至于如何转发，取决于派生类到底如何实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了，甚至可以不去创建这些对象，去做任何你想做的事情，但是必须要实现他的 forwardInvocation: 和 methodSignatureForSelector: 方法。 二、AOMultiproxier.m@interface AOMultiproxier()@property (nonatomic, strong) Protocol protocol;@property (nonatomic, strong) NSOrderedSet objects;@end 私有 readwrite 属性。 + (instancetype)multiproxierForProtocol:(Protocol)protocol withObjects:(NSArray)objects{ // 调用实例方法 return [[super alloc] initWithProtocol:protocol objects:objects];;} - (instancetype)initWithProtocol:(Protocol)protocol objects:(NSArray)objects{ // 保存协议 _protocol = protocol; NSMutableArray * validObjects = \\[NSMutableArray array\\]; BOOL oneConforms = NO; for (id object in objects) { // 判断 object 是否遵守了 protocol 协议 if (\\[object conformsToProtocol:protocol\\]) { oneConforms = YES; } // 判断 object 是否遵守了 protocol 协议或者 protocol 的父协议 if (\\[self _object:object inheritsProtocolOrAncestorOfProtocol:protocol\\]) { \\[validObjects addObject:object\\]; } } // 没有任何对象遵守协议，触发断言 NSAssert(oneConforms, @&quot;You didn&apos;t attach any object that declares itself conforming to %@. At least one is needed.&quot;, NSStringFromProtocol(protocol)); _objects = \\[NSOrderedSet orderedSetWithArray:validObjects\\]; if (_objects.count &lt;= 0 || !oneConforms) return nil; return self; } 初始化方法，给属性赋值。判断对象数组 objects 里的对象是否能够遵守了协议。 + (BOOL)conformsToProtocol:(Protocol*)protocol{ return YES;} - (BOOL)conformsToProtocol:(Protocol *)aProtocol { return protocol_conformsToProtocol(self.protocol, aProtocol);} 重写方法。在此处一直返回 YES，且未调用。 - (NSArray *)attachedObjects{ return [self.objects array];} NSSet -》NSArray。 /** * 是否能够响应 selector 方法。 */- (BOOL)respondsToSelector:(SEL)selector{ BOOL responds = NO; // 是否是必须实现的协议方法（required） BOOL isMandatory = NO; // 获取方法描述 struct objc\\_method\\_description methodDescription = \\[self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory\\]; if (isMandatory) { responds = YES; } else if (methodDescription.name != NULL) { // 非必须实现的再检查 object 是否实现了协议方法 responds = \\[self _checkIfAttachedObjectsRespondToSelector:selector\\]; } return responds; } /** * 转发消息 */- (void)forwardInvocation:(NSInvocation *)anInvocation{ SEL selector = [anInvocation selector]; BOOL isMandatory = NO; struct objc\\_method\\_description methodDescription = \\[self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory\\]; // 方法描述获取失败，调用 super 触发 crash if (methodDescription.name == NULL) { \\[super forwardInvocation:anInvocation\\]; return; } BOOL someoneResponded = NO; for (id object in self.objects) { // 可以响应，由 object 调用协议方法 if (\\[object respondsToSelector:selector\\]) { \\[anInvocation invokeWithTarget:object\\]; someoneResponded = YES; } } // If a mandatory method has not been implemented by any attached object, this would provoke a crash // 如果没有 required 方法没有被实现，调用 super 触发 crash if (isMandatory &amp;&amp; !someoneResponded) { \\[super forwardInvocation:anInvocation\\]; } } /** * 获取方法签名，包含参数类型、返回值类型等信息。 */- (NSMethodSignature )methodSignatureForSelector:(SEL)selector{ NSMethodSignature theMethodSignature; BOOL isMandatory = NO; struct objc\\_method\\_description methodDescription = \\[self _methodDescriptionForSelector:selector isMandatory:&amp;isMandatory\\]; if (methodDescription.name == NULL) { return nil; } // 方法描述 -\\&gt; 方法签名 theMethodSignature = \\[NSMethodSignature signatureWithObjCTypes:methodDescription.types\\]; return theMethodSignature; } 消息转发核心方法。检查 selector 对应的方法描述是否正确，并对 required 方法未实现的情况做出处理。 /** * 返回方法描述 */- (struct objc_method_description)_methodDescriptionForSelector:(SEL)selector isMandatory:(BOOL *)isMandatory{ struct objc_method_description method = {NULL, NULL}; // First check on main protocol. 当前协议查找 method = \\[self _methodDescriptionInProtocol:self.protocol selector:selector isMandatory:isMandatory\\]; // If no method is known on main protocol, try on ancestor protocols. 在父协议查找 if (method.name == NULL) { unsigned int count = 0; Protocol * \\_\\_unsafe\\_unretained * list = protocol_copyProtocolList(self.protocol, &amp;count); for (NSUInteger i = 0; i &lt; count; i++) { Protocol * aProtocol = list\\[i\\]; // Skip root protocol if (\\[NSStringFromProtocol(aProtocol) isEqualToString:@&quot;NSObject&quot;\\]) continue; method = \\[self _methodDescriptionInProtocol:aProtocol selector:selector isMandatory:isMandatory\\]; // 找到了 if (method.name != NULL) { break; } } free(list); } return method; } /** * 获取方法描述 */- (struct objc_method_description)_methodDescriptionInProtocol:(Protocol )protocol selector:(SEL)selector isMandatory:(BOOL )isMandatory{ struct objc_method_description method = {NULL, NULL}; // 使用 runtime 方法获取 method = protocol_getMethodDescription(protocol, selector, YES, YES); if (method.name != NULL) { *isMandatory = YES; return method; } method = protocol_getMethodDescription(protocol, selector, NO, YES); if (method.name != NULL) { *isMandatory = NO; } return method; } 实际获取方法是 _methodDescriptionInProtocol:selector: isMandatory:，在方法内调用运行时方法 protocol_getMethodDescription，这个方法有四个参数，来看看各代表了什么。 /** * Returns a method description structure for a specified method of a given protocol. * * @param proto A protocol. * @param aSel A selector. * @param isRequiredMethod A Boolean value that indicates whether aSel is a required method. 标识是否是必须实现的 * @param isInstanceMethod A Boolean value that indicates whether aSel is an instance method. 标识是否是实例方法 * * @return An \\c objc_method_description structure that describes the method specified by \\e aSel, * \\e isRequiredMethod, and \\e isInstanceMethod for the protocol \\e p. * If the protocol does not contain the specified method, returns an \\c objc_method_description structure * with the value \\c {NULL, \\c NULL}. * * @note This function recursively searches any protocols that this protocol conforms to. /OBJC_EXPORT struct objc_method_descriptionprotocol_getMethodDescription(Protocol _Nonnull proto, SEL _Nonnull aSel, BOOL isRequiredMethod, BOOL isInstanceMethod) OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 注意第三、四个参数即可。 - (BOOL)_checkIfAttachedObjectsRespondToSelector:(SEL)selector{ for (id object in self.objects) { if ([object respondsToSelector:selector]) { return YES; } } return NO; } 检查 object 对象是否能够响应 selector 方法。 - (BOOL)_object:(id)object inheritsProtocolOrAncestorOfProtocol:(Protocol*)protocol{ // 在当前协议中查找 if ([object conformsToProtocol:protocol]) { return YES; } BOOL conforms = NO; unsigned int count = 0; Protocol * \\_\\_unsafe\\_unretained * list = protocol_copyProtocolList(protocol, &amp;count); // 在查找父协议中查找 for (NSUInteger i = 0; i &lt; count; i++) { Protocol * aProtocol = list\\[i\\]; // Skip root protocol. 如果查找到了 NSObject 协议，结束查找 if (\\[NSStringFromProtocol(aProtocol) isEqualToString:@&quot;NSObject&quot;\\]) continue; // 递归调用 if (\\[self _object:object inheritsProtocolOrAncestorOfProtocol:aProtocol\\]) { conforms = YES; break; } } free(list); return conforms; } 查找 object 是否实现了协议方法。 三、HJProtocolDispatcher.h#define AOProtocolDispatcher(__protocol__, …) \\ [ProtocolDispatcher dispatcherProtocol:@protocol(__protocol__) \\ toImplemertors:[NSArray arrayWithObjects:__VA_ARGS__, nil]] 同样的宏定义，这里用了 \\ 换行，更适合阅读。__VA_ARGS__ 是新的 C99 规范中新增的一个可变参数的宏，目前似乎只有 gcc 支持（VC6.0的编译器不支持），实现思想就是宏定义中参数列表的最后一个参数为 …。 四、HJProtocolDispatcher.m/** * 返回方法描述 /struct objc_method_description MethodDescriptionForSELInProtocol(Protocol protocol, SEL sel) { // required 方法 struct objc\\_method\\_description description = protocol_getMethodDescription(protocol, sel, YES, YES); if (description.types) { return description; } // optional 方法 description = protocol_getMethodDescription(protocol, sel, NO, YES); if (description.types) { return description; } // 未找到 return (struct objc\\_method\\_description){NULL, NULL}; } /** * 判断 protocol 是否包含 sel 方法 /BOOL ProtocolContainSel(Protocol protocol, SEL sel) { return MethodDescriptionForSELInProtocol(protocol, sel).types ? YES: NO;} 私有方法。 @interface ImplemertorContext : NSObject@property (nonatomic, weak) id implemertor; // 方法实现者，即最后调用方法的对象@end @implementation ImplemertorContext@end ImplemertorContext 是每个实现者的封装。 @interface ProtocolDispatcher () @property (nonatomic, strong) Protocol prococol; // 协议@property (nonatomic, strong) NSArray implemertors; // 实现者数组 @end @implementation ProtocolDispatcher + (id)dispatcherProtocol:(Protocol )protocol toImplemertors:(NSArray )implemertors{ return [[ProtocolDispatcher alloc] initWithProtocol:protocol toImplemertors:implemertors];} - (instancetype)initWithProtocol:(Protocol )protocol toImplemertors:(NSArray )implemertors{ if (self = [super init]) { self.prococol = protocol; NSMutableArray implemertorContexts = [NSMutableArray arrayWithCapacity:implemertors.count]; [implemertors enumerateObjectsUsingBlock:^(id implemertor, NSUInteger idx, BOOL _Nonnull stop) { ImplemertorContext *implemertorContext = [ImplemertorContext new]; implemertorContext.implemertor = implemertor; [implemertorContexts addObject:implemertorContext]; objc_setAssociatedObject(implemertor, _cmd, self, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }]; self.implemertors = [implemertorContexts copy]; } return self;} - (BOOL)respondsToSelector:(SEL)aSelector{ // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) { return [super respondsToSelector:aSelector]; } for (ImplemertorContext *implemertorContext in self.implemertors) { if (\\[implemertorContext.implemertor respondsToSelector:aSelector\\]) { return YES; } } return NO; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector{ // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) { return [super methodSignatureForSelector:aSelector]; } struct objc\\_method\\_description methodDescription = MethodDescriptionForSELInProtocol(self.prococol, aSelector); return \\[NSMethodSignature signatureWithObjCTypes:methodDescription.types\\]; } - (void)forwardInvocation:(NSInvocation *)anInvocation{ SEL aSelector = anInvocation.selector; // 如果协议未包含方法，直接调用 super if (!ProtocolContainSel(self.prococol, aSelector)) { \\[super forwardInvocation:anInvocation\\]; return; } for (ImplemertorContext *implemertorContext in self.implemertors) { if (\\[implemertorContext.implemertor respondsToSelector:aSelector\\]) { \\[anInvocation invokeWithTarget:implemertorContext.implemertor\\]; } } } 五、总结HJProtocolDispatcher 与 AOMultiproxier 的思想和功能大体相同。 AO 功能更齐全，它会去父协议中检查方法是否存在，且对 required 方法添加了逻辑判断。 AO 继承自 NSProxy，HJ 继承自 NSObject。NSObject 寻找方法顺序：本类-&gt;父类-&gt;动态方法解析-&gt;消息转发；NSproxy 顺序：本类-&gt;消息转发，同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间，所以 NSProxy 效率更高。","tags":[]},{"title":" 消息转发\t\t","date":"2019-03-17T15:51:48.000Z","path":"2019/03/17/e6-b6-88-e6-81-af-e8-bd-ac-e5-8f-91/","text":"文章：iOS 消息转发、Protocol 协议分发器 在开发过程中，可能遇到服务端返回数据中有 null，当取到 null 值并对 null 发送消息的时候，就可能出现 unrecognized selector sent to instance，导致应用 crash 的情况。 针对这种情况，在每次取值的时候去做判断处理又不大合适，在 GitHub上发现了 NullSafe。把这个文件拖到项目中，即使出现 null 的情况，也不会报出 unrecognized selector sent to instance 的问题。 消息转发的整个过程主要涉及的 3 个方法： +(BOOL)resolveInstanceMethod:(SEL)sel;-(id)forwardingTargetForSelector:(SEL)aSelector;-(void)forwardInvocation:(NSInvocation*)anInvocation; 其中在 +(BOOL)resolveInstanceMethod:(SEL)sel 的时候，会有相应的方法缓存操作，这个操作是系统帮我们做的。 一、消息转发过程首先贴一张消息转发的图，笔者聊到的内容会围绕着这张图展开。 下边分析消息转发的过程，以 [MyObjet Length] 为例： ①、首先 MyObjet 在调用 length方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，我们可以在这里动态添加方法，而且如果在这里动态添加方法成功后，系统会把动态添加的 length 方法进行缓存，当 MyObjet 再次调用 length 方法的时候，将不会调用 +(BOOL)resolveInstanceMethod:(SEL)sel。会直接调用动态添加成功的 length 方法。 ②、如果动态方法解析部分没有做操作，或者动态添加方法失败了的话，会进行寻找备援接收者的过程 -(id)forwardingTargetForSelector:(SEL)aSelector，这个过程用于寻找一个接收者，可以响应未知的方法。 ③、如果寻找备援接收者的过程中返回值为 nil 的话，那么会进入到完整的消息转发流程中。完整的消息转发流程：首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中，此对象包含选择子、目标（target）及参数。在出发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。 二、结合 MyObject 中的代码对消息转发流程进一步分析①、先看第一部分 MyObject 在调用 length 方法后，会先进行动态方法解析，调用 +(BOOL)resolveInstanceMethod:(SEL)sel，如果我们在这里为 MyObject 动态添加方法。那么也能处理消息。相关代码如下： (BOOL)resolveInstanceMethod:(SEL)sel{ printf(“%s:%s \\n”, __func__ ,NSStringFromSelector(sel).UTF8String); if (sel == @selector(length)) { BOOL success = class_addMethod(\\[self class\\], sel, (IMP)(length), &quot;q@:&quot;); if (success) { return success; } } return [super resolveInstanceMethod:sel];} 传入的 “q@:” 分别代表： q : 返回值 long long@ : 调用方法的的实例为对象类型: : 表示方法 下图表示了编码类型。 ②、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，会寻找备援接收者，调用 -(id)forwardingTargetForSelector:(SEL)aSelector，如果我们在这里为返回可以处理 length 的接收者。那么也能处理消息。相关代码如下： static NSArray * respondClasses; - (id)forwardingTargetForSelector:(SEL)aSelector { printf(&quot;%s:%s \\\\n&quot;, \\_\\_func\\_\\_ , NSStringFromSelector(aSelector).UTF8String); id forwardTarget = \\[super forwardingTargetForSelector:aSelector\\]; if (forwardTarget) { return forwardTarget; } Class someClass = \\[self myResponedClassForSelector:aSelector\\]; if (someClass) { forwardTarget = \\[someClass new\\]; } return forwardTarget; } - (Class)myResponedClassForSelector:(SEL)selector{ respondClasses = @[ [NSMutableArray class], [NSMutableDictionary class], [NSMutableString class], [NSNumber class], [NSDate class], [NSData class] ]; for (Class someClass in respondClasses) { if ([someClass instancesRespondToSelector:selector]) { return someClass; } } return nil;} +(BOOL)instancesRespondToSelector:(SEL)aSelector; 用于返回 Class 对应的实例能否响应 aSelector。 ③、MyObject 在调用 length 方法后，动态方法解析部分如果返回值为 NO 的时候，寻找备援接收者的返回值为 nil 的时候，会进行完整的消息转发流程。调用 -(void)forwardInvocation:(NSInvocation)anInvocation，这个过程会有一个插曲 -(NSMethodSignature)methodSignatureForSelector:(SEL)selector，只有我们返回了相应地 NSMethodSignature 实例的时候，完整地消息转发流程才能得以顺利完成。 -(NSMethodSignature*)methodSignatureForSelector:(SEL)selector。 摘抄自文档：This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding.If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 这个方法也会用于消息转发的时候，当 NSInvocation 对象必须创建的时候，如果我们的对象能够处理没有直接实现的方法，我们应该重写这个方法，返回一个合适的方法签名。 相关代码 - (void)forwardInvocation:(NSInvocation *)anInvocation{ printf(&quot;%s:%s \\\\n\\\\n\\\\n\\\\n&quot;, \\_\\_func\\_\\_ , NSStringFromSelector(anInvocation.selector).UTF8String); anInvocation.target = nil; \\[anInvocation invoke\\]; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)selector { NSMethodSignature *signature = \\[super methodSignatureForSelector:selector\\]; if (!signature) { Class responededClass = \\[self myResponedClassForSelector:selector\\]; if (responededClass) { @try { signature = \\[responededClass instanceMethodSignatureForSelector:selector\\]; } @catch (NSException *exception) { }@finally { } } } return signature; } - (Class)myResponedClassForSelector:(SEL)selector { respondClasses = @\\[ \\[NSMutableArray class\\], \\[NSMutableDictionary class\\], \\[NSMutableString class\\], \\[NSNumber class\\], \\[NSDate class\\], \\[NSData class\\] \\]; for (Class someClass in respondClasses) { if (\\[someClass instancesRespondToSelector:selector\\]) { return someClass; } } return nil; } 这里有一个不常用的 API：+(NSMethodSignature*)instanceMethodSignatureForSelector:(SEL)aSelector;，这个 API 通过 Class 及给定的 aSelector 返回一个包含实例方法标识描述的方法签名实例。 &lt;NSMethodSignature: 0x6000030a17c0&gt; number of arguments = 2 frame size = 224 is special struct return? NO return value: ——– ——– ——– ——– type encoding (f) ‘f’ flags {isFloat} modifiers {} frame {offset = 16, offset adjust = 0, size = 16, size adjust = -12} memory {offset = 0, size = 4} argument 0: ——– ——– ——– ——– type encoding (@) ‘@’ flags {isObject} modifiers {} frame {offset = 0, offset adjust = 0, size = 8, size adjust = 0} memory {offset = 0, size = 8} argument 1: ——– ——– ——– ——– type encoding (:) ‘:’ flags {} modifiers {} frame {offset = 8, offset adjust = 0, size = 8, size adjust = 0} memory {offset = 0, size = 8} NSInvocation。 仍然以myObject调用length方法为例。 - (void)forwardInvocation:(NSInvocation *)anInvocation中的 anInvocation 的信息如下： &lt;NSInvocation: 0x6000025b8140&gt;return value: {Q} 0target: {@} 0x60000322c360selector: {:} length > return value 指返回值，”Q” 表示返回值类型为 long long 类型；> target 指的是消息的接收者，”@”标识对象类型；> selector 指的是方法，”:”表示是方法，后边的 length 为方法名。 更多内容可见下图 NSInvocation 的 types： enum _NSObjCValueType { NSObjCNoType = 0, NSObjCVoidType = ‘v’, NSObjCCharType = ‘c’, NSObjCShortType = ‘s’, NSObjCLongType = ‘l’, NSObjCLonglongType = ‘q’, NSObjCFloatType = ‘f’, NSObjCDoubleType = ‘d’, NSObjCBoolType = ‘B’, NSObjCSelectorType = ‘:’, NSObjCObjectType = ‘@’, NSObjCStructType = ‘{‘, NSObjCPointerType = ‘^’, NSObjCStringType = ‘*’, NSObjCArrayType = ‘[‘, NSObjCUnionType = ‘(‘, NSObjCBitfield = ‘b’} API_DEPRECATED(“Not supported”, macos(10.0,10.5), ios(2.0,2.0), watchos(2.0,2.0), tvos(9.0,9.0)); 三、尚存疑点细心的读者可能会发现在首次消息转发的时候流程并不是 +[MyObject resolveInstanceMethod:]:length-[MyObject forwardingTargetForSelector:]:length-[MyObject forwardInvocation:]:length 而是 +[MyObject resolveInstanceMethod:]:length-[MyObject forwardingTargetForSelector:]:length+[MyObject resolveInstanceMethod:]:length+[MyObject resolveInstanceMethod:]:_forwardStackInvocation:-[MyObject forwardInvocation:]:length 查看了开源源码 NSObject.mm 相关源码如下： // Replaced by CF (returns an NSMethodSignature) (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { _objc_fatal(“-[NSObject methodSignatureForSelector:] “&quot;not available without CoreFoundation&quot;); } (void)forwardInvocation:(NSInvocation *)invocation { [self doesNotRecognizeSelector:(invocation ? [invocation selector] : 0)];}// Replaced by CF (throws an NSException) (void)doesNotRecognizeSelector:(SEL)sel { _objc_fatal(“-[%s %s]: unrecognized selector sent to instance %p”, object\\_getClassName(self), sel\\_getName(sel), self); } 四、NSNull+QiNullSafe.m根据 NullSafe 仿写的 NSNull+QiNullSafe.m。 NSNull+QiNullSafe.m 能够避免的问题有： NSNull *null = [NSNull null];[null performSelector:@selector(addObject:) withObject:@”aaa”];[null performSelector:@selector(setValue:forKey:) withObject:@”aaa”];[null performSelector:@selector(valueForKey:) withObject:@”aaa”];[null performSelector:@selector(length) withObject:nil];[null performSelector:@selector(integerValue) withObject:nil];[null performSelector:@selector(timeIntervalSinceNow) withObject:nil];[null performSelector:@selector(bytes) withObject:nil]; 五、NullSafe 是怎么处理 null 问题其实 NullSafe 处理 null 问题用的是消息转发的第三部分，走的是完整地消息转发流程。 不过我们开发过程中，如果可以的话，还是尽可能早地处理消息转发这部分，比如在动态方法解析的时候，动态添加方法（毕竟这一步系统可以为我们做方法的缓存处理）。 或者是在寻找备援接收对象的时候，返回能够响应未实现的方法的对象。 注意：相关的使用场景在测试的时候不要用，测试的时候尽可能还是要暴露出问题的。并且使用的时候，最好结合着异常日志上报。 六、单元测试- (void)testStringValue{ id null = [NSNull null]; NSString * string = \\[null stringValue\\]; XCTAssertNil(string); } - (void)testFloatValue{ id null = [NSNull null]; CGFloat f = \\[null floatValue\\]; XCTAssertEqualWithAccuracy(f, 0.0f, 0.0f); } - (void)testPerformSelector{ NSNull * null = [NSNull null]; [null performSelector:@selector(addObject:) withObject:@”aaa”];}","tags":[]},{"title":" SDWebImagePrefetcher\t\t","date":"2019-03-15T09:29:53.000Z","path":"2019/03/15/sdwebimageprefetcher/","text":"文章：SDWebImage源码解读之SDWebImagePrefetcher 我们先看看 SDWebImage主文件的组成模块： 可以看出来，每个模块即独立又相对关联，当最后拼接出 SDWebImageManager 的时候，我们就可以利用它来做一些有意思的事情。 本篇就主要讲解其中的一个使用场景：批量图片下载。 要做一个漫画 APP，漫画都是由图片组成的，每一个本漫画由很多章节组成，需要提供一个缓存功能，也就是把图片一组一组的下载下来。那么使用本篇的这个类就能完美的解决它的需求。 一、.h 文件@protocol SDWebImagePrefetcherDelegate @optional /** * Called when an image was prefetched. * * @param imagePrefetcher The current image prefetcher * @param imageURL The image url that was prefetched * @param finishedCount The total number of images that were prefetched (successful or not) * @param totalCount The total number of images that were to be prefetched * * 一张图片下载完成时调用 */- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher )imagePrefetcher didPrefetchURL:(nullable NSURL )imageURL finishedCount:(NSUInteger)finishedCount totalCount:(NSUInteger)totalCount; /** * Called when all images are prefetched. * @param imagePrefetcher The current image prefetcher * @param totalCount The total number of images that were prefetched (whether successful or not) * @param skippedCount The total number of images that were skipped * * 所有图片下载完成时调用 */- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(NSUInteger)totalCount skippedCount:(NSUInteger)skippedCount; @end 这个代理提供了两个方法来监听事件： 每下载完一张图片 下载完所有的图片 /** * Prefetch some URLs in the cache for future use. Images are downloaded in low priority. * * 在缓存中预存 urls 以供未来使用，低优先级下载图片。 */@interface SDWebImagePrefetcher : NSObject 属性： /** * The web image manager. 图片下载对象 /@property (strong, nonatomic, readonly, nonnull) SDWebImageManager manager; /** * Maximum number of URLs to prefetch at the same time. Defaults to 3. 并发最大下载数量 */@property (nonatomic, assign) NSUInteger maxConcurrentDownloads; /** * SDWebImageOptions for prefetcher. Defaults to SDWebImageLowPriority. 图片下载选项 */@property (nonatomic, assign) SDWebImageOptions options; /** * Queue options for Prefetcher. Defaults to Main Queue. 默认主队列 */@property (strong, nonatomic, nonnull) dispatch_queue_t prefetcherQueue; @property (weak, nonatomic, nullable) id delegate; 初始化： /** * Return the global image prefetcher instance. */+ (nonnull instancetype)sharedImagePrefetcher; /** * Allows you to instantiate a prefetcher with any arbitrary image manager. */- (nonnull instancetype)initWithImageManager:(nonnull SDWebImageManager *)manager NS_DESIGNATED_INITIALIZER; 方法： /** * Assign list of URLs to let SDWebImagePrefetcher to queue the prefetching, * currently one image is downloaded at a time, * and skips images for failed downloads and proceed to the next image in the list. * Any previously-running prefetch operations are canceled. * * @param urls list of URLs to prefetch */- (void)prefetchURLs:(nullable NSArray *)urls; /** * Assign list of URLs to let SDWebImagePrefetcher to queue the prefetching, * currently one image is downloaded at a time, * and skips images for failed downloads and proceed to the next image in the list. * Any previously-running prefetch operations are canceled. * * @param urls list of URLs to prefetch * @param progressBlock block to be called when progress updates; * first parameter is the number of completed (successful or not) requests, * second parameter is the total number of images originally requested to be prefetched * @param completionBlock block to be called when prefetching is completed * first param is the number of completed (successful or not) requests, * second parameter is the number of skipped requests */- (void)prefetchURLs:(nullable NSArray *)urls progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock; /** * Remove and cancel queued list */- (void)cancelPrefetching; 二、.m 文件@interface SDWebImagePrefetcher () @property (strong, nonatomic, nonnull) SDWebImageManager manager;@property (strong, atomic, nullable) NSArray&lt;NSURL &gt; *prefetchURLs; // may be accessed from different queue@property (assign, nonatomic) NSUInteger requestedCount; // 请求数量@property (assign, nonatomic) NSUInteger skippedCount; // 记录下载失败的次数，skip 表示跳过@property (assign, nonatomic) NSUInteger finishedCount; // 完成数量@property (assign, nonatomic) NSTimeInterval startedTime; // 开始时间@property (copy, nonatomic, nullable) SDWebImagePrefetcherCompletionBlock completionBlock;@property (copy, nonatomic, nullable) SDWebImagePrefetcherProgressBlock progressBlock; @end 初始化方法： + (nonnull instancetype)sharedImagePrefetcher { static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^{ instance = [self new]; }); return instance;} - (nonnull instancetype)init { return [self initWithImageManager:[SDWebImageManager new]];} - (nonnull instancetype)initWithImageManager:(SDWebImageManager *)manager { if ((self = [super init])) { _manager = manager; _options = SDWebImageLowPriority; _prefetcherQueue = dispatch_get_main_queue(); self.maxConcurrentDownloads = 3; } return self;} setter、getter 方法： - (void)setMaxConcurrentDownloads:(NSUInteger)maxConcurrentDownloads { self.manager.imageDownloader.maxConcurrentDownloads = maxConcurrentDownloads;} - (NSUInteger)maxConcurrentDownloads { return self.manager.imageDownloader.maxConcurrentDownloads;} setter 并没有要给这个属性赋值，getter 也不是返回该属性的值，而是设置实际下载对象的属性。 - (void)prefetchURLs:(nullable NSArray *)urls{ [self prefetchURLs:urls progress:nil completed:nil];} - (void)prefetchURLs:(nullable NSArray *)urls progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock{ [self cancelPrefetching]; // Prevent duplicate prefetch request self.startedTime = CFAbsoluteTimeGetCurrent(); self.prefetchURLs = urls; self.completionBlock = completionBlock; self.progressBlock = progressBlock; if (urls.count == 0) { if (completionBlock) { completionBlock(0,0); } } else { // Starts prefetching from the very first image on the list with the max allowed concurrency NSUInteger listCount = self.prefetchURLs.count; for (NSUInteger i = 0; i &lt; self.maxConcurrentDownloads &amp;&amp; self.requestedCount &lt; listCount; i++) { \\[self startPrefetchingAtIndex:i\\]; } } } 这个函数首先调用了 [self cancelPrefetching] 方法，看看该方法的实现： - (void)cancelPrefetching{ @synchronized(self) { self.prefetchURLs = nil; self.skippedCount = 0; self.requestedCount = 0; self.finishedCount = 0; } [self.manager cancelAll];} 说明调用该方法后，所以的未完成的下载都会清空，也就是说 SDWebImagePrefetcher 只处理一组 URLs，是无状态的下载。也就要求尽量一次性传入所有的 URLs。 那么如何实现支持多个图片并发下载呢？ 我们都知道 SDWebImageManager 的 loadImage 方法是异步执行的，因此只要多次调用 loadImage 方法就能做到了。 - (void)startPrefetchingAtIndex:(NSUInteger)index{ NSURL *currentURL; // 判断 index 是否越界 @synchronized(self) { if (index &gt;= self.prefetchURLs.count) return; currentURL = self.prefetchURLs\\[index\\]; // 已请求的个数 \\+ 1 self.requestedCount++; } // 使用 SDWebImageManager 下载图片 \\[self.manager loadImageWithURL:currentURL options:self.options progress:nil completed:^( UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) { // 只有当 finished = YES，完成个数 self.finishedCount + 1 if (!finished) return; self.finishedCount++; // 下载完成后，调用 progressBlock if (self.progressBlock) { self.progressBlock(self.finishedCount,(self.prefetchURLs).count); } if (!image) { // Add last failed. 下载失败 skip 数 + 1 self.skippedCount++; } if (\\[self.delegate respondsToSelector:@selector(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)\\]) { \\[self.delegate imagePrefetcher:self didPrefetchURL:currentURL finishedCount:self.finishedCount totalCount:self.prefetchURLs.count\\]; } // 如果 URLs 的数量大于已经下载的数量，就说明还有没下载完的任务，继续下载下一个 if (self.prefetchURLs.count &gt; self.requestedCount) { dispatch_async(self.prefetcherQueue, ^{ // we need dispatch to avoid function recursion call. This can prevent stack overflow even for huge urls list \\[self startPrefetchingAtIndex:self.requestedCount\\]; }); } // 当完成数等于已请求总数的时候，就宣告下载完毕 else if (self.finishedCount == self.requestedCount) { // 调用代理，下载已经完毕 \\[self reportStatus\\]; // 调用 completionBlock。这里把 completionBlock 和 progressBlock 都设为 nil 是为了避免循环引用 if (self.completionBlock) { self.completionBlock(self.finishedCount, self.skippedCount); self.completionBlock = nil; } self.progressBlock = nil; } }\\]; }","tags":[]},{"title":" SDWebImageManager\t\t","date":"2019-03-15T08:55:30.000Z","path":"2019/03/15/sdwebimagemanager/","text":"文章：SDWebImage源码解读之SDWebImageManager SDWebImageManager 是 SDWebImage 中最核心的类，但是源代码确是非常简单的。这一切都归功于功能的良好分类。 有了 SDWebImageManager 这个基石，就能做很多其他的有意思的事情。比如给各种 view 绑定一个 URL，就能显示图片的功能，有了 Options，就能满足多种应用场景的图片下载任务。 读源码既能让我们更好地使用该框架，又能学到很多知识，还能让我们懂得如何去扩充现有的功能。 一、.h 文件typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) { /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won’t keep trying. * This flag disable this blacklisting. * * 每一个下载都会提供一个 URL，如果这个 URL 是错误，SD 就会把它放入到黑名单之中，黑名单中的 URL 是不会再次进行下载的 * 但是，当设置了该选项时，SD 会将其在黑名单中移除，重新下载该 URL */ SDWebImageRetryFailed = 1 &lt;&lt; 0, /\\*\\* \\* By default, image downloads are started during UI interactions, this flags disable this feature, \\* leading to delayed download on UIScrollView deceleration for instance. \\* \\* 一般来说，下载都是按照一定的先后顺序开始的，但是该选项能够延迟下载，也就说他的权限比较低，权限比他高的在他前边下载 */ SDWebImageLowPriority = 1 &lt;&lt; 1, /\\*\\* \\* This flag disables on-disk caching after the download finished, only cache in memory \\* \\* 该选项要求 SD 只把图片缓存到内存中，不缓存到 disk 中 */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, /\\*\\* \\* This flag enables progressive download, the image is displayed progressively during download as a browser would do. \\* By default, the image is only displayed once completely downloaded. \\* \\* 给下载添加进度。默认情况下，图像只显示一次完全下载。 */ SDWebImageProgressiveDownload = 1 &lt;&lt; 3, /\\*\\* \\* Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. \\* The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. \\* This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. \\* If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. \\* \\* Use this flag only if you can&apos;t make your URLs static with embedded cache busting parameter. \\* \\* 有这么一种使用场景，如果一个图片的资源发生了改变。但是 url 并没有变，我们就可以使用该选项来刷新数据了 */ SDWebImageRefreshCached = 1 &lt;&lt; 4, /\\*\\* \\* In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for \\* extra time in background to let the request finish. If the background task expires the operation will be cancelled. \\* 支持切换到后台也能下载 */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, /\\*\\* \\* Handles cookies stored in NSHTTPCookieStore by setting NSMutableURLRequest.HTTPShouldHandleCookies = YES; \\* \\* 使用Cookies */ SDWebImageHandleCookies = 1 &lt;&lt; 6, /\\*\\* \\* Enable to allow untrusted SSL certificates. Useful for testing purposes. Use with caution in production. \\* \\* 允许验证证书 */ SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, /\\*\\* \\* By default, images are loaded in the order in which they were queued. This flag moves them to the front of the queue. \\* 高权限 */ SDWebImageHighPriority = 1 &lt;&lt; 8, /\\*\\* \\* By default, placeholder images are loaded while the image is loading. This flag will delay the loading \\* of the placeholder image until after the image has finished loading. \\* \\* 一般情况下，placeholder image 都会在图片下载完成前显示，该选项将设置 placeholder image 在下载完成之后才能显示 */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, /\\*\\* \\* We usually don&apos;t call transformDownloadedImage delegate method on animated images, \\* as most transformation code would mangle it. \\* Use this flag to transform them anyway. \\* \\* 使用该属性来自由改变图片，但需要使用 transformDownloadedImage delegate */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, /\\*\\* \\* By default, image is added to the imageView after download. But in some cases, we want to \\* have the hand before setting the image (apply a filter or add it with cross-fade animation for instance) \\* Use this flag if you want to manually set the image in the completion when success \\* \\* 该选项允许我们在图片下载完成后不会立刻给 view 设置图片，比较常用的使用场景是给赋值的图片添加动画 */ SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11, /\\*\\* \\* By default, images are decoded respecting their original size. On iOS, this flag will scale down the \\* images to a size compatible with the constrained memory of devices. \\* If \\`SDWebImageProgressiveDownload\\` flag is set the scale down is deactivated. \\* \\* 压缩大图片 */ SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12, /\\*\\* \\* By default, we do not query disk data when the image is cached in memory. This mask can force to query disk data at the same time. \\* This flag is recommend to be used with \\`SDWebImageQueryDiskSync\\` to ensure the image is loaded in the same runloop. \\* \\* 默认情况下，当图像缓存在内存中时，不查询 disk 数据。此枚举值可以强制同时查询 disk 数据。 \\* 建议将此标志与 &apos;sdwebimagequerydisksync&apos; 一起使用，以确保在同一个 runloop 中加载图像。 */ SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13, /\\*\\* \\* By default, we query the memory cache synchronously, disk cache asynchronously. This mask can force to query disk cache synchronously to ensure that image is loaded in the same runloop. \\* This flag can avoid flashing during cell reuse if you disable memory cache or in some other cases. \\* \\* 默认情况下，在内存查找时是同步，在硬盘查找时是异步。这个枚举值强制同步查找 disk，以确保在同一个 runloop 中加载图像。 */ SDWebImageQueryDiskSync = 1 &lt;&lt; 14, /\\*\\* \\* By default, when the cache missed, the image is download from the network. This flag can prevent network to load from cache only. \\* 只从缓存中取，不使用网络 */ SDWebImageFromCacheOnly = 1 &lt;&lt; 15, /\\*\\* \\* By default, when you use \\`SDWebImageTransition\\` to do some view transition after the image load finished, this transition is only applied for image download from the network. This mask can force to apply view transition for memory and disk cache as well. \\* &apos;SDWebImageTransition&apos; 只应用于网络加载图片，此枚举值使得同样应用于 memory 和 disk 缓存 */ SDWebImageForceTransition = 1 &lt;&lt; 16 }; SDWebImageOptions 作为下载的选项提供了非常多的子项。 typedef void(^SDExternalCompletionBlock)(UIImage _Nullable image, NSError _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL); typedef void(^SDInternalCompletionBlock)(UIImage _Nullable image, NSData _Nullable data, NSError _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL _Nullable imageURL); typedef NSString _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL _Nullable url); typedef NSData _Nullable(^SDWebImageCacheSerializerBlock)(UIImage _Nonnull image, NSData _Nullable data, NSURL _Nullable imageURL); 在平时的开发中，使用 Block 可以参考上边的使用方法，XXXxxxCompletionBlock 这种命名应该是 Apple 的风格。 @protocol SDWebImageManagerDelegate @optional /** * Controls which image should be downloaded when the image is not found in the cache. * * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied. * * 在缓存中没发现图片，控制是否通过网络下载该图片。如果没有实现这个方法，默认为 YES */- (BOOL)imageManager:(nonnull SDWebImageManager )imageManager shouldDownloadImageForURL:(nullable NSURL )imageURL; /** * Controls the complicated logic to mark as failed URLs when download error occur. * If the delegate implement this method, we will not use the built-in way to mark URL as failed based on error code; * * @return Whether to block this url or not. Return YES to mark this URL as failed. * * 控制在发生错误的时候标记为失败 url 的复杂逻辑 */- (BOOL)imageManager:(nonnull SDWebImageManager )imageManager shouldBlockFailedURL:(nonnull NSURL )imageURL withError:(nonnull NSError *)error; /** * Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory. * NOTE: This method is called from a global queue in order to not to block the main thread. * * @return The transformed image object. * * 网络下载之后，缓存之前，自由转换图片 */- (nullable UIImage )imageManager:(nonnull SDWebImageManager )imageManager transformDownloadedImage:(nullable UIImage )image withURL:(nullable NSURL )imageURL; @end 使用协议增加了我们编程的灵活性，SDWebImageManagerDelegate 提供了三个方法。 /** * The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. * It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). * You can use this class directly to benefit from web image downloading with caching in another context than * a UIView. * * Here is a simple example of how to use SDWebImageManager: * * @code SDWebImageManager manager = [SDWebImageManager sharedManager];[manager loadImageWithURL:imageURL options:0 progress:nil completed:^(UIImage \\image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) { if (image) { // do something with image } }]; * @endcode */@interface SDWebImageManager : NSObject 1、属性 @property (strong, nonatomic, readonly, nullable) SDImageCache imageCache; // 缓存对象@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader imageDownloader; // 下载对象 /** * The cache filter is a block used each time SDWebImageManager need to convert an URL into a cache key. This can * be used to remove dynamic part of an image URL. * * 每次 SDWebImageManager 需要将 URL 转换为缓存 key 时使用的 block。这可用于删除图像 URL 的动态部分。 * * The following example sets a filter in the application delegate that will remove any query-string from the * URL before to use it as a cache key: * * @code SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL * _Nullable url) { url = \\[\\[NSURL alloc\\] initWithScheme:url.scheme host:url.host path:url.path\\]; return \\[url absoluteString\\]; }; * @endcode */@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter; /** * The cache serializer is a block used to convert the decoded image, the source downloaded data, to the actual data used for storing to the disk cache. If you return nil, means to generate the data from the image instance, see `SDImageCache`. * For example, if you are using WebP images and facing the slow decoding time issue when later retriving from disk cache again. You can try to encode the decoded image to JPEG/PNG format to disk cache instead of source downloaded data. * @note The `image` arg is nonnull, but when you also provide a image transformer and the image is transformed, the `data` arg may be nil, take attention to this case. * @note This method is called from a global queue in order to not to block the main thread. * @code SDWebImageManager.sharedManager.cacheSerializer = ^NSData _Nullable( UIImage _Nonnull image, NSData _Nullable data, NSURL _Nullable imageURL) { SDImageFormat format = [NSData sd_imageFormatForImageData:data]; switch (format) { case SDImageFormatWebP: return image.images ? data : nil; default: return data; } }; * @endcode * The default value is nil. Means we just store the source downloaded data to disk cache. */@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer; 二、.m 文件1、SDWebImageCombinedOperation @interface SDWebImageCombinedOperation : NSObject @property (assign, nonatomic, getter = isCancelled) BOOL cancelled;@property (strong, nonatomic, nullable) SDWebImageDownloadToken downloadToken;@property (strong, nonatomic, nullable) NSOperation cacheOperation;@property (weak, nonatomic, nullable) SDWebImageManager *manager; @end SDWebImageCombinedOperation 是对每一个下载任务的封装，重要的是它提供了一个取消功能。 2、属性 @interface SDWebImageManager () @property (strong, nonatomic, readwrite, nonnull) SDImageCache imageCache;@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader imageDownloader;@property (strong, nonatomic, nonnull) NSMutableSet failedURLs;@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation &gt; *runningOperations;@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe @end 3、初始化 + (nonnull instancetype)sharedManager { static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^{ instance = [self new]; }); return instance;} - (nonnull instancetype)init { SDImageCache cache = [SDImageCache sharedImageCache]; SDWebImageDownloader downloader = [SDWebImageDownloader sharedDownloader]; return [self initWithCache:cache downloader:downloader];} - (nonnull instancetype)initWithCache:(nonnull SDImageCache )cache downloader:(nonnull SDWebImageDownloader )downloader { if ((self = [super init])) { _imageCache = cache; _imageDownloader = downloader; _failedURLs = [NSMutableSet new]; _failedURLsLock = dispatch_semaphore_create(1); _runningOperations = [NSMutableSet new]; _runningOperationsLock = dispatch_semaphore_create(1); } return self;} 4、URL -&gt; key /** * 缓存 key */- (nullable NSString )cacheKeyForURL:(nullable NSURL )url { if (!url) { return @””; } if (self.cacheKeyFilter) { return self.cacheKeyFilter(url); } else { return url.absoluteString; } } 5、缩放图片 - (nullable UIImage )scaledImageForKey:(nullable NSString )key image:(nullable UIImage *)image{ // 调用 SDWebImageCompat 方法 return SDScaledImageForKey(key, image);} 6、查看图片是否已经缓存 /** * 先内存后硬盘 */- (void)cachedImageExistsForURL:(nullable NSURL )url completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock{ NSString key = [self cacheKeyForURL:url]; BOOL isInMemoryCache = (\\[self.imageCache imageFromMemoryCacheForKey:key\\] != nil); // 内存中有缓存 if (isInMemoryCache) { // making sure we call the completion block on the main queue dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ if (completionBlock) { completionBlock(YES); } }); return; } // 硬盘中有缓存 \\[self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) { // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) { completionBlock(isInDiskCache); } }\\]; } 7、查看是否已经缓存到了硬盘 - (void)diskImageExistsForURL:(nullable NSURL )url completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock{ NSString key = [self cacheKeyForURL:url]; // 缓存对象的方法 \\[self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) { // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch if (completionBlock) { completionBlock(isInDiskCache); } }\\]; } SDWebImageDownloadToken \\*subOperationToken = \\[self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage \\*downloadedImage, NSData \\*downloadedData, NSError \\*error, BOOL finished) { \\_\\_strong \\_\\_typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) { // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data } else if (error) { \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url\\]; if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost) { @synchronized (self.failedURLs) { \\[self.failedURLs addObject:url\\]; } } } else { if ((options &amp; SDWebImageRetryFailed)) { @synchronized (self.failedURLs) { \\[self.failedURLs removeObject:url\\]; } } BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) { // Image refresh hit the NSURLCache cache, do not call the completion block } else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; \\[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)\\]) { dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_HIGH, 0), ^{ UIImage *transformedImage = \\[self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url\\]; if (transformedImage &amp;&amp; finished) { BOOL imageWasTransformed = !\\[transformedImage isEqual:downloadedImage\\]; // pass nil if the image was transformed, so we can recalculate the data from the image \\[self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil\\]; } \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\\]; }); } else { if (downloadedImage &amp;&amp; finished) { \\[self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil\\]; } \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\\]; } } if (finished) { \\[self safelyRemoveOperationFromRunning:strongOperation\\]; } }\\]; operation.cancelBlock = ^{ \\[self.imageDownloader cancel:subOperationToken\\]; \\_\\_strong \\_\\_typeof(weakOperation) strongOperation = weakOperation; \\[self safelyRemoveOperationFromRunning:strongOperation\\]; }; } else if (cachedImage) { \\_\\_strong \\_\\_typeof(weakOperation) strongOperation = weakOperation; \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url\\]; \\[self safelyRemoveOperationFromRunning:operation\\]; } else { // Image not in cache and download disallowed by delegate /// (8.4).既没有缓存也下载了代理不允许的图片 \\_\\_strong \\_\\_typeof(weakOperation) strongOperation = weakOperation; \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url\\]; \\[self safelyRemoveOperationFromRunning:operation\\]; } }\\]; return operation; } 8、核心下载方法 - (id )loadImageWithURL:(nullable NSURL )url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock{ // Invoking this method without a completedBlock is pointless /\\ ①、如果想预先下载图片，使用 [SDWebImagePrefetcher prefetchURLs] 取代本方法 预下载图片是有很多种使用场景的，当我们使用 SDWebImagePrefetcher 下载图片后，之后使用该图片时就不用再用网络下载了 */ NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -\\[SDWebImagePrefetcher prefetchURLs\\] instead&quot;); // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString. /\\* ②、XCode 有时候经常会犯一些错误，当用户给 url 赋值了字符串的时候，XCode 也没有报错，因此这里提供一种错误修正的处理 */ if (\\[url isKindOfClass:NSString.class\\]) { url = \\[NSURL URLWithString:(NSString *)url\\]; } // Prevents app crashing on argument type error like sending NSNull instead of NSURL /\\* ③、防止参数的其他错误 */ if (!\\[url isKindOfClass:NSURL.class\\]) { url = nil; } /\\* ④、operation 的类型是 SDWebImageCombinedOperation，是一个封装的对象，并不是一个 NSOperation */ SDWebImageCombinedOperation *operation = \\[SDWebImageCombinedOperation new\\]; operation.manager = self; /\\* ⑤、在图片的下载中，会有一些下载失败的情况，这时候我们把这些下载失败的 url 放到一个集合中去，也就是加入了黑名单中 默认是不会再继续下载黑名单中的 url 了，但是也有例外，当 options被设置为 SDWebImageRetryFailed 的时候，会尝试进行重新下载。 */ BOOL isFailedUrl = NO; if (url) { LOCK(self.failedURLsLock); isFailedUrl = \\[self.failedURLs containsObject:url\\]; UNLOCK(self.failedURLsLock); } /\\* ⑥、会有两种情况让我们停止下载这个 rul 指定的图片： \\- url 的长度为 0 \\- options 并没有选择 SDWebImageRetryFailed 且这个 url 在黑名单之中 调用完成 Block，直接返回 operation */ if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) { \\[self callCompletionBlockForOperation:operation completion:completedBlock error:\\[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil\\] url:url\\]; return operation; } /\\* ⑦、排除了所有的错误可能后，我们就先把这个 operation 添加到正在运行操作的数组中 这里没有判断 self.runningOperations 是否包含了 operation，说明肯定会在下边的代码中做判断，如果存在就删除 operation */ LOCK(self.runningOperationsLock); \\[self.runningOperations addObject:operation\\]; UNLOCK(self.runningOperationsLock); NSString *key = \\[self cacheKeyForURL:url\\]; SDImageCacheOptions cacheOptions = 0; /\\* 将 Manager 枚举值转成 Cache 枚举值，实际上就是 0 |= xxx */ if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory; if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync; if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages; __weak SDWebImageCombinedOperation *weakOperation = operation; /\\* ⑧、self.imageCache 的 queryCacheOperationForKey 方法是异步的获取指定 key 的图片 但是这个方法的 operation 是同步返回的，也就是说下边的代码会直接执行到 return 那里。 这个 Block 会在查询完指定的 key 的图片后回调，由 dispatch_async(self.ioQueue, ^{` // 这个可以看出，是在异步线程采用串行的方式在调用，任务在 self.imageCache 的 ioQueue 中一个一个执行，是线程安全的 }; */ operation.cacheOperation = \\[self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage \\*cachedImage, NSData \\*cachedData, SDImageCacheType cacheType) { \\_\\_strong \\_\\_typeof(weakOperation) strongOperation = weakOperation; /\\* (⑧.1)、如果每次调用 loadImage 方法都会生成一个 operation，如果我们想取消某个下载任务，在设计上来说，只要把响应的operation.isCancelled 设置为 NO，那么下载就会被取消。 */ if (!strongOperation || strongOperation.isCancelled) { \\[self safelyRemoveOperationFromRunning:strongOperation\\]; return; } // Check whether we should download image from network /\\* (⑧.2)、代码来到这里，我们就要根据是否有缓存的图片来做出响应的处理。 可以从网络下载 &amp;&amp; （如果没有获取到缓存图片 || 需要刷新缓存图片） &amp;&amp; 根据 delegate 的 imageManager:shouldDownloadImageForURL: 获取是否下载的权限 -&gt; 返回 YES，就继续下载。 */ BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly)) &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (!\\[self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)\\] || \\[self.delegate imageManager:self shouldDownloadImageForURL:url\\]); // 需要重新下载 if (shouldDownload) { /\\* (⑧.2.1)、这里需要注意了，当图片已经下载 &amp;&amp; Options == SDWebImageRefreshCached 就会触发一次 completionBlock 回调，这说明这个下载的回调不是只触发一次的。 如果使用了 dispatch\\_group\\_enter 和 dispatch\\_group\\_leave 就一定要注意了。 */ if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) { // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image AND try to re-download it in order to let a chance to NSURLCache to refresh it from server. \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url\\]; } // download if no image or requested to refresh anyway, and download allowed by delegate /\\* (⑧.2.2)、这里是 SDWebImageOptions 到 SDWebImageDownloaderOptions 的转换 其实就是 0 |= xxx */ SDWebImageDownloaderOptions downloaderOptions = 0; if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; /* (⑧.2.3)、已经缓存且 SDWebImageRefreshCached 的比较特殊 */ if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) { // force progressive off if image already cached but forced refreshing /\\* SDWebImageDownloaderProgressiveDownload = 1&lt;&lt;1，由于当 options == SDWebImageRefreshCached 时， downloaderOptions |= SDWebImageDownloaderUseNSURLCache (1 &lt;&lt; 2) 00000000 | 00000100 =&gt; 00000100 ~SDWebImageDownloaderProgressiveDownload : ~ 00000010 =&gt; 111111101 00000100 &amp; 11111101 =&gt; 00000100 */ downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing /\\* 00000100 | 00001000 =&gt; 00001100 通过这种位的运算，就能够给同一个值赋值两种转态 */ downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; } // \\`SDWebImageCombinedOperation\\` -&gt; \\`SDWebImageDownloadToken\\` -&gt; \\`downloadOperationCancelToken\\`, which is a \\`SDCallbacksDictionary\\` and retain the completed block below, so we need weak-strong again to avoid retain cycle __weak typeof(strongOperation) weakSubOperation = strongOperation; /* (⑧.2.4)、下载图片 */ strongOperation.downloadToken = \\[self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage \\*downloadedImage, NSData \\*downloadedData, NSError *error, BOOL finished) { __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation; if (!strongSubOperation || strongSubOperation.isCancelled) { // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data } else if (error) { /\\* (⑧.2.4.1)、发生错误就返回 */ \\[self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url\\]; BOOL shouldBlockFailedURL; // Check whether we should block failed url if (\\[self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)\\]) { shouldBlockFailedURL = \\[self.delegate imageManager:self shouldBlockFailedURL:url withError:error\\]; } else { /* (⑧.2.4.2)、除了下边这几种情况之外的情况则把 url 加入黑名单 */ shouldBlockFailedURL = ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost &amp;&amp; error.code != NSURLErrorNetworkConnectionLost); } // 添加到黑名单 if (shouldBlockFailedURL) { LOCK(self.failedURLsLock); \\[self.failedURLs addObject:url\\]; UNLOCK(self.failedURLsLock); } } else { /\\* (⑧.2.4.3)、如果是 SDWebImageRetryFailed 就在黑名单中移除，不管有没有 */ if ((options &amp; SDWebImageRetryFailed)) { LOCK(self.failedURLsLock); \\[self.failedURLs removeObject:url\\]; UNLOCK(self.failedURLsLock); } BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale. if (self != \\[SDWebImageManager sharedManager\\] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) { downloadedImage = \\[self scaledImageForKey:key image:downloadedImage\\]; } if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) { // Image refresh hit the NSURLCache cache, do not call the completion block } /* 要不要修改图片，这个修改图片完全由代理来操作 */ else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; \\[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)\\]) { dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_HIGH, 0), ^{ @autoreleasepool { UIImage *transformedImage = \\[self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url\\]; if (transformedImage &amp;&amp; finished) { BOOL imageWasTransformed = !\\[transformedImage isEqual:downloadedImage\\]; NSData *cacheData; // pass nil if the image was transformed, so we can recalculate the data from the image if (self.cacheSerializer) { cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url); } else { cacheData = (imageWasTransformed ? nil : downloadedData); } \\[self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil\\]; } \\[self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\\]; } }); } else { if (downloadedImage &amp;&amp; finished) { if (self.cacheSerializer) { dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_HIGH, 0), ^{ @autoreleasepool { NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url); \\[self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil\\]; } }); } else { \\[self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil\\]; } } \\[self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\\]; } } /\\* (⑧.2.4.4)、完成了就把该任务从正运行着的数组中删除 */ if (finished) { \\[self safelyRemoveOperationFromRunning:strongSubOperation\\]; } }\\]; } else if (cachedImage) { \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url\\]; \\[self safelyRemoveOperationFromRunning:strongOperation\\]; } else { // Image not in cache and download disallowed by delegate \\[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url\\]; \\[self safelyRemoveOperationFromRunning:strongOperation\\]; } }\\]; return operation; } 对于一个比较复杂的函数，往往只需要做下边三件事就可以了： 处理参数相关的异常 处理复杂的逻辑 返回数据。 这三条适合所有的函数。 9、保存图片到缓存区 - (void)saveImageToCache:(nullable UIImage )image forURL:(nullable NSURL )url{ if (image &amp;&amp; url) { NSString *key = [self cacheKeyForURL:url]; [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil]; }} 10、取消所有的下载 - (void)cancelAll{ LOCK(self.runningOperationsLock); NSSet *copiedOperations = [self.runningOperations copy]; UNLOCK(self.runningOperationsLock); // This will call \\`safelyRemoveOperationFromRunning:\\` and remove from the array \\[copiedOperations makeObjectsPerformSelector:@selector(cancel)\\]; } 11、查看是否下载完毕 - (BOOL)isRunning{ BOOL isRunning = NO; LOCK(self.runningOperationsLock); isRunning = (self.runningOperations.count &gt; 0); UNLOCK(self.runningOperationsLock); return isRunning;} 12、安全移除任务 - (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation{ if (!operation) { return; } LOCK(self.runningOperationsLock); [self.runningOperations removeObject:operation]; UNLOCK(self.runningOperationsLock);} 13、回调 - (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation)operation completion:(nullable SDInternalCompletionBlock)completionBlock error:(nullable NSError )error url:(nullable NSURL *)url{ [self callCompletionBlockForOperation:operation completion:completionBlock image:nil data:nil error:error cacheType:SDImageCacheTypeNone finished:YES url:url];} - (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation)operation completion:(nullable SDInternalCompletionBlock)completionBlock image:(nullable UIImage )image data:(nullable NSData )data error:(nullable NSError )error cacheType:(SDImageCacheType)cacheType finished:(BOOL)finished url:(nullable NSURL *)url { dispatch_main_async_safe(^{ if (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) { completionBlock(image, data, error, cacheType, finished, url); } });} 14、SDWebImageCombinedOperation 实现方法 - (void)cancel{ @synchronized(self) { self.cancelled = YES; if (self.cacheOperation) { [self.cacheOperation cancel]; self.cacheOperation = nil; } if (self.downloadToken) { [self.manager.imageDownloader cancel:self.downloadToken]; } [self.manager safelyRemoveOperationFromRunning:self]; }} 三、问题SD 在特定使用场景会崩溃的情况。（新版 v4.4.2 没有该问题） - (void)test{ NSURL *url = [NSURL URLWithString:@”//upload-images.jianshu.io/upload_images/1432482-dcc38746f56a89ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240”]; SDWebImageManager *manager = \\[SDWebImageManager sharedManager\\]; dispatch\\_group\\_t group = dispatch\\_group\\_create(); dispatch\\_group\\_enter(group); \\[manager loadImageWithURL:url options:SDWebImageRefreshCached progress:nil completed:^(UIImage * \\_Nullable image, NSData * \\_Nullable data, NSError * \\_Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * \\_Nullable imageURL) { dispatch\\_group\\_leave(group); }\\]; dispatch\\_group\\_notify(group, dispatch\\_get\\_main_queue(), ^{ NSLog(@&quot;下载完成了&quot;); }); } 使用 dispatch_group_t、dispatch_group_enter、dispatch_group_leave 的目的是等待所有的异步任务完成。 enter 和 leave 方法必须成对出现，如果调用 leave 的次数多于 enter 就会崩溃。当我们使用 SD 时，如果 Options 设置为SDWebImageRefreshCached，那么这个 completionBlock 至少会调用两次，首先返回缓存中的图片，其次在下载完成后再次调用 Block，这也就是崩溃的原因。 要想重现上边方法的崩溃，等图片下载完之后，再重新新调用该方法就行。 SD 默认下载的图片会缓存进内存和 disk 中。","tags":[]},{"title":" SDWebImageDownloader\t\t","date":"2019-03-15T03:51:28.000Z","path":"2019/03/15/sdwebimagedownloader/","text":"文章：SDWebImage源码解读之SDWebImageDownloader SDWebImageDownloader 这个类非常简单，作者的设计思路也很清晰。 一、编程怎么看待编程这件事？其实不管是函数还是属性，它们都是数据，编写的所有程序都是在处理数据。函数本身也是一种特殊的数据。 真正难的是生产数据的这一过程。 举个例子，给你一堆菜籽，要求生产出油来。怎么办？首先为这个任务设计一个函数： - (油)用菜籽生产油(菜籽); 这就是最外层的函数，也应该是最开始想到的函数。然后经过不断的研究发现，这个生产过程很复杂，必须分工合作才能实现。于是把这个任务分割为好几个小任务： ①、- (干净的菜籽)取出杂质(菜籽); ②、- (炒熟的菜籽)把菜籽炒一下(干净的菜籽); ③、- (蒸了的菜籽)把菜籽蒸一下(炒熟的菜籽); ④、- (捆好的菜籽)把菜籽包捆成一块(蒸了的菜籽); ⑤、- (油)撞击菜籽包(捆好的菜籽); 有没有发现，整个榨油的过程就是对数据的处理。这一点其实很重要。如果没有把 -(油)用菜籽生产油(菜籽); 任务进行拆分，我们就会写出复杂无比的函数。那么就有人要问了，只要实现这个功能就行了呗。其实这往往是写不出好代码的原因。 整个任务的设计应该是事先就设计好的。任务被分割成更小更简单的部分，然后再去实现这些最小的任务，不应该是边写边分割任务，往往临时分割的任务没有最正确的界限。 有了上边合理的分工之后，就可以进行任务安排了。回到现实开发中来。上边 5 个子任务的难度是不同的。有的人可能基础比较差，那么让他去干筛菜籽这种体力活，应该没问题。那些炒或者蒸的子任务是要掌握火候的，也就是说有点技术含量。那么就交给能胜任这项工作的人去做。所有的这一切，我们只要事先定义好各自的生产结果就行了，完全不影响每个程序的执行。 有的人用原始的撞击菜籽包榨油，有的人却用最先进的仪器榨油，这就是编程技术和知识深度的区别啊。 二、.h 文件typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) { /** * Put the download in the low queue priority and task priority. 低优先级 */ SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0, /\\*\\* \\* This flag enables progressive download, the image is displayed progressively during download as a browser would do. 带有进度 */ SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1, /\\*\\* \\* By default, request prevent the use of NSURLCache. With this flag, NSURLCache is used with default policies. \\* 使用 NSCache */ SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2, /\\*\\* \\* Call completion block with nil image/imageData if the image was read from NSURLCache \\* (to be combined with \\`SDWebImageDownloaderUseNSURLCache\\`). 不缓存响应 */ SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3, /\\*\\* \\* In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for extra time in background to let the request finish. If the background task expires the operation will be cancelled. 支持后台下载 */ SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4, /\\*\\* \\* Handles cookies stored in NSHTTPCookieStore by setting NSMutableURLRequest.HTTPShouldHandleCookies = YES; \\* 使用 Cookies */ SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5, /\\*\\* \\* Enable to allow untrusted SSL certificates. \\* Useful for testing purposes. Use with caution in production. 允许验证 SSL */ SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6, /\\*\\* \\* Put the download in the high queue priority and task priority. 高权限 */ SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7, /\\*\\* \\* Scale down the image 裁剪大图片 */ SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8, }; 当需要给某个功能添加 Options 的时候，一般使用枚举来实现。 这些选项提供了几种不同的选项，可以根据自己的需求选个合适的选项。这里作者使用了掩码。比如 1 &lt;&lt; 1 表示把 1 左移一位，将 1 写成二进制格式为：00000001，那么左移一位后就是：00000010，转成十进制后就是 2，也就是说左移一位表示在原来的值上乘以 2。 当判断 self.option 是否是 SDWebImageDownloaderIgnoreCachedResponse 选项时，应该这么判断： if (self.option &amp; SDWebImageDownloaderIgnoreCachedResponse) { } &amp; 运算是当左右两边的相同即为 YES，其他为 NO。 typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) { /** * Default value. All download operations will execute in queue style (first-in-first-out). 先进先出 */ SDWebImageDownloaderFIFOExecutionOrder, /\\*\\* \\* All download operations will execute in stack style (last-in-first-out). 后进先出 */ SDWebImageDownloaderLIFOExecutionOrder }; 定义了数据被调用的顺序。按照一般的想法。下载应该按照数据放入队列的顺序依次进行，但也支持后进先出这种方式。 一个下载管理器肯定有一个下载列表，我们可以假定这个列表保存在一个数组中，正常情况下应该每次取出数组中第 1 个元素来下载，这就是 FIFO（先进先出）。那么要改为 LIFO（后进先出），应该是针对某一个下载的，不应该是把取出数据的顺序改为从数组的最后一个元素取出。 有一个疑问，如果只是想暂停某一个下载，该怎么办呢？如果直接取消，那么点击继续的时候，要重新开启下载，肯定影响体验。这一点跟使用数组管理任务有点不同。 FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadStartNotification;FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadStopNotification; 通过 extern 就能够使用其他文件的代码。 /** * 进度 block /typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize, NSURL _Nullable targetURL); /** * 完成 block /typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage _Nullable image, NSData _Nullable data, NSError _Nullable error, BOOL finished); 命名 Block。 typedef NSDictionary SDHTTPHeadersDictionary;typedef NSMutableDictionary SDHTTPHeadersMutableDictionary; 命名字典。 typedef SDHTTPHeadersDictionary _Nullable (^SDWebImageDownloaderHeadersFilterBlock)(NSURL _Nullable url, SDHTTPHeadersDictionary * _Nullable headers); 这个 block 允许我们自定义请求头，通过 Block 传值。有一定的优点，可以拿到一些参数，然后在加工成我们需要的数据，最后返回。 /** * A token associated with each download. Can be used to cancel a download */@interface SDWebImageDownloadToken : NSObject SDWebImageDownloadToken 作为每一个下载的唯一身份标识，SDWebImageDownloader 和我们平时开发中的下载还是有不一样的，它弱化了下载过程，比较强调的是下载结果。不支持断点下载。 如果我们需要设计一个自己的下载管理者，就应该设计一个类似 SDWebImageDownloadToken 这样的下载对象封装类，能在这个对象中获取需要的所有信息，大家如果有兴趣，可以看看 MCDownloadManager. /** * The download’s URL. This should be readonly and you should not modify /@property (nonatomic, strong, nullable) NSURL url;/** * The cancel token taken from `addHandlersForProgress:completed`. This should be readonly and you should not modify * @note use -\\[SDWebImageDownloadToken cancel\\] to cancel the token */@property (nonatomic, strong, nullable) id downloadOperationCancelToken; 可以通过 token 进行取消下载。 /** * Asynchronous downloader dedicated and optimized for image loading. */@interface SDWebImageDownloader : NSObject 专门为图像加载而优化的异步下载器。 /** * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory. * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption. * 是否需要解压图片，默认为 YES。 */@property (assign, nonatomic) BOOL shouldDecompressImages; /** * The maximum number of concurrent downloads. * * 最大并发下载数 */@property (assign, nonatomic) NSInteger maxConcurrentDownloads; /** * Shows the current amount of downloads that still need to be downloaded. * * 当前下载数量 */@property (readonly, nonatomic) NSUInteger currentDownloadCount; /** * The timeout value (in seconds) for the download operation. Default: 15.0. * * 下载超时时间，默认是 15.0s */@property (assign, nonatomic) NSTimeInterval downloadTimeout; /** * The configuration in use by the internal NSURLSession. * Mutating this object directly has no effect. （只读）直接改变这个对象没有效果 * * @see createNewSessionWithConfiguration: /@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration sessionConfiguration; /** * Changes download operations execution order. Default value is `SDWebImageDownloaderFIFOExecutionOrder`. * * 数据调用顺序。默认为 FIFO */@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder; /** * Singleton method, returns the shared instance * * @return global shared instance of downloader class */+ (nonnull instancetype)sharedDownloader; /** * Set the default URL credential to be set for request operations. 请求验证 /@property (strong, nonatomic, nullable) NSURLCredential urlCredential; /** * Set username 用户名 /@property (strong, nonatomic, nullable) NSString username; /** * Set password 密码 /@property (strong, nonatomic, nullable) NSString password; /** * Set filter to pick headers for downloading image HTTP request. * * This block will be invoked for each downloading image request, returned NSDictionary will be used as headers in corresponding HTTP request. * * 设置请求头部回调 */@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter; 初始化方法： /** * Creates an instance of a downloader with specified session configuration. * @note `timeoutIntervalForRequest` is going to be overwritten. * @return new instance of downloader class */- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration NS_DESIGNATED_INITIALIZER; 一个 NSURLSession 会话，使用 NSURLSessionConfiguration 进行配置，利用这一点，我们在设计自己的网络框架的时候，可以参考 NSURLSessionConfiguration。暴露少量的属性来配置网络请求，后期维护起来也比较容易。 使用 NS_DESIGNATED_INITIALIZER 强调该方法是建议的初始化方法。 其他的方法： /** * Set a value for a HTTP header to be appended to each download HTTP request. * * @param value The value for the header field. Use `nil` value to remove the header. * @param field The name of the header field to set. * * 设置请求头字段。如果 value = nil，移除该头字段 */- (void)setValue:(nullable NSString )value forHTTPHeaderField:(nullable NSString )field; /** * Returns the value of the specified HTTP header field. * * @return The value associated with the header field field, or `nil` if there is no corresponding header field. * 返回头字段 value，可能返回 nil */- (nullable NSString )valueForHTTPHeaderField:(nullable NSString )field; /** * Sets a subclass of `NSOperation` and conforms to `SDWebImageDownloaderOperationInterface`. * Default is `SDWebImageDownloaderOperation`. * Can be used each time SDWebImage constructs a request * operation to download an image. * * @param operationClass The subclass of `NSOperation` and conforms to `SDWebImageDownloaderOperationInterface`. * Default is `SDWebImageDownloaderOperation`, Passing `nil` will revert to `SDWebImageDownloaderOperation`. * * 遵守 SDWebImageDownloaderOperationInterface 协议的 NSOperation 子类，默认为 SDWebImageDownloaderOperation */- (void)setOperationClass:(nullable Class)operationClass; /** * Creates a SDWebImageDownloader async downloader instance with a given URL * * The delegate will be informed when the image is finish downloaded or an error has happen. * * @see SDWebImageDownloaderDelegate * * @param url The URL to the image to download * @param options The options to be used for this download * @param progressBlock A block called repeatedly while the image is downloading * @note the progress block is executed on a background queue * @param completedBlock A block called once the download is completed. * If the download succeeded, the image parameter is set, in case of error, * error parameter is set with the error. The last parameter is always YES * if SDWebImageDownloaderProgressiveDownload isn’t use. With the * SDWebImageDownloaderProgressiveDownload option, this block is called * repeatedly with the partial image object and the finished argument set to NO * before to be called a last time with the full image and finished argument * set to YES. In case of error, the finished argument is always YES. * * @return A token (SDWebImageDownloadToken) that can be passed to -cancel: to cancel this operation * * 下载图片 */- (nullable SDWebImageDownloadToken )downloadImageWithURL:(nullable NSURL )url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock; /** * Cancels a download that was previously queued using -downloadImageWithURL:options:progress:completed: * * @param token The token received from -downloadImageWithURL:options:progress:completed: that should be canceled. * * 取消图片下载 */- (void)cancel:(nullable SDWebImageDownloadToken *)token; /** * Sets the download queue suspension state. 暂停 */- (void)setSuspended:(BOOL)suspended; /** * Cancels all download operations in the queue. * * 取消所有的下载任务 */- (void)cancelAllDownloads; /** * Forces SDWebImageDownloader to create and use a new NSURLSession that is * initialized with the given configuration. * @note All existing download operations in the queue will be cancelled. * @note `timeoutIntervalForRequest` is going to be overwritten. * * @param sessionConfiguration The configuration to use for the new NSURLSession */- (void)createNewSessionWithConfiguration:(nonnull NSURLSessionConfiguration *)sessionConfiguration; /** * Invalidates the managed session, optionally canceling pending operations. * @note If you use custom downloader instead of the shared downloader, you need call this method when you do not use it to avoid memory leak * @param cancelPendingOperations Whether or not to cancel pending operations. * @note Calling this method on the shared downloader has no effect. */- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations; 三、.m 文件@interface SDWebImageDownloadToken () @property (nonatomic, weak, nullable) NSOperation *downloadOperation; @end @implementation SDWebImageDownloadToken - (void)cancel { if (self.downloadOperation) { SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken; if (cancelToken) { [self.downloadOperation cancel:cancelToken]; } }} @end SDWebImageDownloadToken 增加一个遵守 SDWebImageDownloaderOperationInterface 协议的下载任务对象，用于取消任务。 @interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt; // 下载队列@property (strong, nonatomic, nonnull) NSOperationQueue downloadQueue;// 用于记录最后添加的操作@property (weak, nonatomic, nullable) NSOperation lastAddedOperation;// 支持我们自定义的操作类@property (assign, nonatomic, nullable) Class operationClass;// 存放着所有的 operation@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL , NSOperation &gt; *URLOperations; // HTTP 请求头@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders; // 用户线程安全的信号量// a lock to keep the access to `URLOperations` thread-safe@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock;// a lock to keep the access to `HTTPHeaders` thread-safe@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock; // The session in which data tasks will run@property (strong, nonatomic) NSURLSession *session; @end 这些属性可以说都是为了完成管理下载任务而存在的。 1、initialize initialize 和 load 这两个方法比较特殊，通过下边这个表格来看看它们的区别 + (void)initialize { // Bind SDNetworkActivityIndicator if available (download it here: http://github.com/rs/SDNetworkActivityIndicator ) // To use it, just add #import “SDNetworkActivityIndicator.h” in addition to the SDWebImage import if (NSClassFromString(@”SDNetworkActivityIndicator”)) { #pragma clang diagnostic push #pragma clang diagnostic ignored “-Warc-performSelector-leaks” id activityIndicator = [NSClassFromString(@”SDNetworkActivityIndicator”) performSelector:NSSelectorFromString(@”sharedActivityIndicator”)]; #pragma clang diagnostic pop // Remove observer in case it was previously added. \\[\\[NSNotificationCenter defaultCenter\\] removeObserver:activityIndicator name:SDWebImageDownloadStartNotification object:nil\\]; \\[\\[NSNotificationCenter defaultCenter\\] removeObserver:activityIndicator name:SDWebImageDownloadStopNotification object:nil\\]; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:activityIndicator selector:NSSelectorFromString(@&quot;startActivity&quot;) name:SDWebImageDownloadStartNotification object:nil\\]; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:activityIndicator selector:NSSelectorFromString(@&quot;stopActivity&quot;) name:SDWebImageDownloadStopNotification object:nil\\]; } } 上边的方法是为了给图片下载绑定一个 SDNetworkActivityIndicator，只有当这个 SDNetworkActivityIndicator 文件存在的情况下才会执行，目的就是在下载图片时，状态栏会转小菊花。 /** * 初始化方法 */- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration )sessionConfiguration{ if ((self = [super init])) { _operationClass = [SDWebImageDownloaderOperation class]; _shouldDecompressImages = YES; _executionOrder = SDWebImageDownloaderFIFOExecutionOrder; _downloadQueue = [NSOperationQueue new]; _downloadQueue.maxConcurrentOperationCount = 6; _downloadQueue.name = @”com.hackemist.SDWebImageDownloader”; _URLOperations = [NSMutableDictionary new]; SDHTTPHeadersMutableDictionary headerDictionary = [SDHTTPHeadersMutableDictionary dictionary]; NSString *userAgent = nil; #if SD_UIKIT // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@”%@/%@ (%@; iOS %@; Scale/%0.2f)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]]; #elif SD_WATCH // User-Agent Header; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43 userAgent = [NSString stringWithFormat:@”%@/%@ (%@; watchOS %@; Scale/%0.2f)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]]; #elif SD_MAC userAgent = [NSString stringWithFormat:@”%@/%@ (Mac OS X %@)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString )kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]]; #endif if (userAgent) { if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) { NSMutableString *mutableUserAgent = [userAgent mutableCopy]; if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@”Any-Latin; Latin-ASCII; [:^ASCII:] Remove”, false)) { userAgent = mutableUserAgent; } } headerDictionary[@”User-Agent”] = userAgent; } #ifdef SD_WEBP headerDictionary[@”Accept”] = @”image/webp,image/*;q=0.8”; #else headerDictionary[@”Accept”] = @”image/*;q=0.8”; #endif _HTTPHeaders = headerDictionary; _operationsLock = dispatch_semaphore_create(1); _headersLock = dispatch_semaphore_create(1); _downloadTimeout = 15.0; \\[self createNewSessionWithConfiguration:sessionConfiguration\\]; } return self; } 这里边做了必要的初始化，默认最大支持的并发数为 6 个，也就是说可以同时下载 6 张图片。 看看 image/webp,image/;q=0.8 是什么意思。image/webp 是 web 格式的图片，q=0.8 指的是权重系数为 0.8，q 的取值范围是 0 - 1， 默认值为 1，q 作用于它前边分号;前边的内容。在这里，image/webp,image/;q=0.8 表示优先接受 image/webp，其次接受 image/* 的图片。 - (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration { // 取消所有的下载任务 [self cancelAllDownloads]; // 取消当前的会话 if (self.session) { [self.session invalidateAndCancel]; } sessionConfiguration.timeoutIntervalForRequest = self.downloadTimeout; /\\*\\* \\* Create the session for this task \\* We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate \\* method calls and completion handler calls. */ // 创建新的会话 self.session = \\[NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:nil\\]; } - (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations{ if (self == [SDWebImageDownloader sharedDownloader]) { return; } if (cancelPendingOperations) { // 直接取消 [self.session invalidateAndCancel]; } else { // 完成任务后取消 [self.session finishTasksAndInvalidate]; }} 新建、挂起/取消会话。 - (void)setValue:(nullable NSString )value forHTTPHeaderField:(nullable NSString )field { LOCK(self.headersLock); if (value) { self.HTTPHeaders[field] = value; } else { [self.HTTPHeaders removeObjectForKey:field]; } UNLOCK(self.headersLock);} - (nullable NSString )valueForHTTPHeaderField:(nullable NSString )field { if (!field) { return nil; } return [[self allHTTPHeaderFields] objectForKey:field];} - (nonnull SDHTTPHeadersDictionary )allHTTPHeaderFields { LOCK(self.headersLock); SDHTTPHeadersDictionary allHTTPHeaderFields = [self.HTTPHeaders copy]; UNLOCK(self.headersLock); return allHTTPHeaderFields;} - (void)setMaxConcurrentDownloads:(NSInteger)maxConcurrentDownloads { _downloadQueue.maxConcurrentOperationCount = maxConcurrentDownloads;} - (NSUInteger)currentDownloadCount { return _downloadQueue.operationCount;} - (NSInteger)maxConcurrentDownloads { return _downloadQueue.maxConcurrentOperationCount;} - (NSURLSessionConfiguration *)sessionConfiguration { return self.session.configuration;} - (void)setOperationClass:(nullable Class)operationClass{ if (operationClass &amp;&amp; [operationClass isSubclassOfClass:[NSOperation class]] &amp;&amp; [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperationInterface)]) { _operationClass = operationClass; } else { _operationClass = [SDWebImageDownloaderOperation class]; }} set 或者 get 方法，操作数据时加锁保证多线程安全。 - (NSOperation )createDownloaderOperationWithUrl:(nullable NSURL )url options:(SDWebImageDownloaderOptions)options{ // 1、设置超时时间，默认为 15.0 NSTimeInterval timeoutInterval = self.downloadTimeout; if (timeoutInterval == 0.0) { timeoutInterval = 15.0; } // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise // 缓存策略 NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; // 2、创建请求对象 NSMutableURLRequest *request = \\[\\[NSMutableURLRequest alloc\\] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval\\]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; // 3、设置请求头部 if (self.headersFilter) { request.allHTTPHeaderFields = self.headersFilter(url, \\[self allHTTPHeaderFields\\]); } else { request.allHTTPHeaderFields = \\[self allHTTPHeaderFields\\]; } // 4、创建下载任务 NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *operation = \\[\\[self.operationClass alloc\\] initWithRequest:request inSession:self.session options:options\\]; operation.shouldDecompressImages = self.shouldDecompressImages; // 5、给任务设置 url 凭证 if (self.urlCredential) { operation.credential = self.urlCredential; } else if (self.username &amp;&amp; self.password) { operation.credential = \\[NSURLCredential credentialWithUser:self.username password:self.password persistence:NSURLCredentialPersistenceForSession\\]; } // 6、设置优先级 if (options &amp; SDWebImageDownloaderHighPriority) { operation.queuePriority = NSOperationQueuePriorityHigh; } else if (options &amp; SDWebImageDownloaderLowPriority) { operation.queuePriority = NSOperationQueuePriorityLow; } // 7、处理下载顺序 if (self.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) { // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency \\[self.lastAddedOperation addDependency:operation\\]; self.lastAddedOperation = operation; } return operation; } 创建 SDWebImageDownloaderOperation。 - (nullable SDWebImageDownloadToken )downloadImageWithURL:(nullable NSURL )url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock{ // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) { if (completedBlock != nil) { completedBlock(nil, nil, nil, NO); } return nil; } LOCK(self.operationsLock); NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *operation = \\[self.URLOperations objectForKey:url\\]; // There is a case that the operation may be marked as finished or cancelled, but not been removed from \\`self.URLOperations\\`. // 创建新的操作对象 if (!operation || operation.isFinished || operation.isCancelled) { operation = \\[self createDownloaderOperationWithUrl:url options:options\\]; __weak typeof(self) wself = self; operation.completionBlock = ^{ __strong typeof(wself) sself = wself; if (!sself) { return; } LOCK(sself.operationsLock); \\[sself.URLOperations removeObjectForKey:url\\]; UNLOCK(sself.operationsLock); }; \\[self.URLOperations setObject:operation forKey:url\\]; // Add operation to operation queue only after all configuration done according to Apple&apos;s doc. // \\`addOperation:\\` does not synchronously execute the \\`operation.completionBlock\\` so this will not cause deadlock. // 任务加入到队列 \\[self.downloadQueue addOperation:operation\\]; } // 操作任务没有在运行中 else if (!operation.isExecuting) { if (options &amp; SDWebImageDownloaderHighPriority) { operation.queuePriority = NSOperationQueuePriorityHigh; } else if (options &amp; SDWebImageDownloaderLowPriority) { operation.queuePriority = NSOperationQueuePriorityLow; } else { operation.queuePriority = NSOperationQueuePriorityNormal; } } UNLOCK(self.operationsLock); id downloadOperationCancelToken = \\[operation addHandlersForProgress:progressBlock completed:completedBlock\\]; SDWebImageDownloadToken *token = \\[SDWebImageDownloadToken new\\]; token.downloadOperation = operation; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; return token; } 为每个 URL 绑定事件。 - (void)cancel:(nullable SDWebImageDownloadToken )token{ NSURL url = token.url; if (!url) { return; } LOCK(self.operationsLock); NSOperation *operation = [self.URLOperations objectForKey:url]; if (operation) { BOOL canceled = [operation cancel:token.downloadOperationCancelToken]; if (canceled) { [self.URLOperations removeObjectForKey:url]; } } UNLOCK(self.operationsLock);} 取消某个操作。 - (void)setSuspended:(BOOL)suspended{ self.downloadQueue.suspended = suspended;} - (void)cancelAllDownloads{ [self.downloadQueue cancelAllOperations];} 全部暂停或取消。 我们在初始化方法中创建了会话： self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration delegate:self delegateQueue:nil\\]; delegate 设置为自己，也就是当使用这个会话请求数据，收到响应时，会调用 SDWebImageDownloader.m 中的代理方法，然后再调用 SDWebImageDownloaderOperation 中的代理方法处理事情。 那么作者为什么这么设计呢？目的就是为了共用一个 URLSession。 #pragma mark NSURLSessionDataDelegate - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTaskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:dataTask\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)\\]) { \\[dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler\\]; } else { if (completionHandler) { completionHandler(NSURLSessionResponseAllow); } } } - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTask didReceiveData:(NSData *)data { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:dataTask\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveData:)\\]) { \\[dataOperation URLSession:session dataTask:dataTask didReceiveData:data\\]; } } - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTask willCacheResponse:(NSCachedURLResponse )proposedResponse completionHandler:(void (^)(NSCachedURLResponse cachedResponse))completionHandler { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:dataTask\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:dataTask:willCacheResponse:completionHandler:)\\]) { \\[dataOperation URLSession:session dataTask:dataTask willCacheResponse:proposedResponse completionHandler:completionHandler\\]; } else { if (completionHandler) { completionHandler(proposedResponse); } } } #pragma mark NSURLSessionTaskDelegate - (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task didCompleteWithError:(NSError *)error { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:task\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:task:didCompleteWithError:)\\]) { \\[dataOperation URLSession:session task:task didCompleteWithError:error\\]; } } - (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task willPerformHTTPRedirection:(NSHTTPURLResponse )response newRequest:(NSURLRequest )request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:task\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)\\]) { \\[dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:request completionHandler:completionHandler\\]; } else { if (completionHandler) { completionHandler(request); } } } - (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task didReceiveChallenge:(NSURLAuthenticationChallenge )challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential credential))completionHandler { // Identify the operation that runs this task and pass it the delegate method NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \\[self operationWithTask:task\\]; if (\\[dataOperation respondsToSelector:@selector(URLSession:task:didReceiveChallenge:completionHandler:)\\]) { \\[dataOperation URLSession:session task:task didReceiveChallenge:challenge completionHandler:completionHandler\\]; } else { if (completionHandler) { completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil); } } }","tags":[]},{"title":" SDWebImageDownloaderOperation\t\t","date":"2019-03-14T09:47:50.000Z","path":"2019/03/14/sdwebimagedownloaderoperation/","text":"文章：SDWebImage源码解读之SDWebImageDownloaderOperation、多线程之NSOperation简介 本篇主要讲解下载操作的相关知识，SDWebImageDownloaderOperation 的主要任务是把一张图片从服务器下载到内存中。下载数据并不难，如何对下载这一系列的任务进行设计，就很难了。接下来逐步的分析作者在开发中的思路和使用到的技术细节。 一、NSOperation为了让程序更快的执行，我们用多线程异步的方式解决这个问题，GCD 与 NSOperation 都能实现多线程。 NSOperation 最核心的使用方法总结： ①、main() 和 start()。 同步：把逻辑写在 main() 中；异步：把逻辑写到 start() 中。然后加入到队列之中。 ②、NSOperation 什么时候执行呢？难道要手动调用 main() 和 start() 吗？ 手动调用肯定也是行的。当调用 start() 的时候，默认的是在当前线程执行同步操作，如果是在主线程调用了，那么必然会导致程序死锁。 另外一种方式就是加入到 operationQueue 中，operationQueue 会尽快执行 NSOperation。如果 operationQueue 是同步的，那么它会等到 NSOperation 的 isFinished 等于 YES 后，再执行下一个任务；如果是异步的，通过设置 maxConcurrentOperationCount 来控制同时执行的最大操作，某个操作完成后，继续其他的操作。 ③、并不是调用了 canche 就一定取消了。 如果 NSOperation 还没有执行，那么就会取消；如果执行了，只会将 isCancelled 设置为 YES。所以，在我们的操作中，应该在每个操作开始前，或者在每个有意义的实际操作完成后，先检查下这个属性是不是已经设置为 YES。如果是 YES，则后面操作都可以不用在执行了。 思考：比如有一系列的任务要执行，有两种选择，一种是通过数组控制数据的取出顺序，另外一种就是使用队列。 二、.h 文件FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadStartNotification; // 任务开始FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadReceiveResponseNotification; // 接收到数据FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadStopNotification; // 暂停FOUNDATION_EXPORT NSString _Nonnull const SDWebImageDownloadFinishNotification; // 完成 在设计一个功能的时候，作者都会用通知的形式暴露出关键的节点，不管使用者需不需要使用这些通知。这是一个很好地方法，可以在自定义控件的时候参考这个设计。 /* Describes a downloader operation. If one wants to use a custom downloader op, it needs to inherit from `NSOperation` and conform to this protocol For the description about these methods, see `SDWebImageDownloaderOperation` /@protocol SDWebImageDownloaderOperationInterface &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;@required/** * 使用 NSURLRequest、NSURLSession 和 SDWebImageDownloaderOptions 初始化 */- (nonnull instancetype)initWithRequest:(nullable NSURLRequest )request inSession:(nullable NSURLSession )session options:(SDWebImageDownloaderOptions)options; /** * 可以为每一个 NSOperation 自由的添加相应对象 */- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;/** * 是否需要解压图片 */- (BOOL)shouldDecompressImages;- (void)setShouldDecompressImages:(BOOL)value; /** * 是否需要设置凭证 */- (nullable NSURLCredential )credential;- (void)setCredential:(nullable NSURLCredential )value; /** * 根据 token 取消下载 */- (BOOL)cancel:(nullable id)token; @optional- (nullable NSURLSessionTask *)dataTask; @end 按照作者的注释，如果想要实现一个自定义的下载操作，就必须继承自 NSOperation，同时实现 SDWebImageDownloaderOperationInterface 这个协议。不去看其他的代码，只做一个简单的猜测：很可能在别的类中，只使用 SDWebImageDownloaderOperationInterface 和 NSOperation 中的方法和属性。 @interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageDownloaderOperationInterface, SDWebImageOperation&gt; 首先它遵守了 SDWebImageDownloaderOperationInterface 协议，所以协议的 required 方法都必须实现。我们在设计这个 .h 的时候呢，可以把协议中的方法写到这个 .h 中，这样别人在使用的时候，就会更加直观。 /** * The credential used for authentication challenges in -URLSession:task:didReceiveChallenge:completionHandler:. * * This will be overridden by any shared credentials that exist for the username or password of the request URL, if present. /@property (nonatomic, strong, nullable) NSURLCredential credential; 这就实现了 SDWebImageDownloaderOperationInterface 协议中的 -redential 和 - setCredential:。 一般情况下，在主动指明初始化方法的时候，肯定会为初始化方法设定几个参数。那么这些参数就应该以只读的方式暴露给他人。 比如： /** * The request used by the operation’s task. 任务请求 /@property (strong, nonatomic, readonly, nullable) NSURLRequest request; /** * The operation’s task. 任务 /@property (strong, nonatomic, readonly, nullable) NSURLSessionTask dataTask; /** * The SDWebImageDownloaderOptions for the receiver. 下载选项 */@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options; /** * Initializes a `SDWebImageDownloaderOperation` object * * @param request the URL request * @param session the URL session in which this operation will run * @param options downloader options */- (nonnull instancetype)initWithRequest:(nullable NSURLRequest )request inSession:(nullable NSURLSession )session options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER; 其他的属性： /** * The expected size of data. 预期的数据大小 */@property (assign, nonatomic) NSInteger expectedSize; /** * The response returned by the operation’s task. 请求响应 /@property (strong, nonatomic, nullable) NSURLResponse response; 添加回调方法： /** * Adds handlers for progress and completion. Returns a tokent that can be passed to -cancel: to cancel this set of * callbacks. * 为进度和完成添加处理程序。返回一个可传递给 -cancel: 以取消此回调集合的标记。 * * @param progressBlock the block executed when a new chunk of data arrives. * @note the progress block is executed on a background queue 后台队列 * @param completedBlock the block executed when the download is done. * @note the completed block is executed on the main queue for success. If errors are found, there is a chance the block will be executed on a background queue 成功时在主队列执行，失败时在后台队列 * * @return the token to use to cancel this set of handlers */- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock; 取消方法： /** * Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled. * * @param token the token representing a set of callbacks to cancel * * @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise. */- (BOOL)cancel:(nullable id)token; 这个方法不是取消任务的，而是取消任务中的回调，当然当任务中没有响应者的时候，任务也会被取消。 三、.m 文件我们的目的是下载一张图片，那么最核心的逻辑是什么呢？ 初始化一个 task 添加响应者 开启下载任务 处理下载过程和结束后的事情 也就是说 .m 中所有的代码，都是围绕着上边 4 点来设计的。 那么就详细的对每一步进行分析： // iOS 8 Foundation.framework extern these symbol but the define is in CFNetwork.framework. We just fix this without import CFNetwork.framework #if (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_9_0)const float NSURLSessionTaskPriorityHigh = 0.75;const float NSURLSessionTaskPriorityDefault = 0.5;const float NSURLSessionTaskPriorityLow = 0.25; #endif 任务优先级。 typedef NSMutableDictionary SDCallbacksDictionary; // 字典 @interface SDWebImageDownloaderOperation ()/** * 是一个数组，数组中存放的是 SDCallbacksDictionary 类型的数据，SDCallbacksDictionary 字典的 key 是一个字符串，它有两种情况：kProgressCallbackKey 和 kCompletedCallbackKey,也就是说进度和完成的回调都是放到了数组中。那么字典的值就是回调的 block 了。 /@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary &gt; *callbackBlocks; @property (assign, nonatomic, getter = isExecuting) BOOL executing;@property (assign, nonatomic, getter = isFinished) BOOL finished;@property (strong, nonatomic, nullable) NSMutableData imageData;@property (copy, nonatomic, nullable) NSData cachedData; // for `SDWebImageDownloaderIgnoreCachedResponse` // This is weak because it is injected by whoever manages this session. If this gets nil-ed out, we won’t be able to run// the task associated with this operation/** * 这个属性是我们初始化的时候传进来的参数。这个参数不一定是可用的，也就是说是不安全的，当出现不可用的情况时，就需要使用 ownedSession /@property (weak, nonatomic, nullable) NSURLSession unownedSession;// This is set if we’re using not using an injected NSURLSession. We’re responsible of invalidating this one@property (strong, nonatomic, nullable) NSURLSession *ownedSession; @property (strong, nonatomic, readwrite, nullable) NSURLSessionTask *dataTask; @property (strong, nonatomic, nonnull) dispatch_semaphore_t callbacksLock; // a lock to keep the access to `callbackBlocks` thread-safe @property (strong, nonatomic, nonnull) dispatch_queue_t coderQueue; // the queue to do image decoding 解压队列 #if SD_UIKIT@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId; // 后台任务 id #endif @property (strong, nonatomic, nullable) id progressiveCoder; @end 1、初始化一个 task - (nonnull instancetype)init { return [self initWithRequest:nil inSession:nil options:0];} - (nonnull instancetype)initWithRequest:(nullable NSURLRequest )request inSession:(nullable NSURLSession )session options:(SDWebImageDownloaderOptions)options { if ((self = [super init])) { _request = [request copy]; _shouldDecompressImages = YES; _options = options; _callbackBlocks = [NSMutableArray new]; _executing = NO; _finished = NO; _expectedSize = 0; _unownedSession = session; _callbacksLock = dispatch_semaphore_create(1); _coderQueue = dispatch_queue_create(“com.hackemist.SDWebImageDownloaderOperationCoderQueue”, DISPATCH_QUEUE_SERIAL); #if SD_UIKIT _backgroundTaskId = UIBackgroundTaskInvalid; #endif } return self;} 初始化属性。 2、添加响应者 - (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock{ SDCallbacksDictionary *callbacks = [NSMutableDictionary new]; if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy]; if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy]; LOCK(self.callbacksLock); [self.callbackBlocks addObject:callbacks]; UNLOCK(self.callbacksLock); return callbacks;} 将 block 数据保存到新建的字典，再存到数组中，这里边使用 dispatch_semaphore 信号量完成锁的功能。 在旧版本中是使用 dispatch_barrier_async，做一个简单的介绍。 我们可以创建两种类型的队列：串行和并行，也就是 DISPATCH_QUEUE_SERIAL、DISPATCH_QUEUE_CONCURRENT。barrier 是栅栏的意思，也就是说是用来做拦截功能的，上边的这两种都能够拦截任务，换句话说，就是只有我的任务完成后，队列后边的任务才能完成。 不同之处就是，dispatch_barrier_sync 控制了任务往队列添加这一过程，只有当我的任务完成之后，才能往队列中添加任务。dispatch_barrier_async 不会控制队列添加任务。但是只有当我的任务完成后，队列中后边的任务才会执行。 那么在这里的任务是往数组中添加数据，对顺序没什么要求，我们采取 dispatch_barrier_async 就可以了，已经能保证数据添加的安全性了。 - (nullable NSArray )callbacksForKey:(NSString )key{ LOCK(self.callbacksLock); NSMutableArray *callbacks = [[self.callbackBlocks valueForKey:key] mutableCopy]; UNLOCK(self.callbacksLock); // We need to remove [NSNull null] because there might not always be a progress block for each callback [callbacks removeObjectIdenticalTo:[NSNull null]]; return [callbacks copy]; // strip mutability here} 根据 key 取出所有对应 key 的 block，同样加锁。比较有意思的是 [self.callbackBlocks valueForKey:key] 这段代码，self.callbackBlocks 是一个数组，假定它的结构是这样的： @[ @{ @”completed” : Block1 }, @{ @”progress” : Block2 }, @{ @”completed” : Block3 }, @{ @”progress” : Block4 }, @{ @”completed” : Block5 }, @{ @”progress” : Block6 }] 调用 [self.callbackBlocks valueForKey:@”progress”] 后会得到 [Block2, Block4, Block6]。 Returns an array containing the results of invoking valueForKey: using key on each of the array’s objects. 遍历数组，每个元素都执行 valueForKey: 方法。 removeObjectIdenticalTo: 这个方法会移除数组中指定相同地址的元素。 - (BOOL)cancel:(nullable id)token{ BOOL shouldCancel = NO; LOCK(self.callbacksLock); [self.callbackBlocks removeObjectIdenticalTo:token]; if (self.callbackBlocks.count == 0) { shouldCancel = YES; } UNLOCK(self.callbacksLock); if (shouldCancel) { [self cancel]; } return shouldCancel;} 这个函数就是取消某一回调。加锁保证对 callbackBlocks 数组的多线程访问安全。 3、开启下载任务 - (void)start { @synchronized (self) { // 如果任务已经被设置为取消了，那么就无需开启下载任务了，设置 finished = YES，并重置。 if (self.isCancelled) { self.finished = YES; [self reset]; return; } #if SD_UIKIT Class UIApplicationClass = NSClassFromString(@”UIApplication”); BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)]; if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) { __weak __typeof__ (self) wself = self; UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)]; // 开启后台任务 self.backgroundTaskId = \\[app beginBackgroundTaskWithExpirationHandler:^{ \\[wself cancel\\]; }\\]; } #endif NSURLSession *session = self.unownedSession; // 会话不存在，生成会话 if (!session) { NSURLSessionConfiguration *sessionConfig = \\[NSURLSessionConfiguration defaultSessionConfiguration\\]; // 请求超时 15 秒 sessionConfig.timeoutIntervalForRequest = 15; /\\*\\* \\* Create the session for this task \\* We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate \\* method calls and completion handler calls. */ session = \\[NSURLSession sessionWithConfiguration:sessionConfig delegate:self delegateQueue:nil\\]; self.ownedSession = session; } // 不缓存响应 if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse) { // Grab the cached data for later check NSURLCache *URLCache = session.configuration.URLCache; if (!URLCache) { URLCache = \\[NSURLCache sharedURLCache\\]; } NSCachedURLResponse *cachedResponse; // NSURLCache&apos;s \\`cachedResponseForRequest:\\` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483 // 加锁，处理线程不安全的方法 @synchronized (URLCache) { cachedResponse = \\[URLCache cachedResponseForRequest:self.request\\]; } // 保存数据 if (cachedResponse) { self.cachedData = cachedResponse.data; } } self.dataTask = \\[session dataTaskWithRequest:self.request\\]; self.executing = YES; } if (self.dataTask) { #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wunguarded-availability” // 设置任务优先级 if ([self.dataTask respondsToSelector:@selector(setPriority:)]) { if (self.options &amp; SDWebImageDownloaderHighPriority) { self.dataTask.priority = NSURLSessionTaskPriorityHigh; } else if (self.options &amp; SDWebImageDownloaderLowPriority) { self.dataTask.priority = NSURLSessionTaskPriorityLow; } } #pragma clang diagnostic pop // 开启任务 [self.dataTask resume]; // 回调 for (SDWebImageDownloaderProgressBlock progressBlock in \\[self callbacksForKey:kProgressCallbackKey\\]) { progressBlock(0, NSURLResponseUnknownLength, self.request.URL); } __block typeof(self) strongSelf = self; // 通知 dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[\\[NSNotificationCenter defaultCenter\\] postNotificationName:SDWebImageDownloadStartNotification object:strongSelf\\]; }); } else { // 错误 \\[self callCompletionBlocksWithError:\\[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorUnknown userInfo:@{NSLocalizedDescriptionKey : @&quot;Task can&apos;t be initialized&quot;}\\]\\]; \\[self done\\]; } } 这一块分为几个子任务。 如果该任务已经被设置为取消。 /** * 重置类的属性 */- (void)reset{ LOCK(self.callbacksLock); \\[self.callbackBlocks removeAllObjects\\]; UNLOCK(self.callbacksLock); @synchronized (self) { self.dataTask = nil; if (self.ownedSession) { \\[self.ownedSession invalidateAndCancel\\]; self.ownedSession = nil; } #if SD_UIKIT if (self.backgroundTaskId != UIBackgroundTaskInvalid) { // If backgroundTaskId != UIBackgroundTaskInvalid, sharedApplication is always exist UIApplication * app = \\[UIApplication performSelector:@selector(sharedApplication)\\]; \\[app endBackgroundTask:self.backgroundTaskId\\]; self.backgroundTaskId = UIBackgroundTaskInvalid; } #endif } } 增加应用进入后台的处理，确保能够开启下载任务。start 方法的目的只是开启下载任务，它所要保证的就是调用 start 时，任务能够开启，至于是否下载成功，那不是 start 应该关心的事情。（待验证） task 开启前的准备工作：设置优先级、会话。 开启 task 并处理回调、通知。 - (void)cancel { @synchronized (self) { [self cancelInternal]; }} - (void)cancelInternal { if (self.isFinished) return; [super cancel]; if (self.dataTask) { \\[self.dataTask cancel\\]; __block typeof(self) strongSelf = self; dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[\\[NSNotificationCenter defaultCenter\\] postNotificationName:SDWebImageDownloadStopNotification object:strongSelf\\]; }); // As we cancelled the task, its callback won&apos;t be called and thus won&apos;t // maintain the isFinished and isExecuting flags. if (self.isExecuting) self.executing = NO; if (!self.isFinished) self.finished = YES; } \\[self reset\\]; } 同时取消 operation、task，修改状态并向外通知，重置属性。 - (void)setFinished:(BOOL)finished { [self willChangeValueForKey:@”isFinished”]; _finished = finished; [self didChangeValueForKey:@”isFinished”];} - (void)setExecuting:(BOOL)executing { [self willChangeValueForKey:@”isExecuting”]; _executing = executing; [self didChangeValueForKey:@”isExecuting”];} 自己实现了 kvo。 4、处理下载过程和结束后的事情 - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTaskdidReceiveResponse:(NSURLResponse )response completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler{ NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; NSInteger expected = (NSInteger)response.expectedContentLength; expected = expected &gt; 0 ? expected : 0; self.expectedSize = expected; self.response = response; NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse )response).statusCode : 200; BOOL valid = statusCode &lt; 400; //‘304 Not Modified’ is an exceptional one. It should be treated as cancelled if no cache data //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check if (statusCode == 304 &amp;&amp; !self.cachedData) { valid = NO; } if (valid) { for (SDWebImageDownloaderProgressBlock progressBlock in \\[self callbacksForKey:kProgressCallbackKey\\]) { progressBlock(0, expected, self.request.URL); } } else { // Status code invalid and marked as cancelled. // Do not call `\\[self.dataTask cancel\\]` which may mass up URLSession life cycle disposition = NSURLSessionResponseCancel; } __block typeof(self) strongSelf = self; dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[\\[NSNotificationCenter defaultCenter\\] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf\\]; }); if (completionHandler) { completionHandler(disposition); } } 上边的代码，处理了当收到响应后要做的事情。规定：没有收到响应码或者响应码小于 400 认定为正常的情况，其中 304 比较特殊，因为当 stateCode 为 304 的时候，便是这个响应没有变化，可以在缓存中读取。其他的情况可以认定为错误的请求。 当一切顺利的时候，基本上就是给早已定义的属性赋值，上边的代码逻辑比较简单，在这里就不做介绍了。 - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTask didReceiveData:(NSData *)data{ if (!self.imageData) { self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize]; } // 拼接数据 [self.imageData appendData:data]; if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0) { // Get the image data __block NSData *imageData = \\[self.imageData copy\\]; // Get the total bytes downloaded 当前下载数据的总长度 const NSInteger totalSize = imageData.length; // Get the finish status 是否已经完全下载 BOOL finished = (totalSize &gt;= self.expectedSize); if (!self.progressiveCoder) { // We need to create a new instance for progressive decoding to avoid conflicts for (id&lt;SDWebImageCoder&gt;coder in \\[SDWebImageCodersManager sharedInstance\\].coders) { if (\\[coder conformsToProtocol:@protocol(SDWebImageProgressiveCoder)\\] &amp;&amp; \\[((id&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData\\]) { self.progressiveCoder = \\[\\[\\[coder class\\] alloc\\] init\\]; break; } } } // progressive decode the image in coder queue dispatch_async(self.coderQueue, ^{ @autoreleasepool { UIImage *image = \\[self.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished\\]; if (image) { NSString *key = \\[\\[SDWebImageManager sharedManager\\] cacheKeyForURL:self.request.URL\\]; image = \\[self scaledImageForKey:key image:image\\]; if (self.shouldDecompressImages) { image = \\[\\[SDWebImageCodersManager sharedInstance\\] decompressedImageWithImage:image data:&amp;imageData options:@{SDWebImageCoderScaleDownLargeImagesKey: @(NO)}\\]; } // We do not keep the progressive decoding image even when \\`finished\\`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding. \\[self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO\\]; } } }); } for (SDWebImageDownloaderProgressBlock progressBlock in \\[self callbacksForKey:kProgressCallbackKey\\]) { progressBlock(self.imageData.length, self.expectedSize, self.request.URL); } } 上边的方法处理了接收到数据的逻辑。按照正常想法，当我们接受到数据的时候，只要把收据拼接起来，根据设置选项，调用 process 回调就行了。那么为什么这个方法中用了如此大的篇幅来处理图片数据呢？ 答案就是，即使图片没有下载完，我们也能根据已经获取的图片数据，来显示一张数据不完整的图片。 通过这样一个细节，我想到了很多应用场景，比如说，之前看到过一个场景，通过滑动 slider 自上而下的显示一张图片的部分内容，我们完全可以通过上边的代码来实现。根据 slider 的 value 来控制整个 NSData 的大小，来合成图片。当然这也跟图片的组成有关。 - (void)URLSession:(NSURLSession )session dataTask:(NSURLSessionDataTask )dataTask willCacheResponse:(NSCachedURLResponse )proposedResponse completionHandler:(void (^)(NSCachedURLResponse cachedResponse))completionHandler{ NSCachedURLResponse *cachedResponse = proposedResponse; if (!(self.options &amp; SDWebImageDownloaderUseNSURLCache)) { // Prevents caching of responses cachedResponse = nil; } if (completionHandler) { completionHandler(cachedResponse); } } 该方法用于响应的缓存设置，如果把回调的参数设置为 nil，那么就不会缓存响应，总之，真正缓存的数据就是回调中的参数。 - (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task didCompleteWithError:(NSError *)error{ @synchronized(self) { self.dataTask = nil; __block typeof(self) strongSelf = self; dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:strongSelf]; if (!error) { [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:strongSelf]; } }); } // make sure to call `\\[self done\\]` to mark operation as finished if (error) { \\[self callCompletionBlocksWithError:error\\]; \\[self done\\]; } else { if (\\[self callbacksForKey:kCompletedCallbackKey\\].count &gt; 0) { /\\*\\* \\* If you specified to use \\`NSURLCache\\`, then the response you get here is what you need. */ __block NSData *imageData = \\[self.imageData copy\\]; self.imageData = nil; if (imageData) { /\\*\\* if you specified to only use cached data via \\`SDWebImageDownloaderIgnoreCachedResponse\\`, \\* then we should check if the cached data is equal to image data */ if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; \\[self.cachedData isEqualToData:imageData\\]) { // call completion block with nil \\[self callCompletionBlocksWithImage:nil imageData:nil error:nil finished:YES\\]; \\[self done\\]; } else { // decode the image in coder queue dispatch_async(self.coderQueue, ^{ @autoreleasepool { UIImage *image = \\[\\[SDWebImageCodersManager sharedInstance\\] decodedImageWithData:imageData\\]; NSString *key = \\[\\[SDWebImageManager sharedManager\\] cacheKeyForURL:self.request.URL\\]; image = \\[self scaledImageForKey:key image:image\\]; // Do not force decoding animated images or GIF, // because there has imageCoder which can change \\`image\\` or \\`imageData\\` to static image, lose the animated feature totally. BOOL shouldDecode = !image.images &amp;&amp; image.sd_imageFormat != SDImageFormatGIF; if (shouldDecode) { if (self.shouldDecompressImages) { BOOL shouldScaleDown = self.options &amp; SDWebImageDownloaderScaleDownLargeImages; image = \\[\\[SDWebImageCodersManager sharedInstance\\] decompressedImageWithImage:image data:&amp;imageData options:@{SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)}\\]; } } CGSize imageSize = image.size; if (imageSize.width == 0 || imageSize.height == 0) { \\[self callCompletionBlocksWithError:\\[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;}\\]\\]; } else { \\[self callCompletionBlocksWithImage:image imageData:imageData error:nil finished:YES\\]; } \\[self done\\]; } }); } } else { \\[self callCompletionBlocksWithError:\\[NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @&quot;Image data is nil&quot;}\\]\\]; \\[self done\\]; } } else { \\[self done\\]; } } } 该方法是处理了图片下载完成之后的逻辑，也没有很特别的东西，比较复杂的是对完成后的数据的处理更加完善。要做到这一点，确实需要 N 多知识的积累。 - (void)URLSession:(NSURLSession )session task:(NSURLSessionTask )task didReceiveChallenge:(NSURLAuthenticationChallenge )challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential credential))completionHandler{ NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; if (\\[challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust\\]) { if (!(self.options &amp; SDWebImageDownloaderAllowInvalidSSLCertificates)) { disposition = NSURLSessionAuthChallengePerformDefaultHandling; } else { credential = \\[NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust\\]; disposition = NSURLSessionAuthChallengeUseCredential; } } else { if (challenge.previousFailureCount == 0) { if (self.credential) { credential = self.credential; disposition = NSURLSessionAuthChallengeUseCredential; } else { disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; } } else { disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; } } if (completionHandler) { completionHandler(disposition, credential); } } 这个方法跟 HTTPS 有点关系，要想说明白这个方法究竟干了什么事，需要对验证有点了解才行。 当我们发出了一个请求，这个请求到达服务器后，假定服务器设置了需要验证，那么这个方法就会被调用。服务器会返回去一个NSURLAuthenticationChallenge。通过 NSURLAuthenticationChallenge 的 protectionSpace，获取授权 method。如果这个 method 是服务器信任的， 那么我们就可以直接使用服务器返回的证书，当然，我们也可以使用自己的证书，其他情况都会被认为验证失败，当前请求将会被取消。当有了证书后，客户端就可以使用证书中的公钥对数据进行加密了。 其他的方法： - (nullable UIImage )scaledImageForKey:(nullable NSString )key image:(nullable UIImage *)image { return SDScaledImageForKey(key, image);} - (BOOL)shouldContinueWhenAppEntersBackground { return self.options &amp; SDWebImageDownloaderContinueInBackground;} - (void)callCompletionBlocksWithError:(nullable NSError *)error { [self callCompletionBlocksWithImage:nil imageData:nil error:error finished:YES];} - (void)callCompletionBlocksWithImage:(nullable UIImage )image imageData:(nullable NSData )imageData error:(nullable NSError )error finished:(BOOL)finished { NSArray completionBlocks = [self callbacksForKey:kCompletedCallbackKey]; dispatch_main_async_safe(^{ for (SDWebImageDownloaderCompletedBlock completedBlock in completionBlocks) { completedBlock(image, imageData, error, finished); } });} 四、总结SDWebImageDownloaderOperation 提供了下载单张图片的能力，在真实开发中，图片往往都是一组一组的出现的。","tags":[]},{"title":" SDWebImageCache、SDImageCacheConfig\t\t","date":"2019-03-14T09:25:17.000Z","path":"2019/03/14/sdwebimagecache-e3-80-81sdimagecacheconfig/","text":"文章：SDWebImage源码解读之SDWebImageCache(上)、SDWebImage源码解读之SDWebImageCache(下)、NSMapTable: 不只是一个能放weak指针的 NSDictionary 本篇主要讲解图片缓存类的知识，虽然只涉及了图片方面的缓存的设计，但思想同样适用于别的方面的设计。在架构上来说，缓存算是存储设计的一部分。我们把各种不同的存储内容按照功能进行切割后，图片缓存便是其中的一个。 在封装自己的图片缓存管理对象的时候，SDWebImageCache 能够提供大约 90% 的代码给我们直接使用，基于这些代码，我们需要分析出作者的设计思想是什么。当需要缓存某个列表时，基于 SDWebImageCache 的设计思想，我们就能够设计出比较合理的缓存管理对象了。 一、.h 文件只看作者暴露出来的内容，来分析该类有哪些属性和方法，必须明白如何使用这个缓存管理者。 1、缓存位置 typedef NS_ENUM(NSInteger, SDImageCacheType) { /** * The image wasn’t available the SDWebImage caches, but was downloaded from the web. / SDImageCacheTypeNone, /\\* * The image was obtained from the disk cache. * * 硬盘 / SDImageCacheTypeDisk, /\\* * The image was obtained from the memory cache. * * 内存 */ SDImageCacheTypeMemory}; 2、配置 通过 SDImageCacheConfig 这个类来管理缓存的配置信息，打开 SDImageCacheConfig 后，发现可以配置的东西有： /** * 基于什么清除磁盘缓存 /typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) { /\\* * When the image is accessed it will update this value 基于图片创建时间 / SDImageCacheConfigExpireTypeAccessDate, /\\* * The image was obtained from the disk cache (Default) 基于图片修改时间 */ SDImageCacheConfigExpireTypeModificationDate}; @interface SDImageCacheConfig : NSObject /** * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory. * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption. * * 是否解压缩图片 */@property (assign, nonatomic) BOOL shouldDecompressImages; /** * Whether or not to disable iCloud backup. Defaults to YES. * * 是否禁止 iCloud 备份 */@property (assign, nonatomic) BOOL shouldDisableiCloud; /** * Whether or not to use memory cache. Defaults to YES. * @note When the memory cache is disabled, the weak memory cache will also be disabled. * * 是否缓存一份到内存中 */@property (assign, nonatomic) BOOL shouldCacheImagesInMemory; /** * The option to control weak memory cache for images. When enable, `SDImageCache`‘s memory cache will use a weak maptable to store the image at the same time when it stored to memory, and get removed at the same time. * However when memory warning is triggered, since the weak maptable does not hold a strong reference to image instacnce, even when the memory cache itself is purged, some images which are held strongly by UIImageViews or other live instances can be recovered again, to avoid later re-query from disk cache or network. This may be helpful for the case, for example, when app enter background and memory is purged, cause cell flashing after re-enter foreground. * Defautls to YES. You can change this option dynamically. * * 是否额外存一份弱引用的缓存 */@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache; /** * The reading options while reading cache from disk. * Defaults to 0. You can set this to `NSDataReadingMappedIfSafe` to improve performance. * * 从磁盘读取图片的配置项。默认是 NSDataReadingMappedIfSafe，也就是使用文件映射内存的方式，是不消耗内存的 */@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions; /** * The writing options while writing cache to disk. * Defaults to `NSDataWritingAtomic`. You can set this to `NSDataWritingWithoutOverwriting` to prevent overwriting an existing file. * * 写文件的配置项。默认是 NSDataWritingAtomic，也就是会覆盖原有的文件 */@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions; /** * The maximum length of time to keep an image in the cache, in seconds. * * 图片在磁盘的最大缓存不过期时间，单位为秒，默认是一周 */@property (assign, nonatomic) NSInteger maxCacheAge; /** * The maximum size of the cache, in bytes. * * 最大的缓存尺寸，单位为字节，默认为 0，即没有限制 */@property (assign, nonatomic) NSUInteger maxCacheSize; /** * The attribute which the clear cache will be checked against when clearing the disk cache. Default is Modified Date * * 清除磁盘缓存是基于什么清除，默认是 SDImageCacheConfigExpireTypeModificationDate，即基于图片修改时间 */@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType; @end static const NSInteger kDefaultCacheMaxCacheAge = 60 60 24 * 7; // 1 week @implementation SDImageCacheConfig - (instancetype)init { if (self = [super init]) { _shouldDecompressImages = YES; _shouldDisableiCloud = YES; _shouldCacheImagesInMemory = YES; _shouldUseWeakMemoryCache = YES; _diskCacheReadingOptions = 0; _diskCacheWritingOptions = NSDataWritingAtomic; _maxCacheAge = kDefaultCacheMaxCacheAge; _maxCacheSize = 0; _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate; } return self;} 3、内存最大缓存 /** * The maximum “total cost” of the in-memory image cache. The cost function is the number of pixels held in memory. */@property (assign, nonatomic) NSUInteger maxMemoryCost; 通过 maxMemoryCost 来设置内存的最大缓存是多少，这个是以像素为单位的。 4、最大内存缓存数量 /** * The maximum number of objects the cache should hold. */@property (assign, nonatomic) NSUInteger maxMemoryCountLimit; 通过 maxMemoryCountLimit 来设置内存的最大缓存数量是多少。 5、初始化 一般来说，管理类都有一个全局的单例对象，然后根据业务需求设计不同的初始化方法。不管是什么样的类，在设计它的时候，应该通过合理的初始化方法告诉别的开发者，该类应该如何创建。 /** * Returns global shared cache instance */+ (nonnull instancetype)sharedImageCache; /** * Init a new cache store with a specific namespace * * 通过指定的 namespace 来初始化 */- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns; /** * Init a new cache store with a specific namespace and directory * * 通过指定的 namespace 和图片缓存位置来初始化 */- (nonnull instancetype)initWithNamespace:(nonnull NSString )ns diskCacheDirectory:(nonnull NSString )directory NS_DESIGNATED_INITIALIZER; 注意：如果想设置某个方法为指定的初始化方法，通过 NS_DESIGNATED_INITIALIZER 来实现。 6、Cache paths 既然把数据缓存到了 disk 中，那么就要提供一个方法获取这个缓存路径。这里通过下边这个方法，根据 namespace 获取缓存路径： - (nullable NSString )makeDiskCachePath:(nonnull NSString)fullNamespace; 注意：在开发中，我们会遇到这样的情况，假如之前把图片缓存到了地址 1，现在打算重构代码。写了这么一个缓存管理者，我需要和之前缓存的图片建立联系，但是以后都打算使用新写的这个管理者，那怎么办呢？ 只需要把之前的路径添加到管理类的路径集合中就行了。主要目的是在搜索图片的时候，也有权限去搜索新添加的路径。 一个好的架构或框架，应该使用这用思想。 这也是下边这个方法的意义： /** * Add a read-only cache path to search for images pre-cached by SDImageCache Useful if you want to bundle pre-loaded images with your app * * @param path The path to use for this read-only cache path */- (void)addReadOnlyCachePath:(nonnull NSString *)path; 7、存储图片 图片会被存储到内存或者硬盘中，在这一存储过程的设计中有下边这几个需要考虑的因素： 数据源：可以保存 UIImage 也可以保存 NSData 唯一标识：找到该数据的唯一标识，一般使用图片的 URL 是否需要保存到硬盘：根据配置文件中的设置，如果设置了应该缓存到内存，那么图片肯定会被缓存到内存中。 数据保存这一过程必须是异步的，在完成之后，在主线程回调。 代码如下： /** * Asynchronously store an image into memory and disk cache at the given key. */- (void)storeImage:(nullable UIImage )image forKey:(nullable NSString )key completion:(nullable SDWebImageNoParamsBlock)completionBlock; /** * Asynchronously store an image into memory and disk cache at the given key. */- (void)storeImage:(nullable UIImage )image forKey:(nullable NSString )key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock; /** * Asynchronously store an image into memory and disk cache at the given key. * * @param image The image to store * @param imageData The image data as returned by the server, this representation will be used for disk storage * instead of converting the given image object into a storable/compressed image format in order * to save quality and CPU * @param key The unique image cache key, usually it’s image absolute URL * @param toDisk Store the image to disk cache if YES * @param completionBlock A block executed after the operation is finished * * 参数最全的方法。 */- (void)storeImage:(nullable UIImage )image imageData:(nullable NSData )imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock; /** * Synchronously store image NSData into disk cache at the given key. */- (void)storeImageDataToDisk:(nullable NSData )imageData forKey:(nullable NSString )key; 8、获取图片 对于如何获取图片。作者给出了比较多的方式，首先考虑内存和硬盘，其次考虑异步获取还是同步获取。如果获取数据异步的，就要使用 block。总结下来有这么几种情况： 异步判断图片是否被缓存到 disk /** * Async check if image exists in disk cache already (does not load the image) * * @note the completion block will be always executed on the main queue */- (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock; 同步判断 disk 中是否有缓存和返回缓存 /** * Sync check if image data exists in disk cache already (does not load the image) */- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key; /** * Query the image data for the given key synchronously. nil if not found. */- (nullable NSData )diskImageDataForKey:(nullable NSString )key; 异步查询图片是否存在。这里返回了一个 NSOperation，原因是在内存中获取耗时非常短，在 disk 中时间相对较长。 /** * Operation that queries the cache asynchronously and call the completion when done. * * @param doneBlock The completion block. Will not get called if the operation is cancelled * * @return a NSOperation instance containing the cache op. */- (nullable NSOperation )queryCacheOperationForKey:(nullable NSString )key done:(nullable SDCacheQueryCompletedBlock)doneBlock; 同步在 memory 查询图片 /** * Query the memory cache synchronously. nil if not found. */- (nullable UIImage )imageFromMemoryCacheForKey:(nullable NSString )key; 同步在 disk 查询图片 /** * Query the disk cache synchronously. nil if not found. */- (nullable UIImage )imageFromDiskCacheForKey:(nullable NSString )key; 同步查找图片，先 memory 后 disk /** * Query the cache (memory and or disk) synchronously after checking the memory cache. nil if not found. */- (nullable UIImage )imageFromCacheForKey:(nullable NSString )key; 9、移除某条数据 数据可能存在于内存，也可能是 disk，也可能两者都有，那么要想移除数据，就要考虑这些情况了。 全部移除 memory 和 disk（异步） /** * Remove the image from memory and disk cache asynchronously */- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion; 移除 memory 数据，可选移除 disk 数据（异步） /** * Remove the image from memory and optionally disk cache asynchronously */- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion; 10、移除数据 这个移除不同于上边的移除，它会清空所有的符合条件的数据。 清空 memory /** * Clear all memory cached images */- (void)clearMemory; 清空 disk（异步） /** * Async clear all disk cached images. Non-blocking method - returns immediately. */- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion; 清空过期数据（异步） /** * Async remove all expired cached image from disk. Non-blocking method - returns immediately. */- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock; 11、获取缓存相关信息 获取 disk 使用 size /** * Get the size used by the disk cache */- (NSUInteger)getSize; 获取 disk 缓存的图片数目 /** * Get the number of images in the disk cache */- (NSUInteger)getDiskCount; 获取 disk 使用 size（异步） /** * Asynchronously calculate the disk cache’s size. */- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock; 获取某个路径下的指定的图片。比如 key 为 http://www.123.com/image.png，path 为 http://www.456.com，那么方法返回 http://www.456.com/image.png /** * Get the cache path for a certain key (needs the cache path root folder) * * @param key the key (can be obtained from url using cacheKeyForURL) * @param path the cache path root folder * * @return the cache path */- (nullable NSString )cachePathForKey:(nullable NSString )key inPath:(nonnull NSString *)path; 获取默认的缓存路径 /** * Get the default cache path for a certain key */- (nullable NSString )defaultCachePathForKey:(nullable NSString )key; 二、NSCache对于很多开发者来说，NSCache 是一个陌生人，因为大家往往对 NSMutableDictionary 情有独钟，可怜的 NSCache 一直处于 NSMutableDictionary 的阴影之下。就好像没有人知道它提供了垃圾处理的功能，而开发者们却费劲力气地去自己实现它。 NSCache 基本上就是一个会自动移除对象来释放内存的 NSMutableDictionary。无需响应内存警告或者使用计时器来清除缓存。唯一不同的是键对象不会像 NSMutableDictionary 中那样被复制（键不需要实现 NSCopying 协议），这实际上是它的一个优点。 当有缓存数据到内存的业务的时候，就应该考虑 NSCache 了，有缓存就有清除缓存。 NSCache 每个方法和属性的具体作用，请参考这篇文章NSCache 三、.m 文件不管是图片的缓存还是其他各种不同形式的缓存，在原理上都极其相似，通过 SDWebImageCache 来看看如何实现缓存功能。 #define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); #define UNLOCK(lock) dispatch_semaphore_signal(lock); 用信号量来实现锁的功能。 1、SDMemoryCache /** * A memory cache which auto purge the cache on memory warning and support weak cache. * * 内存缓存，在内存出现警告时自动清除缓存并支持弱缓存。 */@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; @end @interface SDMemoryCache &lt;KeyType, ObjectType&gt; () // 缓存配置@property (nonatomic, strong, nonnull) SDImageCacheConfig *config; // strong-weak cache 弱引用缓存@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // a lock to keep the access to `weakCache` thread-safe 用于线程安全的锁，实际为信号量@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; - (instancetype)init NS_UNAVAILABLE;- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config; @end NSCache 在收到内存警告的时候会释放自身的一部分资源，设计 SDMemoryCache 的目的是在收到警告时，释放缓存的所有资源。 #if SD_UIKIT - (void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];} - (instancetype)initWithConfig:(SDImageCacheConfig *)config{ self = [super init]; if (self) { // Use a strong-weak maptable storing the secondary cache. Follow the doc that NSCache does not copy keys // This is useful when the memory warning, the cache was purged. However, the image instance can be retained by other instance such as imageViews and alive. // At this case, we can sync weak cache back and do not need to load from disk cache // 使用强弱映射表存储次要的缓存。按照文档说明，NSCache 不会复制 Key // 当内存警告清除缓存时，这很有用。但是，image 对象还能被其他实例（如 UIImageView 对象）持有 self.weakCache = \\[\\[NSMapTable alloc\\] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0\\]; self.weakCacheLock = dispatch\\_semaphore\\_create(1); self.config = config; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:self selector:@selector(didReceiveMemoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil\\]; } return self; } 析构函数和初始化方法，监听内存警告通知，重点学习 weakCache 的创建。在 iOS 和 osTV 平台使用。 // `setObject:forKey:` just call this with 0 cost. Override this is enough- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g { [super setObject:obj forKey:key cost:g]; // 不需要弱引用缓存 if (!self.config.shouldUseWeakMemoryCache) { return; } // key - value 同时存在 if (key &amp;&amp; obj) { // Store weak cache LOCK(self.weakCacheLock); // Do the real copy of the key and only let NSMapTable manage the key&apos;s lifetime // Fixes issue #2507 https://github.com/SDWebImage/SDWebImage/issues/2507 \\[self.weakCache setObject:obj forKey:\\[\\[key mutableCopy\\] copy\\]\\]; UNLOCK(self.weakCacheLock); } } - (id)objectForKey:(id)key { id obj = [super objectForKey:key]; // 不需要弱引用缓存 if (!self.config.shouldUseWeakMemoryCache) { return obj; } // 如果 key 存在 &amp; obj 不存在 if (key &amp;&amp; !obj) { // Check weak cache LOCK(self.weakCacheLock); obj = \\[self.weakCache objectForKey:key\\]; UNLOCK(self.weakCacheLock); if (obj) { // Sync cache NSUInteger cost = 0; if (\\[obj isKindOfClass:\\[UIImage class\\]\\]) { cost = \\[(UIImage *)obj sd_memoryCost\\]; } // 重新将 obj 存入 NSCache \\[super setObject:obj forKey:key cost:cost\\]; } } return obj; } - (void)removeObjectForKey:(id)key { [super removeObjectForKey:key]; // 不需要弱引用缓存 if (!self.config.shouldUseWeakMemoryCache) { return; } if (key) { // Remove weak cache LOCK(self.weakCacheLock); \\[self.weakCache removeObjectForKey:key\\]; UNLOCK(self.weakCacheLock); } } - (void)removeAllObjects { [super removeAllObjects]; if (!self.config.shouldUseWeakMemoryCache) { return; } // Manually remove should also remove weak cache LOCK(self.weakCacheLock); [self.weakCache removeAllObjects]; UNLOCK(self.weakCacheLock);} 重写 NSCache 的方法，每个方法都先调用 super 方法删除 self 的内容，然后再根据逻辑判断选择是否需要对 weakCache 进行操作。 注意：[[key mutableCopy] copy] 是为了确切的深复制数据。 @interface SDImageCache () @property (strong, nonatomic, nonnull) SDMemoryCache memCache; // 内存容器@property (strong, nonatomic, nonnull) NSString diskCachePath; // 硬盘缓存路径 // 自定义的读取路径。是一个数组，可以通过 addReadOnlyCachePath: 这个方法往里边添加路径。当读取图片的时候，这个数组的路径也会作为数据源@property (strong, nonatomic, nullable) NSMutableArray *customPaths; // 输入输出队列。队列往往可以当做一种”锁“来使用，把某些任务按照顺序一步一步的执行，必须考虑线程是否安全@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;@property (strong, nonatomic, nonnull) NSFileManager *fileManager; // 文件管理者 @end 私有属性。 2、Singleton、init、dealloc 重点讲解最后一个初始化方法： - (nonnull instancetype)initWithNamespace:(nonnull NSString )ns diskCacheDirectory:(nonnull NSString )directory{ if ((self = [super init])) { NSString *fullNamespace = [@”com.hackemist.SDWebImageCache.” stringByAppendingString:ns]; // Create IO serial queue 串行队列 \\_ioQueue = dispatch\\_queue\\_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH\\_QUEUE_SERIAL); _config = \\[\\[SDImageCacheConfig alloc\\] init\\]; // Init the memory cache \\_memCache = \\[\\[SDMemoryCache alloc\\] initWithConfig:\\_config\\]; _memCache.name = fullNamespace; // Init the disk cache if (directory != nil) { _diskCachePath = \\[directory stringByAppendingPathComponent:fullNamespace\\]; } else { // 获取 directories 文件夹，拼接路径 NSString *path = \\[self makeDiskCachePath:ns\\]; _diskCachePath = path; } dispatch\\_sync(\\_ioQueue, ^{ self.fileManager = \\[NSFileManager new\\]; }); #if SD_UIKIT // Subscribe to app events [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil]; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil\\]; #endif } return self; } 这个方法做了两件事：①、初始化自身的属性；②、添加通知监听。 3、Cache paths 添加自定义路径 - (void)addReadOnlyCachePath:(nonnull NSString *)path { if (!self.customPaths) { self.customPaths = [NSMutableArray new]; } if (!\\[self.customPaths containsObject:path\\]) { \\[self.customPaths addObject:path\\]; } } 文件名（MD5） /** * 对 key 值做 MD5 算法处理 */- (nullable NSString )cachedFileNameForKey:(nullable NSString )key { const char str = key.UTF8String; if (str == NULL) { str = “”; } unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSURL keyURL = [NSURL URLWithString:key]; NSString ext = keyURL ? keyURL.pathExtension : key.pathExtension; // File system has file name length limit, we need to check if ext is too long, we don’t add it to the filename if (ext.length &gt; SD_MAX_FILE_EXTENSION_LENGTH) { ext = nil; } NSString filename = [NSString stringWithFormat:@”%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@”, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @”” : [NSString stringWithFormat:@”.%@”, ext]]; return filename;} 默认的某个图片的路径 - (nullable NSString )defaultCachePathForKey:(nullable NSString )key { return [self cachePathForKey:key inPath:self.diskCachePath];} 根据名称和路径拼接路径 - (nullable NSString )cachePathForKey:(nullable NSString )key inPath:(nonnull NSString )path { NSString filename = [self cachedFileNameForKey:key]; return [path stringByAppendingPathComponent:filename];} 4、Store Image 参数最多的保存图片的方法 - (void)storeImage:(nullable UIImage )image forKey:(nullable NSString )key completion:(nullable SDWebImageNoParamsBlock)completionBlock { [self storeImage:image imageData:nil forKey:key toDisk:YES completion:completionBlock];} - (void)storeImage:(nullable UIImage )image forKey:(nullable NSString )key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock { [self storeImage:image imageData:nil forKey:key toDisk:toDisk completion:completionBlock];} - (void)storeImage:(nullable UIImage )image imageData:(nullable NSData )imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock { // 检查 image 和 key 是否为 nil if (!image || !key) { if (completionBlock) { completionBlock(); } return; } // if memory cache is enabled // 根据配置文件中是否设置了缓存到内存，保存 image 到缓存中。这个过程是非常快的，因此不用考虑线程 if (self.config.shouldCacheImagesInMemory) { NSUInteger cost = image.sd_memoryCost; \\[self.memCache setObject:image forKey:key cost:cost\\]; } // 保存到 disk if (toDisk) { // 异步串行 dispatch_async(self.ioQueue, ^{ @autoreleasepool { NSData *data = imageData; if (!data &amp;&amp; image) { // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format 如果我们没有检测图像格式的数据，请检查它是否包含使用PNG或JPEG格式的alpha通道。 SDImageFormat format; // 检查图片是否有透明通道 if (SDCGImageRefContainsAlpha(image.CGImage)) { format = SDImageFormatPNG; } else { format = SDImageFormatJPEG; } // 通过 SDWebImageCodersManager 解析成二进制数据 data = \\[\\[SDWebImageCodersManager sharedInstance\\] encodedDataWithImage:image format:format\\]; } // 存储到 disk 方法 \\[self _storeImageDataToDisk:data forKey:key\\]; } if (completionBlock) { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ completionBlock(); }); } }); } else { if (completionBlock) { completionBlock(); } } } 保存数据到 disk - (void)storeImageDataToDisk:(nullable NSData )imageData forKey:(nullable NSString )key { if (!imageData || !key) { return; } dispatch_sync(self.ioQueue, ^{ \\[self _storeImageDataToDisk:imageData forKey:key\\]; }); } // Make sure to call form io queue by caller- (void)_storeImageDataToDisk:(nullable NSData )imageData forKey:(nullable NSString )key { // 检查 imageData 或者 key 是否为 nil if (!imageData || !key) { return; } // 创建 disk 缓存文件夹 if (!\\[self.fileManager fileExistsAtPath:_diskCachePath\\]) { \\[self.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL\\]; } // get cache Path for image key // 根据 key 获取默认的缓存路径 NSString *cachePathForKey = \\[self defaultCachePathForKey:key\\]; // transform to NSUrl 转成 NSURL NSURL *fileURL = \\[NSURL fileURLWithPath:cachePathForKey\\]; // 写入数据 \\[imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil\\]; // disable iCloud backup // 根据配置文件设置是否禁用 iCloud 的备份功能 if (self.config.shouldDisableiCloud) { \\[fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil\\]; } } 5、Query and Retrieve 根据 key 判断 disk 中的数据是否存在 - (void)diskImageExistsWithKey:(nullable NSString *)key completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock{ // 异步串行 dispatch_async(self.ioQueue, ^{ BOOL exists = [self _diskImageDataExistsWithKey:key]; if (completionBlock) { dispatch_async(dispatch_get_main_queue(), ^{ completionBlock(exists); }); } });} - (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key{ if (!key) { return NO; } __block BOOL exists = NO; // 异步串行 dispatch_sync(self.ioQueue, ^{ exists = \\[self _diskImageDataExistsWithKey:key\\]; }); return exists; } /** * Make sure to call form io queue by caller. 确保在 io 队列中执行 */- (BOOL)_diskImageDataExistsWithKey:(nullable NSString *)key{ if (!key) { return NO; } BOOL exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key]]; // fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension if (!exists) { // 去除扩展名再次检查 exists = \\[self.fileManager fileExistsAtPath:\\[self defaultCachePathForKey:key\\].stringByDeletingPathExtension\\]; } return exists; } 获取 memory 中的数据 - (nullable UIImage )imageFromMemoryCacheForKey:(nullable NSString )key { return [self.memCache objectForKey:key];} 获取 disk 中的数据 在 disk 中获取数据跟在内存中获取不一样，内存中直接保存的是 UIImage，而 disk 中保存的是 NSData，因此肯定需要一个NSData -&gt; UIImage 的转换过程。接下来我们看看这个转换过程： ①、根据 key 获取 disk 中的 NSData 数据。总体思路就是先从默认的路径获取，如果没有获取到，再从自定义的路径获取，值得注意的是，要考虑没有 pathExtention 的情况。 - (nullable NSData )diskImageDataBySearchingAllPathsForKey:(nullable NSString )key{ // 先从默认的路径获取 NSString defaultPath = [self defaultCachePathForKey:key]; NSData data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil]; if (data) { return data; } // fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension // 去掉扩展名的影响 data = \\[NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil\\]; if (data) { return data; } NSArray&lt;NSString *&gt; *customPaths = \\[self.customPaths copy\\]; // 从自定义的路径获取 for (NSString *path in customPaths) { NSString *filePath = \\[self cachePathForKey:key inPath:path\\]; NSData *imageData = \\[NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil\\]; if (imageData) { return imageData; } // fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name // checking the key with and without the extension // 去掉扩展名的影响 imageData = \\[NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil\\]; if (imageData) { return imageData; } } return nil; } ②、根据 NSData 获取 UIImage，需要 scaled 图片，根据配置文件的设置，是否解压图片。 - (nullable UIImage )diskImageForKey:(nullable NSString )key{ NSData *data = [self diskImageDataForKey:key]; return [self diskImageForKey:key data:data];} /** * 1、对 key 做判断 * 2、加入 io 队列执行 */- (nullable NSData )diskImageDataForKey:(nullable NSString )key { if (!key) { return nil; } __block NSData *imageData = nil; dispatch_sync(self.ioQueue, ^{ imageData = [self diskImageDataBySearchingAllPathsForKey:key]; }); return imageData; } - (nullable UIImage )diskImageForKey:(nullable NSString )key data:(nullable NSData *)data { return [self diskImageForKey:key data:data options:0];} /** * 关键方法：NSData -&gt; UIImage */- (nullable UIImage )diskImageForKey:(nullable NSString )key data:(nullable NSData )data options:(SDImageCacheOptions)options{ if (data) { // 获取 UIImage UIImage image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data]; image = [self scaledImageForKey:key image:image]; // 解压 if (self.config.shouldDecompressImages) { BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages; image = \\[\\[SDWebImageCodersManager sharedInstance\\] decompressedImageWithImage:image data:&amp;data options:@{SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)}\\]; } return image; } else { return nil; } } /** * 调用 SDWebImageCompat 类的缩放方法 */- (nullable UIImage )scaledImageForKey:(nullable NSString )key image:(nullable UIImage *)image { return SDScaledImageForKey(key, image);} ③、将 UIImage 放入内存，返回图片 - (nullable UIImage )imageFromDiskCacheForKey:(nullable NSString )key{ UIImage *diskImage = [self diskImageForKey:key]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) { NSUInteger cost = diskImage.sd_memoryCost; [self.memCache setObject:diskImage forKey:key cost:cost]; } return diskImage; } 4、先获取内存的数据，如果没有，再获取 disk 的数据 - (nullable UIImage )imageFromCacheForKey:(nullable NSString )key{ // First check the in-memory cache… UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) { return image; } // Second check the disk cache... image = \\[self imageFromDiskCacheForKey:key\\]; return image; } 5、异步获取数据 上边 1、2、3、4 中获取数据的方法都不是异步获取的，在 SDWebImageCache 中涉及到异步获取的，都会通过 Block 来回调。 这个异步获取值得说的有两点： 如果在内存中获取到的图片是 GIF，那么要去 disk 中获取 返回一个 NSOperation 对象，我们可以通过这个 NSOperation 对象取消获取任务。 代码： - (NSOperation )queryCacheOperationForKey:(NSString )key done:(SDCacheQueryCompletedBlock)doneBlock { return [self queryCacheOperationForKey:key options:0 done:doneBlock];} - (nullable NSOperation )queryCacheOperationForKey:(nullable NSString )key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock{ // key 为空，直接回调和返回 if (!key) { if (doneBlock) { doneBlock(nil, nil, SDImageCacheTypeNone); } return nil; } // First check the in-memory cache... UIImage *image = \\[self imageFromMemoryCacheForKey:key\\]; BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory)); // 只在内存中查找缓存 if (shouldQueryMemoryOnly) { if (doneBlock) { doneBlock(image, nil, SDImageCacheTypeMemory); } return nil; } NSOperation *operation = \\[NSOperation new\\]; void(^queryDiskBlock)(void) = ^{ if (operation.isCancelled) { // do not call the completion if cancelled return; } @autoreleasepool { NSData *diskData = \\[self diskImageDataBySearchingAllPathsForKey:key\\]; UIImage *diskImage; SDImageCacheType cacheType = SDImageCacheTypeNone; if (image) { // the image is from in-memory cache // 缓存中存在 diskImage = image; cacheType = SDImageCacheTypeMemory; } else if (diskData) { cacheType = SDImageCacheTypeDisk; // decode image data only if in-memory cache missed // 从 disk 获得数据时，都要写入内存 diskImage = \\[self diskImageForKey:key data:diskData options:options\\]; if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) { NSUInteger cost = diskImage.sd_memoryCost; \\[self.memCache setObject:diskImage forKey:key cost:cost\\]; } } if (doneBlock) { if (options &amp; SDImageCacheQueryDiskSync) { doneBlock(diskImage, diskData, cacheType); } else { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ doneBlock(diskImage, diskData, cacheType); }); } } } }; if (options &amp; SDImageCacheQueryDiskSync) { queryDiskBlock(); } else { dispatch_async(self.ioQueue, queryDiskBlock); } return operation; } 6、Remove - (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion{ [self removeImageForKey:key fromDisk:YES withCompletion:completion];} - (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion{ if (key == nil) { return; } // 从内存中删除 if (self.config.shouldCacheImagesInMemory) { \\[self.memCache removeObjectForKey:key\\]; } // 从硬盘中删除 if (fromDisk) { dispatch_async(self.ioQueue, ^{ \\[self.fileManager removeItemAtPath:\\[self defaultCachePathForKey:key\\] error:nil\\]; if (completion) { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ completion(); }); } }); } // 不删除，直接回调 else if (completion){ completion(); } } 7、Mem Cache settings - (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost { self.memCache.totalCostLimit = maxMemoryCost;} - (NSUInteger)maxMemoryCost { return self.memCache.totalCostLimit;} - (NSUInteger)maxMemoryCountLimit { return self.memCache.countLimit;} - (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit { self.memCache.countLimit = maxCountLimit;} 设置/获取缓存对象的属性。 8、Cache clean 清空数据有值得我们注意的地方，一个一个方法的看： 清空内存缓存数据 - (void)clearMemory { [self.memCache removeAllObjects];} 清空 disk 数据 - (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion{ // 异步串行 dispatch_async(self.ioQueue, ^{ [self.fileManager removeItemAtPath:self.diskCachePath error:nil]; [self.fileManager createDirectoryAtPath:self.diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; if (completion) { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ completion(); }); } }); } 清空旧数据 对于清空旧数据而言，我们需要考虑两个方面： ①、首先要清空掉所有的过期的数据； ②、过期的数据清空后，缓存的数据比我们设置的最大缓存量还大，我们要继续清空数据，直到满足我们的需求为止。 这里边大概用到的思路就是上边说的两点，关键是如何实现上边所说的内容。有一些我们平时可能不太接触的知识点，在这里做一些简要的讲解。 首先我们需要遍历 Disk 缓存路径下的所有文件，那么怎么遍历呢？NSFileManager 有一个很好地方法： /* enumeratorAtURL:includingPropertiesForKeys:options:errorHandler: returns an NSDirectoryEnumerator rooted at the provided directory URL. The NSDirectoryEnumerator returns NSURLs from the -nextObject method. The optional ‘includingPropertiesForKeys’ parameter indicates which resource properties should be pre-fetched and cached with each enumerated URL. The optional ‘errorHandler’ block argument is invoked when an error occurs. Parameters to the block are the URL on which an error occurred and the error. When the error handler returns YES, enumeration continues if possible. Enumeration stops immediately when the error handler returns NO. If you wish to only receive the URLs and no other attributes, then pass &apos;0&apos; for &apos;options&apos; and an empty NSArray (&apos;\\[NSArray array\\]&apos;) for &apos;keys&apos;. If you wish to have the property caches of the vended URLs pre-populated with a default set of attributes, then pass &apos;0&apos; for &apos;options&apos; and &apos;nil&apos; for &apos;keys&apos;. */ /** * @param url 需要遍历的路径 * @param keys 传入一个数组，表示想获取的 NSURLResourceKeys。 * * NSURLIsDirectoryKey 是否是文件夹 * NSURLContentModificationDateKey 最后修改时间 * NSURLTotalFileAllocatedSizeKey 分配的尺寸 * * @param mask 传入过滤参数，NSDirectoryEnumerationSkipsHiddenFiles 忽略隐藏文件 * * @return 返回一个 NSDirectoryEnumerator 这个对象中存放的是 NSURLs \\/- (nullable NSDirectoryEnumerator )enumeratorAtURL:(NSURL )url includingPropertiesForKeys:(nullable NSArray )keys options:(NSDirectoryEnumerationOptions)mask errorHandler:(nullable BOOL (^)(NSURL \\url, NSError *error))handler API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)); 有了这些参数，再判断最后修改日期是否过期，删除掉过期的数据就行了。还有一个值得注意的是如何对一个字典进行排序： NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) { return \\[obj1\\[cacheContentDateKey\\] compare:obj2\\[cacheContentDateKey\\]\\]; }\\]; 这个会返回排好序的字典的所有的 key。NSSortConcurrent 是并发排序，效率高，但可能不稳定，NSSortStable 稳定，但可能效率不如 NSSortConcurrent 高。排序的规则通过 Block 指定。 基本要注意的就这些。这个函数的实现也是基于这种思路。 - (void)deleteOldFiles { [self deleteOldFilesWithCompletionBlock:nil];} - (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock { dispatch_async(self.ioQueue, ^{ NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; // Compute content date key to be used for tests NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey; switch (self.config.diskCacheExpireType) { case SDImageCacheConfigExpireTypeAccessDate: cacheContentDateKey = NSURLContentAccessDateKey; break; case SDImageCacheConfigExpireTypeModificationDate: cacheContentDateKey = NSURLContentModificationDateKey; break; default: break; } NSArray&lt;NSString *&gt; *resourceKeys = @\\[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey\\]; // This enumerator prefetches useful properties for our cache files. NSDirectoryEnumerator *fileEnumerator = \\[self.fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL\\]; NSDate *expirationDate = \\[NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge\\]; NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = \\[NSMutableDictionary dictionary\\]; NSUInteger currentCacheSize = 0; // Enumerate all of the files in the cache directory. This loop has two purposes: // // 1\\. Removing files that are older than the expiration date. // 2\\. Storing file attributes for the size-based cleanup pass. NSMutableArray&lt;NSURL *&gt; *urlsToDelete = \\[\\[NSMutableArray alloc\\] init\\]; for (NSURL *fileURL in fileEnumerator) { NSError *error; NSDictionary&lt;NSString *, id&gt; *resourceValues = \\[fileURL resourceValuesForKeys:resourceKeys error:&amp;error\\]; // Skip directories and errors. if (error || !resourceValues || \\[resourceValues\\[NSURLIsDirectoryKey\\] boolValue\\]) { continue; } // Remove files that are older than the expiration date; NSDate *modifiedDate = resourceValues\\[cacheContentDateKey\\]; if (\\[\\[modifiedDate laterDate:expirationDate\\] isEqualToDate:expirationDate\\]) { \\[urlsToDelete addObject:fileURL\\]; continue; } // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues\\[NSURLTotalFileAllocatedSizeKey\\]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles\\[fileURL\\] = resourceValues; } for (NSURL *fileURL in urlsToDelete) { \\[self.fileManager removeItemAtURL:fileURL error:nil\\]; } // If our remaining disk cache exceeds a configured maximum size, perform a second // size-based cleanup pass. We delete the oldest files first. if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) { // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // Sort the remaining cache files by their last modification time or last access time (oldest first). NSArray&lt;NSURL *&gt; *sortedFiles = \\[cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) { return \\[obj1\\[cacheContentDateKey\\] compare:obj2\\[cacheContentDateKey\\]\\]; }\\]; // Delete files until we fall below our desired cache size. for (NSURL *fileURL in sortedFiles) { if (\\[self.fileManager removeItemAtURL:fileURL error:nil\\]) { NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles\\[fileURL\\]; NSNumber *totalAllocatedSize = resourceValues\\[NSURLTotalFileAllocatedSizeKey\\]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; if (currentCacheSize &lt; desiredCacheSize) { break; } } } } if (completionBlock) { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ completionBlock(); }); } }); } 申请一段时间在后台删除旧数据 #if SD_UIKIT- (void)backgroundDeleteOldFiles{ Class UIApplicationClass = NSClassFromString(@”UIApplication”); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) { return; } UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; // 删除回调，停止后台任务 __block UIBackgroundTaskIdentifier bgTask = \\[application beginBackgroundTaskWithExpirationHandler:^{ // Clean up any unfinished task business by marking where you // stopped or ending the task outright. \\[application endBackgroundTask:bgTask\\]; bgTask = UIBackgroundTaskInvalid; }\\]; // Start the long-running task and return immediately. // 开始删除数据 \\[self deleteOldFilesWithCompletionBlock:^{ \\[application endBackgroundTask:bgTask\\]; bgTask = UIBackgroundTaskInvalid; }\\]; } #endif 9、Cache Info /** * 获取 diskCachePath 路径下的硬盘缓存大小 */- (NSUInteger)getSize{ __block NSUInteger size = 0; dispatch_sync(self.ioQueue, ^{ NSDirectoryEnumerator fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath]; for (NSString fileName in fileEnumerator) { NSString filePath = [self.diskCachePath stringByAppendingPathComponent:fileName]; NSDictionary&lt;NSString , id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil]; // 累加文件大小 size += [attrs fileSize]; } }); return size;} /** * 硬盘缓存数量 */- (NSUInteger)getDiskCount{ __block NSUInteger count = 0; dispatch_sync(self.ioQueue, ^{ NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath]; count = fileEnumerator.allObjects.count; }); return count;} /** * 获取 diskCacheURL 路径下的硬盘缓存大小 */- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock{ NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; dispatch_async(self.ioQueue, ^{ NSUInteger fileCount = 0; NSUInteger totalSize = 0; NSDirectoryEnumerator *fileEnumerator = \\[self.fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:@\\[NSFileSize\\] options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL\\]; for (NSURL *fileURL in fileEnumerator) { NSNumber *fileSize; \\[fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL\\]; totalSize += fileSize.unsignedIntegerValue; fileCount += 1; } if (completionBlock) { dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ completionBlock(fileCount, totalSize); }); } }); }","tags":[]},{"title":" UIImage+ForceDecode、SDWebImageCodersManager\t\t","date":"2019-03-14T03:11:28.000Z","path":"2019/03/14/uiimageforcedecode/","text":"文章：SDWebImage源码解读_之SDWebImageDecoder UIImage+ForceDecode 对应旧版本的 SDWebImageDecoder。 一、解码首先要弄明白一个问题：为什么要对 UIImage 进行解码？难道不能直接使用吗？ 其实不解码也是可以使用的。假如通过 imageNamed: 来加载 image，系统默认在渲染过程中会立即在主线程进行图片的解码工作，这一过程就是把 image 解码成可供控件直接使用的位图。当在主线程调用了大量的 imageNamed: 方法后，就会产生卡顿。 为了解决这个问题有两种比较简单的处理方法： 不使用 imageNamed: 加载图片，使用其他的方法，比如 imageWithContentsOfFile: 自己解码图片，可以把这个解码过程放到子线程。 通过上边两种方法，我们知道了处理图片的一些小技巧。我们还需要知道图片的一些基础知识和如何解码图片。 二、图像存储首先图像的存储是二维的，所以我们需要考虑如何表示图像中某个特定位置的值。 然后需要考虑具体的值应该如何量化。 另外，根据我们捕捉图像的途径，也会有不同的方式来编码图形数据。 一般来说，最直观的方式是将其存为位图数据，可如果你想处理一组几何图形，效率就会偏低。一个圆形可以只由三个值（两个坐标值和半径）来表示，使用位图会使文件更大，却只能做粗略的近似。 不同于位图把值存在阵列中，矢量格式存储的是绘图图像的指令。在处理一些可以被归纳为几何形状的简单图像时，这样做显然更有效率；但面对照片数据时矢量储存就会显得乏力了。建筑师设计房屋更倾向于使用矢量的方式，因为矢量格式并不仅仅局限于线条的绘制，也可以用渐变或图案的填充作为展示，所以利用矢量方式完全可以生成房屋的拟真渲染图。用于填充的图案单元则更适合被储存为一个位图。 在这种情况下，我们可能需要一种混合格式。一个非常普遍的混合格式的例子是 PostScript（或者时下比较流行的衍生格式 PDF），它基本上是一个用于绘制图像的描述语言。 上述格式主要针对印刷业，而 NeXT 和 Adobe 开发的 Display Postscript 则是进行屏幕绘制的指令集。PostScript 能够排布字母，甚至位图，这使得它成为了一个非常灵活的格式。 三、矢量图像矢量格式的一大优点是缩放。矢量格式的图像其实是一组绘图指令，这些指令通常是独立于尺寸的。如果你想扩大一个圆形，只需在绘制前扩大它的半径就可以了。位图则没这么容易。最起码，如果扩大的比例不是二的倍数，就会涉及到重绘图像，并且各个元素都只是简单地增加尺寸，成为一个色块。 由于我们不知道这图像是一个圆形，所以无法确保弧线的准确描绘，效果看起来肯定不如按比例绘制的线条那样好。也因此，在像素密度不同的设备中，矢量图像作为图形资源会非常有用。位图的话，同样的图标，在视网膜屏幕之前的 iPhone 上看起来并没有问题，在拉伸两倍后的视网膜屏幕上看起来就会发虚。就好像仅适配了 iPhone 的 App 运行在 iPad 的 2x 模式下就不再那么清晰了。 虽然 Xcode 6 已经支持了 PDF 格式，但迄今仍不完善，只是在编译时将其创建成了位图图像。最常见的矢量图像格式为 SVG，在 iOS 中也有一个渲染 SVG 文件的第三方库 SVGKit。 四、位图大部分图像都是以位图方式处理的，从这里开始，我们就将重点放在如何处理它们上。 1、如何表示两个维度 所有的格式都以一系列连续的行作为单元，而每一行则水平地按顺序存储了每个像素。大多数格式会按照行的顺序进行存储，但是这并不绝对，比如常见的交叉格式，就不严格按照行顺序。其优点是当图像被部分加载时，可以更好的显示预览图像。在互联网初期，这是一个问题，随着数据的传输速度提升，现在已经不再被当做重点。 2、如何表示位图 表示位图最简单的方法是将二进制作为每个像素的值：一个像素只有开、关两种状态，我们可以在一个字节中存储八个像素，效率非常高。不过，由于每一位只有最多两个值，我们只能储存两种颜色。考虑到现实中的颜色数以百万计，上述方法听起来并不是很有用。不过有一种情况还是需要用到这样的方法：遮罩。比如，图像的遮罩可以被用于透明性，在 iOS 中，遮罩被应用在 tab bar 的图标上（即便实际图标不是单像素位图）。 3、如何添加更多颜色 如果要添加更多的颜色，有两个基本的选择：使用一个查找表，或直接用真实的颜色值。 GIF 图像有一个颜色表（或色彩面板），可以存储最多 256 种颜色。存储在位图中的值是该查询列表中的索引值，对应着其相应的颜色。所以 GIF 文件仅限于 256 色。对于简单的线条图或纯色图，这是一种不错的解决方法。但对于照片来说，就会显示的不够真实，照片需要更精细的颜色深度。进一步的改进是 PNG 文件，这种格式可以使用一个预置的色板或者独立的通道，它们都支持可变的颜色深度。在一个通道中，每个像素的颜色分量（红、绿、蓝，即 RGB，有时添加透明度值，即 RGBA）是直接指定的。 GIF 和 PNG 对于具有大面积相同颜色的图像是最好的选择，因为它们使用的（主要是基于游程长度编码的）压缩算法可以减少存储需求。这种压缩是无损的，这意味着图像质量不会被压缩过程影响。 一个有损压缩图像格式的例子是 JPEG。创建 JPEG 图像时，通常会指定一个与图像质量相关的压缩比值参数，压缩程度过高会导致图像质量恶化。JPEG 不适用于对比鲜明的图像（如线条图），其压缩方式对类似区域的图像质量损害会相对严重。如果某张截图中包含了文本，且保存为 JPEG 格式，就可以清楚地看到：生成的图像中字符周围会出现杂散的像素点。在大部分照片中不存在这个问题，所以照片主要使用 JPEG 格式。 总结：就放大缩小而言，矢量格式（如 SVG）是最好的。对比鲜明且颜色数量有限的线条图最适合 GIF 或 PNG（其中 PNG 更为强大），而照片则应该使用 JPEG。当然，这些都不是不可逾越的规则，不过通常而言，对一定的图像质量与图像尺寸而言，遵守规则会得到最好的结果。以上内容的来源 五、UIImage+ForceDecode.h 文件@interface UIImage (ForceDecode) + (nullable UIImage )decodedImageWithImage:(nullable UIImage )image; + (nullable UIImage )decodedAndScaledDownImageWithImage:(nullable UIImage )image; @end 读完上边的内容，明白了为什么要解码图片，那么这个方法就是解码图片的实现过程。这给我们提供了一种思路：有时在优化代码的时候，可以考虑用这个方法来处理图像数据。 六、UIImage+ForceDecode..m 文件 + (UIImage )decodedImageWithImage:(UIImage )image { if (!image) { return nil; } NSData *tempData; return [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;tempData options:@{SDWebImageCoderScaleDownLargeImagesKey : @(NO)}];} + (UIImage )decodedAndScaledDownImageWithImage:(UIImage )image { if (!image) { return nil; } NSData *tempData; return [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;tempData options:@{SDWebImageCoderScaleDownLargeImagesKey : @(YES)}];} 除了对无效数据进行拦截判断，具体的工作是由 SDWebImageCodersManager 实现。 七、SDWebImageCodersManager.h 文件/** Global object holding the array of coders, so that we avoid passing them from object to object. Uses a priority queue behind scenes, which means the latest added coders have the highest priority. This is done so when encoding/decoding something, we go through the list and ask each coder if they can handle the current data. That way, users can add their custom coders while preserving our existing prebuilt ones Note: the `coders` getter will return the coders in their reversed order Example: - by default we internally set coders = `IOCoder`, `WebPCoder`. (`GIFCoder` is not recommended to add only if you want to get GIF support without `FLAnimatedImage`) - calling `coders` will return @\\[WebPCoder, IOCoder\\] - call \\[addCoder:\\[MyCrazyCoder new\\]\\] - calling `coders` now returns @\\[MyCrazyCoder, WebPCoder, IOCoder\\] Coders A coder must conform to the `SDWebImageCoder` protocol or even to `SDWebImageProgressiveCoder` if it supports progressive decoding Conformance is important because that way, they will implement `canDecodeFromData` or `canEncodeToFormat` Those methods are called on each coder in the array (using the priority order) until one of them returns YES. That means that coder can decode that data / encode to that format */@interface SDWebImageCodersManager : NSObject /* Shared reusable instance \\/+ (nonnull instancetype)sharedInstance; /* All coders in coders manager. The coders array is a priority queue, which means the later added coder will have the highest priority /@property (nonatomic, copy, readwrite, nullable) NSArray&lt;id&gt; *coders; /** * Add a new coder to the end of coders array. Which has the highest priority. @param coder coder */- (void)addCoder:(nonnull id)coder; /** Remove a coder in the coders array. @param coder coder */- (void)removeCoder:(nonnull id)coder; @end 持有编码器（IOCoder、WebPCoder）数组的全局对象，对编码器统一管理，以便避免将它们从一个对象传递到另一个对象。 在后台使用优先级队列，这意味着最新添加的编码器具有最高优先级。当编码/解码某个东西时，会浏览数组并询问每个编码器是否可以处理当前数据。这样，用户可以在保留现有预构建代码的同时添加自定义代码器。 八、SDWebImageCodersManager.m 文件#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); #define UNLOCK(lock) dispatch_semaphore_signal(lock); 将信号量当做锁来使用。 + (nonnull instancetype)sharedInstance { static dispatch_once_t once; static id instance; dispatch_once(&amp;once, ^{ instance = [self new]; }); return instance;} - (instancetype)init{ if (self = [super init]) { // initialize with default coders NSMutableArray&lt;id&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy]; #ifdef SD_WEBP [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]]; #endif _coders = [mutableCoders copy]; _codersLock = dispatch_semaphore_create(1); } return self;} 初始化方法。默认会在编码器数组中存放一个 IOCoder，如果定义了 SD_WEBP 宏还添加 WebPCoder。 - (void)addCoder:(nonnull id)coder { if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) { return; } LOCK(self.codersLock); NSMutableArray&lt;id&gt; *mutableCoders = [self.coders mutableCopy]; if (!mutableCoders) { mutableCoders = [NSMutableArray array]; } [mutableCoders addObject:coder]; self.coders = [mutableCoders copy]; UNLOCK(self.codersLock);} - (void)removeCoder:(nonnull id)coder { if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) { return; } LOCK(self.codersLock); NSMutableArray&lt;id&gt; *mutableCoders = [self.coders mutableCopy]; [mutableCoders removeObject:coder]; self.coders = [mutableCoders copy]; UNLOCK(self.codersLock);} 添加/移除编码器。注意数据浅拷贝、深拷贝、加锁。 /** * 判断编码器数组里的编码器是否有能力解码传入的二进制数据 */- (BOOL)canDecodeFromData:(NSData )data{ LOCK(self.codersLock); NSArray&lt;id&gt; coders = self.coders; UNLOCK(self.codersLock); for (id coder in coders.reverseObjectEnumerator) { // 调用编码器实现的协议方法 if (\\[coder canDecodeFromData:data\\]) { return YES; } } return NO; } /** * 判断编码器数组里的编码器是否有能力编码指定的类型 */- (BOOL)canEncodeToFormat:(SDImageFormat)format{ LOCK(self.codersLock); NSArray&lt;id&gt; *coders = self.coders; UNLOCK(self.codersLock); for (id coder in coders.reverseObjectEnumerator) { // 调用编码器实现的协议方法 if (\\[coder canEncodeToFormat:format\\]) { return YES; } } return NO; } /** * 解码。NSData -&gt; UIImage */- (UIImage )decodedImageWithData:(NSData )data{ LOCK(self.codersLock); NSArray&lt;id&gt; *coders = self.coders; UNLOCK(self.codersLock); for (id coder in coders.reverseObjectEnumerator) { if ([coder canDecodeFromData:data]) { // 调用编码器实现的协议方法 return [coder decodedImageWithData:data]; } } return nil;} /** * 解码。UIImage -&gt; UIImage, data 用于存储二进制数据，image 参数用于设置解码图片的属性 */- (UIImage )decompressedImageWithImage:(UIImage )image data:(NSData *__autoreleasing _Nullable *)data options:(nullable NSDictionary&lt;NSString, NSObject&gt;)optionsDict{ if (!image) { return nil; } LOCK(self.codersLock); NSArray&lt;id&gt; coders = self.coders; UNLOCK(self.codersLock); for (id coder in coders.reverseObjectEnumerator) { if ([coder canDecodeFromData:*data]) { // 调用编码器实现的协议方法 UIImage *decompressedImage = \\[coder decompressedImageWithImage:image data:data options:optionsDict\\]; decompressedImage.sd\\_imageFormat = image.sd\\_imageFormat; return decompressedImage; } } return nil; } /** * 编码。UIImage -&gt; NSData */- (NSData )encodedDataWithImage:(UIImage )image format:(SDImageFormat)format{ if (!image) { return nil; } LOCK(self.codersLock); NSArray&lt;id&gt; *coders = self.coders; UNLOCK(self.codersLock); for (id coder in coders.reverseObjectEnumerator) { if ([coder canEncodeToFormat:format]) { // 调用编码器实现的协议方法 return [coder encodedDataWithImage:image format:format]; } } return nil;} 实现 SDWebImageCoder 协议方法，每个方法的内部实际上是调用编码器实现的编、解码过程。","tags":[]},{"title":" SDWebImageCompat\t\t","date":"2019-03-14T02:33:49.000Z","path":"2019/03/14/sdwebimagecompat/","text":"文章：SDWebImage源码解读 之 SDWebImageCompat 本篇主要解读 SDWebImage 的配置文件。正如 compat 的定义，该配置文件主要是兼容 Apple 的其他设备。也许我们真实的开发平台只有一个，但考虑各个平台的兼容性，对于框架有着很重要的意义。这篇文章的重点是抽取出对于 iOS 很重要的用法，能够在项目开发中提高效率。 一、.h 文件#import &lt;TargetConditionals.h&gt; 导入这个头文件，就能访问系统提供的配置选项了，我们接下来会对该文件出现的配置属性做出解释。 1、__OBJC_GC__ #ifdef __OBJC_GC__ #error SDWebImage does not support Objective-C Garbage Collection #endif SDWebImage 不支持垃圾回收机制。垃圾回收（Gargage-collection）是 Objective-C 提供的一种自动内存回收机制。在 iPad/iPhone 环境中不支持垃圾回收功能。 当启动这个功能后，所有的 retain、autorelease、release 和 dealloc 方法都将被系统忽略。 2、SD_MAC // Apple’s defines from TargetConditionals.h are a bit weird.// Seems like TARGET_OS_MAC is always defined (on all platforms).// To determine if we are running on OSX, we can only rely on TARGET_OS_IPHONE=0 and all the other platforms #if !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_IOS &amp;&amp; !TARGET_OS_TV &amp;&amp; !TARGET_OS_WATCH #define SD_MAC 1 #else #define SD_MAC 0 #endif 该指令主要用于判断当前平台是不是 MAC，单纯使用 TARGET_OS_MAC 是不靠谱的。这样判断的缺点是，当 Apple 出现新的平台时，判断条件要修改。 TARGET_OS_IPHONE TARGET_OS_IOS TARGET_OS_TV TARGET_OS_WATCH 3、SD_UIKIT // iOS and tvOS are very similar, UIKit exists on both platforms// Note: watchOS also has UIKit, but it’s very limited #if TARGET_OS_IOS || TARGET_OS_TV #define SD_UIKIT 1 #else #define SD_UIKIT 0 #endif iOS 和 tvOS 是非常相似的，UIKit 在这两个平台中都存在，但是 watchOS 在使用 UIKit 时是受限的。因此定义 SD_UIKIT为真的条件是 iOS 和 tvOS 这两个平台。至于为什么要定义 SD_UIKIT 后边会解释的。 4、SD_IOS、SD_WATCH、SD_WATCH #if TARGET_OS_IOS #define SD_IOS 1 #else #define SD_IOS 0 #endif #if TARGET_OS_TV #define SD_TV 1 #else #define SD_TV 0 #endif #if TARGET_OS_WATCH #define SD_WATCH 1 #else #define SD_WATCH 0 #endif 标识 iOS 、osTV、watch 平台。 5、平台兼容适配 #if SD_MAC #import &lt;AppKit/AppKit.h&gt; #ifndef UIImage #define UIImage NSImage #endif #ifndef UIImageView #define UIImageView NSImageView #endif #ifndef UIView #define UIView NSView #endif #else #if \\_\\_IPHONE\\_OS\\_VERSION\\_MIN\\_REQUIRED != 20000 &amp;&amp; \\_\\_IPHONE\\_OS\\_VERSION\\_MIN\\_REQUIRED &lt; \\_\\_IPHONE\\_5_0 #error SDWebImage doesn&apos;t support Deployment Target version &lt; 5.0 #endif #if SD_UIKIT #import &lt;UIKit/UIKit.h&gt; #endif #if SD_WATCH #import &lt;WatchKit/WatchKit.h&gt; #ifndef UIView #define UIView WKInterfaceObject #endif #ifndef UIImageView #define UIImageView WKInterfaceImage #endif #endif #endif 观察上边的代码，可以发现，在 MAC 平台上进行了如下的转换，这算是一个编程技巧： UIImage —–&gt; NSImage UIImageView —–&gt; NSImageView UIView —–&gt; NSView SDWebImage 不支持 5.0 以下的 iOS 版本。SD_UIKIT 为真时，导入 UIKit；SD_WATCH 为真时，导入 WatchKit。 6、基础设置 #ifndef NS_ENUM #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #endif #ifndef NS_OPTIONS #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif 7、接口 FOUNDATION_EXPORT UIImage *SDScaledImageForKey(NSString *key, UIImage *image); typedef void(^SDWebImageNoParamsBlock)(void); FOUNDATION_EXPORT NSString *const SDWebImageErrorDomain; 8、dispatch_main_async_safe 为什么要加入 safe 呢？那么这个 safe 主要是解决那些不安全的问题呢？ #ifndef dispatch_queue_async_safe #define dispatch_queue_async_safe(queue, block)\\ if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(queue)) {\\ block();\\ } else {\\ dispatch_async(queue, block);\\ } #endif #ifndef dispatch_main_async_safe #define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block) #endif 如果当前已经是主线程，那么在调用 dispatch_async(dispatch_get_main_queue(), block) 有可能会出现 crash. static dispatch_queue_t queue; - (void)log{ NSLog(@”%s”, dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)); NSLog(@”%s”, dispatch_queue_get_label(queue));} - (void)viewDidLoad{ [super viewDidLoad]; queue = dispatch\\_queue\\_create(&quot;shjhs&quot;, NULL); dispatch_async(queue, ^{ \\[self log\\]; }); NSLog(@&quot;%s&quot;, dispatch\\_queue\\_get\\_label(DISPATCH\\_CURRENT\\_QUEUE\\_LABEL)); } com.apple.main-threadshjhsshjhs 由上可见，DISPATCH_CURRENT_QUEUE_LABEL 代表的是当前线程设置的 label。if 条件为真表明当前正在 CURRENT_QUEUE 内，可以直接执行，否则在 queue 中执行。 所以此处的逻辑是：如果是主线程，直接调用；如果不是，调用 dispatch_async(dispatch_get_main_queue(), block) 二、.m 文件#if !__has_feature(objc_arc) #error SDWebImage is ARC only. Either turn on ARC for the project or use -fobjc-arc flag #endif #if !OS_OBJECT_USE_OBJC #error SDWebImage need ARC for dispatch object #endif 根据当前 ARC 或 MRC 环境给出错误提示。SDWebImage 只能用于 ARC 环境。 inline UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable image) { // 未传入无图片直接返回 if (!image) { return nil; } // MAC 平台直接返回 #if SD_MAC return image; #elif SD_UIKIT || SD_WATCH if ((image.images).count &gt; 0) { // 图片数组。当图片是 Animated images 时有值 NSMutableArray&lt;UIImage *&gt; *scaledImages = \\[NSMutableArray array\\]; // 如果含有多张图片，循环调用自身方法。边界条件：当只有一张图片时，if (image.images) 条件为假，直接 return image for (UIImage *tempImage in image.images) { \\[scaledImages addObject:SDScaledImageForKey(key, tempImage)\\]; } // 创建 Animated Image 对象 UIImage *animatedImage = \\[UIImage animatedImageWithImages:scaledImages duration:image.duration\\]; if (animatedImage) { animatedImage.sd\\_imageLoopCount = image.sd\\_imageLoopCount; animatedImage.sd\\_imageFormat = image.sd\\_imageFormat; } return animatedImage; } else { #if SD_WATCH if ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) { #elif SD_UIKIT if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) { #endif CGFloat scale = 1; if (key.length &gt;= 8) { NSRange range = [key rangeOfString:@”@2x.”]; if (range.location != NSNotFound) { scale = 2.0; } range = \\[key rangeOfString:@&quot;@3x.&quot;\\]; if (range.location != NSNotFound) { scale = 3.0; } } if (scale != image.scale) { UIImage *scaledImage = \\[\\[UIImage alloc\\] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation\\]; scaledImage.sd\\_imageFormat = image.sd\\_imageFormat; image = scaledImage; } } return image; } #endif} 这个方法是根据 key 来修改图片的尺寸，需要注意的地方有： inline 内联函数； 递归函数； @2x、@3x 图的处理。","tags":[]},{"title":" UIImage+GIF、SDWebImageGIFCoder\t\t","date":"2019-03-14T01:44:30.000Z","path":"2019/03/14/uiimagegif/","text":"文章：SDWebImage源码解读 之 UIImage+GIF 本篇是和 GIF 相关的一个 UIImage 的分类。 一、UIImage 的 size、scale 属性如果要获取一个图片的尺寸，不是直接使用 image.size，而是使用 image.size*image.scale。原因就是在获取 size 的时候使用的是 Point 坐标，而图片的尺寸是以像素为参照的。系统为我们处理了这两种坐标系的转换工作。 用一个例子来演示上边的内容： UIImage * image = [UIImage imageNamed:@”photo_delete”];NSLog(@”—–尺寸:(%f %f)”, image.size.width, image.size.height); —–尺寸:(18.000000 18.000000) 该图片的实际尺寸为 36 * 36。可以看出来只使用 size 这个属性是不对的。 修改代码： UIImage image = [UIImage imageNamed:@”photo_delete”];NSLog(@”—–尺寸:(%f %f)”, image.size.width image.scale, image.size.height * image.scale); —–尺寸:(36.000000 36.000000) 二、实现渐进式图片加载的步骤当图片从网络中获取的时候，可能由于过大，数据缓慢，这时候就需要渐进式加载图片来显示。主要通过 CFData 对象来实现： 创建一个 CFData 去添加 image data 创建一个渐进式图片资源，通过 CGImageSourceCreateIncremental 获取图片数据到 CFData 中 调用 CGImageSourceUpdateData 函数，传递 CFData 和一个 bool 值，去描述这个数据是否包含全部图片数据或者只是部分数据。无论什么情况，这个 data 包含已经积累的全部图片文件； 如果已经有足够的图片数据，可以通过函数 CGImageSourceCreateImageAtIndex 绘制部分图片，记得要 Release 检查是否已经有全部的图片数据通过使用 CGImageSourceGetStatusAtIndex 函数。如果图片是完整的，函数返回值为kCGImageStatusComplete。否则继续 3、4 步骤，直到获得全部数据； Release 掉渐进式增长的 image source 三、UIImage+GIF.h 文件/** * Creates an animated UIImage from an NSData. * For static GIF, will create an UIImage with `images` array set to nil. For animated GIF, will create an UIImage with valid `images` array. */+ (UIImage )sd_animatedGIFWithData:(NSData )data; /** * Checks if an UIImage instance is a GIF. Will use the `images` array. */- (BOOL)isGIF; 根据 NSData 获取图片和判断是否是 gif 图。 四、UIImage+GIF.m 文件+ (UIImage )sd_animatedGIFWithData:(NSData )data { if (!data) { return nil; } return [[SDWebImageGIFCoder sharedCoder] decodedImageWithData:data];} - (BOOL)isGIF { return (self.images != nil);} 根据 images 属性是否为空来判断 GIF 类型，这需要先执行 sd_animatedGIFWithData: 方法来设置 images。对 NSData 数据的操作实际由 SDWebImageGIFCoder 实现。 五、SDWebImageGIFCoder.h/* Built in coder using ImageIO that supports GIF encoding/decoding @note `SDWebImageIOCoder` supports GIF but only as static (will use the 1st frame). @note Use `SDWebImageGIFCoder` for fully animated GIFs - less performant than `FLAnimatedImage` @note If you decide to make all `UIImageView`(including `FLAnimatedImageView`) instance support GIF. You should add this coder to `SDWebImageCodersManager` and make sure that it has a higher priority than `SDWebImageIOCoder` @note The recommended approach for animated GIFs is using `FLAnimatedImage`. It’s more performant than `UIImageView` for GIF displaying /@interface SDWebImageGIFCoder : NSObject + (nonnull instancetype)sharedCoder; @end 基于 ImageIO 编程，支持 GIF 的编码和解码。 六、SDWebImageGIFCoder.m+ (instancetype)sharedCoder { static SDWebImageGIFCoder *coder; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ coder = [[SDWebImageGIFCoder alloc] init]; }); return coder;} 单例方法实现。 /** * 是否能解码传入的二进制数据，即判断图片类型是否 GIF */- (BOOL)canDecodeFromData:(nullable NSData *)data{ return ([NSData sd_imageFormatForImageData:data] == SDImageFormatGIF);} /** * 解码 */- (UIImage )decodedImageWithData:(NSData )data{ if (!data) { return nil; } #if SD_MAC SDAnimatedImageRep imageRep = [[SDAnimatedImageRep alloc] initWithData:data]; NSImage animatedImage = [[NSImage alloc] initWithSize:imageRep.size]; [animatedImage addRepresentation:imageRep]; return animatedImage; #else // 生成图片源对象 CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL); if (!source) { return nil; } // 图片数量 size_t count = CGImageSourceGetCount(source); UIImage *animatedImage; // 单张图片 if (count &lt;= 1) { animatedImage = \\[\\[UIImage alloc\\] initWithData:data\\]; } else { NSMutableArray&lt;SDWebImageFrame *&gt; *frames = \\[NSMutableArray array\\]; // 循环获取 GIF 中的每张图片，将 image 和 duration 一起存入 SDWebImageFrame for (size_t i = 0; i &lt; count; i++) { CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL); if (!imageRef) { continue; } float duration = \\[self sd_frameDurationAtIndex:i source:source\\]; UIImage *image = \\[\\[UIImage alloc\\] initWithCGImage:imageRef\\]; CGImageRelease(imageRef); SDWebImageFrame *frame = \\[SDWebImageFrame frameWithImage:image duration:duration\\]; \\[frames addObject:frame\\]; } // 循环次数 NSUInteger loopCount = 1; // GIF 图片的属性。\\_\\_bridge\\_transfer 内存管理转为 ARC NSDictionary \\*imageProperties = (\\_\\_bridge\\_transfer NSDictionary \\*)CGImageSourceCopyProperties(source, nil); NSDictionary \\*gifProperties = \\[imageProperties valueForKey:(__bridge NSString \\*)kCGImagePropertyGIFDictionary\\]; if (gifProperties) { NSNumber \\*gifLoopCount = \\[gifProperties valueForKey:(__bridge NSString \\*)kCGImagePropertyGIFLoopCount\\]; if (gifLoopCount != nil) { loopCount = gifLoopCount.unsignedIntegerValue; } } animatedImage = \\[SDWebImageCoderHelper animatedImageWithFrames:frames\\]; animatedImage.sd_imageLoopCount = loopCount; animatedImage.sd_imageFormat = SDImageFormatGIF; } CFRelease(source); return animatedImage; #endif} 实现 SDWebImageCoder 协议的解码方法。 CGImageSourceRef 抽象出来了图片数据，通过 raw memory buffer 减轻开发人员对数据的处理。Image Sources 包含不止一个图像，缩略图，各个图像的特征和图片文件。可以这么说：CGImageSourceRef 就是对图像数据的一层封装。 /** * 获取某一帧的时长 */- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source{ float frameDuration = 0.1f; // 获取某一帧的属性字典 CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil); if (!cfFrameProperties) { return frameDuration; } // 获取某一帧的 gif 属性 NSDictionary \\*frameProperties = (__bridge NSDictionary \\*)cfFrameProperties; NSDictionary \\*gifProperties = frameProperties\\[(NSString \\*)kCGImagePropertyGIFDictionary\\]; NSNumber \\*delayTimeUnclampedProp = gifProperties\\[(NSString \\*)kCGImagePropertyGIFUnclampedDelayTime\\]; if (delayTimeUnclampedProp != nil) { frameDuration = \\[delayTimeUnclampedProp floatValue\\]; } else { NSNumber \\*delayTimeProp = gifProperties\\[(NSString \\*)kCGImagePropertyGIFDelayTime\\]; if (delayTimeProp != nil) { frameDuration = \\[delayTimeProp floatValue\\]; } } // Many annoying ads specify a 0 duration to make an image flash as quickly as possible. // We follow Firefox&apos;s behavior and use a duration of 100 ms for any frames that specify // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt; // for more information. /\\* 对于时间太短的进行处理 */ if (frameDuration &lt; 0.011f) { frameDuration = 0.100f; } CFRelease(cfFrameProperties); return frameDuration; } 获取某一帧的时长。 - (UIImage )decompressedImageWithImage:(UIImage )image data:(NSData *__autoreleasing _Nullable *)data options:(nullable NSDictionary&lt;NSString, NSObject&gt;*)optionsDict { // GIF do not decompress return image;} 解压图片，GIF 图不需要解压。 - (BOOL)canEncodeToFormat:(SDImageFormat)format { return (format == SDImageFormatGIF);} - (NSData )encodedDataWithImage:(UIImage )image format:(SDImageFormat)format{ if (!image) { return nil; } // 非 GIF 格式直接返回 if (format != SDImageFormatGIF) { return nil; } NSMutableData *imageData = \\[NSMutableData data\\]; // SDImageFormat -&gt; UTType CFStringRef imageUTType = \\[NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF\\]; // 图片的帧数组 NSArray&lt;SDWebImageFrame *&gt; *frames = \\[SDWebImageCoderHelper framesFromAnimatedImage:image\\]; // Create an image destination. GIF does not support EXIF image orientation // 创建一个图像目标 CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL); if (!imageDestination) { // Handle failure. return nil; } if (frames.count == 0) { // for static single GIF images CGImageDestinationAddImage(imageDestination, image.CGImage, nil); } else { // for animated GIF images. GIF 图属性 NSUInteger loopCount = image.sd_imageLoopCount; NSDictionary \\*gifProperties = @{(\\_\\_bridge NSString \\*)kCGImagePropertyGIFDictionary: @{(\\_\\_bridge NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)}}; // 设置 GIF 属性 CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties); for (size_t i = 0; i &lt; frames.count; i++) { SDWebImageFrame *frame = frames\\[i\\]; float frameDuration = frame.duration; CGImageRef frameImageRef = frame.image.CGImage; NSDictionary \\*frameProperties = @{(\\_\\_bridge NSString \\*)kCGImagePropertyGIFDictionary : @{(\\_\\_bridge NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)}}; // 设置每一帧的属性 CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties); } } // Finalize the destination. if (CGImageDestinationFinalize(imageDestination) == NO) { // Handle failure. imageData = nil; } CFRelease(imageDestination); return \\[imageData copy\\]; } 实现 SDWebImageCoder 协议的编码方法。CGImageDestinationRef 与 CGImageSourceRef 相对。 /** * 缩放图片 */- (UIImage *)sd_animatedImageByScalingAndCroppingToSize:(CGSize)size{ // 与当前尺寸相同 || 传入 { 0, 0 } 尺寸 if (CGSizeEqualToSize(self.size, size) || CGSizeEqualToSize(size, CGSizeZero)) { return self; } CGSize scaledSize = size; CGPoint thumbnailPoint = CGPointZero; CGFloat widthFactor = size.width / self.size.width; CGFloat heightFactor = size.height / self.size.height; // 保留大的比例 CGFloat scaleFactor = (widthFactor &gt; heightFactor) ? widthFactor : heightFactor; scaledSize.width = self.size.width * scaleFactor; scaledSize.height = self.size.height * scaleFactor; if (widthFactor &gt; heightFactor) { thumbnailPoint.y = (size.height - scaledSize.height) * 0.5; } else if (widthFactor &lt; heightFactor) { thumbnailPoint.x = (size.width - scaledSize.width) * 0.5; } NSMutableArray *scaledImages = \\[NSMutableArray array\\]; // 使用 CoreGraphics 重新绘制尺寸 for (UIImage *image in self.images) { UIGraphicsBeginImageContextWithOptions(size, NO, 0.0); \\[image drawInRect:CGRectMake(thumbnailPoint.x, thumbnailPoint.y, scaledSize.width, scaledSize.height)\\]; UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); \\[scaledImages addObject:newImage\\]; UIGraphicsEndImageContext(); } return \\[UIImage animatedImageWithImages:scaledImages duration:self.duration\\]; } v4.0.0 已删除的方法。 七、总结gif 也算是一种无损的格式，本分类只是给予 UIImage 支持 GIF 的能力。 因此由这种思想，可以联想到别的地方：当需要某种能力支持的时候，我们应该去观察底层，也就是数据层的规律。就比如图像数据，本质上还是一些二进制的数据，越往上，越被包装的简单易用，归根到底，写代码的根本就是处理数据。","tags":[]},{"title":" NSData+ImageContentType\t\t","date":"2019-03-13T11:01:12.000Z","path":"2019/03/13/nsdataimagecontenttype/","text":"文章：SDWebImage源码解读 之 NSData+ImageContentType 一、文件头文件头是位于文件开头的一段承担一定任务的数据，一般都在开头的部分。 别看这个文件头和 C 语言中的头文件读起来很像，但这两个东西其实根本没有一点关系： 头文件是一种包含功能函数，数据接口声明的载体文件；而文件头则是直接位于文件中的一段数据，是文件的一部分。 当文件都使用二进制流作为传输时，需要制定一套规范，用来区分该文件到底是什么类型的。文件头有很多个，我们在这里就介绍一些主流的且跟图片相关的文件头。 JPEG (jpg) 文件头：FFD8FFE1 PNG (png) 文件头：89504E47 GIF (gif) 文件头：47494638 TIFF tif;tiff 0x49492A00 TIFF tif;tiff 0x4D4D002A RAR Archive (rar) 文件头：52617221 WebP : 524946462A73010057454250 可以看出来我们通过每个文件头的第一个字节就能判断出是什么类型。 但是值得注意的是 52 开头的，这个要做特别的判断。WebP 这种格式很特别，是由 12 个字节组成的文件头，如果把这些字节通过 ASCII 编码后会得到下边这样一张表格： + (NSString )sd_contentTypeForImageData:(NSData )data{ uint8_t c; [data getBytes:&amp;c length:1]; switch (c) { case 0xFF: return @&quot;image/jpeg&quot;; case 0x89: return @&quot;image/png&quot;; case 0x47: return @&quot;image/gif&quot;; case 0x49: case 0x4D: return @&quot;image/tiff&quot;; case 0x52: // R as RIFF for WEBP if (\\[data length\\] &lt; 12) { return nil; } NSString *testString = \\[\\[NSString alloc\\] initWithData:\\[data subdataWithRange:NSMakeRange(0, 12)\\] encoding:NSASCIIStringEncoding\\]; if (\\[testString hasPrefix:@&quot;RIFF&quot;\\] &amp;&amp; \\[testString hasSuffix:@&quot;WEBP&quot;\\]) { return @&quot;image/webp&quot;; } return nil; } return nil; } 通过看上边方法的实现，我们就明白了。其中 jpeg/png/gif/tiff 是最好判断的。当第一个字节为 52 时，如果长度 &lt; 12 我们就认定为不是图片，返回 nil。我们通过数据截取后获得 testString，如果 testString 头部包含 RIFF 且尾部也包含 WEBP，那么就认定该图片格式为 webp。 为了更好的演示 webp，用代码打印出结果来看看。 NSString path = [[NSBundle mainBundle] pathForResource:@”google@2x” ofType:@”webp”];NSData data = [NSData dataWithContentsOfFile:path];NSString * contentType = [NSData sd_contentTypeForImageData:data];NSLog(@”-----%@------%@”, contentType, data); —–image/webp——&lt;52494646 72370000 57454250 56503858 0a000000 10000000 190200bd 0000414c 50484711 00000187 40906d33 83cd9ff7 778888a4 b3e53068 db4650c2 9f747a77 ff1822fa 9f927ff8 9224460e c3301c46 86216224 932431e6 1f5edfb6 6dd76d6c db56c195 20884bfb ffaf959d c214d01a 39e6f521 a2ffe95b b6edbaad 6ddb2a20 c03b40e4 ffffdade fbb0500b 2ddb2146 8c8788fe a7feff26 7ecae76a 9f2e77a3 fd9ce513 3ffc8fdd a7d286ec b65aa2d3 b3f6c735 44ef3ad6 ac879cce 21fafd58 929e6eac 53ccce25 e9c33bb8 d779b52f 438ccf59 9fdcc1bd ee7871ac f284be4f fad40eee 75c77b63 93b5d1ca 27de1de5 6c4376cf a28fece0 5e77bc36 3659b94a 64311e75 c8562dfa bc0eee75 c75b4393 efb32636 c3d165a7 167d5807 f7bae3a5 aecaf72b a1e28f21 1bb5e893 3ab8d71d 2f5da67c 9ba7472f 36d93892 3ea6a58e 30a6e39d 53e56b71 其中 52494646 72370000 57454250 正好占用了 12 字节。那么也正好符合了我们上边解释的 webp 文件头。 二、.h 文件typedef NS_ENUM(NSInteger, SDImageFormat) { SDImageFormatUndefined = -1, SDImageFormatJPEG = 0, SDImageFormatPNG, SDImageFormatGIF, SDImageFormatTIFF, SDImageFormatWebP, SDImageFormatHEIC, SDImageFormatHEIF}; 枚举值，用于表明二进制数据对应的图片格式。 NSData (ImageContentType) 很明显这是一个 NSData 的分类，都知道分类一般是用来扩展一些方法的。看看它扩展了什么方法？ /** * Return image format * * 传入二进制数据返回图片格式 */+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data; /** * Convert SDImageFormat to UTType * * 将自定义枚举值转为 UTType */+ (nonnull CFStringRef)sd_UTTypeFromSDImageFormat:(SDImageFormat)format; /** * Convert UTTyppe to SDImageFormat * * 将 UTType 转为自定义枚举值 */+ (SDImageFormat)sd_imageFormatFromUTType:(nonnull CFStringRef)uttype; 根据二进制的数据获取图片的 contentType。然后将 SDImageFormat 和 UTType 互相做转化。 三、.m 文件+ (NSString )contentTypeForImageData:(NSData )data __deprecated_msg(“Use `sd_contentTypeForImageData:`“); __deprecated_msg 可以告诉开发者该方法不建议使用。当我们在写框架或者类的时候，如果功能相同，但是想使用新的方法名的时候，使用 __deprecated_msg 给予其他开发者一个提示。这远远比直接删除旧的更专业。 /* 自定义三种格式的 UTType 值 */ #define kSDUTTypeWebP ((__bridge CFStringRef)@”public.webp”)// AVFileTypeHEIC/AVFileTypeHEIF is defined in AVFoundation via iOS 11, we use this without import AVFoundation #define kSDUTTypeHEIC ((__bridge CFStringRef)@”public.heic”) #define kSDUTTypeHEIF ((__bridge CFStringRef)@”public.heif”) @implementation NSData (ImageContentType) /** * 返回数据的格式 */+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data{ if (!data) { return SDImageFormatUndefined; } // File signatures table: http://www.garykessler.net/library/file_sigs.html uint8_t c; \\[data getBytes:&amp;c length:1\\]; switch (c) { case 0xFF: return SDImageFormatJPEG; case 0x89: return SDImageFormatPNG; case 0x47: return SDImageFormatGIF; case 0x49: case 0x4D: return SDImageFormatTIFF; case 0x52: { if (data.length &gt;= 12) { //RIFF....WEBP NSString *testString = \\[\\[NSString alloc\\] initWithData:\\[data subdataWithRange:NSMakeRange(0, 12)\\] encoding:NSASCIIStringEncoding\\]; if (\\[testString hasPrefix:@&quot;RIFF&quot;\\] &amp;&amp; \\[testString hasSuffix:@&quot;WEBP&quot;\\]) { return SDImageFormatWebP; } } break; } // 判断 HEIC、HEIF case 0x00: { if (data.length &gt;= 12) { //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx NSString *testString = \\[\\[NSString alloc\\] initWithData:\\[data subdataWithRange:NSMakeRange(4, 8)\\] encoding:NSASCIIStringEncoding\\]; if (\\[testString isEqualToString:@&quot;ftypheic&quot;\\] || \\[testString isEqualToString:@&quot;ftypheix&quot;\\] || \\[testString isEqualToString:@&quot;ftyphevc&quot;\\] || \\[testString isEqualToString:@&quot;ftyphevx&quot;\\]) { return SDImageFormatHEIC; } if (\\[testString isEqualToString:@&quot;ftypmif1&quot;\\] || \\[testString isEqualToString:@&quot;ftypmsf1&quot;\\]) { return SDImageFormatHEIF; } } break; } } return SDImageFormatUndefined; } /** * 返回 SDImageFormat 枚举值对应的 UTType 值 */+ (nonnull CFStringRef)sd_UTTypeFromSDImageFormat:(SDImageFormat)format{ CFStringRef UTType; switch (format) { case SDImageFormatJPEG: UTType = kUTTypeJPEG; break; case SDImageFormatPNG: UTType = kUTTypePNG; break; case SDImageFormatGIF: UTType = kUTTypeGIF; break; case SDImageFormatTIFF: UTType = kUTTypeTIFF; break; case SDImageFormatWebP: UTType = kSDUTTypeWebP; break; case SDImageFormatHEIC: UTType = kSDUTTypeHEIC; break; case SDImageFormatHEIF: UTType = kSDUTTypeHEIF; break; default: // default is kUTTypePNG UTType = kUTTypePNG; break; } return UTType;} /** * 返回 UTType 值对应的 SDImageFormat 枚举值 */+ (SDImageFormat)sd_imageFormatFromUTType:(CFStringRef)uttype{ if (!uttype) { return SDImageFormatUndefined; } SDImageFormat imageFormat; if (CFStringCompare(uttype, kUTTypeJPEG, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatJPEG; } else if (CFStringCompare(uttype, kUTTypePNG, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatPNG; } else if (CFStringCompare(uttype, kUTTypeGIF, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatGIF; } else if (CFStringCompare(uttype, kUTTypeTIFF, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatTIFF; } else if (CFStringCompare(uttype, kSDUTTypeWebP, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatWebP; } else if (CFStringCompare(uttype, kSDUTTypeHEIC, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatHEIC; } else if (CFStringCompare(uttype, kSDUTTypeHEIF, 0) == kCFCompareEqualTo) { imageFormat = SDImageFormatHEIF; } else { imageFormat = SDImageFormatUndefined; } return imageFormat;}","tags":[]},{"title":" 尾调用（Tail Call）\t\t","date":"2019-03-13T10:02:29.000Z","path":"2019/03/13/tail-call/","text":"文章：百度百科、尾调用优化(Tail Call Optimization)、深入理解JavaScript中的尾调用(Tail Call) 一、什么是尾调用 尾调用(Tail Call)是函数式编程的一个重要概念。 一个函数里的最后一个动作是返回一个函数的调用结果，用简单的一句话描述就是“在函数的最后一步调用函数”。 function f(x){ let y = x + 1; return g(y); } 函数 f 的最后一步是调用函数 g，这就是尾调用。 以下几种情况，都不属于尾调用： function f(x) { return g(x) + 1;} function f(x) { var ret = g(x); return (ret === 0) ? 1 : ret; } 这是因为程序必须返回 g(x) 函数的调用以检查、更动 g(x) 的返回值。 二、尾调用优化传统模式的编译器对于尾调用的处理方式就像处理其他普通函数调用一样，总会在调用时在内存中形成一个“调用记录”，又称“调用帧”（call frame），并将其推入调用栈顶部，用于表示该次函数调用，保存调用位置和内部变量等信息。 当一个函数调用发生时，计算机必须 “记住”调用函数的返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般存在调用栈上。在尾调用这种特殊情形中，计算机理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置（相当于直接连续返回两次）。 如果在函数 A 的内部调用函数 B，那么在 A 的调用记录上方，还会形成一条 B 的调用记录，等到 B 运行结束，将结果返回 A，B 的调用记录才会消失。如果函数 B 内部还调用函数 C，那在 B 的调用记录上方还有一个 C 的调用记录栈，以此类推，所有的调用记录，就形成一个调用栈。这有可能会出现函数调用栈过大甚至溢出的情况。 尾调用由于是函数的最后一步，所以当前函数帧上包含调用位置、局部变量等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。 尾调用消除： 在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化（完全不改变调用栈是不可能的，还是需要校正调用栈上形式参数与局部变量的信息）。 尾调用优化： 只保留内层函数的调用记录，如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。 产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除（Tail Call Elimination）或尾调用优化（Tail Call Optimization, TCO）。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。 function f() { let a = 1, b = 2; return g(a+b); } f(); // 等价于 function f(){ return g(3); } // 等价于 g(3); 上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 a 和 b 的值、函数 f 的调用位置等信息。但由于调用 g 后，函数 f 就结束了，所以执行到最后一步，完全可以删除函数 f 的调用记录，只保留 g(3) 的调用记录。 然而，对于 C++ 等语言来说，在函数最后 return g(x); 并不一定是尾递归，因为在返回之前很可能涉及到对象的析构函数，使得 g(x) 不是最后执行的那个。这可以通过返回值优化来解决。 三、尾递归如果尾调用自身，则称为尾递归。 递归非常耗费内存，因为需要同时保存成百上千条调用记录，很容易出现“栈溢出”的错误。但对于尾递归而言，由于只存在一个调用记录，所以不会发生“栈溢出”的错误。 int factorial(n) { if(n ==1 ) { return 1; } return n * factorial(n-1);} factorial(5); // 120 上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，空间复杂度 O(n)，当 n 足够大时，则会发生调用栈溢出。如果改写成尾递归，则只保留一个调用记录，空间复杂度 O(1)。 int factorial(n, total) { if(n == 1) { return total; } return factorial(n-1, n*total);} factorial(5,1); 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。在 ES6 中，严格模式下，宣称支持尾调用优化这个新特性。 但目前 V8 引擎并没有优化尾递归，V8 团队认为做尾递归优化存在一系列问题，因此倾向于支持用显示的语法来实现，而非做优化。在 node 环境和浏览器环境都做了测试，当尾递归函数中传入 n 过大时，同样会出现栈溢出的情况，不管是否开启严格模式，所以似乎尾递归优化并没有起作用。 四、递归函数的改写尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。就是把所有用到的内部变量改写成函数的参数。 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total，那就把这个中间变量改写成函数的参数。这样做的缺点是使函数看起来不太直观，为什么计算 5 的阶乘，需要传入两个参数 5 和 1。两个方法可以解决这个问题。 1、在尾递归函数之外，再提供一个正常形式的函数 int tailFactorial(n, total) { if(n == 1) { return total; } return tailFactorial(n - 1, n * total);} int factorial(n) { return tailFactorial(n, 1);} factorial(5); // 120 上面代码通过一个正常形式的阶乘函数 factorial，调用尾递归函数 tailFactorial，看起来就正常多了。 函数式编程中有一个概念叫做柯里化（currying），简单来说就是将多参数的函数转换为单参数函数的形式，这里也可以使用柯里化。 function currying(fn, n) { return function (m) { return fn.call(this,m,n); }} function tailFactorial(n, total) { if(n===1) { return total; } return tailFactorial(n - 1, n * total);} const factorial = currying(tailFactorial, 1)factorial(5) // 120 上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受一个参数的 factorial 函数。 2、使用 ES6 的默认值特性。 function factorial(n, total=1) { if(n===1) { return total; } return factorial(n-1, n * total);} factorial(5); 上面代码中参数 total 有默认值 1，调用时可以不提供这个值。 总结，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作的命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言，我们需要知道循环可以用递归来代替，而一旦使用递归，就最好使用尾递归。","tags":[]},{"title":" UIButton/UIProgressView/UIWebView + AFNetworking\t\t","date":"2019-03-13T09:20:41.000Z","path":"2019/03/13/uibutton-uiprogressview-uiwebview-afnetworking/","text":"文章：AFNetworking 3.0 源码解读（十一）之 UIButton/UIProgressView/UIWebView + AFNetworking 一、UIButton+AFNetworkingUIButton 跟图片相关的属性大概有两个：Image 和 BackgroundImage，所以这个分类就是赋予它们异步加载图片的能力。 核心方法为： - (void)setImageForState:(UIControlState)state withURL:(NSURL *)url; - (void)setImageForState:(UIControlState)state withURL:(NSURL )url placeholderImage:(nullable UIImage )placeholderImage; /** Asynchronously downloads an image from the specified URL request, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled. If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished. If a success block is specified, it is the responsibility of the block to set the image of the button before returning. If no success block is specified, the default behavior of setting the image with `setImage:forState:` is applied. */- (void)setImageForState:(UIControlState)state withURLRequest:(NSURLRequest )urlRequest placeholderImage:(nullable UIImage )placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage image))success failure:(nullable void (^)(NSURLRequest \\request, NSHTTPURLResponse * _Nullable response, NSError *error))failure; - (void)setBackgroundImageForState:(UIControlState)state withURL:(NSURL *)url; - (void)setBackgroundImageForState:(UIControlState)state withURL:(NSURL )url placeholderImage:(nullable UIImage )placeholderImage; /** Asynchronously downloads an image from the specified URL request, and sets it as the image for the specified state once the request is finished. Any previous image request for the receiver will be cancelled. If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished. If a success block is specified, it is the responsibility of the block to set the image of the button before returning. If no success block is specified, the default behavior of setting the image with `setBackgroundImage:forState:` is applied. */- (void)setBackgroundImageForState:(UIControlState)state withURLRequest:(NSURLRequest )urlRequest placeholderImage:(nullable UIImage )placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage image))success failure:(nullable void (^)(NSURLRequest \\request, NSHTTPURLResponse * _Nullable response, NSError *error))failure; Image、BackgroundImage 加载图片。 /** * Cancels any executing image task for the specified control state of the receiver, if one exists. */- (void)cancelImageDownloadTaskForState:(UIControlState)state; /** * Cancels any executing background image task for the specified control state of the receiver, if one exists. */- (void)cancelBackgroundImageDownloadTaskForState:(UIControlState)state; 取消图片的加载任务。 static char AFImageDownloadReceiptNormal;static char AFImageDownloadReceiptHighlighted;static char AFImageDownloadReceiptSelected;static char AFImageDownloadReceiptDisabled; static const char * af_imageDownloadReceiptKeyForState(UIControlState state) { switch (state) { case UIControlStateHighlighted: return &AFImageDownloadReceiptHighlighted; case UIControlStateSelected: return &AFImageDownloadReceiptSelected; case UIControlStateDisabled: return &AFImageDownloadReceiptDisabled; case UIControlStateNormal: default: return &AFImageDownloadReceiptNormal; }} - (AFImageDownloadReceipt )af_imageDownloadReceiptForState:(UIControlState)state { return (AFImageDownloadReceipt )objc_getAssociatedObject(self, af_imageDownloadReceiptKeyForState(state));} - (void)af_setImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt forState:(UIControlState)state{ objc_setAssociatedObject(self, af_imageDownloadReceiptKeyForState(state), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} 我们都知道 UIButton 有 4 种状态。这个分类能够支持不同的状态加载不同的图片。同样也知道，每一个图片的加载，都需要一个 AFImageDownloadReceipt 凭证。所以，我们要为 UIButton 扩展一个根据状态获取凭证的方法，就是：af_imageDownloadReceiptForState:。既然有获取凭证的方法，就应该有根据状态设置凭证的方法，那就是：af_setImageDownloadReceipt:forState:。 af_imageDownloadReceiptKeyForState 方法的作用就是为运行时提供一个 key，这个 key 是一个内存地址，也可使用@Selector()。 static char AFBackgroundImageDownloadReceiptNormal;static char AFBackgroundImageDownloadReceiptHighlighted;static char AFBackgroundImageDownloadReceiptSelected;static char AFBackgroundImageDownloadReceiptDisabled; static const char * af_backgroundImageDownloadReceiptKeyForState(UIControlState state) { switch (state) { case UIControlStateHighlighted: return &AFBackgroundImageDownloadReceiptHighlighted; case UIControlStateSelected: return &AFBackgroundImageDownloadReceiptSelected; case UIControlStateDisabled: return &AFBackgroundImageDownloadReceiptDisabled; case UIControlStateNormal: default: return &AFBackgroundImageDownloadReceiptNormal; }} - (AFImageDownloadReceipt )af_backgroundImageDownloadReceiptForState:(UIControlState)state{ return (AFImageDownloadReceipt )objc_getAssociatedObject( self, af_backgroundImageDownloadReceiptKeyForState(state));} - (void)af_setBackgroundImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt forState:(UIControlState)state{ objc_setAssociatedObject( self, af_backgroundImageDownloadReceiptKeyForState(state), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} 上边的代码扩展了 BackgroundImage，原理同上。 这个分类的核心方法可以参考上一篇。 二、UIProgressView+AFNetworkingUIProgressView 的这个分类实现原理：监听 NSURLSessionUploadTask 或者 NSURLSessionDownloadTask 中的”state”、”countOfBytesSent”、”countOfBytesReceived”，然后设置进度就可以了。 /** * 设置上传任务进度 */- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task animated:(BOOL)animated{ if (task.state == NSURLSessionTaskStateCompleted) { return; } // 设置监听 \\[task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext\\]; \\[task addObserver:self forKeyPath:@&quot;countOfBytesSent&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext\\]; // 存储是否动画布尔值 \\[self af_setUploadProgressAnimated:animated\\]; } /** * 设置下载任务进度 */- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task animated:(BOOL)animated{ if (task.state == NSURLSessionTaskStateCompleted) { return; } \\[task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext\\]; \\[task addObserver:self forKeyPath:@&quot;countOfBytesReceived&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext\\]; \\[self af_setDownloadProgressAnimated:animated\\]; } #pragma mark - NSKeyValueObserving - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(__unused NSDictionary )change context:(void *)context{ // 判断是不是设置监听的字段 if (context == AFTaskCountOfBytesSentContext || context == AFTaskCountOfBytesReceivedContext) { // 已经上传 if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))\\]) { if (\\[object countOfBytesExpectedToSend\\] &gt; 0) { // 主线程更新进度 dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[self setProgress:\\[object countOfBytesSent\\] / (\\[object countOfBytesExpectedToSend\\] * 1.0f) animated:self.af_uploadProgressAnimated\\]; }); } } // 下载接收 if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))\\]) { if (\\[object countOfBytesExpectedToReceive\\] &gt; 0) { // 主线程更新进度 dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[self setProgress:\\[object countOfBytesReceived\\] / (\\[object countOfBytesExpectedToReceive\\]*1.0f) animated:self.af_downloadProgressAnimated\\]; }); } } // 状态 if (\\[keyPath isEqualToString:NSStringFromSelector(@selector(state))\\]) { // 完成 if (\\[(NSURLSessionTask *)object state\\] == NSURLSessionTaskStateCompleted) { @try { \\[object removeObserver:self forKeyPath:NSStringFromSelector(@selector(state))\\]; if (context == AFTaskCountOfBytesSentContext) { \\[object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))\\]; } if (context == AFTaskCountOfBytesReceivedContext) { \\[object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))\\]; } } @catch (NSException * __unused exception) {} } } } } 三、UIWebView+AFNetworkingUIWebView 的这个分类是这几个分类中最让我惊讶的一个。让我真正认识到条条大路通罗马到底是什么意思。有时候人的思想确实会被固有的思维所束缚。这里只是用了 UIWebView 的 -loadData:MIMEType:textEncodingName:baseURL: 方法。 你会发现使用这个分类配合 UIWebView，所有的事情都变得很简单。 /** * Asynchronously loads the specified request. */- (void)loadRequest:(NSURLRequest )request progress:(NSProgress _Nullable __autoreleasing _Nullable)progress success:(nullable NSString (^)(NSHTTPURLResponse *response, NSString *HTML))success failure:(nullable void (^)(NSError *error))failure; /** * Asynchronously loads the data associated with a particular request with a specified MIME type and text encoding. */- (void)loadRequest:(NSURLRequest )request MIMEType:(nullable NSString )MIMEType textEncodingName:(nullable NSString )textEncodingName progress:(NSProgress _Nullable __autoreleasing _Nullable)progress success:(nullable NSData (^)(NSHTTPURLResponse *response, NSData *data))success failure:(nullable void (^)(NSError *error))failure; @interface UIWebView (_AFNetworking)@property (readwrite, nonatomic, strong, setter = af_setURLSessionTask:) NSURLSessionDataTask *af_URLSessionTask;@end 为 UIWebView 扩展了一个私有属性 af_URLSessionTask，定义为每一次请求，就会对应一个 af_URLSessionTask。 - (AFHTTPSessionManager )sessionManager { static AFHTTPSessionManager _af_defaultHTTPSessionManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _af_defaultHTTPSessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; _af_defaultHTTPSessionManager.requestSerializer = [AFHTTPRequestSerializer serializer]; _af_defaultHTTPSessionManager.responseSerializer = [AFHTTPResponseSerializer serializer]; }); return objc\\_getAssociatedObject(self, @selector(sessionManager)) ?: \\_af_defaultHTTPSessionManager; } - (void)setSessionManager:(AFHTTPSessionManager *)sessionManager { objc_setAssociatedObject(self, @selector(sessionManager), sessionManager, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} 为 UIWebView 扩展的一个 sessionManager 属性。实现了 setter 和 getter 方法。这样在后边直接使用 self.sessionManager 就可以，不用创建了。 - (void)loadRequest:(NSURLRequest )request progress:(NSProgress _Nullable __autoreleasing _Nullable)progress success:(NSString (^)(NSHTTPURLResponse *response, NSString *HTML))success failure:(void (^)(NSError error))failure{ [self loadRequest:request MIMEType:nil textEncodingName:nil progress:progress success:^NSData (NSHTTPURLResponse *response, NSData *data) { NSStringEncoding stringEncoding = NSUTF8StringEncoding; if (response.textEncodingName) { CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName); if (encoding != kCFStringEncodingInvalidId) { stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding); } } NSString *string = \\[\\[NSString alloc\\] initWithData:data encoding:stringEncoding\\]; if (success) { string = success(response, string); } return \\[string dataUsingEncoding:stringEncoding\\]; } failure:failure\\]; } - (void)loadRequest:(NSURLRequest )request MIMEType:(NSString )MIMEType textEncodingName:(NSString )textEncodingName progress:(NSProgress _Nullable __autoreleasing _Nullable)progress success:(NSData (^)(NSHTTPURLResponse *response, NSData *data))success failure:(void (^)(NSError *error))failure{ // 检查参数 NSParameterAssert(request); // 如果正处于运行 | 暂停状态，取消当前任务，并设置 task = nil if (self.af_URLSessionTask.state == NSURLSessionTaskStateRunning || self.af_URLSessionTask.state == NSURLSessionTaskStateSuspended) { [self.af_URLSessionTask cancel]; } self.af_URLSessionTask = nil; \\_\\_weak \\_\\_typeof(self)weakSelf = self; __block NSURLSessionDataTask *dataTask; dataTask = \\[self.sessionManager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^( NSURLResponse * _Nonnull response, id _Nonnull responseObject, NSError * _Nullable error) { \\_\\_strong \\_\\_typeof(weakSelf) strongSelf = weakSelf; // 失败 if (error) { if (failure) { failure(error); } } else { // 成功 if (success) { success((NSHTTPURLResponse *)response, responseObject); } // 显示数据 \\[strongSelf loadData:responseObject MIMEType:MIMEType textEncodingName:textEncodingName baseURL:\\[dataTask.currentRequest URL\\]\\]; // 调用 webViewDidFinishLoad: 代理方法 if (\\[strongSelf.delegate respondsToSelector:@selector(webViewDidFinishLoad:)\\]) { \\[strongSelf.delegate webViewDidFinishLoad:strongSelf\\]; } } }\\]; self.af_URLSessionTask = dataTask; // 设置进度 if (progress != nil) { *progress = \\[self.sessionManager downloadProgressForTask:dataTask\\]; } // 开启任务 \\[self.af_URLSessionTask resume\\]; // 开始加载 webView if (\\[self.delegate respondsToSelector:@selector(webViewDidStartLoad:)\\]) { \\[self.delegate webViewDidStartLoad:self\\]; } } 总结：UIWebView+AFNetworking 模拟了 UIWebView 加载数据的过程。","tags":[]},{"title":" UIActivityIndicatorView/UIRefreshControl/UIImageView + AFNetworking\t\t","date":"2019-03-13T08:31:57.000Z","path":"2019/03/13/uiactivityindicatorview-uirefreshcontrol-uiimageview-afnetworking/","text":"文章：AFNetworking 3.0 源码解读（十）之 UIActivityIndicatorView/UIRefreshControl/UIImageView + AFNetworking 这篇介绍 AFNetworking 中的 3 个 UIKit 中的分类。UIActivityIndicatorView、UIRefreshControl、UIImageView。读完本篇就能够明白控件是如何显示网络图片的。有兴趣话可以尝试让一个控件的 layer 也能够加载网络图片。 解读源码不仅仅是了解内部实现原理，还要让开发者明白在这些分类中能够使用那些功能。 一、UIActivityIndicatorView+AFNetworking/* This category adds methods to the UIKit framework’s `UIActivityIndicatorView` class. The methods in this category provide support for automatically starting and stopping animation depending on the loading state of a session task. /@interface UIActivityIndicatorView (AFNetworking) 这个分类增加了 UIActivityIndicatorView 的一个方法。只要给传入一个 task，UIActivityIndicatorView 会根据数据的加载情况自动开始动画或结束动画。 这个分类需要监听 AFNetworking 中的网络状态的通知。 按照通常的想法是：只要监听了通知然后设置自己的状态就完事了，然而这并不是好的设计。一个控件的某项新的功能应该交给一个专门负责这个功能的人去完成，这才是好的设计。 因此我们给 UIActivityIndicatorView 扩展了一个属性 af_notificationObserver，这个属性是专门处理上边说的事件的管理者。 伪代码： - (通知监听者 )af_notificationObserver{ return 通知监听者;}- (void)setAnimatingWithStateOfTask:(NSURLSessionTask )task{ // 监听者根据 task 来做一些事;} 这样写的好处是：当想扩展别的功能的时候，只需要再添加一个其他功能的负责人就可以，所有的逻辑都是负责人自己实现。这种思想简直完美。我们看 AFNetworking 中对上边伪代码的实现。相信大多数朋友应该知道，往分类中添加属性使用 Runtime，不明白的可以看这篇 Objective-C runtime的常见应用。 - (AFActivityIndicatorViewNotificationObserver )af_notificationObserver{ // 获取 AFActivityIndicatorViewNotificationObserver notificationObserver = objc_getAssociatedObject(self, @selector(af_notificationObserver)); if (notificationObserver == nil) { // 生成观察者 notificationObserver = [[AFActivityIndicatorViewNotificationObserver alloc] initWithActivityIndicatorView:self]; // 关联 objc_setAssociatedObject( self, @selector(af_notificationObserver), notificationObserver, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } return notificationObserver;} - (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task{ [[self af_notificationObserver] setAnimatingWithStateOfTask:task];} 来看看这个 af_notificationObserver 有什么。 @interface AFActivityIndicatorViewNotificationObserver : NSObject // 控件@property (readonly, nonatomic, weak) UIActivityIndicatorView activityIndicatorView;/\\* * 传入控件对象 */- (instancetype)initWithActivityIndicatorView:(UIActivityIndicatorView )activityIndicatorView;/\\* * 通过这个方法来操控 UIActivityIndicatorView */- (void)setAnimatingWithStateOfTask:(NSURLSessionTask *)task; @end af_notificationObserver 只需要上面的属性和方法，那就剩下 setAnimatingWithStateOfTask: 这个方法的实现了。 - (void)setAnimatingWithStateOfTask:(NSURLSessionTask )task{ NSNotificationCenter notificationCenter = [NSNotificationCenter defaultCenter]; // 移除通知 \\[notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil\\]; \\[notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil\\]; \\[notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil\\]; if (task) { // task 的状态不等于完成 if (task.state != NSURLSessionTaskStateCompleted) { UIActivityIndicatorView *activityIndicatorView = self.activityIndicatorView; // 状态为运行中就开始动画，否则为停止 if (task.state == NSURLSessionTaskStateRunning) { \\[activityIndicatorView startAnimating\\]; } else { \\[activityIndicatorView stopAnimating\\]; } // 添加 AFNetworking 状态通知 \\[notificationCenter addObserver:self selector:@selector(af_startAnimating) name:AFNetworkingTaskDidResumeNotification object:task\\]; \\[notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidCompleteNotification object:task\\]; \\[notificationCenter addObserver:self selector:@selector(af_stopAnimating) name:AFNetworkingTaskDidSuspendNotification object:task\\]; } } } 二、UIRefreshControl+AFNetworking与上面的分类基本相同。 三、UIImageView+AFNetworking在 AFImageDownloader 那篇文章中提到过，要异步显示网络上的图片，就要把图片数据缓存下来才行。因此，要赋予 UIImageView 这项功能，就需要使用 AFImageDownloader 来获取图片数据。 UIImageView 是最常用的显示图片的控件。额外增加了 placeholderImage（占位图片）这个属性和 success、failure 这两个 block 来自定义一些事件。最后增加了两个取消某个状态下的图片下载的方法。 + (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader; - (void)setImageWithURL:(NSURL *)url; - (void)setImageWithURL:(NSURL )url placeholderImage:(nullable UIImage )placeholderImage; /** Asynchronously downloads an image from the specified URL request, and sets it once the request is finished. Any previous image request for the receiver will be cancelled. If the image is cached locally, the image is set immediately, otherwise the specified placeholder image will be set immediately, and then the remote image will be set once the request is finished. If a success block is specified, it is the responsibility of the block to set the image of the image view before returning. If no success block is specified, the default behavior of setting the image with `self.image = image` is applied. */- (void)setImageWithURLRequest:(NSURLRequest )urlRequest placeholderImage:(nullable UIImage )placeholderImage success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage image))success failure:(nullable void (^)(NSURLRequest \\request, NSHTTPURLResponse * _Nullable response, NSError *error))failure; /** * Cancels any executing image operation for the receiver, if one exists. */- (void)cancelImageDownloadTask; 只需要实现参数最多的那个方法就行了。这应该就是所谓的尾调函数。 @interface UIImageView (_AFNetworking)@property (readwrite, nonatomic, strong, setter = af_setActiveImageDownloadReceipt:) AFImageDownloadReceipt *af_activeImageDownloadReceipt;@end 这个属性是图片依据。 - (AFImageDownloadReceipt )af_activeImageDownloadReceipt{ return (AFImageDownloadReceipt )objc_getAssociatedObject(self, @selector(af_activeImageDownloadReceipt));} - (void)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt{ objc_setAssociatedObject(self, @selector(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} 通过运行时为 @selector(af_activeImageDownloadReceipt) 设置了关联值，同样的原理。 sharedImageDownloader 也是这么设置的。 + (AFImageDownloader *)sharedImageDownloader { return objc_getAssociatedObject(self, @selector(sharedImageDownloader)) ?: [AFImageDownloader defaultInstance];} + (void)setSharedImageDownloader:(AFImageDownloader *)imageDownloader { objc_setAssociatedObject(self, @selector(sharedImageDownloader), imageDownloader, OBJC_ASSOCIATION_RETAIN_NONATOMIC);} 在这里说下这个 objc_setAssociatedObject方法，其中第二个参数是一个地址，因此可以用 @selector 或者自定义一个全局的 const 字段，取它的地址。 - (void)cancelImageDownloadTask { if (self.af_activeImageDownloadReceipt != nil) { [[self.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:self.af_activeImageDownloadReceipt]; [self clearActiveDownloadInformation]; }} - (void)clearActiveDownloadInformation { self.af_activeImageDownloadReceipt = nil;} - (BOOL)isActiveTaskURLEqualToURLRequest:(NSURLRequest *)urlRequest { return [self.af_activeImageDownloadReceipt.task.originalRequest.URL.absoluteString isEqualToString:urlRequest.URL.absoluteString];} 来看这个核心方法，处理手法和之前的代码如出一辙，值得学习的是核心方法中的判断比较详细。 - (void)setImageWithURLRequest:(NSURLRequest )urlRequest placeholderImage:(UIImage )placeholderImage success:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage image))success failure:(void (^)(NSURLRequest \\request, NSHTTPURLResponse * _Nullable response, NSError *error))failure{ // urlRequest 不正确 if ([urlRequest URL] == nil) { // 直接设置占位图片 self.image = placeholderImage; // 回调 if (failure) { NSError *error = \\[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil\\]; failure(urlRequest, nil, error); } return; } // 如果当前活动的下载和本次下载相同，则返回 if (\\[self isActiveTaskURLEqualToURLRequest:urlRequest\\]) { return; } // 取消之前的下载任务 \\[self cancelImageDownloadTask\\]; // 取出 downloader AFImageDownloader *downloader = \\[\\[self class\\] sharedImageDownloader\\]; // 取出缓存 id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache; //Use the image from the image cache if it exists UIImage *cachedImage = \\[imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil\\]; if (cachedImage) { // 成功回调，但不会赋值 if (success) { success(urlRequest, nil, cachedImage); } else { self.image = cachedImage; } // 清除激活下载信息 \\[self clearActiveDownloadInformation\\]; } else { // 先设置占位图片 if (placeholderImage) { self.image = placeholderImage; } \\_\\_weak \\_\\_typeof(self)weakSelf = self; NSUUID *downloadID = \\[NSUUID UUID\\]; AFImageDownloadReceipt *receipt; receipt = \\[downloader downloadImageForURLRequest:urlRequest withReceiptID:downloadID success:^(NSURLRequest * \\_Nonnull request, NSHTTPURLResponse * \\_Nullable response, UIImage * _Nonnull responseObject) { \\_\\_strong \\_\\_typeof(weakSelf)strongSelf = weakSelf; if (\\[strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID\\]) { if (success) { success(request, response, responseObject); } else if (responseObject) { strongSelf.image = responseObject; } \\[strongSelf clearActiveDownloadInformation\\]; } } failure:^(NSURLRequest * \\_Nonnull request, NSHTTPURLResponse * \\_Nullable response, NSError * _Nonnull error) { \\_\\_strong \\_\\_typeof(weakSelf)strongSelf = weakSelf; if (\\[strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID\\]) { if (failure) { failure(request, response, error); } \\[strongSelf clearActiveDownloadInformation\\]; } }\\]; self.af_activeImageDownloadReceipt = receipt; } } 方法不是最重要的，重要是梳理出这一整套的逻辑和想法，下面就来分析分析。 首先规定，使用这个分类每加载一次图片生成一个 af_activeImageDownloadReceipt 凭据，这个凭据一旦下载完成后，需要置为 nil； 使用上边的这个最长的方法来加载图片； 判断 urlRequest 是不是有效的。无效的话取消之前的下载，然后赋值替代图片； urlRequest 有效，再判断当前下载的跟之前正在下载的 URL 是一样的； 取消之前的下载任务 在缓存中取图片，如果图片存在，那么再看看是否设置了 success，设置了就调用这个 block，否则就使用替代图片。 请求失败处理方法同上边 6 一样。","tags":[]},{"title":" 面向对象的几大设计原则\t\t","date":"2019-03-11T16:27:42.000Z","path":"2019/03/12/e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-9a-84-e5-87-a0-e5-a4-a7-e8-ae-be-e8-ae-a1-e5-8e-9f-e5-88-99/","text":"原文：面向对象的几大设计原则、面向对象设计的七大设计原则详解 对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。 在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的话。 最常见的 7 种面向对象设计原则如下表所示： 一、七大原则之间的关系七大原则之间并不是相互孤立的，而是彼此间存在着一定关联，一个可以是另一个原则的加强或是基础。违反其中的某一个，可能同时违反了其余的原则。 开闭原则是面向对象的可复用设计的基石，其他设计原则是实现开闭原则的手段和工具。 一般可以把这七个原则分成了以下两个部分： 设计目标：开闭原则、里氏代换原则、迪米特原则设计方法：单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则 二、单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。 单一职责原则（Single Responsibility Principle, SRP） 一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 ①、如果一个职责使用了外部类库，则使用另外一个职责的用户却也不得不包含这个未被使用的外部类库。 ②、某个用户由于某个原因需要修改其中一个职责，另外一个职责的用户也将受到影响，他将不得不重新编译和配置。 1、职责的划分 既然一个类不能有多个职责，那么怎么划分职责呢？ Robert.C Martin 给出了一个著名的定义：所谓一个类的一个职责是指引起该类变化的一个原因。如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责。 SRP 违反例： class Modem { void dial(String pno); // 拨号 void hangup(); // 挂断 void send(char c); // 发送数据 char recv(); // 接收数据}; 乍一看，这是一个没有任何问题的接口设计。 但事实上，这个接口包含了 2 个职责：第一个是连接管理（dial、hangup）；另一个是数据通信（send、recv）。 很多情况下，这 2 个职责没有任何共通的部分，它们因为不同的理由而改变，被不同部分的程序调用。所以它违反了 SRP 原则。 下面的类图将它的 2 个不同职责分成 2 个不同的接口，这样至少可以让客户端应用程序使用具有单一职责的接口： 让 ModemImplementation 实现这两个接口。我们注意到，ModemImplementation 又组合了 2 个职责，这不是我们希望的，但有时这又是必须的。通常由于某些原因，迫使我们不得不绑定多个职责到一个类中，但我们至少可以通过接口的分割来分离应用程序关心的概念。 事实上，这个例子一个更好的设计应该是这样的，如图： 例如，考虑下图的设计。 Retangle 类具有两个方法：一个方法把矩形绘制在屏幕上，另一个方法计算矩形的面积。有两个不同的 Application 使用 Rectangle 类。一个是计算几何面积的，Rectangle 类会在几何形状计算方面给予它帮助。另一个 Application 实质上是绘制一个在舞台上显示的矩形。 这一设计违反了单一职责原则。Rectangle 类具有了两个职责，第一个职责是提供一个矩形形状几何数据模型；第二个职责是把矩形显示在屏幕上。 对于 SRP 的违反导致了一些严重的问题。首先，我们必须在计算几何应用程序中包含核心显示对象的模块。其次，如果绘制矩形 Application 发生改变，也可能导致计算矩形面积 Application 发生改变，导致不必要的重新编译和不可预测的失败。 一个较好的设计是把这两个职责分离到下图所示的两个完全不同的类中。这个设计把 Rectangle 类中进行计算的部分移到 GeometryRectangle 类中。现在矩形绘制方式的改变不会对计算矩形面积的应用产生影响了。 2、使用单一职责原则的理由 单一职责原则从职责（改变理由）的侧面上为我们对类（接口）的抽象的颗粒度建立了判断基准：在为系统设计类（接口）的时候应该保证它们的单一职责性。 降低了类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险。 三、开闭原则 开闭原则（Open-Closed Principle, OCP） 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 扩展开放：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。 修改关闭：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求模块是修改关闭的。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在 Java、C# 等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，在不修改已有代码的基础上（修改关闭）实现扩展系统的功能（扩展开放），达到开闭原则的要求。 注意：因为 xml 和 properties 等格式的配置文件是纯文本文件，可以直接通过 VI 编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的 Java 代码或 C# 代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。 通过下边的例子理解什么是扩展开放和修改关闭： 左边的设计是直接依赖实际的类，不是对扩展开放的。右边的设计是良好的设计：Client 对于 Server 提供的接口是封闭的；Client 对于 Server 的新的接口实现方法的扩展是开放的。 1、系统设计需要遵循开闭原则的原因 稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。 扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。 遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。 2、开闭原则的实现方法 为了满足开闭原则的对修改关闭原则以及扩展开放原则，应该对软件系统中的不变的部分加以抽象，在面向对象的设计中 可以把这些不变的部分加以抽象成不变的接口，这些不变的接口可以应对未来的扩展； 接口的最小功能设计原则。原有的接口要可以应对未来的扩展，不足的部分可以通过定义新的接口来实现； 模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。 接口可以被复用，但接口的实现却不一定能被复用。接口是稳定的、关闭的，但接口的实现是可变的、开放的。 可以通过对接口的不同实现以及类的继承行为等为系统增加新的或改变系统原来的功能，实现软件系统的柔性扩展。 好处： 提高系统的可复用性和可维护性。 简单地说，软件系统是否有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。现在多把开闭原则等同于面向接口的软件设计。 3、一个符合开闭原则的设计 需求：创建一系列多边形。 首先，下面是不满足开闭原则的设计方法： Shape.h enum ShapeType{ isCircle, isSquare }; typedef struct Shape { enumShapeType type} shape; Circle.h typedef struct Circle { enumShapeType type; double radius; Point center;} circle; void drawCircle( circle* ); Square.h typedef struct Square { enumShapeType type; double side; Point topleft;} square; void drawSquare( square* ); drawShapes.cpp #include “Shape.h” #include “Circle.h” #include “Square.h” void drawShapes( shape* list[], int n ) { for( int i = 0; i &lt; n; i++ ) { shape* s= list\\[i\\]; switch( s-&gt;type ) { case isSquare: drawSquare( (square*)s ); break; case isCircle: drawCircle( (circle*)s ); break; } } } 该设计不是对扩展开放的，当增加一个新的图形时： ①、Shape 不是扩展的，需要修改源码来增加枚举类型 ②、drawShapes 不是封闭的，当其被其他模块调用时，如果要增加一个新的图形需要修改 switch/case 此外，该设计逻辑复杂，总的来说是一个僵化的、脆弱的、具有很高的牢固性的设计。用开闭原则重构该设计如下图： 此时，在该设计中，新增一个图形只需要实现 Shape 接口，满足对扩展开放；也不需要修改 drawShapes() 方法，对修改关闭。 4、开闭原则的相对性 软件系统的构建是一个需要不断重构的过程，在这个过程中，模块的功能抽象，模块与模块间的关系，都不会从一开始就非常清晰明了，所以构建 100% 满足开闭原则的软件系统是相当困难的，这就是开闭原则的相对性。 但在设计过程中，通过对模块功能的抽象（接口定义），模块之间的关系的抽象（通过接口调用），抽象与实现的分离（面向接口的程序设计）等，可以尽量接近满足开闭原则。 四、里氏代换原则 里氏代换原则（Liskov Substitution Principle, LSP） 所有引用基类（父类）的地方必须能透明地使用其子类的对象。 里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。 也就是说，只有满足以下 2 个条件的 OO 设计才可被认为是满足了 LSP 原则： ①、不应该在代码中出现 if/else 等对派生类类型进行判断的条件。 ②、派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。 例如有两个类，一个类为 BaseClass，另一个是 SubClass 类，并且 SubClass 类是 BaseClass 类的子类。 那么一个方法如果可以接受一个 BaseClass 类型的基类对象 base 的话，如：method1(base)，那么它必然可以接受一个 SubClass 类型的对象 sub，method1(sub) 能够正常运行。反过来的代换不成立，如一个方法 method2 接受 SubClass 类型的对象 sub 为参数：method2(sub)，那么一般而言不可以有 method2(base)，除非是重载方法。 里氏代换原则是实现开闭原则的重要方式之一。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： ①、子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 ②、在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。 ③、Java 语言中，在编译阶段，Java 编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但 Java 编译器的检查是有局限的。 以下代码就违反了 LSP 定义。 if (obj typeof Class1) { // do something}else if (obj typeof Class2) { // do something else} 同时 LSP 体现了： 类的继承原则：如果一个派生类的对象可能会在基类出现的地方出现运行错误，则应该重新设计它们之间的关系。 动作正确性保证：从另一个侧面上保证了符合 LSP 设计原则的类的扩展不会给已有的系统引入新的错误。 里氏替换原则为我们是否应该使用继承提供了判断的依据，不再是简单地根据两者之间是否有相同之处来说使用继承。 里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。 具体来说： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（方法的输入/入参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的方法时（重载/重写或实现抽象方法）的后置条件（方法的输出/返回值）要比父类更严格或相等。 下面举几个例子帮助更进一步理解 LSP： 例 1： Rectangle 是矩形，Square 是正方形，Square 继承于 Rectangle，这样一看似乎没有问题。 假如已有的系统中存在以下业务逻辑代码： void g(Rectangle &amp;r) { r.SetWidth(5); r.SetHeight(4); assert(r.GetWidth() * r.GetHeight()) == 20); } 则对应于扩展类 Square，在调用既有业务逻辑时会抛出一个异常。 Rectangle square = new Square();g(square); 这显然违反了 LSP 原则。说明这样的继承关系在这种业务逻辑下不应该使用。 例 2： 鲸鱼和鱼，应该属于什么关系？从生物学的角度看，鲸鱼应该属于哺乳动物，而不是鱼类。没错，在程序世界中我们可以得出同样的结论。如果让鲸鱼类去继承鱼类，就完全违背了 Liskov 替换原则。因为鱼作为基类，很多特性是鲸鱼所不具备的，例如通过腮呼吸，以及卵生繁殖。那么，二者是否具有共性呢？ 有，那就是它们都可以在水中”游泳”，从程序设计的角度来说，它们都共同实现了一个支持”游泳”行为的接口。 例 3： 运动员和自行车例子，每个运动员都有一辆自行车，如果按照下面设计，很显然违反了 LSP 原则。 // 自行车class Bike { public: void Move( ); void Stop( ); void Repair( );protected: int ChangeColor(int );private: int mColor;}; // 运动员class Player : private Bike { public: void StartRace( ); void EndRace( );protected: int CurStrength ( );private: int mMaxStrength; int mAge;}; 1、里式替换原则的优点 约束继承泛滥，是开闭原则的一种体现。 加强程序的健壮性，同时变更时也可以做到非常好地提高程序的维护性、扩展性。降低需求变更时引入的风险。 2、重构违反 LSP 的设计 假如两个具体的类 A、B 之间的关系违反了 LSP 的设计（假设是从 B 到 A 的继承关系），那么根据具体的情况可以在下面的两种重构方案中选择一种： 创建一个新的抽象类 C，作为两个具体类的基类，将 A、B 的共同行为移动到 C 中来解决问题。 从 B 到 A 的继承关系改为关联关系。 对于矩形和正方形例子，可以构造一个抽象的四边形类，把矩形和正方形共同的行为放到这个四边形类里面，让矩形和正方形都是它的派生类。对于矩形和正方形，取 width 和 height 是它们共同的行为，但是给 width 和 height 赋值，两者行为不同，因此，这个抽象的四边形的类只有取值方法，没有赋值方法。 对于运动员和自行车例子，可以采用关联关系来重构： class Player { public: void StartRace( ); void EndRace( );protected: int CurStrength ( );private: int mMaxStrength; int mAge;Bike * abike;}; 在进行设计的时候，我们尽量从抽象类继承，而不是从具体类继承。 如果从继承等级树来看，所有叶子节点应当是具体类，而所有的树枝节点应当是抽象类或者接口。当然这只是一个一般性的指导原则，使用的时候还要具体情况具体分析。 在很多情况下，在设计初期我们类之间的关系不是很明确，LSP 则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。 五、依赖倒转原则 依赖倒转原则（Dependency Inversion Principle, DIP） A. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象； B. 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 依赖：在程序设计中，如果一个模块 a 使用/调用了另一个模块 b，我们称模块 a 依赖模块 b。 高层模块与低层模块：往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。 依赖倒置：面向对象程序设计相对于面向过程（结构化）程序设计而言，依赖关系被倒置了。因为传统的结构化程序设计中，高层模块总是依赖于低层模块。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。 为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入（DependencyInjection, DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。 常用的注入方式有三种，分别是：构造注入、设值注入（Setter 注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象；设值注入是指通过 Setter 方法来传入具体类的对象；而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。 这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 扩展软件工程大师 Martin Fowler 在其文章 Inversion of Control Containers and the Dependency Injection pattern 中对依赖注入进行了深入的分析。 1、问题的提出 Robert C. Martin 在原文中给出了“Bad Design”的定义： ①、系统很难改变，因为每个改变都会影响其他很多部分； ②、当你对某地方做一修改，系统的看似无关的其他部分都不工作了； ③、系统很难被另外一个应用重用，因为很难将要重用的部分从系统中分离开来。 导致 Bad Design 的很大原因是“高层模块”过分依赖“低层模块”。 一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。 为了解决上述问题，Robert C. Martin 提出了 OO 设计的 Dependency Inversion Principle (DIP) 原则。 DIP 给出了一个解决方案：在高层模块与低层模块之间，引入一个抽象接口层。 High Level Classes（高层模块） -> Abstraction Layer（抽象接口层） -> Low Level Classes（低层模块） 抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。 这样，高层模块不直接依赖低层模块，而是依赖抽象接口层。抽象接口也不依赖低层模块的实现细节，而是低层模块依赖（继承或实现）抽象接口。 类与类之间都通过抽象接口层来建立关系。 2、依赖倒置原则的违反例和重构 示例：考虑一个控制熔炉调节器的软件。该软件从一个 IO 通道中读取当前的温度，并通过向另一个 IO 通道发送命令来指示熔炉的开或者关。 温度调节器的简单算法： const byte THERMONETER=0x86;const byte FURNACE=0x87;const byte ENGAGE=1;const byte DISENGAGE=0; void Regulate(double minTemp,double maxTemp) { for(;;) { while (in(THERMONETER) &gt; minTemp) wait(1); out(FURNACE,ENGAGE); while (in(THERMONETER) &lt; maxTemp) wait(1); out(FURNACE,DISENGAGE); } } 算法的高层意图是清楚的，但是实现代码中却夹杂着许多低层细节。这段代码根本不能重用于不同的控制硬件。 由于代码很少，所以这样做不会造成太大的损害。但是，即使是这样，使算法失去重用性也是可惜的。我们更愿意倒置这种依赖关系。 图中显示了 Regulate 函数接受了两个接口参数。Thermometer 接口可以读取，而 Heater 接口可以启动和停止。Regulate 算法需要的就是这些。这就倒置了依赖关系，使得高层的调节策略不再依赖于任何温度计或者熔炉的特定细节。该算法具有很好的可重用性。 通用的调节器算法： void Regulate(Thermometer t, Heater h, double minTemp,double maxTemp) { for(;;) { while (t.Read() &gt; minTemp) wait(1); h.Engate(); while (t.Read() &lt; maxTemp) wait(1); h.Disengage(); } } 3、怎么使用依赖倒置原则 ①、依赖于抽象 任何变量都不应该持有一个指向具体类的指针或引用。如： class class1 { class2 * cls2 = new class2();} class class2 { … } 任何类都不应该从具体类派生。 ②、设计接口而非设计实现 使用继承避免对类的直接绑定 抽象类/接口：倾向于较少的变化；抽象是关键点，它易于修改和扩展；不要强制修改那些抽象接口/类。 例外：有些类不可能变化，在可以直接使用具体类的情况下，不需要插入抽象层，如：字符串类。 ③、避免传递依赖 避免高层依赖于低层 使用继承和抽象类来有效地消除传递依赖 4、依赖倒置原则的优点 可以减少类间的耦合性、提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的风险。 六、迪米特法则 迪米特法则（Law of Demeter, LoD） 一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 又叫最少知道原则（Least Knowledge Principle），可以简单说成：talk only to your immediate friends。在迪米特法则中，对于一个对象，其朋友包括以下几类： ①、当前对象本身（this）； ②、以参数形式传入到当前对象方法中的对象； ③、当前对象的成员对象； ④、如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； ⑤、当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时要注意下面的几点： ①、在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及； ②、在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限； ③、在类的设计上，只要有可能，一个类型应当设计成不变类； ④、在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 1、迪米特原则的优缺点 迪米特原则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特原则不希望类直接建立直接的接触。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特原则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系，这在一定程度上增加了系统的复杂度。 例如，购房者要购买楼盘 A、B、C 中的楼，他不必直接到楼盘去买楼，而是可以通过一个售楼处去了解情况，这样就减少了购房者与楼盘之间的耦合。 2、违反迪米特原则的设计与重构 下面的代码在方法体内部依赖了其他类，这严重违反迪米特原则。 class Teacher { public: void command(GroupLeader groupLeader) { list&lt;Student&gt; listStudents = new list&lt;Student&gt;; for (int i = 0; i &lt; 20; i++) { listStudents.add(new Student()); } groupLeader.countStudents(listStudents); } } 方法是类的一个行为，类竟然不知道自己的行为与其他类产生了依赖关系（Teacher 类中依赖了 Student 类，然而 Student 类并不在 Teacher 类的朋友圈中，一旦 Student 类被修改了，Teacher 类是根本不知道的），这是不允许的。 正确的做法： class Teacher { public: void command(GroupLeader groupLeader) { groupLeader.countStudents(); } } class GroupLeader { private: list listStudents; public: GroupLeader(list _listStudents) { this.listStudents = _listStudents; } void countStudents() { cout&lt;&lt;&quot;女生数量是：&quot; &lt;&lt;listStudents.size() &lt;&lt;endl; } } 3、使用迪米特原则时要考虑的 ①、朋友间也是有距离的 一个类公开的 public 属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少 public 方法和属性，是否可以修改为 private 等。 注意：迪米特原则要求类“羞涩”一点，尽量不要对外公布太多的 public 方法和非静态的 public 变量，尽量内敛，多使用private、protected 等访问权限。 ②、是自己的就是自己的 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。 七、合成复用原则 合成复用原则（Composite Reuse Principle, CRP） 尽量使用对象组合，而不是继承来达到复用的目的。 聚合：表示整体和部分的关系，表示“拥有”。 组合：则是一种更强的“拥有”，部分和整体的生命周期一样。组合的新的对象完全支配其组成部分，包括它们的创建和湮灭等。一个组合关系的成分对象是不能与另一个组合关系共享的。 组合是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性。因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用。 扩展对于继承的深入理解，大家可以参考《软件架构设计》文章中《见山只是山见水只是水——提升对继承的认识》。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而“Has-A”则不同，它表示某一个角色具有某一项责任。 1、什么时候才应该使用继承 只有当以下的条件全部被满足时，才应当使用继承关系： ①、派生类是基类的一个特殊种类，而不是基类的一个角色，也就是区分 “Has-A” 和 “Is-A”。只有 “Is-A” 关系才符合继承关系，”Has-A” 关系应当用聚合来描述。 ②、永远不会出现需要将派生类换成另外一个类的派生类的情况。如果不能肯定将来是否会变成另外一个派生类的话，就不要使用继承。 ③、派生类具有扩展基类的责任，而不是具有置换掉（override）或注销掉（Nullify）基类的责任。如果一个派生类需要大量的置换掉基类的行为，那么这个类就不应该是这个基类的派生类。 ④、只有在分类学角度上有意义时，才可以使用继承。 总的来说： 如果语义上存在着明确的 “Is-A” 关系，并且这种关系是稳定的、不变的，则考虑使用继承；如果没有 “Is-A” 关系，或者这种关系是可变的，使用组合。 另外一个就是只有两个类满足里氏替换原则的时候，才可能是 “Is-A” 关系。也就是说，如果两个类是 “Has-A” 关系，但是设计成了继承，那么肯定违反里氏替换原则。 错误的使用继承而不是组合/聚合的一个常见原因是错误的把 “Has-A” 当成了 “Is-A”。”Is-A” 代表一个类是另外一个类的一种；”Has-A” 代表一个类是另外一个类的一个角色，而不是另外一个类的特殊种类。 看一个例子： 如果把“人”当成一个类，然后把雇员、经理、学生当成是“人”的派生类。这个的错误在于把“角色”的等级结构和“人”的等级结构混淆了。经理、雇员、学生是一个人的角色，一个人可以同时拥有上述角色。如果按继承来设计，那么如果一个人是雇员的话，就不可能是学生，这显然不合理。 正确的设计是有个抽象类“角色”，“人”可以拥有多个“角色”（聚合），“雇员”、“经理”、“学生”是“角色”的派生类。 2、通过组合/聚合复用的优缺点 优点： 新对象存取子对象的唯一方法是通过子对象的接口。 这种复用是黑箱复用，因为子对象的内部细节是新对象所看不见的。 这种复用更好地支持封装性。 这种复用实现上的相互依赖性比较小。 每一个新的类可以将焦点集中在一个任务上。 这种复用可以在运行时间内动态进行，新对象可以动态的引用与子对象类型相同的对象。 作为复用手段可以应用到几乎任何环境中去。 缺点：就是系统中会有较多的对象需要管理。 3、通过继承来进行复用的优缺点 优点： 新的实现较为容易，因为基类的大部分功能可以通过继承的关系自动进入派生类。 修改和扩展继承而来的实现较为容易。 缺点： 继承复用破坏封装性，因为继承将基类的实现细节暴露给派生类。由于基类的内部细节常常是对于派生类透明的，所以这种复用是透明的复用，又称“白箱”复用。 如果基类发生改变，那么派生类的实现也不得不发生改变。 从基类继承而来的实现是静态的，不可能在运行时间内发生改变，没有足够的灵活性。 八、接口隔离原则 接口隔离原则（Interface Segregation Principle, ISP） 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如 Java 语言中的 interface。对于这两种不同的含义，ISP 的表达方式以及含义都有所不同： ①、当把“接口”理解成一个类型所提供的所有方法特征的集合时，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 ②、如果把“接口”理解成狭义的特定语言的接口，那么 ISP 表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 它包含了 2 层意思： 接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口。 接口的依赖（继承）原则：如果一个接口 A 继承另一个接口 B，则接口 A 相当于继承了接口 B 的方法，那么继承了接口 B 后的接口 A 也应该遵循不应该包含用户不使用的方法。 反之，则说明接口 A 被 B 给污染了，应该重新设计它们的关系。 如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。 总而言之，接口分隔原则指导我们： ①、一个类对一个类的依赖应该建立在最小的接口上； ②、建立单一接口，不要建立庞大臃肿的接口； ③、尽量细化接口，接口中的方法尽量少。 1、违反 ISP 原则的设计与重构 下面我们举例说明怎么设计接口或类之间的关系，使其不违反 ISP 原则。 假如有一个 Door，有 lock、unlock 功能，另外，可以在 Door 上安装一个 Alarm 而使其具有报警功能。用户可以选择一般的 Door，也可以选择具有报警功能的 Door。 有以下几种设计方法： ISP 原则的违反例一：在 Door 接口里定义所有的方法。 但这样一来，依赖 Door 接口的 CommonDoor 却不得不实现未使用的 alarm() 方法。违反了 ISP 原则。 ISP 原则的违反例二：在 Alarm 接口定义 alarm 方法，在 Door 接口定义 lock、unlock 方法，Door 接口继承 Alarm 接口。 与例一一样，依赖 Door 接口的 CommonDoor 却不得不实现未使用的 alarm() 方法。违反了 ISP 原则。 遵循 ISP 原则的例一：通过多重继承实现 在 Alarm 接口定义 alarm 方法，在 Door 接口定义 lock、unlock 方法。接口之间无继承关系。CommonDoor 实现 Door 接口，AlarmDoor 有 2 种实现方案： ①、同时实现 Door 和 Alarm 接口。 ②、继承 CommonDoor，并实现 Alarm 接口。 第 2 种方案更具有实用性。这样的设计遵循了 ISP 设计原则。 遵循 ISP 原则的例二：通过关联实现 在这种方法里，AlarmDoor 实现了 Alarm 接口，同时把功能 lock 和 unlock 委让给 CommonDoor 对象完成。 这种设计遵循了 ISP 设计原则。 2、接口分隔原则的优点和适度原则 接口分隔原则从对接口的使用上为我们对接口抽象的颗粒度建立了判断基准：在为系统设计接口的时候，使用多个专门的接口代替单一的胖接口。 符合高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。 注意适度原则，接口分隔要适度，避免产生大量的细小接口。 3、单一职责原则和接口分隔原则的区别 单一职责强调的是接口、类、方法的职责是单一的，强调职责，方法可以多，针对程序中实现的细节； 接口分隔原则主要是约束接口，针对抽象、整体框架。","tags":[]},{"title":" 哈希表的原理与实现\t\t","date":"2019-03-11T16:25:59.000Z","path":"2019/03/12/e5-93-88-e5-b8-8c-e8-a1-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/","text":"原文：哈希表的原理与实现、一致性哈希算法原理、五分钟理解一致性哈希算法(consistent hashing) 一、哈希表的原理与实现哈希表（Hash Table）的应用近两年才在 NOI 中出现，作为一种高效的数据结构，它正在竞赛中发挥着越来越重要的作用。 哈希表又叫做散列表，分为“开散列” 和“闭散列”。考虑到竞赛时多数人通常避免使用动态存储结构，本文中的“哈希表”仅指“闭散列”，关于其他方面读者可参阅其他书籍。 哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 一列键值对数据，存储在一个 table 中，如何通过数据的关键字快速查找相应值呢？ 在所有的线性数据结构中，数组的定位速度最快，因为它可以通过下标直接定位到相应的数组空间，不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。 哈希表的做法其实很简单，就是把 Key 通过一个固定的算法函数，即哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将 value 存储在以该数字为下标的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将 key 转换为对应的数组下标，并定位到该空间获取 value。如此一来，就可以充分利用到数组的定位性能进行数据定位。 存储步骤： ①、把字符串 key 通过哈希函数生成一个整形数字； ②、将该数字对数组长度进行取余，取余结果作为数组下标； ③、将 value 存储在数组对应下标的空间里。 查询步骤： ①、使用哈希函数将 key 转换成对应的数组下标； ②、利用下标定位数组对应的空间，获取 value。 哈希表的原理其实就是通过空间换取时间的做法。 哈希函数对 key 进行转换，取余的值是唯一的吗？ 这个当然不能保证，主要是由于 hashcode 会对数组长度进行取余，因此其结果由于数组长度的限制必然会出现重复，所以就会有“冲突”这一问题，至于解决冲突的办法其实有很多种，比如重复散列的方式，大概就是定位的空间已经存在 value 且 key 不同的话就重新进行哈希加一并求模数组元素个数，即 (h(k)+i) mod S, i = 1,2,3…，直到找到空间为止。 Hash 表这种数据结构在 java 中是原生的一个集合对象，在实际中用途极广，主要有这么几个特点： 访问速度快 大小不受限制 按键进行索引，没有重复对象 用字符串（id:string）检索对象（object） 下面是一个 hash 表的实现。先看看头文件，也就是数据结构的定义，相当于 java 中的接口的概念： #include &lt;stdio.h&gt; #define HASHSIZE 256 // 定义 hash 表中的节点的类型struct nlist { struct nlist next; char name; char * defn;}; // 定义接口中的函数，也就是对外来说，这个程序可以做什么 unsigned hash(char s); // 计算一个串的 hash 值struct nlist \\lookup(char *s); // 根据 key 查找一个 valuestruct nlist *install(char *name, char *defn); // 插入一个 key = value 的对象 然后是具体实现： #include &lt;string.h&gt; static struct nlist *hashtab[HASHSIZE]; unsigned hash(char *s) // 取得 hash 值{ unsigned hashval; for(hashval = 0; *s != &apos;\\\\0&apos;; s++) hashval = \\*s + 31 \\* hashval; return hashval % HASHSIZE; } struct nlist *lookup(char *s){ struct nlist *np; for(np = hashtab\\[hash(s)\\]; np != NULL; np = np-&gt;next) if(strcmp(s,np-&gt;name) == 0) return np; return NULL; } struct nlist *install(char *name,char defn){ struct nlist np; unsigned hashval; if((np = lookup(name)) == NULL){ np = (struct nlist *)malloc(sizeof(struct nlist)); if(np == NULL || (np-&gt;name = strdup(name)) == NULL) return NULL; hashval = hash(name); np-&gt;next= hashtab\\[hashval\\]; hashtab\\[hashval\\] = np; } else free((void *)np-&gt;defn); if((np-&gt;defn = strdup(defn)) == NULL) return NULL; return np; } 很简单，只有两个外部接口， install(key, value) 用来插入一个新的节点 lookup(key) 根据一个键来进行搜索，并返回节点 代码很简单，主要用到的 hash 算法跟 java 中的 String 的 hashcode() 方法中用到的算法一样，使用： unsigned hash(char *s){ unsigned hashval; for(hashval = 0; *s != &apos;\\\\0&apos;;s++) hashval = \\*s + 31 \\* hashval; return hashval % HASHSIZE; } 这里的 31 并非随意，乃是一个经验值，选取它的目的在于减少冲突，当然，hash 冲突这个问题是不能根本避免的。这里只是一个人们在测试中发现的可以相对减少 hash 冲突的一个数字，可能以后会发现更好的数值来。 二、一致性 hash 算法一致性 hash 算法早在 1997 年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，在论文 Consistent hashing and random trees 中被提出，设计目标是为了解决因特网中的热点（Hot spot）问题，初衷和 CARP 十分类似。一致性哈希修正了 CARP 使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在 P2P 环境中真正得到应用。目前在 cache 系统中应用越来越广泛。 1、基本场景 假设有 N 个 cache 服务器（后简称 cache），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache： hash(object) % N 一切都运行正常，再考虑如下的两种情况： ①、cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1)； ②、由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1)； 这两种情况意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器； 再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。有什么方法可以改变这个状况呢，这就是 consistent hashing 一致性 hash 算法。 2、判定哈希算法好坏的四个定义 ①、平衡性（Balance）：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。 ②、单调性（Monotonicity）：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 ③、分散性（Spread）：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 ④、负载（Load）：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。 容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。 3、consistent hashing 算法的原理 consistent hashing 是一种 hash 算法，简单的说，在移除/添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。 下面就按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。 ①、环形 hash 空间 考虑通常的 hash 算法都是将 value 映射到一个 32 位的 key 值，也即是 0~232-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 232-1 ）相接的圆环，如下图所示的那样。 ②、把对象映射到 hash 空间 接下来考虑 4 个对象 object1~object4，通过特定的 hash 函数计算出对应的 key 值，然后散列到 hash 环上，分布如下图。 hash(object1) = key1; …hash(object4) = key4; ③、把 cache 映射到 hash 空间 在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的 Hash 算法将机器也映射到环中（一般情况下对机器的 hash 计算是采用机器的 IP 或者机器名作为输入值）。 假设当前有 A、B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。 hash(cache A) = key A; …hash(cache C) = key C; ④、把对象映射到 cache 现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间了，接下来要考虑的是如何将对象映射到 cache 上面了。 在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这就找到了对象和 cache 的映射方法。 依然继续上面的例子（上图），那么根据上面的方法： 对象 object1 将被存储到 cache A 上； object2 和 object3 对应到 cache C； object4 对应到 cache B。 ⑤、考察 cache 的变动 前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。 考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache A）之间的对象，也即是本来映射到 cache B 上的那些对象。 因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可： 再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache（cache B）之间的对象（它们是本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。 因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上： 4、虚拟节点 考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下： 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。 hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中，cache A 仅存储了 object1，而 cache C 则存储了 object2 、object3 和 object4；分布是很不均衡的。 为了解决这种情况，consistent hashing 引入了“虚拟节点”的概念，它可以如下定义： “虚拟节点”（virtual node）是实际节点在 hash 空间的复制品（replica），一个实际节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。 仍以仅部署 cache A 和 cache C 的情况为例，在前面我们已经看到，cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”。cache A1、cache A2 代表了 cache A；cache C1、cache C2 代表了 cache C；假设一种比较理想的情况，参见下图 。 此时，对象到“虚拟节点”的映射关系为： objec1-&gt;cache A2objec2-&gt;cache A1objec3-&gt;cache C1objec4-&gt;cache C2 因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图所示。 “虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241 引入“虚拟节点”前，计算 cache A 的 hash 值：Hash(“202.168.14.241”); 引入“虚拟节点”后，计算“虚拟节点” cache A1 和 cache A2 的 hash 值： Hash(“202.168.14.241#1”); // cache A1Hash(“202.168.14.241#2”); // cache A2 三、分布式哈希算法由浅入深一步一步介绍什么是分布式哈希表。 1、哈希函数 哈希函数是一种计算方法，它可以把一个值 A 映射到一个特定的范围 [begin, end] 之内。对于一个值的集合{k1, k2, … , kN}，哈希函数把他们均匀的映射到某个范围之中。这样，通过这些值就可以很快的找到与之对应的映射地址 {index1, index2, … , indexN}。对于同一个值，哈希函数要能保证对这个值的运算结果总是相同的。 哈希函数需要经过精心设计才能够达到比较好的效果，但是总是无法达到理想的效果。多个值也许会映射到同样的地址上。这样就会产生冲突，如图中的红线所示。在设计哈希函数时要尽量减少冲突的产生。 最简单的哈希函数就是一个求余运算：hash(A) = A % N。这样就把 A 这个值映射到了 [0, N-1] 这样一个范围之中。 2、哈希表 哈希表的核心就是哈希函数 hash()。 哈希表是一种数据结构，它把 KEY 和 VALUE 用某种方式对应起来。使用 hash() 函数把一个 KEY 值映射到一个 index 上，即hash(KEY) = index。这样就可以把一个 KEY 值同某个 index 对应起来。然后把与这个 KEY 值对应的 VALUE 存储到 index 所标记的存储空间中。这样，每次想要查找 KEY 所对应的 VALUE 值时，只需要做一次 hash() 运算就可以找到了。 举个例子：图书馆中的书会被某人借走，这样“书名”和“人名”之间就形成了 KEY 与 VALUE 的关系。假设现在有三个记录： 这就是“书名”和“人名”的对应关系，它表示某人借了某本书。现在把这种对应关系用哈希表存储起来，它们的 hash() 值分别为： hash(简明现代魔法) = 2; hash(最后一天) = 0; hash(变形记) = 1; 然后我们就可以在一个表中存储“人名”了： 当有大量的 KEY VALUE 对应关系的数据需要存储时，这种方法就非常有效。这三个人名分别存储在 0、1 和 2 号存储空间中。当我们想要查找《简明现代魔法》这本书是被谁借走的时候，只要 hash()一下这个书名，就可以找到它所对应的 index = 2。然后在这个表中就可以找到对应的人名了。在这里，KEY 为“书名”， VALUE 为“人名”。 3、分布式哈希表 哈希表把所有的东西都存储在一台机器上，当这台机器坏掉了之后，所存储的东西就全部消失了。分布式哈希表可以把一整张哈希表分成若干个不同的部分，分别存储在不同的机器上，这样就降低了数据全部被损坏的风险。 分布式哈希表通常采用一致性哈希函数来对机器和数据进行统一运算。这里先不用深究一致性哈希究竟是什么，只需要知道它是对机器（通常是其 IP 地址）和数据（通常是其 KEY 值）进行统一的运算，把它们全都映射到一个地址空间中。假设有一个一致性哈希函数可以把一个值映射到 32bit 的地址空间中，从 0 一直到 232–1。用一个圆环来表示这个地址空间。 假设有 N 台机器，那么 hash() 就会把这 N 台机器映射到这个环的 N 个地方。然后我们把整个地址空间进行一下划分，使每台机器控制一个范围的地址空间。这样，当我们向这个系统中添加数据的时候，首先使用 hash() 函数计算一下这个数据的 index，然后找出它所对应的地址在环中属于哪个地址范围，我们就可以把这个数据放到相应的机器上。这样，就把一个哈希表分布到了不同的机器上。如下图所示： 这里蓝色的圆点表示机器，红色的圆点表示某个数据经过 hash() 计算后所得出的地址。 在这个图中，按照逆时针方向，每个机器占据的地址范围为从本机器开始一直到下一个机器为止。用顺时针方向来看，每个机器所占据的地址范围为这台机器之前的这一段地址空间。图中的虚线表示数据会存储在哪台机器上。 四、基础操作我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素。也可以简单的理解为，按照关键字为每一 个元素“分类”，然后将这个元素存储在相应“类”所对应的地方。 但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。后面我们将看到一种解决“冲突”的简便做法。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。 1、函数构造 构造函数的常用方法（下面为了叙述简洁，设 h(k) 表示关键字为 k 的元素所对应的函数值）： 除余法：选择一个适当的正整数 p ，令 h(k ) = k mod p，这里 p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。 数字选择法：如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。 2、冲突处理 线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S, i = 1,2,3…，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。 3、支持运算 哈希表支持的运算主要有：初始化(makenull)、哈希函数值的运算(h(x))、插入元素(insert)、查找元素(member)。 设插入的元素的关键字为 x ，A 为存储的数组。初始化比较容易，例如 ： const empty = maxlongint; // 用非常大的整数代表这个位置没有存储元素 p=9997; // 表的大小 procedure makenull; var i:integer; begin for i:=0 to p-1 do A[i]:=empty; End; 哈希函数值的运算根据函数的不同而变化，例如除余法的一个例子： function h(x:longint):Integer; begin h:= x mod p; end; 我们注意到，插入和查找首先都需要对这个元素定位，即如果这个元素若存在，它应该存储在什么位置，因此加入一个定位的函数 locate。 function locate(x:longint):integer; var orig,i:integer; begin orig:=h(x); i:=0; while (i &lt; S)and(A\\[(orig+i)mod S\\]&lt;&gt;x)and(A\\[(orig+i)mod S\\]&lt;&gt;empty) do inc(i);//当这个循环停下来时，要么找到一个空的存储单元，要么找到这个元素存储的单元，要么表已经满了 locate:=(orig+i) mod S; end; 插入元素： procedure insert(x:longint); var posi:integer; begin posi:=locate(x); //定位函数的返回值 if A\\[posi\\]=empty then A\\[posi\\]:=x else error; // error 即为发生了错误，当然这是可以避免的 end; 查找元素是否已经在表中： procedure member(x:longint):boolean; var posi:integer; begin posi:=locate(x); if A\\[posi\\]=x then member:=true else member:=false; end; 这些就是建立在哈希表上的常用基本运算。 当数据规模接近哈希表上界或者下界的时候，哈希表完全不能够体现高效的特点，甚至还不如一般算法。但是如果规模在中央，它高效的特点可以充分体现。试验表明当元素充满哈希表的 90% 的时候，效率就已经开始明显下降。这就给了我们提示：如果确定使用哈希表，应该尽量使数组开大，但对最太大的数组进行操作也比较费时间，需要找到一个平衡点。通常使它的容量至少是题目最大需求的 120%，效果比较好（这个仅仅是经验，没有严格证明）。 五、应用举例什么时候适合应用哈希表呢？如果发现解决这个问题时经常要询问：“某个元素是否在已知集合中？”，也就是需要高效的数据存储和查找，则使用哈希表是最好不过的了。那么，在应用哈希表的过程中，值得注意的是什么呢？ 哈希函数的设计很重要。一个不好的哈希函数，就是指造成很多冲突的情况，从前面的例子已经可以看出来，解决冲突会浪费掉大量时间，因此我们的目标就是尽力避免冲突。前面提到，在使用“除余法”的时候，h(k)=k mod p，p 最好是一个大素数。这就是为了尽力避免冲突。为什么呢？假设 p = 1000，则哈希函数分类的标准实际上就变成了按照末三位数分类，这样最多 1000 类，冲突会很多。一般地说，如果 p 的约数越多，那么冲突的几率就越大。 简单的证明：假设 p 是一个有较多约数的数，同时在数据中存在 q 满足 gcd(p,q) = d &gt;1，即有 p = ad，q = bd，则有 q mod p = q – p [q div p] = q – p[b div a]. ① 其中 [b div a] 的取值范围是不会超过 [0, b] 的正整数。也就是说，[b div a] 的值只有 b + 1 种可能，而 p 是一个预先确定的数。因此 ① 式的值就只有 b + 1 种可能了。这样，虽然 mod 运算之后的余数仍然在 [0，p-1] 内，但是它的取值仅限于 ① 可能取到的那些值。也就是说余数的分布变得不均匀了。容易看出，p 的约数越多，发生这种余数分布不均匀的情况就越频繁，冲突的几率越高。而素数的约数是最少的，因此我们选用大素数。记住“素数是我们的得力助手”。 另一方面，一味的追求低冲突率也不好。理论上是可以设计出一个几乎完美，几乎没有冲突的函数的。然而，这样做显然不值得，因为这样的函数设计很浪费时间而且编码一定很复杂，与其花费这么大的精力去设计函数，还不如用一个虽然冲突多一些但是编码简单的函数。因此，函数还需要易于编码，即易于实现。 综上所述，设计一个好的哈希函数是很关键的。而“好”的标准，就是较低的冲突率和易于实现。 另外，使用哈希表并不是记住了前面的基本操作就能以不变应万变的。有的时候，需要按照题目的要求对哈希表的结构作一些改进。往往一些简单的改进就可以带来巨大的方便。 这些只是一般原则，真正遇到试题的时候实际情况千变万化，需要具体问题具体分析才行。 六、图例过程 删除节点。 增加节点。 虚拟节点。","tags":[]},{"title":" while(true)\t\t","date":"2019-03-10T12:59:44.000Z","path":"2019/03/10/whiletrue/","text":"文章：while(true) 循环与 CPU 占用率问题 1、为什么死循环占用 CPU 高？ 一个进程如果是死循环，那么占有的 CPU 会很高，可是操作系统时间片运行的，到了一定时间不是会自动切换到别的进程吗？既然即便是死循环，到时间还是会切换到别的进程，为什么占用 CPU 会高呢？ 当切换到别的进程时，别的进程告诉系统自己没什么事情要做，不需要那么多的时间，这个时候系统就会切换到下一个进程，直到回到这个死循环的进程上，而这个进程无论什么时候都再循环，所以一直会报告有事情要做，系统就会把尽可能多的时间分给它。实际上是这个死循环任务用光了别的进程节省下来的时间。 （虽然不是很准确，真正的进程调度实现比上面说的复杂得多，不过应该可以解释这个问题了）。 while(true) { // code} 改进之后： while(true) { Sleep(1); // code } 其实只添加了一句 Sleep(1)，但是 CPU 占用率就直接从 100% 跌到了 1% 左右。 2、for(;;) 和 while(true) 的区别？ for(;;) 死循环里的两个分号代表两个空语句，编译器一般会优化掉它们，直接进入循环体。 while(true) 死循环里的 true 被看成表达式，每次循环都要判断表达式是否为真。 即相对来说 for 死循环要更加高效一点。 当然以上条件还要看编译器的优化，一些编译器优化的两者并无区别，但是并非所有的编译器都做了这样的优化。","tags":[]},{"title":" 加密算法\t\t","date":"2019-03-08T02:30:02.000Z","path":"2019/03/08/e5-8a-a0-e5-af-86-e7-ae-97-e6-b3-95/","text":"据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。 对称加密有流式、分组两种，加密和解密都是使用的同一个密钥。例如：DES、AES-GCM、ChaCha20-Poly1305等 非对称加密加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE 哈希算法将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 数字签名签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。---------------------作者：猪哥66来源：CSDN原文：https://blog.csdn.net/u014044812/article/details/79571927版权声明：本文为博主原创文章，转载请附上博文链接！ 一般来说,常见的数字加密方式都可以分为两类,即对称加密和非对称加密. 对于对称加密来说,加密和解密用的是同一个密钥, 加密方法有AES,DES,RC4,BlowFish等; 对应的, 非对称加密在加密和解密时, 用的是不同的密钥, 分别称为公钥或私钥. 非对称加密的加密方法有RSA, DSA,Diffie-Hellman等. OpenSSL是一个开源项目,为传输层安全(TLS)和安全套接字(SSL)协议提供了比较完整的实现,同时也致力于将自身打造为一个通用的密码学工具集. 其中包括: libssl : 提供了SSL(包括SSLv3)和TLS的服务器端以及客户端的实现. libcrypto : 通用的密码学库以及对X.509的支持 openssl : 一个多功能的命令行工具 本文主要使用openssl的命令行工具来示例非对称加密的流程, 如果有兴趣的话,也可以用其SDK来实现更具体的操作. 2.加解密过程2.1创建公私钥对首先用openssl生成私钥: openssl genrsa -out private.pem 1024 当然为了更加安全,可以在生成私钥的时候同时指定密码, 这样即使不小心泻露了私钥,也能增加别人的盗用难度: openssl genrsa -aes256 -passout stdin -out private.pem 1024 openssl genrsa -aes256 -passout file:passwd.txt -out private.pem 1024 openssl genrsa -aes256 -passout pass:my_password -out private.pem 1024 其中-passout 指定密码的输入方式,可以分别是stdin,从文件中读取或者紧接着pass:后面输入.有了私钥,便可以从其中提取出公钥: openssl rsa -in private.pem -pubout -out public.pem 2.2用公私钥进行加解密在一次秘密的信息传输中, 我们首先通过可信的方式(比如面对面)将公钥告知对方, 对方发送机密信息的时候就可以用我们的公钥加密: openssl rsautl -encrypt -pubin -inkey public.pem -in file.txt -out file.txt.enc 在发送的过程中即便泄露了文件,也无法查看文件的明文信息. 而我们收到密文后, 用私钥解密即可: openssl rsautl -decrypt -inkey private.pem -in file.txt.enc -out file.txt.dec 2.2和对称加密协作虽然公私钥加密很好用, 但事实上非对称加密的缺点是加解密速度要远远慢于对称加密, 在某些极端情况下,甚至能比非对称加密慢上千倍. 另外由于RSA算法的工作机理, 如果密钥是n比特的,那么其加密的信息容量就不能大于(n-11)比特. 因此对于大文件的加密传输, 通常还是使用对称加密的方式, 例如 openssl rand -base64 128 -out aeskey.txt openssl enc -aes-256-cbc -salt -in file.txt -out file.txt.aesenc -pass file:aeskey.txt openssl enc -d -aes-256-cbc -in file.txt.aesenc -out file.txt.aesdec -pass file:aeskey.txt 其中aeskey.txt是我们随机生成密码文件, 并且用其可以对大文件进行对称的加解密, 在实际中,通常还会将密码文件用公私钥加密的方式来发送给对方. 值得一提的是,这也正是PGP的工作方式, 3.证书对任一个体来说, 它都有公钥,私钥和证书. 其中私钥用来加密发出去的信息,公钥用来解密收到的信息,而证书则用来证明自己的身份. 一般来说,证书中包含自己的公钥以及额外的信息,如签发机构(CA, Certificate Authority),证书用途(比如适用的域名)和有效时间等. CA通常是个第三方的可信机构, 比如VeriSign, GeoTrust,DigiCert和沃通等, 当然也可以是未知的主体, 比如说自己. 获得一张证书的流程通常是: 1)用私钥生成证书签名请求(csr), 2)将csr文件发送给CA,待其验证信息无误后,CA会用自己的私钥对其进行签名表示确认. 3.1 生成证书签名请求证书签名请求(Certificate Signing Request)通常以.csr为后缀, 包含了请求方的公钥和主体的详细信息,如域名,公司名,国家,城市等信息, 其完整内容可以参考这里. 使用openssl也能很方便地生成csr: openssl req -new -key private.pem -out pppan.csr 默认会在stdin中根据提示交互地输入主体信息,也可以通过-config选项来从文件中读取.生成完之后可以通过: openssl req -in pppan.csr -noout -text 来查看csr文件中的详细信息. 3.2 CA对csr文件进行签名当CA收到csr文件并且对请求方的域名,公司等内容校验无误后,便可以对csr请求进行确认(签名), openssl req -x509 -newkey rsa:4096 -nodes -keyout cakey.pem -out cacert.pem -outform PEM openssl ca -config openssl-ca.cnf -policy SP -extensions SR -infiles pppan.csr -out pppan.crt 虽然这不是重点, 但也稍微解释下这两个命令的意思吧. 第一个命令是CA一开始创建私钥和CA的证书,第二个命令表示对csr文件进行签名确认, 用-config指定自定义的配置文件, 如果不指定则默认为/usr/lib/ssl/openssl.cnf,SP和SR都是自定义于配置文件中的信息, 此外配置文件中还包括CA证书路径和私钥路径,以及对req的默认校验策略等,有兴趣的可以查看详细解释. 另外值得一提的是, 我们用自己的私钥也可以生成证书, 并且也能用这个证书来对自己的csr进行签名,这通常称为自签名(self-signed), 上面CA生成的证书cacert.pem就是自签名的. 一般来说,如果是自己随便生成自签名证书, 通常会被认为是不可信的, 除非手动添加到对方的信任CA证书列表中. 3.3查看和验证证书CA对csr进行签名后, 我们就能得到对应的证书, 这里是pppan.crt, 可以用openssl查看证书的详细信息: openssl x509 -noout -text -in pppan.crt 可以看到具体的签发机构,签发时间和证书的有效时间等信息.可以用命令验证证书是否有效: openssl verify -CAfile Trusts.pem pppan.crt 其中Trusts.pem是一系列所信任的证书集合,其中也包括了上述CA的证书cacert.pem 4. 其他上面所有用到的证书及其组件,如公钥,私钥,csr等,其格式都是PEM的,这也是最常见的一种格式,可以用文本便及其打开,通常是以—–BEGIN XXX——开头, 以—–END XXX—–结束,中间的部分则是实际密钥的base64编码, 其二进制表示也称为DER格式, 两者可以用base64转化,因此都属于x509实现的证书格式. 还有比较常见的证书格式,为PKCS7和PKCS12. 其中PKCS7是由JAVA使用的开放标准,并且也被Windows所支持, 其内是不包含私钥信息的; 而PKCS12则是一种非公开的标准,用来提供比PEM的纯文本格式更高的安全性, 这是Windows建议使用的格式, 其中可以包含私钥信息. 不同格式的转换如下所示. PEM DER: openssl x509 -in bar.pem -outform der -out bar.der openssl x509 -inform der -in foo.der -out foo.pem PEM PKCS7: openssl crl2pkcs7 -nocrl -certfile foocert.pem -out foocert.p7b openssl pkcs7 -in foocert.p7b -print_certs -out barcert.pem PEM PKCS12: openssl pkcs12 -inkey private.key -in foocert.pem -export -out foocert.pfx openssl pkcs12 -in foocert.pfx -nodes -out barcert.pem 5. 后记当今我们使用最多的https本质上就是在http协议的基础上对传输内容进行了非对称的加密,当然实现过程多了很多复杂的交互, 感兴趣的可以去查看SSL和TLS协议. 我想说的是,这一切信任机制的基石是对于CA的信任, 如果说CA的私钥泻露,或者我们错误地信任了一个坏CA,那么https的隐私性也就不复存在了, 因为其可能对无效的csr进行签名, 从而使得https中间人攻击成为现实. 据说早在两年前伟大的防火墙就已经可以对https进行监听,敏感词识别和连接重置,后来因为某种原因才从大范围应用转为只对特殊对象使用,不过那是后话了. 博客地址: http://pppan.net有价值炮灰-博客园欢迎交流,文章转载请注明出处. 常用Java加密算法总结 简单的java加密算法有： BASE64 严格地说，属于编码格式，而非加密算法 MD5(Message Digest algorithm 5，信息摘要算法) SHA(Secure Hash Algorithm，安全散列算法) HMAC(Hash Message Authentication Code，散列消息鉴别码) 1. BASE64Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。（来源百度百科） java实现代码： package com.cn.单向加密;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/BASE64的加密解密是双向的，可以求反解.BASE64Encoder和BASE64Decoder是非官方JDK实现类。虽然可以在JDK里能找到并使用，但是在API里查不到。JRE 中 sun 和 com.sun 开头包的类都是未被文档化的，他们属于 java, javax 类库的基础，其中的实现大多数与底层平台有关，一般来说是不推荐使用的。BASE64 严格地说，属于编码格式，而非加密算法主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。另，BASE加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。BASE64按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.）常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。 /public class BASE64 { /** * BASE64解密 * * @param key * @return * @throws Exception */ public static byte[] decryptBASE64(String key) throws Exception { return (new BASE64Decoder()).decodeBuffer(key); } /\\*\\* \\* BASE64加密 \\* \\* @param key \\* @return \\* @throws Exception */ public static String encryptBASE64(byte\\[\\] key) throws Exception { return (new BASE64Encoder()).encodeBuffer(key); } public static void main(String\\[\\] args) { String str=&quot;12345678&quot;; try { String result1= BASE64.encryptBASE64(str.getBytes()); System.out.println(&quot;result1=====加密数据==========&quot;+result1); byte result2\\[\\]= BASE64.decryptBASE64(result1); String str2=new String(result2); System.out.println(&quot;str2========解密数据========&quot;+str2); } catch (Exception e) { e.printStackTrace(); } } } 2. MD5MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值。好比现在的ISO校验，都是MD5校验。怎么用？当然是把ISO经过MD5后产生MD5的值。一般下载linux-ISO的朋友都见过下载链接旁边放着MD5的串。就是用来验证文件是否一致的。 java实现代码： package com.cn.单向加密;import java.math.BigInteger;import java.security.MessageDigest;/MD5(Message Digest algorithm 5，信息摘要算法)通常我们不直接使用上述MD5加密。通常将MD5产生的字节数组交给BASE64再加密一把，得到相应的字符串Digest:汇编 /public class MD5 { public static final String KEY_MD5 = “MD5”; public static String getResult(String inputStr) { System.out.println(&quot;=======加密前的数据:&quot;+inputStr); BigInteger bigInteger=null; try { MessageDigest md = MessageDigest.getInstance(KEY_MD5); byte\\[\\] inputData = inputStr.getBytes(); md.update(inputData); bigInteger = new BigInteger(md.digest()); } catch (Exception e) {e.printStackTrace();} System.out.println(&quot;MD5加密后:&quot; + bigInteger.toString(16)); return bigInteger.toString(16); } public static void main(String args\\[\\]) { try { String inputStr = &quot;简单加密8888888888888888888&quot;; getResult(inputStr); } catch (Exception e) { e.printStackTrace(); } } } MD5算法具有以下特点： 1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。2、容易计算：从原数据计算出MD5值很容易。3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等。 3.SHA安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种”指纹”或是”摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。 java实现代码： package com.cn.单向加密;import java.math.BigInteger;import java.security.MessageDigest;/SHA(Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了，但是SHA仍然是公认的安全加密算法，较之MD5更为安全/public class SHA { public static final String KEY_SHA = “SHA”; public static String getResult(String inputStr) { BigInteger sha =null; System.out.println(&quot;=======加密前的数据:&quot;+inputStr); byte\\[\\] inputData = inputStr.getBytes(); try { MessageDigest messageDigest = MessageDigest.getInstance(KEY_SHA); messageDigest.update(inputData); sha = new BigInteger(messageDigest.digest()); System.out.println(&quot;SHA加密后:&quot; + sha.toString(32)); } catch (Exception e) {e.printStackTrace();} return sha.toString(32); } public static void main(String args\\[\\]) { try { String inputStr = &quot;简单加密&quot;; getResult(inputStr); } catch (Exception e) { e.printStackTrace(); } } } SHA-1与MD5的比较因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：l 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2^128数量级的操作，而对SHA-1则是2^160数量级的操作。这样，SHA-1对强行攻击有更大的强度。l 对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。l 速度：在相同的硬件上，SHA-1的运行速度比MD5慢。 4.HMACHMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。 java实现代码： package com.cn.单向加密;/HMACHMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。/import javax.crypto.KeyGenerator;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import com.cn.comm.Tools;/** * 基础加密组件 */public abstract class HMAC { public static final String KEY_MAC = “HmacMD5”; /\\*\\* \\* 初始化HMAC密钥 \\* \\* @return \\* @throws Exception */ public static String initMacKey() throws Exception { KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC); SecretKey secretKey = keyGenerator.generateKey(); return BASE64.encryptBASE64(secretKey.getEncoded()); } /\\*\\* \\* HMAC加密 ：主要方法 \\* \\* @param data \\* @param key \\* @return \\* @throws Exception */ public static String encryptHMAC(byte\\[\\] data, String key) throws Exception { SecretKey secretKey = new SecretKeySpec(BASE64.decryptBASE64(key), KEY_MAC); Mac mac = Mac.getInstance(secretKey.getAlgorithm()); mac.init(secretKey); return new String(mac.doFinal(data)); } public static String getResult1(String inputStr) { String path=Tools.getClassPath(); String fileSource=path+&quot;/file/HMAC_key.txt&quot;; System.out.println(&quot;=======加密前的数据:&quot;+inputStr); String result=null; try { byte\\[\\] inputData = inputStr.getBytes(); String key = HMAC.initMacKey(); /*产生密钥*/ System.out.println(&quot;Mac密钥:===&quot; + key); /*将密钥写文件*/ Tools.WriteMyFile(fileSource,key); result= HMAC.encryptHMAC(inputData, key); System.out.println(&quot;HMAC加密后:===&quot; + result); } catch (Exception e) {e.printStackTrace();} return result.toString(); } public static String getResult2(String inputStr) { System.out.println(&quot;=======加密前的数据:&quot;+inputStr); String path=Tools.getClassPath(); String fileSource=path+&quot;/file/HMAC_key.txt&quot;; String key=null;; try { /*将密钥从文件中读取*/ key=Tools.ReadMyFile(fileSource); System.out.println(&quot;getResult2密钥:===&quot; + key); } catch (Exception e1) { e1.printStackTrace();} String result=null; try { byte\\[\\] inputData = inputStr.getBytes(); /*对数据进行加密*/ result= HMAC.encryptHMAC(inputData, key); System.out.println(&quot;HMAC加密后:===&quot; + result); } catch (Exception e) {e.printStackTrace();} return result.toString(); } public static void main(String args\\[\\]) { try { String inputStr = &quot;简单加密&quot;; /*使用同一密钥：对数据进行加密：查看两次加密的结果是否一样*/ getResult1(inputStr); getResult2(inputStr); } catch (Exception e) { e.printStackTrace(); } } }","tags":[]},{"title":" HTTPS\t\t","date":"2019-03-08T01:52:24.000Z","path":"2019/03/08/https/","text":"文章：https 工作原理、深入浅出HTTPS工作原理 HTTP 协议由于是明文传送，所以存在三大风险： ①、被窃听的风险：第三方可以截获并查看你的内容； ②、被篡改的危险：第三方可以截获并修改你的内容； ③、被冒充的风险：第三方可以伪装成通信方与你通信。 HTTPS 其实是由两部分组成：HTTP + SSL / TLS。 也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。 HTTPS 通信过程： 1、客户端发起 HTTPS 请求 用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口，请求携带了浏览器支持的加密算法和哈希算法。 2、服务端的配置 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。 自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面（startssl 是个不错的选择，有 1 年的免费服务）。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 服务器收到请求，选择浏览器支持的加密算法和哈希算法。 3、服务器传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构、过期时间等等。 4、客户端解析证书 这部分工作是由客户端的 TLS 来完成的。 首先客户端会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。客户端会先验证证书签名的合法性。签名通过后，客户端验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。 浏览器生成一个随机数 R，并使用网站公钥对 R 进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5、传送加密信息 这部分传送的是用证书加密后的随机值 R，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个 R 来进行加密解密了。 6、服务端解密信息 服务端用私钥解密后，得到了客户端传过来的 R，然后把内容通过该值进行对称加密。 所谓对称加密就是，将信息和随机值 R 通过某种算法混合在一起，这样除非知道随机值，不然无法获取内容，而正好客户端和服务端都知道这个随机值，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7、传输加密后的信息 服务器以 R为密钥使用了对称加密算法加密内容并传输给客户端，在客户端被还原。 8、客户端解密信息 客户端用之前生成的 R 为密钥来解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 备注 1： 前 4 步其实就是 HTTPS 的握手过程，这个过程主要是认证服务端证书（内置的公钥）的合法性。因为非对称加密计算量较大，整个通信过程只会用到一次非对称加密算法（主要是用来保护传输客户端生成的用于对称加密的随机数私钥）。后续内容的加解密都是通过一开始约定好的对称加密算法进行的。 备注 2： SSL/TLS 是 HTTPS 安全性的核心模块，TLS 的前身是 SSL，TLS1.0 就是 SSL3.1，TLS1.1 是 SSL3.2，TLS1.2 则是 SSL3.3。SSL/TLS 是建立在 TCP 协议之上，因而也是应用层级别的协议。其包括 TLS Record Protocol 和 TLS Handshaking Protocols 两个模块，后者负责握手过程中的身份认证，前者则保证数据传输过程中的完整性和私密性。 HTTPS 缺点： ①、SSL 证书费用很高，以及其在服务器上的部署、更新维护非常繁琐；②、HTTPS 降低用户访问速度（多次握手）；③、网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 302 跳转）；④、HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加大量机器（https 访问过程需要加解密）。 总结： 相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，建议大家多多推广HTTPS。","tags":[]},{"title":" malloc\t\t","date":"2019-03-07T03:01:49.000Z","path":"2019/03/07/malloc-2/","text":"文章：malloc 函数详解 使用 malloc 要加头文件，malloc 是分配一块连续的内存，和 free 函数是一起用的。但是一部分人还是将 malloc 当作系统所提供的或者是 C 的关键字，事实上 malloc 只是 C 标准库中提供的一个普通函数。 而且很多人都对 malloc 的具体实现机制不是很了解。 一、关于 malloc 以及相关的几个函数// Linux #include &lt;stdlib.h&gt; void malloc(size_t size);void free(void ptr);void calloc(size_t nmemb, size_t size);void \\realloc(void *ptr, size_t size); 也可以这样认为（window 下）原型：extern void *malloc(unsigned int num_bytes); 导入头文件 #include &lt;malloc.h&gt; 或者 #include &lt;alloc.h&gt; 两者的内容是完全一样的。 如果分配成功，则返回指向被分配内存空间的指针；不然，返回空指针 NULL。同时，当内存不再使用的时候，应使用 free() 函数将内存块释放掉。 关于：void 表示未确定类型的指针。C、C++ 规定，void 类型可以强转为任何其他类型的的指针。 malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small. 关于 void * 的其他说法： void p1;int p2; p1 = p2; // 其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。 malloc： ①、malloc 分配的内存大小至少为 size 参数所指定的字节数； ②、malloc 的返回值是一个指针，指向一段可用内存的起始地址； ③、多次调用 malloc 所分配的地址不能有重叠部分，除非某次 malloc 所分配的地址被释放掉 ④、malloc 应该尽快完成内存分配并返回（不能使用 NP-hard 的内存分配算法） ⑤、实现 malloc 时应同时实现内存大小调整和内存释放函数（realloc 和 free） malloc 和 free 函数是配对的，如果申请后不释放就是内存泄露；如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以释放多少次都是可以的。 二、malloc 和 newnew 返回指定类型的指针，并且可以自动计算所需要的大小。 int p;p = new int; // 返回类型为 int 类型，分配的大小为 sizeof(int)p = new int[100]; // 返回类型为 int 类型，分配的大小为 sizeof(int) 100 而 malloc 则必须由我们计算字节数，并且在返回的时候强转成实际指定类型的指针。 int *p = (int *)malloc(sizeof(int)); ①、malloc 的返回是 void ，如果写成了 p = malloc(sizeof(int)); 间接的说明了将 void 转成 int *，这不合理 ②、malloc 的实参是 sizeof(int)，用于指明一个整形数据需要的大小，如果我们写成： int p = (int )malloc(1); 可以看出，只是申请了一个字节的空间，如果向里面存放了一个整数的话，将会占用额外的 3 个字节，可能会改变原有内存空间中的数据。 ③、malloc 只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般习惯性的将其初始化为NULL。当然，也可以用 memset 函数的。 简单的说： malloc 函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看 malloc 函数中参数 size 的具体内容。我们这里 malloc 分配的内存空间在逻辑上是连续的，而在物理上可以不连续。程序员关注的是逻辑上的连续，其它的，操作系统会帮着我们处理的。 下面看看 malloc 的具体实现机制。 三、Linux 内存管理1、虚拟内存地址与物理内存地址 为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时， 都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片 2N 字节的内存，其中 N 是机器位数。例如在 64 位 CPU 和 64 位操作系统下，每个进程的虚拟地址空间为 264Byte。 这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。 由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫 MMU（Memory Management Unit）的硬件完成。 2、页与地址构成 在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到 Linux 中，典型的内存页大小为 4096Byte（4K）。 所以内存地址可以分为页号和页内偏移量。下面以 64 位机器，4G 物理内存，4K 页大小为例，虚拟内存地址和物理内存地址的组成如下： 上面是虚拟内存地址，下面是物理内存地址。由于页大小都是 4K，所以页内偏移都是用低 12 位表示，而剩下的高地址表示页号。 MMU 映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构页表来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如 TLB 等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。 3、内存页与磁盘页 一般将内存看做磁盘的的缓存，有时 MMU 在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对 malloc 实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。 最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（图片来源页）。 四、Linux 进程级内存管理1、内存排布 明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。 以 Linux 64 位系统为例。理论上，64bit 内存地址可用空间为 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux 实际上只用了其中一小部分（256T）。 根据 Linux 内核相关文档描述，Linux 64 位操作系统仅使用低 47 位，高 17 位做扩展（只能是全 0 或全 1）。所以，实际用到的地址为空间为 0x0000000000000000 ~ 0x00007FFFFFFFFFFF 和 0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下： 对用户来说，主要关注的空间是 User Space。将 User Space 放大后，可以看到里面主要分为如下几段： Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）； Data：这里存放的是初始化过的全局变量； BSS：这里存放的是未初始化的全局变量； Heap：堆。堆自低地址向高地址增长，后面要讲到的 brk 相关的系统调用就是从这里分配内存 Mapping Area：这里是与 mmap 系统调用相关的区域。大多数实际的 malloc 实现会考虑通过 mmap 分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长 Stack：栈。自高地址向低地址增长。 下面我们主要关注 Heap 区域的操作。 2、Heap 内存模型 一般来说，malloc 所申请的内存主要从 Heap 区域分配（本文不考虑通过 mmap 申请大块内存的情况）。 由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址后，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux 对堆的管理示意如下： Linux 维护一个 break 指针，这个指针指向堆空间的某个地址。从堆起始地址到 break 之间的地址空间为映射好的，可以供进程访问；而从 break 往上，是未映射的地址空间，如果访问这段空间则程序会报错。 3、brk 与 sbrk 由上文知道，要增加一个进程实际的可用堆大小，就需要将 break 指针向高地址移动。Linux 通过 brk 和 sbrk 系统调用操作 break 指针。两个系统调用的原型如下： int brk(void addr);void sbrk(intptr_t increment); brk 将 break 指针直接设置为某个地址，而 sbrk 将 break 从当前位置移动 increment 所指定的增量。brk 在执行成功时返回0，否则返回 -1 并设置 errno 为 ENOMEM；sbrk 成功时返回 break 移动之前所指向的地址，否则返回 (void *)-1。 小技巧：如果将 increment 设置为 0，则可以获得当前 break 的地址。 另外需要注意的是，由于 Linux 是按页进行内存映射的，所以如果 break 被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比 break 指向的地方要大一些。但是使用 break 之后的地址是很危险的（尽管也许 break 之后确实有 一小块可用内存地址）。 4、资源限制与 rlimit 系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个 rlimit 表示当前进程可用的资源上限。这个限制可以通过 getrlimit 系统调用得到，下面代码获取当前进程虚拟内存空间的 rlimit： int main() { struct rlimit limit = (struct rlimit )malloc(sizeof(struct rlimit)); getrlimit(RLIMIT_AS, limit); printf(&quot;soft limit: %ld, hard limit: %ld\\\\n&quot;, limit-&gt;rlim\\_cur, limit-&gt;rlim\\_max); } 其中 rlimit 是一个结构体： struct rlimit { rlim_t rlim_cur; / Soft limit / rlim_t rlim_max; / Hard limit (ceiling for rlim_cur) /}; 每种资源有软限制和硬限制，并且可以通过 setrlimit 对 rlimit 进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。 五、实现 malloc1、玩具实现 在正式开始讨论 malloc 的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具 malloc，权当对上面知识的复习： #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; void malloc(size_t size){ void p = sbrk(0); if (sbrk(size) == (void *)-1) return NULL; return p; } 这个 malloc 每次都在当前 break 的基础上增加 size 所指定的字节数，并将之前 break 的地址返回。这个 malloc 由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。 2、正式实现 下面讨论 malloc 的实现方案。 2.1 数据结构 首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由 meta 区和数据区组成，meta 区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为 malloc 返回的地址。 可以用如下结构体定义一个 block： typedef struct s_block *t_block; struct s_block { size_t size; / 数据区大小 / t_block next; / 指向下个块的指针 / int free; / 是否是空闲块 / int padding; / 填充4字节，保证meta块长度为8的倍数 / char data[1]; / 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入 meta /}; 由于只考虑 64 位机器，为了方便，在结构体最后填充一个 int，使得结构体本身的长度为 8 的倍数，以便内存对齐。示意图如下： 关于长度为 1 的数组注意：http://bbs.csdn.net/topics/300077699 2.2 寻找合适的 block 现在考虑如何在 block 链中查找合适的 block。一般来说有两种查找算法： First fit：从头开始，使用第一个数据区大小大于要求 size 的块所谓此次分配的块； Best fit：从头开始，遍历所有块，使用数据区大小大于 size 且差值最小的块作为此次分配的块。 两种方法各有千秋，best fit 具有较高的内存使用率（payload 较高），而 first fit 具有更好的运行效率。这里我们采用 first fit 算法。 /* First fit /t_block find_block(t_block last, size_t size) { t\\_block b = first\\_block; while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) { *last = b; b = b-&gt;next; } return b; } find_block 从 frist_block 开始，查找第一个符合要求的 block 并返回 block 起始地址，如果找不到这返回 NULL。这里在遍历时会更新一个叫 last 的指针，这个指针始终指向当前遍历的 block。这是为了如果找不到合适的 block 而开辟新 block 使用的，具体会在接下来的一节用到。 2.3 开辟新的 block 如果现有 block 都不能满足 size 的要求，则需要在链表最后开辟一个新的 block。这里关键是如何只使用 sbrk 创建一个 struct： #define BLOCK_SIZE 24 / 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 / t_block extend_heap(t_block last, size_t s) { t_block b; b = sbrk(0); if(sbrk(BLOCK_SIZE + s) == (void *)-1) return NULL; b-&gt;size = s; b-&gt;next = NULL; if(last) last-&gt;next = b; b-&gt;free = 0; return b; } 2.4 分裂 block First fit 有一个比较致命的缺点，就是可能会让很小的 size 占据很大的一块 block，此时，为了提高 payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的 block，示意如下： 实现代码： void split_block(t_block b, size_t s) { t_block new; new = b-&gt;data + s; new-&gt;size = b-&gt;size - s - BLOCK_SIZE ; new-&gt;next = b-&gt;next; new-&gt;free = 1; b-&gt;size = s; b-&gt;next = new; } 2.5 malloc 的实现 有了上面的代码，我们可以利用它们整合成一个简单但初步可用的 malloc。注意首先要定义个 block 链表的头 first_block，初始化为 NULL；另外，我们需要剩余空间至少有 BLOCK_SIZE + 8 才执行分裂操作。 由于我们希望 malloc 分配的数据区是按 8 字节对齐，所以在 size 不为 8 的倍数时，需要将 size 调整为大于 size 的最小的 8 的倍数： size_t align8(size_t s) { if(s &amp; 0x7 == 0) return s; return ((s &gt;&gt; 3) + 1) &lt;&lt; 3; } #define BLOCK_SIZE 24 void *first_block = NULL; /* other functions… */ void *malloc(size_t size) { t_block b, last; size_t s; /\\* 对齐地址 */ s = align8(size); if(first_block) { /\\* 查找合适的block */ last = first_block; b = find_block(&amp;last, s); if(b) { /\\* 如果可以，则分裂 */ if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8)) split_block(b, s); b-&gt;free = 0; } else { /\\* 没有合适的block，开辟一个新的 */ b = extend_heap(last, s); if(!b) return NULL; } } else { b = extend_heap(NULL, s); if(!b) return NULL; first_block = b; } return b-&gt;data; } 2.6 calloc 的实现 有了 malloc，实现 calloc 只要两步： ①、malloc 一段内存 ②、将数据区内容置为 0 由于我们的数据区是按 8 字节对齐的，所以为了提高效率，我们可以每 8 字节一组置 0，而不是一个一个字节设置。我们可以通过新建一个 size_t 指针，将内存区域强制看做 size_t 类型来实现。 void *calloc(size_t number, size_t size) { size_t *new; size_t s8, i; new = malloc(number * size); if(new) { s8 = align8(number * size) &gt;&gt; 3; for(i = 0; i &lt; s8; i++) new\\[i\\] = 0; } return new; } 2.7 free 的实现 free 的实现并不像看上去那么简单，这里我们要解决两个关键问题： ①、如何验证所传入的地址是有效地址，即确实是通过 malloc 方式分配的数据区首地址 ②、如何解决碎片问题 首先我们要保证传入 free 的地址是有效的，这个有效包括两方面： ①、地址应该在之前 malloc 所分配的区域内，即在 first_block 和当前 break 指针范围内 ②、这个地址确实是之前通过我们自己的 malloc 分配的 第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个 magic number 字段，free 之前通过相对偏移检查特定位置的值是否为我们设置的 magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时 free 时传入的地址），我们在 free 前检查 magic pointer是否指向参数所指地址。这里我们采用第二种方案： 首先我们在结构体中增加 magic pointer（同时要修改 BLOCK_SIZE）： typedef struct s_block *t_block; struct s_block { size_t size; / 数据区大小 / t_block next; / 指向下个块的指针 / int free; / 是否是空闲块 / int padding; / 填充 4 字节，保证 meta 块长度为 8 的倍数 / void *ptr; /* Magic pointer，指向 data / char data[1] / 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */}; 然后我们定义检查地址合法性的函数： t_block get_block(void *p) { char *tmp; tmp = p; return (p = tmp -= BLOCK_SIZE); } int valid_addr(void *p) { if(first_block) { if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) { return p == (get_block(p))-&gt;ptr; } } return 0; } 当多次 malloc 和 free 后，整个内存池可能会产生很多碎片 block，这些 block 很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此 malloc 要求，但是由于分割成了多个小 block 而无法 fit，这就是碎片问题。 一个简单的解决方式时当 free 某个 block 时，如果发现它相邻的 block 也是 free 的，则将 block 和相邻 block 合并。为了满足这个实现，需要将 s_block 改为双向链表。修改后的 block 结构如下： typedef struct s_block *t_block; struct s_block { size_t size; / 数据区大小 / t_block prev; / 指向上个块的指针 / t_block next; / 指向下个块的指针 / int free; / 是否是空闲块 / int padding; / 填充4字节，保证meta块长度为8的倍数 / void *ptr; /* Magic pointer，指向data / char data[1] / 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */}; 合并方法如下： t_block fusion(t_block b) { if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) { b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size; b-&gt;next = b-&gt;next-&gt;next; if(b-&gt;next) b-&gt;next-&gt;prev = b; } return b; } 有了上述方法，free 的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此 block 的 free 标为 1，并且在可以的情况下与后面的 block 进行合并。如果当前是最后一个 block，则回退 break 指针释放进程内存，如果当前 block 是最后一个 block，则回退 break 指针并设置 first_block 为 NULL。实现如下： void free(void *p) { t_block b; if(valid_addr(p)) { b = get_block(p); b-&gt;free = 1; if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free) b = fusion(b-&gt;prev); if(b-&gt;next) { fusion(b); } else { if(b-&gt;prev) b-&gt;prev-&gt;prev = NULL; else first_block = NULL; brk(b); } } } 2.8 realloc 的实现 为了实现 realloc，首先要实现一个内存复制方法。如同 calloc 一样，为了效率，我们以 8 字节为单位进行复制： void copy_block(t_block src, t_block dst) { size_t \\*sdata, \\*ddata; size_t i; sdata = src-&gt;ptr; ddata = dst-&gt;ptr; for(i = 0; (i * 8) &lt; src-&gt;size &amp;&amp; (i * 8) &lt; dst-&gt;size; i++) ddata\\[i\\] = sdata\\[i\\]; } 然后我们开始实现 realloc。一个简单（但是低效）的方法是 malloc 一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面： 如果当前 block 的数据区大于等于 realloc 所要求的 size，则不做任何操作 如果新的 size 变小了，考虑 split 如果当前 block 的数据区不能满足 size，但是其后继 block 是 free 的，并且合并后可以满足，则考虑做合并。 下面是 realloc 的实现： void *realloc(void *p, size_t size) { size_t s; t_block b, new; void *newp; if (!p) /\\* 根据标准库文档，当p传入NULL时，相当于调用malloc */ return malloc(size); if(valid_addr(p)) { s = align8(size); b = get_block(p); if(b-&gt;size &gt;= s) { if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8)) split_block(b,s); } else { /\\* 看是否可进行合并 */ if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) { fusion(b); if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8)) split_block(b, s); } else { /\\* 新malloc */ newp = malloc (s); if (!newp) return NULL; new = get_block(newp); copy_block(b, new); free(p); return(newp); } } return (p); } return NULL; } 六、遗留问题和优化以上是一个较为简陋，但是初步可用的 malloc 实现。还有很多遗留的可能优化点，例如： 同时兼容 32 位和 64 位系统 在分配较大快内存时，考虑使用 mmap 而非 sbrk，这通常更高效 可以考虑维护多个链表而非单个，每个链表中的 block 大小均为一个范围内，例如 8 字节链表、16 字节链表、24-32 字节链表等等。此时可以根据 size 到对应链表中做分配，可以有效减少碎片，并提高查询 block 的速度。 可以考虑链表中只存放 free 的 block，而不存放已分配的 block，可以减少查找 block 的次数，提高效率。 七、其它参考A malloc Tutorial Computer Systems: A Programmer’s Perspective, 2/E Anatomy of a Program in Memory How the Kernel Manages Your Memory glibc 的实现 维基百科","tags":[]},{"title":" TCP\t\t","date":"2019-03-06T15:41:47.000Z","path":"2019/03/06/tcp/","text":"文章：TCP三次握手四次回收图解、TCP的三次握手与四次挥手（详解+动图）、跟着动画学习TCP三次握手和四次挥手 一、背景描述网络模型中的 IP 层可以实现两个主机之间的通信。但是这并不具体，因为真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。IP 协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。 UDP 在传送数据前不需要先建立连接，远地的主机在收到 UDP 报文后也不需要给出任何确认。 UDP 虽然不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是 UDP。对应的应用层的协议主要有 DNS、TFTP、DHCP、SNMP、NFS 等。 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。 因此 TCP 是一种可靠的的运输服务，但不可避免的增加了许多的开销，比如确认、流量控制等。对应的应用层的协议主要有 SMTP、TELNET、HTTP、FTP 等。 端口号 二、TCP 的概述TCP 把连接作为最基本的对象，每一条 TCP 连接都有两个端点，这种端点叫作套接字（socket），它的定义为端口号拼接到 IP 地址即构成了套接字，若 IP 地址为 192.3.4.16 而端口号为 80，那么得到的套接字为 192.3.4.16:80。 TCP 报文首部 源端口和目的端口。各占 2 个字节，分别写入源端口和目的端口； 序号。占 4 个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301，而携带的数据共有 100 字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始； 确认号。占 4 个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B 收到了 A 发送过来的报文，其序列号字段是 501，而数据长度是 200 字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701； 数据偏移。占 4 位，它指出 TCP 报文的数据距离 TCP 报文段的起始处有多远； 保留。占 6 位，保留今后使用，但目前应都为 0； 紧急 URG。当 URG = 1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据； 确认 ACK。仅当 ACK = 1 时，确认号字段才有效。TCP 规定：在连接建立后所有报文的传输都必须把 ACK 置 1； 推送 PSH。当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 PSH = 1； 复位 RST。当 RST = 1，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接； 同步 SYN。在连接建立时用来同步序号。当 SYN = 1, ACK = 0，表明是连接请求报文，若同意连接，则响应报文中应该使 SYN = 1、ACK = 1； 终止 FIN，用来释放连接。当 FIN = 1，表明此报文的发送方的数据已经发送完毕，并且要求释放； 窗口。占 2 字节，指的是通知接收方，发送本报文你需要有多大的空间来接受； 检验和。占 2 字节，校验首部和数据这两部分； 紧急指针。占 2 字节，指出本报文段中的紧急数据的字节数； 选项。长度可变，定义一些其他的可选的参数。 三、TCP 连接状态下面是每一个 TCP 连接在任意时刻可能处于的状态，在 Linux 下可以在 netstat 命令的最后一列里看到。 各个状态的含义如下： CLOSED 初始状态。表示 TCP 连接是“关闭着的”或“未打开的”。 LISTEN 表示服务器端的某个 SOCKET 处于监听状态，可以接受客户端的连接。 SYN_RCVD 表示接收到了 SYN 报文。在正常情况下，这个状态是服务器端的 SOCKET 在建立 TCP 连接时的三次握手会话过程中的一个很短暂的中间状态，基本上用 netstat 很难看到这种状态，除非故意写一个监测程序，将三次 TCP 握手过程中最后一个 ACK报文不予发送。当 TCP 连接处于此状态时，再收到客户端的 ACK 报文，它就会进入到 ESTABLISHED 状态。 SYN_SENT 与 SYN_RCVD 状态相呼应，当客户端 SOCKET 执行 connect() 进行连接时，它首先发送 SYN 报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第 2 个报文。SYN_SENT 状态表示客户端已发送 SYN 报文。 ESTABLISHED 表示 TCP 连接已经成功建立。 FIN_WAIT_1 其实 FIN_WAIT_1 和 FIN_WAIT_2 两种状态的真正含义都是表示等待对方的 FIN 报文。 而这两种状态的区别是：FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态有时仍可以用 netstat看到。 FIN_WAIT_2 实际上 FIN_WAIT_2 状态下的 SOCKET 表示半连接，即有一方调用 close() 主动要求关闭连接。 注意：FIN_WAIT_2 是没有超时的（不像 TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成 4 次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的 FIN_WAIT_2 状态会导致内核 crash。 TIME_WAIT 表示收到了对方的 FIN 报文，并发送出了 ACK 报文。 TIME_WAIT 状态下的 TCP 连接会等待 2*MSL。每个具体的 TCP 协议实现都必须选择一个确定的 MSL 值，RFC 1122 建议是 2 分钟，但 BSD 传统实现采用了 30 秒，Linux 可以 cat /proc/sys/net/ipv4/tcp_fin_timeout 看到本机的这个值），然后即可回到 CLOSED 可用状态了。如果在 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。 Max Segment Lifetime：最大分段生存期，指一个 TCP 报文在 Internet 上的最长生存时间 CLOSING 这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送 FIN 报文后，按理来说是应该先收到（或同时收到）对方的 ACK 报文，再收到对方的 FIN 报文。但是 CLOSING 状态表示一方发送 FIN 报文后，并没有收到对方的 ACK 报文，反而却也收到了对方的 FIN 报文。什么情况下会出现此种情况呢？当双方几乎在同时 close() 一个 SOCKET，出现双方同时发送 FIN 报文的情况，这是就会出现 CLOSING 状态，表示双方都正在关闭 SOCKET 连接。 CLOSE_WAIT 表示自己正在等待关闭。当对方 close() 一个 SOCKET 后发送 FIN 报文给自己，你的系统毫无疑问地将会回应一个 ACK 报文给对方，此时 TCP 连接则进入到 CLOSE_WAIT 状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以 close() 这个 SOCKET 并发送 FIN 报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK 当被动关闭的一方在发送 FIN 报文后，等待对方的 ACK 报文的时候，就处于 LAST_ACK 状态。当收到对方的 ACK 报文后，也就可以进入到 CLOSED 可用状态了。 四、建立 TCP 连接（三次握手）TCP 协议采用有保障的三次握手方式来创建一个可靠的连接服务。 最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。 三次握手的具体过程如下： 客户端向服务器发送一个带 SYN 标志的 TCP 报文，其中包含连接的初始序列号 x 和一个窗口大小（表示客户端上用来存储从服务器发送来的传入段的缓冲区的大小）。 服务器收到客户端发送过来的 SYN 报文后，向客户端发送一个带 SYN 标志和 ACK 标志的 TCP 报文，其中包含它选择的初始序列号 y、对客户端的序列号的确认 x+1 和一个窗口大小（表示服务器上用来存储从客户端发送来的传入段的缓冲区的大小）。 客户端接收到服务器端返回的 SYN + ACK 报文后，向服务器端返回一个确认号 y+1 和序号 x+1 的 ACK 报文，一个标准的 TCP 连接完成。 TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态； TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同步位 SYN = 1，同时选择一个初始序列号 seq = x，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定：SYN 报文段（SYN = 1 的报文段）不能携带数据，但需要消耗掉一个序号。 TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK = 1、SYN = 1，确认号是 ack = x + 1，同时也要为自己初始化一个序列号 seq = y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。 TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK = 1、ack = y + 1，自己的序列号 seq = x + 1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。 当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。 为什么 TCP 客户端最后还要发送一次确认呢？ 主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。 如果使用两次握手建立连接，假设客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。 五、终止 TCP 连接（四次挥手）数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。原则是主动关闭的一方（如已传输完所有数据等原因）发送一个 FIN 报文来表示终止这个方向的连接，收到一个 FIN 意味着这个方向不再有数据流动，但另一个方向仍能继续发送数据，直到另一个方向也发送 FIN 报文。 四次挥手的具体过程如下： 客户端发送一个 FIN 报文给服务器，表示将关闭客户端到服务器端这个方向的连接，包含一个序列号 m。 服务器收到客户端发来的 FIN 报文后，发送一个 ACK 报文给客户端，对客户端的序列号的确认 m + 1。 服务器发送一个 FIN 报文给客户端，表示将关闭服务器端到客户端这个方向的连接，包含一个序列号 n。 客户端收到报文后，发回一个 ACK 报文给服务器，对服务端的序列号的确认 n + 1。 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN = 1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK = 1、ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1、ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1、ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。 服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。 至此，一个 TCP 连接就安全关闭了。 四、TCP 状态变迁图展示 TCP 连接的各种状态的变迁可能： TCP 三次握手，四次挥手的时序图。","tags":[]},{"title":" 图片压缩\t\t","date":"2019-03-06T10:58:02.000Z","path":"2019/03/06/e5-9b-be-e7-89-87-e5-8e-8b-e7-bc-a9/","text":"文章：iOS优秀的图片压缩处理方案（系统 UIImageJPEG 和 UIKit 以及 ImageI/O 处理） Demo 地址：https://github.com/KirstenDunst/CSXImageCompress 大图资源：https://pan.baidu.com/s/13eexiBPy_lyJxBLXIddnZw 一、UIImageJPEGRepresentation1、为什么用 UIImageJPEGRepresentation() 不用 UIImagePNGRepresentation()？ 因为是 png 格式读取的内容会有多图层的的问题导致读取的会显示比较大，而且比较耗时间。 { double begin = CACurrentMediaTime(); NSData * data1 = UIImagePNGRepresentation(image); double end = CACurrentMediaTime(); NSLog(@&quot;%8.2f %lu&quot;, (end - begin) * 1000, (unsigned long)\\[data1 length\\]); begin = CACurrentMediaTime(); NSData * data2 = UIImageJPEGRepresentation(image, 1.0); end = CACurrentMediaTime(); NSLog(@&quot;%8.2f %lu&quot;, (end - begin) * 1000, (unsigned long)\\[data2 length\\]); } Demo[10775:139506] 2.44 6831Demo[10775:139506] 0.71 15256 一张 29KB 的图片，UIImagePNGRepresentation() 返回的数据大小为 6.831KB，而 UIImageJPEGRepresentation( , 1.0) 返回的数据大小为 15.256KB，UIImageJPEGRepresentation( , 0.5) 的数据大小为 3.166KB。如果对图片的清晰度要求不高，还可以通过设置 UIImageJPEGRepresentation() 函数的第二个参数，大幅度降低图片数据量。 2、第二个参数 scale，一个 0～1 的浮点型比率，0 不是压缩到 0B 大小，1.0 不是原图大小。 图片的大小 = 图片的宽 * 图片的高 * 每一个色彩的深度。你的图片只会按照你的手机像素的分辨率 [UIScreen mainScreen].scale 来读取值。其次，第二个参数苹果官方并没有明确说明这个参数的具体意义。对于大图片来说，即使你的scale 设置很小，比如：0.0000000001，但是得到的结果还是很大，这里做了一个实验：一个 10M 左右的图片，处理后大小为2M 多，有点不能继续的感觉。当然如果是小图片的话那就是没问题，能满足你的希望的压缩到的大小。 二、压缩循环压缩算法，考虑到递归、二分法处理。更快一点压缩图片到指定的大小。先看一段代码： { // 二分最多 10 次，区间范围精度最大可达 0.00097657；最大 6 次，精度可达 0.015625 for (int i = 0; i &lt; 10; ++i) { compression = (max + min) / 2; imageData = UIImageJPEGRepresentation(image, compression); // 容错区间范围 0.9～1.0 if (imageData.length &lt; fImageBytes * 0.9) { min = compression; } else if (imageData.length &gt; fImageBytes) { max = compression; } else { break; } } } 上面就是使用二分法进行处理，比 for 循环依次递减“高效”很多，而且也合理很多。 无法继续压缩怎么办？ 这样压缩到极致（一般我们不用进行太多的 for 循环，个人觉得参数到 0.05 已经可以了），如果还是比你想要的大很多那就不要用 UIImageJPEGRepresentation 了。 然后可以换一个方式，进行尺寸压缩。提到尺寸压缩，会不会很失望，原来也是使用 UIGraphicsBeginImageContextWithOptions 然后 drawInRect 绘制一个图片。代码类似如下： /** * @brief 根据 size 返回一个新的 image */- (UIImage )drawWithWithImage:(UIImage )imageCope Size:(CGSize)size{ // 这里设置为 0，意为自动设置清晰度，图片可以是别的传过来的图片信息 UIGraphicsBeginImageContextWithOptions(size, NO, 0); [imageCope drawInRect:CGRectMake(0, 0, size.width, size.height)]; imageCope = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return imageCope; } 首先需要说一下这个绘制很耗内存性能的，[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的，并且还有位数对齐等耗时操作。 如果在一个方法中循环压缩比例进行代码的比例压缩，那么这种使用 UIKit 类进行图片绘制的话是需要先把图片读入内存然后再进行绘制，那么势必会给内存中占用大量的临时内存 bitmap，而这个如果再加上循环，那么内存占有将是不可估量的，你可能会加一个自动释放池 @autoreleasepool，错：首先这个自动释放池 @autoreleasepool 不要放在循环的外面，包着这个循环，原因就不过多说明，可以自行百度。然后放在 for 循环内部包着这个绘制的方法，你的内存并不是画完就得到了释放，内存占有的情况可以得到缓解，但是还是不能解决内存突然暴增的问题。尤其是大图片的压缩尤其明显。 然后你会想换一个方式，使用 Image I/O 相关的处理方式，使用相关的生成缩略图的形式压缩图片文件。直接上代码如下： static size_t getAssetBytesCallback(void *info, void *buffer, off_t position, size_t count){ ALAssetRepresentation rep = (__bridge id)info; NSError error = nil; size_t countRead = [rep getBytes:(uint8_t *)buffer fromOffset:position length:count error:&amp;error]; if (countRead == 0 &amp;&amp; error) { // We have no way of passing this info back to the caller, so we log it, at least. NSLog(@&quot;thumbnailForAsset:maxPixelSize: got an error reading an asset: %@&quot;, error); } return countRead; } static void releaseAssetCallback(void * info){ // The info here is an ALAssetRepresentation which we CFRetain in thumbnailForAsset:maxPixelSize:. // This release balances that retain. CFRelease(info);} - (UIImage )thumbnailForAsset:(ALAsset )asset maxPixelSize:(NSUInteger)size{ NSParameterAssert(asset != nil); NSParameterAssert(size &gt; 0); ALAssetRepresentation * rep = \\[asset defaultRepresentation\\]; CGDataProviderDirectCallbacks callbacks = { .version = 0, .getBytePointer = NULL, .releaseBytePointer = NULL, .getBytesAtPosition = getAssetBytesCallback, .releaseInfo = releaseAssetCallback, }; CGDataProviderRef provider = CGDataProviderCreateDirect((void *)CFBridgingRetain(rep), \\[rep size\\], &amp;callbacks); CGImageSourceRef source = CGImageSourceCreateWithDataProvider(provider, NULL); CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(source, 0, (__bridge CFDictionaryRef) @{ (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @YES,(NSString *)kCGImageSourceThumbnailMaxPixelSize : @(size), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @YES, }); CFRelease(source); CFRelease(provider); if (!imageRef) { return nil; } UIImage * toReturn = \\[UIImage imageWithCGImage:imageRef\\]; CFRelease(imageRef); return toReturn; } 可以结合从数据库获取的 info 返回使用。这里代码如下： #pragma mark - UIImagePickerControllerDelegate - (void)imagePickerController:(UIImagePickerController )picker didFinishPickingMediaWithInfo:(NSDictionary )info{ NSLog(@”info:\\n%@”, info); UIImage * image = info\\[UIImagePickerControllerOriginalImage\\]; __block NSData * imgData = UIImageJPEGRepresentation(image, 1.0); NSLog(@&quot;length1: %lu&quot;, (unsigned long)imgData.length); NSURL * imageURL = info\\[UIImagePickerControllerReferenceURL\\]; ALAssetsLibrary * assetsLibrary = \\[\\[ALAssetsLibrary alloc\\] init\\]; \\[assetsLibrary assetForURL:imageURL resultBlock:^(ALAsset *asset) { image = \\[self thumbnailForAsset:asset maxPixelSize:600\\]; imgData = UIImageJPEGRepresentation(image, 1.0); NSLog(@&quot;length2: %lu&quot;, (unsigned long)imgData.length); NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *filePath = \\[\\[paths objectAtIndex:0\\] stringByAppendingPathComponent:@&quot;new/ceshi.jpg&quot;\\]; // 保存文件的名称 BOOL result = \\[imgData writeToFile: filePath atomically:YES\\]; // 保存成功会返回YES NSLog(@&quot;文件保存成功？%d&quot;,result); } failureBlock:nil\\]; \\[picker dismissViewControllerAnimated:YES completion:^{}\\]; } 使用 ImageIO 接口，避免在改变图片大小的过程中产生临时的 bitmap，就能够在很大程度上减少内存的占有从而避免由此导致的 app 闪退问题。 在这之前我也直接有过另外一种方式压缩图片（直接靠图片尺寸压缩绘制图片）： + (void)compressedImageFiles:(UIImage )image imageKB:(CGFloat)fImageKBytes imageBlock:(ReturnCompressImage)block{ __block UIImage imageCope = image; CGFloat fImageBytes = fImageKBytes 1024; // 需要压缩的字节Byte __block NSData uploadImageData = nil; // uploadImageData = UIImagePNGRepresentation(imageCope); uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0);// NSLog(@”图片压前缩成 %fKB”,uploadImageData.length/1024.0);// CGFloat value1 = uploadImageData.length/1024.0; CGSize size = imageCope.size; CGFloat imageWidth = size.width; CGFloat imageHeight = size.height; if (uploadImageData.length &gt; fImageBytes &amp;&amp; fImageBytes &gt;0) { dispatch\\_async(dispatch\\_queue\\_create(&quot;CompressedImage&quot;, DISPATCH\\_QUEUE_SERIAL), ^{ /\\* 宽高的比例 **/ CGFloat ratioOfWH = imageWidth/imageHeight; /\\* 压缩率 **/ CGFloat compressionRatio = fImageBytes/uploadImageData.length; /\\* 宽度或者高度的压缩率 **/ CGFloat widthOrHeightCompressionRatio = sqrt(compressionRatio); CGFloat dWidth = imageWidth *widthOrHeightCompressionRatio; CGFloat dHeight = imageHeight*widthOrHeightCompressionRatio; if (ratioOfWH &gt;0) { /* 宽 &gt; 高,说明宽度的压缩相对来说更大些 **/ dHeight = dWidth/ratioOfWH; } else { dWidth = dHeight*ratioOfWH; } imageCope = \\[self drawWithWithImage:imageCope width:dWidth height:dHeight\\]; // uploadImageData = UIImagePNGRepresentation(imageCope); uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0); // NSLog(@”当前的图片已经压缩成 %fKB”,uploadImageData.length/1024.0); //微调 NSInteger compressCount = 0; /* 控制在 1M 以内/ while (fabs(uploadImageData.length - fImageBytes) &gt; 1024) { /* 再次压缩的比例/ CGFloat nextCompressionRatio = 0.9; if (uploadImageData.length &gt; fImageBytes) { dWidth = dWidth*nextCompressionRatio; dHeight= dHeight*nextCompressionRatio; }else { dWidth = dWidth/nextCompressionRatio; dHeight= dHeight/nextCompressionRatio; } imageCope = \\[self drawWithWithImage:imageCope width:dWidth height:dHeight\\]; // uploadImageData = UIImagePNGRepresentation(imageCope); uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0); /*防止进入死循环**/ compressCount ++; if (compressCount == 10) { break; } } // NSLog(@”图片已经压缩成 %fKB”,uploadImageData.length/1024.0);// CGFloat value2 = uploadImageData.length/1024.0; imageCope = \\[\\[UIImage alloc\\] initWithData:uploadImageData\\]; dispatch\\_sync(dispatch\\_get\\_main\\_queue(), ^{ if (block) { block(imageCope); } }); }); } else { if (block) { block(imageCope); } } } /* 根据 dWidth dHeight 返回一个新的 image /+ (UIImage )drawWithWithImage:(UIImage *)imageCope width:(CGFloat)dWidth height:(CGFloat)dHeight{ UIGraphicsBeginImageContext(CGSizeMake(dWidth, dHeight)); [imageCope drawInRect:CGRectMake(0, 0, dWidth, dHeight)]; imageCope = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return imageCope; } 这种方式极耗手机的 cpu，而且绘制也是使用 UIKit 进行绘制，内存占用也是比较严重的。 综合上面的所有情况现在我的最终处理方案如下： ①、首先使用 UIImageJPEGRepresentation 进行尽可能的压缩，这里使用二分法（考虑到手机性能问题，这里二分法设置 10 次以内即可，能精确到 0.00097657）处理压缩的比率参数，尽可能压缩一下原图片信息，比对一下最小的二分法能处理的最大限度得到的最小图片信息能否满足条件（在你设定的目标大小以内）。以减少不必要的循环，保护 cpu 处理 ②、然后对处理后的图片信息，保留最大压缩比（即上面的最小二分法的 scale 结果），然后再进行和最终目标的大小比值，求根，然后对图像的宽和高等比压缩处理。然后再次根据最小二分法的 scale 以 UIImageJPEGRepresentation 读取结果再和你的目标大小比对，然后以此循环。直到小于目标大小。 这样得到的图片几乎就能够在你设定的大小以内的附近，而且图片的信息肉眼几乎看不出来多大的区别，而且压缩出来的图片清晰度很高。 代码如下： - (void)compressedImageFiles:(UIImage )image imageKB:(CGFloat)fImageKBytes imageBlock:(void(^)(NSData imageData))block{ //二分法压缩图片 CGFloat compression = 1; NSData imageData = UIImageJPEGRepresentation(image, compression); NSUInteger fImageBytes = fImageKBytes 1000; //需要压缩的字节Byte，iOS系统内部的进制1000 if (imageData.length &lt;= fImageBytes){ block(imageData); return; } CGFloat max = 1; CGFloat min = 0; //指数二分处理，s首先计算最小值 compression = pow(2, -6); imageData = UIImageJPEGRepresentation(image, compression); if (imageData.length &lt; fImageBytes) { //二分最大10次，区间范围精度最大可达0.00097657；最大6次，精度可达0.015625 for (int i = 0; i &lt; 6; ++i) { compression = (max + min) / 2; imageData = UIImageJPEGRepresentation(image, compression); //容错区间范围0.9～1.0 if (imageData.length &lt; fImageBytes * 0.9) { min = compression; } else if (imageData.length &gt; fImageBytes) { max = compression; } else { break; } } block(imageData); return; } // 对于图片太大上面的压缩比即使很小压缩出来的图片也是很大，不满足使用。 // 然后再一步绘制压缩处理 UIImage * resultImage = \\[UIImage imageWithData:imageData\\]; while (imageData.length &gt; fImageBytes) { @autoreleasepool { CGFloat ratio = (CGFloat)fImageBytes / imageData.length; // 使用 NSUInteger 不然由于精度问题，某些图片会有白边 NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&quot;,resultImage.size.width, sqrtf(ratio), resultImage.size.height); CGSize size = CGSizeMake((NSUInteger)(resultImage.size.width * sqrtf(ratio)), (NSUInteger)(resultImage.size.height * sqrtf(ratio))); // resultImage = [self drawWithWithImage:resultImage Size:size];// resultImage = [self scaledImageWithData:imageData withSize:size scale:resultImage.scale orientation:UIImageOrientationUp]; resultImage = [self thumbnailForData:imageData maxPixelSize:MAX(size.width, size.height)]; imageData = UIImageJPEGRepresentation(resultImage, compression); } } // 整理后的图片尽量不要用 UIImageJPEGRepresentation 方法转换，后面参数 1.0 并不表示的是原质量转换。 block(imageData); }- (UIImage )thumbnailForData:(NSData )data maxPixelSize:(NSUInteger)size{ CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data); CGImageSourceRef source = CGImageSourceCreateWithDataProvider(provider, NULL); CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(source, 0, (__bridge CFDictionaryRef) @{ (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @YES, (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(size), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @YES, }); CFRelease(source); CFRelease(provider); if (!imageRef) { return nil; } UIImage * toReturn = \\[UIImage imageWithCGImage:imageRef\\]; CFRelease(imageRef); return toReturn; }","tags":[]},{"title":" CGImageSource\t\t","date":"2019-03-06T09:16:46.000Z","path":"2019/03/06/cgimagesource/","text":"#import &lt;ImageIO/ImageIO.h&gt; 1、创建 CGImageSourceRef // ①CGImageSourceRef imageSourceRef = CGImageSourceCreateWithURL((__bridge CFURLRef)[NSURL fileURLWithPath:imagePath], NULL); // ②CGDataProviderRef dataProviderRef = CGImageGetDataProvider(image.CGImage)CGImageSourceRef imageSourceRef = CGImageSourceCreateWithDataProvider(dataProviderRef, NULL); // ③CFDataRef dataRef = CGDataProviderCopyData(dataProviderRef);CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData(dataRef, NULL); 2、获取图像 CGImageRef imageRef = CGImageSourceCreateImageAtIndex(imageSourceRef, 0, NULL); 3、创建图像的缩略图 CGFloat maxPixelSize = MAX(size.width, size.height); // 缩略图的信息字典CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (bridge id)kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; // 生成缩略图CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSourceRef, 0, options); 4、获取图像的属性信息 CFDictionaryRef imageInfo = CGImageSourceCopyPropertiesAtIndex(imageSourceRef, 0,NULL); // 像素的宽NSNumber pixelWidthObj = (__bridge NSNumber )CFDictionaryGetValue(imageInfo, kCGImagePropertyPixelWidth); // 像素的高NSNumber pixelHeightObj = (__bridge NSNumber )CFDictionaryGetValue(imageInfo, kCGImagePropertyPixelHeight); // 图像的旋转方向NSInteger orientation = [(__bridge NSNumber *)CFDictionaryGetValue(imageInfo, kCGImagePropertyOrientation) integerValue]; // 时间间隔NSNumber * number = CFDictionaryGetValue(gifProperties, kCGImagePropertyGIFUnclampedDelayTime); // Exif 信息NSDictionary exifInfo = (__bridge NSDictionary )CFDictionaryGetValue(imageInfo, kCGImagePropertyExifAuxDictionary); 5、GIF 图片动画 原理：GIF 图片包含了图片张数，以及每张图片的信息，如延迟时间（ms），因此只要获取到每张 gif 子图，然后动画时间求和，[UIImage animatedImageWithImages:xx duration:xx]; 这里有一个问题，因为这样 gif 里的每张图片动画时长会平均到 gif 动画时间里，实际上每张图的动画时间是不同的。假设一张 GIF 有三张图，每张图为分别为：0.2、0.3、0.5；但是如果直接调用，动画时间就变成：0.33、0.33、0.33，并不符合预期； 解决方式： 根据 gif 格式，每张图片时间间隔为 N*0.01s（N &gt; 0 的正整数），如果未获取到值，默认 N 为 1，在上面的 0.2s、0.3s，0.5s，N 分别为：20、30、50，取出他们的最大公约数，为 10，这时候，图片分别为 20/10、30/10、50/10张，放入数组中，此时有 10 张图，总动画时间依然为 1s，但是每张图的动画分别为都为 0.1，但是因为只有三种图，看起来的效果就像 0.2s 图片一，0.3s 图片二，0.5s 图片三，也就达到了我们想要的目的了。 #if __has_feature(objc_arc) #define toCF (__bridge CFTypeRef) #define fromCF (__bridge id) #else #define toCF (CFTypeRef) #define fromCF (id) #endif // 伪代码size_t const count = CGImageSourceGetCount(source);CGImageRef images[count]; for (size_t i = 0; i &lt; count; ++i) { imagesOut[i] = CGImageSourceCreateImageAtIndex(source, i, NULL); delayCentisecondsOut[i] = 获取间隔秒数，看上面，这里获取的是 N;} int duration = delayCentisecondsOut求和;int frameCount = duration/最小公约数; NSArray const frames = 重复每个图片的个数，然后累计放到一个数组;UIImage const animation = [UIImage animatedImageWithImages:frames duration:(NSTimeInterval)totalDurationCentiseconds / 100.0]; 注意：CFxxCreate 的图片和字典对象，都是需要手动释放的。 求最大公约数代码： static int vectorGCD(size_t const count, int const *const values){ int gcd = values[0]; for (size_t i = 1; i &lt; count; ++i) { gcd = pairGCD(values\\[i\\], gcd); } return gcd; } static int pairGCD(int a, int b) { if (a &lt; b) return pairGCD(b, a); while (true) { int const r = a % b; if (r == 0) return b; a = b; b = r; } } 6、边下载边显示 原理：任何文件都是按照一定格式的，一般文件格式都在文件的 header 中，imageIO 库就是根据先行下载的图片头，构建一个空白图片（其实工作量很多，包括各种图片类型、数据等解码，然后空白图和已有数据编码成一个图片），然后新来的多少数据边覆盖空白部分，直到最后完成。 创建：CGImageSourceRef imageSource = CGImageSourceCreateIncremental(NULL); 更新：CGImageSourceUpdateData(&lt;#CGImageSourceRef isrc#&gt;, &lt;#CFDataRef data#&gt;, &lt;#bool final#&gt;); 生成：CGImageSourceCreateImageAtIndex(&lt;#CGImageSourceRef isrc#&gt;, &lt;#size_t index#&gt;, &lt;#CFDictionaryRef options#&gt;); 返回：return [UIImage imageWithCGImage:imageRef]; 文章CGImageSource的用法","tags":[]},{"title":" Image I/O 解码探究\t\t","date":"2019-03-06T05:44:16.000Z","path":"2019/03/06/image-i-o/","text":"原文：图片 ImageI/O 解码探究 一、Image I/O在使用 CGImageSourceCreateImageAtIndex() 和 CGImageSourceCreateThumbnailAtIndex() 方法创建 UIImage 对象时，引发了关于 ImageI/O 的使用以及解码过程的思考。 当用 UIImage 或 CGImageSource 的几个相关方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。 通过下面的方法模拟图片被解码并渲染的过程： - (void)drawImage:(UIImage *)image{ size_t width = CGImageGetWidth(image.CGImage); size_t height = CGImageGetHeight(image.CGImage); CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpaceRef, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst); if(!context) return; // 绘制图片。解码阶段 CGContextDrawImage(context, CGRectMake(0, 0, width, height), image.CGImage); // 获取图片 CGImageRef newImageRef = CGBitmapContextCreateImage(context); // 释放内存 CGColorSpaceRelease(colorSpaceRef); CFRelease(context); CGImageRelease(newImageRef); } 用 TimeProfiler 一步一步来看过程中内部调用的函数可以帮助我们解决问题，由于 TimeProfiler 统计函数栈为间隔一段时间统计一次，导致没有记录下所有函数的调用而且每次函数栈还可能不一致，所以没法精确判断函数栈是如何调用的，但是可以大概推测出每步做了什么。 看下正常情况下图片解码时系统都是如何做的。首先是 PNG 格式的图片： CGContextDrawImageWithOptions 方法中，调用了 PNGPlugin 库中的一系列方法，没有明显看到带有 decode 关键字的方法，猜测 png_read_IDAT_dataApple 就是执行的解码过程。 接着是 JPEG 格式的图片： CGContextDrawImageWithOptions 方法中调用了 AppleJPEGPlugin 库中的一系列方法，可以看到带有 decode 关键字的方法 FigPhotoJPEGDecodeJPEGIntoRGBSurface，这个应该就是执行解码的过程。 以上的实验大致推断出 PNG 和 JPEG 格式的图片执行解码的关键方法，接下来正式进入本文章的探究主题。 下面使用 ImageI/O 通过获取缩略图的方法，将图片进行裁剪操作，生成所需要的 UIImage 对象。 - (UIImage )resizeWithData:(NSData )data scaleSize:(CGSize)size{ if(!data) { return nil; } // 获取 source 对象 CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL); if(!imageSourceRef) { return nil; } CGFloat maxPixelSize = MAX(size.width, size.height); CFDictionaryRef options = (__bridge CFDictionaryRef) @{ (\\_\\_bridge id)kCGImageSourceShouldCacheImmediately : (\\_\\_bridge id)kCFBooleanFalse, (\\_\\_bridge id)kCGImageSourceShouldCache : (\\_\\_bridge id)kCFBooleanFalse, (\\_\\_bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (\\_\\_bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceThumbnailMaxPixelSize : \\[NSNumber numberWithFloat:maxPixelSize\\] }; // 获取缩略图 CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSourceRef, 0, options); UIImage * thumbnailImage = \\[UIImage imageWithCGImage:imageRef\\]; // 释放内存 CFRelease(imageSourceRef); CGImageRelease(imageRef); return thumbnailImage; } options 的几个参数需要解释一下，依次如下： 1、kCGImageSourceShouldCacheImmediately。文档解释： /* Specifies whether image decoding and caching should happen at image creation time. * The value of this key must be a CFBooleanRef. The default value is kCFBooleanFalse (image decoding will * happen at rendering time). */ 是否应该在图像创建过程时进行图像解码和缓存。 值必须是 CFBooleanRef。 默认值为 kCFBooleanFalse（图像解码将在渲染时发生）。 2、kCGImageSourceShouldCache。文档解释： /** Keys for the options dictionary of “CGImageSourceCopyPropertiesAtIndex” ** and “CGImageSourceCreateImageAtIndex”. *//\\ Specifies whether the image should be cached in a decoded form. The * value of this key must be a CFBooleanRef. * kCFBooleanFalse indicates no caching, kCFBooleanTrue indicates caching. * For 64-bit architectures, the default is kCFBooleanTrue, for 32-bit the default is kCFBooleanFalse. */ 在方法 CGImageSourceCopyPropertiesAtIndex 和 CGImageSourceCreateImageAtIndex 中使用指定是否应以解码形式缓存图像。 此键的值必须是 CFBooleanRef。 kCFBooleanFalse 表示没有缓存，kCFBooleanTrue 表示缓存。 对于 64 位体系结构，默认值为 kCFBooleanTrue，对于 32 位，默认值为 kCFBooleanFalse。 注意：此 key 指定的是解码后的数据是否需要缓存。此处我们设置为 kCFBooleanFalse，不进行缓存。 3、kCGImageSourceCreateThumbnailFromImageAlways。文档解释： /* Specifies whether a thumbnail should be created from the full image even * if a thumbnail is present in the image source file. The thumbnail will * be created from the full image, subject to the limit specified by * kCGImageSourceThumbnailMaxPixelSize—if a maximum pixel size isn’t * specified, then the thumbnail will be the size of the full image, which * probably isn’t what you want. The value of this key must be a * CFBooleanRef; the default value of this key is kCFBooleanFalse. */ 指定是否应从完整图像创建缩略图，即使图像源文件中存在缩略图。 缩略图将根据完整图像创建，受 kCGImageSourceThumbnailMaxPixelSize 指定的限制，如果未指定最大像素大小，则缩略图将是完整图像的大小。 该键的值必须是 CFBooleanRef，默认值为 kCFBooleanFalse。 4、kCGImageSourceThumbnailMaxPixelSize。文档解释： /* Specifies the maximum width and height in pixels of a thumbnail. If * this this key is not specified, the width and height of a thumbnail is * not limited and thumbnails may be as big as the image itself. If * present, this value of this key must be a CFNumberRef. */ 指定缩略图的最大宽度和高度（以像素为单位）。 如果未指定此键，则缩略图的宽度和高度不受限制，缩略图可能与图像本身一样大；否则值必须为 CFNumberRef。 接下来看看 CGImageSourceCreateThumbnailAtIndex() 系统具体做了什么。 二、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanTrue为了测试图片的解码过程，令 kCGImageSourceShouldCacheImmediately 的值设置为 kCFBooleanTrue，也就是创建图片过程中进行解码。 1、PNG 格式的图片 根据 Time Profiler 查看下系统在这个函数里面做了什么，调用结果如下： 看到 - (UIImage)resizeWithData:(NSData)data scaleSize:(CGSize)size 方法执行了 48.00ms，其中CGImageSourceCreateThumbnailAtIndex() 执行了大约 45.00ms，大部分耗时都在这里。 继续看下里面究竟做了什么。过程中系统调用了 CGContextDrawImageWithOptions。因为我们前面设置了kCGImageSourceShouldCacheImmediately 对应的值修改为 kCFBooleanTrue，也就是需要解码，所以这里系统调用了CGContextDrawImageWithOptions 方法，会将图片渲染到画布，这个过程是会解码的。再接着往下看，具体解码的步骤在哪里。可以看到接下来最耗时的操作分别在 img_interpolate_extent 和 img_interpolate_read 两个函数。然后分别看看这两个函数做了什么。 系统调用了 CGImageProviderCopyImageBlockSet，里面调用了 PNGPlugin 库的 _cg_png_read_row 和 _cg_png_read_info 方法，_cg_png_read_row 方法调用了 png_read_IDAT_dataApple，这个方法上面已经提到了，是进行的解码操作。 img_interpolate_read 里面调用了 img_decide_read，猜测应该是读取解码完成的数据。PNG 格式的图片如何解码大致推理出来了。 2、JPEG 格式的图片 JPEG 图片的 -(UIImage)resizeWithData:(NSData)data scaleSize:(CGSize)size 方法执行了 55.00ms，其中CGImageSourceCreateThumbnailAtIndex() 执行了大约 53.00ms，这里系统同样调用了 CGContextDrawImageWithOptions方法，与 PNG 不同的是，JPEG 里面调用了 img_decode_stage 和 img_interpolate_read 方法。 可以看到 img_decode_stage 方法里面同样调用了 CGImageProviderCopyImageBlockSet 方法，然后调用了AppleJPEGPlugin 库的 FigPhotoJPEGDecodeJPEGIntoRGBSurface 方法，这里进行了解码。 img_interpolate_read 里面调用了 img_decode_read，与 PNG 图片的一模一样，应该也是对解码完成的数据进行读取。 以上就是解码过程的剖析，那么作为对比试验，我们接下来看下不经过解码时的调用过程。 三、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanFalse将 kCGImageSourceShouldCacheImmediately 对应的值修改为 kCFBooleanFalse，也就是创建图片过程中不进行解码。 1、PNG 格式的图片 居然跟之前强制解码的一模一样，也是 img_interpolate_extent、img_interpolate_read。 真的是也会解码！这究竟是为什么呢？难道是 options 的问题？ CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (bridge id)kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; 尝试使用不同的 options，有了下面的结果： ①、不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse。 CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue // (bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; 依次为 PNG、JPEG 的结果： 结论：如果不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse，那么不管是 PNG 还是 JPEG 格式的图片，都没有进行解码操作。 ②、不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue。 CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue // (bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; 依次为 PNG、JPEG 的结果： 结论：如果不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue，那么不管是 PNG 还是 JPEG 格式的图片，都进行了解码操作。 ③、设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为kCFBooleanFalse。 CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; 依次 PNG、JPEG 结果： 结论：如果设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse，PNG 和 JPEG 格式的图片，都进行了解码操作。 ④、设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为kCFBooleanTure。 CFDictionaryRef options = (bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] }; 依次 PNG、JPEG 结果： 结论：如果设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue，那么不管是 PNG 还是 JPEG 格式的图片，也都进行了解码操作。 ⑤、总结 在使用 CGImageSourceCreateThumbnailAtIndex 方法时 a. 设置了 kCGImageSourceThumbnailMaxPixelSize，那么肯定会进行解码操作，生成对应的新图 CGImageRef。 b. 不设置 kCGImageSourceThumbnailMaxPixelSize，那么是否进行解码操作，取决于kCGImageSourceShouldCacheImmediately 对应的值是 kCFBooleanTure 还是 kCFBooleanFalse。 四、CGImageSourceCreateImageAtIndex()ImageI/O 中使用 CGImageSourceCreateThumbnailAtIndex 创建缩略图方法的结论就是如上所述。那么这里又有另一个思考，如果是 CGImageSourceCreateImageAtIndex 方法，那么上述的 kCGImageSourceShouldCacheImmediately 键值对会造成什么影响呢？ - (UIImage )resizeWithData:(NSData )data scaleSize:(CGSize)size{ if(!data) { return nil; } // 获取 source 对象 CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL); if(!imageSourceRef) { return nil; } CGFloat maxPixelSize = MAX(size.width, size.height); CFDictionaryRef options = (__bridge CFDictionaryRef) @{ (\\_\\_bridge id)kCGImageSourceShouldCacheImmediately : (\\_\\_bridge id)kCFBooleanFalse, (\\_\\_bridge id)kCGImageSourceShouldCache : (\\_\\_bridge id)kCFBooleanFalse}; CGImageRef imageRef = CGImageSourceCreateImageAtIndex(imageSourceRef, 0, options); UIImage * thumbnailImage = \\[UIImage imageWithCGImage:imageRef\\]; // 释放内存 CFRelease(imageSourceRef); CGImageRelease(imageRef); return thumbnailImage; } ①、设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanFalse。 CFDictionaryRef options = (__bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse }; 结果： CGImageSourceCreateImageAtIndex() 不解码 _PNG。 CGImageSourceCreateImageAtIndex() 不解码 _JPEG。 结论：设置 kCGImageSourceShouldCacheImmediately为 kCFBooleanFalse 时，PNG 和 JPEG 都没有进行解码。 ②、设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanTrue。 CFDictionaryRef options = (__bridge CFDictionaryRef) @{ (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse }; 结果： CGImageSourceCreateImageAtIndex() 解码 _PNG。 CGImageSourceCreateImageAtIndex() 解码 _JPEG。 结论：设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanTrue 时，PNG 和 JPEG 都进行了解码。 ③总结 在使用 CGImageSourceCreateImageAtIndex 方法创建 CGImageRef 时，kCGImageSourceShouldCacheImmediately 值会影响是否开启解码操作。ImageI/O 默认的 kCGImageSourceShouldCacheImmediately 为 kCFBooleanFalse，也就是说创建图片时候不解码，会等到图片被渲染的时候才进行解码。 以上部分就明确了 CGImageSourceCreateImageAtIndex() 和 CGImageSourceCreateThumbnailAtIndex() 时系统底层具体的实现。 当然，在使用这个 -(UIImage )resizeWithData:(NSData )data scaleSize:(CGSize)size 方法时也采坑了。因为大部分情况下（参考图片缩放使用 UIKIt、Core Graphics、Core Foundation 等情况下的方法)，是为 UIImage 添加一个分类，使用分类方法进行缩放。那么既然如此，为什么不同样使用分类呢？嗯，不错的想法，笔者刚开始是这样做的： - (UIImage )resizeWithImage:(UIImage )image scaleSize:(CGSize)size{ CFDataRef bitmapData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage)); // Create the image source CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData(bitmapData, NULL); if(!imageSourceRef) { return nil; } CGFloat maxPixelSize = MAX(size.width, size.height); // 缩略图选项 CFDictionaryRef options = (__bridge CFDictionaryRef) @{ (\\_\\_bridge id)kCGImageSourceShouldCache : (\\_\\_bridge id)kCFBooleanFalse, (\\_\\_bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (\\_\\_bridge id)kCFBooleanTrue, (__bridge id)kCGImageSourceThumbnailMaxPixelSize: \\[NSNumber numberWithFloat:maxPixelSize\\] }; // 生成缩略图 CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSourceRef, 0, options); UIImage * thumbnailImage = \\[UIImage imageWithCGImage:imageRef\\]; // 释放内存 CFRelease(imageSourceRef); CGImageRelease(imageRef); return thumbnailImage; } 直接跑起来，结果返回的图片为 nil。 经过详细了解 CGDataProvider 的一系列 API，CGImage 的 dataProvider 指的是 CGImageCreate 时，传入的承载了Bitmap Buffer 数组的一个提供者，可以是一个内存中的 buffer，也可以是一个 callback 来实现惰性解码。也就是说，这个传入的 Bitmap Buffer 数组，必须是未经过解压缩的数据。如果是经过了解压缩的图片数据，那么传给 ImageI/O 是没有意义的。 问题真的出在这里吗？ 这两个方法参数不同之处是，一个是使用 UIImage image = [UIImage imageWithContentsOfFile:path]，传入 UIImage 对象，而另一个是通过 NSData data = [NSData dataWithContentsOfFile:path]，传入的 NSData 对象。 这两个方法本质的区别到底是什么呢？为什么造成不同的结局？系统在这两个方法里面具体都干了什么呢？ 首先，拿 JPEG 格式的做实验，看看 [UIImage imageWithContentsOfFile:] 都做了什么。 可以看到，在该方法中系统调用了 CGImageSourceCreateImageAtIndex 方法，接着使用了 AppleJPEGPlugin 库的一些方法，但是并没有发现 decode 相关的函数，所以这里应该没有进行解码，而只是将图片进行了解压缩（decompress）。这也就解释了为什么使用 CGImageGetDataProvider 获取的 CGDataProvider 对象是无效的了。 那么同时可以看下 PNG 格式的图片，在使用 [UIImage imageWithContentsOfFile:] 时系统都做了什么。 PNG 格式的图片，同样是调用 CGImageSourceCreateImageAtIndex 等方法，同时可以看到使用的是 PNGPlugin 库相关的方法，PNGReadPlugin 读取文件数据进行解压缩。","tags":[]},{"title":" 图片加载和处理\t\t","date":"2019-03-05T16:21:45.000Z","path":"2019/03/06/e5-9b-be-e7-89-87-e5-8a-a0-e8-bd-bd-e5-92-8c-e5-a4-84-e7-90-86/","text":"文章：iOS性能优化–图片加载和处理、WWDC2018-Image and Graphics Best Practices 一、图片显示图片的显示分为三步：加载、解码、渲染。解码和渲染是由 UIKit 进行，通常我们操作的只有加载。 以 UIImageView 为例。当其显示在屏幕上时，需要 UIImage 作为数据源。UIImage 持有的数据是未解码的压缩数据，能节省较多的内存和加快存储。 当 UIImage 被赋值给 UIImage 时（例如 imageView.image = image;），图像数据会被解码，变成 RGB 的颜色数据。 解码是一个计算量较大且需要 CPU 来执行的任务；并且解码出来的图片体积与图片的宽高有关系，而与图片原来的体积无关。其体积大小可简单描述为：宽 * 高 * 每个像素点的大小 = width height 4bytes。 图像解码操作会造成什么问题？ 以常见的 UITableView 和 UICollectionView 为例，假如在使用一个多图片显示的功能：在上下滑动显示图片的过程中，我们会在 cellForRow 的方法加载 UIImage 图片、赋值给 UIImageView，相当于在主线程同时进行 IO 操作、解码操作等，会造成内存迅速增长和 CPU 负载瞬间提升。 并且内存的迅速增加会触发系统的内存回收机制，尝试回收其他后台进程的内存，增加 CPU 的工作量。如果系统无法提供足够的内存，则会先结束其他后台进程，最终无法满足的话会结束当前进程。 优化 1：降采样 在滑动显示的过程中，图片显示的宽高远比真实图片要小，我们可以采用加载缩略图的方式减少图片的占用内存。如下图所示： 我们加载 JPEG的图片，然后进行相关设置，解码后根据设置生成 CGImage 缩略图，最后包装成 UIImage，最终传递给UIImageView 渲染。 思考：这里的解码步骤为何不是上文提到的 imageView.image = image 时机？ - (UIImage )downsampleImageAt:(NSURL )imageURL to:(CGSize)pointSize scale:(CGFloat)scale{ CFDictionaryRef imageSourceOptions = CFDictionaryCreate ( CFAllocatorGetDefault(), (void )@[ (NSString )kCGImageSourceShouldCache ], (void *)@[ @(YES) ], 1, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef imageSource = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, imageSourceOptions); NSInteger maxDimensionInPixels = MAX(pointSize.width, pointSize.height) * scale; CFDictionaryRef downsampleOptions = (__bridge CFDictionaryRef)@{ (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @(YES), (NSString *)kCGImageSourceShouldCacheImmediately : @(YES), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @(YES), (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(maxDimensionInPixels) }; CGImageRef downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions); return \\[UIImage imageWithCGImage:downsampledImage\\]; } 正常的 UIImage 加载是从 App 本地读取，或者从网络下载图片，此时不涉及图片内容相关的操作，并不需要解码；当图片被赋值给 UIImageView 时，CALayer 读取图片内容进行渲染，所以需要对图片进行解码；而上文的缩略图生成过程中，已经对图片进行解码操作，此时的 UIImage 只是一个 CGImage 的封装，所以当 UIImage 赋值给 UIImageView 时，CALayer 可以直接使用 CGImage 所持有的图像数据。 优化 2：异步处理 从用户的体验来分析，滑动的操作往往是间断性触发，在滑动的瞬间有较大的工作量，而且由于都是在主线程进行操作无法进行任务分配，CPU 2 处于闲置。由此引申出两种优化手段：Prefetching（预处理）和 Background decoding / downsampling（子线程解码和降采样）。综合起来，可以在 Prefetching 时把降采样放到子线程进行处理，因为降采样过程就包括解码操作。 Prefetching 回调中，把降采样的操作放到同步队列 serialQueue 中，处理完毕之后抛给主线程进行 update 操作。 需要特别注意，此处不能是并发队列，否则会造成线程爆炸，原因见总结部分。 { // 创建串行队列 _serialQueue = dispatch_queue_create(“DecodeQueue”, DISPATCH_QUEUE_SERIAL);} /** * @brief 获取单元格的图片 */- (void)collectionView:(UICollectionView )collectionView prefetchItemsAt:(NSArray&lt;NSIndexPath &gt; )indexPaths{ for (NSIndexPath indexPath in indexPaths) { dispatch_async(_serialQueue, ^{ UIImage * downsampledImage = [self downsample]; dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[self updateAt:indexPath with:downsampledImage\\]; }); }); } } /** * @brief 降采样。自行实现。 */- (UIImage *)downsample{ return nil;} /** * @brief 更新单元格的图片 */- (void)updateAt:(NSIndexPath )indexPath with:(UIImage )image{ } 优化 3：使用 Image Asset Catalogs 苹果推荐的图片资源管理工具，压缩效率更高，在 iOS 12 的机器上有 10~20% 的空间节约，并且苹果会持续对其进行优化。 WWDC Session。 二、总结应用上述的优化策略，已经能对图片加载有比较好的优化。 WWDC 后续还有对 CustomDrawing 和 CALayer 的 BackingStore 的介绍，与图片关系不大，不在此赘述。 三、WWDC学习原作者的经验：落影loyinglin 先主观假设两个前提： ①、大部分苹果工程师对 iOS 系统内部实现都比我们要清楚； ②、能到 WWDC 分享的工程师在苹果内部也是优秀的工程师；那么 WWDC 所讲的内容我们可以认为是正确的事实。 所以可以基于自己已掌握的基础知识，还有对 iOS 系统的了解来分析 WWDC 上面所提到的现象，看我们的 iOS 知识体系是否存在缺陷；另外，WWDC 介绍的很多知识点同样免验证的加入自己的知识体系。 以上文提到的线程爆炸为例，看看这种方式的好处。 原文如下： Thread Explosion（线程爆炸） More images to decode than available CPUs（解码图像数量大于 CPU 数量）GCD continues creating threads as new work is enqueued（GCD 创建新线程处理新的任务）Each thread gets less time to actually decode images（每个线程获得很少的时间解码图像） 从这个案例我们学习到如何避免图像解码的线程爆炸，我们分析苹果工程师的逻辑，然后扩散思维： 原因：解码任务过多 => 过程：GCD 开启更多线程=> 结果：每个线程获得更少的时间 延伸出来的问题： GCD 是如何处理并发队列？为何会启动多个线程处理？多少的线程数量合适？线程的 cpu 时间分配和切换代价？… 举一反三。但是这样的思考稍显混乱，仍有优化的空间。把脑海关于 GCD 的认知提炼出来： ①、GCD 是用来处理一系列任务的同步和异步执行，队列有串行和并发两种，与线程的关系只有主线程和非主线程的区别； ②、串行队列是执行完当前的任务，才会执行下一个 block 任务；并行队列是多个 block 任务并行执行，GCD 会根据任务的执行情况分配线程，原则是尽快完成所有任务。 接下来的表现是操作系统相关的知识： ①、iOS 系统中进程和线程的关联，每个启动的 App 都是一个进程，其中有多个线程； ②、cpu 的时间是分为多个时间片，每个线程轮询执行； ③、线程切换执行有代价，但比进程切换小得多； ④、每个 cpu 核心在同一时刻只能执行一个线程。 至此我们可以结合操作系统和 GCD 的知识，猜测底层 GCD 的实现思路和线程爆炸情况下的表现： 主线程把多个任务 block 放到并发队列，GCD 先启动一个线程处理解码任务，线程执行过程中遇到耗时操作时（IO 等待、大量 CPU 计算），短时间内无法完成，为了不阻塞后续任务的执行，GCD 启动新的线程处理新的任务。 结合此案例，我们能回答相关问题： ①、现在有一个很复杂的计算任务，例如统计一个 50005000 图片中像素点的 RGB 颜色通道，如果用分为 25 个任务放到 GCD 并发队列，把大图切分成 25 个 10001000 小图分别统计，是否会速度的提升？ ②、GCD 的串行队列和并发队列的应用场景有何不同？","tags":[]},{"title":" LC 2\t\t","date":"2019-03-04T16:26:45.000Z","path":"2019/03/05/lc-2/","text":"十一、Container With Most Water（盛最多水的容器）1、问题描述 给定 n 个非负整数 a1、a2、…、an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：不能倾斜容器，且 n 的值至少为 2。 2、算法分析 定义两个指针 i、j 分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离。 3、算法实现 #define MAX(a, b) ((a) &lt; (b) ? (b) : (a)) #define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) int maxArea(int* height, int heightSize) { int i = 0; int j = heightSize - 1; int max = 0; while(i &lt; j) { max = MAX(max, (j - i) * MIN(height\\[i\\], height\\[j\\])); height\\[i\\] &lt; height\\[j\\] ? ++i : --j; } return max; } 4ms 代码。减少了多余的 height[i] 和 height[j] 比较。 int maxArea(int* height, int heightSize){ int maxarea = 0, left = 0, right = heightSize - 1; int area = 0; while(left &lt; right) { if(height\\[left\\]&lt;height\\[right\\]) { area = height\\[left\\]*(right-left); left++; if(area &gt; maxarea) maxarea = area; } else { area = height\\[right\\]*(right-left); right--; if(area &gt; maxarea) maxarea = area; } } return maxarea; } 十二、Integer to Roman（整数转罗马数字）1、算法分析 字符 数值I 1V 5X 10L 50C 100D 500M 1000 寻找 I、V、X、L、C、D、M 与数字位数的关系。 ①、当 0 &lt; n &lt;= 10，只需要 I、V、X； ②、当 10 &lt; n &lt;= 100，只需要 X、L、C； ②、当 100 &lt; n &lt;= 1000，只需要 C、D、M； ③、当 1000 &lt; n &lt;= 3000，只需要 M。 由上可得：每进一位 -》idx += 2。 2、算法实现 char* intToRoman(int num){ int size = -1; // int 转为 int\\[\\] int* a = calloc(sizeof(int), 4); while (num &gt; 0) { a\\[++size\\] = num % 10; num /= 10; } /* 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 */ char r\\[7\\] = { &apos;I&apos;, &apos;V&apos;, &apos;X&apos;, &apos;L&apos;, &apos;C&apos;, &apos;D&apos;, &apos;M&apos; }; int rIdx = size * 2; char * s = malloc(sizeof(char) * 20); for (int j = 0; j &lt; 20; j++) s\\[j\\] = &apos;\\\\0&apos;; int sIdx = -1; int temp = 0; while (size &gt;= 0) { temp = a\\[size\\]; // 4 if (temp == 4) { s\\[++sIdx\\] = r\\[rIdx\\]; s\\[++sIdx\\] = r\\[rIdx + 1\\]; } // 9 else if (temp == 9) { s\\[++sIdx\\] = r\\[rIdx\\]; s\\[++sIdx\\] = r\\[rIdx + 2\\]; } // \\[0, 4) else if (temp &lt; 4) { for (int j = 0; j &lt; temp; j++) s\\[++sIdx\\] = r\\[rIdx\\]; } // \\[5, 9) else { s\\[++sIdx\\] = r\\[rIdx + 1\\]; for (int j = 0; j &lt; temp - 5; j++) s\\[++sIdx\\] = r\\[rIdx\\]; } size--; rIdx -= 2; } return s; } 24ms 代码。 char* intToRoman(int num) { static char temp[16]; int n=0; int i=0; int j=0; if(num&lt;1||num&gt;3999) { //printf(“The num is overflow!”); return 0; } // int i=0; n=num/1000; if(n&gt;0){ for(i;i&lt;n;i++) { temp[i]=’M’; } } n=num%1000; n=n/100; if(n&gt;0){ if(n==9) { temp[i]=’C’; temp[++i]=’M’; ++i; }else if(n==4) { temp[i]=’C’; temp[++i]=’D’; ++i; }else if(n&gt;=5) { temp[i]=’D’; for(j=++i;j&lt;i+n-5;j++) { temp[j]=’C’; } i=j; }else { for(j=i;j&lt;i+n;j++) { temp[j]=’C’; } i=j; } } n=num%100; n=n/10; if(n&gt;0) { if(n==9) { temp[i]=’X’; temp[++i]=’C’; ++i; } else if(n==4) { temp[i]=’X’; temp[++i]=’L’; ++i; } else if(n&gt;=5) { temp[i]=’L’; for(j=++i;j&lt;i+n-5;j++) { temp[j]=’X’; } i=j; } else { for(j=i;j&lt;i+n;j++) { temp[j]=’X’; } i=j; } } n=num%10; if(n&gt;0){ if(n==9) { temp[i]=’I’; temp[++i]=’X’; ++i; } else if(n==4) { temp[i]=’I’; temp[++i]=’V’; ++i; } else if(n&gt;=5) { temp[i]=’V’; for(j=++i;j&lt;i+n-5;j++) { temp[j]=’I’; } i=j; } else { for(j=i;j&lt;i+n;j++) { temp[j]=’I’; } i=j; } } temp[i]=’\\0’; return temp; } 十三、Roman to Integer（罗马数字转整数）1、算法分析 从低位向高位转换，当 ‘I’ 的右侧小于或等于 ‘I’ 时 +1，否则 -1，因为在一个更大的数的左边不会同时有两个 ‘I’，如 ‘IIV’ 是错误的；当 ‘V’ 的右侧小于或等于 ‘V’ 时 +10，否则 -10，依此规律类推。 2、算法实现 int romanToInt(char s){ / I 1 V 5 X 10 L 50 C 100 D 500 M 1000 */ int len = (int)strlen(s); int i = len - 1; int sum = 0; char lastC = &apos;I&apos;; while (i &gt;= 0) { // &apos;I&apos; 的右侧为 &apos;I&apos; 才能 + 1，否则 - 1 if (s\\[i\\] == &apos;I&apos;) { sum += (lastC == &apos;I&apos;) ? 1 : -1; } // &apos;V&apos; 不能在任何人的左边 else if (s\\[i\\] == &apos;V&apos;) { sum += 5; } // &apos;X&apos; 的右侧为 &apos;I&apos;、&apos;V&apos;、&apos;X&apos; 才能 + 10，否则 - 10。 else if (s\\[i\\] == &apos;X&apos;) { sum += (lastC == &apos;I&apos; || lastC == &apos;V&apos; || lastC == &apos;X&apos;) ? 10 : -10; } // &apos;L&apos; 不能在任何人的左边 else if (s\\[i\\] == &apos;L&apos;) { sum += 50; } // &apos;C&apos; 的右侧为 &apos;I&apos;、&apos;V&apos;、&apos;X&apos;、&apos;L&apos;、&apos;C&apos; 才能 + 10，否则 - 10。 else if (s\\[i\\] == &apos;C&apos;) { sum += (lastC == &apos;D&apos; || lastC == &apos;M&apos;) ? -100 : 100; } // &apos;D&apos; 不能在任何人的左边 else if (s\\[i\\] == &apos;D&apos;) { sum += 500; } // &apos;M&apos; 不能在任何人的左边 else if (s\\[i\\] == &apos;M&apos;) { sum += 1000; } lastC = s\\[i\\]; i--; } return sum; } 28ms 代码（实际运行 100ms）。 int romanToInt(char s) { char p = s; int r = 0; while(p){ int n = \\p,post = *(p+1); if(n == ‘I’){ if(post == ‘V’){ r+=4; p++; }else if(post == ‘X’){ r+=9; p++; }else{ r+=1; } }else if(n == ‘V’){ r+=5; }else if(n == ‘X’){ if(post == ‘L’){ r+=40; p++; }else if(post == ‘C’){ r+=90; p++; }else{ r+=10; } }else if(n == ‘L’){ r+=50; }else if(n == ‘C’){ if(post == ‘D’){ r+=400; p++; }else if(post == ‘M’){ r+=900; p++; }else{ r+=100; } }else if(n == ‘D’){ r+=500; }else if(n == ‘M’){ r+=1000; } p++; } return r;} 十四、Longest Common Prefix（最长公共前缀）1、算法分析 先确定返回空字符串的情况，①、数组为空；②、有字符串为空；③、没有共同前缀。 然后用 minLen 保存数组内元素最短字符串的长度，用于 while 循环的退出条件，循环比较每个字符串的同一索引下的字符，设定一个索引值为 index，那么每个比较的字符为 ((char *)strs[i])[index]，i 表示第几个字符串。 2、算法实现 #define INTMAX 10000 #define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) char* longestCommonPrefix(char** strs, int strsSize) { // 外层数组为空 if (strsSize == 0) return &quot;&quot;; int minLen = INTMAX; // 数组内字符串的最短长度 for (int i = 0; i &lt; strsSize; i++) { minLen = MIN(minLen, (int)strlen(strs\\[i\\])); } // 有字符串为空 if (minLen == 0) return &quot;&quot;; int index = -1; // 指向当前比较字符的索引 char curC = &apos;\\\\0&apos;; while (index &lt; minLen) { ++index; for (int i = 0; i &lt; strsSize; i++) { if (i == 0) { curC = ((char *)strs\\[i\\])\\[index\\]; } else if (curC != ((char *)strs\\[i\\])\\[index\\]){ index -= 1; // 退回 1，因为当前不是公共字符 minLen = -1; // 退出 while 循环 break; // 退出 for 循环 } } } // 没有共同前缀 if (index &lt; 0) { return &quot;&quot;; } char * sub = malloc(sizeof(char) * (index + 2)); for (int i = 0; i &lt;= index; i++) { sub\\[i\\] = ((char *)strs\\[0\\])\\[i\\]; } sub\\[index + 1\\] = &apos;\\\\0&apos;; // 结束符 return sub; } 十五、3Sum（三数之和）1、算法分析 首先对数组从小到大排序。用 i 索引循环遍历数组，范围 [0, numSize - 2]，i 位置的值分为三种情况： ①、nums[i] &gt; 0，直接结束，因为在它后面数都 > 0； ②、nums[i] ≤ 0，分别设置两个指针 j、k，j 指向 i + 1 的位置，k 指向数组末尾的位置。然后三个位置的数值相加，如果 = 0，即找到一组，保存起来；如果 &lt; 0，说明需要一个值增加，因为 i 不能移动，所以 j 向右移一位，因为 nums[j + 1] ≥ nums[j]；如果 > 0，说明需要一个值减少，同样 i 不能一定，所以 k 向左移动，因为 nums[j - 1] ≤ nums[j]。 ③、nums[i] == nums[i - 1]，因为 nums[i] 的结果是 nums[i - 1] 的子集，所以跳过这一次循环； 2、算法实现 自实现归并排序。 /** * @param SR 两个有序序列构成的序列 * @param TR 一个空数组，用来存放排序好之后的数字 * @param left 起始位置 * @param mid 两个序列的分解位置 * @param right 结束位置 */ #define MAXSIZE 100000int SR[MAXSIZE], TR[MAXSIZE]; int merge(int SR[], int TR[], int left, int mid, int right){ int i = left, j = mid + 1, k = left; // k 是 TR 当前存入数字的下标 while(i &lt;= mid &amp;&amp; j &lt;= right) { if(SR\\[i\\] &lt; SR\\[j\\]) { TR\\[k++\\] = SR\\[i++\\]; } else { TR\\[k++\\] = SR\\[j++\\]; } } while(i &lt;= mid) { TR\\[k++\\] = SR\\[i++\\]; // 当前面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 } while(j &lt;= right) { TR\\[k++\\] = SR\\[j++\\]; // 当后面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 } return 0; }void copy(int SR[], int TR[], int s, int t){ for(int i = s; i &lt;= t; i++) { SR[i] = TR[i]; // TR -》 SR，相当于 TR 所在的区间有序 }}int mergesort2(int SR[], int left, int right){ if(left &lt; right) { int mid = (left + right) &gt;&gt; 1; mergesort2(SR, left, mid); // 前一半序列继续进行归并排序 mergesort2(SR, mid+1, right); // 后一半序列同时进行归并排序 // 以上递归调用的结束条件是 left ≥ right，也就是分到只有一个数字进行归并排序的时候，一个序列只有一个数字，那么这个序列肯定是有序的 // 以上都是属于“分”的阶段，目的是获得两个有序的数列。 int TR\\[MAXSIZE\\] = { 0 }; merge(SR, TR, left, mid, right); // 对这两个有序的数列，进行排序，变成一个同样大小但是有序的数列 copy(SR, TR, left, right); //将在TR中排序好的数列给SR，方便SR递归调用归并排序，因为每次两个归并排序的结果都是保存在TR中的，现在要进行下一步就必须在TR数列的基础上面=进行，所以我们把TR给SR } else { ; } return 0; } /** * Return an array of arrays of size returnSize. \\ Note: The returned array must be malloced, assume caller calls free(). /int** threeSum(int nums, int numsSize, int returnSize) { if (numsSize &lt; 3) { returnSize = 0; return NULL; } mergesort2(nums, 0, numsSize - 1); *returnSize = 0; int \\*\\*result = malloc(sizeof(int\\[3\\]) \\* MAXSIZE); for (int i = 0; i &lt; numsSize - 2; i++) { // 当前为正数，说明后面都是正数 if (nums\\[i\\] &gt; 0) break; // 当前数 = 上一个数，跳过。因为上一个数的集合肯定包括当前的 if (i &gt; 0 &amp;&amp; nums\\[i\\] == nums\\[i-1\\]) continue; int j = i + 1; int k = numsSize - 1; while (j &lt; k) { // 如果当前值 = 上一个值，说明重复计算了 if (j &gt; i + 1 &amp;&amp; nums\\[j\\] == nums\\[j - 1\\]) { j++; continue; } int sum = nums\\[i\\] + nums\\[j\\] + nums\\[k\\]; if (sum == 0) { int* arr = (int *)malloc(sizeof(int) * 3); arr\\[0\\] = nums\\[i\\]; arr\\[1\\] = nums\\[j\\]; arr\\[2\\] = nums\\[k\\]; result\\[*returnSize\\] = arr; (*returnSize)++; j++; } else if (sum &gt; 0){ k--; } else { j++; } } } return result; } 52ms 代码。 /** * Return an array of arrays of size returnSize. \\ Note: The returned array must be malloced, assume caller calls free(). */typedef struct{ int num;}table; typedef struct{ int *table; int size;}hash; hash creatHash(int m){ int n = abs(m); hash p; p = calloc(1, sizeof(hash)); p-&gt;table = calloc(n + 1, sizeof(int)); p-&gt;size = n + 1; return p; } void deletHash(hash h){ free(h-&gt;table); free(h); return;}void putHash(hash h, int x){ int n = abs(x); if(n &lt; h-&gt;size) { h-&gt;table\\[n\\] = 1; } return; }int getHash(hash *h,int x){ int n = abs(x); if(n &lt; h-&gt;size) return h-&gt;table\\[n\\]; else return 0; } int searchHash(hash *map, int target, int limit){ if(abs(target) &lt;= abs(limit)) return getHash(map,target); else return 0;} /** * 排序规则 /int cmp( const void \\a , const void *b ){ return ((table )a)-&gt;num - ((table )b)-&gt;num;} int* threeSum(int nums, int numsSize, int* returnSize) { int i = 0, n = numsSize; if(n &lt; 3 || !nums) return NULL; table \\*pTable, \\*pWalk, \\*pA, \\*pB, *pC, Target; hash \\*NegMap, \\*PosMap; // sort pTable = malloc(20000 * sizeof(table)); memcpy(pTable, nums, n * sizeof(int)); qsort(pTable, n, sizeof(table), cmp); // 排序后，数组数值全部 \\&gt; 0，或者全部 &lt; 0，直接返回 null if(pTable\\[0\\].num &gt; 0) return NULL; if(pTable\\[n-1\\].num &lt; 0) return NULL; // two hash table NegMap = creatHash(pTable\\[0\\].num); PosMap = creatHash(pTable\\[n-1\\].num); for(pWalk = &amp;pTable\\[0\\]; pWalk-&gt;num &lt;= 0; pWalk++) { putHash(NegMap, pWalk-&gt;num); } for(pWalk = &amp;pTable\\[n-1\\]; pWalk-&gt;num &gt;= 0; pWalk--) { putHash(PosMap, pWalk-&gt;num); } // C(1 n) + C(2 n) = n(n+1)/2 int find, limit, \\*\\*p = malloc(n\\*(n+1)/2\\*sizeof(int\\*)); pA = &amp;pTable\\[0\\]; pB = &amp;Target; pC = &amp;pTable\\[n - 1\\]; for(; pA-&gt;num &lt; 0; pA++) { for(pC = &amp;pTable\\[n-1\\]; pC-&gt;num &gt; 0; pC--) { pB-&gt;num = -(pA-&gt;num + pC-&gt;num); if(pB-&gt;num &lt; 0) { limit = (pA+1)-&gt;num&gt;0? 0: (pA+1)-&gt;num; find=searchHash(NegMap,pB-&gt;num,limit); } else{ limit=(pC-1)-&gt;num&lt;0? 0: (pC-1)-&gt;num; find=searchHash(PosMap,pB-&gt;num,limit); } if(find){ p\\[i\\]=malloc(3*sizeof(int)); p\\[i\\]\\[0\\]=pA-&gt;num; p\\[i\\]\\[1\\]=pB-&gt;num; p\\[i\\]\\[2\\]=pC-&gt;num;i++; while(pA-&gt;num==(pA+1)-&gt;num) pA++; while(pC-&gt;num==(pC-1)-&gt;num) pC--; } } } if(!pA-&gt;num &amp;&amp; !pC-&gt;num &amp;&amp; pA+1 &lt;= pC-1){ p\\[i\\] = malloc(3*sizeof(int)); p\\[i\\]\\[0\\] = 0; p\\[i\\]\\[1\\] = 0; p\\[i\\]\\[2\\] = 0; i++; } *returnSize = i; free(pTable); deletHash(NegMap); deletHash(PosMap); return p; } 十六、3Sum Closest最接近的三数之和1、算法分析 与 3Sum 的思路差不多，先排序，后通过比较查找最接近的三数之和，处理的关键在于当前三个数之和与之前最接近的和的比较。 C 表示当前三数之和，L 表示上一次三数之和，T 表示目标值。 2、算法实现 注意 qsort 排序方法。 #define MAXINT 100000 int compare(const void *a, const void *b) { return ((int )a - (int )b);} int threeSumClosest(int* nums, int numsSize, int target) { if (numsSize &lt; 3 || !nums) return 0; qsort(nums, numsSize, sizeof(int), compare); int nearly = MAXINT; int sum = 0; for (int i = 0; i &lt; numsSize - 2; i++) { int j = i + 1; int k = numsSize - 1; while (j &lt; k) { if (j &gt; i+1 &amp;&amp; nums\\[j\\] == nums\\[j-1\\]) { j++; continue; } sum = nums\\[i\\] + nums\\[j\\] + nums\\[k\\]; if (sum == target) { return sum; } else if (sum &gt; target) { if ((nearly &gt; target &amp;&amp; sum &lt; nearly) || (nearly &lt; target &amp;&amp; sum - target &lt; target - nearly)) { nearly = sum; } k--; } else { if ((nearly &lt; target &amp;&amp; sum &gt; nearly) || (nearly &gt; target &amp;&amp; target - sum &lt; nearly - target)) { nearly = sum; } j++; } } } return nearly; } 4ms 代码。 int compare(const void *a, const void *b){ return ((int )a-(int )b);} int threeSumClosest(int* nums, int numsSize, int target) { int closest, num1, num2, num3, sum; qsort(nums, numsSize, sizeof(int), compare); closest = nums\\[0\\] + nums\\[1\\] + nums\\[2\\]; for(num1 = 0; num1 &lt; numsSize; num1++) { if(num1 == 0 || nums\\[num1\\] != nums\\[num1-1\\]) { num2 = num1 + 1; num3 = numsSize - 1; while(num2 &lt; num3) { sum = nums\\[num1\\] + nums\\[num2\\] + nums\\[num3\\]; // 重点 closest = abs(sum-target) &lt; abs(closest-target) ? sum : closest; if(sum == target) return target; else if(sum &gt; target) num3--; else num2++; } } } return closest; }","tags":[]},{"title":" pthread 的同步机制\t\t","date":"2019-03-04T08:37:18.000Z","path":"2019/03/04/pthread-e7-9a-84-e5-90-8c-e6-ad-a5-e6-9c-ba-e5-88-b6/","text":"原文：pthread的各种同步机制 一、简述pthread 是 POSIX 标准的多线程库，UNIX、Linux 上广泛使用，windows 上也有对应的实现，共一百多个函数都是 pthread 开头。 多线程编程被普遍认为复杂，主要是因为多线程给程序引入了一定的不可预知性，要控制这些不可预知性，就需要使用各种锁各种同步机制，不同的情况就应该使用不同的锁、不同的机制。什么事情一旦放到多线程环境，要考虑的问题立刻就上升了好几个量级。多线程编程就像潘多拉魔盒，带来的好处不可胜数，然而只要一不小心，就很容易让程序失去控制，所以你得用各种锁各种机制管住它。要解决好这些问题，工程师们就要充分了解这些锁机制，分析不同的场景，选择合适的解决方案。 二、Mutex Lock 互斥锁MUTual-EXclude Lock 互斥锁。 它是最容易理解、使用最广泛的一种同步机制。顾名思义，被这个锁保护的临界区就只允许一个线程进入，其它线程如果没有获得锁权限，那就只能在外面等着。 它使用得非常广泛，以至于大多数人谈到锁就是 mutex。pthread 里面还有很多锁，mutex 只是其中一种。 1、相关宏和函数 PTHREAD_MUTEX_INITIALIZER // 用于静态的mutex的初始化，采用默认的attr。比如: static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); // 用于动态的初始化int pthread_mutex_destroy(pthread_mutex_t mutex); // 把 mutex 锁干掉，并且释放所有它所占有的资源int pthread_mutex_lock(pthread_mutex_t mutex); // 请求锁，如果当前 mutex 已经被锁，那么这个线程就会卡在这儿，直到 mutex 被释放int pthread_mutex_unlock(pthread_mutex_t mutex); // 解锁int pthread_mutex_trylock(pthread_mutex_t mutex); // 尝试请求锁，如果当前 mutex 已经被锁或者不可用，这个函数就直接 return 了，不会把线程卡住 2、注意 mutex 的初始化 mutex 的初始化分两种，一种是用宏（PTHREAD_MUTEX_INITIALIZER），一种是用函数（pthread_mutex_init）。 如果没有特殊的配置要求的话，使用宏比较好，因为它比较快。只有真的需要配置的时候，才需要用函数。也就是说，凡是pthread_mutex_init(&amp;mutex, NULL) 的地方都可以使用宏，因为在 pthread_mutex_init 这个函数里的实现其实也是用了 PTHREAD_MUTEX_INITIALIZER： ///////////////////// pthread_src/include/pthread/pthread.h #define PTHREAD_MUTEX_INITIALIZER __PTHREAD_MUTEX_INITIALIZER ///////////////////// pthread_src/sysdeps/generic/bits/mutex.h # define __PTHREAD_MUTEX_INITIALIZER \\{ __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0, 0, 0, 0, 0 } // mutex 锁本质上是一个 spin lock，空转锁，关于空转锁的东西在下面会提到。 ///////////////////// pthread_src/sysdeps/generic/pt-mutex-init.cint_pthread_mutex_init (pthread_mutex_t mutex, const pthread_mutexattr_t attr){ *mutex = (pthread_mutex_t) __PTHREAD_MUTEX_INITIALIZER; // 这里其实用的也是宏。就这一句是初始化，下面都是在设置属性。 if (! attr || memcmp (attr, &amp;\\_\\_pthread\\_default_mutexattr, sizeof (*attr) == 0)) /\\* The default attributes. */ return 0; if (! mutex-&gt;attr || mutex-&gt;attr == \\_\\_PTHREAD\\_ERRORCHECK_MUTEXATTR || mutex-&gt;attr == \\_\\_PTHREAD\\_RECURSIVE_MUTEXATTR) mutex-&gt;attr = malloc (sizeof *attr); // pthread\\_mutex\\_destroy 释放的就是这里的资源 if (! mutex-&gt;attr) return ENOMEM; \\*mutex-&gt;attr = \\*attr; return 0; } 但是业界有另一种说法是：早年的 POSIX 只支持在 static 变量上使用 PTHREAD_MUTEX_INITIALIZER，所以PTHREAD_MUTEX_INITIALIZER 尽量不要到处都用，所以使用的时候得搞清楚你的 pthread 的实现版本是不是比较老的。 三、mutex 锁不是万能灵药基本上所有的问题都可以用互斥的方案去解决，大不了就是慢点儿，但不要不管什么情况都用互斥，都能采用这种方案不代表都适合采用这种方案。而且这里所说的慢不是说 mutex 的实现方案比较慢，而是互斥方案影响的面比较大，本来不需要通过互斥就能让线程进入临界区，用了互斥方案之后，就使这样的线程不得不等待互斥锁的释放，所以就慢了。 甚至有些场合用互斥就很蛋疼，比如多资源分配，线程步调通知等。如果是读多写少的场合，就比较适合读写锁（reader/writter lock），如果临界区比较短，就适合空转锁（pin lock）。 四、预防死锁如果要进入一段临界区需要多个 mutex 锁，那么就很容易导致死锁，单个 mutex 锁是不会引发死锁的。要解决这个问题也很简单，只要申请锁的时候按照固定顺序，或者及时释放不需要的 mutex 锁就可以。这就对代码有一定的要求，尤其是全局 mutex 锁的时候，更需要遵守一个约定。 如果是全局 mutex 锁，我习惯将它们写在同一个头文件里。一个模块的文件再多，都必须要有两个 umbrella header file。一个是整个模块的伞，外界使用你的模块的时候，只要 include 这个头文件即可。另一个用于给模块的所有子模块去 include，然后这个头文件里面就放一些公用的宏、配置，全局 mutex 放在这里就最合适了。这两个文件不能是同一个，否则容易出循环include 的问题。如果有人写模块不喜欢写这样的头文件的，那现在就要改了。 然后我的 mutex 锁的命名规则就是：作用_mutex_序号，比如 LinkListMutex_mutex_1、OperationQueue_mutex_2，后面的序号在每次有新锁的时候 +1。如果有哪个临界区进入的时候需要获得多个 mutex 锁的，我就按照序号的顺序去进行加锁操作（pthread_mutex_lock），这样就能够保证不会出现死锁了。 如果是属于某个 struct 内部的 mutex 锁，那么也一样，只不过序号可以不必跟全局锁挂钩，也可以从 1 开始数。 还有另一种方案也非常有效，就是用 pthread_mutex_trylock 函数来申请加锁，这个函数在申请加锁失败时立刻返回错误：EBUSY（锁尚未解除）或者 EINVAL（锁变量不可用）。一旦在 trylock 的时候有错误返回，那就把前面已经拿到的锁全部释放，然后过一段时间再来一遍。 当然也可以使用 pthread_mutex_timedlock 这个函数来申请加锁，这个函数跟pthread_mutex_trylock 类似，不同的是，你可以传入一个时间参数，在申请加锁失败之后会阻塞一段时间等解锁，超时之后才返回错误。 这两种方案我更多会使用第一种，原因如下： 一般情况下进入临界区需要加的锁数量不会太多，第一种方案足够。如果多于 2 个，就要考虑一下是否可以合并某些锁。 第一种方案适合锁比较少的情况，因为这不会导致非常大的阻塞延时。但是当你要加的锁非常多，ABCDE，加锁到 D 的时候阻塞了，然而其他线程可能只需要 AB 就可以运行，就会因为 AB 已经被锁住而阻塞，这时候才会采用第二种方案。如果要加的锁本身就不多，只有 AB 两个，那么阻塞一下还可以接受。 第二种方案在面临阻塞的时候，要操作的事情太多。 当把已经拿到的所有的锁都释放以后，当前线程的处理策略就会导致你的代码复杂度上升：当前线程不能退出，需要找个地方把它放起来，让它去等待一段时间之后再去申请锁，如果有多个线程出现了这样的情况，就需要一个线程池来存放这些等待解锁的线程。如果临界区是嵌套的，你在把这个线程挂起的时候，最好还要把外面的锁也释放掉，要不然也会容易导致死锁，这就需要你在一个地方记录当前线程使用锁的情况。这里要做的事情太多，复杂度比较大，容易出错。 总而言之，设计的时候尽量减少同一临界区所需要 mutex 锁的数量，然后采用第一种方案。如果确实有需求导致多个 mutex 锁，那么就只能采用第二种方案了，然后老老实实写好周边代码。但是 umbrella header file 和按照序号命名 mutex 锁是个非常好的习惯，可以允许你随着软件的发展而灵活采取第一第二种方案。 但是到了 semaphore 情况下的死锁处理方案时，上面两种方案就都不顶用了。另外，还有一种自己把自己锁死的死锁。 五、Reader-Writter Lock 读写锁mutex 锁有个缺点，就是只要锁住了，不管其他线程要干什么，都不允许进入临界区。 设想这样一种情况：临界区 foo 变量在被 thread1 线程读着，加了个 mutex 锁，thread2 线程如果也要读 foo 变量，因为被 thread1 加了个互斥锁，那就不能读了。但事实情况是，读取数据不影响数据内容本身，所以即便被 1 个线程读着，另外一个线程也应该允许去读。除非另外一个线程是写操作，为了避免数据不一致的问题，写线程就需要等读线程都结束了再写。 因此诞生了 Reader-Writter Lock，有的地方也叫 Shared-Exclusive Lock，共享锁。 读写锁的特性： 当一个线程加了读锁访问临界区，另一个线程也想访问临界区读取数据的时候，也可以加一个读锁成功进入临界区进行读操作了，此时读锁线程有两个。当第三个线程需要进行写操作时，它需要加一个写锁，这个写锁只有在读锁的拥有者为 0 时才有效。也就是等前两个读线程都释放读锁之后，第三个线程就能进去写了。 总结，读写锁里，读锁能允许多个线程同时去读，但是写锁在同一时刻只允许一个线程去写。 这样更精细的控制，就能减少 mutex 导致的阻塞延迟时间。虽然用 mutex 也能起作用，但这种场合明显读写锁更好。 1、相关宏和函数 PTHREAD_RWLOCK_INITIALIZER int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); int pthread_rwlock_rdlock(pthread_rwlock_t rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); int pthread_rwlock_timedrdlock_np(pthread_rwlock_t *rwlock, const struct timespec *deltatime); // 这个函数在 Linux 和 Mac 的 man 文档里都没有，新版的pthread.h里面也没有，旧版的能找到int pthread_rwlock_timedwrlock_np(pthread_rwlock_t *rwlock, const struct timespec *deltatime); // 同上 2、认真区分使用场合，记得避免写线程饥饿 跟上面提到的写 muetx 锁的约定一样，操作、类别、序号最好都要有。比如 OperationQueue_rwlock_1。 由于读写锁的性质，在默认情况下是很容易出现写线程饥饿的。因为它必须要等到所有读锁都释放之后才能成功申请写锁。不过不同系统的实现版本对写线程的优先级实现不同。Solaris 是写线程优先，其他系统默认读线程优先。 比如在写线程阻塞的时候，有很多读线程是可以一个接一个地在那儿插队的（在默认情况下，只要有读锁在，写锁就无法申请，然而读锁可以一直申请成功，就导致所谓的插队现象），那么写线程就不知道什么时候才能申请成功写锁了，然后它就饿死了。 为了控制写线程饥饿，必须要在创建读写锁的时候设置 PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE，不要用PTHREAD_RWLOCK_PREFER_WRITER_NP，这个似乎没什么用。 ////////////////////////////// /usr/include/pthread.h /* Read-write lock types. */ #if defined __USE_UNIX98 || defined __USE_XOPEN2Kenum{ PTHREAD_RWLOCK_PREFER_READER_NP, PTHREAD_RWLOCK_PREFER_WRITER_NP, // 妈蛋，没用，一样reader优先 PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP}; 总的来说，这样的锁建立之后一定要设置优先级，不然就容易出现写线程饥饿。而且读写锁适合读多写少的情况，如果读、写一样多，那还是用 mutex 锁比较合理。 六、spin lock 空转锁spin lock 空转锁。它是互斥锁、读写锁的基础。在其它同步机制里 condition variable、barrier 等都有它的身影。 先说一下其他锁申请加锁的过程，你就知道什么是 spin lock 了。 互斥锁和读写锁在申请加锁时会使得线程阻塞。阻塞的过程分为两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请锁，在空转一定时间之后，线程会进入 waiting 状态，此时线程不占用 CPU 资源了，等锁可用的时候，这个线程会被唤醒。 为什么会有这两个阶段呢？主要还是出于效率因素。 如果在申请锁失败之后立刻将线程状态挂起，会带来上下文切换的开销，挂起之后就不占用 CPU 资源了，原属于这个线程的 CPU 时间就可以拿去做更加有意义的事情。假设锁在第一次申请失败之后就又可用了，那么短时间内进行上下文切换的开销就显得很没效率。 如果在申请锁失败之后不断轮询申请加锁，那么可以在第一时间申请加锁成功，同时避免了上下文切换的开销，但是浪费了宝贵的 CPU 时间。假设锁在第一次申请失败之后，很久很久才能可用，那么 CPU 在这段时间里都被这个线程拿来轮询了，也显得很没效率。 于是就出现了两种方案结合的情况：在第一次申请加锁失败的时候，先不着急切换上下文，空转一段时间。如果锁在短时间内又可用了，那么就避免了上下文切换的开销，CPU 浪费的时间也不多。空转一段时间之后发现还是不能申请加锁成功，那么就有很大概率在将来的不短的一段时间里面加锁也不成功，那么就把线程挂起，把轮询用的 CPU 时间释放出来给别的地方用。 《APUE》中原文是这样：A spin lock is like a mutex, except that instead of blocking a process by sleeping, the process is blocked by busy-waiting (spinning) until the lock can be acquired. 事实上，spin lock 在实现的时候，有一个 __pthread_spin_count 限制，如果空转次数超过这个限制，线程依旧会挂起（__shed_yield）。 spin lock 申请加锁的实现： /////////////////////////////pthread_src/sysdeps/posix/pt-spin.c /* Lock the spin lock object LOCK. If the lock is held by another thread spin until it becomes available. /int_pthread_spin_lock (__pthread_spinlock_t lock){ int i; while (1) { for (i = 0; i &lt; \\_\\_pthread\\_spin_count; i++) { if (\\_\\_pthread\\_spin_trylock (lock) == 0) return 0; } \\_\\_sched\\_yield (); } } 1、相关宏和函数 在 man 里面没找到 spin lock 相关的函数，但事实上外面还是能够使用的，下面是在源代码里面挖到的原型： ////////////////////////////////pthread_src/pthread/pt-spin-inlines.c /* Weak aliases for the spin lock functions. Note that pthread_spin_lock is left out deliberately. We already provide an implementation for it in pt-spin.c. */weak_alias (__pthread_spin_destroy, pthread_spin_destroy);weak_alias (__pthread_spin_init, pthread_spin_init);weak_alias (__pthread_spin_trylock, pthread_spin_trylock);weak_alias (__pthread_spin_unlock, pthread_spin_unlock); /////////////////////////////////pthread_src/sysdeps/posix/pt-spin.c weak_alias (_pthread_spin_lock, pthread_spin_lock); /————————————————-/ PTHREAD_SPINLOCK_INITIALIZERint pthread_spin_init (__pthread_spinlock_t __lock, int __pshared);int pthread_spin_destroy (__pthread_spinlock_t __lock);int pthread_spin_trylock (__pthread_spinlock_t __lock);int pthread_spin_unlock (__pthread_spinlock_t __lock);int pthread_spin_lock (__pthread_spinlock_t *__lock); /————————————————-/ 2、分清楚使用场合 空转锁非常适合临界区非常短的场合，或者实时性要求比较高的场合。 由于临界区短，线程需要等待的时间也短，即便轮询浪费 CPU 资源，也浪费不了多少，省了上下文切换的开销。由于实时性要求比较高，来不及等待上下文切换的时间，那就只能浪费 CPU 资源在那儿轮询了。 大部分情况都不会直接用到空转锁，其他锁在申请不到加锁时也是会空转一定时间的，如果连这段时间都无法满足你的请求，那要么就是线程太多，或者临界区没那么短。 七、pthread_cleanup_push() &amp; pthread_cleanup_pop()线程是允许在退出的时候，调用一些回调方法的。如果你需要做类似的事情，那么就用以下这两种方法： void pthread_cleanup_push(void (*callback)(void *), void *arg);void pthread_cleanup_pop(int execute); 它的背后有一个 stack，可以塞很多个 callback 函数进去，然后调用的时候按照先入后出的顺序调用这些 callback。所以你在塞 callback 的时候，如果是关心调用顺序的，那就得注意这一点了。 塞进去的 callback 只有在以下情况下才会被调用： 线程通过 pthread_exit() 函数退出 线程被 pthread_cancel() 取消 pthread_cleanup_pop(int execute) 时，execute 传了一个非 0 值 也就是说，如果你的线程函数是这么写的，那在线程结束的时候就不会调到你塞进去的那些 callback 了： static void thread_function(void args){ … … … … return 0; // 线程退出时没有调用 pthread_exit() 退出，而是直接 return，此时是不会调用栈内 callback 的} 用 exit() 行吗？只要在任意线程调用 exit()，整个进程就结束了。 pthread_cleanup_push 塞入的 callback 可以用来记录线程结束的点，或者打日志等，一般不太会在这里执行业务逻辑。在线程结束之后如果要执行业务逻辑，一般用下面提到的 pthread_join。 1、callback 函数是可以传参数的 在 pthread_cleanup_push 函数中，第二个参数的值会作为 callback 函数的第一个参数。举个例子： void callback(void callback_arg){ printf(“arg is : %s\\n”, (char )callback_arg);} static void thread_function(void thread_arg){ … pthread_cleanup_push(callback, “this is a queue thread, and was terminated.”); … pthread_exit((void ) 0); // 这句不调用，线程结束就不会调用你塞进去的 callback 函数。 return ((void ) 0);} int main (){ … … error = pthread_create(&amp;tid, NULL, thread_function, (void *)thread_arg) … … return 0;} callback 函数的参数是在线程函数里面设置的，所以拿来做业务也是可以的，不过一般都是拿来做清理的事情，很少会把它放到业务里面去做。 2、要保持 callback 栈平衡 关于要在保持栈平衡的前提下，选择性地调用 callback，似乎只能在中间调用 *__handlers = __handler.next; 这句话了？也许这是个伪需求，关于这个问题，大家也可以在评论区讨论一下。 样例： void callback1(void callback_arg){ printf(“arg is : %s\\n”, (char )callback_arg);} void callback2(void callback_arg){ printf(“arg is : %s\\n”, (char )callback_arg);} static void thread_function(void thread_arg){ … pthread\\_cleanup\\_push(callback1, &quot;this is callback 1.&quot;); pthread\\_cleanup\\_push(callback2, &quot;this is callback 2.&quot;); ... if (thread\\_arg-&gt;should\\_callback) { pthread_exit((void *) result); } pthread\\_cleanup\\_pop(0); // 传递参数0，在pop的时候就不会调用对应的callback，如果传递非0值，pop的时候就会调用对应callback了。 pthread\\_cleanup\\_pop(0); // push 了两次就 pop 两次，你要是只 pop 一次就不能编译通过 pthread_exit((void *) result); return ((void *) 0); } int main (){ … … error = pthread_create(&amp;tid, NULL, thread_function, (void *)thread_arg) … … return 0;} push 和 pop 如果不一一对应，就会导致编译不过。事实的确如此，在 pthread 对于这两个函数是通过宏来实现的，如果没有一一对应，编译器就会报 “} missing” 的错误。其相关实现代码如下： /* ./include/pthread/pthread.h */ #define pthread_cleanup_push(rt, rtarg) __pthread_cleanup_push(rt, rtarg) #define pthread_cleanup_pop(execute) __pthread_cleanup_pop(execute)/* ./sysdeps/generic/bits/cancelation.h */ #define __pthread_cleanup_push(rt, rtarg) \\ { \\ struct __pthread_cancelation_handler *__handlers \\ = __pthread_get_cleanup_stack (); \\ struct __pthread_cancelation_handler __handler = \\ { \\ (rt), \\ (rtarg), \\ __handlers \\ }; \\ *__handlers = &amp;__handler; #define __pthread_cleanup_pop(execute) \\ if (execute) \\ __handler.handler (__handler.arg); \\ *__handlers = __handler.next; \\ } \\ 八、pthread_join()在线程结束的时候，我们能通过上面的 pthread_cleanup_push 塞入的 callback 方法知道，也能通过 pthread_join 这个方法知道。一般情况下，如果是出于业务的需要要知道线程何时结束的，都会采用 pthread_join 这个方法。 它适用这样的场景： 有两个线程，B 线程在做某些事情之前，必须要等待 A 线程把事情做完，然后才能接着做下去。这时候可以用 join。 原型： int pthread_join(pthread_t thread, void **value_ptr); 在 B 线程里调用这个方法，第一个参数传 A 线程的 thread_id，第二个参数你可以扔一个指针进去。当 A 线程调用pthread_exit(void *value_ptr) 来结束的时候，A 的 value_ptr 就会到 pthread_join 的 value_ptr 去，你可以理解成 A 把它计算出来的结果放到 exit 函数里面去，然后其他 join 的线程就能拿到这个数据了。 在 B 线程 join 了 A 线程之后，B 线程会阻塞住，直到 A 线程跑完。A 线程跑完之后，自动被 detach，后续再要 join 的线程就会报 EINVAL。 1、新创建的线程默认是 join 属性，每一个 join 属性的线程都需要通过 pthread_join 来回收资源 如果 A 线程已经跑完，但没被 join 过，此时 B 线程要去 join A 线程的时候，pthread_join 是会立刻正确返回的，之后 A 线程就被 detach 了，占用的资源也会被释放。 如果 A 线程已经跑完，后面没人 join 它，它占用的资源就会一直在哪儿，变成僵尸线程。 所以要么在创建线程的时候就把线程设置为 detach 的线程，这样线程跑完以后不用 join，占用的资源自动回收。 要么不要忘记去 join 一下，把资源回收。 2、注意传递的参数的内存生命周期 虽然线程和进程共享同一个进程资源，但如果在 pthread_exit() 里面你传递的指针指向的是栈内存，那么在结束之后，这片内存还是会被回收的，具体到使用的时候，不同的系统又是不同的方案。 一定要在获得 value_ptr 之后，检查一下 value_ptr 是否 PTHREAD_CANCELED，因为如果你要等待的线程被 cancel 掉了，你拿到的就是这个数据。 3、多个线程 join 同一个线程 pthread_join 是允许多个线程等待同一个线程的结束的。如果要一个线程等待多个线程的结束，那就需要用下面提到的条件变量，或者 barrier。 但是多个线程 join 同一个线程的时候，情况就比较多。先建立一个约定：A 线程是要被 join 的线程，BCDEF 是要等待 A 线程结束的线程。下面说一下每种情况： A 线程正在运行，BCDEF 线程发起对 A 的 join，发起 join 结束后，A 仍然在运行中 此时 BCDEF 线程都会被阻塞，等待 A 线程的结束。A 线程结束之后，BCDEF 都被唤醒，能够正常获得 A 线程通过pthread_exit() 返回的数据。 A 线程正在运行，BCDEF 线程发起对 A 的 join，BCD 发起 join 成功后，A 线程结束，然后 EF 发起 join 此时 BCD 线程能够正常被唤醒，并完成任务，由于被 join 后 A 线程被 detach，资源释放，后续 EF 再要发起 join，就会EINVAL。 A 线程正在运行，且运行结束。此时 BCDEF 发起对 A 的 join。 此时谁先调用成功，谁就能完成任务，后续再要 join 的就都会 EINVAL。一旦有一个线程 join 成功，A 立刻被 detach，资源释放，然后后面其他的线程就都不会 join 成功。 总的来说，只要线程运行结束，并且被 detach 了，后面再 join 就不行了，只要线程还在运行中，就能 join。如果运行结束了，第一次被 join 之后，线程就被 detach 了，后续就不能 join。当然了，如果线程本来就是 detach 属性的线程，那任何时候都无法被 join。 九、Condition Variables 条件变量pthread_join 解决的是多个线程等待同一个线程的结束。条件变量能在合适的时候唤醒正在等待的线程。具体什么时候合适由你自己决定。它必须要跟互斥锁联合起来用。 场景： B 线程和 A 线程之间有合作关系，当 A 线程完成某件事情之前，B 线程会等待。当 A 线程完成某件事情之后，需要让 B 线程知道，然后 B 线程从等待状态中被唤醒，然后继续做自己要做的事情。 如果不用条件变量的话，就是搞个 volatile 变量，然后让其他线程不断轮询，一旦这个变量到了某个值，就可以让线程继续。如果有多个线程需要修改这个变量，那就再加个互斥锁或者读写锁。 这做法太蠢，还特别浪费 CPU 时间。 大致的实现原理： 一个条件变量背后有一个池子，所有需要 wait 这个变量的线程都会进入这个池子。当有线程扔出这个条件变量的 signal，系统就会把这个池子里面的线程挨个唤醒。 1、相关宏和函数 PTHREAD_COND_INITIALIZERint pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_signal(pthread_cond_t cond);int pthread_cond_broadcast(pthread_cond_t cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 原则上 pthread_cond_signal 是只通知一个线程，pthread_cond_broadcast 是用于通知很多线程。但 POSIX 标准也允许让 pthread_cond_signal 用于通知多个线程，不强制要求只允许通知一个线程。具体看各系统的实现。 另外，在调用 pthread_cond_wait 之前，必须要申请互斥锁，当线程通过 pthread_cond_wait 进入 waiting 状态时，会释放传入的互斥锁。 下面先给一个条件变量的使用例子，然后再讲需要注意的点。 void thread_waiting_for_condition_signal (){ pthread_mutex_lock(&amp;mutex); while (operation_queue == NULL) { pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); } /\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/ /\\* 做一些关于operation_queue的事 */ /*********************************/ pthread\\_mutex\\_unlock(&amp;mutex); } void thread_prepare_queue (){ pthread_mutex_lock(&amp;mutex); /\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/ /\\* 做一些关于operation_queue的事 */ /*********************************/ pthread\\_cond\\_signal(&amp;condition\\_variable\\_signal); // 事情做完了之后要扔信号给等待的线程告诉他们做完了 pthread\\_mutex\\_unlock(&amp;mutex); /\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*/ /\\* 这里可以做一些别的事情 */ /**************************/ ... pthread_exit((void *) 0); } 1、一定要跟 mutex 配合使用 void thread_function_1 (){ done = 1; pthread_cond_signal(&amp;condition_variable_signal);} void thread_function_2 (){ while (done == 0) { pthread_cond_wait(&amp;condition_variable_signal, NULL); }} 这样当然不行。 这里有非常精巧的情况：在 thread_function_2 发现 done = 0 的时候，准备要进行下一步的 wait 操作。在具体开始下一步的 wait 操作之前，thread_function_1 完成了设置 done，发送信号的事情。thread_function_2 还没来得及 waiting，thread_function_1 就把信号发出去了，也没人接收这信号，thread_function_2 继续执行 waiting 之后，就只能一直等待。 2、一定要检测你要操作的内容 void thread_function_1 (){ pthread_mutex_lock(&amp;mutex); ... operation\\_queue = create\\_operation_queue(); ... pthread\\_cond\\_signal(&amp;condition\\_variable\\_signal); pthread\\_mutex\\_unlock(&amp;mutex); } void thread_function_2 (){ pthread_mutex_lock(&amp;mutex); … pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); … pthread_mutex_unlock(&amp;mutex);} 这样当然不行。 比如 thread_function_1 直接执行完，operation_queue 也初始化好了，信号也扔出去了。这时候 thread_function_2 刚刚启动，由于它没有去先检查 operation_queue 是否可用，直接就进入 waiting 状态。然而事实是 operation_queue 早已搞定，再也不会收到 operation_queue 创建好的信号，thread_function_2 也不知道 operation_queue 已经好了，就只能一直等待。 3、一定要用 while 来检测要操作的内容而不是 if void thread_function_1 (){ pthread_mutex_lock(&amp;mutex); done = 1; pthread_cond_signal(&amp;condition_variable_signal); pthread_mutex_unlock(&amp;mutex);} void thread_function_2 (){ pthread_mutex_lock(&amp;mutex); if (done == 0) { pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); } pthread_mutex_unlock(&amp;mutex);} 这样行不行？大多数情况行，但是用 while 更加安全。 如果有别人写一个线程去把这个 done 设置成 0，期间没有申请 mutex 锁。那么这时用 if 去判断的话，由于线程已经从 wait 状态唤醒，它会直接做下面的事情，而全然不知 done 的值已经变了。 如果这时用 while 去判断的话，在 pthread_cond_wait 解除 wait 状态之后，会再去 while 判断一次 done 的值，只有这次done的值对了，才不会进入wait。如果这期间done被别的不长眼的线程给改了，while补充的那一次判断就帮了你一把，能继续进入waiting。 不过这解决不了根本问题哈，如果那个不长眼的线程在while的第二次判断之后改了done，那还是要悲剧。根本方案还是要在改done的时候加mutex锁。 总而言之，用if也可以，毕竟不太容易出现不长眼的线程改done变量不申请加mutex锁的。用while的话就多了一次判断，安全了一点，即便有不长眼的线程干了这么龌龊的事情，也还能hold住。 扔信号的时候，在临界区里面扔，不要在临界区外扔 void thread_function_1 () { pthread_mutex_lock(&amp;mutex); done = 1; pthread_mutex_unlock(&amp;mutex); pthread\\_cond\\_signal(&amp;condition\\_variable\\_signal); } void thread\\_function\\_2 () { pthread\\_mutex\\_lock(&amp;mutex); if (done == 0) { pthread\\_cond\\_wait(&amp;condition\\_variable\\_signal, &amp;mutex); } pthread\\_mutex\\_unlock(&amp;mutex); } 这样行不行？当然不行。为什么不行？《Advanced Programming in the UNIX Enviroment 3 Edtion》这本书里也把扔信号的事儿放在临界区外面了呢。 插播： （此处张扬同学指出《APUE》在这里有一段论述，在这里我把这段摘下来） 《APUE》中关于这个问题是这么描述的： When we put a message on the work queue, we need to hold the mutex, but we don’t need to hold the mutex when we signal the waiting threads. As long as it is okay for a thread to pull the message off the queue before we call cond_signal, we can do this after releasing the mutex. 在临界区外扔signal这种做法需要满足一些前提，这种做法不属于一种普适做法。所以我认为在制定编程规范的时候，应该禁止这种做法。在这份资料的第5页也对这个问题有一段小的论证。它的建议也是ALWAYS HOLD THE LOCK WHILE SIGNALING。 上面提到的资料的原文如下： TIP: ALWAYS HOLD THE LOCK WHILE SIGNALINGAlthough it is strictly not necessary in all cases, it is likely simplest andbest to hold the lock while signaling when using condition variables. Theexample above shows a case where you must hold the lock for correctness;however, there are some other cases where it is likely OK not to, butprobably is something you should avoid. Thus, for simplicity, hold thelock when calling signal.The converse of this tip, i.e., hold the lock when calling wait, is not justa tip, but rather mandated by the semantics of wait, because wait always(a) assumes the lock is held when you call it, (b) releases said lock whenputting the caller to sleep, and (c) re-acquires the lock just before returning.Thus, the generalization of this tip is correct: hold the lock whencalling signal or wait, and you will always be in good shape. 插播结束 不行就是不行，哪怕是圣经上这么写，也不行。哼。 就应该永远都在临界区里面扔条件信号，我画了一个高清图来解释这个事情，图比较大，可能要加载一段时间： 看到了吧，1的情况就是在临界区外扔信号的坏处。由于在临界区外，其他线程要申请加mutex锁是可以成功的，然后这个线程要是改了你的敏感数据，你就只能去哭了… semaphore 信号量pthread库里面藏了一个semaphore（感谢评论区张扬指正：semaphore是进程间PV，也属于posix标准的组成部分，故前面的说法并不准确。），man手册里面似乎也找不到semaphore相关的函数。 semaphore事实上就是我们学《操作系统》的时候所说的PV操作。 你也可以把它理解成带有数量控制的互斥锁，当sem_init(&amp;sem, 0, 1);时，他就是一个mutex锁了。 场景：比如有3台打印机，有5个线程要使用打印机，那么semaphore就会先记录好有3台，每成功被申请一次，就减1，减到0时，后面的申请就会被拒绝。 它也可以用mutex和条件变量来实现，但实际上还是用semaphore比较方便。 相关函数 int sem_destroy(sem_t sem); int sem_init(sem_t sem, int pshared, unsigned int value); int sem\\_wait(sem\\_t *sem); // 如果sempahore的数值还够，那就semaphore数值减1，然后进入临界区。也就是传说中的P操作。 int sem\\_post(sem\\_t *sem); // 这个函数会给semphore的值加1，也就是V操作。 int sem\\_getvalue(sem\\_t \\*sem, int \\*valp); // 注意了，它把semaphore的值通过你传进去的指针告诉你，而不是用这个函数的返回值告诉你。 要注意的地方semaphore下的死锁mutex下的死锁比较好处理，因为mutex只会锁一个资源(当semaphore的值为1时，就是个mutex锁)，按照顺序来申请mutex锁就好了。但是到了semaphore这里，由于资源数量不止1个，死锁情况就显得比较复杂。 要想避免死锁，即便采用前面提到的方案：按照顺序加锁，一旦出现加锁失败，就释放所有资源。这招也行不通。假设这样一个情况，当前系统剩余资源情况如下： 剩余资源： 全部系统资源A:3 A:10B:2 B:10C:4 C:10 此时有两个线程：t1, t2。 t1需要3个A，4个B，1个Ct2需要2个A，2个B，2个C 根据当前剩余资源列表来看，t2可以得到执行，不会出现死锁。 假设我们采用旧方案：顺序申请加锁，加锁失败就释放。我们按照CPU时间来推演一个： 1. t1申请3个A -&gt; 成功 2. t2申请2个A -&gt; 失败，等待 3. t1申请4个B -&gt; 失败，等待，并释放3个A 4. t1申请3个A -&gt; 成功 5. t2申请2个A -&gt; 失败，等待 6. t1申请4个B -&gt; 失败，等待，并释放3个A 7. t1申请3个A -&gt; 成功 8. t2申请2个A -&gt; 失败，等待 9. t1申请4个B -&gt; 失败，等待，并释放3个A … 发现没有，这时候t1和t2都得不到执行，但实际上系统的剩余资源是满足t2的要求的，但由于运气不好，抢资源抢不过t1，在有新的资源被释放之前，这俩线程就一直在那儿抢来抢去得不到执行了。 要解决这样的问题，就需要采用银行家算法，银行家算法描述起来很简单：获取所有候选线程的需求，随机取一个假设资源分配出去，看是否能够分配成功。如果不能，就换一个候选者，再进行资源分配。直到有线程满足需求为止。如果都不能满足，那就挂起所有线程，等待新的资源释放。 也就是可以理解成很多个人去贷款，银行家先假设你们都能按期还得起钱，按照你们的需求给你们派钱，不过这不是真的派出去了，只是先写在纸上，银行家一推算，卧槽，到后面会出现资金缺口，那就换一种派发方式，直到没有资金缺口为止。 说白了，你需要在你的程序里面建立一个资源分配者的角色，所有待分配资源的线程都去一个池子里排队，然后这个资源分配者一次只允许一个线程来请求资源，如果请求失败，就换下一个，如果池子里没有线程能够被满足需求，那就集体挂起，然后等有新的资源来了，就再把这些线程一个一个叫过来进行资源分配。 BarriersBarrier可以理解成一个mile stone。当一个线程率先跑到mile stone的时候，就先等待。当其他线程都到位之后，再从等待状态唤醒，继续做后面的事情。 场景：超大数组排序的时候，可以采用多线程的方案来排序。比如开10个线程分别排这个超大数组的10个部分。必须要这10个线程都完成了各自的排序，你才能进行后续的归并操作。先完成的线程会挂起等待，直到所有线程都完成之后，才唤醒所有等待的线程。 前面有提到过条件变量和pthread_join，前者是在做完某件事情通知其他线程，后者是在线程结束之后让其他线程能够获得执行结果。如果有多个线程同时做一件事情，用上面这两者可以有次序地进行同步。另外，用semaphore也可以实现Barrier的功能。 但是我们已经有Barrier了好吗！你们能不要把代码搞那么复杂吗！ 相关宏和函数int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *restrict attr, unsigned count);int pthread_barrier_destroy(pthread_barrier_t barrier);int pthread_barrier_wait(pthread_barrier_t barrier); pthread_barrier_wait在唤醒之后，会有两种返回值：0或者PTHREAD_BARRIER_SERIAL_THREAD，在众多线程中只会有一个线程在唤醒时得到PTHREAD_BARRIER_SERIAL_THREAD的返回，其他返回都是0。拿到PTHREAD_BARRIER_SERIAL_THREAD返回的，表示这是上天选择的主线程～ 要注意的地方其实Barrier很少被错用，因为本来也没几个函数。更多的情况是有人不知道有Barrier，然后用其他的方式实现了类似Barrier的功能。知道就好了。 关于attrthread创建thread的时候是可以设置attr的：detachstate、guardsize、stackaddr、stacksize。一般情况下我都是采取默认的设置。只有在我非常确定这个线程不需要跟其他线程协作的时候，我会把detachstate设置为PTHREAD_CREATE_DETACHED。 mutex创建mutex的时候也是可以设置attr的：process-shared、robust、type。一般情况下尽量不要出现跨进程的锁共享，万一有个相关进程被酒杀(kill 9)了，而且死之前它抱着锁没放，你后面的事情就麻烦了，基本无解。process-shared和robust就是跟跨进程有关。 关于type，我强烈建议显式设置为PTHREAD_MUTEX_ERRORCHECK。在Linux下，默认的type是PTHREAD_MUTEX_NORMAL。这在下面这种情况下会导致死锁： void thread_function(){ pthread_mutex_lock(&amp;mutex); foo(); pthread_mutex_unlock(&amp;mutex);} void foo(){ pthread_mutex_lock(&amp;mutex); pthread_mutex_unlock(&amp;mutex);} 上面的代码看着很正常是吧？但由于在调用foo之前，mutex已经被锁住了，于是foo就停在那边等待thread_function释放mutex。但是！thread_function必须要等foo跑完才能解锁，然后现在foo被卡住了。。。 如果type设置为PTHREAD_MUTEX_ERRORCHECK，那在foo里面的pthread_mutex_lock就会返回EDEADLK。如果你要求执行foo的时候一定要处于mutex的临界区，那就要这么判断。 如果type设置为PTHREAD_MUTEX_RECURSIVE，也不会产生死锁，但不建议用这个。PTHREAD_MUTEX_RECURSIVE使用的场景其实很少，我一时半会儿也想不到哪个场景不得不采用PTHREAD_MUTEX_RECURSIVE。 嗯，其他应该没什么了吧。 总结这篇文章主要讲了pthread的各种同步机制相关的东西：mutex、reader-writter、spin、cleanup callbacks、join、condition variable、semaphore、barrier。其中cleanup callbacks不算是同步机制，但是我看到也有人拿这个作为同步机制的一部分写在程序中，这是不对的！所以我才写了一下这个。 文章很长，相信你们看到这里也不容易，看完了这篇文章，你对多线程编程的同步机制应该可以说比较了解了。但我还要说的是，多线程编程的复杂点不仅仅在于同步机制，例如多线程跟系统信号的协作、多线程创建进程后的协作和控制、多线程和I/O之间的协作和控制、函数的可重入性等，我看我什么时候有时间再写这些内容了。","tags":[]},{"title":" LazyTableImages\t\t","date":"2019-03-04T08:27:03.000Z","path":"2019/03/04/lazytableimages/","text":"LazyTableImages 苹果官网、Demo下载地址 滑动的同时在请求数据，虽然异步，但在渲染的时候就会影响性能。 一、代码解析1、IconDownloader 类 功能：图片下载、取消 - (void)startDownload{ { \\[\\[NSOperationQueue mainQueue\\] addOperationWithBlock: ^{ // Set appIcon and clear temporary data/image UIImage * image = \\[\\[UIImage alloc\\] initWithData:data\\]; if (image.size.width != kAppIconSize || image.size.height != kAppIconSize) { CGSize itemSize = CGSizeMake(kAppIconSize, kAppIconSize); UIGraphicsBeginImageContextWithOptions(itemSize, NO, 0.0f); CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height); \\[image drawInRect:imageRect\\]; self.appRecord.appIcon = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); } else { self.appRecord.appIcon = image; } }\\]; } } - (void)cancelDownload{ [self.sessionTask cancel]; _sessionTask = nil;} 主要看 startDownload 方法，它在子线程中请求数据，主线程中刷新 UI。 这里请求到的图片并没有直接赋值给 imageView：图片请求成功后将尺寸与 kAppIconSize 宏进行比较，调用 Graphics 方法重新画了一张位图。简单的介绍一下： iOS 加载的图片都是位图，JPEG 和 PNG，位图就是像素的集合。 在不同的显示屏上一个像素的字节大小不同，一张图片在渲染到屏幕上必经的就是解压缩过程，因为系统需要知道图片像素的详细信息，才能进行渲染。所以，未经过解压缩的图片都要经过系统的强制解压缩才能成功显示在屏幕上。 什么时候需要解压缩？当需要加载大量图片的时候，为了不影响性能，就需要我们手动”解压缩”，调用系统 API 画一张。附一篇关于解压缩的博客：谈谈 iOS 中图片的解压缩 2、ParseOperation 类 使用系统的 NSXMLParser 类，实现 协议方法，解析 xml。 3、RootViewController 类 功能：界面展示，懒加载逻辑。 - (void)terminateAllDownloads{ NSArray *allDownloads = [self.imageDownloadsInProgress allValues]; [allDownloads makeObjectsPerformSelector:@selector(cancelDownload)]; \\[self.imageDownloadsInProgress removeAllObjects\\]; } 取消图片下载，在 dealloc、didReceiveMemoryWarning 方法中调用，Demo 中没有体现。 - (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ { { if (!appRecord.appIcon) { if (self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO) { [self startIconDownload:appRecord forIndexPath:indexPath]; } // if a download is deferred or in progress, return a placeholder image cell.imageView.image = [UIImage imageNamed:@”Placeholder.png”]; } else { cell.imageView.image = appRecord.appIcon; } } } return cell; } dragging 是否正在拖动；decelerating 是否正在减速，当停止拖拽后视图仍在滚动时返回 YES。 未加载过图片 &amp; 表格停止拖动 &amp; 滚动已经停止时，调用 startIconDownload:forIndexPath:indexPath: 方法请求图片并加载；否则，加载占位图。 #pragma mark - UIScrollViewDelegate // ——————————————————————————-// scrollViewDidEndDragging:willDecelerate:// Load images for all onscreen rows when scrolling is finished.// -------------------------------------------------------------------------------- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate{ if (!decelerate) { [self loadImagesForOnscreenRows]; }} // ——————————————————————————-// scrollViewDidEndDecelerating:scrollView// When scrolling stops, proceed to load the app icons that are on screen.// -------------------------------------------------------------------------------- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{ [self loadImagesForOnscreenRows];} 在 UIScrollViewDelegate 中判断：当视图停止滚动时，加载当前屏幕上 cell 的图片。 - (void)loadImagesForOnscreenRows{ if (self.entries.count &gt; 0) { NSArray visiblePaths = [self.tableView indexPathsForVisibleRows]; for (NSIndexPath indexPath in visiblePaths) { AppRecord *appRecord = (self.entries)[indexPath.row]; if (!appRecord.appIcon) // Avoid the app icon download if the app already has an icon { \\[self startIconDownload:appRecord forIndexPath:indexPath\\]; } } } } 方法内获取当前显示的 cell，循环加载图片。 - (void)startIconDownload:(AppRecord )appRecord forIndexPath:(NSIndexPath )indexPath{ IconDownloader *iconDownloader = (self.imageDownloadsInProgress)[indexPath]; if (iconDownloader == nil) { iconDownloader = [[IconDownloader alloc] init]; iconDownloader.appRecord = appRecord; [iconDownloader setCompletionHandler:^{ UITableViewCell *cell = \\[self.tableView cellForRowAtIndexPath:indexPath\\]; // Display the newly loaded image cell.imageView.image = appRecord.appIcon; // Remove the IconDownloader from the in progress list. // This will result in it being deallocated. \\[self.imageDownloadsInProgress removeObjectForKey:indexPath\\]; }\\]; (self.imageDownloadsInProgress)\\[indexPath\\] = iconDownloader; \\[iconDownloader startDownload\\]; } } 这个方法内调用 [iconDownloader startDownload] 开启图片下载。 self.imageDownloadsInProgress 是 NSMutableDictionary 类型，主要用来缓存 IconDownloader 的实例。 缓存 IconDownloader 的实例，为了取消加载时使用。 [self.imageDownloadsInProgress removeObjectForKey:indexPath]，请求成功后删除 indexPath 位置的下载实例，因为需要下载时必然是当前未加载过图片，加载成功后 if(!appRecord.appIcon) 为假，不会再进行下载，所以IconDownloader 的实例就没必要继续缓存了。","tags":[]},{"title":" 混淆加固策略\t\t","date":"2019-03-04T04:00:26.000Z","path":"2019/03/04/e6-b7-b7-e6-b7-86-e5-8a-a0-e5-9b-ba-e7-ad-96-e7-95-a5/","text":"原文：iOS-代码混淆加固策略 一、前言iOS 系统是封闭的，App 上架需要通过 App Store，安全性来说相当高。但是对于大厂和知名 App 而言，别人给的安全保障永远没有自己做的来得踏实。所以对于大厂、少部分企业级和金融支付类应用来说加固是相当重要的。 下面是目前几个专业加固大厂提供的加固策略。 1、网易 网易安全主要操作： ①、防静态分析。包括字符串加密、符号混淆、代码逻辑混淆和游戏存档加密； ②、防动态调试、反调试和通信安全（数据加密）； ③、外挂检测。加速挂、内存修改挂和自动任务挂等。 2、爱加密 3、safengine 4、几维安全 5、梆梆安全 本文将针对以上几点进行实现，对于一些不太容易实现的将会做方向性讨论。 字符串加密 隐患：程序里面的明文字符串给静态分析提供了极大的帮助，比如说根据界面特殊字符串提示信息，从而定义到程序代码块，或者获取程序使用的一些网络接口。 加固：对程序中使用到字符串的地方，首先获取到使用到的字符串，当然要注意哪些是能加密，哪些不能加密的，然后对字符串进行加密，并保存加密后的数据，再在使用字符串的地方插入解密算法，这样就很好的保护了明文字符串。 代码混淆（方法名、类名、变量名、符号表） 隐患：只要使用 class-dump 把应用的类和方法定义 dump 下来，然后根据方法名就能够判断很多程序的处理函数是在哪。从而进行 hook 等操作。 加固：对于程序中的类名方法名，自己产生一个随机的字符串来替换这些定义的类名和方法名，但是不是所有类名、方法名都能替换的，要过滤到系统有关的函数以及类，可以参考下开源项目：https://github.com/Polidea/ios-class-guard 代码逻辑混淆 隐患：目前的 iOS 应用找到可执行文件然后拖到 Hopper Disassembler 或者 IDA 里，程序的逻辑基本一目了然。 加固：可以基于 Xcode 使用的编译器 clang，然后在中间层 IR 实现自己的一些混淆处理，比如加入一些无用的逻辑块、代码块，以及加入各种跳转但是又不影响程序原有的逻辑。可以参考下开源项目：https://github.com/obfuscator-llvm/obfuscator/ 当然开源项目中也是存在一些问题的，还需自己再去做一些优化工作。 反调试 隐患：目前大多数 iOS 应用对于简单的反调试功能都没有，更别说注入检测，以及其它的一些检测了。 加固：加入安全 SDK，包括多处调试检测，注入检测，越狱检测，关键代码加密，防篡改等等功能。并提供接口给开发者处理检测结果。 二、字符串加密对字符串加密的方式目前所了解到掌握到的最可靠方式就是用脚本将代码中的所有标记需要加密的字符串进行异或转换，这样代码中就不存在明文字符串了。当然第三方的字符串加密不可能这么简单。 不过为了增加字符串加密的难度复杂性，可以先将字符串用加密工具（如 AES、base64 等）转换，然后把转换后的字符串和解密的钥匙放在工程中，用异或转换，把解密钥匙和加密后的字符串转换，这样就有两层保障，增加了复杂度。 创建任意一个工程，在工程中写入下面的代码，并在每句打上断点。 / 加密NSString字符串 /NSString * s = @”Hello World”;NSLog(@”%@”, s); / 加密char字符串 /char cs = “Super Man”;NSLog(@”%s”, cs); 选择 Xcode -&gt; Debug -&gt; Debug Workflow -&gt; Always Show Disassembly，这样就可以在断点处进入汇编模式界面。 最后运行程序，断点处进入汇编模式界面。 你会发现，代码里的字符串内容暴露在了汇编模式中，这会导致别人在逆向分析你的工程时能看见字符串内容，一般接口、域名、加解密钥匙串、AppKey、AppId 等比较重要的东西会放在客户端用作字符串，这就很容易暴露出来。 处理步骤： 1、首先需要在工程代码中进行修改，把下面的宏和 decryptConfusionCS、decryptConstString 函数放入代码。 /* * @brief 字符串混淆解密函数。将 char[] 形式字符数组和 0xAA 异或运算解密。 /extern char decryptConfusionCS(char string){ char origin_string = string; while(string) { string ^= 0xAA; string++; } return origin_string;} /* * @brief 解密函数。 * @return 返回 NSString 类型。 /extern NSString decryptConstString(char string){ // 先执行decryptConfusionString函数解密字符串 char str = decryptConfusionCS(string); // 获取字符串的长度 unsigned long len = strlen(str); NSUInteger length = \\[\\[NSString stringWithFormat:@&quot;%lu&quot;,len\\] integerValue\\]; return \\[\\[NSString alloc\\] initWithBytes:str length:length encoding:NSUTF8StringEncoding\\]; } /* * @brief 使用 confusion_key 宏控制加密解密 * 1、当 confusion_key 宏被定义时，执行解密脚本，对字符串解密 * 2、当 confusion_key 宏被删除或未定义时，执行加密脚本，对字符串进行加密 */ #define confusion_key #ifdef confusion_key // 解密 #define confusion_NSSTRING(string) decryptConstString(string) // 返回结果是 NSString 类型 #define confusion_CSTRING(string) decryptConfusionCS(string) // 返回结果是 char* 类型的 #else // 加密 #define confusion_NSSTRING(string) @string // 加密 NSString 类型的内容 #define confusion_CSTRING(string) string // 加密 char * 类型的内容 #endif 2、用宏包含每个需要转换的字符串。 { /* 使用 confusion_NSSTRING 宏包含需要加密的 NSString 字符串 / NSString s = confusion_NSSTRING(“Hello World”); NSLog(@”%@”, s); /\\* 使用 confusion_CSTRING 宏包含需要加密的 char* 字符串 */ char * cs = confusion_CSTRING(&quot;Super Man&quot;); NSLog(@&quot;%s&quot;, cs); } 3、使用终端 cd 到需要加密的工程目录下，执行 touch confusion.py 和 touch decrypt.py 命令，生产加密和解密脚本文件。 $ touch confusion.py$ touch decrypt.py 4、把下面代码加入加密脚本 confusion.py。 #!/usr/bin/env python# encoding=utf8# -- coding: utf-8 --# author by heyujia# 脚本将会用于对指定目录下的.h .m源码中的字符串进行转换# 替换所有字符串常量为加密的char数组，形式((char[]){1, 2, 3, 0}) import importlibimport osimport reimport sys # replace替换字符串为((char[]){1, 2, 3, 0})的形式，同时让每个字节与0xAA异或进行加密# 当然可以不使用0xAA 使用其他的十六进制也行 例如0XBB、0X22、0X11def replace(match): string = match.group(2) + ‘\\x00’ replaced_string = ‘((char []) {‘ + ‘, ‘.join([“%i” % ((ord(c) ^ 0xAA) if c != ‘\\0’ else 0) for c in list(string)]) + ‘})’ return match.group(1) + replaced_string + match.group(3) # obfuscate方法是修改传入文件源代码中用confusion_NSSTRING标记的所有字符串# 使用replace函数对字符串进行异或转换def obfuscate(file): with open(file, ‘r’) as f: code = f.read() f.close() code = re.sub(r’(confusion_NSSTRING\\(|confusion_CSTRING\\()”(.*?)”(\\))’, replace, code) code = re.sub(r’//#define ggh_confusion’, ‘#define ggh_confusion’, code) with open(file, ‘w’) as f: f.write(code) f.close() # openSrcFile方法是读取源码路径下的所有.h和.m 文件# 对每个文件执行obfuscate函数def openSrcFile(path): print(“混淆的路径为 “+ path) # this folder is custom for parent,dirnames,filenames in os.walk(path): #case 1: # for dirname in dirnames: # print((&quot; parent folder is:&quot; + parent).encode(&apos;utf-8&apos;)) # print((&quot; dirname is:&quot; + dirname).encode(&apos;utf-8&apos;)) #case 2 for filename in filenames: extendedName = os.path.splitext(os.path.join(parent,filename)) if (extendedName\\[1\\] == &apos;.h&apos; or extendedName\\[1\\] == &apos;.m&apos;): print(&quot;处理源代码文件: &quot;+ os.path.join(parent,filename)) obfuscate(os.path.join(parent,filename)) #这里需要修改源码的路径为自己工程的文件夹名称srcPath = ‘../SSDemo’ if __name__ == ‘__main__‘: print(“本脚本用于对源代码中被标记的字符串进行加密”) if len(srcPath) &gt; 0: openSrcFile(srcPath) else: print(&quot;请输入正确的源代码路径&quot;) sys.exit() 5、把下面代码放入解密脚本 decrypt.py。 #!/usr/bin/env python# encoding=utf8# -- coding: utf-8 --# author by heyujia# 解密脚本# 替换所有标记过的加密的char数组为字符串常量，”” import importlibimport osimport reimport sys # 替换((char[]){1, 2, 3, 0})的形式为字符串，同时让每个数组值与0xAA异或进行解密def replace(match): string = match.group(2) decodeConfusion_string = “” for numberStr in list(string.split(‘,’)): if int(numberStr) != 0: decodeConfusion_string = decodeConfusion_string + “%c” % (int(numberStr) ^ 0xAA) replaced_string = ‘\\“‘ + decodeConfusion_string + ‘\\“‘ print(&quot;replaced\\_string = &quot; + replaced\\_string) return match.group(1) + replaced_string + match.group(3) # 修改源代码，加入字符串加密的函数def obfuscate(file): with open(file, ‘r’) as f: code = f.read() f.close() code = re.sub(r’(confusion_NSSTRING\\(|confusion_CSTRING\\()\\(\\(char \\[\\]\\) \\{(.?)\\}\\)(\\))’, replace, code) code = re.sub(r’[/]#define ggh_confusion’, ‘//#define ggh_confusion’, code) with open(file, ‘w’) as f: f.write(code) f.close() #读取源码路径下的所有.h和.m 文件def openSrcFile(path): print(“解密路径： “+ path) # this folder is custom for parent,dirnames,filenames in os.walk(path): #case 1: # for dirname in dirnames: # print((&quot; parent folder is:&quot; + parent).encode(&apos;utf-8&apos;)) # print((&quot; dirname is:&quot; + dirname).encode(&apos;utf-8&apos;)) #case 2 for filename in filenames: extendedName = os.path.splitext(os.path.join(parent,filename)) #读取所有.h和.m 的源文件 if (extendedName\\[1\\] == &apos;.h&apos; or extendedName\\[1\\] == &apos;.m&apos;): print(&quot;已解密文件:&quot;+ os.path.join(parent,filename)) obfuscate(os.path.join(parent,filename)) #源码路径srcPath = ‘../SSDemo’if __name__ == ‘__main__‘: print(“字符串解混淆脚本，将被标记过的char数组转为字符串，并和0xAA异或。还原代码”) if len(srcPath) &gt; 0: openSrcFile(srcPath) else: print(“请输入正确的源代码路径！”) sys.exit() 5、根据自己的需求修改下脚本里面的代码和文件路径 srcPath = ‘../SSDemo’ 。 6、注释工程代码中的宏定义 #define confusion_key，然后执行加密脚本，在终端中输入 python confusion.py。 $ python confusion.py本脚本用于对源代码中被标记的字符串进行加密混淆的路径为 ../SSDemo处理源代码文件: ../SSDemo/SSDemo/AppDelegate.h处理源代码文件: ../SSDemo/SSDemo/ViewController.m处理源代码文件: ../SSDemo/SSDemo/main.m处理源代码文件: ../SSDemo/SSDemo/AppDelegate.m处理源代码文件: ../SSDemo/SSDemo/ViewController.h处理源代码文件: ../SSDemo/SSDemoUITests/SSDemoUITests.m处理源代码文件: ../SSDemo/SSDemoTests/SSDemoTests.m 处理后，工程中的代码如下： { NSString * s = confusion_NSSTRING(((char []) {226, 207, 198, 198, 197, 138, 253, 197, 216, 198, 206, 0})); NSLog(@”%@”, s); char* cs = confusion_CSTRING(((char \\[\\]) {249, 223, 218, 207, 216, 138, 231, 203, 196, 0})); NSLog(@&quot;%s&quot;, cs); } 此时字符串已被加密，运行程序一切正常。 2019-03-04 11:05:35.091685+0800 SSDemo[4368:2059292] Hello World2019-03-04 11:05:35.091843+0800 SSDemo[4368:2059292] Super Man 汇编模式下看。 加密后汇编界面看不见字符串内容了，但是用来解密的方法暴露在了汇编界面，所以还需要对方法名、变量名、类名等做混淆。 7、取消注释工程代码中的宏定义 #define confusion_key，然后执行解密脚本，在终端中输入 python decrypt.py。 SSDemo $ python decrypt.py字符串解混淆脚本，将被标记过的char数组转为字符串，并和0xAA异或。还原代码解密路径： ../SSDemo已解密文件:../SSDemo/SSDemo/AppDelegate.h已解密文件:../SSDemo/SSDemo/ViewController.mreplaced_string = “Hello World”replaced_string = “Super Man”已解密文件:../SSDemo/SSDemo/main.m已解密文件:../SSDemo/SSDemo/AppDelegate.m已解密文件:../SSDemo/SSDemo/ViewController.h已解密文件:../SSDemo/SSDemoUITests/SSDemoUITests.m已解密文件:../SSDemo/SSDemoTests/SSDemoTests.m 解密后： { /* 使用confusion_NSSTRING宏包含需要加密的NSString字符串 / NSString s = confusion_NSSTRING(“Hello World”); NSLog(@”%@”, s); /\\* 使用confusion_NSSTRING宏包含需要加密的char*字符串 */ char* cs = confusion_CSTRING(&quot;Super Man&quot;); NSLog(@&quot;%s&quot;, cs); } 解密后文本又变回了原样。 8、这里只是基本的异或转换加密，让代码中的字符串变成看不懂的 char[]，实际操作中远远不止这么简单。 ①、先用加密工具如：AES、Base64 等把需要转换的字符串先加密； ②、用异或转换加密的脚本把加密字符串进行转换（包括解密用的钥匙串）； ③、先异或解密字符串，然后根据解密钥匙串把字符串在转为可用的字符串。 还可以使用 NSLocalizedString 字符串本地化保护字符串。 要验证最终的混淆结果是否达到效果，你还需要学习如何破壳解密 IPA 如何动态静态逆向编程分析工程源码，先掌握逆向分析后在来做代码混淆，就能验证混淆结果是否有效。这篇文章 9、出现的问题 ①、报错时请查看下自己 Mac 电脑中的 python 版本，如果是 python3 就输入 python3 confusion.py。 ②、如果报 Non-ASCII character ‘\\xe8’ in file confusion.py on line 2 相关的错，请确定脚本的前面 3 行是 #!/usr/bin/env python# encoding=utf8# -- coding: utf-8 -- 必须有这三行代码，才能在脚本中输入中文。 ③、如果报 IndentationError: unexpected indent 请注意脚本中的每行代码的换行符和缩进格式必须标准。 ④、如果报错 SSDemo $ python decrypt.py File “decrypt.py”, line 25 return match.group(1) + replaced_string + match.group(3)SyntaxError: ‘return’ outside function 请注意脚本中的每行代码的换行符和缩进格式必须标准。 三、变量、方法名、类名混淆对于混淆这一块，网上基本都是 copy 念大婶的内容，没有创新和思考。网上的方法有缺陷，只能混淆方法名或者说自己固定的内容去替换。第一不自动，对于大项目而言每个方法名自己添加，太麻烦。第二变量混淆有问题，因为只是单纯的字符串替换，用宏代替。当遇到使用 ‘_’ 下划线访问变量时，就会出现错误。 对于变量、方法名、类名的混淆，其实和字符串混淆差不多，都是加密混淆，然后解密混淆。 不同的是，变量、方法名、类名的混淆目的是为了让别人反编译的时候不知道你的变量、方法、类是具体用来干什么的，不会像明文那样一目了然，增加逆向难度。混淆的内容不需要像字符串一样，最后程序运行时还要转成中文正常使用。 1、打开终端 cd 到需要混淆的工程目录下，输入 touch obConfusion.sh、touch obDecrypt.sh，生成机密加密混淆脚本文件和解密混淆脚本文件。 SSDemo $ touch obConfusion.shSSDemo $ touch obDecrypt.sh 2、在工程目录以外创建一个文件夹，用于保存加密时生成的加密文本内容，该内容会在解密是用到。 3、在 obConfusion.sh 和 obDecrypt.sh 文件中加入脚本内容。 加密混淆脚本内容： #!/bin/sh ############################################################### 代码混淆脚本 RyoHo 2016.2.25## ############################################################ #识别含有多字节编码字符时遇到的解析冲突问题export LC_CTYPE=Cexport LANG=C #配置项： #项目路径ProjectPath=”../SSDemo” #替换文本存放路径（不能在项目目录或其子目录）SecretFile=”/Users/cykj/Desktop/Temp/rlf”$(date +%Y%m%d)”_”$(date +%H%M) #第一个参数为项目路径if [[ $1 ]]thenif [[ $1 != “_” ]]; thenProjectPath=$1fifi #第二个参数指定密钥文件路径及文件名if [[ $2 ]]thenif [[ $2 != “_” ]]; thenSecretFile=$2fifi ############################################################################## #查找文本中所有要求混淆的属性\\方法\\类resultfiles=`grep ‘ob_[A-Za-z0-9_]*_fus’ -rl $ProjectPath` #查找结果为空则退出if [[ -z $resultfiles ]]thenecho “项目没有需要混淆的代码”exitelseecho “开始混淆代码…”echo &gt; $SecretFilefi x=$(awk ‘BEGIN{srand();k=0;} #随机数生成函数function random_int(min, max) {return int( rand()*(max-min+1) ) + min;} #随机字符串生成函数function random_string(len) {result=”UCS”k;alpbetnum=split(“a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z”, alpbet, “,”);for (i=0; i&lt;len; i++) {result = result””alpbet[ random_int(1, alpbetnum) ];}return result;}/ob_[A-Za-z0-9_]*_fus/{x = $0; #匹配需要混淆的属性变量方法while (match(x, “ob_[A-Za-z0-9_]*_fus”) &gt; 0) {tempstr=substr(x, RSTART, RLENGTH); #判断是否有之前已经找过的重复字符串for ( i = 0; i &lt; k; i++ ){if (strarr[i] == tempstr){break;}}if(i&lt;k){ #重复字符串，直接删除x=substr(x, RSTART+RLENGTH);continue;}else{ #不是重复字符串，添加到替换数组strarr[k++]=tempstr;}randomstr=random_string(20);printf(“%s:%s|”, tempstr,randomstr); #替换随机字符串gsub(tempstr,randomstr, x);x = substr(x, RSTART+RLENGTH);}}’ $resultfiles ) #加密对写入密钥文件echo $x &gt; $SecretFile recordnum=1while [[ 1 == 1 ]]; dorecord=`echo $x|cut -d “|” -f$recordnum`if [[ -z $record ]]thenbreakfirecord1=`echo $record|cut -d “:” -f1`echo “原项:”$record1record2=`echo $record|cut -d “:” -f2`echo “加密项:”$record2 #替换文件夹中所有文件的内容（支持正则） #单引号不能扩展sed -i ‘’ “s/${record1}/${record2}/g” `grep $record1 -rl $ProjectPath`echo “第”$recordnum”项混淆代码处理完毕”let “recordnum = $recordnum + 1”done #查找需要混淆的文件名并替换filerecordnum=1while [[ 1 == 1 ]]; dofilerecord=`echo $x|cut -d “|” -f$filerecordnum`if [[ -z $filerecord ]]thenbreakfifilerecord1=`echo $filerecord|cut -d “:” -f1` #echo “原项:”$filerecord1filerecord2=`echo $filerecord|cut -d “:” -f2` #echo “加密项:”$filerecord2 #改文件名 find $ProjectPath -name $filerecord1”*”| awk ‘BEGIN{frecord1=”‘“$filerecord1”‘“;frecord2=”‘“$filerecord2”‘“;finish=1}{filestr=$0;gsub(frecord1,frecord2,filestr);print “mv “ $0 “ “ filestr”;echo 第”finish”个混淆文件处理完毕”;finish++;}’|bashlet “filerecordnum = $filerecordnum + 1”done 执行加密脚本： SSDemo $ sh obConfusion.sh开始混淆代码…原项:ob_say_fus加密项:UCS1aqxdgwdNzwiQOcjuWaQx第1项混淆代码处理完毕 SSDemo $ sh obConfusion.sh项目没有需要混淆的代码 解密混淆脚本的内容： #!/bin/sh ######################################## 代码还原脚本 RyoHo 2018.03.15# ###################################### #识别含有多字节编码字符时遇到的解析冲突问题export LC_CTYPE=Cexport #配置项： #已经混淆的项目路径ProjectPath=”../SSDemo” #这个是文件路径而不是目录，是混淆的时候生成的文本文件路径，每次不一样。所以每次加密后，解密时需要更换路径SecretFile=”/Users/cykj/Desktop/Temp/rlf20190304_1344” #第一个参数为项目路径if [[ $1 ]]thenif [[ $1 != “_” ]]; thenProjectPath=$1fifi #第二个参数指定密钥文件路径及文件名if [[ $2 ]]thenif [[ $2 != “_” ]]; thenSecretFile=$2fifi ############################################################################## #内容还原x=`cat $SecretFile`recordnum=1while [[ 1 == 1 ]]; dorecord=`echo $x|cut -d “|” -f$recordnum`if [[ -z $record ]]thenbreakfirecord1=`echo $record|cut -d “:” -f1`echo “原项:”$record1record2=`echo $record|cut -d “:” -f2`echo “加密项:”$record2 #若项目中加密项与密钥文件的加密项不符合则退出程序searchresult=`grep $record2 -rl $ProjectPath`if [[ -z $searchresult ]]; thenecho “指定的密钥文件不能还原”exitfi #替换文件夹中所有文件的内容（支持正则） #单引号不能扩展sed -i ‘’ “s/${record2}/${record1}/g” $searchresultecho “第”$recordnum”项混淆代码还原完毕”let “recordnum = $recordnum + 1”done #文件还原filerecordnum=1while [[ 1 == 1 ]]; dofilerecord=`echo $x|cut -d “|” -f$filerecordnum`if [[ -z $filerecord ]]thenbreakfifilerecord1=`echo $filerecord|cut -d “:” -f1` #echo “原项:”$filerecord1filerecord2=`echo $filerecord|cut -d “:” -f2` #echo “加密项:”$filerecord2 #改文件名 find $ProjectPath -name $filerecord2”*”| awk ‘BEGIN{frecord1=”‘“$filerecord1”‘“;frecord2=”‘“$filerecord2”‘“;finish=1;}{filestr=$0;gsub(frecord2,frecord1,filestr);print “mv “ $0 “ “filestr “;echo 第”finish”个混淆文件还原完毕”finish++;}’|bashlet “filerecordnum = $filerecordnum + 1”done 执行解码脚本： SSDemo $ sh obDecrypt.shexport Apple_PubSub_Socket_Render=”/private/tmp/com.apple.launchd.1l9oMsXueg/Render”export GEM_HOME=”/Users/cykj/.rvm/gems/ruby-2.6.0-preview2”export GEM_PATH=”/Users/cykj/.rvm/gems/ruby-2.6.0-preview2:/Users/cykj/.rvm/gems/ruby-2.6.0-preview2@global”export HOME=”/Users/cykj”export IRBRC=”/Users/cykj/.rvm/rubies/ruby-2.6.0-preview2/.irbrc”export LANG=”zh_CN.UTF-8”export LC_CTYPE=”C”export LOGNAME=”cykj”export MY_RUBY_HOME=”/Users/cykj/.rvm/rubies/ruby-2.6.0-preview2”export OLDPWDexport PATH=”/Users/cykj/.rvm/gems/ruby-2.6.0-preview2/bin:/Users/cykj/.rvm/gems/ruby-2.6.0-preview2@global/bin:/Users/cykj/.rvm/rubies/ruby-2.6.0-preview2/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/cykj/.rvm/bin”export PWD=”/Users/cykj/Desktop/SSDemo”export RUBY_VERSION=”ruby-2.6.0-preview2”export SHELL=”/bin/bash”export SHLVL=”2”export SSH_AUTH_SOCK=”/private/tmp/com.apple.launchd.892oNF07Ru/Listeners”export TERM=”xterm-256color”export TERM_PROGRAM=”Apple_Terminal”export TERM_PROGRAM_VERSION=”404.1”export TERM_SESSION_ID=”BA420A1D-F03B-471F-A33D-FDB3E1BF5CBD”export TMPDIR=”/var/folders/yl/n6xlpycx5cg0869cspvt3bp80000gn/T/“export USER=”cykj”export XPC_FLAGS=”0x0”export XPC_SERVICE_NAME=”0”export _system_arch=”x86_64”export _system_name=”OSX”export _system_type=”Darwin”export _system_version=”10.13”export rvm_bin_path=”/Users/cykj/.rvm/bin”export rvm_path=”/Users/cykj/.rvm”export rvm_prefix=”/Users/cykj”export rvm_version=”1.29.4 (latest)”原项:ob_say_fus加密项:UCS1aqxdgwdNzwiQOcjuWaQx第1项混淆代码还原完毕 可以阅读、学习、理解脚本内容，该脚本是有针对性的混淆内容，可以自己修改脚本中的正则表达式来确定混淆的内容。目前脚本中只会替换文本中 ob_fus 格式的字符串（区分大小写，oB_fus 就不会做混淆），也会替换注释内容里的这种形式的字符串。对于使用下划线访问的变量属性，不会有影响，一样会替换成对应的混淆内容。 脚本源码地址：https://github.com/xkftkffz/DMHXDemo、https://github.com/heqingliang/CodeObfus 四、代码混淆开源工具 Obfuscator-LLVM KLGenerateSpamCode 代码生成器（iOSMixProject 代码生成器）、ChaosTool 第一项：文件夹绝对路径 示例： /Users/wangxiushuai/Desktop/测试/WxsTestDemo1/WxsTestDemo3第二项：修改源代码类名前缀 格式：-modifyClassNamePrefix [工程文件 xcodeproj 绝对路径] [原前缀]&gt;[新前缀] 示例：-modifyClassNamePrefix /Users/wangxiushuai/Desktop/测试/WxsTestDemo1/WxsTestDemo3.xcodeproj Wxs&gt;WxsTest第三项：修改工程名 格式：-modifyProjectName [原名称]&gt;[新名称] 示例：-modifyProjectName WxsTestDemo3&gt;WxsTestDemo4 注意：Podfile 被修改后需要手动 pod install第四项：生成垃圾代码 格式：-spamCodeOut [垃圾代码文件输出目录] [垃圾代码方法增加的参数名] 示例：-spamCodeOut /Users/wangxiushuai/Desktop/测试/WxsTestDemo1/Trash WxsTrash第五项：忽略这些文件夹 格式：-ignoreDirNames [忽略文件夹名称字符串] 示例：-ignoreDirNames 第三方库第六项：修改xxx.xcassets文件夹中的 png 资源文件名 格式：-handleXcassets第七项：删除工程目录下 .h .m .swift 文件中的注释和空行 格式：-deleteComments第八项：改变api名字，注意是随机的，这个更改最好不要提交，只用来上架，一次性操作，否则可能增加后续维护的负担 格式：-modifyAPIName 五、总结提供一个shell 脚本学习的网站 这种方法混淆能过审核么？ 单纯按照上面的方法审核一般是过不了的。 因为上面脚本中替换的字符串是随机无意义的，而苹果审核对于过多无意义的字符串会拒绝的。 如果要过审核，需要将替换的字符串改为有意义的字符串。可以自己定义一个有意义字符串列表，然后把原本方法名、变量名、类名等按照定义的列表去替换。 混淆的目的是为了防止别人破壳看源码的时候根据方法名类名等轻易就了解逻辑，混淆只是增加了逆向破解者的破解时间成本，只要多花一点时间，破壳者肯定是能完全看懂代码的，并不能做到阻止。 如果你混淆的目的是为了加固应用。你考虑的重点可能应该是 1、对 App 内部的所有数据加密，例如：App 中使用了数据库，对库本身加密，对库中的所有字段都加密。2、防止动态库的注入。每次启动检测 APP 内部的所有库。","tags":[]},{"title":" 互斥锁\t\t","date":"2019-03-03T15:50:17.000Z","path":"2019/03/03/e4-ba-92-e6-96-a5-e9-94-81/","text":"文章：百度百科 在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为”互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。 互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。 上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数（比如 1000 次）的 testandtest，这样可以在错误使用互斥锁时提高性能。 另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 互斥锁特点： 一次只能一个线程拥有互斥锁，其他线程只有等待。 互斥锁是在抢锁失败的情况下主动放弃 CPU 进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概 100ns 左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁。 条件变量的特点： 互斥锁一个明显的缺点是它只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。","tags":[]},{"title":" 自旋锁\t\t","date":"2019-03-03T14:55:22.000Z","path":"2019/03/03/e8-87-aa-e6-97-8b-e9-94-81/","text":"文章：百度百科 一、自旋锁自旋锁是专为防止多处理器并发而引入的一种锁，它在内核中大量应用于中断处理等部分。 自旋锁是为实现保护共享资源而提出一种锁机制（为了解决对某项资源的互斥使用）。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。 如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。 死锁。试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”，也无法获得资源，从而进入死循环。 过多占用 cpu 资源。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候，如果不成功，不会睡眠，会持续的尝试，单 cpu 的时候自旋锁会让其它 process 动不了。因此，一般自旋锁实现会有一个参数限定最多持续尝试次数。超出后, 自旋锁放弃当前time slice. 等下一次机会。 由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。 由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。信号量和读写信号量适合于保持时间较长的情况，它们会导致调用者睡眠，因此只能在进程上下文使用，而自旋锁适合于保持时间非常短的情况，它可以在任何上下文使用。如果被保护的共享资源只在进程上下文访问，使用信号量保护该共享资源非常合适，如果对共享资源的访问时间非常短，自旋锁也可以。但是如果被保护的共享资源需要在中断上下文访问（包括底半部即中断处理句柄和顶半部即软中断），就必须使用自旋锁。自旋锁保持期间是抢占失效的，而信号量和读写信号量保持期间是可以被抢占的。自旋锁只有在内核可抢占或SMP（多处理器）的情况下才真正需要，在单CPU且不可抢占的内核下，自旋锁的所有操作都是空操作。 事实上，自旋锁的初衷就是：在短期间内进行轻量级的锁定。如果需要长时间锁定的话，最好使用信号量。 自旋锁实际上是忙等锁。 当锁不可用时，CPU 一直循环执行“测试并设置”该锁直到可用而取得该锁，CPU 在等待自旋锁时不做任何有用的工作，仅仅是等待。因此，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。当临界区很大或有共享设备的时候，需要较长时间占用锁，使用自旋锁会降低系统的性能。 自旋锁可能导致系统死锁。 引发这个问题最常见的情况是递归使用一个自旋锁，即如果一个已经拥有某个自旋锁的 CPU 想第二次获得这个自旋锁，则该 CPU 将死锁。此外，如果进程获得自旋锁之后再阻塞，也有可能导致死锁的发生。 用下面这段伪代码来描述： do { Acquire Lock Critical section // 临界区 Release Lock Reminder section // 不需要锁保护的代码} 在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区（Critical Section）中的代码不会被多个线程执行。 自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下: bool lock = false; // 一开始没有锁上，任何线程都可以申请锁do { while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 lock = true; // 挂上锁，这样别的线程就无法获得锁 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码} 注释写得很清楚，就不再逐行分析了。可惜这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。 二、原子操作狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。 然而在多处理器的情况下，能够被多个处理器同时执行的操作仍然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。 这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示: bool test_and_set (bool target) { bool rv = target; *target = TRUE; return rv;} 这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。 三、自旋锁的总结至此，自旋锁的实现原理就很清楚了： bool lock = false; // 一开始没有锁上，任何线程都可以申请锁do { while(test_and_set(&amp;lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码} 如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。","tags":[]},{"title":" @synchronized\t\t","date":"2019-03-03T09:34:09.000Z","path":"2019/03/03/synchronized/","text":"文章：关于 @synchronized，这儿比你想知道的还要多 一、@synchronized@synchronized 是一个 OC 层面的锁，主要是通过牺牲性能换来语法上的简洁与可读。它的性能是最差的。 @synchronized() 需要传入一个 OC 对象，实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组（可以理解为锁池），通过对对象去哈希值来得到对应的互斥锁。 @synchronized(object) { //do work} @synchronized(object) 指令使用的 object 为该锁的唯一标识，只有当标识相同时，才满足互斥。@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized 块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。@synchronized 还有一个好处就是不用担心忘记解锁了。如果在 @sychronized(object){} 内部 object 被释放或被设为 nil，从测试的结果来看，的确没有问题，但如果 object 一开始就是 nil，则失去了锁的功能。不过虽然 nil 不行，但 @synchronized([NSNull null]) 是完全可以的。 二、原理探究synchronized block 与 [_lock lock] 和 [_lock unlock] 效果相同。你可以把它当成是锁住 self，仿佛 self 就是个 NSLock。锁在 ‘{‘ 后面的任何代码运行之前被获取到，在 ‘}’ 后面的任何代码运行之前被释放掉。不用担心忘记调用 unlock。 @synchronized 的文档告诉我们 @synchronized block 在被保护的代码上暗中添加了一个异常处理。为的是同步某对象时如若抛出异常，锁会被释放掉。 Stackoverflow 上的这篇帖子 说 @synchronized block 会变成 objc_sync_enter 和 objc_sync_exit 的成对儿调用。我们不知道这些函数是干啥的，但基于这些事实我们可以认为编译器将这样的代码： @synchronized(obj) { // do work} 转化成： @try { objc_sync_enter(obj); // do work}@finally { objc_sync_exit(obj);} objc_sync_enter 和 objc_sync_exit 是什么？它们是如何实现的？在 Xcode 中按住 Command 键单击它们，然后进到了 &lt;objc/objc-sync.h&gt;，里面有我们感兴趣的这两个函数： /** * Begin synchronizing on ‘obj’. * Allocates recursive pthread_mutex associated with ‘obj’ if needed. * * @param obj The object to begin synchronizing on. * * @return OBJC_SYNC_SUCCESS once lock is acquired. */OBJC_EXPORT intobjc_sync_enter(id _Nonnull obj) OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0, 2.0); /** * End synchronizing on ‘obj’. * * @param obj The object to end synchronizing on. * * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR */OBJC_EXPORT intobjc_sync_exit(id _Nonnull obj) OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0, 2.0); objc_sync_enter 的文档告诉我们一些新东西： @synchronized 结构在工作时为传入的对象分配了一个递归锁。分配工作何时发生，如何发生呢？它怎样处理 nil？幸运的是 Objective-C runtime 是开源的，所以我们马上阅读源码并找到答案！ 注：递归锁在被同一线程重复获取时不会产生死锁。你可以在这找到一个它工作原理的精巧案例。有个叫做 NSRecursiveLock 的现成的类也是这样的。 你可以在这里找到 objc-sync 的全部源码。先从文件顶部的数据结构开始看。在代码块的下方我将立刻做出解释，所以尝试理解代码时别花太长时间哦。 typedef struct SyncData { struct SyncData* nextData; id object; int threadCount; // number of THREADS using this block recursive_mutex_t mutex;} SyncData; typedef struct { SyncData *data; spinlock_t lock; char align\\[64 - sizeof (spinlock_t) - sizeof (SyncData *)\\]; } SyncList __attribute__((aligned(64))); // Use multiple parallel lists to decrease contention among unrelated objects. #define COUNT 16 #define HASH(obj) ((((uintptr_t)(obj)) &gt;&gt; 5) &amp; (COUNT - 1)) #define LOCK_FOR_OBJ(obj) sDataLists[HASH(obj)].lock #define LIST_FOR_OBJ(obj) sDataLists[HASH(obj)].datastatic SyncList sDataLists[COUNT]; 一开始，有一个 struct SyncData 的定义。这个结构体包含一个 object（就是给 @synchronized 传入的那个对象）和一个有关联的 recursive_mutex_t，它就是那个跟 object 关联在一起的锁。每个 SyncData 也包含一个指向另一个 SyncData 对象的指针，叫做 nextData，所以你可以把每个 SyncData 结构体看做是链表中的一个元素。最后，每个 SyncData 包含一个 threadCount，这个 SyncData 对象中的锁会被一些线程使用或等待，threadCount 就是此时这些线程的数量。它很有用处，因为 SyncData 结构体会被缓存，threadCount == 0 就暗示了这个 SyncData 实例可以被复用。 下面是 struct SyncList 的定义。正如我在上面提过，你可以把 SyncData 当做是链表中的节点。每个 SyncList 结构体都有个指向 SyncData 节点链表头部的指针，也有一个用于防止多个线程对此列表做并发修改的锁。 上面代码块的最后一行是 sDataLists 的声明：一个 SyncList 结构体数组，大小为 16。通过定义的一个哈希算法将传入对象映射到数组上的一个下标。值得注意的是这个哈希算法设计的很巧妙，是将对象指针在内存的地址转化为无符号整型并右移五位，再跟 0xF 做按位与运算，这样结果不会超出数组大小。 LOCK_FOR_OBJ(obj) 和 LIST_FOR_OBJ(obj) 这俩宏就更好理解了，先是哈希出对象的数组下标，然后取出数组对应元素的 lock 或 data。一切都是这么顺理成章哈。 当你调用 objc_sync_enter(obj) 时，它用 obj 内存地址的哈希值查找合适的 SyncData，然后将其上锁。当你调用 objc_sync_exit(obj) 时，它查找合适的 SyncData 并将其解锁。 现在知道了 @synchronized 如何将一个锁和你正在同步的对象关联起来，接下来看看当一个对象在 @synchronized(){} 中被释放或设为 nil 时会发生什么。 如果看了源码，你会注意到 objc_sync_enter 里面没有 retain 和 release。所以它要么没有保持传递给它的对象，要么或是在 ARC 下被编译。我们可以用下面的代码来做个测试： NSDate * test = [NSDate date];NSLog(@”%@”, @([test retainCount])); @synchronized (test) { NSLog(@”%@”, @([test retainCount]));} 两次输出结果都是 1。那么 objc_sync_enter 貌似是没保持被传入的对象啊。这就有趣了。如果你正在同步的对象 A 被释放了，然后有可能在它的内存地址上生成了一个新的对象 B，有可能某个其他的线程试着去同步那个新的对象 B。在这种情况下，另一个线程将会阻塞，直到当前线程结束它的同步 block。这看起来并不是很糟。这听起来像是这种事情实现者早就知道并予以接受。没有遇到过任何好的替代方案。 假如对象在 “synchronized block” 中被设成 nil 呢？我们回顾下我们“拿衣服（naive）”的实现吧： NSString * test = @”test”; @try { // Allocates a lock for test and locks it objc_sync_enter(test); test = nil;}@finally { // Passed `nil`, so the lock allocated in `objc_sync_enter` // above is never unlocked or deallocated objc_sync_exit(test);} objc_sync_enter 被调用时传入的是 test 而 objc_sync_exit 被调用时传入的是 nil。而传入 nil 的时 objc_sync_exit 是个空操作，所以将不会有人释放锁。 如果 Objective-C 容易受这种情况的影响，我们知道么？下面的代码调用 @synchronized 并在 {} 中将一个指针设为 nil。然后在后台线程对指向同一个对象的指针调用 @synchronized。如果在 {} 中设置一个对象为 nil 会让锁死锁，那么在第二个 @synchronized 中的代码将永远不会执行。控制台中将不会打印任何东西出来。 NSNumber number = @(1);NSNumber thisPtrWillGoToNil = number; @synchronized (thisPtrWillGoToNil) { /** * Here we set the thing that we’re synchronizing on to `nil`. If * implemented naively, the object would be passed to `objc_sync_enter` * and `nil` would be passed to `objc_sync_exit`, causing a lock to * never be released. */ thisPtrWillGoToNil = nil;} dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^ { NSCAssert(!\\[NSThread isMainThread\\], @&quot;Must be run on background thread&quot;); /\\*\\* \\* If, as mentioned in the comment above, the synchronized lock is never \\* released, then we expect to wait forever below as we try to acquire \\* the lock associated with \\`number\\`. \\* \\* This doesn&apos;t happen, so we conclude that `@synchronized` must deal \\* with this correctly. */ @synchronized (number) { NSLog(@&quot;This line does indeed get printed to stdout&quot;); } }); 当执行上面的代码时，控制台打印了 “This line does indeed get printed to stdout”。所以 Objective-C 很好地处理了这种情形。编译器可能做了类似下面的事情来解决这事儿的。 NSString * test = @”test”;id synchronizeTarget = (id)test; @try { objc_sync_enter(synchronizeTarget); test = nil;}@finally { objc_sync_exit(synchronizeTarget);} 用这种方式实现的话，传递给 objc_sync_enter 和 objc_sync_exit 总是相同的对象。他们在传入 nil 时都是空操作。这带来了个棘手的 debug 场景：如果向 @synchronized 传递 nil，那么你就不会得到任何锁而且你的代码将不会是线程安全的！如果你想知道为什么你正收到出乎意料的竞态（race），确保没有向 @synchronized 传入 nil。你可以在 objc_sync_nil 上设置一个符号断点来达到此目的。objc_sync_nil 是一个空方法，当 objc_sync_enter 函数被传入 nil 时会被调用，这让 debug 更容易些。 下面是 objc_sync_enter 的源码，主要逻辑很容易看懂，加深理解 objc_sync_nil： // Begin synchronizing on ‘obj’.// Allocates recursive mutex associated with ‘obj’ if needed.// Returns OBJC_SYNC_SUCCESS once lock is acquired.int objc_sync_enter(id obj){ int result = OBJC_SYNC_SUCCESS; if (obj) { SyncData* data = id2data(obj, ACQUIRE); require\\_action\\_string(data != NULL, done, result = OBJC\\_SYNC\\_NOT_INITIALIZED, &quot;id2data failed&quot;); result = recursive\\_mutex\\_lock(&amp;data-&gt;mutex); require\\_noerr\\_string(result, done, &quot;mutex_lock failed&quot;); } else { // @synchronized(nil) does nothing if (DebugNilSync) { \\_objc\\_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc\\_sync\\_nil to debug&quot;); } objc\\_sync\\_nil(); } done: return result;} 三、总结 调用 sychronized 的每个对象，Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中； 如果在 {} 中对象被释放或被设为 nil 看起来正常。不过这没在文档中说明，所以不要依赖这条； 注意不要向 @sychronized() 传入 nil，这将会从代码中移走线程安全。可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。","tags":[]},{"title":" NSCondition\t\t","date":"2019-03-03T07:57:36.000Z","path":"2019/03/03/nscondition/","text":"文章：深入理解 iOS 锁、 一、NSConditionNSCondition 的对象实际上作为一个锁和一个线程检查器，锁上之后其它线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入 waiting 状态。经测试，NSCondition 并不会先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法。 NSCondition 内部是封装了一个互斥锁和条件变量，它把互斥锁的 lock 方法和条件变量的 wait/signal 统一在对象中，暴露给使用者。 - (void) signal { pthread_cond_signal(&amp;_condition);} // 其实这个函数是通过宏来定义的，展开后就是这样- (void) lock { int err = pthread_mutex_lock(&amp;_mutex);} 所以它的加解锁过程与 NSLock 基本类似，性能也很接近。 NSCondition * lock = [NSCondition new];[lock lock];// do work[lock unlock]; API： wait 进入等待状态waitUntilDate: 让一个线程等待一定的时间signal 唤醒一个等待的线程broadcast 唤醒所有等待的线程 NSCondition 的底层是通过条件变量（condition variable）pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 二、如何使用条件变量很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用： // 消费者void consumer (){ pthread_mutex_lock(&amp;mutex); while (data == NULL) { pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据 } // --- 有新的数据，以下代码负责处理 // temp = data; // --- 有新的数据，以上代码负责处理 pthread_mutex_unlock(&amp;mutex);} // 生产者void producer (){ pthread_mutex_lock(&amp;mutex); // 生产数据 pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，通知有了新的数据 pthread_mutex_unlock(&amp;mutex);} 如果不用互斥锁，只用条件变量会有什么问题呢？问题在于 temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。 wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。 三、为什么要使用条件变量介绍条件变量的文章非常多，但大多都对一个基本问题避而不谈：为什么要用条件变量？它仅仅是控制了线程的执行顺序，用信号量或者互斥锁能不能模拟出类似效果？ 信号量可以一定程度上替代 condition，但是互斥锁不行。在以上给出的生产者-消费者模式的代码中， pthread_cond_wait 方法的本质是锁的转移，消费者放弃锁，然后生产者获得锁，同理，pthread_cond_signal 则是一个锁从生产者到消费者转移的过程。 如果使用互斥锁，我们需要把代码改成这样： // 消费者void consumer (){ pthread_mutex_lock(&amp;mutex); while (data == NULL) { pthread_mutex_unlock(&amp;mutex); pthread_mutex_lock(&amp;another_lock) // 相当于 wait 另一个互斥锁 pthread_mutex_lock(&amp;mutex); } pthread_mutex_unlock(&amp;mutex);} 这样做存在的问题在于，在等待 anotherlock 之前， 生产者有可能先执行代码， 从而释放了 anotherlock。也就是说，我们无法保证释放锁和等待另一个锁这两个操作是原子性的，也就无法保证“先等待、后释放 another_lock” 这个顺序。 用信号量则不存在这个问题，因为信号量的等待和唤醒并不需要满足先后顺序，信号量只表示有多少个资源可用，因此不存在上述问题。然而与 pthread_cond_wait 保证的原子性锁转移相比，使用信号量似乎存在一定风险（暂时没有查到非原子性操作有何不妥）。 不过，使用 condition 有一个好处，我们可以调用 pthread_cond_broadcast 方法通知所有等待中的消费者，这是使用信号量无法实现的。 四、NSConditionLockNSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值: // 简化版代码- (id) initWithCondition: (NSInteger)value{ if (self = [super init]) { _condition = [NSCondition new] _condition_value = value; } return self;} 它的 lockWhenCondition 方法其实就是消费者方法： - (void) lockWhenCondition: (NSInteger)value{ [_condition lock]; while (value != _condition_value) { [_condition wait]; }} 对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者： - (void) unlockWithCondition: (NSInteger)value{ _condition_value = value; [_condition broadcast]; [_condition unlock];}","tags":[]},{"title":" pthread_mutex、NSLock、NSRecursiveLock\t\t","date":"2019-03-01T10:12:02.000Z","path":"2019/03/01/pthread-mutex-e3-80-81nslock-e3-80-81nsrecursivelock/","text":"文章：深入理解 iOS 开发中的锁 一、pthread_mutexpthread 表示 POSIX thread，简称 Pthreads，是线程的 POSIX 标准。该标准定义了创建、操纵线程的一整套跨平台的 API。 pthread_mutex 表示互斥锁。 互斥锁的常见用法如下： pthread_mutexattr_t attr;pthread_mutexattr_init(&amp;attr);pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁 pthread_mutex_lock(&amp;mutex); // 申请锁 // 临界区pthread_mutex_unlock(&amp;mutex); // 释放锁 对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等。 #import &lt;pthread.h&gt; static pthread_mutex_t pLock;pthread_mutex_init(&amp;pLock, NULL); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ pthread_mutex_lock(&amp;pLock); sleep(3); pthread_mutex_unlock(&amp;pLock);}); pthread_mutex 中也有个 pthread_mutex_trylock(&amp;pLock)，和 OSSpinLockTry(&amp;oslock) 区别在于，前者可以加锁时返回的是 0，否则返回一个错误提示码；后者返回的 YES 和 NO。 二、NSLockNSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法。 #define MLOCK \\- (void) lock\\{\\ int err = pthread_mutex_lock(&amp;_mutex);\\ // 错误处理…} NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 这里使用宏定义的原因是，OC 内部还有其他几种锁，它们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 三、NSRecursiveLock一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。幸运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁。 递归锁：允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。 NSRecursiveLock 与 NSLock 类似，也是使用 pthread_mutex 实现，把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器 +1，锁的释放过程也是同理。 static pthread_mutex_t pLock;pthread_mutexattr_t attr;pthread_mutexattr_init(&amp;attr); // 初始化 attr 并且给它赋予默认pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); // 设置锁类型为递归锁pthread_mutex_init(&amp;pLock, &amp;attr);pthread_mutexattr_destroy(&amp;attr); // 销毁一个属性对象，在重新进行初始化之前该结构不能重新使用 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ static void (^RecursiveBlock)(int); RecursiveBlock = ^(int value) { pthread_mutex_lock(&amp;pLock); if (value &gt; 0) { NSLog(@”value: %d”, value); RecursiveBlock(value - 1); } pthread_mutex_unlock(&amp;pLock); }; RecursiveBlock(5);});","tags":[]},{"title":" os_unfair_lock_t\t\t","date":"2019-03-01T09:51:56.000Z","path":"2019/03/01/os-unfair-lock-t/","text":"os_unfair_lock_t 是官方推荐的替代 OSSpinLock 的方案，优化了”优先级反转”问题。 os_unfair_lock_t lock = &amp;(OS_UNFAIR_LOCK_INIT);os_unfair_lock_lock(lock);os_unfair_lock_unlock(lock);","tags":[]},{"title":" dispatch_semaphore\t\t","date":"2019-03-01T09:49:31.000Z","path":"2019/03/01/dispatch-semaphore/","text":"文章：深入理解GCD dispatch_semaphore 是 GCD 用来同步的一种方式，关于信号量的 API 主要是三个：create、wait 和 signal。 一、dispatch_semaphore_create信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value：一个是当前的 value，一个是记录初始 value。 信号的 wait 和 signal 是互逆的两个操作。如果 value 大于 0，前者将 value 减一，此时如果 value 小于零就一直等待。 初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。 二、dispatch_semaphore_wait首先从这个函数的源码看起: long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) { long value = dispatch_atomic_dec2o(dsema, dsema_value); dispatch_atomic_acquire_barrier(); if (fastpath(value &gt;= 0)) { return 0; } return _dispatch_semaphore_wait_slow(dsema, timeout);} 第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将 dsema 的值减一，并把新的值赋给 value。 如果减一后的 value 大于等于 0 就立刻返回，没有任何操作，否则进入等待状态。 _dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑： case DISPATCH_TIME_NOW: while ((orig = dsema-&gt;dsema_value) &lt; 0) { if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) { return KERN_OPERATION_TIMED_OUT; } } 这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value 加一（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。 实际上 while 判断一定会成立，因为如果 value ≥ 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。 第二种情况是 DISPATCH_TIME_FOREVER： case DISPATCH_TIME_FOREVER: do { kr = semaphore_wait(dsema-&gt;dsema_port); } while (kr == KERN_ABORTED); break; 进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。 在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。 整个函数的框架如下: static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) {again: while ((orig = dsema-&gt;dsema_sent_ksignals)) { if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig, orig - 1)) { return 0; } } switch (timeout) { default: / semaphore_timedwait / case DISPATCH_TIME_NOW: / KERN_OPERATION_TIMED_OUT / case DISPATCH_TIME_FOREVER: / semaphore_wait / } goto again;} 可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。 进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。 它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下： int sem_wait (sem_t sem) { int \\futex = (int *) sem; if (atomic_decrement_if_positive (futex) &gt; 0) return 0; int err = lll_futex_wait (futex, 0); return -1;) 首先会把信号量的值减一，并判断是否大于 0。大于 0，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。 三、dispatch_semaphore_signal这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下： long dispatch_semaphore_signal(dispatch_semaphore_t dsema) { long value = dispatch_atomic_inc2o(dsema, dsema_value); if (fastpath(value &gt; 0)) { return 0; } return _dispatch_semaphore_signal_slow(dsema);} 首先会调用原子方法让 value 加一，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow： long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) { (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals); _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port); kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port); return 1;} 它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：如果唤醒了线程，返回非 0，否则返回 0。 四、使用将信号总量设为 1 时可以当作锁来使用。在没有等待情况出现时，它的性能比 pthread_mutex 还要高。当有等待情况出现时，会让线程进入睡眠状态，主动让出时间片，导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。 五、总结可以看到，信号量的实现都非常简单，这也是它加解锁耗时很短的原因。再次强调，加解锁耗时不能准确反应出锁的效率（比如时间片切换就无法发生），它只能从一定程度上衡量锁的实现复杂程度。","tags":[]},{"title":" OSSpinLock\t\t","date":"2019-03-01T09:01:03.000Z","path":"2019/03/01/osspinlock/","text":"文章：iOS 笔记 - 锁、iOS 开发中的八种锁（Lock）、iOS 常见知识点（三）：Lock、不再安全的 OSSpinLock 一、OSSpinLockOSSpinLock 是一种自旋锁，属于 busy-waiting 类型的锁。与互斥锁不同，当 SpinLock 被其它线程持有，spinLock 不会被阻塞，而会一直的请求获取 lock，从而消耗大量 cpu 资源。所以当临界区任务时间较长时，并不适合用 SpinLock，但当任务时间较短，其效率很高。 只有加锁、解锁、尝试加锁三个方法。 #import &lt;libkern/OSAtomic.h&gt; - (void)viewDidLoad{ [super viewDidLoad]; \\_\\_block OSSpinLock oslock = OS\\_SPINLOCK_INIT; // 线程 1 dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;线程1 准备上锁&quot;); OSSpinLockLock(&amp;oslock); sleep(4); NSLog(@&quot;线程1&quot;); OSSpinLockUnlock(&amp;oslock); NSLog(@&quot;线程1 解锁成功&quot;); NSLog(@&quot;--------------------------------------------------------&quot;); }); //线程2 dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;线程2 准备上锁&quot;); OSSpinLockLock(&amp;oslock); NSLog(@&quot;线程2&quot;); OSSpinLockUnlock(&amp;oslock); NSLog(@&quot;线程2 解锁成功&quot;); }); } 2019-03-01 16:17:03.812 Demo[589:1531210] 线程2 准备上锁2019-03-01 16:17:03.812 Demo[589:1531209] 线程1 准备上锁2019-03-01 16:17:03.812 Demo[589:1531210] 线程22019-03-01 16:17:03.812 Demo[589:1531210] 线程2 解锁成功2019-03-01 16:17:07.814 Demo[589:1531209] 线程12019-03-01 16:17:07.815 Demo[589:1531209] 线程1 解锁成功2019-03-01 16:17:07.816 Demo[599:1532045] ——————————————————– 2019-03-01 16:18:33.605 Demo[599:1532045] 线程1 准备上锁2019-03-01 16:18:33.605 Demo[599:1532044] 线程2 准备上锁2019-03-01 16:18:37.610 Demo[599:1532045] 线程12019-03-01 16:18:37.610 Demo[599:1532045] 线程1 解锁成功2019-03-01 16:18:37.611 Demo[599:1532045] ——————————————————–2019-03-01 16:18:37.668 Demo[599:1532044] 线程22019-03-01 16:18:37.668 Demo[599:1532044] 线程2 解锁成功 先锁住线程 1 时，异步执行锁住线程 2，线程 2 会一直等待（自旋锁不会让等待的进入睡眠状态），直到线程 1 的任务执行完且解锁完毕，线程 2 会立即执行；同理，先锁住线程 2，那么线程 1 就需要等待线程 2 解锁成功才能继续执行。 修改一下代码： dispatch\\_async(dispatch\\_get\\_global\\_queue(DISPATCH\\_QUEUE\\_PRIORITY_DEFAULT, 0), ^{ OSSpinLockLock(&amp;oslock); // OSSpinLockUnlock(&amp;oslock); }); 当注释掉先锁住的线程的解锁代码，后锁住的线程将一直等待。 常用的方法： OS_SPINLOCK_INIT 默认值为 0。在 locked 状态时就会大于 0，unlocked 状态下为 0 OSSpinLockLock(&amp;oslock) 上锁。参数为 &amp;OSSpinLock OSSpinLockUnlock(&amp;oslock) 解锁。参数为 &amp;OSSpinLock OSSpinLockTry(&amp;oslock) 尝试加锁，可以加锁则立即加锁并返回 YES，反之返回 NO trylock 和 lock 使用场景： 当前线程锁失败，也可以继续其它任务，用 trylock 合适；当前线程只有锁成功后，才会做一些有意义的工作，那就 lock，没必要轮询 trylock。 OSSpinLock 与 NSLock 的区别： NSLock 请求加锁失败的话，会先轮询，但一秒过后便会使线程进入 waiting 状态，等待唤醒；而 OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务。 二、不再安全的 OSSpinLock2015-12-14 苹果工程师透露了自旋锁的 bug，对话内容大致如下： 新版 iOS 中，系统维护了 5 个不同的线程优先级/QoS：background、utility、default、user-initiated、user-interactive。高优先级线程始终会在低优先级线程前执行，一个线程不会受到比它更低优先级线程的干扰。这种线程调度算法会产生潜在的优先级反转问题，从而破坏了 spin lock。 具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock，这就是优先级反转。这并不只是理论上的问题，开发者已经遇到很多次这个问题，于是苹果工程师停用了 OSSpinLock。 苹果工程师 Greg Parker 提到，对于这个问题，一种解决方案是用 truly unbounded backoff 算法，这能避免 livelock 问题，但如果系统负载高时，它仍有可能将高优先级的线程阻塞数十秒之久；另一种方案是使用 handoff lock 算法，这也是 libobjc 目前正在使用的。锁的持有者会把线程 ID 保存到锁内部，锁的等待者会临时贡献出它的优先级来避免优先级反转的问题。理论上这种模式会在比较复杂的多锁条件下产生问题，但实践上目前还一切都好。 libobjc 里用的是 Mach 内核的 thread_switch() 然后传递了一个 mach thread port 来避免优先级反转，另外它还用了一个私有的参数选项，所以开发者无法自己实现这个锁。另一方面，由于二进制兼容问题，OSSpinLock 也不能有改动。 最终的结论就是，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。 三、OSSpinLock 的替代方案除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。 四、替换更新查看 CoreFoundation 的源码能够发现，苹果至少在 2014 年就发现了这个问题，并把 CoreFoundation 中的 spinlock 替换成了 pthread_mutex，具体变化可以查看这两个文件：CFInternal.h(855.17)、CFInternal.h(1151.16)。苹果自己发现问题后，并没有及时更新 OSSpinLock 的文档，也没有告知开发者。 在 iOS 10/macOS 10.12 发布时，苹果提供了新的 os_unfair_lock 作为 OSSpinLock 的替代，并且将 OSSpinLock 标记为了 Deprecated。 google/protobuf 内部的 spinlock 被全部替换为 dispatch_semaphore，详情可以看这个提交：https://github.com/google/protobuf/pull/1060。用 dispatch_semaphore 而不用 pthread_mutex 应该是出于性能考虑。","tags":[]},{"title":" 锁\t\t","date":"2019-03-01T08:14:23.000Z","path":"2019/03/01/lock/","text":"文章：iOS 笔记 - 锁、不再安全的 OSSpinLock 测试代码： - (void)viewDidLoad{ [super viewDidLoad]; __block int num = 0; dispatch\\_async(dispatch\\_get\\_global\\_queue(0, DISPATCH\\_QUEUE\\_PRIORITY_DEFAULT), ^{ // ① //OSSpinLock lock = OS\\_SPINLOCK\\_INIT; // ② //os\\_unfair\\_lock\\_t lock = &amp;(OS\\_UNFAIR\\_LOCK\\_INIT); // ③ //dispatch\\_semaphore\\_t semaphore = dispatch\\_semaphore\\_create(0); // ④ //pthread\\_mutexattr\\_t attr; //pthread\\_mutexattr\\_init(&amp;attr); //pthread\\_mutexattr\\_settype(&amp;attr, PTHREAD\\_MUTEX\\_NORMAL); // 定义锁的属性 //pthread\\_mutex\\_t mutex; //pthread\\_mutex\\_init(&amp;mutex, &amp;attr); // ⑤ //NSCondition * condition = \\[\\[NSCondition alloc\\] init\\]; // ⑥ //NSLock * lock = \\[\\[NSLock alloc\\] init\\]; // ⑦ //pthread\\_mutexattr\\_t attr; //pthread\\_mutexattr\\_init(&amp;attr); //pthread\\_mutexattr\\_settype(&amp;attr, PTHREAD\\_MUTEX\\_RECURSIVE); // 定义锁的属性 //pthread\\_mutex\\_t mutex; //pthread\\_mutex\\_init(&amp;mutex, &amp;attr); // ⑧ //NSRecursiveLock * lock = \\[\\[NSRecursiveLock alloc\\] init\\]; // ⑨ //NSConditionLock * lock = \\[\\[NSConditionLock alloc\\] initWithCondition:0\\]; double begin = CACurrentMediaTime(); for (int i = 0; i &lt; 10000000; i++) { // ① //OSSpinLockLock(&amp;lock); //num = 1; //OSSpinLockUnlock(&amp;lock); // ② //os\\_unfair\\_lock_lock(lock); //num = 1; //os\\_unfair\\_lock_unlock(lock); // ③ //dispatch\\_semaphore\\_signal(semaphore); //num = 1; //dispatch\\_semaphore\\_wait(semaphore, DISPATCH\\_TIME\\_FOREVER); // ④ //pthread\\_mutex\\_lock(&amp;mutex); //num = 1; //pthread\\_mutex\\_unlock(&amp;mutex); // ⑤ //\\[condition lock\\]; //num = 1; //\\[condition unlock\\]; // ⑥ //\\[lock lock\\]; //num = 1; //\\[lock unlock\\]; // ⑦ //pthread\\_mutex\\_lock(&amp;mutex); //num = 1; //pthread\\_mutex\\_unlock(&amp;mutex); // ⑧ //\\[lock lock\\]; //num = 1; //\\[lock unlock\\]; // ⑨ //\\[lock lock\\]; //num = 1; //\\[lock unlock\\]; // ⑩ @synchronized (self) { num = 1; } } double end = CACurrentMediaTime(); NSLog(@&quot;%8.2f ms&quot;, (end - begin) * 1000); }); } 测试结果： ————-Xcode 10.1 iPhone 6s(10.0)————- OSSpinLock 87.03 ms | 88.60 msos_unfair_lock_t 161.19 ms | 154.48 msdispatch_semaphore 153.24 ms | 160.33 mspthread_mutex 292.67 ms | 229.60 msNSCondition 395.05 ms | 330.32 msNSLock 326.62 ms | 325.10 mspthread_mutex(recursive) 351.81 ms | 355.97 msNSRecursiveLock 480.43 ms | 517.27 msNSConditionLock 888.47 ms | 1011.47 ms@synchronized 995.82 ms | 1027.01 ms 几种常见的锁加解锁的时间：","tags":[]},{"title":" iOS 内置图片瘦身\t\t","date":"2019-03-01T07:00:58.000Z","path":"2019/03/01/ios-e5-86-85-e7-bd-ae-e5-9b-be-e7-89-87-e7-98-a6-e8-ba-ab/","text":"一、iOS 内置资源的集中方式1、将图片存放在 bundle 这是一种很常见的方式，项目中各类文件分类放在各个 bundle 下，项目既整洁又能达到隔离资源的目的。采用 bundle 的加载方式为 [UIImage imageNamed:”xx.bundle/xx.png”]。 这种方式有比较明显的缺点： ①、iOS 系统不会对其进行压缩存储，造成了应用体积的增大。 ②、使用 bundle 存储图片放弃了 APP thinning。明显的表现是 2 倍屏手机和 3 倍屏手机下载的应用包大小一样。如果能够实现 APP thinning，那么往往 2 倍屏幕的手机包大小会小于 3 倍屏手机的，起到差异性优化的目的。 在调研过程中发现，应用的体积与图片资源的数量密切相关。换句话说，iPhone 的 rom 存在 4K 对齐的情况，一张 498B 大小的图片在应用包中也要占据 4KB 大小。因此项目中每添加一张图片就至少增大了 4KB。 下面来证实。首先创建空应用，其大小在 iPhone7 上为 131KB ，引入一张 3KB 的图片前后对比如下： 以上未经过 App Store 上线认证，仅仅通过本地真机运行测试，仅供参考。 2、使用 .ttf 字体文件替代图标 使用字体文件替代图片也是一种比较常见的资源内置方式。很多应用都使用过这种方案，如淘宝、爱奇艺等知名应用。 使用字体文件的好处是显而易见的，如果 APP 中某个图片比较大，那么为了保证清晰度，UI 可能会提供比较大的图标。使用字体文件会避免这个问题，而且不必导入 @2x 和 @3x 图片，一套字体文件就能保证 UI 的清晰度。 字体文件使用起来比较简单，但是使用方法与 png 图片的使用方法有很大的不同，因为字体文件实际所展示的图标都是 UTF8 编码转来的字符串。因此当我们需要展示一个图标的时候不再是使用 UIImageView 了，而是 UILabel。 UILabel * iconLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 50, 50)];iconLabel.font = [UIFont fontWithName:@”icomoon” size:50];iconLabel.text = [NSString stringWithUTF8String:”\\ue902”]; 由于使用了字体来替代图片，所以可以通过设置字体的颜色来改变图标的颜色。之前经常会遇到一个场景，如两个一模一样的图标但是由于颜色不同，UI 就需要提供两套图片，每套图片中包含 @2x 和 @3x 图片。如果采用了字体替代简单的图标，那么 UI 只需要提供一套字体即可，并且拉伸后也不会失真。 优点： ①、可以降低应用图片内置资源的体积。 ②、可以随意缩放和修改颜色。 缺点： ①、图标的查找和替换比较麻烦，不如直接使用图片那样简单。 ②、有些情况无法替换之前存在的图片，只能起到缩小增量的目的，无法减小全量。 任何一种需要大刀阔斧改革的优化都是一种不明智的行为。 3、图片存在 Assets.xcassets 下 使用 Assets.xcassets 是苹果推荐的一种方式。Assets.xcassets 是 iOS7 推出的一种图片资源管理工具，将图片内置到Assets.xcassets 下系统会对图片资源进行压缩，并且支持 APP thinning。 二、优化项目优化不能脱离场景，很多很好的方案由于场景的限制并不能起到优化的作用。 为了达到跨团队快速开发的目的，项目很早就利用 cocoapods 实现组件化。项目中存在多个业务 pod，每个 pod 都有各自的团队维护，各个团队的代码彼此不开放，各个 pod 最终会被编译为 .a 的形式。 与 .a 相对应的是 .framework，它们之间有一个重要的区别就是资源的问题。.framework 中可以存放资源，但 .a 不可以，因此生成 .a 的 pod 下的资源会被转移到 main bundle 下，这为资源冲突造成了隐患。采用的 bundle 管理资源大大降低了资源冲突的可能性，因为 bundle 名很少会重复。 优化的前提之一也是不破坏这种组件化开发的模式，换句话说也就是各个业务线不产生资源耦合、业务线的 RD 不必担心彼此资源的冲突、业务 Pod 下的资源文件彼此隔离。 先要抛出两个问题： ①、cocoapods 是否支持使用 Assets.xcassets。 ②、各个 pod 维护自己的 Assets.xcassets 会不会造成资源冲突。 为了弄清楚上面两个问题，先要看下 podspec 的几个重要参数： s.source_files ：源文件路径。 s.public_header_files ：表明了哪些路径下的文件可以在 framework 外被引用。 s.resources ：资源文件路径及文件类型。 s.resource_bundles ：资源文件路径及类型，同时资源文件会被打成 bundle。（推荐使用）。 实验发现各个 pod 下都可以创建自己的 xcassets，因此问题 ① 确定。 如果我们在各个业务 pod 下都创建 .xcassets 文件内置图片，那么 cocoapods 的脚本会在编译时将各个目录下的 xcassets 文件内容提取出来，合并到一个 xcassets 中并生成一个 .car 文件。这样的话如果资源文件重名，那么很可能其中某一个文件会被覆盖替换。因此我们主要是要解决问题 ②。 查看 podspec 的写法发现 s.resource_bundles 貌似是我们所需要的法宝。 最终打包结果很理想，确实能够生成 Demo.bundle，并且 bundle 下存在 Assets.car。 运行发现通过 [UIImage imageNamed:@”Demo.bundle/1”];加载不出来图片。必须使用 [UIImage imageNamed:@”1” inBundle:bundle compatibleWithTraitCollection:nil]; 才能加载出来。也就是说如果 Assets.car 不在 main bundle 下，那么加载图片需要指定 bundle。 既然需要指定 bundle 加载图片，那么如何获取这个 bundle 呢？换句话说如何才能低成本的将项目中的图片放到特定 bundle 下的 Assets.car 文件中呢？对此我们提出了一个解决方案： ①、在 pod 下新建一个空文件夹。找出该 pod 存放图片的所有 bundle，在新建文件夹下创建与 bundle 数量相等的 Asset。 ②、修改 podspec 文件，设置 resource_bundles 将 Asset 指定为资源，并指定 bundle 名称，如 A.bundle，其对应的 Asset 最终资源 bundle 为 A_Asset.bundle。 ③、新增方法 imageWithName:，从符合 xx.bundle/yy.png 特征的参数中获取 bundle 名和图片名 xx_Asset.bundle 和 yy.png，获取图片并返回。 ④、查找并全部替换 imageNamed: 和 imageWithContentOfFile: 为 imageWithName:。 只要能拿到原来代码中 imageNamed: 的参数就能知道现在图片存在哪个 bundle 下，这样就能通过 imageNamed:inBundle: 获取到图片，其思路如下图所示： 看到这里已经应该能遇见这种优化的成本了。加载图片都需要指定 bundle 也就意味着成千上万处的 API 需要修改。我们最初探讨到这里的时候首先想到的是脚本，但是这个方案很快就被否定了，因为项目中存在大量的 XIB，XIB 中设置图片我们无法通过脚本替换 API。 为了解决 XIB 设置图片的问题，我们首先想到了 AOP。通过 hook Xib 加载图片的方法将方法偷偷替换为 imageNamed:inBundle:，但是很遗憾 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 XIB 上所设置的图片名，也就意味着我们无法得知优化后的图片在哪个 bundle 下，也就不知道图片该如何加载。虽然有坎坷，但是我们始终坚信 XIB 一定是通过某些方法将图片加载出来的，我们一定能拿到这个过程！为了验证这个问题，首先定义一个 UIImageView 的子类，并将XIB 上的 UIImageView 指定为这个子类。大家都知道通过 XIB 加载的视图都一定会执行 initWithCoder: 方法。 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行完这行代码后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现aDecoder 有一些固定的 key，可以通过这些固定的 key 得到一部分信息。如 很显然通过 UIImage 这个 key 能拿到图片，但是很遗憾经过多次尝试没能找到图片的路径信息。因此这个问题的关键是怎么找到合适的 key，为了解决这个问题，最好是能拿到 aDecoder 的解码过程。因此 hook aDecoder 的解码方法 decodeObjectForKey:是个不错的选择。如果能拿到 xib 上设置的图片名称，那么我们就可以根据图片名称获取到正确的图片路径。经过断点查看 aDecoder 是 UINibDecoder（私有类）类型。 - (id)swizzle_decodeObjectForKey:(NSString )key{ Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (\\functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); return value; } 打印系统 decode 的所有 key 后发现有个 key 为 UIResourceName，value 为图片的名称。也就是说我们能得到 XIB 上设置的图片名称了。但是这个图片的名称怎么传递给这个 XIB 对应的 UIImageView 对象呢？换句话说也就是说我们怎么把图片传给这个 XIB 对应的 view 呢？为了将图片名称传给 UIImageView，需要给 aDecoder 添加一个 block 的关联引用。 在 hook 到的 decodeObjectForKey: 方法中将图片名称回传给 initWithDecoder: 方法。 这里需要注意的是一点是：XIB 默认设置图片是在 rentun value 之后，也就是说如果我们回调过早有可能图片被替换为 nil。因此需要 dispatch_after 一下，等 return 之后再回调图片名称并设置图片。受此启发，我们也可以 hook UIImage 的imageNamed: 方法，根据参数的规则到 xxxCopy.bundle 下获取图片，并返回图片。这就意味着放弃通过脚本修改 API，减少了代码的改动。看到这里似乎是没有什么问题，但是我们忽略了一个很严重的问题 aDecoder 对象和 UIImageView 类型的对象是一一对应的吗？一个 imageView 它的 aDecoder 是它唯一拥有的吗？带着这个问题，我们先来看下打印信息： 重复生成对象并打印后发现 aDecoder 的地址都相同，也就是说存在一个 aDecoder 对应多个 UIImageView 的现象。因此异步方案不适用，需要同步进行设置图片，因此全局变量最为合适。其实这一点很容易理解，aDecoder 是与 XIB 对应的，XIB 是不变的所以 aDecoder 是不变的。因此异步回调的方案不适用，需要同步进行设置图片，在这种情况（主线程串行执行）下跨类传值全局变量最为合适。 - (id)swizzle_decodeObjectForKey:(NSString )key{ Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (\\functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @&quot;emaNecruoseRIU&quot;; // 反转字符串 propKey = \\[XUtil stringByReversed:propKey\\]; if (\\[key isEqualToString:propKey\\]) { if (normal_imageName) { select_imageName = value; } else { normal_imageName = value; } } return value; } hook UIImageView 的 initWithCoder: - (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder{ // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)\\[self swizzle\\_imageView\\_initWithCoder:aDecoder\\]; if (normal\\_imageName &amp;&amp; \\[normal\\_imageName isKindOfClass:\\[NSString class\\]\\] &amp;&amp; normal_imageName.length &gt; 0) { UIImage * normalImage = \\[HookTool imageAfterSearch:normal_imageName\\]; // 赋值 if (normalImage) { instance.image = normalImage; } normal_imageName = nil; select_imageName = nil; } return instance; } 上面两段代码仅仅介绍思路。同理 hook 项目中 UIImage 所用到的加载图片的 API 即可加载图片。如果将所有的 hook 方法放到一个类中，那么只要将这个类拖入到项目中，并将项目中所有的 bundle 下的图片都放到对应的 Assets.xcassets 文件下那么无需修改一行代码即可将所有的图片迁移到 Assets.xcassets 下，达到应用瘦身的目的。 但是我们组内老练的架构师们指出：项目中 hook 如此重要的 API 对增加了项目维护的难度。这也引发了对项目中 AOP 场景的思考，项目中到底 hook 了多少 API？为此特地赶制了一个基于 fishhook 的一个 hook 打印工具，检测和统计项目中的 AOP 情况。但是缺点是必须调整编译顺序保证工具类最先被 load。 hook method_exchangeImplementations 方法。 检测方法（字典写入时不要忘了加锁）。 这种方式不能区分 image 和 backgroundImage、normal 和 Selected。目前根据观察顺序应该是： UIResourceName ： normal - image(前景图)UIResourceName ： normal - backgroundImage(背景图)UIResourceName ： selected - image(前景图)UIResourceName ： selected - backgroundImage(背景图)","tags":[]},{"title":" NSDateFormatter 性能\t\t","date":"2019-03-01T02:45:21.000Z","path":"2019/03/01/nsdateformatter-e6-80-a7-e8-83-bd/","text":"文章：NSDateFormatter 性能测试 NSDateFormatter dateFormatter = [[NSDateFormatter alloc] init];[dateFormatter setDateFormat:@”yyyy-MM-dd”];NSString current = [dateFormatter stringFromDate:[NSDate date]]; 关于 NSDateFormatter 创建耗时的资料很多，下面开始测试一下，究竟有多耗时。 double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = nil; { begin = CACurrentMediaTime(); for (int i = 0; i &lt; 1000; i++) { formatter = \\[\\[NSDateFormatter alloc\\] init\\]; \\[formatter setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; } end = CACurrentMediaTime(); NSLog(@&quot;NSDateFormatter: %8.2f ms&quot;, (end - begin) * 1000); } { begin = CACurrentMediaTime(); formatter = \\[\\[NSDateFormatter alloc\\] init\\]; for (int i = 0; i &lt; 1000; i++) { \\[formatter setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; } end = CACurrentMediaTime(); NSLog(@&quot;NSDateFormatter once: %8.2f ms&quot;, (end - begin) * 1000); } ———–Xcode 10.1 iPhone 6s(10.0)———- 2019-03-01 10:08:42.184 Demo[95118:1359994] NSDateFormatter: 48.73 ms2019-03-01 10:08:42.188 Demo[95118:1359994] NSDateFormatter once: 3.57 ms 2019-03-01 10:11:18.871 Demo[95164:1361958] NSDateFormatter: 61.18 ms2019-03-01 10:11:18.875 Demo[95164:1361958] NSDateFormatter once: 3.85 ms 2019-03-01 10:12:03.123 Demo[95178:1362677] NSDateFormatter: 79.80 ms2019-03-01 10:12:03.129 Demo[95178:1362677] NSDateFormatter once: 6.08 ms 上面可以看出两者之间消耗时间差距很大。创建单例很有必要。 那是 [[NSDateFormatter alloc] init] 初始化消耗太高吗？ NSDateFormatter * formatter = nil;double begin = 0.0;double end = 0.0;double a = 0, b = 0, c = 0; for (int i = 0; i &lt; 1000; i++) { begin = CACurrentMediaTime(); formatter = [[NSDateFormatter alloc] init]; end = CACurrentMediaTime(); a += (end - begin); begin = CACurrentMediaTime(); \\[formatter setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; end = CACurrentMediaTime(); b += (end - begin); begin = CACurrentMediaTime(); \\[formatter stringFromDate:\\[NSDate date\\]\\]; end = CACurrentMediaTime(); c += (end - begin); } NSLog(@”NSDateFormatter:alloc %8.2f ms”, a 1000);NSLog(@”NSDateFormatter:setFormat %8.2f ms”, b 1000);NSLog(@”NSDateFormatter:stringFromDate %8.2f ms”, c * 1000); ————-Xcode 10.1 iPhone 6s(10.0)————- 2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:alloc 7.01 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:setFormat 0.28 ms2019-03-01 10:11:18.939 Demo[95164:1361958] NSDateFormatter:stringFromDate 55.98 ms 2019-03-01 10:12:03.198 Demo[95178:1362677] NSDateFormatter:alloc 7.69 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:setFormat 0.25 ms2019-03-01 10:12:03.199 Demo[95178:1362677] NSDateFormatter:stringFromDate 60.97 ms 2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:alloc 6.01 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:setFormat 0.20 ms2019-03-01 10:18:43.946 Demo[95261:1366071] NSDateFormatter:stringFromDate 49.06 ms 从上面可以看出，实际最耗时的方法是 stringFromDate:/dateFromString:。再往下细究。 double begin = 0.0;double end = 0.0;NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) { \\[formatter setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; begin = CACurrentMediaTime(); \\[formatter stringFromDate:\\[NSDate date\\]\\]; end = CACurrentMediaTime(); NSLog(@&quot;%8.2f ms&quot;, (end - begin) * 1000); } ————-Xcode 10.0 iPhone 6s(10.0)————- 2019-03-01 10:27:06.218 Demo[95456:1372764] 1.43 ms2019-03-01 10:27:06.218 Demo[95456:1372764] 0.03 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.219 Demo[95456:1372764] 0.02 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.220 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms2019-03-01 10:27:06.221 Demo[95456:1372764] 0.01 ms 从上面可以看出，只有首次调用 stringFromDate:/dateFromString: 方法才会很耗时。再往下细究。 还有人说应该针对 format 格式创建对应的单例对象。 double begin = 0.0;double end = 0.0; // 不同的对象不同的 format 格式{ begin = CACurrentMediaTime(); NSDateFormatter * formatter1 = \\[\\[NSDateFormatter alloc\\] init\\]; NSDateFormatter * formatter2 = \\[\\[NSDateFormatter alloc\\] init\\]; NSDateFormatter * formatter3 = \\[\\[NSDateFormatter alloc\\] init\\]; NSDateFormatter * formatter4 = \\[\\[NSDateFormatter alloc\\] init\\]; for (int i = 0; i &lt; 1000; i++) { \\[formatter1 setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; \\[formatter1 stringFromDate:\\[NSDate date\\]\\]; \\[formatter2 setDateFormat:@&quot;MM-dd-yyyy&quot;\\]; \\[formatter2 stringFromDate:\\[NSDate date\\]\\]; \\[formatter3 setDateFormat:@&quot;MM-dd&quot;\\]; \\[formatter3 stringFromDate:\\[NSDate date\\]\\]; \\[formatter4 setDateFormat:@&quot;MM-yyyy&quot;\\]; \\[formatter4 stringFromDate:\\[NSDate date\\]\\]; } end = CACurrentMediaTime(); printf(&quot;NSDateFormatter: different format %8.2f ms\\\\n&quot;, (end - begin) * 1000); } // 同一个对象不同的 format 格式{ begin = CACurrentMediaTime(); NSDateFormatter * formatter = [[NSDateFormatter alloc] init]; for (int i = 0; i &lt; 1000; i++) { \\[formatter setDateFormat:@&quot;yyyy-MM-dd&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; \\[formatter setDateFormat:@&quot;MM-dd-yyyy&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; \\[formatter setDateFormat:@&quot;MM-dd&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; \\[formatter setDateFormat:@&quot;MM-yyyy&quot;\\]; \\[formatter stringFromDate:\\[NSDate date\\]\\]; } end = CACurrentMediaTime(); printf(&quot;NSDateFormatter: %8.2f ms\\\\n&quot;, (end - begin) * 1000); } —————Xcode 10.1 iPhone 6s(10.0)————— NSDateFormatter: different format 23.26 msNSDateFormatter: 16.25 ms 如果不计 NSDateFormatter 对象的初始化时间，那么打印输出： NSDateFormatter:different format 23.81 msNSDateFormatter: 23.02 ms 两者相差不大，创建一个单例即可。dateFormatter 初次使用时消耗较大，设置 format 格式却并没有什么影响。","tags":[]},{"title":" UIImage 加载图片的方式\t\t","date":"2019-02-28T16:16:02.000Z","path":"2019/03/01/uiimage-e5-8a-a0-e8-bd-bd-e5-9b-be-e7-89-87-e7-9a-84-e6-96-b9-e5-bc-8f/","text":"一、创建图片对象根据是否缓存图数据，有两类创建 UIImage 对象的方法可选： Use the imageNamed:inBundle:compatibleWithTraitCollection: method (or the imageNamed: method) to create an image from an image asset or image file located in your app’s main bundle (or some other known bundle). Because these methods cache the image data automatically, they are especially recommended for images that you use frequently. 1、有缓存 imageNamed: 可以加载 bundle 中任意位置的图片，包括 mainBundle 中其他 bundle 的。 imageNamed: 方法创建对象的步骤如下： ①、根据图片文件名在缓存池中查找图片数据，如果存在则创建对象并返回； ②、如果不存在，则从 bundle 中加载图片数据，创建对象并返回； ③、如果相应的图片数据不存在，返回 nil。 Use the imageWithContentsOfFile: or initWithContentsOfFile: method to create an image object where the initial data is not in a bundle. These methods load the image data from disk each time, so you should not use them to load the same image repeatedly. 2、无缓存 imageWithContentsOfFile: 必须传入图片文件的全名（全路径＋文件名）。无法加载 Images.xcassets 中的图片。 二、Images.xcassetsImages.xcassets 在 app 打包后，以 Assets.car 文件的形式出现在 bundle 中。其作用在于： ①、自动识别 @2x、@3x 图片，对内容相同但分辨率不同的图片统一管理； ②、可以对图片进行 Slicing，即剪裁和拉伸； ③、只能通过 imageNamed: 方法加载图片资源，通过 NSBundle 的 pathForResource:ofType: 无法获得图片路径； ④、使用 imageNamed: 加载时，只需提供文件名，不需提供扩展名，从别的的地方加载图片，必须在文件名后加扩展名； ⑤、适合存放系统常用的、占用内存小的图片资源； ⑥、只支持 png/jpeg，不支持诸如 gif 等其他图片格式； ⑦、同名图片很有可能造成异常和 bug。如：一个在 Assets.xcassets 被 sliced，另一个没有，则系统 sliced 图片。 ⑧、如果一个 sliced 过的图片连同相应的 Contents.json 一起拷贝，则处理效果会被保留。 三、从其他 Bundle 中加载资源从 mainBundle 中其他 bundle 加载资源，分为四步： ①、在 mainBundle 中找到特定 bundle。 ②、载入 bundle，即创建 bundle 对象。 ③、从 bundle 中获取资源路径。注意，如果资源位于次级目录，则必须指明路径。 ④、通过路径创建对象。 四、文章UIImage加载图片的方式以及Images.xcassets对于加载方法的影响 笔记@Bundle Programming Guide","tags":[]},{"title":" 将图片资源打包成 bundle文件\t\t","date":"2019-02-28T15:41:29.000Z","path":"2019/02/28/e5-b0-86-e5-9b-be-e7-89-87-e8-b5-84-e6-ba-90-e6-89-93-e5-8c-85-e6-88-90-bundle-e6-96-87-e4-bb-b6/","text":"A bundle is a directory with a standardized hierarchical structure that holds executable code and the resources used by that code. bundle 是一种标准的目录结构，能够包含可执行程序，以及程序执行所需的资源文件。 bundle 的作用在于规范代码及其资源的位置，便于系统访问。 .app/.bundle/.framework 都是 bundle 的后缀。 缺少 info.plist 的 bundle 一样可以使用，但会失去某些特性。 对于有 info.plist 的 bundle 来说，CFBundleDisplayName 代表其在操作系统中的显示名，CFBundleName 才是其真正意义上（代码所用）的名。 笔记@Bundle Programming Guide 一、简单创建无 info.plist 的 bundle新建文件夹，然后显示简介修改后缀名为 .bundle。 二、Xcode 创建 bundle1、新建项目 command + shift + N。 2、点击创建好的 bundle ，修改属性 ①、Base SDK 设置为 “iOS”。Build Active Architecture Only 设置为 “YES” ②、Installation Directiotory 删除掉后面的路径。Skip Install 设置为 “NO” ③、Code Signing Identity 选择 Don’t Code Sign 或者为空。 ④、iOS Deployment Target 设置为 iOS 8.0 (为了兼容性最好选择最低版本) ⑥、Strip Debug Symbols During Copy 中 Release 模式设置为 “YES” ⑦、COMBINE_HIDPI_IMAGES 设置为 “NO” 3、开始导入图片资源 ①、直接拖项目中，系统会自动导入 Copy Bundle Resources 里。 ②、在 Build Phases 加进去。 ③、使用 Xcode 自带的 Assets，可以自动识别图片是 @2x 屏还是 @3x 屏，拖到 Assets 文件里会自动识别位置。 4、选择创建的 bundle 进行编译，开始生成 bundle，分别选择真机和模拟器，然后各运行一遍，即可生成真机和模拟器使用的bundle。 找到生成的 bundle，打包上架 APP 的时候应使用真机模式下运行生成的 Bundle，即 Debug-iphoneos 文件夹内的 bundle。 5、bundle 的使用。因为 bundle 是静态的、不进行编译的资源文件。所以，要使用 bundle 中的资源，就需要找到相应的资源路径。 // ①UIImage * image = [UIImage imageNamed:@”MyBundle.bundle/icon.png”]; // ②NSString bundlePath = [[ NSBundle mainBundle] pathForResource:@”MyBundle” ofType:@”bundle”];NSBundle bundle = [NSBundle bundleWithPath:bundlePath];NSString imgPath = [bundle pathForResource:@”icon” ofType:@”png”];UIImage image = [UIImage imageWithContentsOfFile:imgPath]; App 打包上传失败提示： 删除 bundle 里的执行文件：找到工程中的 MyBundle.Bundle，右键单击后选择 “显示包内容”，找到里面的 info.plist 文件 ，删除掉 Executable file 字段，重新打包，上传应用商店就可以了。（未验证）","tags":[]},{"title":" .pch\t\t","date":"2019-02-28T07:39:59.000Z","path":"2019/02/28/pch/","text":"Xcode6 之前会在 Supporting Files 文件夹下自动生成一个“工程名-PrefixHeader.pch”的预编译头文件，pch 头文件的内容能被项目中的其他所有源文件共享和访问。之后则需要手动创建。 一、作用①、定义全局性宏； ②、引用全局性头文件； ③、根据运行环境，自动打开或者关闭日志输出功能。 二、优点①、PCH 文件的内容能被项目中的其他所有文件共享和访问，其它地方可直接使用，不用再手动重复定义或引用； ②、预编译后的头文件会被缓存起来，再次编译时不需要重新编译 PCH 文件中导入的内容，从而提高编译速度。 三、缺点①、把类中使用的框架等放到 PCH 中，依赖关系不明确，不利于代码的迁移和解耦，降低了代码的可移植性和复用性。 ②、大量的共用性不高的宏定义和头文件引入，会导致编译时整个工程范围地查找和替换这些宏定义字段，或重复导入这些头文件，造成时间过长； 四、思考①、PCH 的目的是：提高编译速度，而不是少敲几行 #import； ②、造成这些问题的原因在于对 PCH 文件的使用方式和方法不对。要正确、适度的使用 PCH 文件，不要滥用； ③、可以考虑按照层级或者功能模块等方式，定义多个头文件。将该层级或者模块共用性较高的宏或文件写入，供本层使用。如果整个工程需要使用，再导入 PCH 文件。这样既可以避免或减少同一个且多余的文件被重复编译，增加编译时间，又可以方便地使用一些全局的东西。 ④、关于宏定义：宏定义是在预编译的时候处理的。因此，当你修改宏定义的时候会导致大量的代码被重新编译。另外，宏定义存在许多潜在的 bug 是因为在预编译的时候，它并不会被发觉到。替代宏定义，可以考虑使用常量 const。 ⑤、关于引用：iOS7 之后，系统的 Module 都可以被 “semantic import”。把原来的 #import 换成 @import 即可。比如：#import &lt;Foundation/Foundation.h&gt; 换成 @import Foundation; 即可。编译器遇到 @import 时，会将预编译好的 framework 载入，同时也不需要到 project settings 里添加 framework，系统做这些事情。这些 Module 只会编译一次。 ⑥、如果不使用 pch，可以使用继承处理公用的宏、框架和三方库。在父类的头文件中定义宏和导入共用框架、三方库，需要用到的去继承。 ⑦、宏、框架和三方库共用性高不高有时候很难去界定和把握，就会造成纠结状态，干脆尽量不用了。 五、文章PCH 文件的优缺点 PCH文件的新建和其缺点","tags":[]},{"title":" 修改项目名称\t\t","date":"2019-02-27T10:05:44.000Z","path":"2019/02/27/e4-bf-ae-e6-94-b9-e9-a1-b9-e7-9b-ae-e5-90-8d-e7-a7-b0/","text":"重命名项目时，记得先备份好一份。 一、对项目名进行重命名1、选中项目名并按下回车，进入编辑状态后修改名称。 2、修改成新的项目名称后，弹出改名前和改名后的文件对名，这时点击 Rename： 二、修改文件夹名称和显示包内容1、打开应用所在文件夹，修改文件夹名字 注意： 文件夹 Tests 和 UITests 的子目录名也要修改； 只需要把旧名称（CiYunApp）替换成新名称（Replacement）即可，保留其它字符（Tests）。 2、选中 CiYunApp.xcodeproj 右键显示包内容 –&gt; 双击打开 project.pbxproj 。 3、打开 project.pbxproj 文件后，command + f 全局搜索旧的项目名 CiYunApp ，并用新的项目名 Replacement 进行替换。替换完成后保存 command + s，关闭。 注意：要 Replace All。 三、 .xcodeproj 文件和 .xcworkspace 文件1、打开 .xcworkspace 文件会弹出提示框，点击 OK 就行。 2、修改更新 Podfile 文件 使用 CocoaPods 的话，运行之后发现提示错误：diff: /../Podfile.lock: No such file or directory. 解决： ①、先关闭 Xcode 然后 pod install ②、如果不行就删除 .xcworkspace、Podfile.lock、Pods文件夹、~/Library/Developer/Xcode/DerivedData 路径下对应工程的文件夹；然后 pod install。 或者出现错误： 打开项目文件夹，找到 Podfile 文件，修改 target 后的项目名为新项目名 Replacement。 target ‘Replacement’ do end 然后在终端 cd 到项目 podfile 文件目录下，运行 $ pod install 进行更新。 3、打开 .xcworkspace 文件 文件标红显示错误：因为文件路径的原因。 选中显示红色的 CiYunApp 文件，点击右侧文件夹小图标，更改路径。 路径更改成功之后，项目基本就可以运行成功了。 四、修改 Scheme 名选中 CiYunApp –&gt; 下拉中选中 Manage Schemes –&gt; 弹出一个显示框。 选中要修改的 CiYunApp 那一行，按下回车，进行修改新的名称 Replacement，然后点击 Close。 五、项目内全局修改、替换其实到上面，项目已经基本修改完成了，但还有一些注释里面存在旧项目名称： 全局搜索旧的项目名，把 Find 修改为 Replace，然后 Replace All 全部替换。 到此，项目名已经完全修改完成了。 六、文章在iOS项目中，如何完美的修改项目名称","tags":[]},{"title":" 组件化 xib 图片设置方案\t\t","date":"2019-02-27T02:59:22.000Z","path":"2019/02/27/e7-bb-84-e4-bb-b6-e5-8c-96-xib-e5-9b-be-e7-89-87-e8-ae-be-e7-bd-ae-e6-96-b9-e6-a1-88/","text":"工程采用 cocoaPods + git 实现组件化功能，遇到了图片加载失败问题，系统的 [UIImage imageNamed:@””] 方法加载的是 mainBundle 中的资源，显然无法获取到所在或其它组件中的图片资源。 为了解决这个问题，显然需要获取到图片所在的 bundle，并从中加载资源。 # pragma mark - 获取 xib、图片资源 /** * @param cls 与资源在同一目录下的类，用于获取 bundle * @param module 资源名 */+ (NSBundle )bundleWithClassName:(Class)cls moduleName:(NSString)module{ if (cls == nil) { return [NSBundle mainBundle]; } // 根据 class 获取 bundle NSBundle * bundle = \\[NSBundle bundleForClass:cls\\]; NSURL * bundleURL = \\[bundle URLForResource:module withExtension:@&quot;bundle&quot;\\]; // bundle 未找到 if (bundleURL == nil) { __block UINavigationController * nav; \\[\\[UIApplication sharedApplication\\].windows enumerateObjectsUsingBlock:^(\\_\\_kindof UIWindow * \\_Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { UIViewController * windowVC = obj.rootViewController; if (\\[windowVC isKindOfClass:\\[UINavigationController class\\]\\]) { nav = (UINavigationController *)windowVC; *stop = YES; } }\\]; // 根据当前 navigationViewController 的堆栈 vc.class 获取 bundle if (nav != nil) { Class callerCls = \\[nav.viewControllers.firstObject class\\]; bundle = \\[NSBundle bundleForClass:callerCls\\]; bundleURL = \\[bundle URLForResource:module withExtension:@&quot;bundle&quot;\\]; } // 只能返回 mainBundle if (bundleURL == nil) { return \\[NSBundle mainBundle\\]; } } return \\[NSBundle bundleWithURL:bundleURL\\]; } + (UIImage )imageNamed:(NSString )imageName module:(NSString *)module cls:(Class)cls{ if (module == nil || module.length == 0) { module = @”IOS”; // 默认的资源名 } if (cls == nil) { cls = \\[self class\\]; // 默认的类 } return \\[UIImage imageNamed:imageName inBundle:\\[self bundleWithClassName:cls moduleName:module\\] compatibleWithTraitCollection:nil\\]; } 执行步骤： ①、根据传入的 class 和 module 获取资源所在 url； ②、第 1 步无效时，根据视图堆栈获取到 class，再执行第 1 步同样的方法； ③、第 1、2 步无效时，返回 mainBundle（图片可能加载失败）。 找到 bundle 之后，需要给 UIImageView、UIButton 设置图片。 为了解决 xib 设置图片的问题，首先想到了 AOP（面向切面编程）。通过 hook xib 加载图片的方法，然后将方法偷偷替换为imageNamed:inBundle:，但是 hook 了 UIImage 所有加载图片的方法，没有一个方法能拿到 xib 上所设置的图片名称，也就不知道图片该如何加载。 为了验证这个问题，首先定义一个 UIImageView 的子类，重写 initWithCoder: 方法。 - (instancetype)initWithCoder:(NSCoder *)aDecoder{ id temp = [super initWithCoder:aDecoder]; return temp; } 发现在执行 [super initWithCoder:aDecoder] 之前通过 lldb 查看 self.image 是 nil。当执行之后 self.image 就有值了。因此推断图片的信息（图片名称、路径等信息）都在 aDecoder 中！在网上搜索了一些资料后发现 aDecoder 有一些固定的 key。 所以接下来通过 hook UINibDecoder、UIImageView、UIButton 类，获取图片名称。 /** hook UINibDecoder 类的 decodeObjectForKey，用于获取图片名称 **/@interface HookTool : NSObject @end #import &lt;objc/runtime.h&gt; #import “XUtil.h” NSString normal_imageName; // 全局变量。不能用 @property 或者 { NSString normal_imageName; } 会崩溃NSString * select_imageName; // 选中状态的图片。经过打印显示，所有状态的 key 值都是 UIResourceName，输出顺序为：normal -》highlighted -》selected -》disabled @implementation HookTool + (void)load{ // hook UINibDecoder - decodeObjectForKey: NSString* clsName = [NSString stringWithFormat:@”redoce%@biNIU”, @”D”]; clsName = [XUtil stringByReversed:clsName]; \\[HookTool exchangeInstanceMethod:NSClassFromString(clsName) originalSEL:@selector(decodeObjectForKey:) swizzledSEL:@selector(swizzle_decodeObjectForKey:)\\]; // hook UIImageView - initWithCoder: \\[HookTool exchangeInstanceMethod:UIImageView.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle\\_imageView\\_initWithCoder:)\\]; // hook UIButton - initWithCoder: \\[HookTool exchangeInstanceMethod:UIButton.class originalSEL:@selector(initWithCoder:) swizzledSEL:@selector(swizzle\\_button\\_initWithCoder:)\\]; } - (id)swizzle_decodeObjectForKey:(NSString )key{ Method originalMethod = class_getInstanceMethod([HookTool class], @selector(swizzle_decodeObjectForKey:)); IMP function = method_getImplementation(originalMethod); id (\\functionPoint)(id, SEL, id) = (id (*)(id, SEL, id)) function; id value = functionPoint(self, _cmd, key); NSString* propKey = @&quot;emaNecruoseRIU&quot;; propKey = \\[XUtil stringByReversed:propKey\\]; if (\\[key isEqualToString:propKey\\]) { if (normal_imageName) { select_imageName = value; } else { normal_imageName = value; } } return value; } /** * @brief hook UIImageView 的 initWithCode: 方法 */- (id)swizzle_imageView_initWithCoder:(NSCoder *)aDecoder{ // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 imageView 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 imageView 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIImageView * instance = (UIImageView *)\\[self swizzle\\_imageView\\_initWithCoder:aDecoder\\]; if (normal\\_imageName &amp;&amp; \\[normal\\_imageName isKindOfClass:\\[NSString class\\]\\] &amp;&amp; normal_imageName.length &gt; 0) { UIImage * normalImage = \\[HookTool imageAfterSearch:normal_imageName\\]; // 赋值 if (normalImage) { instance.image = normalImage; } normal_imageName = nil; select_imageName = nil; } return instance; } /** * @brief hook UIButton 的 initWithCode: 方法 */- (id)swizzle_button_initWithCoder:(NSCoder *)aDecoder{ // 执行顺序：initWithCoder -》DecoderWithKey -》setImage：，所以每次给 button 设置图片时，需要将之前的置空。 // tabbarItem 的图片设置不会执行 initWithCoder，如果不置空，会导致 button 设置成和 tabbarItem 一样的图片。 normal_imageName = nil; select_imageName = nil; UIButton * instance = (UIButton *)\\[self swizzle\\_button\\_initWithCoder:aDecoder\\]; // 正常状态 if (normal\\_imageName &amp;&amp; \\[normal\\_imageName isKindOfClass:\\[NSString class\\]\\] &amp;&amp; normal_imageName.length &gt; 0) { UIImage * normalImage = \\[HookTool imageAfterSearch:normal_imageName\\]; if (normalImage) { \\[instance setImage:normalImage forState:UIControlStateNormal\\]; } normal_imageName = nil; } // 选中状态 if (select\\_imageName &amp;&amp; \\[select\\_imageName isKindOfClass:\\[NSString class\\]\\] &amp;&amp; select_imageName.length &gt; 0) { UIImage * selectImage = \\[HookTool imageAfterSearch:select_imageName\\]; if (selectImage) { \\[instance setImage:selectImage forState:UIControlStateSelected\\]; } select_imageName = nil; } return instance; } /** * @brief 获取查找后的图片 */+ (UIImage )imageAfterSearch:(NSString )imageName{ UIImage * resultImage = [XUtil imageNamed:imageName module:nil cls:nil]; // 去 mainBundle 中找 if (!resultImage) { resultImage = \\[UIImage imageNamed:imageName\\]; } return resultImage; } #pragma mark - Tool/** * @brief 替换方法实现 */+ (void)exchangeInstanceMethod:(Class)otherClass originalSEL:(SEL)originalSEL swizzledSEL:(SEL)swizzledSEL{ Method originalMethod = class_getInstanceMethod(otherClass, originalSEL); Method swizzledMethod = class_getInstanceMethod(self, swizzledSEL); // otherClass 添加替换后的 SEL，避免 unrecognizeSelectorSentToInstance 错误 class_addMethod( otherClass, swizzledSEL, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); // 替换 otherClass 类的旧方法实现 BOOL c = class_addMethod( otherClass, originalSEL, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (!c) { method_exchangeImplementations(originalMethod, swizzledMethod); } } 其中 XUtil 包含了获取 bundle 的方法和以下反转字符串的方法。 + (NSString )stringByReversed:(NSString)origStr{ NSMutableString *s = [NSMutableString string]; for (NSUInteger i=origStr.length; i&gt;0; i–) { [s appendString:[origStr substringWithRange:NSMakeRange(i-1, 1)]]; } return s;} 这种方式不能区分 image 和 backgroundImage、normal 和 Selected，使用场景受到一些限制。","tags":[]},{"title":" 依赖注入\t\t","date":"2019-02-26T10:20:08.000Z","path":"2019/02/26/e4-be-9d-e8-b5-96-e6-b3-a8-e5-85-a5/","text":"依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。 初始化方法注入： - (instancetype)initWithDependency1:(Dependency1 )d1 dependency2:(Dependency2 )d2; 属性注入： @property (nonatomic, retain) Dependency1 dependency1;@property (nonatomic, retain) Dependency2 dependency2; 一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。 一、为什么使用依赖注入依赖注入的几个重要之处： ①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量； ②、使用构成。 即一直坚持的多构成少继承原则。它能提高代码的可重用性； ③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。 ④、明确的所有者。 ⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。 二、使用依赖注入1、注入类的类型 首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。 简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。 复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。 分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。 2、在初始化时依赖分配 原始代码： @interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end @implementation RCRaceCar - (instancetype)init{ if (self = [super init]) { … _engine = [[RCEngine alloc] init]; } return self;} @end 使用依赖注入改版后： @interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@end @implementation RCRaceCar - (instancetype)initWithEngine:(RCEngine *)engine{ if (self = [super init]) { ... _engine = engine; } return self; } @end 3、延迟初始化依赖 通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子： @implementation RCRaceCar - (void)recoverFromCrash{ if (self.fire != nil) { RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init]; [fireExtinguisher extinguishFire:self.fire]; }} @end 在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。 工厂方法是一个标准的 Objective-C 的 block, 它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。 下面，通过一个工厂，使用依赖注入创建一个灭火器。 typedef RCFireExtinguisher *(^RCFireExtinguisherFactory)(); @interface RCRaceCar ()@property (nonatomic, readonly) RCEngine * engine;@property (nonatomic, copy, readonly) RCFireExtinguisherFactory fireExtinguisherFactory;@end @implementation RCRaceCar - (instancetype)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory{ if (self = [super init]) { ... _engine = engine; _fireExtinguisherFactory = \\[extFactory copy\\]; } return self; } - (void)recoverFromCrash{ if (self.fire != nil) { RCFireExtinguisher * fireExtinguisher = self.fireExtinguisherFactory(); [fireExtinguisher extinguishFire:self.fire]; }} @end 工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下： @implementation RCRaceCar - (instancetype)initWithEngine:(RCEngine )engine transmission:(RCTransmission )transmission wheelFactory:(RCWheel *(^)())wheelFactory;{ if (self = [super init]) { _engine = engine; _transmission = transmission; _leftFrontWheel = wheelFactory(); _leftRearWheel = wheelFactory(); _rightFrontWheel = wheelFactory(); _rightRearWheel = wheelFactory(); // 保留轮子工厂，之后还需要一个备胎。 _wheelFactory = \\[wheelFactory copy\\]; } return self; } @end 三、避免多余的配置如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。 在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。 为了配置我们的对象，将从 4 个点来收集我们的依赖： ①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中； ②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值； ③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。 ④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。 下面是关于赛车的简单初便利构造器 + (instancetype)raceCarWithPitRadioFrequency:(RCRadioFrequency )frequency{ RCEngine engine = [[RCEngine alloc] init]; RCTransmission * transmission = [[RCTransmission alloc] init]; RCWheel *(^wheelFactory)() = ^{ return \\[\\[RCWheel alloc\\] init\\]; }; return \\[\\[self alloc\\] initWithEngine:engine transmission:transmission pitRadioFrequency:frequency wheelFactory:wheelFactory\\]; } 便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。 四、系统单例在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。 这里建议避免在你的代码中创建全局的单例，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。 五、不可修改的构造函数有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码： // 一个我们不能直接调用初始化方法的例子。RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];// 我们仍然可以使用属性来配置我们的赛车路径raceTrack.width = 10;raceTrack.numberOfHairpinTurns = 2; setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。 六、类注册“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码： NSArray raceCarClasses = @[ [RCFastRaceCar class], [RCSlowRaceCar class] ];NSMutableArray raceCars = [[NSMutableArray alloc] init]; for (Class raceCarClass in raceCarClasses) { // 所有赛车必须有相同的初始化方法 (在这个例子中是 “init” 方法). // 这里意味着我们不能自定义不同的子类 [raceCars addObject:[[raceCarClass alloc] init]];} // 一个简单的替换方法是：使用工厂 block 来代替 typedef RCRaceCar *(^RCRaceCarFactory)(); NSArray raceCarFactories = @[ ^{ return [[RCFastRaceCar alloc] initWithTopSpeed:200]; }, ^{ return [[RCSlowRaceCar alloc] initWithLeatherPlushiness:11]; } ];NSMutableArray raceCars = [[NSMutableArray alloc] init]; for (RCRaceCarFactory raceCarFactory in raceCarFactories) { // 现在这样，我们就不用关心到底是那个初始化方法被调用了 [raceCars addObject:raceCarFactory()];} 七、StoryboardsStoryboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。 解决方法是避免使用 storyboard。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。 八、公有和私有依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。 // In public ObjectA.h.@interface ObjectA // 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件- (instancetype)initWithObjectB:(ObjectB *)objectB;@end @interface ObjectB // 这里也一样：需要暴露 ObjectC.h- (instancetype)initWithObjectC:(ObjectC *)objectC;@end @interface ObjectC- (instancetype)init;@end 对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。 @interface ObjectA- (instancetype)initWithObjectB:(id )objectB;@end // 这个协议只暴露 ObjectA 需要原始的 ObjectB。// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 @protocol ObjectB- (void)methodNeededByObjectA;@end 九、一次高效的依赖注入1、问题场景 如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的： 这里依赖路径有两条： ①、主项目依赖第三方 pods。 ②、组件依赖第三方 pods，主项目再依赖组件。 单向的依赖关系决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，组件却没有办法主动和主项目通讯。 可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。 2、依赖注入 依赖注入有另外一个名字，叫做“控制反转”。 像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。 所以依赖注入有两个比较重要的点： ①、要实现这种反转控制的功能。 ②、要解耦。 不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。 出自这篇文章：理解依赖注入与控制反转 3、iOS 依赖注入调查 iOS 平台实现依赖注入功能的开源项目有两个大头：objection、typhoon。 详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。 还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。 那有没有其他没那么方案呢？libextobjc libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点： ①、充分使用了 OC 动态语言的特性，不侵入项目 ②、高度自动化 ③、框架十分轻量（只有一个 .h 和 .m 文件） ④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。 4、EXTConcreteProtocol 实现原理 有两个比较重要的概念需要提前明白才能继续往下讲。 ①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。 ②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。 如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。 4.1、EXTConcreteProtocol 的使用 比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。 @protocol ObjectProtocol (void)sayHello; (int)age; @end @concreteprotocol(ObjectProtocol) (void)sayHello{ NSLog(@”Hello”);} (int)age{ return 18;} @end 之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。 @interface Person : NSObject @end 我们接下来就可以对 Person 调用注入的方法。 int main(int argc, char argv[]) { Person p = [Person new]; NSLog(@”%@”, [p age]); [p.class sayHello];} 18Hello 4.2、源码解析 先来看一下头文件： #define concreteprotocol(NAME) \\ /* * create a class used to contain all the methods used in this protocol / \\ // 定义一个容器类 interface NAME ## _ProtocolMethodContainer : NSObject &lt; NAME &gt; {} \\ @end \\ \\ @implementation NAME ## _ProtocolMethodContainer \\ /\\ * when this class is loaded into the runtime, add the concrete protocol * into the list we have of them / \\ // load 方法添加混合协议 + (void)load { \\ /\\ * passes the actual protocol as the first parameter, then this class as * the second / \\ if (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), self)) \\ fprintf(stderr, “ERROR: Could not load concrete protocol %s\\n”, metamacro_stringify(NAME)); \\ } \\ \\ /\\ * using the “constructor” function attribute, we can ensure that this * function is executed only AFTER all the Objective-C runtime setup (i.e., * after all +load methods have been executed) / \\ // 在 load 之后，main 之前执行方法注入 __attribute__((constructor)) \\ static void ext_ ## NAME ## _inject (void) { \\ /\\ * use this injection point to mark this concrete protocol as ready for * loading */ \\ ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \\ } /*** implementation details follow **/// load 方法添加混合协议BOOL ext_addConcreteProtocol (Protocol protocol, Class methodContainer);// load 之后，main 之前执行方法注入void ext_loadConcreteProtocol (Protocol *protocol); 可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。 然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。 // contains the information needed to reference a full special protocoltypedef struct { // the actual protocol declaration (@protocol block) 用户定义的协议. __unsafe_unretained Protocol *protocol; // the injection block associated with this protocol // // this block is RETAINED and must eventually be released by transferring it // back to ARC // 在 \\_\\_attribute\\_\\_((constructor)) 时往指定类里注入方法的 block. void *injectionBlock; // whether this protocol is ready to be injected to its conforming classes // // this does NOT refer to a special protocol having been injected already // 对应的协议是否已经准备好注入. BOOL ready; } EXTSpecialProtocol; BOOL ext_addConcreteProtocol (Protocol *protocol, Class containerClass) { return ext_loadSpecialProtocol(protocol, ^(Class destinationClass){ ext_injectConcreteProtocol(protocol, containerClass, destinationClass); });} BOOL ext_loadSpecialProtocol (Protocol *protocol, void (^injectionBehavior)(Class destinationClass)) { @autoreleasepool { NSCParameterAssert(protocol != nil); NSCParameterAssert(injectionBehavior != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread\\_mutex\\_lock(&amp;specialProtocolsLock) != 0) { fprintf(stderr, &quot;ERROR: Could not synchronize on special protocol data\\\\n&quot;); return NO; } // if we&apos;ve hit the hard maximum for number of special protocols, we can&apos;t // continue if (specialProtocolCount == SIZE_MAX) { pthread\\_mutex\\_unlock(&amp;specialProtocolsLock); return NO; } // if the array has no more space, we will need to allocate additional // entries // specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols. if (specialProtocolCount &gt;= specialProtocolCapacity) { size_t newCapacity; if (specialProtocolCapacity == 0) // if there are no entries, make space for just one newCapacity = 1; else { // otherwise, double the current capacity newCapacity = specialProtocolCapacity &lt;&lt; 1; // if the new capacity is less than the current capacity, that&apos;s // unsigned integer overflow if (newCapacity &lt; specialProtocolCapacity) { // set it to the maximum possible instead newCapacity = SIZE_MAX; // if the new capacity is still not greater than the current // (for instance, if it was already SIZE_MAX), we can&apos;t continue if (newCapacity &lt;= specialProtocolCapacity) { pthread\\_mutex\\_unlock(&amp;specialProtocolsLock); return NO; } } } // we have a new capacity, so resize the list of all special protocols // to add the new entries void * restrict ptr = realloc(specialProtocols, sizeof(\\*specialProtocols) \\* newCapacity); if (!ptr) { // the allocation failed, abort pthread\\_mutex\\_unlock(&amp;specialProtocolsLock); return NO; } specialProtocols = ptr; specialProtocolCapacity = newCapacity; } // at this point, there absolutely must be at least one empty entry in the // array assert(specialProtocolCount &lt; specialProtocolCapacity); // disable warning about &quot;leaking&quot; this block, which is released in // ext_injectSpecialProtocols() #ifndef \\_\\_clang\\_analyzer__ ext_specialProtocolInjectionBlock copiedBlock = \\[injectionBehavior copy\\]; // construct a new EXTSpecialProtocol structure and add it to the first // empty space in the array // 将协议保存为一个 EXTSpecialProtocol 结构体。 specialProtocols\\[specialProtocolCount\\] = (EXTSpecialProtocol){ .protocol = protocol, .injectionBlock = (\\_\\_bridge\\_retained void *)copiedBlock, .ready = NO }; #endif ++specialProtocolCount; pthread\\_mutex\\_unlock(&amp;specialProtocolsLock); } // success! return YES; } ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。 ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。 static void ext_injectConcreteProtocol (Protocol protocol, Class containerClass, Class class) { // get the full list of instance methods implemented by the concrete // protocol 获取容器类里所有的实例方法. unsigned imethodCount = 0; Method imethodList = class_copyMethodList(containerClass, &amp;imethodCount); // get the full list of class methods implemented by the concrete // protocol 获取容器类里所有的类方法方法. unsigned cmethodCount = 0; Method *cmethodList = class\\_copyMethodList(object\\_getClass(containerClass), &amp;cmethodCount); // get the metaclass of this class (the object on which class // methods are implemented) 拿到要注入方法的类的元类. Class metaclass = object_getClass(class); // inject all instance methods in the concrete protocol 注入实例方法. for (unsigned methodIndex = 0;methodIndex &lt; imethodCount;++methodIndex) { Method method = imethodList\\[methodIndex\\]; SEL selector = method_getName(method); // first, check to see if such an instance method already exists // (on this class or on a superclass) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(class, selector)) { // it does exist, so don&apos;t overwrite it continue; } // add this instance method to the class in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(class, selector, imp, types)) { fprintf(stderr, &quot;ERROR: Could not implement instance method -%s from concrete protocol %s on class %s\\\\n&quot;, sel\\_getName(selector), protocol\\_getName(protocol), class_getName(class)); } } // inject all class methods in the concrete protocol 注入类方法. for (unsigned methodIndex = 0;methodIndex &lt; cmethodCount;++methodIndex) { Method method = cmethodList\\[methodIndex\\]; SEL selector = method_getName(method); // +initialize is a special case that should never be copied // into a class, as it performs initialization for the concrete // protocol // +initialize 不能被注入. if (selector == @selector(initialize)) { // so just continue looking through the rest of the methods continue; } // first, check to see if a class method already exists (on this // class or on a superclass) // // since &apos;class&apos; is considered to be an instance of &apos;metaclass&apos;, // this is actually checking for class methods (despite the // function name) // 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现. if (class_getInstanceMethod(metaclass, selector)) { // it does exist, so don&apos;t overwrite it continue; } // add this class method to the metaclass in question IMP imp = method_getImplementation(method); const char *types = method_getTypeEncoding(method); if (!class_addMethod(metaclass, selector, imp, types)) { fprintf(stderr, &quot;ERROR: Could not implement class method +%s from concrete protocol %s on class %s\\\\n&quot;, sel\\_getName(selector), protocol\\_getName(protocol), class_getName(class)); } } // free the instance method list 管理内存 free(imethodList); imethodList = NULL; // free the class method list free(cmethodList); cmethodList = NULL; // use \\[containerClass class\\] and discard the result to call +initialize // on containerClass if it hasn&apos;t been called yet // // this is to allow the concrete protocol to perform custom initialization // 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行. (void)\\[containerClass class\\]; } 我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。 void ext_specialProtocolReadyForInjection (Protocol *protocol) { @autoreleasepool { NSCParameterAssert(protocol != nil); // lock the mutex to prevent accesses from other threads while we perform // this work 加锁 if (pthread\\_mutex\\_lock(&amp;specialProtocolsLock) != 0) { fprintf(stderr, &quot;ERROR: Could not synchronize on special protocol data\\\\n&quot;); return; } // loop through all the special protocols in our list, trying to find the // one associated with &apos;protocol&apos; // 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES. for (size_t i = 0;i &lt; specialProtocolCount;++i) { if (specialProtocols\\[i\\].protocol == protocol) { // found the matching special protocol, check to see if it&apos;s // already ready if (!specialProtocols\\[i\\].ready) { // if it&apos;s not, mark it as being ready now specialProtocols\\[i\\].ready = YES; // since this special protocol was in our array, and it was not // loaded, the total number of protocols loaded must be less // than the total count at this point in time assert(specialProtocolsReady &lt; specialProtocolCount); // ... and then increment the total number of special protocols // loaded – if it now matches the total count of special // protocols, begin the injection process if (++specialProtocolsReady == specialProtocolCount) // 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入. ext_injectSpecialProtocols(); } break; } } pthread\\_mutex\\_unlock(&amp;specialProtocolsLock); } } 上面都是准备工作，接下来开始进入核心方法进行注入。 /** * This function actually performs the hard work of special protocol injection. * It obtains a full list of all classes registered with the Objective-C * runtime, finds those conforming to special protocols, and then runs the * injection blocks as appropriate. /static void ext_injectSpecialProtocols (void) { /\\ * don’t lock specialProtocolsLock in this function, as it is called only * from public functions which already perform the synchronization */ /\\* \\* This will sort special protocols in the order they should be loaded. If \\* a special protocol conforms to another special protocol, the former \\* will be prioritized above the latter. */ // 对协议进行排序. // 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的 load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现. // 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面. qsort_b(specialProtocols, specialProtocolCount, sizeof(EXTSpecialProtocol), ^(const void \\*a, const void \\*b){ // if the pointers are equal, it must be the same protocol if (a == b) return 0; const EXTSpecialProtocol *protoA = a; const EXTSpecialProtocol *protoB = b; // A higher return value here means a higher priority int (^protocolInjectionPriority)(const EXTSpecialProtocol *) = ^(const EXTSpecialProtocol *specialProtocol){ int runningTotal = 0; for (size_t i = 0;i &lt; specialProtocolCount;++i) { // the pointer passed into this block is guaranteed to point // into the &apos;specialProtocols&apos; array, so we can compare the // pointers directly for identity if (specialProtocol == specialProtocols + i) continue; if (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols\\[i\\].protocol)) runningTotal++; } return runningTotal; }; /\\* \\* This will return: \\* 0 if the protocols are equal in priority (such that load order does not matter) \\* &lt; 0 if A is more important than B \\* \\&gt; 0 if B is more important than A */ return protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA); }); // 获取项目中所有的类 unsigned classCount = objc_getClassList(NULL, 0); if (!classCount) { fprintf(stderr, &quot;ERROR: No classes registered with the runtime\\\\n&quot;); return; } Class \\*allClasses = (Class \\*)malloc(sizeof(Class) * (classCount + 1)); if (!allClasses) { fprintf(stderr, &quot;ERROR: Could not allocate space for %u classes\\\\n&quot;, classCount); return; } // use this instead of ext_copyClassList() to avoid sending +initialize to // classes that we don&apos;t plan to inject into (this avoids some SenTestingKit // timing issues) classCount = objc_getClassList(allClasses, classCount); /\\* \\* set up an autorelease pool in case any Cocoa classes get used during \\* the injection process or +initialize */ @autoreleasepool { // loop through the special protocols, and apply each one to all the // classes in turn // // ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in // the order in which they appear in specialProtocols. Consider classes // X and Y that implement protocols A and B, respectively. B needs to get // its implementation into Y before A gets into X. // 遍历所有的要注入的协议结构体. for (size_t i = 0;i &lt; specialProtocolCount;++i) { Protocol *protocol = specialProtocols\\[i\\].protocol; // transfer ownership of the injection block to ARC and remove it // from the structure // 使用 \\_\\_bridge\\_transfer 把对象的内存管理交给 ARC. ext\\_specialProtocolInjectionBlock injectionBlock = (\\_\\_bridge_transfer id)specialProtocols\\[i\\].injectionBlock; specialProtocols\\[i\\].injectionBlock = NULL; // loop through all classes 遍历所有的类 for (unsigned classIndex = 0;classIndex &lt; classCount;++classIndex) { Class class = allClasses\\[classIndex\\]; // if this class doesn&apos;t conform to the protocol, continue to the // next class immediately // 如果这个类遵守了要注入的协议，那么就执行注入 // 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法. if (!class_conformsToProtocol(class, protocol)) continue; injectionBlock(class); } } } // 管理内存. // free the allocated class list free(allClasses); // now that everything&apos;s injected, the special protocol list can also be // destroyed free(specialProtocols); specialProtocols = NULL; specialProtocolCount = 0; specialProtocolCapacity = 0; specialProtocolsReady = 0; } 这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 4.3、问题在哪？ 接下来讨论 EXTConcreteProtocol 的缺点。 如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。 这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。 这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。 5、解决方案 从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。 那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。 但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。 如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。 ①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。 ②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。 ③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。 ④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。 https://github.com/newyjp/BLMethodInjecting 十、结语依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。 文章：依赖注入——让iOS代码更简洁、[iOS]一次高效的依赖注入","tags":[]},{"title":" 单例\t\t","date":"2019-02-26T07:19:13.000Z","path":"2019/02/26/e5-8d-95-e4-be-8b/","text":"单例：该类在程序运行期间有且仅有一个实例。 1、单例的主要优点 ①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例； ②、因为类控制了实例化过程，所以类可以灵活更改实例化过程； ③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。 2、单例的主要缺点 ①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放； ②、单例不能继承。 一、单例的实现单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。 主要是做到以下几点： 防止调用 [A alloc] init] 引起的错误防止调用 new 引起的错误防止调用 copy 引起的错误防止调用 mutableCopy 引起的错误 方法一：把所有可能出现的初始化方法做了相应的处理来其保证安全性 + (instancetype)sharedSingleton{ static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 不能再使用 alloc 方法 // 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法 _sharedSingleton = [[super allocWithZone:NULL] init]; }); return _sharedSingleton;} // ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法+ (instancetype)allocWithZone:(struct _NSZone *)zone{ return [Singleton sharedSingleton];} // ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.- (id)copyWithZone:(nullable NSZone *)zone{ return [Singleton sharedSingleton];} // ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.- (id)mutableCopyWithZone:(nullable NSZone *)zone{ return [Singleton sharedSingleton];} 方法二：**不做处理的情况下禁止外部调用** 一些成熟的第三方代码的单例中也有使用该方法的。 .h 文件 - (instancetype)init NS_UNAVAILABLE;+ (instancetype)new NS_UNAVAILABLE;- (id)copy NS_UNAVAILABLE;- (id)mutableCopy NS_UNAVAILABLE; .m 文件 + (instancetype)sharedSingleton{ static Singleton *_sharedSingleton = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _sharedSingleton = [[self alloc] init]; // 要使用 self 来调用 }); return _sharedSingleton;} 当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。 二、单例的滥用全局状态 大多数的开发者都认同使用全局可变的状态是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。 @implementation SPMath{ NSInteger _a; NSInteger _b;} (NSInteger)add{ return _a + _b;} 在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题： 1、add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。 2、当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。 把下面的代码和上面的例子做对比: (NSUInteger)addOf:(NSUInteger)a plus:(NSUInteger)b{ return a + b;} 这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为类方法，这样就显式的告诉了代码的阅读者：这个方法不会修改任何实例的状态。 那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“单例就是披着羊皮的全局状态” 。 一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。 @interface Singleton : NSObject + (instancetype)sharedInstance;- (NSString )name;- (void)setName:(NSString )name; @end @implementation A - (void)a{ if ([[Singleton sharedInstance] name]) { // … }} @end @implementation B - (void)b{ [[Singleton sharedInstance] setName:””];} @end 在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的共享状态来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致隐式的在两个看起来完全不相关的模块之间建立了耦合。 来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。 想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器： @interface URLCache (NSCache *)sharedURLCache; (void)storeCachedResponse:(NSCachedURLResponse )cachedResponse forRequest:(NSURLRequest )request; @end 这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。 几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？ 原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。 持久化状态是单元测试的敌人，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。 对象的生命周期 另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。 假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例： @interface ThumbnailCache : NSObject (instancetype)sharedThumbnailCache; (void)cacheProfileImage:(NSData )imageData forUserId:(NSString )userId; (NSData )cachedProfileImageForUserId:(NSString )userId; @end 继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。 当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。 问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例： static ThumbnailCache * sharedThumbnailCache; (instancetype)sharedThumbnailCache{ if (!sharedThumbnailCache) { sharedThumbnailCache = \\[\\[self alloc\\] init\\]; } return sharedThumbnailCache;} (void)cleanUp{ // The SPThumbnailCache will clean up persistent states when deallocated sharedThumbnailCache = nil;} 这是一个明显的对单例模式的滥用，但是它可以工作，对吧。 当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作： dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];}); 需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。 由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。 分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。 举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持多个用户账号登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。 这里我们得到的教训是：单例应该只用来保存全局的状态，并且不能和任何作用域绑定。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。 三、避免使用单例既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？ 重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。 @interface User : NSObject@property (nonatomic, readonly) ThumbnailCache * thumbnailCache;@end @implementation User (instancetype)init{ if ((self = [super init])) {_thumbnailCache = \\[\\[ThumbnailCache alloc\\] init\\]; } return self;} @end 现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。 现在假设我们有一个 VC 来展现好友列表： @interface FriendListVC : UIViewController (instancetype)initWithUser:(User *)user; @end 我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是依赖注入，并且它有很多优点： ①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。 ②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];}); 这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。 为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。 1、假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示： vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。 当用户登出后，清理 rootViewController 并且退出到登录页面： 这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。 2、使用依赖注入的对象图： 简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了简化 applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示： 这个对象图看起来和使用单例时很像。这有什么区别？ 关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互： 当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态： 四、结论在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。 这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。 五、文章避免滥用单例","tags":[]},{"title":" @protocol\t\t","date":"2019-02-26T03:12:53.000Z","path":"2019/02/26/protocol/","text":"// 协议 A@protocol ProtocolA @end // 协议 B@protocol ProtocolB @end @interface ClassB : NSObject @end // 协议 C@protocol ProtocolC @end @interface ClassC : NSObject @end @implementation ClassC@end - (void)viewDidLoad{ [super viewDidLoad]; NSLog(@&quot;%@&quot;, NSProtocolFromString(@&quot;ProtocolA&quot;)); NSLog(@&quot;%@&quot;, NSProtocolFromString(@&quot;ProtocolB&quot;)); NSLog(@&quot;%@&quot;, NSProtocolFromString(@&quot;ProtocolC&quot;)); } 2019-02-26 11:04:52.021 Demo[43855:381276] (null)2019-02-26 11:04:52.021 Demo[43855:381276] (null)2019-02-26 11:04:52.021 Demo[43855:381276] &lt;Protocol: 0x105f248f0&gt; ProtocolA、ProtocolB 竟然是 null。为什么会取不到值呢? 猜测是 protocol 初始化的问题。先去看看 protocol 的定义： #elif__OBJC2__ #include &lt;objc/NSObject.h&gt; // All methods of class Protocol are unavailable.// Use the functions in objc/runtime.h instead. __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)@interface Protocol : NSObject@end #else!__OBJC2__ #endif 可见 Protocol 也是一个类。 @protocol A @end 猜测上面代码只是声明了一个类，因为没有 @implementation 实现，实际编译后并没有这个类。 写一段测试代码，写一个只有声明的类，看看最终有没有这个类。 // 声明@interface ClassD : NSObject@end NSLog(@”%@”, NSClassFromString(@”ClassD”)); 2019-02-26 11:04:52.021 Demo[43855:381276] (null) // 实现@implementation ClassD@end 2019-02-26 11:12:16.360 Demo[43966:384826] ClassD","tags":[]},{"title":" 图片设置圆角性能问题\t\t","date":"2019-02-26T02:50:27.000Z","path":"2019/02/26/e5-9b-be-e7-89-87-e8-ae-be-e7-bd-ae-e5-9c-86-e8-a7-92-e6-80-a7-e8-83-bd-e9-97-ae-e9-a2-98/","text":"通常设置圆角方式 imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50; 这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几个头像，这样设置了圆角会明显感觉到卡顿。 注意：UIImageView 处理 png 图片的圆角是不会产生离屏渲染的。（iOS9.0 之后不会离屏渲染，iOS9.0 之前还是会离屏渲染）。 一、设置圆角的方法①、直接使用 cornerRadius。这种是最常用的，也是最耗性能的。 ②、设置 cornerRadius 圆角之后，shouldRasterize = YES 光栅化 imageView.clipsToBounds = YES;imageView.layer.cornerRadius = 50;imageView.layer.shouldRasterize = YES; // 设置光栅化imageView.layer.rasterizationScale = [UIScreen mainScreen].scale; // UIImageView 不加这句会产生一点模糊 设置光栅化可以使离屏渲染的结果缓存到内存中存为位图，使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。 但是如果 layer 及 sublayers 常常改变的话，它就会一直不停的渲染及删除缓存重新创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。 ③、直接覆盖一张中间为圆形透明的图片（推荐使用） 这种方法就是多加了一张透明的图片，GPU 计算多层的混合渲染 blending 也是会消耗一点性能的，但比第一种方法还是好上很多的。 这种圆片覆盖的方法一般只用在底色为纯色的时候，如果圆角图片的父 View 是张图片的时候就没办法了，而且底色如果是多种颜色的话那要做多张不同颜色的圆片覆盖。（可以用代码取底色的颜色值给圆片着色） ④、UIImage drawInRect 绘制圆角 这种方式 GPU 损耗低内存占用大。 @interface CornerImageView (){ NSBlockOperation _operation; // 任务 NSOperationQueue _queue; UIImage * _cornerImage; // 圆角化的图片}@end @implementation CornerImageView - (instancetype)initWithFrame:(CGRect)frame{ if (self = [super initWithFrame:frame]) { _queue = [[NSOperationQueue alloc] init]; } return self;} /** * 重写设置方法。如果是 UIButton 可以换成 setImage:forState: */- (void)setImage:(UIImage *)image{ [super setImage:nil]; \\[self roundedImage:image\\]; } - (void)roundedImage:(UIImage *)image{ [_queue cancelAllOperations]; \\[_operation cancel\\]; _operation = nil; _operation = \\[NSBlockOperation blockOperationWithBlock:^{ UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, \\[UIScreen mainScreen\\].scale); // Add a clip before drawing anything, in the shape of an rounded rect \\[\\[UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:self.bounds.size.height / 2\\] addClip\\]; \\[image drawInRect:self.bounds\\]; _cornerImage = UIGraphicsGetImageFromCurrentImageContext(); // Lets forget about that we were drawing UIGraphicsEndImageContext(); if (!_operation) { return; } dispatch\\_async(dispatch\\_get\\_main\\_queue(), ^{ \\[super setImage:_cornerImage\\]; }); }\\]; \\[\\_queue addOperation:\\_operation\\]; } 这段方法可以写在 SDWebImage 的 completed 回调里，在主线程异步绘制。也可以封装到 UIImageView 里，后台线程异步绘制，不会阻塞主线程。 问题：这种方法图片很多的话 CPU 消耗会高，内存占用也会暴增，而且后台线程绘制会比在主线程绘制占用更多的内存，不知道怎么解决？ ⑤、SDWebImage 处理图片时 CoreGraphics 绘制圆角 @interface UIImage (corner)+ (id)createRoundedRectImage:(UIImage *)image;@end @implementation UIImage (corner) static void addRoundedRectToPath(CGContextRef context, CGRect rect, float ovalWidth, float ovalHeight){ float fw, fh; if (ovalWidth == 0 || ovalHeight == 0) { CGContextAddRect(context, rect); return; } CGContextSaveGState(context); CGContextTranslateCTM(context, CGRectGetMinX(rect), CGRectGetMinY(rect)); CGContextScaleCTM(context, ovalWidth, ovalHeight); fw = CGRectGetWidth(rect) / ovalWidth; fh = CGRectGetHeight(rect) / ovalHeight; // 使的圆角半径为 1 CGContextMoveToPoint(context, fw, fh/2); // Start at lower right corner CGContextAddArcToPoint(context, fw, fh, fw/2, fh, 1); // Top right corner CGContextAddArcToPoint(context, 0, fh, 0, fh/2, 1); // Top left corner CGContextAddArcToPoint(context, 0, 0, fw/2, 0, 1); // Lower left corner CGContextAddArcToPoint(context, fw, 0, fw, fh/2, 1); // Back to lower right CGContextClosePath(context); CGContextRestoreGState(context); } + (id)createRoundedRectImage:(UIImage *)image{ CGFloat wh = MIN(MAX(image.size.width, image.size.height), 160); CGSize imageSize = CGSizeMake(wh, wh); CGfloat radius = wh / 2; CGContextRef context = CGBitmapContextCreate( NULL, wh, wh, 8, 4 * wh, CGColorSpaceCreateDeviceRGB(), kCGImageAlphaPremultipliedFirst ); // 绘制圆角 CGContextBeginPath(context); addRoundedRectToPath(context, CGRectMake(0, 0, wh, wh), radius, radius); CGContextClosePath(context); CGContextClip(context); CGContextDrawImage(context, CGRectMake(0, 0, w, h), img.CGImage); CGImageRef imageMasked = CGBitmapContextCreateImage(context); image = \\[UIImage imageWithCGImage:imageMasked\\]; CGContextRelease(context); CGImageRelease(imageMasked); return image; } 以上代码写成了 UIImage 的类别。并在 SDWebImage 库里处理 image 的时候使用类别方法绘制圆角并缓存。 /** * @brief 在上下文的路径中添加一条圆弧，可能前面有一条直线段。弧与当前点到 ‘(x1，y1)’ 的直线相切，与 ‘(x1，y1)’ 到 ‘(x2, y2)’ 的直线相切。 */CG_EXTERN void CGContextAddArcToPoint(CGContextRef cg_nullable c, CGFloat x1, CGFloat y1, CGFloat x2, CGFloat y2, CGFloat radius) CG_AVAILABLE_STARTING(10.0, 2.0); 二、使用 Instruments 的 Core Animation 查看性能 Color Offscreen-Rendered Yellow 开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。 Color Hits Green and Misses Red 如果 shouldRasterize 被设置成 YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。 用 Instruments 测试得： ①、直接设置 cornerRadius，UIImageView 和 UIButton 都高亮为黄色。 ②、增加光栅化，UIImageView 和 UIButton 都高亮为绿色。 ③、添加圆形透明图片，无任何高亮，说明没离屏渲染。 ④、drawInRect 方法无任何高亮，说明没离屏渲染（但是 CPU 消耗和内存占用会很大） ⑤、CoreGraphics 绘制方法无任何高亮，说明没离屏渲染，而且内存占用也不大。(暂时感觉是最优方法) 三、问题①、有提到还有一种 mask 方法。 这种方法比第一种方法其实更卡顿。一次 mask 发生了两次离屏渲染和一次主屏渲染。 具体可以参考小心别让圆角成了你列表的帧数杀手。 ②、第四种比第一种更卡。 第一种能明显的感觉到卡顿，第四种还是挺顺畅的，有兴趣的可以自己试试看。第四种是解决了离屏渲染 GPU 的问题。 可以用 Instruments的 GPU Driver 进行测试： Renderer Utilization 如果这个值 > 50%，就意味着你的动画可能对帧率有所限制，很可能因为离屏渲染或者是重绘导致的过度混合。 Tiler Utilization 如果这个值 > 50%，就意味着你的动画可能限制于几何结构方面，也就是在屏幕上有太多的图层占用了。 第 1 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 90% 左右，帧率 20 左右。 第 2 种方法的 Renderer Utilization 和 Tiler Utilization 基本在 20% 左右，帧率接近 60。 帧率越接近 60 滑动越顺畅。 发现第 4 种 Core Graphics 绘制圆角会有大量的内存占用，而且每次绘制的时候 CUP 消耗会很大。 如果使用了 UITableView 进行测试，因为 UITableView 滚动的时候是一直在复用的，UIImageView 会重复绘制，所以会一直消耗 CUP，然后你就能看的明显的卡顿。将图片的绘制在后台线程进行绘制，解决了卡顿问题，但是由于是在后台线程的异步绘制所以在滚动的时候会看到图片先是正方形然后再变成圆形。 而使用 UIScrollView 进行测试，只有第一次绘制的时候会占用 CUP 资源，所以滑动的时候还是挺流畅的，但是内存消耗还是很大。如果是主线程绘制的话会阻塞一点时间的主线程，而后台线程绘制的话内存消耗会更大，特别容易崩溃。 所以第四种方法当图片特别多的时候很容易 Received memory warning 导致崩溃。 四、参考文章 内存恶鬼drawRect - 谈画图功能的内存优化 github 绘制圆角源码参考 NZCircularImageView、HJCornerRadius","tags":[]},{"title":" 利用预渲染加速iOS设备的图像显示\t\t","date":"2019-02-26T02:19:13.000Z","path":"2019/02/26/e5-88-a9-e7-94-a8-e9-a2-84-e6-b8-b2-e6-9f-93-e5-8a-a0-e9-80-9fios-e8-ae-be-e5-a4-87-e7-9a-84-e5-9b-be-e5-83-8f-e6-98-be-e7-a4-ba/","text":"使用 UITableView 时，发现滚动时的性能还不错，但来回滚动时，第一次显示的图像不如再次显示的图像流畅，出现前会有稍许的停顿感。 于是猜想显示过的图像肯定是被缓存起来了，查了下文档后发现果然如此。在《Improving Image Drawing Performance on iOS》一文中找到了一些提示：原来在显示图像时，解压和重采样会消耗很多 CPU 时间；而如果预先在一个 bitmap context 里画出图像，再缓存这个图像，就能省去这些繁重的工作了。 接着下面举个例子程序来验证： #import &lt;UIKit/UIKit.h&gt; @interface ImageView : UIView@property (nonatomic, strong) UIImage * image;@end #import “ImageView.h” #include &lt;mach/mach_time.h&gt; static const CGRect imageRect = { {0, 0}, {100, 100}}; @implementation ImageView - (void)awakeFromNib{ if (!self.image) { self.image = [UIImage imageNamed:@”xxx”]; } [superawakeFromNib];} - (void)drawRect:(CGRect)rect{ if (CGRectContainsRect(rect, imageRect)) { uint64_t start = getTickCount(); \\[self.image drawInRect:imageRect\\]; uint64_t drawTime = getTickCount() - start; NSLog(@&quot;%llu&quot;, drawTime); // 打印时间间隔 } } // mach_absolute_time() 的单位是 Mach absolute time unit，而不是纳秒。它们之间的换算关系和 CPU 相关，不是一个常量。最简单的办法是用 CoreServices 框架的 AbsoluteToNanoseconds 和 AbsoluteToDuration 函数来转换。此外也可以用 mach_timebase_info 函数来获取这个比值。uint64_t getTickCount(void){ static mach_timebase_info_data_t sTimebaseInfo; uint64\\_t machTime = mach\\_absolute_time(); // Convert to nanoseconds - if this is the first time we&apos;ve run, get the timebase. if (sTimebaseInfo.denom == 0) { (void)mach\\_timebase\\_info(&amp;sTimebaseInfo); } uint64_t millis = (machTime * sTimebaseInfo.numer) / sTimebaseInfo.denom; // 纳秒 return millis; } @end 测试用一张 1838 * 890 的图 2018-07-05 11:05:25.950978+0800 Demo[5831:113872] 31802012 接下来就是见证奇迹的时刻了，把这段代码加入程序： static const CGSize imageSize = {100, 100}; - (void)awakeFromNib{ if (!self.image) { self.image = [UIImage imageNamed:@”xxx”]; // 由于JPEG图像是不透明的，所以第二个参数就设为YES // 第三个参数是缩放比例。虽然这里可以用 \\[UIScreen mainScreen\\].scale 来获取，但实际上设为 0 后，系统就会自动设置正确的比例了 UIGraphicsBeginImageContextWithOptions(imageSize, YES, 0); // 将图像画到当前的 image context 里，此时就完成了解压缩和重采样的工作 \\[image drawInRect:imageRect\\]; self.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); } } 值得一提的是，图像本身也有缩放比例，普通的图像是 1.0（除了 imageNamed: 外，大部分 API 都只能获得这种图像，而且缩放比例是不可更改的），高清图像是 2.0。图像的点和屏幕的像素就是依靠两者的缩放比例来计算的，例如普通图像在视网膜显示屏上是 1:4，而高清图像在视网膜显示屏上则是 1:1。 时间间隔：2018-07-05 11:30:46.284490+0800 Demo[6401:133240] 127939，缩短了很多。 还能更快吗？让我们来试试 Core Graphics。 先定义一个全局的 CGImageRef 变量： static CGImageRef imageRef; 再 - (void)awakeFromNib{ imageRef = self.image.CGImage;} 最后 - (void)drawRect:(CGRect)rect{ CGContextRef context = UIGraphicsGetCurrentContext(); CGContextDrawImage(context, imageRect, imageRef);} 运行一下，发现时间间隔为 2018-07-05 11:36:19.837131+0800 Demo[6677:139386] 27425265，而且图像还上下颠倒了⋯ 这个原因是 UIKit 和 Core Graphics 的坐标系 y 轴是相反的，于是加上下面代码来修正： CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, 0, 100);CGContextScaleCTM(context, 1, -1);CGContextDrawImage(context, imageRect, imageRef); 这下图像终于正常显示了，时间增加到了 2018-07-05 11:39:27.557629+0800 Demo[6817:142712] 34242146，成效不大，看来直接用 -drawAtPoint: 和 -drawInRect: 就足够好了。","tags":[]},{"title":" MJRefresh\t\t","date":"2019-02-26T02:01:18.000Z","path":"2019/02/26/mjrefresh/","text":"- (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath 与 MJRefresh 有冲突。estimatedHeight 会导致触发上拉加载更多后，执行 reloadData 方法，tableView 发生滚动，滚动期间被 MJRefresh 内的 Observer 监听到。 上拉 - 》加载完数据 -》reloadData -》 estimatedHeight 导致 tableView 的 contentOffset 发生变化 MJRefresh 内有个 Observer 在监听 contentOffset 所以需要去掉这个 - (CGFloat)tableView:(UITableView )tableView estimatedHeightForRowAtIndexPath:(NSIndexPath )indexPath 2、 iOS Collectionview通过设置contentInset方式添加表头Header,影响MJRefresh使用的解决方案ignoredScrollViewContentInsetTop","tags":[]},{"title":" 离屏渲染\t\t","date":"2019-02-23T10:18:07.000Z","path":"2019/02/23/offscreenrendering/","text":"一、Off-Screen Rendering离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。离屏渲染的数量才是影响 app 交互性能的根源。 离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。原因主要在于创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。 二、上下文切换不管是在 GPU 渲染过程中，还是熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源 -> 初始化环境 -> 开始一个绘制 -> 绘制完毕后销毁这个绘制环境，如需要切换到 On-Screen Rendering 或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次 mask 的渲染操作。 一次 mask 发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次 mask 需要渲染三次才能在屏幕上显示，这已经是普通视图显示 3 倍耗时，若再加上下文环境切换，一次 mask 就是普通渲染的 30 倍以上耗时操作。 三、出现场景下面的情况或操作会引发离屏渲染： ①、为图层设置遮罩（layer.mask） ②、将图层的 layer.masksToBounds/view.clipsToBounds 属性设置为 true ③、将图层的 layer.allowsGroupOpacity 属性设置为 YES 和 layer.opacity &lt; 1.0 ④、为图层设置阴影（layer.shadow*） ⑤、为图层设置 layer.shouldRasterize = true ⑥、具有 layer.cornerRadius、layer.edgeAntialiasingMask、layer.allowsEdgeAntialiasing 的图层 ⑦、文本（任何种类，包括 UILabel、CATextLayer、CoreText 等） ⑧、使用 CGContext 在 drawRect: 方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现 二、优化方案官方对离屏渲染产生性能问题也进行了优化： iOS 9.0 之前 UIimageView 跟 UIButton 设置圆角都会触发离屏渲染；iOS 9.0 之后 UIButton 设置圆角会触发离屏渲染，而 UIImageView 设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。 1、圆角优化 在 APP 开发中圆角图片还是经常出现的。如果一个界面中只有少量圆角图片或许对性能没有非常大的影响，但是当圆角图片比较多的时候就会 APP 性能产生明显的影响。 我们设置圆角一般通过如下方式： imageView.layer.cornerRadius = CGFloat(10);imageView.layer.masksToBounds = YES; 这样处理的渲染机制是 GPU 在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区的频繁合并和上下文的的频繁切换，性能的代价会宏观地表现在用户体验上–掉帧。 优化方案 ①：使用贝塞尔曲线 UIBezierPath 和 Core Graphics 框架画出一个圆角。 UIImageView imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];UIImage image = [UIImage imageNamed:@”myImg”]; // 开始对 imageView 进行画图UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, [UIScreen mainScreen].scale);// 使用贝塞尔曲线画出一个圆形图[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];[image drawInRect:imageView.bounds];imageView.image = UIGraphicsGetImageFromCurrentImageContext();// 结束画图UIGraphicsEndImageContext(); [self.view addSubview:imageView]; HJCornerRadius 2、shadow 优化 对于 shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置 shadowPath 来优化性能，能大幅提高性能。示例如下： imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0;imageView.layer.shadowRadius = 2.0;UIBezierPath * path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 我们还可以通过设置 shouldRasterize 属性值为 YES 来强制开启离屏渲染。其实就是光栅化（Rasterization）。既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于UITableViewCell中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。 （3）其他的一些优化建议 当我们需要圆角效果时，可以使用一张中间透明图片蒙上去 使用ShadowPath指定layer阴影效果路径 使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit） 设置layer的opaque值为YES，减少复杂图层合成 尽量使用不包含透明（alpha）通道的图片资源 尽量设置layer的大小值为整形值 直接让美工把图片切成圆角进行显示，这是效率最高的一种方案 很多情况下用户上传图片进行显示，可以让服务端处理圆角 使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片 （4）Core Animation工具检测离屏渲染 对于离屏渲染的检测，苹果为我们提供了一个测试工具Core Animation。可以在Xcode-&gt;Open Develeper Tools-&gt;Instruments中找到，如下图： Core Animation工具用来监测Core Animation性能，提供可见的FPS值，并且提供几个选项来测量渲染性能。如下图： 下面我们来说明每个选项的功能： Color Blended Layers：这个选项如果勾选，你能看到哪个layer是透明的，GPU正在做混合计算。显示红色的就是透明的，绿色就是不透明的。 Color Hits Green and Misses Red：如果勾选这个选项，且当我们代码中有设置shouldRasterize为YES，那么红色代表没有复用离屏渲染的缓存，绿色则表示复用了缓存。我们当然希望能够复用。 Color Copied Images：按照官方的说法，当图片的颜色格式GPU不支持的时候，Core Animation会 拷贝一份数据让CPU进行转化。例如从网络上下载了TIFF格式的图片，则需要CPU进行转化，这个区域会显示成蓝色。还有一种情况会触发Core Animation的copy方法，就是字节不对齐的时候。如下图： Color Immediately：默认情况下Core Animation工具以每毫秒10次的频率更新图层调试颜色，如果勾选这个选项则移除10ms的延迟。对某些情况需要这样，但是有可能影响正常帧数的测试。 Color Misaligned Images：勾选此项，如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。像素对齐我们已经在上面有所介绍。 Color Offscreen-Rendered Yellow：用来检测离屏渲染的，如果显示黄色，表示有离屏渲染。当然还要结合Color Hits Green and Misses Red来看，是否复用了缓存。 Color OpenGL Fast Path Blue：这个选项对那些使用OpenGL的图层才有用，像是GLKView或者 CAEAGLLayer，如果不显示蓝色则表示使用了CPU渲染，绘制在了屏幕外，显示蓝色表示正常。 Flash Updated Regions：当对图层重绘的时候回显示黄色，如果频繁发生则会影响性能。可以用增加缓存来增强性能。 以上就是本人的一些总结，当然对于UITableView的性能优化，网上有很多相关的资料。如果有什么不同的观点，欢迎大家补充。 1. 使用tableView的复用机制 作用：减少内存资源的消耗。 注意：cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。 2. 提前预估高度 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法。 3. cell内部有图片 此时需要异步加载图片，防止卡顿（此时的SDWebImage的每个cell中都创建一个子线程吗？）但是内部开启的线程过多也会影响主线程的性能 解决办法： 3.1.）在scrollerView的代理方法中，didEndDragging,didEndDeceleratiing方法中，才开始异步加载，其它时刻不进行加载 3.2.在didEndDragging,didEndDeceleratiing方法中实现方法：获取屏幕上显示出来的cell的indexPath数组，然后通过遍历indexPath的数组，在数据源中，如果已经加载了，就不需要再异步加载，反之进行异步加载,然后再cellForRow方法中也进行一次判断：当self.tableView.dragging == NO &amp;&amp; self.tableView.decelerating == NO 的时候执行异步加载图片的方法 4. 尽量少用addView给Cell动态添加View 可以初始化时就添加，相对于一些固定的视图在初始化时就布局好，学会用hidden属性来控制是否显示。 5. 减少子视图的数目 当cell上面的子视图数量过多时，会影响滑动性能，当子视图太多的时候，对适当的视图进行绘制。 6. 使用不透明视图 不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）。 7. 预渲染图像和离屏渲染 你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是预渲染图像，在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见《利用预渲染加速iOS设备的图像显示》。 离屏渲染就是在tableView中展示多张需要切圆形的图片，此时不要使用setCornerRadius的方法，这样耗损性能，用Core Graphics绘制圆角，然后返回图片，在SDWebImage处理我的分类返回的图片，并进行缓存。 8. UIImage:本地图片加载方式本地图片加载常用方法有两种： 1）. [UIImage imageNamed:@”xx.png”] 图片多次使用时使用，需要使用此方式加入缓存。 2). [[UIImage alloc] initWithContentsOfFile :@”xx.png”] 图片不常使用时，不使用缓存。 9. 避免对象创建时过多消耗资源 例如：日期处理，将保持日期对象全局唯一。 https://blog.csdn.net/hmh007/article/details/54907560","tags":[]},{"title":" id、instancetype\t\t","date":"2019-02-23T02:34:00.000Z","path":"2019/02/23/id-e3-80-81instancetype/","text":"instancetype 是 clang 3.5 开始，clang 提供的一个关键字，表示某个方法返回的未知类型的 Objective-C 对象。 相同点： instancetype 和 id 都可以表示任何对象类型； instancetype 和 id 都可以作为方法的返回类型。 不同点： instancetype 只能用在返回值类型上，id 还可以表示参数类型； instancetype 返回与方法所在类相同类型的对象，id 返回未知类型的对象； 编译器会检测 instancetype 的真实类型，可以提前暴露程序存在的风险； + (id)a1{ return [[self alloc] init];} + (instancetype)a2{ return [[self alloc] init];} NSString * s1 = [A a1]; // 用字符串类型的指针指向 A 类的对象，编译通过，因为 a1 返回 id 类型，任何指针都可以指向它 NSString s2 = [A a2]; // 编译时，会有警告。[A a2] 返回的 A 类型, 警告信息：Incompatible pointer types initializing ‘NSString ‘ with an expression of type ‘A *’ 关联返回类型 根据 Cocoa 的命名规则，满足下述规则的方法： ①、+ 方法以 alloc 或 new 开头； ②、- 方法以 autorelease、init、retain 或 self 开头。 会返回一个方法所在类类型的对象，这些方法就被称为是关联返回类型的方法。能够返回一个方法所在类型的对象。","tags":[]},{"title":" UITableView 优化\t\t","date":"2019-02-22T15:00:14.000Z","path":"2019/02/22/uitableviewoptimize/","text":"图片加载优化官方 Demo：LazyTableImages 文章：提升 UITableView 性能-复杂页面的优化 代码：VVeboTableViewDemo 一、Cell 复用在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 解决方案：创建一个静态变量 reuseID，防止重复创建（提高性能），使用系统的缓存池功能。 static NSString * CELL_RUID = @”CELL”; // 调用次数太多，static 保证只创建一次 reuseID，提高性能 - (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath{ // 缓存池中取已经创建的 cell UITableViewCell cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID forIndexPath:indexPath]; return cell;} 通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。 - (nullable __kindof UITableViewCell )dequeueReusableCellWithIdentifier:(NSString )identifier; // Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.- (__kindof UITableViewCell )dequeueReusableCellWithIdentifier:(NSString )identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0); // newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered 复用 Cell 时 不会调用 awakeFromNib。 获取方法的区别 dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示： reason: ‘unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard’ dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示： failed to obtain a cell from its dataSource 判断 nil 后可以自己创建 cell。 { MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@”Cell”]; if (cell == nil) { cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@”Cell”]; }} 为什么需要 forIndexPath: 因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。 我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。 注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。 二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的数量不会很多，完全可以接受的。 好处： ①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（多个 Cell 不是更容易维护？） ②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。 既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。 尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。 三、提前计算并缓存 Cell 的高度1、固定高度的 cell self.tableView.rowHeight = 88; 直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。 2、动态高度的 cell 实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。 tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。 解决方案：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。 @interface Model : NSObject @property (nonatomic, assign) CGFloat cellHeight; // Cell 高度 /** * @brief 计算高度 */- (void)calculateCellHeight; @end 在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。 还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。 4、异步绘制（自定义 Cell 绘制）遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。详细整理：UITableView 优化技巧 /** * @brief cell 添加 draw 方法 */- (void)draw{ // 异步绘制 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ }); } /** * @brief 重写 drawRect: 方法 */- (void)drawRect:(CGRect)rect{ // 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。} 绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。 五、滑动时，按需加载自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。 - (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ if (needLoadArr.count &gt; 0 &amp;&amp; [needLoadArr indexOfObject:indexPath] == NSNotFound) { [cell clear]; // 清掉内容 } return cell;} // 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。- (void)scrollViewWillEndDragging:(UIScrollView )scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint )targetContentOffset{ NSIndexPath ip = [self.tableView indexPathForRowAtPoint:CGPointMake(0, targetContentOffset-&gt;y)]; NSIndexPath cip = [[self.tableView indexPathsForVisibleRows] firstObject]; NSInteger skipCount = 8; // -8 &lt; 当前位置 - 目标位置 &lt; 8 if (labs(cip.row - ip.row) &gt; skipCount) { // 目标区域的 cell 的 indexPaths NSArray * temp = \\[self.tableView indexPathsForRowsInRect:CGRectMake(0, targetContentOffset-&gt;y, self.tableView.frame.size.width, self.tableView.frame.size.height)\\]; NSMutableArray * arr = \\[NSMutableArray arrayWithArray:temp\\]; if (velocity.y &lt; 0) { NSIndexPath * indexPath = \\[temp lastObject\\]; if (indexPath.row + 33) { \\[arr addObject:\\[NSIndexPath indexPathForRow:indexPath.row - 3 inSection:0\\]\\]; \\[arr addObject:\\[NSIndexPath indexPathForRow:indexPath.row - 2 inSection:0\\]\\]; \\[arr addObject:\\[NSIndexPath indexPathForRow:indexPath.row - 1 inSection:0\\]\\]; } } \\[needLoadArr addObjectsFromArray:arr\\]; } } 思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。 六、缓存 View当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。 七、尽量显示“大小刚好合适的”图片资源避免大量的图片缩放、颜色渐变等。 八、避免同步的从网络、文件获取数据Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。 九、渲染1、减少 subviews 的个数和层级 子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。 2、少用 subviews 的透明图层 渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。 3、背景色不要使用 clearColor 4、避免 CALayer 特效（shadowPath） 给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿： view.layer.shadowColor = color.CGColor;view.layer.shadowOffset = offset;view.layer.shadowOpacity = 1;view.layer.shadowRadius = radius; 5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。 十、总结UITableView 的优化主要从四个方面入手： 1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法； 2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage； 3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。 大概需要关注的： 1、cell 复用 2、cell 高度的计算 3、渲染（混合问题） 4、减少视图的数目（重写 drawRect:） 5、减少多余的绘制操作 6、不要给 cell 动态添加 subView 7、异步化 UI，不要阻塞主线程 8、滑动时按需加载对应的内容","tags":[]},{"title":" 第 k 小的数\t\t","date":"2019-02-22T08:55:11.000Z","path":"2019/02/22/kmaximumnumber/","text":"文章：LeetCode004——两个排序数组的中位数 一、寻找两个有序数组的中位数1、问题描述 给定两个大小为 m 和 n 的不同时为空的有序数组 nums1 和 nums2。找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 2、算法分析 题目要求的时间复杂度是 O(log(m + n))，要产生这样级别的时间复杂度只有采用二分查找法，用分治递归的思路来考虑这个问题。 需要转换题目中求中位数的问题为求第 k 小数的问题。如果 m + n 是奇数，那么寻找第 k = (m + n)/2 + 1 小的数即可；如果长度和是偶数，那么我们还需要寻找第 (m + n)/2 小的数，然后计算两数的平均值。 在求解整个问题的过程中，我们始终需要考虑一个很重要的问题–数组索引越界问题。 下面将详细地分析整个递归流程。 ①、首先定义递归函数的作用：寻找两个有序数组 nums1 数组中 [L1, R1] 范围内和 nums2 数组 [L2, R2] 范围内第 k 小的数，k 从 1开始计数。 /** * L1 nums1数组的寻找范围的左边界 * R1 nums1数组的寻找范围的右边界 * L2 nums2数组的寻找范围的左边界 * R2 nums2数组的寻找范围的右边界 * k 需要寻找第k小的元素 */int findKth(int[] nums1, int L1, int R1, int[] nums2, int L2, int R2, int k) ②、用 len1 = R1 - L1 + 1 来记录 nums1 数组中寻找范围的长度，用 len2 = R2 - L2 + 1 来记录 nums2 数组中寻找范围的长度。 ③、如果要寻找的 k &gt; len1 + len2，就像只有 3 个数字要找第 4 小的数一样，超出寻找区域，显然无法找到。 ④、递归的终止条件： a. 当 len1 = 0 时，说明只有 nums2 数组中有元素，直接取 nums2[L2 + k - 1] 位元素即可。 b. 当 k = 1 时，说明要取的是两个有序数组中的最小值 MIN(nums1[L1], nums2[L2])。 ⑤、递归过程： 由于要求的是第 k 小的数，而且是在两个有序数组中求。划分两个数组时按照 k 值来分。取变量 i = MIN(len1, k/2)，之所以这么取，是为了防止 L1 + k/2 - 1 &gt; len1 导致从 nums1 取值越界。再取变量 j = MIN(len2, k/2)。 接下来比较 nums1[L1 + i - 1] 和 nums2[L2 + i - 1] 这两个值。 如果 nums1[L1 + i - 1] &lt;= nums2[L2 + j - 1]，显然 nums1 数组中索引为 L1 + i - 1 及之前的元素不可能是中位数，去除 nums1 数组中 [L1, L1 + i - 1] 范围内的元素，缩小了查找范围。我们递归调用该函数，此时在 nums1 中的查找范围变成了 nums1[L1 + i, R1]，此时要找的也不应该是第 k 小的元素，因为已经剔除了 i 个比 k 小的元素，因此我们要找的元素变成了第 k - i 小的元素。 如果 nums1[L1 + i - 1] &gt; nums2[L2 + j - 1]，同理，nums2 数组中索引为 L2 + j - 1 及之前的元素不可能是中位数，缩小查找范围，剔除了 j 个比 k 小的元素，因此我们要找的元素变成了第 k - j 小的元素。 因为 i + j = MIN(len1, k/2) + MIN(len2, k/2) &lt;= k，所以可以直接判断 [L1, L1 + i - 1] 或者 [L2, L2 + j -1] 区间的元素不可能是中位数。 总结：算法的思想是不断的剔除数据，逐渐逼近第 k 小的数。 3、时间复杂度 假设数组长度足够长，每次剔除的元素都是 k/2(i 或者j)，显然我们需要 log(k) 次才能找到第 k 小数，这和二分查找法是同理的，而我们要找的 k 值要么是 (m + n)/2 + 1，要么额外再加上 (m + n)/2，因此时间复杂度是 O(log(m + n)) 级别的。 4、代码实现 #define MIN(a, b) (a) &lt; (b) ? (a) : (b) int findKth(int nums1, int left1, int right1, int nums2, int left2, int right2, int k){ int n1 = right1 - left1 + 1; int n2 = right2 - left2 + 1; // 递归退出条件 if(k &gt; n1 + n2) { return 0; // 实际上 k 不会小于 n1 + n2 } if(n1 == 0) { return nums2\\[left2 + k - 1\\]; } else if (n2 == 0) { return nums1\\[left1 + k - 1\\]; } if(k == 1) { return MIN(nums1\\[left1\\], nums2\\[left2\\]); } int i = MIN(n1, k / 2); int j = MIN(n2, k / 2); // 剔除比第 k 小的数还小的数，逐渐逼近 if(nums1\\[left1 + i - 1\\] &gt; nums2\\[left2 + j - 1\\]) { return findKth(nums1, left1, right1, nums2, left2 + j, right2, k - j); } else { return findKth(nums1, left1 + i, right1, nums2, left2, right2, k - i); } } double findMedianSortedArrays(int nums1, int nums1Size, int nums2, int nums2Size){ // k = (nums1Size + nums2Size) /2 + 1，因为 k 从 1 开始计数 int mid1 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2 + 1); // 两个数组总长度是奇数 if((nums1Size + nums2Size) % 2 != 0) { return mid1; } // 两个数组总长度是偶数 else { // 额外求 (nums1Size + nums2Size) / 2 的值 int mid2 = findKth(nums1, 0, nums1Size - 1, nums2, 0, nums2Size - 1, (nums1Size + nums2Size) / 2); return (mid1 + mid2) / 2.0; } }","tags":[]},{"title":" 挖金矿\t\t","date":"2019-02-21T06:30:03.000Z","path":"2019/02/21/e6-8c-96-e9-87-91-e7-9f-bf/","text":"原文：https://juejin.im/post/5a29d52cf265da43333e4da7 1、问题描述 有 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ 2、算法分析 w 表示总共人数，n 表示金矿数， ①、排列组合 每一座金矿都有挖与不挖两种选择，排列组合起来就有 2n 种选择。对所有可能性做遍历，剔除那些使用工人数超过 10 的选择，在剩下的选择里找出获得金币数最多的选择。 时间复杂度：O(2n)。 ②、递归 每个金矿存在”挖”、”不挖”两种情况，可以同时内部调用两次递归方法，表示”挖”和”不挖”。 void A(){ if (边界条件) return x; // 挖 A(); // 不挖 A();} 时间复杂度：O(2n) 开辟空间：递归深度 O(n) ③、动态规划 这个问题与 0-1 背包问题相同，动态规划时的策略也是：当前金矿是否应该挖，挖与不挖的价值比较。整理出以下表格。 【状态】是 f(w)，【边界】是 f(w &lt; 3) = 0；状态方程 f(w) = max{ f(w - 1), f(w - i) + vi }, w &gt; i i 表示当前金矿需要的人数，vi 表示当前金矿的价值。 时间复杂度：O(n*w) 空间复杂度：O(n*w) 如果不保留挖金矿信息，只输出最高金币数，可以由上发现，每一层的数据只与上一层有关，那么就可以由上至下，只用一位数组保存状态，空间复杂度 O(w)。 ④、比较 当工人数 w -&gt; ∞ 时，动态规划的时间复杂度和空间复杂度与 w 成正比，所以增长较快；而递归算法与 w 无关，所以不增长，此时动态规划的效率就没有递归的好。 3、代码实现 ①、递归（自底向上） #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX(a, b) (a) &gt; (b) ? (a) : (b) typedef struct GoldMine { int worker; int gold;} GoldMine; /** * mineNum 金矿数 * workerNum 挖矿总人数 * curMine 当前金矿（从 0 开始） * curWorker 当前人数（从 0 开始） * max 当前最大金币数 /int monerFinderAlgorithm(GoldMine mines, int mineNum, int workerNum, int curMine, int curWorker, int max){ GoldMine curGoldMine = mines[curMine]; // 金矿挖完了 || 人数不够了 if (curMine &gt;= mineNum || curWorker + curGoldMine.worker &gt; workerNum) return max; // 挖 int dig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker + curGoldMine.worker, max + curGoldMine.gold); // 不挖 int noDig = monerFinderAlgorithm(mines, mineNum, workerNum, curMine + 1, curWorker, max); return MAX(dig, noDig); } int main(){ GoldMine mines[5] = { {3, 200}, {4, 300}, {3, 350}, {5, 400}, {5, 500} }; printf(“\\n\\n%d”, monerFinderAlgorithm(mines, 5, 10, 0, 0, 0)); //GoldMine mines\\[2\\] = { {4, 300}, {5, 500} }; //printf(&quot;\\\\n\\\\n%d&quot;, monerFinderAlgorithm(mines, 2, 10, 0, 0, 0)); return 0; } ②、动态规划 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MAX(a, b) (a) &gt; (b) ? (a) : (b) typedef struct GoldMine { int worker; int gold;} GoldMine; /// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker){ if (worker == 0 || mineNum == 0) return 0; // i 列 j 行 int i = 0, j = 0; // 二维数组，从左向右，第一个 \\[ \\] 是列，第二个 \\[ \\] 是行 int goldMatrix\\[worker + 1\\]\\[mineNum\\]; // 初始化并打印二维数组 for (; j &lt; mineNum; j++) { for (i = 0; i &lt;= worker; i++) { goldMatrix\\[i\\]\\[j\\] = 0; printf(&quot;0 &quot;); // printf(&quot;%d &quot;, goldMatrix\\[i\\]\\[j\\]); } printf(&quot;\\\\n&quot;); } printf(&quot;\\\\n&quot;); GoldMine mine; for (i = 1; i &lt;= worker; i++) { for (j = 0; j &lt; mineNum; j++) { mine = mines\\[j\\]; // 挖矿人数不够 if (mine.worker &gt; i) { // 第一个存储 0，非第一个存储前一个 j 的值 goldMatrix\\[i\\]\\[j\\] = (j == 0) ? 0 : goldMatrix\\[i\\]\\[j-1\\]; } // 挖矿人数足够 else { // 第一个直接存储，非第一个存储 MAX{ 不加入 j 的值， 加入 j 的值 }，j -1 是因为剔除了当前 goldMatrix\\[i\\]\\[j\\] = (j == 0) ? mine.gold : MAX(goldMatrix\\[i\\]\\[j-1\\], goldMatrix\\[i-mine.worker\\]\\[j-1\\] + mine.gold); } } } // 打印二维数组内容 for (j = 0; j &lt; mineNum; j++) { for (i = 1; i &lt;= worker; i++) printf(&quot;%d &quot;, goldMatrix\\[i\\]\\[j\\]); printf(&quot;\\\\n&quot;); } printf(&quot;\\\\n&quot;); // 挖哪些矿 int curWorker = worker; for (j = mineNum - 1; j &gt;= 0; j--) { mine = mines\\[j\\]; if (curWorker == 0) { break; } // 根据变换公式从上至下获得物品 if (goldMatrix\\[curWorker\\]\\[j\\] - goldMatrix\\[curWorker - mine.worker\\]\\[j-1\\] == mine.gold) { printf(&quot;%d &quot;, mine.worker); curWorker -= mine.worker; } } return goldMatrix\\[worker\\]\\[mineNum - 1\\]; } int main(){ GoldMine mines[5] = { {3, 200}, {4, 300}, {3, 350}, {5, 400}, {5, 500} }; printf(“\\n\\n%d”, monerFinderAlgorithm(mines, 5, 10)); //GoldMine mines\\[2\\] = { {4, 300}, {5, 500} }; //printf(&quot;\\\\n\\\\n%d&quot;, monerFinderAlgorithm(mines, 2, 10)); return 0; } 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 200 200 200 200 200 200 200 2000 0 200 300 300 300 500 500 500 5000 0 350 350 350 550 650 650 650 8500 0 350 350 400 550 650 750 750 8500 0 350 350 500 550 650 850 850 900 5 5 900 空间复杂度 O(n) /// mineNum 金矿数 worker 工人数int monerFinderAlgorithm(GoldMine* mines, int mineNum, int worker){ if (worker == 0 || mineNum == 0) return 0; int* preGoldMatrix = (int *)calloc(sizeof(int), worker); int* goldMatrix = (int *)calloc(sizeof(int), worker); GoldMine mine; for (int i = 0; i &lt; mineNum; i++) { mine = mines\\[i\\]; // 从 1 开始计算 for (int j = 1; j &lt;= worker; j++) { // 挖矿人数不够 if (j &lt; mine.worker) { goldMatrix\\[j-1\\] = preGoldMatrix\\[j-1\\]; } // 挖矿人数足够 else { // 从上一层中 \\[j - mine.worker - 1\\] 和 \\[j - 1\\] 中获取最大值 goldMatrix\\[j-1\\] = MAX(preGoldMatrix\\[j-1\\], preGoldMatrix\\[j - mine.worker - 1\\] + mine.gold); } printf(&quot;%d &quot;, goldMatrix\\[j - 1\\]); } printf(&quot;\\\\n&quot;); // 打印 preGoldMatrix、goldMatrix 数组的内容 // for (int k = 0; k &lt; worker; k++) {// printf(“%d “, preGoldMatrix[k]);// }// printf(“\\n”);//// for (int k = 0; k &lt; worker; k++) {// printf(“%d “, goldMatrix[k]);// }// printf(“\\n\\n”); for (int k = 0; k &lt; worker; k++) { // 不能使用 preGoldMatrix = goldMatrix; 这是指针赋值，preGoldMatrix 与 goldMatrix 内存地址一样 preGoldMatrix\\[k\\] = goldMatrix\\[k\\]; } //printf(&quot;%p %p&quot;, preGoldMatrix, goldMatrix); // 打印数组的内存地址 } return goldMatrix\\[worker - 1\\]; }","tags":[]},{"title":" 爬楼梯\t\t","date":"2019-02-20T10:12:29.000Z","path":"2019/02/20/climbstairs/","text":"原文：漫画：什么是动态规划？ 1、问题描述 有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级台阶。要求用程序来求出一共有多少种走法。 2、算法分析 从简单的分析，要到第 10 级台阶，有多少种方法？要么从 9 级跨 1 级，要么从 8 级跨 1 级。 记 10 级台阶的状态为 f(10)，9 级台阶的状态为 f(9)，8 级台阶的状态为 f(8)，那么 f(10) = f(9) + f(8)。 f(9) = f(8) + f(7) … f(2) = 2 f(1) = 1 f(8)、f(9) 是 f(10) 的【最优子结构】；f(1)、f(2) 是【边界】；f(n) = f(n-1) + f(n-2) 是【状态转移方程】。 3、代码实现 ①、递归 int getClimbingWays(int n){ if (n &lt; 3) return n; return getClimbingWays(n - 1) + getClimbingWays(n - 2); } 递归调用的执行过程和一颗二叉树一样，所以它的时间复杂度就是叶子节点数。 时间复杂度：O(2n) ②、备忘录算法 递归方法中会重复计算相同的值，如图中的 f(n-3)。用缓存，先创建一个哈希表，每次把不同参数的计算结果存入哈希。当遇到相同参数时，再从哈希表里去除，避免重复计算。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int getClimbingWays(int n, int* hashMap){ if (n &lt; 3) return n; // 没有缓存 if (hashMap\\[n\\] == 0) { int value = getClimbingWays(n - 1, hashMap) + getClimbingWays(n - 2, hashMap); hashMap\\[n\\] = value; } return hashMap\\[n\\]; } int main(){ int n = 10; int hashMap = (int )calloc(n, sizeof(int)); printf(&quot;%d&quot;, getClimbingWays(n, hashMap)); return 0; } 时间复杂度：O(n) 空间复杂度：O(n) ③、动态规划法 int getClimbingWays(int n){ if (n &lt; 3) return n; int a = 1; int b = 2; int sum = 0; for (int i = 3; i &lt;= n; i++) { sum = a + b; a = b; b = sum; } return sum; } 时间复杂度：O(n) 空间复杂度：O(1)","tags":[]},{"title":" LC 29\t\t","date":"2019-02-20T08:54:09.000Z","path":"2019/02/20/lc-29/","text":"三零零、Longest Increasing Subsequence（最长上升子序列）详情：http://www.dzliving.com/2019/02/20/longestincreasingsubsequence/","tags":[]},{"title":" 最长上升子序列\t\t","date":"2019-02-20T08:26:53.000Z","path":"2019/02/20/longestincreasingsubsequence/","text":"1、问题描述 给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, 3, 4, 8, 6, 7] 返回 4。 2、算法分析 面对这个问题，首先要定义一个”状态”来代表它的子问题， 并且找到它的解。 注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。 假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。 以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是： 5 3 4 8 6 7 根据上面找到的状态，可以得到： i = 1 的 LIS 长度 d(1) = 1, d[] = {5} i = 2 的 LIS 长度 d(2) = 1, d[] = {3} i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4} i = 4 的 LIS 长度 d(4) = max{ d(1), d(2), d(3) } + 1 = 3, d[] = {3, 4, 8} 状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到： d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A[j] &lt;= A[i] 想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。 分析完了，上图。 3、复杂度分析 时间复杂度：O(n2) 空间复杂度：O(n) 4、代码实现 int lengthOfLIS(int* nums, int numsSize) { if (numsSize == 0) return 0; int \\*d = (int \\*)malloc(sizeof(int) * numsSize); int len = 1; for(int i = 0; i &lt; numsSize; ++i){ d\\[i\\] = 1; for(int j = 0; j &lt; i; ++j) // 如果当前的数值 A\\[i\\] 大于 它之前的数值 A\\[j\\] &amp;&amp; 最长的段 if(nums\\[j\\] &lt; nums\\[i\\] &amp;&amp; d\\[j\\] + 1 &gt; d\\[i\\]) d\\[i\\] = d\\[j\\] + 1; if(d\\[i\\] &gt; len) len = d\\[i\\]; } free(d); return len; } int main(){ int A[] = { 5, 3, 4, 8, 6, 7 }; printf(“%d”, lengthOfLIS(A, 6)); return 0; } 5、进阶：O(nlogn)算法 假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。 定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。注意：B 的索引从 1 开始。 ①、把 d[0] 有序地放到 B 里，令 B[1] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。 ②、把 d[2] 有序地放到 B 里，令 B[1] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d[1] = 2 已经没用了，因为 2 &gt; 1。 ③、d[3] = 5，因为 d[3] &gt; B[1]，所以令 B[1+1] = B[2] = d[3] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B[] = { 1, 5 }。 ④、d[4] = 3，B[1] &lt; d[3] &lt; B[2]，放在 B[1] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B[] = { 1, 3 }。 ⑤、d[5] = 6，因为 d[5] &gt; B[2]，所以令 B[2+1] = B[3] = d[5] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B[] = { 1, 3, 6 }。 ⑥、d[6] = 4，3 &lt; d[6] &lt; 6，于是把 6 替换掉，这时 Len = 3, B[] = { 1, 3, 4 }。 ⑦、d[7] = 8，d[7] &gt; B[3]，将 8 追加到 B 数组末尾，这时 Len = 4, B[] = { 1, 3, 4, 8 }。 ⑧、d[8] = 9，d[8] &gt; B[4]，将 9 追加到 B 数组末尾，这时 Len = 5, B[] = { 1, 3, 4, 8, 9 }。 ⑨、d[9] = 7，B[3]=4 &lt; d[9] &lt; B[4]=8，所以最新的 B[4] = 7，这时 Len = 5, B[] = 1, 3, 4, 7, 9。 注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。 有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。 在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。 // 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1int upper_bound(int B[], int left, int right, int key){ int mid; // 将 key 插入到数组末尾 if (B\\[right\\] &lt; key) return right + 1; // num\\[left\\] ≤ key &lt; nums\\[right\\] 之后 left 将大于 right，循环结束 while (left &lt; right) { mid = (left + right) / 2; if (B\\[mid\\] &lt; key) { left = mid + 1; } else { right = mid; } } return left; } int lengthOfLIS(int* nums, int numsSize){ if (numsSize &lt; 2) return numsSize; int* B = (int *)malloc(sizeof(int) * (numsSize + 1)); B\\[0\\] = 0; // 无意义 B\\[1\\] = nums\\[0\\]; // 从 1 开始是为了让 len、pos 不需要 -1 或 +1 int len = 1; for (int i = 1; i &lt; numsSize; i++) { // 找到插入位置 int pos = upper_bound(B, 1, len, nums\\[i\\]); B\\[pos\\] = nums\\[i\\]; // 打印 B 数组，看看每次循环的变化，B\\[0\\] 无意义 printf(&quot;%d &quot;, pos); for (int k = 0; k &lt;= pos; k++) { printf(&quot;%d&quot;, B\\[k\\]); } printf(&quot;\\\\n&quot;); if (len &lt; pos) { len = pos; } } return len; } int main(){ int A[] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }; printf(“%d”, lengthOfLIS(A, 11)); return 0; }","tags":[]},{"title":" LC 67\t\t","date":"2019-02-20T06:02:17.000Z","path":"2019/02/20/lc-68/","text":"六七四、Longest Continuous Increasing Subsequence（最长连续递增序列）1、问题描述 给定一个未经排序的整数数组，找到最长且连续的的递增序列。 2、算法分析 用中间变量 temp 保存每次向后查找连续的长度，当递增中断或达到末尾时，与最大长度变量 max 作比较。 3、代码实现 int findLengthOfLCIS(int* nums, int numsSize) { if (numsSize &lt; 2) return numsSize; int max = 0, temp = 1; for (int i = 1; i &lt; numsSize; i++) { if (nums\\[i\\] &gt; nums\\[i-1\\]) { temp++; } else { if (max &lt; temp) { max = temp; } temp = 1; } } if (max &lt; temp) { max = temp; } return max; } int main(){ int a[] = { 4, 1, 3, 5, 7 }; int count = sizeof(a) / sizeof(int); printf(&quot;%d&quot;, findLengthOfLCIS(a, count)); return 0; }","tags":[]},{"title":" ","date":"2019-02-20T03:53:20.000Z","path":"2019/02/20/1771/","text":"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html","tags":[]},{"title":" 算法复杂度与 Master 定理\t\t","date":"2019-02-19T14:47:36.000Z","path":"2019/02/19/e7-ae-97-e6-b3-95-e7-9a-84-e5-a4-8d-e6-9d-82-e5-ba-a6-e4-b8-8e-master-e5-ae-9a-e7-90-86/","text":"原文：算法的复杂度与Master定理 1、时间复杂度 平时设计或者阅读一个算法时，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如一个二分查找算法的平均时间复杂度为 O(logn)，快速排序可能是 O(nlogn)。 与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ 和 o，Master 定理。 在算法复杂度分析中，log 通常表示以 2 为底的对数。 算法复杂度是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常利用渐进性态来描述算法的复杂度。 用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在，当 n→∞ 时，有 就说 是 T(n) 当 n→∞ 时的渐进性态。 比如 T(n) = 2n2 + nlogn + 3，那么显然它的渐进性态是 2 n2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果它们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。 总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ 和 o 可以帮助我们了解函数渐进阶的大小。 假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：（∃ 存在、∀ 任意） f(n) = O(g(n))：∃c&gt;0, n0∈ℕ, ∀n≥n0, f(n)≤cg(n); f 的阶不高于 g 的阶。 f(n) = Ω(g(n))：∃c&gt;0, n0∈ℕ, ∀n≥n0, f(n)≥cg(n); f 的阶不低于 g 的阶。 f(n) = θ(g(n))：⟺ f(n) = O(g(n)) &amp;&amp; f(n) = Ω(g(n)); f 的阶等于 g 的阶。 ∃c1、c2，∀n≥n0, c1*g(n) &lt; f(n) &lt; c2 * g(n)，即认为：在 n 足够大后，g(n) 给出了 f(n) 的一个确界 f(n) = o(g(n))：∀ε&gt;0, ∃n0∈ℕ, ∀n≥n0, f(n)/g(n) &lt; ε; f 的阶低于 g 的阶。 可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的）；相反，记号 Ω 给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。 列举一些常见的函数之间的渐进阶的关系： logn! = θ(nlogn) logn2 = θ(logn) logn2= O(√n) n = Ω(log2n) log2n = Ω(logn) 2n = Ω(n2) 2n = O(3n) n! = o(nn) 2n = o(n!) 有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。 即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。 有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为 θ(n2)，最好情况下为 θ(n)，那这个算法的复杂度一定是 O(n2)、Ω(n) 之间的。也就是说 n2 是该算法复杂度的上界，n 是其下界。 2、Master 定理 有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的： 设常数 a ≥ 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n/b) + f(n)，则有： 若 f(n) = O(nlogba − ε), ε&gt;0, 那么 T(n) = θ(nlogba)。 若 f(n) = θ(nlogba), 那么 T(n) = θ(nlogbalogn)。 若 f(n) = Ω(nlogba + ε), ε&gt;0, 对于某常数 c &lt; 1 和充分大的 n 有af(n/b)≤cf(n)，那么 T(n)=θ(f(n))。 比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n/2) + θ(1)，f(n) = θ(1)，显然 nlogba = n0 = θ(1)，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(logn)。 再看一个例子，T(n) = 9 T(n/3) + n，f(n) = n，可知 nlogba = n2，令 ε 取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n2)。 稍微复杂点的例子，T(n) = 3 T(n/4) + nlogn。nlogba = O(n0.793)，取 ε = 0.2，显然当 c = 3/4 时，对于充分大的 n 可以满足 a*f(n/b) = 3*(n/4)*log(n/4) &lt;= (3/4)*n*log n = c*f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(nlogn)。 运用 Master 定理的时候，有一点一定要特别注意，就是第一条和第三条中的 ε 必须大于零。如果无法找到大于零的 ε，就不能使用这两条规则。 举个例子，T(n) = 2 T(n/2) + nlogn。可知 nlogba = n1，而 f(n) = nlogn，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的 ε 使得 nlogn = O(n1−ε) 或者 nlogn = Ω(n1+ε)，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 T(n) = O(nlog2n)。 简单的说一下计算过程： 递归树的建立过程就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 nlogn 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n/2的问题，分别需要 (n/2)log(n/2) 的时间。因此在第二层一共需要 n(logn-1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n/4)log(n/4) 时间的节点，总的时间消耗为 n(logn-2)。依此类推，第 k（设树根为 k = 0）层有 2k 的节点，总的时间为 n*(logn-k)。而且可以知道，这棵树总共有 logn 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到： 3、空间复杂度 空间复杂度通常不计入输入本身所占用的空间，统计的是算法额外开辟的空间。 由于任意算法的任何一次运行过程中所消耗的存储空间，都不会多于其间执行基本操作的累计次数，所以每次基本操作所涉及的存储空间都不会超过常数规模，即使每次基本操作所占用或访问的存储空间都是新开辟的，整个算法所需的空间总量，也不过与基本操作的次数同阶。所以时间复杂度本身就是空间复杂度的一个天然上界。当然，由时间复杂度确定的平凡上界不能令人满意，则可更为精细的考察不同算法的空间复杂度。","tags":[]},{"title":" Manacher's Algorithm (马拉车)算法\t\t","date":"2019-02-19T09:30:37.000Z","path":"2019/02/19/manachers-algorithm/","text":"原文：Manacher’s Algorithm 马拉车算法 Manacher’s Algorithm 是用来查找一个字符串的最长回文子串的线性方法，由一位叫 Manacher 的人在 1975 年发明，这个方法的最大贡献是在于将时间复杂度提升到了线性。 回文串就是正读反读都一样的字符串，比如 “bob”、”level”、”noon” 等。在一个字符串中找出最长回文子串，可以用蛮力法、动态规划法、中间扩展法，详见。但是这些方法并不是很高效，下面来看时间复杂度为 O(n) 的马拉车算法。 由于回文串的长度可奇可偶，比如 “bob” 是奇数形式的回文，”noon” 就是偶数形式的回文，马拉车算法的第一步是预处理，做法是在每一个字符的左右都加上一个特殊字符，比如加上 ‘#’，那么 bob (3 位) ==&gt; #b#o#b# (7 位) noon(4 位) ==&gt; #n#o#o#n#(9 位) 这样做的好处是不论原字符串是奇数还是偶数长度，处理之后的字符串都是奇数长度，这样就不用分情况讨论，而可以统一处理 接下来我们还需要和处理后的字符串 t 等长的数组 p，其中 p[i] 表示以 t[i] 字符为中心的回文子串的半径，若 p[i] = 1，则它的回文子串就是 t[i] 本身，来看一个简单的例子： t = { # 1 # 2 # 2 # 1 # 2 # 2 # }p = { 1 2 1 2 5 2 1 6 1 2 3 2 1 } 为啥需要关心回文子串的半径呢？ ①、以中间的 ‘1’ 为中心的回文子串 “#2#2#1#2#2#” 的半径是 6，而回文子串为 “22122”，字符长度是 5，等于半径减 1。 ②、”#b#o#b#” 很容易看出来以 ‘o’ 为中心的回文串的半径是 4，而 “bob” 的长度是 3，等于半径减 1。 ③、”#n#o#o#n#” 以最中间的 ‘#’ 为中心的回文串的半径是 5，而 “noon” 的长度是4，等于半径减 1。 综上，可以得出规律：回文长度 Length = 半径 - 1。 所以只要找到了最大的半径，就知道最长的回文子串的字符个数，结合子串的起始位置就找到了子串。 先来看 “#1#2#2#1#2#2#” 中间的 ‘1’ 在字符串的位置是 7，半径是 6，貌似 7 - 6 = 1，刚好就是回文子串 “22122” 在原字符串 “122122” 的起始位置 1。 再来验证下 “bob”。”o” 在 “#b#o#b#” 中的位置是 3，但是半径是 4，3 - 4 = -1，肯定不对。所以应该至少把中心位置向后移动一位，才能为 0，那么我们就需要在前面增加一个字符，这个字符不能是 ‘#’号，也不能是原字符串中可能出现的字符，所以暂且就用 ‘$’ 吧。这样都不相同的话就不会改变 p 值了，那么末尾要不要对应的也添加呢，其实不用的，不用加的原因是字符串的结尾标识为 ‘\\0’，等于默认加过了。那此时 “o” 在 “$#b#o#b#” 中的位置是 4，半径是 4，4 - 4 = 0，貌似没啥问题。 再来验证下字符串 “$#1#2#2#1#2#2#” 中间的 ‘1’ 在的位置是 8，而半径是 6，8 - 6 = 2，而需要的是 1，所以要除以 2。 之前的 “bob” 4 - 4 = 0，除以 2 还是 0，没有问题。 再来验证下 “noon”，中间的 ‘#’ 在字符串 “$#n#o#o#n#” 中的位置是 5，半径是 5，(5 - 5) / 2 = 0，完美。 可以任意试试其他的例子，都是符合这个规律：最长子串的长度是半径减 1，起始位置是中间位置减去半径再除以 2。 下面就来看如何求 p 数组，需要新增两个辅助变量 mx（回文子串能延伸到的最右端的位置）和 id（能延伸到最右端的位置的那个回文子串的中心点位置）。这个算法的最核心的一行如下： p[i] = mx &gt; i ? min(p[2 * id - i], mx - i) : 1; 可以这么说，这行要是理解了，那么马拉车算法基本上就没啥问题了。 当 mx - i &gt; P[j] 的时候，以 S[j] 为中心的回文子串包含在以 S[id] 为中心的回文子串中，由于 i 和 j 对称，以 S[i] 为中心的回文子串必然包含在以 S[id] 为中心的回文子串中，所以必有 P[i] = P[j]。 当 P[j] &gt;= mx - i 的时候，以 S[j] 为中心的回文子串不一定完全包含于以 S[id] 为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以 S[i] 为中心的回文子串，其向右至少会扩张到 mx 的位置，也就是说 P[i] = mx - i。至于 mx 之后的部分是否对称，就只能老老实实去匹配了。 对于 mx &lt;= i 的情况，无法对 P[i] 做更多的假设，只能 P[i] = 1，然后再去匹配了。 代码实现： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #define MIN(a, b) (a) &lt; (b) ? (a) : (b) char longestPalindrome(char s){ if (s == NULL || strlen(s) &lt; 1) return “”; char* t = (char *)malloc(sizeof(char) * 1000); t\\[0\\] = &apos;$&apos;; t\\[1\\] = &apos;#&apos;; int length = 1; // 向原字符串中插入 $ 和 # for (int i = 0; i &lt; strlen(s); ++i) { t\\[++length\\] = s\\[i\\]; t\\[++length\\] = &apos;#&apos;; } // 输出插入结果 for(int i = 0; i &lt; length; i++) { printf(&quot;%c &quot;, t\\[i\\]); } printf(&quot;\\\\n&quot;); // 半径数组。初始化为 0 int* p = (int *)calloc(length, sizeof(int)); /\\* max 即为上文的 mx mid 即为上文的 id resLen 半径 resCenter 中心点 */ int max = 0, mid = 0, resLen = 0, resCenter = 0; for (int i = 1; i &lt; length; ++i) { // p\\[2 * mid - i\\] 即为 p\\[j\\] p\\[i\\] = max &gt; i ? MIN(p\\[2 * mid - i\\], max - i) : 1; // 当 max &lt; i 时，i + p\\[i\\] 即为 max + 1, max + 2, ... while (i - p\\[i\\] &gt; -1 &amp;&amp; i + p\\[i\\] &lt; length &amp;&amp; t\\[i + p\\[i\\]\\] == t\\[i - p\\[i\\]\\]) ++p\\[i\\]; if (max &lt; i + p\\[i\\]) { max = i + p\\[i\\]; mid = i; } if (resLen &lt; p\\[i\\]) { resLen = p\\[i\\]; resCenter = i; } } char* sub = (char *)malloc(sizeof(char) * resLen); for (int i = 0; i &lt; resLen - 1; i++) { sub\\[i\\] = s\\[(resCenter - resLen) / 2 + i\\]; // strncpy(sub, s + (resCenter - resLen) / 2, resLen - 1); } sub\\[resLen - 1\\] = &apos;\\\\0&apos;; return sub; } int main(){ printf(“%s”, longestPalindrome(“dsfsdhadhfkdsdsfsdhadhdsfsdhadhfkddsfsdhadhfkdsahfksadhdsfsdhadhfkdsahfksadhfksddsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdsfsdhadhfkdsahfksadhfksdhfusdihfksjadsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskdfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskfdsfsdhadhfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhsksahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskfkdsahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhskahfksadhfksdhfusdihfksjadfhksadjkdsahfdsjkhfksdhffhiawoeuruihweiyrtiuoncsdbfzmbfkhfioaewncfhsk”)); return 0; }","tags":[]},{"title":" 最长回文子串\t\t","date":"2019-02-19T07:06:19.000Z","path":"2019/02/19/longestpalindromicsubstring/","text":"1、问题描述 给定一个字符串 s，找到 s 中最长的回文子串。 2、算法分析 大多数问题都可以用暴力法解决。暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。 时间复杂度：O(n3)，假设 n 是输入字符串的长度，则 (n * (n−1))/2​ 为此类子字符串（不包括字符本身是回文的一般解法）的总数。因为验证每个子字符串需要 O(n) 的时间，所以运行时间复杂度是 O(n3)。 空间复杂度：O(1)。 为了改进暴力法，我们首先观察如何避免在验证回文时进行不必要的重复计算。考虑 “ababa” 这个示例。如果我们已经知道 “bab” 是回文，那么很明显，”ababa” 一定是回文，因为它的左首字母和右尾字母是相同的。 我们给出 P(i,j) 的定义如下： 如果子串 Si…Sj ​是回文子串 p(i, j) = true 其他情况 p(i, j) = false 因此： P(i, j) = ( P(i+1, j-1) and Si​ == Sj​) 基本示例如下： P(i, i) = true P(i, i+1) = (Si ​== Si+1​) 这产生了一个直观的动态规划解法，我们首先初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推… 3、复杂度分析 时间复杂度：O(n2)，这里给出我们的运行时间复杂度为 O(n2)。 空间复杂度：O(n2)，该方法使用 O(n2) 的空间来存储表。 4、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char longestPalindrome(char s){ if (s == NULL || strlen(s) &lt; 1) { return “”; } int n = (int)strlen(s); // 初始化二维数组 int matrix\\[n\\]\\[n\\]; for (int i = 0; i &lt; n; i++) for (int j = 0; j&lt; n; j++) matrix\\[i\\]\\[j\\] = 0; int left = 0; int right = 0; // i 从倒数第二个开始，从右往左。标识子串的起始位置 for (int i = n - 2; i &gt;= 0; i--) { matrix\\[i\\]\\[i\\] = 1; // j 从 i 的下一位开始，从左往右。标识子串的结束位置 for (int j = i + 1; j &lt; n; j++) { // ①、s\\[i\\] == s\\[j\\] ②、小于或等于 3 个字符 ③、内缩一位是回文子串 matrix\\[i\\]\\[j\\] = (s\\[i\\] == s\\[j\\] &amp;&amp; (j - i &lt; 3 || matrix\\[i+1\\]\\[j-1\\])); // 获得最长的子串位置 if(matrix\\[i\\]\\[j\\] &amp;&amp; right - left &lt; j - i) { left = i; right = j; } for (int m = 0; m &lt; n; m++) { for (int k = 0; k &lt; n; k++) printf(&quot;%d &quot;, matrix\\[m\\]\\[k\\]); printf(&quot;\\\\n\\\\n&quot;); } } } char* sub = (char *)malloc(sizeof(char) * (right - left + 1)); int i = 0; for (; i &lt; right - left + 1; i++) { sub\\[i\\] = s\\[left + i\\]; //strncpy(sub, s+left, right+1); } sub\\[i\\] = &apos;\\\\0&apos;; return sub; } int main(){ printf(“%s”, longestPalindrome(“aaabaaaa”)); return 0; } 关键代码： matrix[i][j] = (s[i] == s[j] &amp;&amp; (j - i &lt; 3 || matrix[i+1][j-1])); 以及 i 和 j 的取值方向","tags":[]},{"title":" 硬币问题\t\t","date":"2019-02-19T03:56:00.000Z","path":"2019/02/19/e7-a1-ac-e5-b8-81-e9-97-ae-e9-a2-98/","text":"1、问题描述 假设有 1 元、3 元、5 元的硬币无限个，现在需要凑出 11 元，问如何组合才能使硬币的数量最少？ 2、算法分析 有最小单位 1 的情况下，可以使用贪心算法： NSInteger count = m / 5;NSInteger mol = m % 5; if(mol/3 &gt; 0) { count++; mol %= 3;} count += mol; 但当硬币的种类改变，并且需要凑出的总价值变大时，很难靠简单的计算得出结果。贪心算法可以在一定的程度上得出较优解，但不是每次都能得出最优解。 这里运用动态规划的思路解决该问题。动态规划中有三个重要的元素：最优子结构、边界、状态转移公式。按照一般思路，先从最基本的情况来一步一步地推导。 注意：动态规划的策略在于当前的硬币（或其他物品）是否能算进去。 先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量。 当 i = 0 时，很显然知道 d(0) = 0。 当 i = 1 时，因为有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = d(0) + 1。 当 i = 2 时，因为并没有 2 元的硬币，所以在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = d(1) + 1。 当 i = 3 时，需要 3 个 1 元硬币或者 1 个 3 元硬币，d(3) = min{ d(2)+1, d(3-3)+1 }; … 抽离出来 d(i) = min{ d(i-1)+1, d(i-vj)+1 }，其中 i - vj &gt;= 0，vj 表示第 j 个硬币的面值。 这里 d(i-1)+1 和 d(i-vj)+1 是 d(i) 的最优子结构；d(0) = 0 是边界；d(i) = min{ d(i-1)+1, d(i-vj)+1 } 是状态转移公式。其实我们根据边界 + 状态转移公式就能得到最终动态规划的结果。 3、算法实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Coins 3 int dp(int n){ // min 数组包含 d(0)~d(n)，所以数组长度是 n+1 n++; // 初始化数组 int min = (int)calloc(n, sizeof(int)); // 可选硬币种类 int v\\[Coins\\] = { 1, 3, 5 }; for (int i = 1; i &lt; n; i++) { min\\[i\\] = min\\[i-1\\] + 1; for (int j = 0; j &lt; Coins; j++) { // 装不下 if (v\\[j\\] &gt; i) { break; } // 装得下 if (min\\[i - v\\[j\\]\\] &lt; min\\[i - 1\\]) { min\\[i\\] = min\\[i - v\\[j\\]\\] + 1; } } } for (int i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, min\\[i\\]); } return min\\[n - 1\\]; } int main(){ printf(“\\n%d”, dp(101)); return 0; } 4、拓展 上面的问题中包含了最小单位 1 元的硬币，所以每次 i 增加时，都能 min[i] = min[i - 1] + 1（+1 是用了 1 元硬币），但如果硬币为 2 元、3 元、5 元呢？应该如何求出 11 元呢？ 来推算下： ①、n = 1，不存在 1 元硬币，且 2、3、5 &gt; 1，所以 f(1) = 0; ②、n = 2，存在 2 元硬币，所以 f(2) = 1; ③、n = 3，存在 3 元硬币，所以 f(3) = 1; ④、n = 4，不存在 4 元硬币，而 2 和3 &lt; 4，5 &gt; 4，其中 f(4-3) = f(1) = 0说明在去除 3 元的情况下，不能获得剩下的 1 元； f(4-2) = f(2) = 1 说明在去除2 元的情况下，可以获得剩下的2 元，f(4) = f(2) + 1 = 2; 结合上面两种情况 f(4) = MIN{ f(4-2) + 1 } ⑤、n = 5，存在 5 元硬币，所以 f(5) = 1; ⑥、n = 6，不存在 6元硬币，而 2、3、5 &lt; 6，其中 f(6-5) = f(1) = 0 说明在去除 5 元的情况下，不能获得剩下的 1 元； f(6-3) = f(3) = 1 说明在去除3 元的情况下，可以获得剩下的 3 元，f(6) = f(6-3) + 1 = 2; f(6-2) = f(4) = 2 说明在去除2 元的情况下，可以获得剩下的3 元，f(6) = f(6-4) + 1 = 3; 结合上面三种情况 f(6) = MIN{ f(6-3) + 1, f(6-2) + 1 } 【状态】是 f(n) 【边界】是 n = 2、3、5 时只有一种选择 【状态转移方程】是f(n) = MIN{ f(n - ci) +1 }, 其中n 表示当前的总额，ci 表示金币数额。 注意：因为是取最小值，所以是无法获得的总额时，如 f(1)，应该让 f(1)等于很大的值，这样就可以将它剔除出去。 下面的代码为了直观每次选币的过程，增加了结构体、打印代码，不需要时可以自行删除。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define Coins 3 #define MIN(a, b) (a) &lt; (b) ? (a) : (b) typedef struct CoinLog { int minCoin; // 最少的硬币数 int coin[100]; // 所选硬币} CoinLog; int dp(int n){ n++; // result 数组包含 d(0)~d(n)，所以数组长度是 n+1 // 初始化数组 // int result = (int)malloc(sizeof(int) n);// for (int i = 0; i &lt; n; i++) {// result[i] = n;// } CoinLog result = (CoinLog )malloc(sizeof(CoinLog) n); for (int i = 0; i &lt; n; i++) { CoinLog log = { n, {0} }; result[i] = log; } // 硬币种类 int v\\[Coins\\] = { 2, 3, 5 }; for (int i = 1; i &lt; n; i++) { printf(&quot;%3d =&quot;, i); for (int j = 0; j &lt; Coins; j++) { // 硬币正好 if (v\\[j\\] == i) { result\\[i\\].minCoin = 1; result\\[i\\].coin\\[0\\] = v\\[j\\]; } // 硬币太大 else if (v\\[j\\] &gt; i) { } // 循环 Coins，找出最少的币数 else if (result\\[i - v\\[j\\]\\].minCoin &lt; result\\[i\\].minCoin) { result\\[i\\].minCoin = result\\[i - v\\[j\\]\\].minCoin + 1; int k = 0; for (; k &lt; result\\[i - v\\[j\\]\\].minCoin; k++) { result\\[i\\].coin\\[k\\] = result\\[i - v\\[j\\]\\].coin\\[k\\]; } result\\[i\\].coin\\[k\\] = v\\[j\\]; } } if (result\\[i\\].minCoin &lt; n) { // 显示每次怎么找的 for (int k = 0; k &lt; result\\[i\\].minCoin; k++) { printf(&quot;%3d &quot;, result\\[i\\].coin\\[k\\]); } } printf(&quot;\\\\n&quot;); } // for (int i = 1; i &lt; n; i++) {// printf(“%d “, result[i]);// } return result\\[n - 1\\].minCoin; } int main(){ printf(“\\n最少的币数 = %d”, dp(21)); return 0; } 1 = 2 = 2 3 = 3 4 = 2 2 5 = 5 6 = 3 3 7 = 2 5 8 = 3 5 9 = 2 2 5 10 = 5 5 11 = 3 3 5 12 = 2 5 5 13 = 3 5 5 14 = 2 2 5 5 15 = 5 5 5 16 = 3 3 5 5 17 = 2 5 5 5 18 = 3 5 5 5 19 = 2 2 5 5 5 20 = 5 5 5 5 21 = 3 3 5 5 5 最少的币数 = 5","tags":[]},{"title":" 搜索优化\t\t","date":"2019-02-18T09:14:04.000Z","path":"2019/02/18/e6-90-9c-e7-b4-a2-e4-bc-98-e5-8c-96/","text":"优化技巧：公司开发者账号 + 语言本地化 + 评论 + 积分墙 + 信息流 + 版本迭代 https://blog.csdn.net/weixin_44052294/article/details/84969839 https://blog.csdn.net/weixin_44052294/article/details/85003694","tags":[]},{"title":" 苹果审核\t\t","date":"2019-02-18T09:13:14.000Z","path":"2019/02/18/e8-8b-b9-e6-9e-9c-e5-ae-a1-e6-a0-b8/","text":"https://blog.csdn.net/MinggeQingchun/article/details/80349795 https://baijiahao.baidu.com/s?id=1608489655023296632&amp;wfr=spider&amp;for=pc https://blog.csdn.net/qq_15602525/article/details/80249665","tags":[]},{"title":" 马甲包\t\t","date":"2019-02-18T08:49:29.000Z","path":"2019/02/18/vestcode/","text":"App Store 审核指南 一、苹果审核条款条款说明： 4.3 重复应用 不要为同一个应用程序创建多个 Bundle ID。如果你的应用程序有多个版本，例如针对特定的国家和地区的版本，体育队伍、大学等，考虑提交一个版本的应用但是使用应用内付费来做区分。此外还要避免将你的应用放到已经饱和的分类下。AppStore 当中已经有了足够多的模拟放屁、打嗝声音的 App，以及手电筒 App。如果想要往 AppStore 投放重复应用可能会导致你的开发者资格被撤销。 被拒邮件内容： Guideline 4.3 - Design Your app duplicates the content and functionality of apps currently available on the App Store. Apps that simply duplicate content or functionality create clutter, diminish the overall experience for the end user, and reduce the ability of developers to market their apps. Next Steps We encourage you to review your app concept and incorporate different content and features that are in compliance with the App Store Review Guidelines. For app design information, check out the following videos: “Best Practices for Great iOS UI Design” and “Designing Intuitive User Experiences,” available on the Apple Developer website. You may also want to review the iOS Human Interface Guidelines for more information on how to create a great user experience in your app. If you cannot - or choose not to - revise your app to be in compliance with the App Store Review Guidelines, you may wish to build an HTML5 web app instead. You can distribute web apps directly on your web site; the App Store does not accept or distribute web apps. HTML5 is the major new version of HTML and enables audio and video to play natively in the browser without requiring proprietary plug-ins. Using HTML5, web apps can look and behave like native iPhone and iPad apps, and using HTML5’s Offline Application Cache, a web app can work even when the device is offline. With web apps, you have flexibility to deliver as much or as little functionality as you desire. To get started with iPhone or iPad web apps, please review the Safari Client-Side Storage and Offline Applications Programming Guide. For a description of the HTML elements and attributes you can use in Safari on iPhone, check out Safari HTML Reference: Introduction. 简而言之：4.3 是功能或者应用程序重复出现在 AppStore，相同类型产品功能较一致（包括上传马甲或者分包）。 二、苹果的三种审核机制1、预审核 扫描 api 及 plist文件字符缺失等。 此处分两步，第一步为上传时苹果 Application Loador 等应用对于适配 icon 等的检查；第二步为上传后苹果的功能性检查，例如配置了 push 功能但有缺失或者未打开功能，则会邮件提示等。 2、机审 苹果机器审核的具体原理估计只有苹果内部人员才知道，而且这个审核原理应该也是会不断的升级和变化。根据目前大家测试的结果来看，当前主要原理是对 App 扫描。App 扫描分为两部分， 一部分是扫描代码，一部分是扫描资源文件。 ①、代码扫描部分主要是编译器会对每个函数生成编译器内部才识别的函数名，所以这里就需要针对不同的语言进行不同的修改，而且修改的量也需要比较大，才能绕过苹果的识别库。 可以人工修改， 比如函数增加一些默认参数、修改类名和函数名，比较费时费力。也可以写代码进行批量修改或生成，省时省力。 ②、扫描资源文件部分主要是针对各个文件扫描出来的 MD5 进行比对，如果文件和苹果识别库里的 App 相似达到一定程度，就会触发 4.3，这时可以人工增加大量小文件进行混淆，当然技术实力强的也可以通过代码进行生成。 部分无法过机审情况可尝试加速审核绕过机审。 3、人工审核 此处主要检测功能或者 App 体验测试。例如用测试账号登录 App 体验功能，或其他是否有明显 bug 等，ipv6 也在此处检测。 苹果很久以前都是人工进行 4.3 审核，效率很慢。 被人工审核出来的， 基本上要么是被人举报， 要么就是 App 实在是太明显了， 比如仿非常出名的游戏， 不然一般是很难查出来的。 如果你的账号之前查出来个 4.3， 那么后面再次提交时，苹果审核人员就会高度怀疑，所以被再次查出 4.3 的可能性就高了。 注：H5 类游戏和应用是很容易被人工 4.3 的，再如何混淆都绕不过人工 4.3。 苹果政策： 包名相同 包名不同 二进制代码相同 无意义 无法通过审核 二进制代码不同 视为更新 即马甲，可能通过审核 三、被拒原因机审： ①、你多次提交一个项目，代码重复率在 60% 以上； ②、你的代码被苹果做了标记，拉入了黑名单； ③、你的项目中开源代码占比过高，个人代码占比不足 50%； ④、代码层面和别的项目产生了关联性； ⑤、隐藏功能。即：用户使用 App 过程中并未使用到的后台任务（动态部署除外）。 人工审核： ①、购买的国内（外）开发者账号, 发生了账号 4.3 被拒连坐； ②、UI 截图有极高的相似度（Apple Review 图像对比技术）； ③、ITC 后台设置的元数据有较高相似度。如标题、描述、关键词、技术支持网址、隐私声明等； ④、内购关联问题：多个账号使用同一个人的银行卡及税务登记信息； ⑤、国外账号权重低，对于 Apple 信任度有一定的影响。 也存在被政策误伤的可能性。 四、什么是马甲包？ 与原 App 包除了包名、Bundle ID、图标等给用户加以区分的东西不同，其他功能基本不变的 App 包。简单理解为给产品穿个马甲。 马甲包是利用 AppStore 规则漏洞，通过技术手段，多次上架同一款产品的方法。 五、马甲包的好处1、抗风险 正常情况下，任何一款产品都是要不断的更新功能的。如果直接在主包上更新，一旦新功能不被用户接受那就损失大了，公司前期大量投入带来的用户将会流失，这对很多产品开发者来说是不可承受之痛。 如果使用马甲包，则可以随意测试新功能，好的功能就在主包上迭代，不好的则丢弃。 2、导量 主包和马甲包属于同一个平台，用户信息可以共享，通过弹窗、广告、push 等引导用户去下载主 App。（网盟相互导流） 3、增加关键词覆盖数 AppStore 关键词长度上限是 100 个字符，据了解人为正常优化的极限是关键词覆盖数在 4000 左右，覆盖数在 8000+ 的都是利用了苹果漏洞。所以，多做一个马甲也就意味着覆盖的关键词可以更多。 4、刷榜 ①、积分墙：理论上是真实用户，冲榜量级大，可靠后续补量维持。但冲榜和维榜费用高昂，非一般产品所能承受。 ②、真机：利用真实机器操作任务，但不能抹机，否则就成假量了。成本相对较低。 ③、技术流：机刷，服务器控制操作，成本最低。 以上机刷是最便宜的，但是风险高，容易被苹果后台发现下架，所以一般用马甲包来做机刷，以此来抵抗风险。 马甲包有时是作为备胎存在的。当主号在进行刷榜被下架后就会立即上架作为替身，很多不明真相的用户并没有察觉，所以这类替身马甲很多开发者都是直接使用主 App 的所有资源，直接换个开发者账号。如果资源允许的话，也可以使用不同的后台，这样能避免后台被黑和主 App 被下架同时发生的突发情况。 六、制作马甲包1、二进制代码务必不同 二进制代码是应用市场判别产品的唯一标准，把代码做一些修改，就会生成一个全新的二进制代码，这是制作马甲包的唯一方式。 ①、升级 Version 提交审核； ②、换 Bundle Id 提交审核； ③、换不同开发者账号提交审核； ④、修改 logo 素材及 UI 色调等； ⑤、修改功能界面等，可改功能可做开关； ⑥、添加垃圾代码或者注释块，主要防苹果机审扫描。 2、工程目录修改 ①、修改工程名称； ②、修改工程内文件名称； ③、修改工程内文件夹名称； ④、修改实体文件夹名称； ⑤、删除和新建 .entitlements； ⑥、点击 xx.xcodeproj 显示包内容，打开 project.pbxproj，全部替换名称； ⑦、其他替换。 3、功能局部化 如果主 App 功能较为丰富，做马甲是可以独立其中一部分功能。审核通过率高，但投入成本比较贵，适合大产品大公司操作。 4、产品简单化（关闭部分功能或页面） 如果方式 2 复杂，可以选择产品简单化操作。具体是指： ①、主 App 中的部分界面/功能删除掉； ②、主 App 中的部分界面/功能设置开关按钮，在审核期间关闭，审核通过后打开。 5、页面差异化 修改 App 启动后第一个页面，保证马甲与主 App 的第一个页面不同，从先入视觉迷惑苹果审核人员。 6、整套 UI 更改 适合游戏类。 7、项目修改 ①、修改应用程序价格，打造与原产品不同的价格级别； ②、修改应用程序发布地区，打造与原产品不同的售卖地区或分不同地区运营； ③、修改产品分类，打造与原产品不同的产品侧重属性分类； ④、市场图、应用描述、搜索关键词调整； 注意：切断当前马甲包与以往马甲包的所有相似性关联。 ①、ipa 包特征：包括有代码相似性，资源相似性； 代码相似性解决办法： a. 已有代码的混淆（改类名、改函数名） b. 添加一些无用的代码。 资源相似性解决办法： a. 资源改名； b. 适当添加一些无用的资源。 ②、开发者帐号：两个马甲包不要关联到同一个开发者帐号的信息；比如打包时关联。 ③、打包电脑：有条件的最好用不同的 MAC 来打包（每台 MAC 上最好打马甲包不要超过 5 个）。 ④、上传 IP：上传马甲包时，IP 不要跟其他马甲包的 IP 相同。 ⑤、材料相似：itunes 后台材料如宣传图、ICON、版权人不要出现相同。 七、混淆1、修改类名、文件名 ①、手动操作 在 Xcode 里修改文件名类名，然后在可能引用的地方替换（header），要注意的地方是替换的时候要匹配大小写；如果文件夹名称跟文件名一样的话，文件夹名称也要跟着改名，否则替换之后路径引用可能找不到。 ②、脚本批量操作 最好先整理工程，确保以下几点能让脚本写的更简单更可靠： a. 要修改的类和文件最好都放到一个文件夹下，万一搞出事不用东找西找，备份和回滚也简单一点； b. 类名和文件名尽量带上前缀，这样修改只替换前缀即可，也不太会跟函数名、变量名什么的重复 c. 最好过一遍，把不能修改类名的列出来，比如外面太多地方调用的、第三方的类库。在写脚本的时候把他们排除在外 脚本就是遍历文件。根据上面的 a、b、c 条件在文件中查找替换。改完后可以替换一下 xx.xcodeproj/project.pbxproj 里的相应字符串，这样 Xcode 打开工程的时候就不用手动再添加进来。 2、添加垃圾函数 OC 头文件的声明必然是在 @interface、@end 之间，实现是在 @implementation、@end 之间，直接在相应的地方插入垃圾函数，模板可以直接写个 HelloWorld 生成个随机字符串。避免当前语言的关键字如 break、false、if 之类的。 3、添加垃圾类 可以简单的把垃圾类文件都放到同一个文件夹下方便管理。不太确定的是如果外部不引用这些垃圾类，编译之后它们会不会因为太独立而被检测认为是垃圾代码。所以保险起见，写了一个单独的头文件 include 所有这些生成的垃圾类，然后在外部 include 了这个单独的头文件。 4、修改资源 md5 值 资源文件有很多类型，通常来说文本文件添加随机数量的空格或空行应该就可以了。图片的话常见的 png 和 jpg 都是有固定的结尾字节块的，png 是 00 00 00 00 49 45 4E 44 AE 42 60 82，jpg 是 ffd9，用十六进制查看工具打开图片应该能注意到这个规律，也可以参考下常见图片文件格式简析。在结尾字节块后添加的内容是不会影响图片本身显示的，我们可以利用这个来改变图片的 md5 值。音效应该也有相应的格式。 5、创建资源垃圾文件 跟第 3 步类似，不过这个最好也随机下创建文件夹显得真实点，一些文本文件是什么格式都有各自定义，png 和 jpg 的话就随机写任意长度的任意字符，最好结尾加上相应的结尾字节块，防止第 5 步后又执行第 4 步导致出错。 6、其他事项 上面的基本都能脚本自动化执行，完了后工程名最好也在 Xcode 改下；info.plist 会被打包进 ipa，最好也多加几个字段上去；target 能改也改下方便识别；scheme 关联到导出的 ipa 文件名，不是特别麻烦也顺手改掉；包名、启动页、图标应该都是基本的东西不会被忽略。 八、总结马甲包的出现给 ASO 优化带来了新的方式，也给优化工作带来了极大的便利。 在使用马甲包的时候一定要把握两个方向： ①、导量。不管是什么产品带来量才能带来效益，效益为先。 ②、抗风险。有些优化手段风险极高，但是带来的利益也是极大，所以制作马甲包就是为了抵抗风险，把利益留下。 开发时代码共用；打包（发包）时，通过加密之类的操作，尽量做到不一样。 iOS 马甲包：iOS 马甲包制作（Config 配置） 安卓马甲包：初识马甲包","tags":[]},{"title":" 结构体\t\t","date":"2019-02-02T03:57:31.000Z","path":"2019/02/02/e7-bb-93-e6-9e-84-e4-bd-93/","text":"一、初始化struct Node{ float value; char * name; node * next; }; 1、定义时赋值 struct Node node = {-10,3.141590，”method one”，0.25}；1需要注意对应的顺序，不能错位。 方法二：定义后逐个赋值struct InitMember test； test.first = -10;test.second = 3.141590;test.third = “method two”;test.four = 0.25;123456因为是逐个确定的赋值，无所谓顺序啦。 方法三：定义时乱序赋值（C风格）这种方法类似于第一种方法和第二种方法的结合体，既能初始化时赋值，也可以不考虑顺序； struct InitMember test = {.second = 3.141590,.third = “method three”,.first = -10,.four = 0.25};123456这种方法在Linux内核（kernel）中经常使用，在音视频编解码库FFmpeg中也大量频繁使用，还是很不错的一种方式。 方法四：定义时乱序赋值（C++风格）这种方法和前一种类似，网上称之为C++风格，类似于key-value键值对的方式，同样不考虑顺序。 struct InitMember test = {second：3.141590,third：”method three”,first：-10,four：0.25}; 二、学习文章C语言结构体初始化的四种方法","tags":[]},{"title":" 链表\t\t","date":"2019-02-02T03:37:25.000Z","path":"2019/02/02/e9-93-be-e8-a1-a8/","text":"一、介绍 链表是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。 链表相比于顺序表，在插入和删除元素时，效率要高很多。 每个数据单元叫做结点。由两部分组成： ①、数据域，存储数据值； ②、指针域，指向下一个数据单元。 当多个结点通过指针指向，关联起来，就形成了一个链，即链表。 链式存储结构的特点： ①、比顺序存储结构的存储密度小（链式存储结构中每个结点都由数据域与指针域两部分组成，相比顺序存储结构增加了存储空间）。 ②、逻辑上相邻的节点物理上不必相邻。 ③、插入、删除灵活（不必移动节点，只要改变节点中的指针）。 ④、查找节点时链式存储要比顺序存储慢。 ⑤、每个节点是由数据域和指针域组成。 ⑥、由于簇是随机分配的，这也使数据删除后覆盖几率降低，恢复可能提高。 二、单链表 单链表就是沿着单方向的链表。 A -&gt; B -&gt; C -&gt; D -&gt; … 按照顺序连下去，可以由 A 向后找其他元素，反之则不能。 /** * @brief 单链表结构。元素存放在动态分配的堆空间（非连续内存）。头结点索引为 -1，新增、删除的索引从 0 开始。 */typedef struct Node { int data; struct Node * next; int length; // 链表长度 } Node, Link; /// 初始化单链表void initLink(Link * link){ link-&gt;next = NULL; link-&gt;length = 0;} /// 空单链表bool isEmptyLink(Link * link){ return link-&gt;length == 0;} /// 插入void inputLink(Link * link, int data, int index){ if (index &lt; 0 || index &gt; link-&gt;length) return; // 新增结点 Node * node = (Node *)malloc(sizeof(Node)); node-&gt;data = data; // 上一个结点 Node * preNode = searchLink(link, index - 1); // 下一个结点 Node * nextNode = preNode-&gt;next; node-&gt;next = nextNode; preNode-&gt;next = node; link-&gt;length++; } /// 移除bool outputLink(Link link, int data, int index){ if (isEmptyLink(link) || index &lt; 0 || index &gt;= link-&gt;length) return NO; // 上一个结点 Node * preNode = searchLink(link, index - 1); // 当前结点 Node * curNode = preNode-&gt;next; if (data != NULL) *data = curNode-&gt;data; // 下一个结点 Node * nextNode = curNode-&gt;next; preNode-&gt;next = nextNode; link-&gt;length--; return YES; } /// 查找指定索引位置的结点Node searchLink(Link link, int index){ if (index &lt; 0) return link; // 返回头结点 Node * node = link-&gt;next; int i = 0; while (node &amp;&amp; node-&gt;next &amp;&amp; i &lt; index) { node = node-&gt;next; i++; } return node; } /// 打印单链表的内容void printLink(Link * link){ if (isEmptyLink(link)) return; Node * node = searchLink(link, 0); while (node) { printf(&quot;%d\\\\t&quot;, node-&gt;data); node = node-&gt;next; } printf(&quot;\\\\r\\\\n&quot;); } /// 调用{ int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int data = 0; Link link = { 0 }; for (int i = 0; i &lt; 9; i++) { inputLink(&amp;link, array\\[i\\], i); } printLink(&amp;link); inputLink(&amp;link, 0, 5); inputLink(&amp;link, 0, 7); printLink(&amp;link); outputLink(&amp;link, &amp;data, 4); outputLink(&amp;link, &amp;data, 10); // 索引为 10 移除的是第 11 个内容 printLink(&amp;link); } 1 2 3 4 5 6 7 8 91 2 3 4 5 0 6 0 7 8 91 2 3 4 0 6 0 7 8 9 三、双链表 双链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。 从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。 双链表结构： typedef struct Node { int data; int length; // 链表长度 struct Node * parent; struct Node * children; } Node, Link; 四、循环链表它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同。 五、约瑟夫环 设编号为 1、2、… n 的 n 个人围坐一圈，约定编号为 k（1 &lt;= k &lt;= n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 /// 约瑟夫环。k ∈[1, n] m &gt;= 1void josephusCircle(Link * link, int k, int m){ int index = k - 1; while (!isEmptyLink(link)) { int data = 0; index = (index + m - 1) % link-&gt;length; outputLink(link, &amp;data, index); printf(&quot;%d\\\\t&quot;, data); } } /// 调用{ int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; Link link = { 0 }; initLink(&amp;link); for (int i = 0; i &lt; 9; i++) { inputLink(&amp;link, array\\[i\\], i); } josephusCircle(&amp;link, 2, 1); } 2 3 4 5 6 7 8 9 1 josephusCircle(&amp;link, 2, 2);3 5 7 9 2 6 1 8 4 josephusCircle(&amp;link, 2, 3);4 7 1 5 9 6 3 8 2 josephusCircle(&amp;link, 9, 3);2 5 8 3 7 4 1 6 9 josephusCircle(&amp;link, 9, 9);8 9 2 5 3 4 1 6 7","tags":[]},{"title":" 寻找假币\t\t","date":"2019-01-31T09:30:56.000Z","path":"2019/01/31/e5-af-bb-e6-89-be-e5-81-87-e5-b8-81/","text":"1、问题描述 一个袋子里有若干硬币，其中一枚是假币，并且和假币和真币一模一样，目前只知道假币比真币轻一点。请问如何找到这枚假币？ 2、算法分析 根据分治的策略，将硬币平分为两份（奇数个硬币取出中间的硬币后再平分），比较两边的重量之和的大小。左侧重，则假币在右半段，反之，假币在左半段（或者中间的假币），然后继续在有假币的半区查找，直到剩余两个硬币，比较大小后，返回假币的位置。 时间复杂度：O(logn)。 3、代码实现 #include &lt;stdio.h&gt; #define MAXNUM 30 int FalseCoin(int coin[], int low, int high){ // 两个硬币的比较 if (low + 1 == high) { if (coin[low] &lt; coin[high]) { return low + 1; } return high + 1; } int sum1 = 0, sum2 = 0, sum3 = 0; int mid = (low + high) &gt;&gt; 1; int i; // 偶数个硬币 if ((high - low + 1) % 2 == 0 ) { // 左半段 for (i = low; i &lt;= mid; i++) { sum1 += coin\\[i\\]; } // 右半段 for (i = mid + 1; i &lt;= high; i++) { sum2 += coin\\[i\\]; } // 左侧重，则假币在右半段 if (sum1 &gt; sum2) { return FalseCoin(coin, mid + 1, high);; } // 右侧重，则假币在左半段 else if (sum2 &gt; sum1){ return FalseCoin(coin, low, mid);; } else { printf(&quot;没有假币。输入的硬币重量有误！&quot;); } } // 奇数个硬币 else { // 左半段，除去中间的一个硬币 for (i = low; i &lt;= mid - 1; i++) { sum1 += coin\\[i\\]; } // 右半段，除去中间的一个硬币 for (int i = mid + 1; i &lt;= high; i++) { sum2 += coin\\[i\\]; } sum3 = coin\\[mid\\]; // 左侧重，则假币在右半段 if (sum1 &gt; sum2) { return FalseCoin(coin, mid + 1, high); } // 右侧重，则假币在左半段 else if (sum2 &gt; sum1){ return FalseCoin(coin, low, mid - 1); } else { // 中间的是假币 if (coin\\[mid\\] != coin\\[low\\]) { return mid + 1; } else { printf(&quot;没有假币。输入的硬币重量有误！&quot;); } } } return -1; } int main(){ int coin[] = { 1, 1, 1, 0, 1, 1, 1, 1, 1, 1 }; int position = FalseCoin(coin, 0, 9); printf(&quot;假币在第 %d 个位置&quot;, position); return 0; } 假币在第 4 个位置","tags":[]},{"title":" 循环赛日程表\t\t","date":"2019-01-31T07:08:23.000Z","path":"2019/01/31/e5-be-aa-e7-8e-af-e8-b5-9b-e6-97-a5-e7-a8-8b-e8-a1-a8/","text":"学习文章：算法之循环赛日程表 1、问题描述 设有 n = 2k 个运动员要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表 ①、每个选手必须与其他 n-1 个选手各赛一场 ②、每个选手一天只能比赛一场 ③、循环赛一共进行 n-1 天 2、算法分析 按此要求可将比赛日程表设计成 n 行 n-1 列的表，在表中第 i 行和第 j 列处填入第 i 个选手在第 j 天所遇到的对手。 按分治策略，可以将所有的选手分为两半，则 n 个选手的比赛日程表可以通过 n/2 个选手的比赛日程表来决定。递归地用一分为二的策略对选手进行划分，直到只剩下两个选手时，比赛日程表的制定就变得很简单，这时只要让这两个选手进行比赛就可以了。 通过 k 增长来看算法实现步骤： ①、当 k = 1 时，n = 21 = 2 人，循环表为 **1 2** 2 1 ②、当 k = 2 时，n = 22 = 4 人，循环表为 1 2 3 4 2 1 4 3 3 4 1 2 4 3 2 1 ③、当 k = 3 时，n = 23 = 8 人，循环表为 1 2 3 4 5 6 7 8 2 1 4 3 6 5 8 7 3 4 1 2 7 8 5 6 4 3 2 1 8 7 6 5 5 6 7 8 1 2 3 4 6 5 8 7 2 1 4 3 7 8 5 6 3 4 1 2 8 7 6 5 4 3 2 1 以此类推，可以用分治的方法实现，现自顶向下分解，直到分解到最简单的情况，即人数为 2 人，这时就可以两两比赛，表的填充为对角填充的方式，然后再自底向上填充表格，具体的看上面的 k = 1、k = 2、k = 3 时形成的循环表就很好理解了。 3、代码 #include &lt;stdio.h&gt; #define N 64 void GameTable(int k, int a[][N]){ int n = 2; // 选手数 // 求解两个选手比赛日，得到左上角元素 a\\[0\\]\\[0\\] = 1; a\\[0\\]\\[1\\] = 2; a\\[1\\]\\[0\\] = 2; a\\[1\\]\\[1\\] = 1; int i, j, half; // 循环处理，依次处理 2^2 ... 2^k 个选手比赛日程 for (int t = 1; t &lt; k; t++) { half = n; // 当前选手数的 1 / 2 n *= 2; // 当前选手数 // 左下角 for (i = half; i &lt; n; i++) // 行 for (j = 0; j &lt; half; j++) // 列 a\\[i\\]\\[j\\] = a\\[i - half\\]\\[j\\] + half; // 右上角 for (i = 0; i &lt; half; i++) for (j = half; j &lt; n; j++) a\\[i\\]\\[j\\] = a\\[i + half\\]\\[j - half\\]; // 右下角 for (i = half; i &lt; n; i++) for (j = half; j &lt; n; j++) a\\[i\\]\\[j\\] = a\\[i - half\\]\\[j - half\\]; } printf(&quot;运动员编号\\\\t&quot;); for (i = 1; i &lt; n; i++) { printf(&quot;第 %d 天\\\\t&quot;, i); } printf(&quot;\\\\n\\\\n&quot;); for (i = 0; i &lt; n; i++) { printf(&quot; %d 号 \\\\t&quot;, i + 1); for (j = 1; j &lt; n; j++) printf(&quot; %d&quot;, a\\[i\\]\\[j\\]); printf(&quot;\\\\n&quot;); } } int main(){ int a[N][N] = { 0 }; int k = 3; printf(&quot;******************************************\\\\n&quot;); printf(&quot;\\\\t\\\\t**\\\\t\\\\t循环赛日程表\\\\t\\\\t**\\\\n&quot;); printf(&quot;******************************************\\\\n\\\\n&quot;); GameTable(k, a); return 0; } ****************************************** 循环赛日程表 ****************************************** 运动员编号 第 1 天 第 2 天 第 3 天 第 4 天 第 5 天 第 6 天 第 7 天 1 号 2 3 4 5 6 7 8 2 号 1 4 3 6 5 8 7 3 号 4 1 2 7 8 5 6 4 号 3 2 1 8 7 6 5 5 号 6 7 8 1 2 3 4 6 号 5 8 7 2 1 4 3 7 号 8 5 6 3 4 1 2 8 号 7 6 5 4 3 2 1","tags":[]},{"title":" n 次方\t\t","date":"2019-01-30T15:28:10.000Z","path":"2019/01/30/n-e6-ac-a1-e6-96-b9/","text":"文章：计算 n 次方–变治法 1、问题描述 计算 an 2、算法分析 先将 n 变一变，寻找新的计算路径。预处理就是变治法的根本。 如果单纯循环执行 n 次相乘，那么时间复杂度为 O(n)。可以利用二进制幂大大改进效率。 主要思路是：将十进制的 n 转换成二进制的数组序列 b[]。二进制幂求解有两种方法：从左至右二进制幂和从右至左二进制幂。 ①、从左至右二进制幂 变换：an = a^(b[n]2m + … + b[0]20) 先求 n 的二进制串，如：n = 5 =&gt; 1 0 1，那么 b[2] = 1, b[1] = 0, b[0] = 1 二进制求 n 的伪代码： Horner(b[0…n], x)k = b[n]for i = n-1 downto 0 do p = x*k + b[i]return p 那么 n 用作 a 的指数时意义是什么样的呢： ap = a1for i = n - 1 downto 0 do ap = a(2p+b[i]) ②、从右至左二进制幂 n 变换方法与上面相同，然后从 b[0] -&gt; b[n] 方向逐步求解。 时间复杂度：O(logn) 3、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; /** * @brief 返回 x 的二进制串（数组） */int GetBinArray(int x, int arr[], int length){ int idx = 0; while(x &gt; 0) { // 获取末位的二进制 arr\\[idx++\\] = (x &amp; 1) ? 1 : 0; if (idx == length) break; // 右移两位 x = x &gt;&gt; 1; } return idx; } /** * @brief a^n = a^（b[n]2^n + … + b[0]2^0）= a^（b[n]2^n） … a^b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_RightToLeft(int number, int power){ if (power == 0) return 1; int length = sizeof(int) * 8; // 32 int \\*pint = (int \\*)malloc(length); // 获取幂的二进制数组 length = GetBinArray(power, pint, length); int item = number; int ret = 1; for (int i = 0; i &lt; length; i++) { // 二进制值为 1，计入结果 if (pint\\[i\\] == 1) ret *= item; item *= item; } free(pint); return ret; } /** * @brief a^n = a^（b[n]2^n + … + b[0]2^0）=（（b[n]*2 + b[n-1]）*X + ….）2 + b[0]。 b 数组元素不是 1 就是 0 */int Pow_Bin_LeftToRight(int number, int power){ if (power == 0) return 1; int length = sizeof(int)*8; int \\*pint = (int \\*)malloc(length); length = GetBinArray(power, pint, length); int ret = number; for (int i = length - 1 - 1; i &gt;= 0; i--) { ret *= ret; if(pint\\[i\\] == 1) ret *= number; } free(pint); return ret; } int main(){ int num = 8, power = 6; int ret1 = Pow_Bin_RightToLeft(num, power); int ret2 = Pow_Bin_LeftToRight(num, power); printf(&quot;Pow\\_Bin\\_RightToLeft: %d^%d == %d\\\\n&quot;, num, power, ret1); printf(&quot;Pow\\_Bin\\_LeftToRight: %d^%d == %d\\\\n&quot;, num, power, ret2); return 0; } Pow_Bin_RightToLeft: 8^6 == 262144Pow_Bin_LeftToRight: 8^6 == 262144","tags":[]},{"title":" 汉诺塔\t\t","date":"2019-01-30T10:50:29.000Z","path":"2019/01/30/e6-b1-89-e8-af-ba-e5-a1-94/","text":"学习文章：汉诺塔 1、问题描述 在三根柱子之间一次只能移动一个圆盘，在小圆盘上不能放大圆盘。 2、算法思路 依据分治的策略，将问题化简为两个圆盘，三根柱子 A、B、C，首先解决倒数第二个圆盘的移动，将 n - 1（小盘） 从 A 移到 B，然后将 n（大盘） 从 A 移到 C，再将小盘从 B 移到 C。 子问题分别为：小盘和大盘的移动。 3、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define num 5 static int a[num] = { 1, 2, 3, 4, 5 }; // 1 - 最小的物品 5 - 最大的物品static int b[num] = { 0 }; // 0 - 为空static int c[num] = { 0 }; // 0 - 为空static int idxA = 0; // 当前有物品的下标static int idxB = num;static int idxC = num; /// 定义 move 函数，移动物品void move(char from, char to){ int x = 0; printf(&quot;%c -&gt; %c\\\\n&quot;, from, to); // 移出 if (from == &apos;A&apos; &amp;&amp; idxA &gt; -1 &amp;&amp; idxA &lt; num) { x = a\\[idxA\\]; a\\[idxA\\] = 0; idxA++; } else if (from == &apos;B&apos; &amp;&amp; idxB &gt; -1 &amp;&amp; idxB &lt; num) { x = b\\[idxB\\]; b\\[idxB\\] = 0; idxB++; } else if (from == &apos;C&apos; &amp;&amp; idxC &gt; -1 &amp;&amp; idxC &lt; num) { x = c\\[idxC\\]; c\\[idxC\\] = 0; idxC++; } else { printf(&quot;%c from 数组越界！&quot;, from); return; } // 存入 if (to == &apos;A&apos; &amp;&amp; --idxA &gt; -1 &amp;&amp; idxA &lt; num) { a\\[idxA\\] = x; } else if (to == &apos;B&apos; &amp;&amp; --idxB &gt; -1 &amp;&amp; idxB &lt; num) { b\\[idxB\\] = x; } else if (to == &apos;C&apos; &amp;&amp; --idxC &gt; -1 &amp;&amp; idxC &lt; num){ c\\[idxC\\] = x; } else { printf(&quot;%c to 数组越界！&quot;, to); return; } // 打印移动后结果 for (int i = 0; i &lt; num; i++) { printf(&quot;%d %d %d\\\\n&quot;, a\\[i\\], b\\[i\\], c\\[i\\]); } printf(&quot;\\\\n&quot;); } /// 将 n 个物品从 one 座借助 two 座，移到 three 座void hanoi(int n, char one, char two, char three){ if(n == 1) { move(one, three); // 只有一个物品，直接移动 } else { hanoi(n-1, one, three, two); //首先把 n - 1 个从 one 移动到 two move(one, three); // 然后把最后一个 n 从 one 移动到 three hanoi(n-1, two, one, three); // 最后再把 n - 1 个从 two 移动到 three }} int main(){ hanoi(num, ‘A’, ‘B’, ‘C’); return 0; } A -&gt; C0 0 02 0 03 0 04 0 05 0 1 A -&gt; B0 0 00 0 03 0 04 0 05 2 1 C -&gt; B0 0 00 0 03 0 04 1 05 2 0 A -&gt; C0 0 00 0 00 0 04 1 05 2 3 B -&gt; A0 0 00 0 01 0 04 0 05 2 3 B -&gt; C0 0 00 0 01 0 04 0 25 0 3 A -&gt; C0 0 00 0 00 0 14 0 25 0 3 A -&gt; B0 0 00 0 00 0 10 0 25 4 3 C -&gt; B0 0 00 0 00 0 00 1 25 4 3 C -&gt; A0 0 00 0 00 0 02 1 05 4 3 B -&gt; A0 0 00 0 01 0 02 0 05 4 3 C -&gt; B0 0 00 0 01 0 02 3 05 4 0 A -&gt; C0 0 00 0 00 0 02 3 05 4 1 A -&gt; B0 0 00 0 00 2 00 3 05 4 1 C -&gt; B0 0 00 1 00 2 00 3 05 4 0 A -&gt; C0 0 00 1 00 2 00 3 00 4 5 B -&gt; A0 0 00 0 00 2 00 3 01 4 5 B -&gt; C0 0 00 0 00 0 00 3 21 4 5 A -&gt; C0 0 00 0 00 0 10 3 20 4 5 B -&gt; A0 0 00 0 00 0 10 0 23 4 5 C -&gt; B0 0 00 0 00 0 00 1 23 4 5 C -&gt; A0 0 00 0 00 0 02 1 03 4 5 B -&gt; A0 0 00 0 01 0 02 0 03 4 5 B -&gt; C0 0 00 0 01 0 02 0 43 0 5 A -&gt; C0 0 00 0 00 0 12 0 43 0 5 A -&gt; B0 0 00 0 00 0 10 0 43 2 5 C -&gt; B0 0 00 0 00 0 00 1 43 2 5 A -&gt; C0 0 00 0 00 0 30 1 40 2 5 B -&gt; A0 0 00 0 00 0 30 0 41 2 5 B -&gt; C0 0 00 0 20 0 30 0 41 0 5 A -&gt; C0 0 10 0 20 0 30 0 40 0 5","tags":[]},{"title":" 大整数相乘\t\t","date":"2019-01-30T09:29:18.000Z","path":"2019/01/30/e5-a4-a7-e6-95-b4-e6-95-b0-e7-9b-b8-e4-b9-98/","text":"学习文章：分治算法详解、分治法的经典问题——大整数相乘 1、问题描述 计算两个很大整数的结果，例如：27392361983108271361039746313 * 37261038163103818366341087632113 2、算法分析 先用一个简单的例子，如 234 * 456 = ？？？来考虑。在这里考虑将 456 拆分为 4、5、6，然后分别去乘以 234。 234 x 456 -------------------- 1404 1170 936 -------------------- 106704 这就是熟悉的竖式计算乘法的结构，看着每一步计算出来的结果，一层一层的，是否看起来像二维数组？我们就用二维数组来保存结果，数组的第一行保留 1404，第二行保留 11700，第三行保留 93600。由于不能直接存储，需要对存放的位置做一下计算：数组该有多少行，该有多少列？ 在这里我们需要知道，3 位 3 位，结果最多为 6 位数；2 位 6 位，结果最多为 2 + 6 = 8 位，所以这里数组该有 6 列，而对于行数，则由被乘数决定，所以这里为 3 行。 temp[3][6] = { 0 0 1 4 0 4 0 1 1 7 0 0 0 9 3 6 0 0 } 每列依次往下加 1 0 6 7 0 4; 所得刚好为我们要的答案。 3、代码实现 时间复杂度 O(n2) #include &lt;stdio.h&gt; #define num1 11 #define num2 6 void MultiOfLargeNumbers(int a1[], int a2[]){ int temp[num2][num1 + num2] = { 0 }; // 注意：二维数组列数的规律 int x, y; // x - 行数，y - 列数 uint isCarry = 0; // 进位值 // 打印二维数组 for (int i = 0; i &lt; num2; i++) { // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(&quot;%d &quot;, temp\\[i\\]\\[j\\]); printf(&quot;\\\\n&quot;); } printf(&quot;\\\\n&quot;); for(int idx2 = num2 - 1; idx2 &gt;= 0; idx2--) { // 乘数 x = num2 - idx2 - 1; y = num1 + idx2; for(int idx1 = num1 - 1; idx1 &gt;= 0; idx1--, y--) { // 被乘数 // 加上进位数值 temp\\[x\\]\\[y\\] = a1\\[idx1\\] * a2\\[idx2\\] + isCarry; isCarry = 0; // 当前计算结果需要进位，计算进位数值和结果数值 if(temp\\[x\\]\\[y\\] &gt;= 10) { isCarry = temp\\[x\\]\\[y\\] / 10; temp\\[x\\]\\[y\\] %= 10; } } if(isCarry) { // 首位有进位 temp\\[x\\]\\[y\\] += isCarry; isCarry = 0; } } // 合并 int temp_sum\\[num1 + num2\\] = {0}; // 将每一列的数组到最后的结果数组里面 for(int j = num2 + num1 - 1; j &gt;= 0; j--) { // 列 for(int i = num2 - 1; i &gt;= 0; i--) { // 行 temp_sum\\[j\\] += temp\\[i\\]\\[j\\]; } if (isCarry) { temp_sum\\[j\\] += isCarry; isCarry = 0; } if( temp_sum\\[j\\] &gt;= 10) { isCarry = temp_sum\\[j\\] / 10; temp_sum\\[j\\] %= 10; } } // 打印二维数组 for (int i = 0; i &lt; num2; i++) { // 行 for (int j = 0; j &lt; num1 + num2; j++) // 列 printf(&quot;%d &quot;, temp\\[i\\]\\[j\\]); printf(&quot;\\\\n&quot;); } printf(&quot;\\\\n&quot;); // 打印相乘结果 for(int i = 0; i &lt; num2 + num1; i++) printf(&quot;%d&quot;, temp_sum\\[i\\]); } int main(){ //int a1[num1] = { 2, 3, 4 }; //int a2[num2] = { 4, 5, 6 }; // 2739236198310827136103974、37261038163103818366 int a1\\[num1\\] = { 2, 7, 3, 9, 2, 3, 6, 1, 9, 8, 3 }; int a2\\[num2\\] = { 3, 7, 2, 6, 1, 0 }; MultiOfLargeNumbers(a1, a2); return 0; } 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 00 0 0 0 0 2 7 3 9 2 3 6 1 9 8 3 00 0 0 1 6 4 3 5 4 1 7 1 8 9 8 0 00 0 0 5 4 7 8 4 7 2 3 9 6 6 0 0 00 1 9 1 7 4 6 5 3 3 8 8 1 0 0 0 00 8 2 1 7 7 0 8 5 9 4 9 0 0 0 0 0 10206667998485630 4、分治法 首先将 X 分为 A、B 和 Y 分成 C、D。注意：这里的 X、Y 假设位数相同。 此时将 X 和 Y 的乘积转化，把问题转化为求解式子的值。 分析一下：对这个式子，一共要进行 4 次 n/2 的乘法（AC 2 次， AD、BC 各 1 次）和 3 次加法，因而该算法的时间复杂度为 T(n) = 4 * T(n/2) + θ(n) 通过 master 定理可以求得 T(n) = θ(n2)，跟小学算法的时间复杂度没有区别。 但是我们再来看看，我们是否可以用加法来换取乘法？因为多一个加法操作，也是常数项，对时间复杂度没有影响，如果减少一个乘法则不同。 时间复杂度为： T(n) = 3 * T(n/2) + θ(n)，通过 master 定理求得 T(n) = O(nlog23) = O(n1.59)。","tags":[]},{"title":" 求第 k 小/大元素\t\t","date":"2019-01-30T05:31:51.000Z","path":"2019/01/30/e6-b1-82-e7-ac-ac-k-e5-b0-8f-e5-a4-a7-e5-85-83-e7-b4-a0/","text":"#include&lt;bits/stdc++.h&gt;using namespace std;void swap_t(int a[],int i,int j){ int t=a[i]; a[i]=a[j]; a[j]=t;}int par(int a[],int p,int q)//p是轴,轴前面是比a[p]小的，后面是比a[p]大的{ int i=p,x=a[p]; for(int j=p+1;j&lt;=q;j++) { if(a[j]&gt;=x) { i++; swap_t(a,i,j); } } swap_t(a,p,i); return i;//返回轴位置}int Random(int p,int q)//返回p，q之间的随机数{ return rand()%(q-p+1)+p;}int Randomizedpar(int a[],int p,int q){ int i=Random(p,q); swap_t(a,p,i);//第一个和第i个交换，相当于有了一个随机基准元素 return par(a,p,q);}int RandomizedSelect(int a[],int p,int r,int k){ if(p==r) return a[p]; int i=Randomizedpar(a,p,r); int j=i-p+1; printf(“i=%d j=%d\\n”,i,j); if(k&lt;=j) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j);}int main(){ int n; scanf(“%d”,&amp;n); int a[n]; for(int i=0;i&lt;n;i++) { scanf(“%d”,&amp;a[i]); } int x=RandomizedSelect(a,0,n-1,2); printf(“%d\\n”,x);}","tags":[]},{"title":" 棋盘覆盖\t\t","date":"2019-01-30T02:53:47.000Z","path":"2019/01/30/e6-a3-8b-e7-9b-98-e8-a6-86-e7-9b-96/","text":"原文：棋盘覆盖问题、分治法之棋盘覆盖问题 问题：在一个 2k * 2k（k ≥ 0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格，显然，特殊方格在棋盘中出现的位置有 4k 种情形，因而有 4k 种不同的棋盘。 思路：用分治策略。 ①、当 k &gt; 0 时，将 2k * 2k 棋盘分割成 4 个 2k-1 * 2k-1 子棋盘，特殊方格必定只位于某个子棋盘中。 ②、用一个 L 型骨牌覆盖 3 个无特殊方格子棋盘的结合处，由原问题转化成 4 个较小规模的棋盘覆盖子问题。 步骤： 代码： #include &lt;stdio.h&gt; #define max 1024 int board[max][max]; // 最大棋盘static int tile = 0; // 覆盖标志位 /** * （tr，tc） 棋盘左上角的方格坐标 * （dr，dc） 特殊方格所在的坐标 * size 是棋盘的行数和列数 */void ChessBoard(int tr,int tc,int dr,int dc,int size){ if(size == 1) return; // 递归到棋盘大小为 1 时，则结束递归 int t = tile++; // L型骨牌号 int s = size / 2; // 分割棋盘，使得新得到的棋盘为原来棋盘大小的四分之一 // ①、左上角子棋盘 // 如果特殊方格在左上角，就对这个棋盘左上角的四分之一重新进行棋盘覆盖 if(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) { // 特殊方格在此棋盘中 ChessBoard(tr, tc, dr, dc, s); } // 因为特殊方格不在左上角，所以要在左上角构造一个特殊方格 else { // 用 t 号 L 型骨牌覆盖右下角 board\\[tr + s - 1\\]\\[ tc + s - 1\\] = t; // 在构造完特殊方格之后，棋盘的左上角的四分之一又有了特殊方格，所以就对左上角棋盘的四分之一进行棋盘覆盖，直到棋盘大小为 1 * 1 ChessBoard(tr, tc, tr+s-1, tc+s-1, s); } // ②、右上角子棋盘 if(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) { ChessBoard(tr, tc+s, dr, dc, s); } else { board\\[tr + s - 1\\]\\[tc + s\\] = t; ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); } // ③、左下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) { ChessBoard(tr + s, tc, dr, dc, s); } else { // 用 t 号 L 型骨牌覆盖右上角 board\\[tr + s\\]\\[tc + s - 1\\] = t; ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); } // ④、右下角子棋盘 if(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) { ChessBoard(tr + s, tc + s, dr, dc, s); } else { // 用 t 号 L 型骨牌覆盖左上角 board\\[tr + s\\]\\[tc + s\\] = t; ChessBoard(tr + s, tc + s, tr + s, tc + s, s); } } int main(){ int size = 8, dr = 0, dc = 0; printf(&quot;不可覆盖点的值为 -1！\\\\n\\\\n&quot;); board\\[dr\\]\\[dc\\] = -1; ChessBoard(0, 0, dr, dc, size); for(int m = 0; m &lt; size; m++) { printf(&quot;%2d&quot;, board\\[m\\]\\[0\\]); for(int n = 1; n &lt; size; n++) { printf(&quot; %2d&quot;, board\\[m\\]\\[n\\]); } printf(&quot;\\\\n&quot;); } return 0; } 不可覆盖点的值为 -1！ -1 2 3 3 7 7 8 8 2 2 1 3 7 6 6 8 4 1 1 5 9 9 6 10 4 4 5 5 0 9 10 1012 12 13 0 0 17 18 1812 11 13 13 17 17 16 1814 11 11 15 19 16 16 2014 14 15 15 19 19 20 20","tags":[]},{"title":" 算法设计策略\t\t","date":"2019-01-29T15:43:52.000Z","path":"2019/01/29/e7-ae-97-e6-b3-95-e8-ae-be-e8-ae-a1-e7-ad-96-e7-95-a5/","text":"一、分治将一个难以直接解决的大问题，分割成 n 个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后各个击破，分而治之。 分治法常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，这和递归算法的思路一致。 根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜？每个子问题是否规模相同或怎样才为适当？这些问题很难给出肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取 k = 2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，它几乎总是比使子问题规模不等的做法好。 文章：分治算法详解 二、动态规划将原问题分解成若干个子问题。与分治法不同的是，其分解出的子问题往往不是相互独立的。这种情况下若用分治法会对一些子问题进行多次求解，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。 动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质： 1、最优子结构性质 当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。 要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的，然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。 2、子问题重叠性质 子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。 用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。然后有如下两种程序设计方法： ①、自底向上递归法 利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。 ②、自顶向下递归法（即备忘录法） 利用问题的最优子结构性质，用与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格，以备以后查看。否则则说明该问题已被求解过，直接返回表格中相应的值即可，不必重新计算。 当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采用自顶向下递归法。 文章：动态规划：从新手到专家 三、贪心当一个问题具有最优子结构性质时，可用动态规划法求解。但有时会有比动态规划更简单更直接效率更高的算法：贪心法。 贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑，它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。 贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质： 1、贪心选择性质 贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择，即贪心选择来达到。 对于一个具体问题，要确定它是否具有贪心选择性质，通常可考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到，即具有贪心选择性质。 2、最优子结构性质 这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。 贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各子问题，而贪心法通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做出一次贪心选择就将所求问题简化为规模更小的子问题。 四、回溯回溯法是对问题的解空间树进行深度优先搜索 ，但是在对每个节点进行 DFS 之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含，则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含，则进入该子树，进行 DFS。 回溯法通常的解题步骤如下： ①、定义问题的解空间。 (2)、将解空间组织成便于进行 DFS 的结构，通常采用树或图的形式。 (3)、对解空间进行 DFS，并在搜索过程中用剪枝函数避免无效搜索。 用回溯法解题时并不需要显式地存储整个解空间，而是在 DFS 过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为 h，则回溯法的空间复杂度通常为 O(h) 用回溯法解题时，常会遇到以下两类典型的解空间树： (1)、当所给的问题是从 n 个元素的集合 S 中找出 S 满足某种性质的子集时，相应的解空间树称为子集树，例如 0-1背包问题 (2)、当所给的问题是找出 n 个元素满足某种性质的排列时，相应的解空间树称为排列树，例如 回溯法解旅行推销员问题 回溯法中的剪枝函数通常分为两类： (1)、用约束函数在指定节点处剪去不满足约束的子树，例如 0-1背包问题 (2)、用限界函数在指定节点处剪去得不到最优解的子树，例如回溯法解旅行推销员问题 五、分支限界回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，而分支限界法则是对解空间进行优先级优先搜索。 分支限界法的搜索策略是，在当前节点处，先生成其所有的子节点（分支），并为每个满足约束条件的子节点计算一个函数值(限界)，再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定) 作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。 六、学习文章姚来飞的博客常见的算法设计策略","tags":[]},{"title":" 快速排序\t\t","date":"2019-01-29T15:33:22.000Z","path":"2019/01/29/e5-bf-ab-e9-80-9f-e6-8e-92-e5-ba-8f/","text":"一、简介快速排序 Quick Sort，有时又称划分-交换排序（Partition-Exchange Sort）。 快速排序的主要思想是：选取一个数字，通过一次遍历，将这个数字放到其最终的位置，并且保证其最终位置的左侧都小于等于这个数字，其右侧都大于等于这个数字。 与归并排序相同，是“分治法”的又一个实现案例。快速排序中分治的思想体现在哪里呢？ ①、把大问题分解成很多子问题（分区操作可以每次使得一位元素有序） ②、解决子问题（进行分区操作，每次使得一位元素有序） ③、所有子问题解决了，那么最大的问题也解决了。 一个优秀的快速排序实现，能比其竞争对手（归并排序、堆排序，都是时间复杂度为 O(nlog2n) 的排序算法），快 2-3 倍。 From Wikipedia: https://en.wikipedia.org/wiki/Quicksort 二、快速排序的具体步骤快速排序的过程可以拆分成以下三个步骤： 从数组中选择一个数字。 根据这个数字，对整个数组进行一次划分，即：通过一系列的交换，将这个数字放到其最终位置，并且保证其左侧的数字都小于等于它，右侧的数字都大于等于它。 对两侧的子数组进行递归。 三、快速排序的基本代码int partition(int array[], int left, int right){ // …} void sort(int array[], int left, int right){ if (left &lt; right) { int q = partition(array, left, right); sort(array, left, q - 1); sort(array, q + 1, right); }} 4、划分 - 挖坑取数快速排序的核心内容：如何对一个数组进行一次划分（partition）。 这里先介绍一种常见的划分算法，我（原作者）称之为“挖坑取数”，具体过程如下： 将最左侧的数字作为待划分的数字，在快速排序中，称这个数字是划分的主元（pivot）。 从最右侧开始向前寻找，找到第一个比 pivot 小的数字（坑），交换 pivot。 此时“坑”的位置被交换到了最左侧，从最左侧的下一个位置开始向后寻找，找到第一个比 pivot 大的数字，交换 pivot。 循环从两侧“夹逼”找“坑”的步骤，直至 pivot 到它的最终位置。 int partition(int array[], int left, int right){ int pivot = array[left]; int i = left; int j = right + 1; bool forward = NO; while(i &lt; j) { while(forward &amp;&amp; array\\[++i\\] &lt;= pivot &amp;&amp; i &lt; j); while(!forward &amp;&amp; array\\[--j\\] &gt;= pivot &amp;&amp; i &lt; j); // 交换 i、j 的内容 swap(array, i, j); forward = !forward; } return j; } void swap(int arr[], int one, int two){ int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp;} 其中在“夹逼”过程中的最后一个判断 i &lt; j，是为了防止在夹逼的过程中出现左侧小于右侧的情况。 退出循环后 i = j，所以最后一次交换也不会影响结果。 五、划分 - 挖坑取数 - 演示步骤如果上面的说明过于抽象，这里演示一遍“挖坑取数”在数组 {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 3。 从最右侧 7 开始，向前寻找，找到第一个小于等于 3 的数字：2，交换两者位置，得到数组： {2, 5, 1, 9, 8, 6, 0, 3, 4, 7} 。 从最左侧的下一个数字 5 开始，向后寻找，找到第一个大于等于 3 的数字：5，交换两者位置，得到数组： {2, 3, 1, 9, 8, 6, 0, 5, 4, 7} 。 从最右侧的上一个数字 0 开始，向前寻找，找到第一个小于等于 3 的数字：0，交换两者位置，得到数组： {2, 0, 1, 9, 8, 6, 3, 5, 4, 7} 。 从最左侧的下一个数字 1 开始，向后寻找，找到第一个大于等于 3 的数字：9，交换两者位置，得到数组： {2, 0, 1, 3, 8, 6, 9, 5, 4, 7} 。 从最右侧的上一个数字 6 开始，向前寻找，找到第一个小于等于 3 的数字，没有找到，得到最终数组：{2, 0, 1, 3, 8, 6, 9, 5, 4, 7}。 此时，pivot = 3 的左侧数字全部小于等于 3，右侧数字全部大于等于 3，划分完成。 六、划分 - 快慢指针这里介绍另外一种划分算法，我（原作者）称之为“快慢指针”，具体过程如下： 将最右侧的数字作为主元。 使用两个指针 faster 和 slower，faster 初始指向第一个数字，slower 初始时指向 faster 上一个数字。 从第一个数字开始遍历数组，快指针随着数组遍历的过程增大。 遍历数组时，每当数字小于等于 pivot 时，慢指针前进一位，然后交换快慢指针的位置，即慢指针指向的数字，永远小于等于 pivot。 当遍历结束时，0-慢指针的最终位置，都保证小于等于 pivot。快指针的最终位置，为 pivot 的前一位。 慢指针向前移动一位（指向的数字保证大于等于 pivot，只有指向 pivot 时，等号成立），交换 pivot 与此时慢指针的位置。 int partition(int array[], int left, int right){ int pivot = array[right]; // 慢指针指向小于 pivot 的值的位置 int slower = left - 1; for (int faster = left; faster &lt; right; ++faster) { if(array\\[faster\\] &lt;= pivot) { // 因为发现一个小于 pivot 的值，慢指针向右移一位，用于交换 slower++; swap(array, slower, faster); } } // 最终，慢指针右侧即为 pivot 的位置 swap(array, slower + 1, right); return slower + 1; } 七、划分 - 快慢指针 - 演示步骤同样地，演示一遍“快慢指针”在数组 A = {3, 5, 1, 9, 8, 6, 0, 2, 4, 7} 的执行步骤： 取 pivot = 7，快指针初始位置指向 3，faster = 0，慢指针初始位置在快指针的前一个位置，slower = -1。 第一个数，3 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 0，faster = 1。 第二个数，5 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 1，faster = 2。 第三个数，1 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 3。 第四个数，9 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 4。 第五个数，8 &gt; 7，慢指针位置不动 -&gt;保持原来的位置不变 -&gt;快指针前进一位，得到数组：{3, 5, 1, 9, 8, 6, 0, 2, 4, 7}，slower = 2，faster = 5。 第六个数，6 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 8, 9, 0, 2, 4, 7}，slower = 3，faster = 6。 第七个数，0 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 9, 8, 2, 4, 7}，slower = 4，faster = 7。 第八个数，2 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 8, 9, 4, 7}，slower = 5，faster = 8。 第九个数，4 ≤ 7，慢指针前进一位 -&gt;交换快慢指针的位置 -&gt;快指针前进一位，得到数组：{3, 5, 1, 6, 0, 2, 4, 9, 8, 7}，slower = 6，faster = 9。 此时，快指针 faster = 9，不满足小于 right = 9 的条件，退出循环，将主元 pivot = 7，与慢指针的后一个数字 A[7] = 9，做一次交换，得到最终数组：{3, 5, 1, 6, 0, 2, 4, 7, 8, 9}，划分完成。 八、快速排序的时间复杂度和稳定性 最坏情况时间复杂度 T(n) = O(n^2)。 最好情况时间复杂度 T(n) = O(nlog2n)。 平均情况时间复杂度 T(n) = O(nlog2n)。 最坏情况空间复杂度 T(n) = O(n)。 最好情况空间复杂度 T(n) = O(log2n)。 快速排序，始终只使用原来的数组空间 O(1)，真正消耗的空间，是由递归的深度决定的。 无论哪一种快速排序排序的划分算法，都会打破快速排序的稳定性。 九、代码#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define n 5int a[n];int temp;static int count = 0; void swap_t(int a[], int i, int j){ temp = a[i]; a[i] = a[j]; a[j] = temp; count++;} int par(int a[], int left, int right){ int i = left; int x = a[left]; // 基准元素 for(int j = left + 1; j &lt;= right; j++) { if(a\\[j\\] &lt;= x) { // 比 x 小的换到左侧 i++; swap_t(a, i, j); } } swap_t(a, left, i); return i; // 轴位置 } void QuickSort(int a[],int left, int right){ if(left &lt; right) { int r = par(a, left, right); QuickSort(a, left, r - 1); QuickSort(a, r + 1, right); }} int main(){ int i = 0; for(;i &lt; n; i++) { a[i] = arc4random() % 100 + 1; printf(“%d “, a[i]); } printf(“\\n”); QuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) { printf(&quot;%d &quot;, a\\[i\\]); } printf(&quot;\\\\n&quot;); printf(&quot;交换了 %d 次&quot;, count); return 0; } 87 71 39 75 6139 61 71 75 87交换了 8 次 随机选择元素： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define n 5int a[n];int temp; void swap_t(int a[], int i, int j){ temp = a[i]; a[i] = a[j]; a[j] = temp;} int par(int a[], int left, int right){ int i = left; int x = a[left]; for(int j = left + 1; j &lt;= right; j++) { if(a\\[j\\] &lt;= x) { i++; swap_t(a, i, j); } } swap_t(a, left, i); return i; } /// 生成随机的基准元素下标int Random(int left, int right){ return arc4random() % (right - left + 1) + left;} // 用随机的基准元素进行快速排序int Randomizedpar(int a[], int left, int right){ int i = Random(left, right); swap_t(a, left, i); // 第一个和第 i 个交换，相当于有了一个随机基准元素 return par(a, left, right); } void RandomizedQuickSort(int a[], int left, int right){ if(left &lt; right) { int r = Randomizedpar(a, left, right); printf(&quot;%d到%d之间的随机数：%d\\\\n&quot;, left, right, r); RandomizedQuickSort(a, left, r - 1); RandomizedQuickSort(a, r + 1, right); } } int main(){ int i = 0; for(; i&lt; n; i++) { a\\[i\\] = arc4random() % 100 + 1; printf(&quot;%2d &quot;, a\\[i\\]); } printf(&quot;\\\\n&quot;); RandomizedQuickSort(a, 0, n-1); for(i = 0; i &lt; n; i++) { printf(&quot;%2d &quot;, a\\[i\\]); } printf(&quot;\\\\n&quot;); return 0; } 十、快速排序的性能瓶颈与优化策略详情见：排序算法杂谈（五）关于快速排序的优化策略分析 十一、学习文章Gerrard_Feng 排序算法（七）快速排序 快速排序算法分析和实现","tags":[]},{"title":" 归并排序\t\t","date":"2019-01-29T15:09:54.000Z","path":"2019/01/29/e5-bd-92-e5-b9-b6-e6-8e-92-e5-ba-8f/","text":"归并排序 Merge Sort，又称为二路归并排序，是指将一个数组一分为二，对每一个子数组递归排序，最后将排好的子数组合并为一个有序数组的过程。 归并排序，是 “分治法” 应用的完美实现。 From Wikipedia: https://en.wikipedia.org/wiki/Merge_sort 一、图示 二、流程通过图示可以发现归并排序一共只需要两个步骤： 分：将原数组分为 n 个子数组，每个子数组长度为 1。 合：依次将两个相邻的有序数组，合并成一个有序数组，重复操作直至剩下一个有序数组。 三、代码实现1、分成两个子数组，左右递归 - (void)sort:(NSMutableArray *)arr left:(NSInteger)left right:(NSInteger)right{ if (left &lt; right) { NSInteger mid = (left + right) &gt;&gt; 1; // ÷ 2 \\[self sort:arr left:left right:mid\\]; \\[self sort:arr left:(mid + 1) right:right\\]; // 将分开的两部分子数组合并 \\[self merge:arr left:left mid:mid right:right\\]; } } 2、合并两个有序数组，此时处理新数组的排序 /** * @brief 合并 */- (void)merge:(NSMutableArray )arr left:(NSInteger)left mid:(NSInteger)mid right:(NSInteger)right{ // 注意新数组的长度 NSMutableArray newArr = [NSMutableArray arrayWithCapacity:right - left + 1]; NSInteger startIndex1 = left; NSInteger startIndex2 = mid + 1; for (int i = 0; i &lt; right - left + 1; ++i) { // 左侧数组检索完毕 if (startIndex1 == mid + 1) { newArr\\[i\\] = arr\\[startIndex2++\\]; } // 右侧数组检索完毕 else if (startIndex2 == right + 1) { newArr\\[i\\] = arr\\[startIndex1++\\]; } else { // 使用两个指针记录数组位置，依次比较指针位置的数字，将较小的数字放入新数组。这样可以在线性的时间内完成合并工作。 newArr\\[i\\] = \\[arr\\[startIndex1\\] integerValue\\] &lt; \\[arr\\[startIndex2\\] integerValue\\] ? arr\\[startIndex1++\\] : arr\\[startIndex2++\\]; } } \\[arr replaceObjectsInRange:NSMakeRange(left, newArr.count) withObjectsFromArray:newArr\\]; } 3、相似的完整代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define max 1024 int SR[max], TR[max];/** * @param SR 两个有序序列构成的序列 * @param TR 一个空数组，用来存放排序好之后的数字 * @param left 起始位置 * @param mid 两个序列的分解位置 * @param right 结束位置 */int merge(int SR[], int TR[], int left, int mid, int right){ int i = left, j = mid + 1, k = left; // k 是 TR 当前存入数字的下标 while(i &lt;= mid &amp;&amp; j &lt;= right) { if(SR\\[i\\] &lt; SR\\[j\\]) { TR\\[k++\\] = SR\\[i++\\]; } else { TR\\[k++\\] = SR\\[j++\\]; } } while(i &lt;= mid) { TR\\[k++\\] = SR\\[i++\\]; // 当前面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 } while(j &lt;= right) { TR\\[k++\\] = SR\\[j++\\]; // 当后面一个序列有剩余的时候，直接把剩余数字放在 TR 的后面 } return 0; } void copy(int SR[], int TR[], int s, int t){ for(int i = s; i &lt;= t; i++) { SR[i] = TR[i]; // TR -》 SR，相当于 TR 所在的区间有序 }} int mergesort2(int SR[], int left, int right){ if(left &lt; right) { int mid = (left + right) &gt;&gt; 1; mergesort2(SR, left, mid); // 前一半序列继续进行归并排序 mergesort2(SR, mid+1, right); // 后一半序列同时进行归并排序 // 以上递归调用的结束条件是 left ≥ right，也就是分到只有一个数字进行归并排序的时候，一个序列只有一个数字，那么这个序列肯定是有序的 // 以上都是属于“分”的阶段，目的是获得两个有序的数列。 merge(SR, TR, left, mid, right); // 对这两个有序的数列，进行排序，变成一个同样大小但是有序的数列 copy(SR, TR, left, right); //将在TR中排序好的数列给SR，方便SR递归调用归并排序，因为每次两个归并排序的结果都是保存在TR中的，现在要进行下一步就必须在TR数列的基础上面=进行，所以我们把TR给SR } else { ; } return 0; } int main(){ int n = 10; int i = 0; for(; i &lt; n; i++) { SR\\[i\\] = arc4random() % 100 + 1; printf(&quot;%d &quot;, SR\\[i\\]); } printf(&quot;\\\\n&quot;); mergesort2(SR, 0, n-1); // 升序排列 for(i = 0; i &lt; n; i++) { printf(&quot;%d &quot;,SR\\[i\\]); } printf(&quot;\\\\n&quot;); return 0; } 四、时间复杂度和空间复杂度显而易见，递归的次数为 m = log2n，合并操作的时间消耗是线性的，所以时间复杂度 T(n) 如下： 空间复杂度为 O(n)。 五、空间复杂度为 O(1) 的归并排序因为两个子数组已经有序，合并的步骤可以采取直接插入排序。 如此一来，可以将空间复杂度由 O(n) 降低至 O(1)，然而相对的时间复杂度则由 O(nlog2n) 升至 O(n^2)。 六、性能分析及优化两种归并排序的算法，分别是采取了空间换时间，以及时间换空间的策略，性能各有优劣，但是通过分析可以得出以下特点： 计算机对于频繁开辟小数组空间的消耗，比开辟等价大的单个数组空间，代价要来的更大。 使用直接插入排序（从 1/2 处开始），由于拥有较小的最高次幂系数，其性能在长度 n 较小的时候，与 T(n) = O(log2n) 相差不大。 根据以上两个性质，可以在归并排序中，设置一个阈值。超过这个给定的阈值，则采取空间换时间的策略；反之，采用时间换空间的策略，从而提高归并排序的效率。 七、学习文章Gerrard_Feng 排序算法（六）归并排序","tags":[]},{"title":" 堆排序\t\t","date":"2019-01-29T15:00:36.000Z","path":"2019/01/29/e5-a0-86-e6-8e-92-e5-ba-8f/","text":"堆排序 Heap Sort，是指将整个数组转化成 “堆” 这种数据结构，利用堆的性质，去简化排序的过程。堆排序，可以看做是“变治法”的一种实现。 From Wikipedia：https://en.wikipedia.org/wiki/Heapsort 一、堆堆是一个可以被看做一棵树的数组对象，但是堆总是需要满足以下两条性质： ①、堆是一棵完全二叉树。树的每一层都是满的，除了最后一层最右边的元素有可能出现缺位。②、父母优势。即堆中的所有子节点，总是不大于或不小于其父节点的值。 根据子节点与父节点的关系，可以将堆分为最大堆（大的值在上）和最小堆（小的值在上）两种情况。 二、堆的数组表现形式数组 [9, 7, 3, 5, 1, 2, 6, 0, 8, 4] 按照顺序逐层放置可以转化为以下二叉树结构。（目前不具备堆的性质） 三、堆的性质1、获取堆中某个节点的左节点、右节点、父节点 - (int)leftNode:(int)node{ return (node &lt;&lt; 1) + 1; // 0 &lt;&lt; 1 = 0} - (int)rightNode:(int)node{ return (node &lt;&lt; 1) + 2;} - (int)parentNode:(int)node{ return (node - 1) &gt;&gt; 1;} ①、把完全二叉树每层的节点个数看成二进制 1、2、4、8… ②、当前节点在层 n（从 0 开始）的位置为 m（从 0 开始），那么节点在数组的位置为 index = 2 ^ (n - 1) + 2 ^ (n - 2) + … + 2 ^ 0 + m 左边子节点就是 2 ^ n + 2 (n - 1) + … + 2 ^ 0 + m 2 + 1 = index 2 + 1右边子节点就是 2 ^ n + 2 (n - 1) + … + 2 ^ 0 + m 2 + 2 = index 2 + 2 2、保持最大堆/最小堆的性质 当二叉树中的某个子节点，其左子树和右子树都具备堆的性质，那么可以通过一系列的交换，将以该子节点为根节点的树，转化为堆的结构。 /** * @param array 待排序数组 * @param node 当前节点 * @param lastNode 最后一个节点 */- (void)maxHeapSort:(NSMutableArray *)array node:(int)node lastNode:(int)lastNode{ int lNode = [self leftNode:node]; // 左子节点 int rNode = [self rightNode:node]; // 右子节点 int largestNode = node; // 最大值节点。初始为当前节点 // 如果左子节点没有超出范围 &amp;&amp; 左子节点数值比 largestNode 的大 if (lNode &lt;= lastNode &amp;&amp; \\[array\\[lNode\\] integerValue\\] &gt; \\[array\\[largestNode\\] integerValue\\]) { largestNode = lNode; } // 如果右子节点没有超出范围 &amp;&amp; 右子节点数值比 largestNode 的大 if (rNode &lt;= lastNode &amp;&amp; \\[array\\[rNode\\] integerValue\\] &gt; \\[array\\[largestNode\\] integerValue\\]) { largestNode = rNode; } // 如果当前节点不是最大值，发生交换 if (node != largestNode) { \\[array exchangeObjectAtIndex:node withObjectAtIndex:largestNode\\]; \\[self maxHeapSort:array node:largestNode lastNode:lastNode\\]; } } 3、构造最大堆/最小堆 将一个不具备堆性质的数组，转化为堆的结构，一般都是自底向上开始的。 自二叉树的第一个非叶节点开始，自底向上，依次保持二叉树的堆的性质，直至根节点。 NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; for (int i = lastNonLeaf; i &gt; -1; –i) { [self maxHeapSort:arr node:i lastNode:arr.count - 1];} 四、堆排序①、将原数组转化为堆的形式。升序排列使用最大堆，降序排列使用最小堆。 ②、将数组最后一位与第一位交换，因为是最大堆的关系，第一位数字就是最大值，落在了最后一位上。 ③、剔除最后一位数字，将数组剩余部分，看作一颗新的二叉树。其中根节点的左子树和右子树都满足最大堆的性质，保持这棵新二叉树的最大堆性质。这里是通过自顶向下的方式直到最后一个叶子节点调整二叉树。 ④、循环 ②、③，直至根节点，整个数组即自然有序。 NSMutableArray * arr = [NSMutableArray arrayWithObjects:@9, @7, @3, @5, @1, @2, @6, @0, @8, @4, nil];int lastNonLeaf = (int)(arr.count - 2) &gt;&gt; 1; // 从第一个非叶子节点开始构造，即最后一个叶子节点的父节点。 // 数组 -&gt; 堆 -> 最大堆for (int i = lastNonLeaf; i &gt; -1; –i) { [self maxHeapSort:arr node:i lastNode:(int)arr.count - 1];} // 最大堆 -> 第一个与最后一个交换for (int i = (int)arr.count - 1; i &gt; 0; –i) { [arr exchangeObjectAtIndex:i withObjectAtIndex:0]; [self maxHeapSort:arr node:0 lastNode:i - 1];} 五、变治法代码#include &lt;stdio.h&gt; #define num 10 int temp; void Description(int *a){ for(int i = 0; i &lt; num; i++) { printf(“%d “, a[i]); } printf(“\\n”);} /** * @brief 筛选算法。用于维护堆，保持最大堆的性质 * @param a 数组 * @param k 调整的结点 * @param n 堆的大小 /void MaxHeapify(int a, int k, int n){ int i = k, j; j = 2 * i + 1; // 置 i 为要筛的结点，j 为 i 的左孩子 while(j &lt; n) { // j + 1 &lt; n 用于判断 i 是否有右孩子。a\\[j\\] &lt; a\\[j+1\\] 用于比较左右孩子的大小 if (j + 1 &lt; n &amp;&amp; a\\[j\\] &lt; a\\[j+1\\]) j++; if(a\\[i\\] &gt; a\\[j\\]) { // i 节点大于左右孩子中的最大者 break; } else { temp = a\\[i\\]; a\\[i\\] = a\\[j\\]; a\\[j\\] = temp; i = j; j = 2 * i + 1; } } } void HeapSort(int *a){ int i; // 每建立一次堆，只能确定根节点是最大值，其他节点并没有按序排好，所以后面有重复建堆的过程，但是需要建堆的区间慢慢变少了 for(i = (num - 1)/2; i &gt;= 0; i--) { MaxHeapify(a, i, num); // 初始建堆，其中一开始 i 表示的是最后一个元素的父节点 Description(a); } printf(&quot;\\\\n&quot;); // 重复执行移走堆项及重建堆的操作 for (i = 1; i &lt; num; i++) { // i 表示当前堆的大小，即等待排序的元素的个数 temp = a\\[0\\]; a\\[0\\] = a\\[num - i\\]; a\\[num - i\\] = temp; MaxHeapify(a, 0, num - i); //从根节点处继续调整建堆，0 ... n-i 是无序区 Description(a); } } int main(){ int a[num] = {0, 1, 3, 5, 7, 9, 8, 6, 4, 2}; HeapSort(a); Description(a); return 0; } 0 1 3 5 7 9 8 6 4 20 1 3 6 7 9 8 5 4 20 1 9 6 7 3 8 5 4 20 7 9 6 2 3 8 5 4 19 7 8 6 2 3 0 5 4 1 8 7 3 6 2 1 0 5 4 97 6 3 5 2 1 0 4 8 96 5 3 4 2 1 0 7 8 95 4 3 0 2 1 6 7 8 94 2 3 0 1 5 6 7 8 93 2 1 0 4 5 6 7 8 92 0 1 3 4 5 6 7 8 91 0 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 9 六、堆排序的时间复杂度堆排序由两部分组成： 构建最大堆 循环保持最大堆的性质 1、构建最大堆的时间复杂度 T = O(n) 构建最大堆的过程，是从第一个非叶节点开始的，即数组的 1/2 处。 考虑最坏情况： 二叉树的倒数第二行，总会与最后一行发生一次比较/交换。 二叉树的倒数第三行，总会与倒数第二行发生一次比较/交换，与最后一行发生一次比较/交换。 … 二叉树的第一行，总会与它下面的每一行都发生一次比较/交换，即交换次数为二叉树高度 d = log2n。 将这些比较/交换次数累加： 2、循环保持最大堆的性质的时间复杂度 T = O(n * log2n) 这一步的时间计算就相对比较明显了，在 n 次循环的内部，进行时间复杂度为 O(log2n) 的 maxHeapSort()。 所以总时间复杂度 T = O(n) + O(nlog2n) =O(nlog2n) 七、学习文章Gerrard_Feng 排序算法（五）堆排序 使用减治法求解堆排序 堆排序原理及算法实现（最大堆）","tags":[]},{"title":" 希尔排序\t\t","date":"2019-01-29T14:27:16.000Z","path":"2019/01/29/e5-b8-8c-e5-b0-94-e6-8e-92-e5-ba-8f/","text":"一、和直接插入排序的关系希尔排序 Shell sort 是直接插入排序的变种方式之一，更高效的改进版本。其基本思想如下： ①、记录按下标的一定增量分组，对每组进行直接插入排序。 ②、不断地缩小增量，对每组进行直接插入排序，直至增量为 1。 数组：a[33, 13, 44, 21, 88, 8, 17] 1、增量 d = 3 分组 [33, 21, 17]、[13, 88]、[44, 8] 排序结果：[17, 13, 8, 21, 88, 44, 33] 2、增量 d = 3/2 = 1 分组 [17, 13, 8, 21, 88, 44, 33] 排序结果：[8, 13, 17, 21, 33, 44, 88] 由上可知，希尔排序本质就是多次使用直接插入排序。其优于直接插入排序的原因在之前也提到过，就是：直接插入排序对于基本有序的数组，拥有较高的性能。 希尔排序的时间复杂度是 O(n^2)（只是针对最坏情况而言，平均的效率要远远高出其他时间复杂度为 O(n^2) 的排序算法），空间复杂度是 O(1)。 希尔排序在提供优秀性能的同时，打破了排序算法的稳定性。 二、希尔排序的实现希尔排序，又称为缩小增量排序，其重点显然在于初始增量 d 的选取，以及每次增量 d 缩小的额度。一般来说，初始增量设为数组长度的一半，同时每次增量减半，直至 d = 1，可以满足大多数的需求。 三、优化1、设置哨兵位优化各分组的直接插入排序 2、二分查找法优化各分组的直接插入排序 四、简单的性能比较 结论： 直接插入排序的优化手段，对希尔排序没有作用，反而是一种伤害。原因是直接插入排序的优化手段对于小规模的数组是有害的，而希尔排序的原理是将整个数组拆成若干个小数组，利用直接插入排序对基本有序的数组拥有良好的性能这一特性出发的。 同样是不稳定排序，对比直接插入排序的二分查找优化，无论数组规模的大小，希尔排序在性能上都有明显的优势。 五、学习文章Gerrard_Feng 排序算法(四) 希尔排序","tags":[]},{"title":" 整数划分\t\t","date":"2019-01-29T09:48:54.000Z","path":"2019/01/29/e6-95-b4-e6-95-b0-e5-88-92-e5-88-86/","text":"问题：将一个正整数 n 写成如下形式 n = m1 + m2 + … + mi; （其中 mi 为正整数，并且 1 &lt;= mi &lt;= n），则 {m1, m2, …, mi} 为 n 的一个划分。 如果 { m1, m2, …, mi }中的最大值不超过 m，即 max(m1, m2, …, mi) &lt;= m，则称它属于 n 的一个 m 划分。 思路：这里记 n 的 m 划分的个数为 f(n, m); 例如当 n = 4 时，有 5 个划分 {4}, {3,1}, {2,2}, {2,1,1},{1,1,1,1}; 该问题是求出 n 的所有划分个数，即 f(n, n)。下面考虑求 f(n,m) 的方法。 ①、m = 1 || n = 1 只有一种划分情况，即 n 个 1 相加， 所以 f(n, m) = 1; ②、m = n &gt; 1 f(n, m) = f(n, n-1) + 1 加上的 1 代表 n + 0 = n 这个划分方案 ③、n &lt; m f(n, m) = f(n, n) 逻辑上不存在 m &gt; n 的情况 ④、n &gt; m f(n, m) = f(n, m-1) + f(n-m, m); f(n, m-1) 表示划分方案中没有 m 的情况，f(n-m, m) 表示划分方案中有 m 的情况 #include &lt;stdio.h&gt; /** * @brief 整数划分问题，将一个整数划分为若干个数相加。例：整数 4，最大加数 4 4 =4 + 0 1+3=4 1+1+2=4 2+2=4 1+1+1+1=4 注意：1+3=4，3+1=4被认为是同一种划分方案 * @param n 需要划分的数字 * @param m 最大的加数 */int algorithm(int n, int m){ if (n == 1 || m == 1) { // 只要存在一个为 1，那么划分的方法数肯定只有一种，那就是 n 个 1 相加 return 1; } else if (n == m &amp;&amp; n &gt; 1) { // 等价于：q(n, n-1) + 1; 最后面 +1 代表的是：0+n，这个划分的方案 return algorithm(n, m - 1) + 1; } else if (n &lt; m) { // 如果 m &gt; n,那么令 m = n，因为最大加数在逻辑上不可能超过 n return algorithm(n, n); } else if (n &gt; m) { // 分为两种：划分方案没有 m 的情况 + 划分方案有 m 的情况 return algorithm(n, m - 1) + algorithm(n - m, m); } return 0; } int main(){ int r = algorithm(7, 7); printf(“%d\\n”, r); return 0; }","tags":[]},{"title":" 二分查找\t\t","date":"2019-01-29T07:12:11.000Z","path":"2019/01/29/e4-ba-8c-e5-88-86-e6-9f-a5-e6-89-be/","text":"1、问题描述 在一个有序（升序）数组查找一个数 x 2、算法分析 暴力的做法就是拿 x 跟数组里面每个数比较一下，然后返回找到的 x 的下标。这里明显可以使用分治的思想：可以把数组分成很多部分，在每个部分里面查找 x。如果所有部分都没有找到 x，那么把这些子问题合并起来后，表示整个数组里没有 x。 这很好的反应了分治的思想，先分解成很多小问题，解决这些小问题，把解决的小问题合并起来，大问题就解决了。 3、代码实现 递归： #include &lt;stdio.h&gt; #include &lt;string.h&gt; /** * @param a 需要二分的升序数组 * @param x 需要查找的数字 * @param low 低位 * @param high 高位 */int binarysearch(int a[], int x, int low, int high){ if(low &gt; high) { return -1; // 没有找到 } int mid = (low + high) &gt;&gt; 1; if(x == a\\[mid\\]) { return mid; // 找到 x } else if(x &gt; a\\[mid\\]) { return binarysearch(a, x, mid + 1, high); // 在后半部分继续二分查找 } else { return binarysearch(a, x, low, mid - 1); // 在前半部分继续二分查找 } } int main(){ int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int idx = binarysearch(a, 2, 0, 9); if(idx == -1) { printf(&quot;未查到！\\\\n&quot;); } else { printf(&quot;查到了！数组下标 = %d\\\\n&quot;, idx); } return 0; } 非递归： #include &lt;stdio.h&gt; int BinarySearch(int a[], int n, int key){ if (n == 0) return -1; int left = 0, mid, right = n - 1; while (left &lt;= right) { mid = (left + right) &gt;&gt; 1; if (a\\[mid\\] &lt; key) { left = mid + 1; } else if (a\\[mid\\] &gt; key) { right = mid - 1; } else { return mid; } } return -1; } int main(){ int a[] = { 1, 3, 5, 8, 22, 45, 65, 78, 79, 102 }; printf(&quot;%d&quot;, BinarySearch(a, 10, 65)); return 0; }","tags":[]},{"title":" 构造子集\t\t","date":"2019-01-24T06:51:04.000Z","path":"2019/01/24/e6-9e-84-e9-80-a0-e5-ad-90-e9-9b-86/","text":"问题：构造出 0~n-1 的所有子集。 思路：一次选出一个元素放入集合。 代码： #define ARRAY_LENGTH 10 { int A[ARRAY_LENGTH]; print_subset(ARRAY_LENGTH, A, 0);} void print_subset(int n, int* A, int cur){ // cur:当前位置 printf(“cur = %d “, cur); // 确定当前元素的最小可能值 int s = cur ? A\\[cur-1\\] + 1 : 0; printf(&quot;s = %d &quot;, s); // 打印当前子集元素。 for(int i = 0; i &lt; cur; i++) { printf(&quot;%d &quot;, A\\[i\\]); } // 每次选出一个元素当子集的首元素, for(int i = s; i &lt; n; i++) { A\\[cur\\] = i; // 打印加入元素后的数组 printf(&quot; after：&quot;); for(int j = 0; j &lt;= cur; j++) { printf(&quot;%d &quot;, A\\[j\\]); } printf(&quot;\\\\n&quot;); print_subset(n, A, cur + 1); // 递归构造子集 } } cur = 0 s = 0 after：0cur = 1 s = 1 0 after：0 1cur = 2 s = 2 0 1 after：0 1 2cur = 3 s = 3 0 1 2 after：0 1 2 3cur = 4 s = 4 0 1 2 3 after：0 1 3cur = 3 s = 4 0 1 3 after：0 2cur = 2 s = 3 0 2 after：0 2 3cur = 3 s = 4 0 2 3 after：0 3cur = 2 s = 4 0 3 after：1cur = 1 s = 2 1 after：1 2cur = 2 s = 3 1 2 after：1 2 3cur = 3 s = 4 1 2 3 after：1 3cur = 2 s = 4 1 3 after：2cur = 1 s = 3 2 after：2 3cur = 2 s = 4 2 3 after：3cur = 1 s = 4 3","tags":[]},{"title":" 分治、减治、变治\t\t","date":"2019-01-24T02:33:06.000Z","path":"2019/01/24/e5-88-86-e6-b2-bb-e3-80-81-e5-87-8f-e6-b2-bb-e3-80-81-e5-8f-98-e6-b2-bb/","text":"一、分治法1、基本思想 分而治之：将原始问题分解为若干个规模较小的相同的子问题，在逐个解决各个子问题的基础上，得到原始问题的解。 能用分治法的基本特征： ①、问题缩小到一定规模容易解决 ②、分解成的子问题是相同种类的子问题，即该问题具有最优子结构性质（递归思想） ③、分解而成的小问题在解决之后要可以合并 ④、子问题是相互独立的，即子问题之间没有公共的子问题 第 ③ 条是能分治的关键。解决子问题之后如果不能合并从而解决大问题的话，那么凉凉，如果满足一、二，不满足三，即具有最优子结构的话，可以考虑贪心或者 dp。 如果不满足第 ④ 条的话，也可以用分治。但是在分治的过程中，有大量的重复子问题被多次的计算，拖慢了算法效率，这样的问题可以考虑 dp（大量重复子问题）。 2、分治步骤 ①、分解成很多子问题 ②、解决这些子问题 ③、将解决的子问题合并从而解决整个大问题 化成一颗问题树的话，最底下的就是很多小问题，最上面的就是要解决的大问题，自底向上的方式求解问题。 它的一般的算法设计模式如下： Divide-and-Conquer(P) if |P|≤n0 then return(ADHOC(P)) 将 P 分解为较小的子问题 P1, P2, …, Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) △ 递归解决 Pi T ← MERGE(y1,y2,…,yk) △ 合并子问题 return(T) 3、分类 根据如何由分解出的子问题得出原始问题的解，分治策略可分为两种情形： 原始问题的解只存在于分解出的某一个（或某几个）子问题中，则只需要在这一（或这几个）子问题中求解即可； 原始问题的解需要由各个子问题的解再经过综合处理得到。 4、效果 适当运用分治策略往往可以较快地缩小问题求解的范围，从而加快问题求解的速度。子问题最好规模相同；然后对子问题求解；最后合并这些子问题的解，得到原始问题的解。 分治策略运用于计算机算法时，往往会出现分解出来的子问题与原始问题类型相同的现象；而与原始问题相比，各个子问题的尺寸变小了。这刚好符合递归的特性。 因此，计算机算法中的分治策略往往与递归联系在一起。 5、算法的典型应用 ①、MAXMIN问题 ②、二分搜索 ③、归并排序 ④、寻找第 K 小的元素 ⑤、大整数的乘法 ⑥、Strassen 矩阵乘法 ⑦、快速排序 ⑧、二叉树遍历 ⑨、棋盘覆盖 ⑩、线性时间选择 最接近点对问题 循环赛日程表 汉诺塔。。。 6、依据分治法设计程序时的思维过程 实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。 ①、一定是先找到最小问题规模时的求解方法；②、然后考虑随着问题规模增大时的求解方法；③、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。 二、减治1、基本思想 减治技术利用了一种关系：一个问题给定实例的解和同样问题较小实例的解之间的关系。（利用解之间的关系，也就是说可以减少相应的计算，也可以说是一种时空平衡） 有了这种关系，我们可以自顶向下地递归求解，也可以自底向上地迭代实现，从较小实例开始求解这一角度来看减治也叫增量法。 一旦建立了这样一种关系，既可以递归地，也可以非递归地地来运用减治技术。 2、分类 减治法有 3 种主要的变种： 减去一个常量 减去一个常数因子 减去的规模是可变的 3、减去一个常量 每次算法迭代总是从实例规模中减去一个规模相同的常量。一般来说，这个常量为 1。 函数 f(n) = an 可以用一递归定义来计算 f(n) = f(n-1) * a 如果 n &gt; 1 f(n) = a 如果 n = 1 虽然时间复杂度和蛮力法一致，但是体现的思想却不一样！ 4、减去常量因子 每次算法迭代总是从实例的规模中减去一个相同的常数因子。在的多数应用中，这样的常数因子为 2。 计算 an 的值是规模为 n 的实例，规模减半（常数因子等于 2）的实例计算就是 an/2 的值；它们之间有着明显的关系： an = (an/2)2。 an = (an/2)2 n 是正偶数 an = (a(n-1)/2)2 * a n 是大于 1 的奇数，先提出一个 a 来再减半 an = a n = 1 上式递归根据所做的乘法次数来度量效率，该算法属于 O(log n); 因为每次迭代的时候，以不超过两次乘法为代价，问题的规模至少会减小一半。 5、减可变规模 每次算法迭代时，规模减小的模式都是不同的。例如：欧几里德算法 6、算法思想的典型应用 减去一个常量： ①、插入排序 ③、深度优先查找 ④、广度优先查找 ⑤、拓扑排序（源删除法对无环有向图进行拓扑排序） ⑥、生成排列 ⑦、生成子集 减去常量因子： ①、折半查找 ②、假币问题 ③、俄式乘法 ④、约瑟夫斯问题 减可变规模 ①、插值查找、二叉查找树 ②、欧几里得算法，随着不断求余，n 越来越小 三、分治减治区别分治法：求解多个子问题（每个子问题都需要求解），合并子问题的解。 减治法：求解一个子问题（子问题只需要求解一次），扩展子问题的解。 求 an。 分治法：a(n/2) * a(n/2) 则左右两个 a(n/2) 均需要求解，所以时间复杂度为 O(n)。减治法：(a(n/2))2 则只需要求 a(n/2) 再平方即可，所以时间复杂度为 O(lgn)。 也就是说分治法是分解的部分需要进行分开的单独计算（需要计算两遍），而减治法则利用了“一个问题给定实例的解和同样问题较小实例的解之间的关系”从而减少了计算量。 四、变治基于变换的方法，首先把问题的实例变得容易求解，然后进行求解。根据对问题实例的变换方式，变治思想有 3 种主要类型： 变换为同样问题的一个更简单或者更方便的实例：实例化简； 变换为同样实例的不同表现：改变表现； 变换为另一个问题的实例， 这种问题的算法是已知的：问题化简。 基于这种思想的算法也有很多，如：预排序（把无序变为有序，然后处理）。 1、实例化简 ①、检验数组中元素的唯一性（预排序） ②、模式计算（预排序） ③、AVL 树 2、改变表现 ①、2-3 树、2-3-4 树（二叉排序树） ②、堆和堆排序（利用最大/小堆总是找到最大/小值） ③、霍纳法则（多项式的计算） ④、高斯消去法（把方程组经过初等变换，得到具有特殊性质的方程组） 3、问题化简 ①、背包问题（线性规划）","tags":[]},{"title":" 选择排序\t\t","date":"2019-01-23T13:43:35.000Z","path":"2019/01/23/e9-80-89-e6-8b-a9-e6-8e-92-e5-ba-8f/","text":"一、简介选择排序是蛮力法的一种实际应用。 首先扫描整个数组，找到最小的元素，然后和第一个元素进行交换，如此一来就等同于将最小的元素放到它在有序表中最终的位置上。然后从第二个元素开始扫描整个表，找到剩余 n-1 个元素中最小的元素，与第二个元素交换位置。以此类推，在执行 n-1 遍之后，这个数组就自然有序了。（当然每次找最大的元素，与最后一个元素交换也是可行的） 选择排序有一个最明显的优于冒泡排序的：数据交换的次数。在完全逆序的情况下，冒泡排序需要最多的 n*(n-1)/2 次交换，而选择排序最多产生 n-1 次交换。 选择排序的时间复杂度是 O(n^2)，空间复杂度是 O(1)。 选择排序有一个很重要的特性——它是一种不稳定排序。假定一个数组：[5, 5, 6, 1, 8]，可以很清晰的发现，在选择排序结束之后，两个 5 并不能保持原来的顺序，第一个 5 在第四的位置，第二个 5 还在第二的位置。 二、改进每一次外循环的遍历，可以同时找到最小值（minIndex）和最大值（maxIndex），分别和头、尾两个元素进行交换。这样一来外循环只要执行原来一半的循环次数就可以了。 但是需要注意一点：每次循环要进行 2 次交换，第一次最小值交换结束之后，在进行最大值交换的时候要先判断最大值是不是在第一个位置，在第一次最小值交换的时候已经换到了后面。 如 [5, 4, 3, 2, 1] 第一次最小值交换后变成了 [1, 4, 3, 2, 5]，初始记录的 maxIndex = 0 就指向了 1，而不是 5。 三、代码#define ARRAY_LENGTH 10 void selectSort(int arr[]){ // 数组内容合法性判断 int minIndex; int maxIndex; // 方式 ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) { minIndex = i; for (int j = i; j &lt; ARRAY_LENGTH; j++) { if (arr\\[j\\] &lt; arr\\[minIndex\\]) { minIndex = j; } } // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) { swap(i, minIndex, arr); } } // 方式 ② for (int i = 0; i &lt; ARRAY_LENGTH / 2; i++) { minIndex = i; maxIndex = i; for (int j = i; j &lt; ARRAY_LENGTH - i; j++) { if (arr\\[j\\] &lt; arr\\[minIndex\\]) { minIndex = j; } if (arr\\[j\\] &gt; arr\\[maxIndex\\]) { maxIndex = j; } } // 判断第一个是不是最小值，是的话可以不用交换 if (i != minIndex) { swap(i, minIndex, arr); } if (ARRAY_LENGTH - 1 - i != maxIndex) { // 防止最大数在第一个，优先和最小数进行交换 swap(ARRAY_LENGTH - 1 - i, (i == maxIndex) ? minIndex : maxIndex, arr); } } for (int i = 0; i &lt; ARRAY_LENGTH; i++) { printf(&quot;%d &quot;, arr\\[i\\]); } } void swap(int idx1, int idx2, int arr[]) { int temp = arr[idx1]; arr[idx1] = array[idx2]; arr[idx2] = temp;} 四、学习文章 Gerrard_Feng 排序算法(二) 选择排序 [常见排序算法导读(3)\\[简单选择排序\\]](https://www.cnblogs.com/idorax/p/6537412.html)","tags":[]},{"title":" 冒泡排序\t\t","date":"2019-01-23T12:24:34.000Z","path":"2019/01/23/e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f/","text":"一、简介冒泡排序是蛮力法在排序问题上的一个典型的应用场景。 对于一个给定长度为 n 的无序数组，由初始位置开始，比较数组相邻两个元素。如果是逆序排列的，就交换它们的位置，重复多次之后，最大数就“沉”到了数组最后的位置。第二次再从初始位置开始，将第二大的元素沉到倒数第二个位置。这样一直做 n-1 次，整个数组就是有序的了。 对于一个长度为 n 的数组，整个算法消耗的时间为：(n-1) + (n-2) + … + 1 = n(n-1)/2，那么它的时间复杂度为 O(n^2)。同时，显而易见，整个算法只消耗一份数组的空间，所以空间复杂度为 O(1)。 另外，普及一下排序算法另一个重要的特性：稳定性。 所谓的稳定性，通俗地讲就是能保证两个相等的数在排序前后的顺序相同。 假定原数组有两个相同的元素 Ω，在数组的 a[i] 和 a[j] 位置。排序前 a[i] 在 a[j] 的前面，在排序之后，a[i] 仍然在 a[j] 的前面，那么就说这种排序方法具有稳定性。 冒泡排序是一种稳定排序。 蛮力法的应用有一个显著的特点，就是在经过适当的努力之后，可以对算法进行一定的改良，从而提高它的性能，但并不会减弱算法本身的时间复杂度。冒泡排序作为蛮力法的典型应用，自然也有这种特性。 二、改进 设定交换发生的标识位 对于待排序的数组，可以设定一个标志位，检查一次比较之后，是否有数据进行了交换，若是没有，那么整个数组就已经有序了，可以直接退出。极端情况下，如刚才提到的，对有序数组进行排序，只需要执行 n-1 次操作，就可以完成排序。 记录最后一次发生交换的位置 初始排序时，数组是在 [0, n] 区间遍历，那么下一轮的遍历是在 [0, n-1] 区间。 现在记录数组本轮遍历的最后一次交换发生在 lastSwapPos 位置，那么下一轮的遍历实际上是在 [0, lastSwapPos] 区间。 三、代码#define ARRAY_LENGTH 10 void bubbleSort(int arr[]){ int lastSwapPos = ARRAY_LENGTH - 1; int lastSwapPosTemp = ARRAY_LENGTH - 1; int temp = 0; // ① for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) { for (int j = 0; j &lt; ARRAY_LENGTH - i - 1; j++) { if (arr\\[j\\] &gt; arr\\[j+1\\]) { temp = arr\\[j\\]; arr\\[j\\] = arr\\[j+1\\]; arr\\[j+1\\] = temp; } } } // ② for (int i = 0; i &lt; ARRAY_LENGTH - 1; i++) { lastSwapPos = lastSwapPosTemp; for (int j = 0; j &lt; lastSwapPos; j++) { if (arr\\[j\\] &gt; arr\\[j+1\\]) { temp = arr\\[j\\]; arr\\[j\\] = arr\\[j+1\\]; arr\\[j+1\\] = temp; lastSwapPosTemp = j; } } // 一次都未交换的情况 if (lastSwapPos == lastSwapPosTemp) { break; } } for (int i = 0; i &lt; ARRAY_LENGTH; i++) { printf(&quot;%d &quot;, arr\\[i\\]); } } 四、总结优点： 空间复杂度 T = O(1) 稳定排序 在排序过程中，整个数组趋向稳定 对于已经有序的数组，排序效率高 缺点： 效率低 交换次数多，交换效率低（每次交换只减少一组逆序对） 不能并发执行 四、学习文章 Gerrard_Feng 排序算法(一) 冒泡排序","tags":[]},{"title":" LC 1\t\t","date":"2019-01-23T12:13:40.000Z","path":"2019/01/23/leetcode-lc1/","text":"交换两个数字思路：当 a 变成原来 b 的值时，需要 b 中含有原来 a 的部分。a = a + b, b = a - b - (void)swapAB:(int)a b:(int)b{ a = a + b; b = a - 2 b; // a - b a = (a - b) / 2; // (a - a + 2 b)/2 b = a + b;} 一、Two Sum（两数之和）1、问题描述 给定一个整数数组 nums 和一个目标值 target，在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例：nums = [2, 7, 11, 15], target = 9 因为nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2、算法分析 ①、直接遍历两遍数组，外层循环 nums[i]，内层循环找 nums 数组中是否存在 k = target - nums[i] 这个数字，找到就返回两个数字的索引组成的数组，这个方法时间复杂度为 O(n²)。 ②、用哈希表先把数组中的数字和对应的下标存储一遍，即数字作为键，下标作为值，存储。当前值为 nums[i]，当遍历数组时计算 k = target - nums[i]，然后在 map 中找是否存在 k，找到即返回 k 所对应的 value，也就是所对应的数组下标。这样时间复杂度就为 O(n)，空间复杂度 O(n)。 3、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int twoSum(int nums, int numsSize, int target){ int min = nums[0]; int i = 0; // 不能用 while (!num++)，会导致指针位置不对 for (i = 0; i &lt; numsSize; i++) if (min &gt; nums\\[i\\]) min = nums\\[i\\]; int max = target - min; // 允许的最大值 int length = max - min + 1; int* result = (int *)malloc(sizeof(int) * 2); // 存储索引值 int* hashTable = (int *)malloc(sizeof(int) * length); // 下标 = 值 内容 = 索引 for (i = 0; i &lt; length; i++) { hashTable\\[i\\] = -1; // hash 初始化 } for (i = 0; i &lt; numsSize; i++) { // 当前的值不大于最大值 if (nums\\[i\\] &lt;= max) { if (hashTable\\[target - min - nums\\[i\\]\\] != -1) { result\\[0\\] = hashTable\\[target - min - nums\\[i\\]\\]; result\\[1\\] = i; return result; } hashTable\\[nums\\[i\\] - min\\] = i; } } free(hashTable); return result; } int main(){ int nums[] = { 2, 3, 7, 11, 15 }; int * p = twoSum(nums, 5, 10); for (int i = 0; i &lt; 2; i++) { printf(&quot;%d &quot;, p\\[i\\]); } return 0; } 4、学习文章 LeetCode1两数之和 Leet_code—1两数之和—C语言版 LintCode/LeetCode–两数和、三数和、四数和 二、Add Two Numbers（两数相加）1、问题描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储 一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 示例：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) -》(7 -&gt; 0 -&gt; 8) 原因：342 + 465 = 807 2、算法分析 简单的链表操作，同时移位两个链表。 3、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; struct ListNode { int val; struct ListNode *next;}; struct ListNode addTwoNumbers(struct ListNode l1, struct ListNode* l2) { int carry = 0; int value1 = 0; int value2 = 0; struct ListNode * result = (struct ListNode *)malloc(sizeof(struct ListNode)); struct ListNode * temp = result; while (l1 || l2 || carry &gt; 0) { // 获取第一个链表的内容 if (l1) { value1 = l1-&gt;val; l1 = l1-&gt;next; } else { value1 = 0; } // 获取第 2 个链表的内容 if (l2) { value2 = l2-&gt;val; l2 = l2-&gt;next; } else { value2 = 0; } int sum = value1 + value2 + carry; struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode)); node-&gt;next = NULL; if (sum &gt; 9) { node-&gt;val = sum - 10; carry = 1; } else { node-&gt;val = sum; carry = 0; } temp-&gt;next = node; temp = node; } return result-&gt;next; } int main(){ // (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) struct ListNode a = (struct ListNode )malloc(sizeof(struct ListNode)); a-&gt;next = NULL; struct ListNode * b = (struct ListNode *)malloc(sizeof(struct ListNode)); b-&gt;next = NULL; struct ListNode * temp = a; int arr1\\[\\] = {5}; int arr2\\[\\] = {5}; int size1 = sizeof(arr1) / sizeof(int); int size2 = sizeof(arr2) / sizeof(int); // 初始化链表 1 for (int i = 0; i &lt; size1; i++) { struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode)); node-&gt;val = arr1\\[i\\]; node-&gt;next = NULL; temp-&gt;next = node; temp = node; } temp = b; // 初始化链表 2 for (int i = 0; i &lt; size2; i++) { struct ListNode * node = (struct ListNode *)malloc(sizeof(struct ListNode)); node-&gt;val = arr2\\[i\\]; node-&gt;next = NULL; temp-&gt;next = node; temp = node; } // 跳过开头 val = 0 的链表 struct ListNode * node = addTwoNumbers(a-&gt;next, b-&gt;next); // 输出 while (node) { printf(&quot;%d &quot;, node-&gt;val); node = node-&gt;next; } return 0; } 0 1 三、Longest Substring Without Repeating Characters（无重复字符的最长子串）1、问题描述 给定一个字符串，找出其中不含有重复字符的最长连续子串的长度。 2、算法分析 ①、暴力法 用两层循环找出子串，用一层循环查看子串是否有重复字符。 for (int i = 0; i &lt; n; i++) for(int j = i+1; j &lt; n; j++) for(int k = i; k &lt; j; k++) 要验证索引范围在 [i, j) 内的字符是否无重复，需要将花费 O(j - i) 的时间。 对于给定的 i，对于所有 j∈[i+1, n] 所耗费的时间总和为： 因此，执行所有步骤耗去的时间总和为： ②、滑动窗口 开辟 hashMap[256] 的空间，索引是字符对应的 ASCII 码值，元素内容是它在字符串的位置。 当找到重复的字符时，立即滑动窗口。如果 s[i] 在 [start, i-1] 范围内有重复的字符 s[i’]，我们不需要逐渐增加 start。 可以直接跳过 [start，i’] 范围内的所有元素，并将 start 变为 i’ + 1。 时间复杂度：O(n) 3、代码实现 int lengthOfLongestSubstring(char* s){ int count = (int)strlen(s); if (count == 0) return 0; int* code= (int *)malloc(sizeof(int) * 256); int start = 0; int len = 0; for (int i = 0; i &lt; 256; i++) { code\\[i\\] = -1; } for (int i = 0; i &lt; count; i++) { int c = (int)s\\[i\\]; // 用 Unicode 码作为下标访问 if (code\\[c\\] &gt; -1 &amp;&amp; code\\[c\\] &gt;= start) { // 最长子串长度 if (len &lt; i - 1 - start) { len = i - 1 - start; } if (code\\[c\\] + 1 == i) { start = i; } else { start = code\\[c\\] + 1; } } code\\[c\\] = i; } // 最长子串长度 if (len &lt; count - 1 - start) { len = count - 1 - start; } return len + 1; } 四、Median of Two Sorted Arrays（寻找两个有序数组的中位数）1、问题描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2，m 和n 不能同时为0。请找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 2、算法分析 ①、O(m+n) 开辟一个 (m + n)/2 + 1 长度的数组来存储两个数组排序后处于前半段的数据，通过一层循环从 nums1 和 nums2 中找出前半段的数，最后根据 n + m 是奇数还是偶数来确定是直接取值还是平均值。 空间复杂度：O(n+m) ②、O(log(m+n)) 递归分治法：http://www.dzliving.com/2019/02/22/kmaximumnumber/ 3、代码实现 double findMedianSortedArrays(int nums1, int nums1Size, int nums2, int nums2Size){ // 存储前半段的数组 int len = (nums1Size + nums2Size) / 2 + 1; int result = (int )calloc(len, sizeof(int)); int idx = 0; int i = 0; int j = 0; while (idx &lt; len) { // 未遍历完两个数组 if (i &lt; nums1Size &amp;&amp; j &lt; nums2Size) { if (nums1\\[i\\] &lt;= nums2\\[j\\]) { result\\[idx\\] = nums1\\[i\\]; i++; } else { result\\[idx\\] = nums2\\[j\\]; j++; } } // nums2 已遍历完 else if (i &lt; nums1Size) { result\\[idx\\] = nums1\\[i\\]; i++; } // nums1 已遍历完 else { result\\[idx\\] = nums2\\[j\\]; j++; } idx++; } int mid = (nums1Size + nums2Size) / 2; if ((nums1Size + nums2Size) % 2 || mid == 0) { // 当 nums1 = { }, nums2 = { 1 } 时，mid == 0 不能 - 1 return result\\[mid\\]; } return (result\\[mid\\] + result\\[mid -1\\]) / 2.0; } 五、Longest Palindromic Substring（最长回文子串）1、问题描述 给定一个字符串 s，找到 s 中最长的回文子串。如：字符串 “abcb”，最长回文子串是 “bcb”。 2、算法分析 ①、蛮力法 O(n3) ②、动态规划法 O(n2) ③、马拉车（Manacher）算法 O(n) ④、中心扩展法 O(n2) 这里给出中心扩展法。 中心扩展法就是把给定的字符串的每一个字母当做中心，向两边扩展，找出最长的子回文串。 需要考虑两种情况： ①、回文长度为奇数 aba ②、回文长度为偶数 abba 3、代码实现 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char longestPalindrome(char s) { if (strlen(s) &lt; 2) return s; int start = 0; int end = 0; int tempStart1 = 0; int tempEnd1 = 0; int tempStart2 = 0; int tempEnd2 = 0; for (int i = 1; i &lt; strlen(s); i++) { tempStart1 = 0; tempEnd1 = 0; tempStart2 = 0; tempEnd2 = 0; // 与左边的值相等 if (s\\[i-1\\] == s\\[i\\]) { tempStart1 = i - 1; tempEnd1 = i; } // 当前位置的两边相等 if (s\\[i-1\\] == s\\[i+1\\]) { tempStart2 = i - 1; tempEnd2 = i + 1; } // start 向左移动 end 向右移动 while (tempStart1 &gt; 0 &amp;&amp; tempEnd1 &lt; strlen(s) - 1 &amp;&amp; s\\[tempStart1 - 1\\] == s\\[tempEnd1 + 1\\]) { tempStart1--; tempEnd1++; } // start 向左移动 end 向右移动 while (tempStart2 &gt; 0 &amp;&amp; tempEnd2 &lt; strlen(s) - 1 &amp;&amp; s\\[tempStart2 - 1\\] == s\\[tempEnd2 + 1\\]) { tempStart2--; tempEnd2++; } // 比较当前是不是最长回文字符串 if (end - start &lt; tempEnd1 - tempStart1) { start = tempStart1; end = tempEnd1; } if (end - start &lt; tempEnd2 - tempStart2) { start = tempStart2; end = tempEnd2; } } int length = end - start + 1; char* result = (char *)malloc(sizeof(char) * (length + 1)); result\\[length\\] = &apos;\\\\0&apos;; // 字符串以 \\\\0 结束 // 存在长度超过 1 的回文字符串 if (length &gt; 1) { for (int i = start; i &lt;= end; i++) { result\\[i-start\\] = s\\[i\\]; } } else { result\\[0\\] = s\\[0\\]; } return result; } int main(){ printf(“%s”, longestPalindrome(“ccccc”)); return 0; } 六、zigzag conversion（Z 字形变换）1、问题描述 将一个字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。如字符串 “LEETCODEISHIRING” 在行数为 3 时如下： L C I R E T O E S I I G E D H N 之后的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 2、算法分析 这道题就是看坐标的变化。并且需要分块处理。 n = 2 时，字符串坐标变成 zigzag 的走法就是： 0 2 4 6 1 3 5 7 n = 3： 0 4 8 1 3 5 7 9 2 6 10 n = 4： 0 6 12 1 5 7 11 13 2 4 8 10 14 3 9 15 可以发现规律： ①、画红色的长度永远是 2n - 2 （n 是行数，因为第一行和最后一行比其他行少一个字符）； ②、斜线上绿色的下标永远是 j + (2n - 2) - 2i（i 是行号，j 是列号）。 3、代码实现 从左至右、从上至下的扫描 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; char convert(char s, int numRows){ if (numRows &lt;= 1) return s; int size = 2 * numRows - 2; // 红色的长度 size_t length = strlen(s); // 数组、指针通过参数传递时，sizeof(s) / sizeof(char) 无效 char* c = (char *)malloc(sizeof(char) * (length + 1)); c\\[length\\] = &apos;\\\\0&apos;; // 字符串以 \\\\0 结束 int i = 0; for (int row = 0; row &lt; numRows; row++) { for (int idx = row; idx &lt; length; idx += size) { // 循环执行的次数 = 红色的次数 c\\[i++\\] = s\\[idx\\]; // printf(“%c “, s[idx]); if (row != 0 &amp;&amp; row != numRows - 1 &amp;&amp; (idx + size - 2*row &lt; length)) { // printf(“%c “, s[idx + size - 2row]); c[i++] = s[idx + size - 2row]; } } } return c;} int main(){ / h o l e l w r d l o / char c[] = “gtausokbfugjtfiuqbjclvlazamucimicnewdoxjlfuemdadgkhufsuevjaxrnivcorhfrq”;//“A”; //“LEETCODEISHIRING\\0”;//{ ‘h’, ‘e’, ‘l’, ‘l’, ‘o’, ‘w’, ‘o’, ‘r’, ‘l’, ‘d’ }; char* s = convert(c, 31);//convert(c, 2); // convert(c, 4); // convert(c, 3); printf(&quot;%s&quot;, s); return 0; } 从上至下、从左至右的扫描 char convert(char s, int numRows){ if (numRows &lt;= 1) return s; size_t length = strlen(s); char* c = (char *)malloc(sizeof(char) * (length + 1)); c\\[length\\] = &apos;\\\\0&apos;; int curRow = 0; int goingDown = 0; for (int i = 0; i &lt; length; i++) { // c 语言在某个位置插入元素没有直接的方法，需要移动元素 if (curRow == 0 || curRow == numRows - 1) { goingDown = 1 - goingDown; } curRow += goingDown ? 1 : -1; } return c; } 4、学习文章 ZigZag Conversion leetcode java 七、Reverse Integer（整数翻转）1、问题描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例：输入 123 输出 321；输入 -123 输出 -321；输入 120 输出 21。 注意：假设环境只能存储得了 32 位的有符号整数，则其数值范围为 [−231, 231−1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 2、算法分析 输入数字的个位数在翻转后将是最高位，十位数是在第二高位，依此类推。所以需要依次获得数字的低位，存入数组中，数组元素的顺序即已达到翻转的效果。 2147483648 依次获取低位存入数组为 8 4 6 3 8 4 7 4 1 2。 LeetCode 官方算法的思路也是每次获取数字的末位，但空间复杂度仅为 O(1)。 假设 rev 是正数。 如果 temp = rev*10 + pop 导致溢出，那么一定有 rev≥ INT_MAX​/10。 如果 rev &gt; INT_MAX/10​，那么 temp = rev*10 + pop 一定会溢出。 如果 rev == INT_MAX/10​，那么只要 pop &gt; 7，temp = rev*10 + pop 就会溢出。 当 rev 为负时可以应用类似的逻辑。 3、代码实现 #include &lt;stdio.h&gt; #include &lt;math.h&gt; int reverse(int x){ // 32 位的有符号整数最多只有 10 位数 int a[10] = { 0 }; // 获取到数字的符号 int sign = (x &lt; 0) ? -1 : 1; int i = -1; // 确定数字的最大位数。从 0 开始 while (x != 0) { ++i; a\\[i\\] = x % 10 * sign; // -9 % 10 = -9 x /= 10; // 丢掉&quot;个位数&quot; } long sum = 0; // 将数组各个位置的元素组成一个数字 for (int j = 0; j &lt;= i; j++) { sum += a\\[j\\] * (long)pow(10, i - j); } sum *= sign; if (sum &lt; -1 * pow(2, 31) || sum &gt; pow(2, 31) - 1) return 0; return (int)sum; } int main(){ // -2147483648 -》-8463847412 printf(“%d”, reverse(-2147483648)); return 0; } 下面的算法空间复杂度为 O(1)。 #include &lt;limits.h&gt; int reverse(int x){ int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; // INT\\_MAX = 2147483647（末位是 7） , INT\\_MIN = -2147483648（末位是 -8） if (rev &gt; INT\\_MAX/10 || (rev == INT\\_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; INT\\_MIN/10 || (rev == INT\\_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } 八、String to Integer（字符串转换整数 (atoi)）1、算法分析 首先对第一个字符进行判断，如果不是数字、空格、+/- 直接返回 0；然后循环获取每个字符，记录符号状态，用双指针跟踪数字头尾，对已经有数字、符号之后再出现的空格、符号直接返回 0；数字后接数字继续执行，移动指针。 2、代码实现 #define INT_MAX 2147483647 #define INT_MIN -2147483648 int isVaildCharacter(char c) { return (c - 43 == 0 || c - 45 == 0 || c - 32 == 0 || (0 &lt;= c - 48 &amp;&amp; c - 48 &lt;= 9));} int isNumber(char c) { return (0 &lt;= c - 48 &amp;&amp; c - 48 &lt;= 9);} int isWhiteCharacter(char c) { return c - 32 == 0;} int isSignedCharacter(char c) { return c - 43 == 0 || c - 45 == 0;} int myAtoi(char* str){ if (strlen(str) == 0 || (isVaildCharacter(str[0]) == 0)) return 0; int start = 0; int end = -1; int hasSign = 0; int positive = 1; int sum = 0; while (1) { char c = str\\[end + 1\\]; // 已经有符号 if (hasSign) { // 空白符 || 符号 if (isWhiteCharacter(c) || isSignedCharacter(c)) { break; } // 数字 else if(isNumber(c)) { end++; int pop = (c - 48) * positive; if (sum &gt; INT\\_MAX/10 || (sum == INT\\_MAX / 10 &amp;&amp; pop &gt; 7)) return INT_MAX; if (sum &lt; INT\\_MIN/10 || (sum == INT\\_MIN / 10 &amp;&amp; pop &lt; -8)) return INT_MIN; sum = sum * 10 + pop; } else { break; } } // 当前无符号 else { // 空格 &amp; 无数字 if (isWhiteCharacter(c) &amp;&amp; end - start &lt; 0) { start++; end++; } // 符号 &amp; 无数字 else if (isSignedCharacter(c) &amp;&amp; end - start &lt; 0) { hasSign = 1; positive = (str\\[start\\] - 43 == 0) ? 1 : -1; end++; } // 当前是数字 else if (isNumber(c)) { end++; int pop = (c - 48) * positive; if (sum &gt; INT\\_MAX/10 || (sum == INT\\_MAX / 10 &amp;&amp; pop &gt; 7)) return INT_MAX; if (sum &lt; INT\\_MIN/10 || (sum == INT\\_MIN / 10 &amp;&amp; pop &lt; -8)) return INT_MIN; sum = sum * 10 + pop; } else { break; } } } return sum; } 以上代码表现了对 c 语言的不熟悉，下面的代码为 LeetCode 短耗时的代码。 #include &lt;string.h&gt; /** * @brief 从字符串 s 的开头计算连续的字符，而这些字符都完全是 accept 所指字符串中的字符。简单的说，若 strspn() 返回的数值为 n，则代表字符串 s 开头连续有 n 个字符都是属于字符串accept内的字符。 * @return 返回字符串 s 开头连续包含字符串 accept 内的字符数目。 /size_t strspn (const char \\s,const char * accept); char *str = “Linux was first developed for 386/486-based pcs.”;printf(“%d\\n”, strspn(str, “Linux”)); 百度百科：strspn #define INT_MAX 2147483647 #define INT_MIN -2147483648 int myAtoi(char * str){ int StrOffset = (int)strspn(str, “ “); int Polarity = 1; // 负数 if (*(str + StrOffset) == 45) { Polarity = 0; str++; } // 正数 else if (*(str + StrOffset) == 43) { str++; } int rtNumber = 0; int iCur = 0; // 第一次 iCur = 0，不影响 rtNumber * 10 + iCur 的计算 while (iCur &gt;= 0 &amp;&amp; iCur &lt;= 9) { // 计算是否超出 if (rtNumber &gt; INT\\_MAX / 10 || (rtNumber == INT\\_MAX / 10 &amp;&amp; iCur &gt; 7)) return INT_MAX; if (rtNumber &lt; INT\\_MIN / 10 || (rtNumber == INT\\_MIN / 10 &amp;&amp; iCur &gt; 8)) return INT_MIN; // 确定符号 if(Polarity) rtNumber = rtNumber * 10 + iCur; else rtNumber = rtNumber * 10 - iCur; // 到了末尾结束 if (*(str + StrOffset) == &apos;\\\\0&apos;) break; // 获取下一个值 iCur = *(str++ + StrOffset) - 48; } return rtNumber; } 九、Palindrome Number（回文数）1、算法分析 采用第七题整数翻转算法，然后比较数字是否一样大。 2、代码实现 bool isPalindrome(int x){ if (x &lt; 0 || (x != 0 &amp;&amp; x % 10 == 0)) return 0; int temp = x; int sum = 0; int pop = 0; while (temp != 0) { pop = temp % 10; if (sum &gt; INT\\_MAX/10 || (sum == INT\\_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; if (sum &lt; INT\\_MIN/10 || (sum == INT\\_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; sum = sum * 10 + pop; temp = temp / 10; } return x == sum; } 十、Regular Expression Matching（正则表达式匹配）1、问题描述 实现 . 和 匹配， 表示前面字符 0~∞，. 表示任意一个字符。要求全部匹配，不是部分匹配。 2、算法分析 思路类似最长公共子序列。d[i][j] 是状态，d[0][0] 是边界，下面求出状态转换方程。 ①、s[i] == p[j] || p[j] == ‘.’，则 dp[i][j] = dp[i - 1][j - 1] ②、p[j] == ‘*’ &amp;&amp; s[i] != p[j - 1]，则 dp[i][j] = dp[i][j - 2] ③、p[j] == ‘*’ &amp;&amp; s[i] == p[j - 1]，则 dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 1][j - 2] || dp[i][j - 2] 对于 s 和 p，设最后一个字符分别为 x、y，p 的倒数第二字符为 z，除此外前面字符设为 S、P，则： s = Sx p = Pzy ①、x == y 或 y == ‘.’，则如果 S 和 Pz 匹配，则 s 和 p 匹配，因为最后两个字母是匹配的。这缩减了问题规模。 ②、对于 y == ‘‘ 的情况，p = Pz，即代表是有 0~∞ 个 z。需要考虑 z： 如果 x != z，则只有在 s 和 P 匹配的情况下，s 和 p 才匹配。 如果 x == z，设匹配符号为 ~，则如果 S~P、S~Pz、S~Pzy、Sx~P、Sx~Pz，都可得出 s 和 p 匹配。 3、算法实现 #define bool int bool cmatch(char s, char p) { return p == ‘*’ || p == ‘.’ || s == p;} bool isMatch(char s, char p){ int m = (int)strlen(s); int n = (int)strlen(p); bool* arr = calloc(sizeof(bool), n+1); arr\\[0\\] = 1; for (int i = 2; i &lt;= n; ++i) if (p\\[i - 1\\] == &apos;*&apos; &amp;&amp; arr\\[i - 2\\] == 1) arr\\[i\\] = 1; int j2 = arr\\[0\\]; int j1 = arr\\[1\\]; int temp = arr\\[2\\]; for (int i = 1; i &lt;= m; ++i) { for (int j = 0; j &lt;= n; ++j) if (j == 0) { j2 = arr\\[0\\]; arr\\[0\\] = 0; } else if (j == 1) { j1 = arr\\[1\\]; arr\\[1\\] = i == 1 &amp;&amp; cmatch(s\\[0\\], p\\[0\\]); } else { temp = arr\\[j\\]; if (p\\[j - 1\\] == &apos;*&apos;) // x == z &amp;&amp; ...，因为 &amp;&amp; 操作在第一个条件为假的情况下，会停止判断第二条件 arr\\[j\\] = cmatch(s\\[i - 1\\], p\\[j - 2\\]) &amp;&amp; (arr\\[j\\] || arr\\[j - 1\\] || j1 || j2 || arr\\[j - 2\\]) ? 1 : arr\\[j - 2\\]; else // x == y || y == &apos;.&apos; || y = &apos;*&apos; arr\\[j\\] = cmatch(s\\[i - 1\\], p\\[j - 1\\]) ? j1 : 0; j2 = j1; j1 = temp; } } return arr\\[n\\]; } int main(){// printf(“%d\\n”, isMatch(“aaa”, “aa”)); // 1// printf(“%d\\n”, isMatch(“aaa”, “ab\\ac*a”)); // 1// printf(“%d\\n”, isMatch(“ab”, “.“)); // 1// printf(“%d\\n”, isMatch(“a”, “...a“)); // 0// printf(“%d\\n”, isMatch(“aa”, “a”)); // 0// printf(“%d\\n”, isMatch(“aa”, “a“)); // 1// printf(“%d\\n”, isMatch(“mississippi”, “mis*is*p.”)); // 0 printf(“%d\\n”, isMatch(“ppi”, “ppic“)); // 1// printf(“%d\\n”, isMatch(“aaa”, “aaaa”)); // 0// printf(“%d\\n”, isMatch(“aaa”, “ab*a*c*a”)); // 1 return 0; } 动态归划缩减版，只用一个数组和一些 temp 变量。 bool isMatch(const char s,const char p) { size_t m = strlen(s); size_t n = strlen(p); bool* cur = calloc(sizeof(bool), n + 1); bool temp, pre; for (int i = 0; i &lt;= m; i++) { pre = cur\\[0\\]; cur\\[0\\] = (i == 0); printf(&quot;%d &quot;, cur\\[0\\]); for (int j = 1; j &lt;= n; j++) { temp = cur\\[j\\]; if (p\\[j - 1\\] == &apos;*&apos;) { cur\\[j\\] = cur\\[j - 2\\] || (i &gt; 0 &amp;&amp; cur\\[j\\] &amp;&amp; (s\\[i - 1\\] == p\\[j - 2\\] || p\\[j - 2\\] == &apos;.&apos;)); } else { cur\\[j\\] = i &gt; 0 &amp;&amp; pre &amp;&amp; (s\\[i - 1\\] == p\\[j - 1\\] || p\\[j - 1\\] == &apos;.&apos;); } pre = temp; printf(&quot;%d &quot;, cur\\[j\\]); } printf(&quot;\\\\n&quot;); } temp = cur\\[n\\]; free(cur); return temp; }","tags":[]},{"title":" init、initWithCapacity\t\t","date":"2019-01-22T08:20:20.000Z","path":"2019/01/22/init-e3-80-81initwithcapacity/","text":"initWithCapacity:10 并不代表里面的 object 数量不能大于 10，也可以大于 10； init是在告诉程序，”我不知道要放多少 object，暂且帮我初始化”。 如果你知道大概要放多少东西，那么最好用 initWithCapacity，这个会提高程序内存运用效率。 如果你初始化了可变数组，并且很长时间不会用到，建议用 initWithCapacity:0。","tags":[]},{"title":" #define、const、static\t\t","date":"2019-01-22T07:27:42.000Z","path":"2019/01/22/define-e3-80-81const-e3-80-81static/","text":"const（static） 和 #define 在开发中常用来定义常量，这样做的好处是：使代码更易维护、提高代码的效率。 #define#define 是预定义定义常量，其实不是常量。在程序中并没有给 #define 的字符量开辟变量空间，它没有类型。因为根本找不到存储地址，所以在程序中也就不可改变了。 #define dd 100 // 在程序预编译的时候将程序中的所有的 dd 改为 100 define 除了定义常量外，还能进行高级宏定义功能。如：定义函数；定义 OC 中常用的单例模式；还能根据传参数生成字符串等。 #undef DEF_SINGLETON #define DEF_SINGLETON \\- (instancetype)sharedInstance \\{ \\return [[self class] sharedInstance]; \\} \\+ (instancetype)sharedInstance \\{ \\static dispatch_once_t once; \\static id __singleton__; \\dispatch_once( &amp;once, ^{ __singleton__ = [[self alloc] init]; } ); \\return __singleton__; \\} staticstatic 比 const 先出现。static 是 c 语言时出现的，const 是 c++ 语言时出现的。const 是 static 的加强版本，这是因为作为一个常量的修饰符，static 并不是完全意义上的常量修饰符。 constconst是绝对的常量修饰符。不可修改。 const 定义常量时，编译器通常不为普通 const 常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高。从汇编的角度来看，只是给出了对应的内存地址，所以，const 定义的常量在程序运行过程中只有一份拷贝。 const 定义常量时，通常是同时定义常量的类型、值，且常与 static 结合使用。 #define 与 const 的区别①、起作用的阶段：#define 是在编译的预处理阶段起作用，而 const 是在 编译、运行的时候起作用。 ②、起作用的方式：#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 ③、存储方式：#define 只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const 定义的只读变量在程序运行过程中只有一份备份。 ④、代码调试的方便程度： const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了。 const 优点①、const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 ②、有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。 ③、const 可节省空间，避免不必要的内存分配，提高效率 综上所述：#define 和 const、static 有本质的区别。const 和 static 是严谨与更严谨，严格与更严格的区别。 建议：在确定了使用的常量类型及常量值时使用 const 进行定义；而简单的函数或传参字符串等高级定义时，则使用 #define 进行宏定义。","tags":[]},{"title":" KSCrash\t\t","date":"2019-01-16T03:10:37.000Z","path":"2019/01/16/kscrash/","text":"http://www.php-master.com/post/313638.html https://github.com/kstenerud/KSCrash","tags":[]},{"title":" 符号表\t\t","date":"2019-01-15T10:03:37.000Z","path":"2019/01/15/e7-ac-a6-e5-8f-b7-e8-a1-a8/","text":"一、什么是符号表符号表就是指在 Xcode 项目编译后，在编译生成的二进制文件 .app 的同级目录下生成的同名的 .dSYM 文件，.dSYM 文件其实是一个目录，在子目录中包含了一个16 进制的保存函数地址映射信息的中转文件，所有 Debug 的 symbols 都在这个文件中(包括文件名、函数名、行号等)，所以也称之为调试符号信息文件。 二、符号表有什么用符号表就是用来符号化 crash log（崩溃日志）。crash log 中有一些方法 16 进制的内存地址等，通过符号表就能找到对应的能够直观看到的方法名等。 三、如何得到.dSYM文件1、在 Archive 的时候会生成 .xcarchive 文件，然后显示包内容就能够在里面找到 .dSYM 文件和 .app 文件。 .xcarchive 显示包内容 -> dSYMs -&gt; [appname].app.dSYM -&gt; 右击”显示包内容” -> “Contents” -&gt; “Resources” -&gt; “DWARF”，这时会看到和你 APPNAME 一样的文件。 2、Archives 界面点击 Download dSYMs 按钮。Xcode 会下载 dSYM 文件，然后把它们插入到选中的 archive 中。 3、从 iTunes Connect 网站下载 dSYM 文件： ①、Open the App Details page. ②、Click Activity. ③、From the list of All Builds, select a version. ④、Click the Download dSYM link. 四、翻译’hidden’ 符号When you upload your app with bitcode to the App Store, you may choose not to send your application’s symbols by unchecking the “Upload your app’s symbols to receive symbolicated reports from Apple” box in the submission dialog. If you choose not to send your app’s symbol information to Apple, Xcode will replace the symbols in your app’s .dSYM files with obfuscated symbols such as “__hidden#109_“ before sending your app to iTunes Connect. Xcode creates a mapping between the original symbols and the “hidden” symbols and stores this mapping in a .bcsymbolmap file inside the application archive. Each .dSYM file will have a corresponding .bcsymbolmap file. 将 bitCode = YES 的应用程序上传到 App Store 时，可以不选中 “Upload your app’s symbols to receive symbolicated reports from Apple” 来选择不发送应用程序的符号。如果选择了不将应用程序的符号信息发送到 Apple，Xcode 将在应用程序发送到 iTunes Connect 之前，用模糊的符号（如”__hidden#109_“）替换应用程序的 .dsym 文件中的符号。Xcode 创建原始符号和”隐藏”符号之间的映射，并将此映射存储在应用程序存档中的 .bcsymbolmap 文件中。每个 .dsym 文件都将有一个对应的 .bcsymbolmap 文件。 Before symbolicating crash reports, you will need to de-obfuscate the symbols in the .dSYM files downloaded from iTunes Connect. If you use the Download dSYMs button in Xcode, this de-obfuscation will be performed automatically for you. However, if you use the iTunes Connect website to download the .dSYM files, open Terminal and use the following command to de-obfuscate your symbols (replacing the example paths with your own archive and the dSYMs folder downloaded from iTunes Connect): 在对崩溃报告进行符号化之前，需要对从 iTunes Connect 下载的 .dsym 文件中的符号进行去模糊处理。如果在 Xcode 中使用Download dSYMs 按钮，将自动执行去模糊处理。但是，如果使用 iTunes Connect 网站下载 .dsym 文件，请打开终端并使用以下命令取消混淆的符号（将示例路径替换为自己的存档和从 iTunes Connect 下载的 dsyms 文件夹）： $ xcrun dsymutil -symbol-map ~/Library/Developer/Xcode/Archives/2017-11-23/MyGreatApp\\ 11-23-17\\,\\ 12.00\\ PM.xcarchive/BCSymbolMaps ~/Downloads/dSYMs/3B15C133-88AA-35B0-B8BA-84AF76826CE0.dSYM Run this command for each .dSYM file inside the dSYMs folder you downloaded. 五、确定崩溃日志已经是否符号化一个崩溃日志可能是没有符号化的，没有符号化的日志将不包括方法或者方法名在回溯信息中。 在一个被完全符号化的日志中，每一行 16 进制地址都是对应着符号。在部分符号化的崩溃日志中，只有一些地址在回溯日志中被替换在它的回馈符号中。很明显，你应该尝试符号化获得的崩溃日志当它提供了很多内在的崩溃。 一部分符号化崩溃日志可能包括足够的信息去明白崩溃，依赖崩溃的类型和回溯的一部分（被成功符号化的一部分）。没有符号化的崩溃日志很少有用。 注意：Low Memory Reports do not need to be symbolicated. 低内存的报告不需要被符号化。 六、Crash日志包含了进程信息、基本信息、异常信息、线程回溯、Crash 的调用栈、动态库的信息。对于这样的日志，如果没有符号化是基本不可能显示出崩溃出现的地方的，所以需要对 Crash 日志进行符号化处理。符号化处理的方式有一下两种： ①、Xcode 符号化 ②、symbolicatecrash 脚本符号化 七、Xcode 符号化Xcode 将自动尝试符号化它遇到的所有崩溃报告。你所需要做的就是将崩溃报告添加到 Xcode Organizer。 注意：Xcode 不接受没有 .crash 扩展名的崩溃报告。如果收到的崩溃报告没有扩展名或扩展名为 .txt，请在执行下面列出的步骤之前将其重命名为 .crash 扩展名。 ①、将 iOS 设备连接到 Mac； ②、从 “Window” 菜单中选择 “Devices and Simulators”； ③、在左列的选择一个设备； ④、单击右侧面板上 “Device Information” 部分下的 “View Device Logs” 按钮； ⑤、将崩溃报告拖到所显示面板的左栏上； ⑥、xcode 将自动符号化崩溃报告并显示结果。 要表示崩溃报告，Xcode 需要能够定位以下内容： ①、崩溃应用程序的二进制文件和 dsym 文件。 ②、应用程序链接到的所有自定义框架的二进制文件和 dsym 文件。对于使用应用程序从源代码构建的框架，它们的 dsym 文件与应用程序的 dsym 文件一起复制到归档文件中。对于由第三方构建的框架，您需要向作者请求 dsym 文件。 ③、应用程序崩溃时运行的操作系统的符号。这些符号包含特定操作系统版本（如 iOS9.3.3）中包含的框架的调试信息。操作系统符号是特定于体系结构的 -- 64 位设备的 iOS 版本不包括 ARMV7 符号。Xcode 将自动从连接到 Mac 的每个设备复制操作系统符号。 如果缺少这些代码中的任何一个，Xcode 可能无法表示崩溃报告，或者只能部分表示崩溃报告。 八、Symbolicating Crash Reports With atos（使用 atos 进行符号化）atos 将数字化的地址转化为二进制符号或者进程。 如果一个调试的符号信息是有用的，atos 的输出将会包括文件的名字和资源的行号信息。atos 命令能够用于在没有被符号化的回溯信息中符号化单独的地址或者部分符号化崩溃日志。使用 atos 符号化一部分崩溃日志。 ①、找一行回溯信息中的你想符号化的，注意二进制映像的名字在第二列和第三列的地址 ②、查找二进制映像的名字在崩溃日志的二进制映像汇总。注意结构和加载的二进制地址。 atos 的方式解析崩溃日志（包含 atos 需要的信息） ①、找到相对于二进制文件的 dSYM。可以使用 Spotlight 为二进制映像的UUID 查找匹配的dSYM 文件；dSYM 文件是一个包，其中包含编译器在生成时生成的 dwarf 调试信息 ②、利用上述信息，你能够使用 atos 命令在回溯信息中符号化地址。你能够指定多个由空格分隔的地址来符号化。调用 ATOS 时，必须提供此文件的路径，而不是 DSYM 包的路径。 atos -arch -o /Contents/Resources/DWARF/ -l $ atos -o /Users/nhz/Library/Developer/Xcode/Archives/2018-07-18/Demo\\ 2018-7-18\\ 上午10.44. xcarchive/dSYMs/Demo.app.dSYM/Contents/Resources/DWARF/Demo -l 0x6c000 -arch armv7 0x0007571e-[ViewController viewDidLoad] (in Demo) (ViewController.m:59) 如果想将系统库的堆栈信息符号化，将会出错 九、Symbolication Troubleshooting（符号化分析解决问题）如果 Xcode 符号化崩溃日志失败，可能是 Mac 少了应用程序二进制文件的 dSYM 文件、应用程序链接的一个或多个框架的 dSYM 文件或者应用程序崩溃时运行的操作系统的设备符号。下面步骤展示怎么使用 Spotlight 来确定 Mac 上是否存在表示二进制映像中的回溯地址所需的 dSYM 文件。 Locating the UUID for a binary image. 定位 UUID ①、找到回溯信息中找到 Xcode 无法符号化的行。注意二进制映像文件的名字在第二列； ②、通过名字在崩溃日志的底部的二进制映像列表中查找二进制映像。此列表包含崩溃时加载到进程中的每个二进制图像的UUID。 通过 grep 命令快速找到 $ grep –after-context=1000 “Binary Images:” | grep ③、将二进制映像的 UUID 转换为 32 个字符串，以 8-4-4-4-12（XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXX）为一组进行分隔。注意所有字母都必须大写。 ④、通过 mdfind 命令使用 “com-apple-xcode-dsym-uuids==“（包括引号）语句查找 UUID。 使用 mdfind 命令行工具搜索具有给定 UUID 的 dSYM 文件。 $ mdfind “com_apple_xcode_dsym_uuids == ⑤、如果 Spotlight 找到 UUID 的 dSYM 文件，则 mdfind 将打印到 dSYM 文件的路径，并可能打印到包含该文件的存档文件。如果找不到 UUID 的 dSYM 文件，则 mdfind 将退出而不打印任何内容。 如果 Spotlight 找到二进制文件的 dSYM 文件，但 Xcode 无法在该二进制映像中符号化地址，则应提交一个 bug。将崩溃报告和相关的 dSYM 文件附加到错误报告中。作为一种解决方法，您可以使用 ATOS 手动表示地址。Symbolicating Crash Reports With atos.。 如果 Spotlight 找不到二进制映像的 dSYM，请验证你仍然拥有崩溃应用程序版本的 Xcode 存档，并且该存档位于 Spotlight 可以找到它的位置。如果你的应用程序是在启用 bitCode 的情况下构建的，请确保你已经从应用程序商店下载了用于最终编译的dSYM 文件。Downloading the dSYM files from Xcode。 如果你认为二进制映像的 dSYM 是正确的，那么可以使用 dwarfdump 命令来打印匹配的 UUID。还可以使用 dwarfdump 命令打印二进制文件的 UUID。 先 cd 到 dSYMs 所在的目录，终端执行 dwarfdump –uuid xx.app.dSYM &amp; xcrun dwarfdump –uuid 注意： 你必须有 archive 文件，就是你当初提交到 App Store 上，对应于你的应用的崩溃，dSYM 文件和应用的二进制被绑定在一起。创建一个新的归档，甚至从相同的源代码和配置，此时的 dSYM 和崩溃是没有建立关系。 如果你没有这个归档文件，你就需要提交新的一份，进行操作了。 十、Analyzing Crash Reports（分析崩溃报告）每个崩溃报告都以一个 header 开始。 Incident Identifier: B6FD1E8E-B39F-430B-ADDE-FC3A45ED368CCrashReporter Key: f04e68ec62d3c66057628c9ba9839e30d55937dcHardware Model: iPad6,8Process: TheElements [303]Path: /private/var/containers/Bundle/Application/888C1FA2-3666-4AE2-9E8E-62E2F787DEC1/TheElements.app/TheElementsIdentifier: com.example.apple-samplecode.TheElementsVersion: 1.12Code Type: ARM-64 (Native)Role: ForegroundParent Process: launchd [1]Coalition: com.example.apple-samplecode.TheElements [402] Date/Time: 2016-08-22 10:43:07.5806 -0700Launch Time: 2016-08-22 10:43:01.0293 -0700OS Version: iPhone OS 10.0 (14A5345a)Report Version: 104 大多数字段都是不言自明的，但有一些字段值得特别注意： Incident Identifier: A unique identifier for the report. Two reports will never share the same Incident Identifier. 事件标识符：报告的唯一标识符。两个报告永远不会共享同一事件标识符。Xcode 导出来的 crash 里的 Incident Identifier 与终端命令通过 dwarfdump 命令得到的 UUID 不一致，因为每次崩溃文件都在变化。这个方式获取 UUID 是行不通。 CrashReporter Key: An anonymized per-device identifier. Two reports from the same device will contain identical values. 报告提交者 key：每个设备的匿名标识符。来自同一设备的两个报告将包含相同的值。 Beta Identifier: A unique identifier for the combination of the device and vendor of the crashed application. Two reports for applications from the same vendor and from the same device will contain identical values. This field is only present in crash reports generated for applications distributed through TestFlight, and replaces the CrashReporter Key field. beta 标识符：崩溃应用程序的设备和供应商组合的唯一标识符。来自同一供应商和同一设备的应用程序的两个报告将包含相同的值。此字段仅存在于为通过 TestFlight 分发的应用程序生成的崩溃报告中，并替换了 CrashReporter Key 字段。 Process: The executable name for the process that crashed. This matches the value for the CFBundleExecutable key in the application’s information property list. 进程：崩溃进程的可执行文件名。这与应用程序 info.plist 中的 CFBundleExecutable 键的值匹配。 Version: The version of the process that crashed. The value for this field is a concatenation of the crashed application’s CFBundleVersion and CFBundleVersionString. 版本：崩溃进程的版本。此字段的值是崩溃应用程序的 CFBundleVersion和 CFBundleVersionString 的串联。 Code Type: The target architecture of the process that crashed. This will be one of ARM-64, ARM, x86-64, or x86. 代码类型：崩溃进程的目标体系结构。这将是 ARM-64、ARM、x86-64 或 x86 之一。 Role: The task_role assigned to the process at the time of termination. 角色：终止时分配给流程的任务角色。 OS Version: The OS version, including the build number, on which the crash occurred. 操作系统版本：发生崩溃的操作系统版本，包括内部版本号。 还有其他不是一定出现的字段： Exception Type: EXC_BAD_ACCESS (SIGSEGV)Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000Termination Signal: Segmentation fault: 11Termination Reason: Namespace SIGNAL, Code 0xbTerminating Process: exc handler [0]Triggered by Thread: 0 Exception Codes: Processor specific information about the exception encoded into one or more 64-bit hexadecimal numbers. Typically, this field will not be present because the Crash Reporter parses the exception codes to present them as a human-readable description in the other fields. 异常代码：有关将异常编码为一个或多个 64 位十六进制数的处理器特定信息。通常此字段不会出现，因为崩溃报告程序解析异常代码，将它们作为人类可读的描述显示在其他字段中。 Exception Subtype: The human-readable name of the exception codes. 异常子类型：异常代码的人类可读名称。 Exception Message: Additional human-readable information extracted from the exception codes. 异常消息：从异常代码中提取的其他人类可读信息。 Exception Note: Additional information that is not specific to one exception type. If this field contains SIMULATED (this is NOT a crash) then the process did not crash, but was killed at the request of the system, typically the watchdog. 异常说明：不特定于一个异常类型的其他信息。如果此字段包含模拟（这不是崩溃），那么进程没有崩溃，而是在系统的请求下终止。 Termination Reason: Exit reason information specified when a process is terminated. Key system components, both inside and outside of a process, will terminate the process upon encountering a fatal error (e.g. a bad code signature, a missing dependent library, or accessing privacy sensitive information without the proper entitlement). macOS Sierra, iOS 10, watchOS 3, and tvOS 10 have adopted new infrastructure to record these errors, and crash reports generated by these operating systems list the error messages in the Termination Reason field. 终止原因：进程终止时指定的退出原因信息。进程内外的关键系统组件将在遇到致命错误（例如错误的代码签名、丢失的依赖库或在没有适当权限的情况下访问隐私敏感信息）时终止进程。MacOS Sierra、iOS10、WatchOS3 和 TVOS10 采用了新的基础设施来记录这些错误，这些操作系统生成的崩溃报告在”终止原因”字段中列出了错误消息。 Triggered by Thread: The thread on which the exception originated. 由线程触发：产生异常的线程。 The following sections explain some of the most common exception types: 十一、代码 + 工具#import &lt;mach-o/dyld.h&gt; - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ log(); return YES; } void log(void){ for (int i = 0; i &lt; _dyld_image_count(); i++) { if (_dyld_get_image_header(i)-&gt;filetype == MH_EXECUTE) { char image_name = (char )_dyld_get_image_name(i); const struct mach_header * mh = _dyld_get_image_header(i); intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i); printf(“Image name %s at load address 0x%llx and ASLR slide 0x%lx.\\n”, image_name, (mach_vm_address_t)mh, vmaddr_slide); break; } }} Image name /Users/cykj/Library/Developer/CoreSimulator/Devices/5EA7E32E-0543-406C-A9D1-1917DEB0F3A3/data/Containers/Bundle/Application/F418542C-8AAC-4B1A-AA8D-3087D2508194/Demo.app/Demo at load address 0x10f982000 and ASLR slide 0xf982000. stackoverflow 介绍： slide = _dyld_get_image_vmaddr_slide(0); load address = _dyld_get_image_header(0); symbol address = slide + stack address - load address； stack address 在 crash log 中可以找到。用得到的 symbol 地址去 dSYM 文件中查询，终端命令： $ dwarfdump –arch arm64 –lookup [symbol address] **.app.dSYM/ 就可以定位到具体的代码函数名、所处的文件、行等信息了；（测试时未成功） dSYMs $ dwarfdump –arch arm64 –lookup 0x0000000108991dfd Demo.app.dSYM/---------------------------------------------------------------------- File: Demo.app.dSYM/Contents/Resources/DWARF/Demo (arm64)----------------------------------------------------------------------Looking up address: 0x0000000108991dfd in .debug_info… not found.Looking up address: 0x0000000108991dfd in .debug_frame… not found. 另一篇 blog 是这么说的符号地址： symbol address = stack address - slide; 确定 dSYM、app 以及 crash 文件的关系，每一个 xx.app、xxx.app.dSYM 文件都拥有相应的 UUID，crash 文件也有 UUID，只有三者 UUID 一致才表明这三者可以解析出正确的日志文件。 Applications $ dwarfdump –uuid Demo.app/DemoUUID: 754EE0F1-DEF4-3E77-83DC-C943327E1069 (armv7) Demo.app/DemoUUID: 70F61941-82F0-384A-B10B-860C685408C2 (arm64) Demo.app/Demo dSYMs $ dwarfdump –uuid Demo.app.dSYMUUID: 754EE0F1-DEF4-3E77-83DC-C943327E1069 (armv7) Demo.app.dSYM/Contents/Resources/DWARF/DemoUUID: 70F61941-82F0-384A-B10B-860C685408C2 (arm64) Demo.app.dSYM/Contents/Resources/DWARF/Demo crash 文件内 Binary Images：下面一行中 &lt;&gt; 内的就是该 crash 文件的 UUID，而第一个地址 0x1000ac000 便是 slide address。 Binary Images:0x1000ac000 - 0x100c13fff Example arm64 /var/containers/Bundle/Application/99EE6ECE-4CEA-4ADD-AE8D-C4B498886D22/Example.app/Example 十二、参考文章https://www.jianshu.com/p/947fe55ca434 Understanding and Analyzing Application Crash Reports 十三、dSYM 工具https://github.com/answer-huang/dSYMTools","tags":[]},{"title":" 线程 Call Stack 的捕获和解析\t\t","date":"2019-01-15T04:01:03.000Z","path":"2019/01/15/e7-ba-bf-e7-a8-8bcall-stack-e7-9a-84-e6-8d-95-e8-8e-b7-e5-92-8c-e8-a7-a3-e6-9e-90/","text":"注：文中的 jdy_、BS_ 均是原文作者的资源前缀。 一、获取任意一个线程的 Call Stack如果要获取当前线程的调用栈，可以直接使用现有 API:[NSThread callStackSymbols]。 但是并没有相关 API 支持获取任意线程的调用栈，所以只能自己编码实现。 1、调用栈 一个线程的调用栈是什么样的呢？ “我”的理解是应该包含当前线程的执行地址，并且从这个地址可以一级一级回溯到线程的入口地址，这样就反向构成了一条链：线程入口执行某个方法，然后逐级嵌套调用到当前现场。 如图所示，每一级的方法调用，都对应了一张活动记录，也称为活动帧。也就是说，调用栈是由一张张帧结构组成的，可以称之为栈帧。每个栈帧对应一个函数调用：蓝色的部分是 DrawSquare 函数的栈帧，它在执行的过程中调用了绿色部分的 DrawLine 函数。 可以看到栈帧由三部分组成：函数参数、返回地址、帧内的变量。首先把函数的参数入栈；随后将返回地址入栈，这表示当前活动记录执行结束后要返回的地址；最后是在函数内部定义的变量。 Stack Pointer(栈指针)表示当前栈的顶部，由于大部分操作系统的栈向下生长，它其实是栈地址的最小值。根据之前的解释，Frame Pointer 指向的地址中，存储了上一次 Stack Pointer 的值，也就是返回地址。 在大多数操作系统中，每个栈帧还保存了上一个栈帧的 Frame Pointer，因此只要知道当前栈帧的 Stack Pointer 和 Frame Pointer，就能知道上一个栈帧的 Stack Pointer 和 Frame Pointer，从而递归的获取栈底的帧。形成了一条链。 显然当一个函数调用结束时，它的栈帧就不存在了。 因此，调用栈其实是栈的一种抽象概念，它表示了方法之间的调用关系，一般来说从栈中可以解析出调用栈。 那么，在我们获取到栈帧后，就可以通过返回地址来进行回溯了。 2、指令指针和基址指针 我们明确了两个目标：①、当前执行的指令 ②、当前栈帧结构。 以 x86 为例，寄存器用途如下： SP/ESP/RSP: Stack pointer for top address of the stack.BP/EBP/RBP: Stack base pointer for holding the address of the current stack frame.IP/EIP/RIP: Instruction pointer. Holds the program counter, the current instruction address. 可以看到，我们可以通过指令指针来获取当前指令地址，以及通过栈基址指针获取当前栈帧地址。 那么问题来了，我们怎么获取到相关寄存器呢？ 3、线程执行状态 考虑到一个线程被挂起时，后续继续执行需要恢复现场，所以在挂起时相关现场需要被保存起来，比如当前执行到哪条指令了。 那么就要有相关的结构体来为线程保存运行时的状态，经过一番查阅，得到如下信息： The function thread_get_state returns the execution state (e.g. the machine registers) of target_thread as specified by flavor. Function - Return the execution statefora thread. SYNOPSIS kern_return_t thread_get_state( thread_act_t target_act, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t *old_stateCnt); /* * THREAD_STATE_FLAVOR_LIST 0 these are the supported flavors. 这些枚举值没有找到，可能为作者自定义。/#define x86_THREAD_STATE32 1#define x86_FLOAT_STATE32 2#define x86_EXCEPTION_STATE32 3#define x86_THREAD_STATE64 4#define x86_FLOAT_STATE64 5#define x86_EXCEPTION_STATE64 6#define x86_THREAD_STATE 7#define x86_FLOAT_STATE 8#define x86_EXCEPTION_STATE 9#define x86_DEBUG_STATE32 10#define x86_DEBUG_STATE64 11#define x86_DEBUG_STATE 12#define THREAD_STATE_NONE 13/\\ 14 and 15 are used for the internal x86_SAVED_STATE flavours */#define x86_AVX_STATE32 16#define x86_AVX_STATE64 17#define x86_AVX_STATE 18 所以我们可以通过这个 API 搭配相关参数来获得想要的寄存器信息： bool jdy_fillThreadStateIntoMachineContext(thread_t thread, _STRUCT_MCONTEXT * machineContext) { mach_msg_type_number_t state_count = x86_THREAD_STATE64_COUNT; kern_return_t kr = thread_get_state(thread, x86_THREAD_STATE64, (thread_state_t)&amp;machineContext-&gt;__ss, &amp;state_count); return (kr == KERN_SUCCESS);} 不同的架构对应的 state_count 不同，所以这里用了宏 x86_THREAD_STATE64_COUNT 来做处理。这里引入了一个结构体叫 _STRUCT_MCONTEXT。 4、不同平台的寄存器 _STRUCT_MCONTEXT 在不同平台上的结构不同： x86_64，如 iPhone6 模拟器： _STRUCT_MCONTEXT64{ _STRUCT_X86_EXCEPTION_STATE64 es; _STRUCT_X86_THREAD_STATE64 ss; _STRUCT_X86_FLOAT_STATE64 __fs;}; _STRUCT_X86_THREAD_STATE64{ __uint64_t rax; __uint64_t rbx; __uint64_t rcx; __uint64_t rdx; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rsp; __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rip; __uint64_t rflags; __uint64_t cs; __uint64_t fs; __uint64_t __gs;}; x86_32，如 iPhone4s 模拟器： _STRUCT_MCONTEXT32{ _STRUCT_X86_EXCEPTION_STATE32 es; _STRUCT_X86_THREAD_STATE32 ss; _STRUCT_X86_FLOAT_STATE32 __fs;}; _STRUCT_X86_THREAD_STATE32{ unsignedint eax; unsignedint ebx; unsignedint ecx; unsignedint edx; unsignedint edi; unsignedint esi; unsignedint ebp; unsignedint esp; unsignedint ss; unsignedint eflags; unsignedint eip; unsignedint cs; unsignedint ds; unsignedint es; unsignedint fs; unsignedint gs;}; ARM64，如 iPhone5s： _STRUCT_MCONTEXT64{ _STRUCT_ARM_EXCEPTION_STATE64 es; _STRUCT_ARM_THREAD_STATE64 ss; _STRUCT_ARM_NEON_STATE64 __ns;}; _STRUCT_ARM_THREAD_STATE64{ __uint64_t x[29]; / General purpose registers x0-x28 / void __opaque_fp; / Frame pointer x29 / void __opaque_lr; / Link register x30 / void __opaque_sp; / Stack pointer x31 / void __opaque_pc; / Program counter / __uint32_t cpsr; / Current program status register / __uint32_t __opaque_flags; / Flags describing structure format /}; ARMv7/v6，如 iPhone4s： _STRUCT_MCONTEXT32{ _STRUCT_ARM_EXCEPTION_STATE es; _STRUCT_ARM_THREAD_STATE ss; _STRUCT_ARM_VFP_STATE __fs;}; _STRUCT_ARM_THREAD_STATE{ __uint32_t r[13]; / General purpose register r0-r12 / __uint32_t sp; / Stack pointer r13 / __uint32_t lr; / Link register r14 / __uint32_t pc; / Program counter r15 / __uint32_t __cpsr; / Current program status register /}; 可以对照《iOS ABI Function Call Guide》，其中在 ARM64 相关章节中描述到： The frame pointer register (x29) must always address a valid frame record, although some functions–such as leaf functions or tail calls–may elect not to create an entry in this list. As a result, stack traces will always be meaningful, even without debug information 而在 ARMv7/v6 上描述到： The function calling conventions used in the ARMv6 environment are the same as those used in the Procedure Call Standard for the ARM Architecture (release 1.07), with the following exceptions: *The stack is 4-byte aligned at the point of function calls. Large data types (larger than 4 bytes) are 4-byte aligned. Register R7 is used as a frame pointer Register R9 has special usage.* 所以，通过了解以上不同平台的寄存器结构，我们可以编写出比较通用的回溯功能。 5、算法实现 /** * 关于栈帧的布局可以参考： * https://en.wikipedia.org/wiki/Call_stack * http://www.cs.cornell.edu/courses/cs412/2008sp/lectures/lec20.pdf * http://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/ /typedef struct JDYStackFrame { const struct JDYStackFrame const previous; // 上一个栈帧 const uintptr_t returnAddress; // 返回地址：上一个栈帧的地址} JDYStackFrame; /// 回溯int jdy_backtraceThread(thread_t thread, uintptr_t *backtraceBuffer, int limit) { if (limit &lt;= 0) return 0; \\_STRUCT\\_MCONTEXT mcontext; // 获取上下文 if (!jdy_fillThreadStateIntoMachineContext(thread, &amp;mcontext)) { return 0; } int i = 0; uintptr\\_t pc = jdy\\_programCounterOfMachineContext(&amp;mcontext); backtraceBuffer\\[i++\\] = pc; if (i == limit) return i; uintptr\\_t lr = jdy\\_linkRegisterOfMachineContext(&amp;mcontext); if (lr != 0) { /\\* 由于lr保存的也是返回地址，所以在lr有效时，应该会产生重复的地址项 */ backtraceBuffer\\[i++\\] = lr; if (i == limit) return i; } JDYStackFrame frame = {0}; uintptr\\_t fp = jdy\\_framePointerOfMachineContext(&amp;mcontext); if (fp == 0 || jdy\\_copyMemory((void *)fp, &amp;frame, sizeof(frame)) != KERN\\_SUCCESS) { return i; } while (i &lt; limit) { backtraceBuffer\\[i++\\] = frame.returnAddress; if (frame.returnAddress == 0 || frame.previous == NULL || jdy\\_copyMemory((void *)frame.previous, &amp;frame, sizeof(frame)) != KERN\\_SUCCESS) { break; } } return i; } 二、失败的传统方法利用 dispatch_async 或 performSelectorOnMainThread 等方法，结合 callstackSymbols 方法，回到主线程并获取调用栈。这是否可行？ 线程，首先要运行起来，然后(如果有必要)启动 runloop 进行保活。我们知道 runloop 的本质就是一个死循环，在循环中调用多个函数，分别判断 source0、source1、timer、dispatch_queue 等事件源有没有要处理的内容。 和 UI 相关的事件都是 source0，因此会执行 __CFRunLoopDoSources0，当事件处理完后 runloop 进入休眠状态。 假设我们使用 dispatch_async，它会唤醒 runloop 并处理事件，但此时 __CFRunLoopDoSources0 已经执行完毕，不可能获取到 viewDidLoad 的调用栈。 performSelector 系列方法的底层也依赖于 runloop，因此它只是向当前的 runloop 提交了一个任务，但是依然要等待现有任务完成以后才能执行，所以拿不到实时的调用栈。 总而言之，一切涉及到 runloop，或者需要等待 viewDidLoad 执行完的方案都不可能成功。 三、Mach_thread回忆之前对栈的介绍，只要知道 StackPointer 和 FramePointer 就可以完全确定一个栈的信息，那有没有办法拿到所有线程的 StackPointer 和 FramePointer 呢？ 答案是肯定的，首先系统提供了 task_threads 方法，可以获取到所有的线程，注意这里的线程是最底层的 mach 线程，它和 NSThread 的关系稍后会详细阐述。 对于每一个线程，可以用 thread_get_state 方法获取它的所有信息，信息填充在 _STRUCT_MCONTEXT 类型的参数中。这个方法中有两个参数随着 CPU 架构的不同而改变，因此定义了 BS_THREAD_STATE_COUNT 和 BS_THREAD_STATE 这两个宏用于屏蔽不同 CPU 之间的区别。 在 _STRUCT_MCONTEXT 类型的结构体中，存储了当前线程的 Stack Pointer 和最顶部栈帧的 Frame Pointer，从而获取到了整个线程的调用栈。 在项目中，调用栈存储在 backtraceBuffer 数组中，其中每一个指针对应了一个栈帧，每个栈帧又对应一个函数调用，并且每个函数都有自己的符号名。 接下来的任务就是根据栈帧的 Frame Pointer 获取到这个函数调用的符号名。 四、相关 API 和数据结构由于在上面回溯线程调用栈拿到的是一组地址，所以这里进行符号化的输入输出应该分别是地址和符号。在实际操作中，我们需要依赖于 dyld 相关方法和数据结构： /* * Structure filled in by dladdr(). /typedef struct dl_info { const char \\dli_fname; /* Pathname of shared object / void \\dli_fbase; /* Base address of shared object / const char \\dli_sname; /* Name of nearest symbol / void \\dli_saddr; /* Address of nearest symbol */} Dl_info; extern int dladdr(const void , Dl_info ); DESCRIPTION These routines provide additional introspection of dyld beyond that provided by dlopen() and dladdr() \\_dyld\\_image_count() returns the current number of images mapped in by dyld. Note that using this count to iterate all images is not thread safe, because another thread may be adding or removing images dur-ing during ing the iteration. \\_dyld\\_get\\_image\\_header() returns a pointer to the mach header of the image indexed by image_index. If image_index is out of range, NULL is returned. \\_dyld\\_get\\_image\\_vmaddr_slide() returns the virtural memory address slide amount of the image indexed by image\\_index. If image\\_index is out of range zero is returned. \\_dyld\\_get\\_image\\_name() returns the name of the image indexed by image_index. The C-string continues to be owned by dyld and should not deleted. If image_index is out of range NULL is returned. 又为了要判断此次解析是否成功，所以接口设计为： bool jdy_symbolicateAddress(const uintptr_t addr, Dl_info *info) Dl_info 用来填充解析的结果。 五、算法思路对一个地址进行符号化解析说起来也是比较直接的，就是找到地址所属的内存镜像，然后定位该镜像中的符号表，最后从符号表中匹配目标地址的符号。 以下思路是描述一个大致的方向，并没有涵盖具体的细节，比如基于 ASLR 的偏移量： // 基于 ASLR 的偏移量 https://en.wikipedia.org/wiki/Address\\_space\\_layout_randomization /** * When the dynamic linker loads an image, * the image must be mapped into the virtual address space of the process at an unoccupied address. * The dynamic linker accomplishes this by adding a value “the virtual memory slide amount” to the base address of the image. */ ①、寻找包含地址的目标镜像 起初看到一个 API 还有点小惊喜，可惜 iPhone 上用不了： extern bool _dyld_image_containing_address(const void * address) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_3,__MAC_10_5,__IPHONE_NA,__IPHONE_NA); 所以得自己来判断。 A segment defines a range of bytes in a Mach-O file and the addresses and memory protection attributes at which those bytes are mapped into virtual memory when the dynamic linker loads the application. As such, segments are always virtual memory page aligned. A segment contains zero or more sections. 通过遍历每个段，判断目标地址是否落在该段包含的范围内： /** The segment load command indicates that a part of this file is to be* mapped into the task’s address space. The size of this segment in memory,* vmsize, maybe equal to or larger than the amount to map from this file,* filesize. The file is mapped starting at fileoff to the beginning of* the segment in memory, vmaddr. The rest of the memory of the segment,* if any, is allocated zero fill on demand. The segment’s maximum virtual* memory protection and initial virtual memory protection are specified* by the maxprot and initprot fields. If the segment has sections then the* section structures directly follow the segment command and their size is* reflected in cmdsize./struct segment_command { / for 32-bit architectures / uint32_t cmd; / LC_SEGMENT / uint32_t cmdsize; / includes sizeof section structs / char segname[16]; / segment name / uint32_t vmaddr; / memory address of this segment / uint32_t vmsize; / memory size of this segment / uint32_t fileoff; / file offset of this segment / uint32_t filesize; / amount to map from the file / vm_prot_t maxprot; / maximum VM protection / vm_prot_t initprot; / initial VM protection / uint32_t nsects; / number of sections in segment / uint32_t flags; / flags */}; /** * @brief 判断某个segment_command是否包含addr这个地址，基于segment的虚拟地址和段大小来判断 /bool jdy_segmentContainsAddress(const struct load_command cmdPtr, const uintptr_t addr) { if (cmdPtr-&gt;cmd == LC_SEGMENT) { struct segment_command *segPtr = (struct segment_command *)cmdPtr; if (addr &gt;= segPtr-&gt;vmaddr &amp;&amp; addr &lt; (segPtr-&gt;vmaddr + segPtr-&gt;vmsize)) { return true; } }} 这样一来，我们就可以找到包含目标地址的镜像文件了。 ②、定位目标镜像的符号表 由于符号的收集和符号表的创建贯穿着编译和链接阶段，这里就不展开了，而是只要确定除了代码段 _TEXT 和数据段 DATA 外，还有个 _LINKEDIT 段包含符号表： The __LINKEDIT segment contains raw data used by the dynamic linker, such as symbol, string, and relocation table entries. 所以现在我们需要先定位到 __LINKEDIT 段，同样摘自苹果官方文档： Segments and sections are normally accessed by name. Segments, by convention, are named using all uppercase letters preceded by two underscores (for example, _TEXT); sections should be named using all lowercase letters preceded by two underscores (for example, _text). This naming convention is standard, although not required for the tools to operate correctly. 我们通过遍历每个段，比较段名称是否和 __LINKEDIT 相同： usr/include/mach-o/loader.h #define SEG_LINKEDIT “__LINKEDIT” 接着来找符号表： 摘自《The Mac Hacker’s Handbook》： The LC_SYMTAB load command describes where to find the string and symbol tables within the __LINKEDIT segment. The offsets given are file offsets, so you subtract the file offset of the __LINKEDIT segment to obtain the virtual memory offset of the string and symbol tables. Adding the virtual memory offset to the virtual-memory address where the __LINKEDIT segment is loaded will give you the in-memory location of the string and sym- bol tables. 也就是说，我们需要结合 __LINKEDIT segment_command(见上面结构描述)和 LC_SYMTAB load_command(见下面结构描述)来定位符号表： /* * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD * “stab” style symbol table information as described in the header files * &lt;nlist.h&gt; and &lt;stab.h&gt;. /struct symtab_command { uint32_t cmd; / LC_SYMTAB / uint32_t cmdsize; / sizeof(struct symtab_command) / uint32_t symoff; / symbol table offset / uint32_t nsyms; / number of symbol table entries / uint32_t stroff; / string table offset / uint32_t strsize; / string table size in bytes */}; 如上述引用描述，LC_SYMTAB 和 _LINKEDIT 中的偏移量都是文件偏移量，所以要获得内存中符号表和字符串表的地址，我们先将 LC_SYMTAB 的 symoff 和 stroff 分别减去 LINKEDIT 的 fileoff 得到虚拟地址偏移量，然后再加上 _LINKEDIT 的vmoffset 得到虚拟地址。当然，要得到最终的实际内存地址，还需要加上基于 ASLR 的偏移量。 ③、在符号表中寻找和目标地址最匹配的符号 终于找到符号表了，代码： /** * @brief 在指定的符号表中为地址匹配最合适的符号，这里的地址需要减去vmaddr_slide /const JDY_SymbolTableEntry jdy_findBestMatchSymbolForAddress(uintptr_t addr, JDY_SymbolTableEntry *symbolTable, uint32_t nsyms) { // 1\\. addr &gt;= symbol.value; 因为addr是某个函数中的一条指令地址，它应该大于等于这个函数的入口地址，也就是对应符号的值； // 2\\. symbol.value is nearest to addr; 离指令地址addr更近的函数入口地址，才是更准确的匹配项； const JDY_SymbolTableEntry *nearestSymbol = NULL; uintptr\\_t currentDistance = UINT32\\_MAX; for (uint32_t symIndex = 0; symIndex &lt; nsyms; symIndex++) { uintptr\\_t symbolValue = symbolTable\\[symIndex\\].n\\_value; if (symbolValue &gt; 0) { uintptr_t symbolDistance = addr - symbolValue; if (symbolValue &lt;= addr &amp;&amp; symbolDistance &lt;= currentDistance) { currentDistance = symbolDistance; nearestSymbol = symbolTable + symIndex; } } } return nearestSymbol; } /* * This is the symbol table entry structure for 64-bit architectures. /struct nlist_64 { union { uint32_t n_strx; / index into the string table / } n_un; uint8_t n_type; / type flag, see below / uint8_t n_sect; / section number or NO_SECT / uint16_t n_desc; / see &lt;mach-o/stab.h&gt; / uint64_t n_value; / value of this symbol (or stab offset) */}; 找到匹配的 nlist 结构后，我们可以通过 .n_un.n_strx 来定位字符串表中相应的符号名。 六、揭秘 NSThread我们可以获取到所有线程以及它们的调用堆栈，但如果想单独获取某个线程的堆栈呢？如何建立 NSThread 线程和内核线程之间的联系？ GNUStep-base 的源码中包含了 Foundation 库的源码，不能确保 NSThread 是否采用它的实现，但至少可以从 NSThread.m 类中挖掘出很多有用信息。 很多文章都提到了 NSThread 是 pthread 的封装，这就涉及两个问题： pthread 是什么？ NSThread 如何封装 pthread？ pthread 中的字母 p 是 POSIX 的简写，POSIX 表示”可移植操作系统接口(Portable Operating System Interface)”。 每个操作系统都有自己的线程模型，它们提供的操作线程的 API 也不一样，这就给跨平台的线程管理带来了问题，而 POSIX 的目的就是提供抽象的 pthread 以及相关 API，这些 API 在不同操作系统中有不同的实现，但是完成的功能一致。 Unix 系统提供的 thread_get_state 和 task_threads 等方法，操作的都是内核线程，每个内核线程由 thread_t 类型的 id 来唯一标识，pthread 的唯一标识是 pthread_t 类型。 内核线程和 pthread 的转换(也即是 thread_t 和 pthread_t 互转)很容易，因为 pthread 诞生的目的就是为了抽象内核线程。 说 NSThread 封装了 pthread 并不是很准确，NSThread 内部只有很少的地方用到了 pthread。NSThread 的 start 方法简化版实现如下: - (void) start{ pthread_attr_t attr; pthread_t thr; errno = 0; pthread_attr_init(&amp;attr); if (pthread_create(&amp;thr, &amp;attr, nsthreadLauncher, self)) { // Error Handling }} 甚至于 NSThread 都没有存储新建 pthread 的 pthread_t 标识。 另一处用到 pthread 的地方就是 NSThread 在退出时，调用了 pthread_exit()。除此以外就很少感受到 pthread 的存在感了。 实际上所有的 performSelector 系列最终都会走到下面这个全能函数: - (void)performSelector:(SEL)aSelector onThread:(NSThread )thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString &gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)); 而它仅仅是一个封装，根据线程获取到 runloop，真正调用的还是 NSRunloop 的方法: - (void) performSelector:(SEL)aSelector target:(id)target argument:(id)argument order:(NSUInteger)order modes:(NSArray*)modes; 这些信息将组成一个 Performer 对象放进 runloop 等待执行。 七、NSThread 转内核 thread由于系统没有提供相应的转换方法，而且 NSThread 没有保留线程的 pthread_t，所以常规手段无法满足需求。 一种思路是利用 performSelector 方法在指定线程执行代码并记录 thread_t，执行代码的时机不能太晚，如果在打印调用栈时才执行就会破坏调用栈。最好的方法是在线程创建时执行，上文提到了利用 pthread_create 方法创建线程，它的回调函数 nsthreadLauncher 实现如下: static void *nsthreadLauncher(void* thread){ NSThread *t = (NSThread*)thread; [nc postNotificationName: NSThreadDidStartNotification object:t userInfo: nil]; [t _setName: [t name]]; [t main]; [NSThread exit]; return NULL;} 很神奇的发现系统居然会发送一个通知，通知名不对外提供，但是可以通过监听所有通知名的方法得知它的名字： @”_NSThreadDidStartNotification”，于是我们可以监听这个通知并调用 performSelector 方法。 一般 NSThread 使用 initWithTarget:Selector:object 方法创建。在 main 方法中 selector 会被执行，main 方法执行结束后线程就会退出。如果想做线程保活，需要在传入的 selector 中开启 runloop，详见我的这篇文章：深入研究 Runloop 与线程保活。 可见，这种方案并不现实，因为之前已经解释过，performSelector 依赖于 runloop 开启，而 runloop 直到 main 方法才有可能开启。 回顾问题发现，我们需要的是一个联系 NSThread 对象和内核 thread 的纽带，也就是说要找到 NSThread 对象的某个唯一值，而且内核 thread 也具有这个唯一值。 观察一下 NSThread，它的唯一值只有对象地址，对象序列号(Sequence Number) 和线程名称: &lt;NSThread: 0x144d095e0&gt;{number = 1, name = main} 地址分配在堆上，没有使用意义，序列号的计算没有看懂，因此只剩下 name。幸运的是 pthread 也提供了一个方法 pthread_getname_np 来获取线程的名字，两者是一致的，感兴趣的读者可以自行阅读 setName 方法的实现，它调用的就是 pthread 提供的接口。 这里的 np 表示 not POSIX，也就是说它并不能跨平台使用。 于是解决方案就很简单了，对于 NSThread 参数，把它的名字改为某个随机数(我选择了时间戳)，然后遍历 pthread 并检查有没有匹配的名字。查找完成后把参数的名字恢复即可。 八、主线程转内核 thread本来以为问题已经圆满解决，不料还有一个坑，主线程设置 name 后无法用 pthread_getname_np 读取到。 好在我们还可以迂回解决问题：事先获得主线程的 thread_t，然后进行比对。 上述方案要求我们在主线程中执行代码从而获得 thread_t，显然最好的方案是在 load 方法里： static mach_port_t main_thread_id;+ (void)load { main_thread_id = mach_thread_self();} 九、学习文章iOS中线程Call Stack的捕获和解析（一） iOS中线程Call Stack的捕获和解析（二） 获取任意线程调用栈的那些事 BSBacktraceLogger","tags":[]},{"title":" Bitcode（2）\t\t","date":"2019-01-11T10:42:40.000Z","path":"2019/01/11/bitcode-ef-bc-882-ef-bc-89/","text":"原文：http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/ 前言苹果在 WWDC2015 大会上引入了 bitcode，随后在 Xcode7 中添加了在二进制中嵌入 bitcode(Enable Bitcode) 的功能，并且默认设置为开启状态。 什么是 BitcodeBitcode 是由 LLVM 引入的一种中间代码(Intermediate Representation，简称 IR)，它是源代码被编译为二进制机器码过程中的中间表示形态，它既不是源代码，也不是机器码。从代码组织结构上看它比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。 LLVM 是一套优秀的编译器框架，目前 NDK/Xcode 均采用 LLVM 作为默认的编译器。LLVM 的编译过程可以简单分为 3 个部分: 前端(Frontend)负责把各种类型的源代码编译为中间表示，也就是 Bitcode。在 LLVM 体系内，不同的语言有不同的编译器前端，最常见的如 clang 负责 c/c++/oc 的编译，flang 负责 fortran 的编译，swiftc 负责 swift 的编译等等 优化(Optimizer)负责对 Bitcode 进行各种类型的优化，将 bitcode 代码进行一些逻辑等价的转换，使得代码的执行效率更高，体积更小，比如 DeadStrip/SimplifyCFG。 后端(Backend)也叫 CodeGenerator，负责把优化后的 bitcode 编译为指定目标架构的机器码，比如 X86Backend 负责把 bitcode 编译为 x86 指令集的机器码。 在这个体系中，不同语言的源代码将会被转化为统一的 bitcode 格式，三个模块可以充分复用，防止重复造轮子。如果要开发一门新的语言 x，只需要造一个 x 语言的前端，将 x 语言的源代码编译为 bitcode，优化和后端的事情完全不用管。同理，如果新的芯片架构问世，则只需要基于 LLVM 重新写一套目标平台的后端，非常方便。 初探既然 bitcode 是代码的一种表示形式，因此它也会有自己的一套独立的语法，可以通过一个简单的例子来一探究竟，这里以 clang为例，swift 的操作和结果可能稍有不同。 ①、先编写一段 c 语言代码(test.c)： #include &lt;stdio.h&gt;int main(void){ printf(“hello, world.\\n”); return 0;} ②、通过以下命令可以将源代码编译为 object 文件。 $ clang -c test.c -o test.o$ file test.otest.o: Mach-O 64-bit object x86_64 这个命令同时完成了前端、优化、后端，可以通过 -emit-llvm -c 将前端这一步单独拆出来，这样就可以看到 bitcode 了。 $ clang -emit-llvm -c test.c -o test.bc # 将源代码编译为 bitcode $ clang -c test.bc -o test.bc.o # 将 bitcode 编译为 object $ clang -emit-llvm -c test.c -o test.bc$ file test.bctest.bc: LLVM bitcode, wrapper x86_64$ clang -c test.bc -o test.bc.o$ file test.bc.otest.bc.o: Mach-O 64-bit object x86_64$ md5 test.bc.o test.oMD5 (test.bc.o) = 9b90026b9c1d3fa0211e106ff921e9bdMD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bd bitcode 文件使用后缀名 .bc表示。可以看到，将 bitcode 文件作为 clang 的输入，编出的 object 文件跟直接编源代码是相同的。 ③、查看 bitcode 文件。 $ hexdump -C test.bc | head00000000 de c0 17 0b 00 00 00 00 14 00 00 00 90 09 00 00 |…………….|00000010 07 00 00 01 42 43 c0 de 35 14 00 00 07 00 00 00 |….BC..5…….|00000020 62 0c 30 24 94 96 a6 a5 f7 d7 7f 4f d3 3e ed df |b.0$…….O.&gt;..|00000030 bd 6f ff b4 10 05 c8 14 00 00 00 00 21 0c 00 00 |.o……….!…|00000040 58 02 00 00 0b 82 20 00 02 00 00 00 13 00 00 00 |X….. ………|00000050 07 81 23 91 41 c8 04 49 06 10 32 39 92 01 84 0c |..#.A..I..29….|00000060 25 05 08 19 1e 04 8b 62 80 10 45 02 42 92 0b 42 |%……b..E.B..B|00000070 84 10 32 14 38 08 18 4b 0a 32 42 88 48 90 14 20 |..2.8..K.2B.H.. |00000080 43 46 88 a5 00 19 32 42 e4 48 0e 90 11 22 c4 50 |CF….2B.H…”.P|00000090 41 51 81 8c e1 83 e5 8a 04 21 46 06 51 18 00 00 |AQ…….!F.Q…| 通过 hexdump 可以看出它并非文本文件，全是乱码，这样的文件是很难分析的。其实 LLVM 提供了 llvm-dis/llvm-as 两个工具，用于将 bitcode 在二进制格式和可读的文本格式之间进行相互的转化，但遗憾的是 Xcode 的编译器工具链中并没有附带这个命令，因此需要另寻他法。 ④、我们知道通过编译器的 -S 参数可以将源代码编译为文本的 assembly 代码，不进行最后一步 assembly 到机器码的翻译工作，而 assembly 和机器码是等价的两种表示形式，bitcode 同样也是有文本和二进制(bitcode)两种等价表示形式，clang 也为 bitcode 保留了这一特性，可以通过 -emit-llvm -S 将源代码编译为文本格式的 bitcode， 也叫做 LLVM Assembly Language，一般后缀名使用 .ll。 $ clang -emit-llvm -S test.c -o test.ll # 将源代码编译为 LLVM Assembly test.ll 可用文本编辑器打开，全部内容： ; ModuleID = ‘test.c’source_filename = “test.c”target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”target triple = “x86_64-apple-macosx10.13.0” @.str = private unnamed_addr constant [15 x i8] c”hello, world.\\0A\\00”, align 1 ; Function Attrs: noinline nounwind ssp uwtabledefine i32 @main() #0 { %1 = alloca i32, align 4 store i32 0, i32 %1, align 4 %2 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([15 x i8], [15 x i8] @.str, i32 0, i32 0)) ret i32 0} declare i32 @printf(i8*, …) #1 attributes #0 = { noinline nounwind ssp uwtable “correctly-rounded-divide-sqrt-fp-math”=”false” “disable-tail-calls”=”false” “less-precise-fpmad”=”false” “no-frame-pointer-elim”=”true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=”false” “no-jump-tables”=”false” “no-nans-fp-math”=”false” “no-signed-zeros-fp-math”=”false” “no-trapping-math”=”false” “stack-protector-buffer-size”=”8” “target-cpu”=”penryn” “target-features”=”+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87” “unsafe-fp-math”=”false” “use-soft-float”=”false” }attributes #1 = { “correctly-rounded-divide-sqrt-fp-math”=”false” “disable-tail-calls”=”false” “less-precise-fpmad”=”false” “no-frame-pointer-elim”=”true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=”false” “no-nans-fp-math”=”false” “no-signed-zeros-fp-math”=”false” “no-trapping-math”=”false” “stack-protector-buffer-size”=”8” “target-cpu”=”penryn” “target-features”=”+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87” “unsafe-fp-math”=”false” “use-soft-float”=”false” } !llvm.module.flags = !{!0}!llvm.ident = !{!1} !0 = !{i32 1, !”PIC Level”, i32 2}!1 = !{!”Apple LLVM version 9.0.0 (clang-900.0.39.2)”} 这样看上去就很清晰明了了，我们重点关注下函数定义这部分，加了一些注释方便理解。 ; 定义全局常量 @.str, 内容初始化为 ‘hello, world.\\n\\0’@.str = private unnamed_addr constant [15 x i8] c”hello, world.\\0A\\00”, align 1 ; Function Attrs: noinline nounwind optnone ssp uwtabledefine i32 @main() #0 { ; 定义函数 @main，返回值为i32类型 %1 = alloca i32, align 4 ; 声明变量 %1 = 分配i32的内存空间 store i32 0, i32 %1, align 4 ; 将 0 存入 %1 的内存空间 %2 = call i32 (i8, …) @printf(i8 getelementptr inbounds ([15 x i8], [15 x i8] @.str, i32 0, i32 0)) ; 调用 @printf 函数，并将 @.str 的地址作为参数 ret i32 0 ; 返回 0} declare i32 @printf(i8*, …) #1 ; 声明一个外部函数 @printf 这段代码不难阅读， 其含义和逻辑与我们所写的源代码基本一致，只是用了另外一种语法表示出来。因为没有经过优化，函数中的前两条语句其实是多余的，这在之后的优化阶段会被消除(dead_strip)。bitcode 的具体语法在此不做展开，虽然这个例子看起来非常简单易懂，但真实场景中，bitcode 的语法远比这个复杂，有兴趣的同学可以直接阅读 LLVM Language Reference Manual。 Enable Bitcode在对 bitcode 有了一个直观的认识之后，再来看一下 Apple 围绕 bitcode 做了什么。Xcode 中对 Enable Bitcode 这个配置的解释是 Xcode Help： Enable Bitcode (ENABLE_BITCODE)Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode. 具体展开一下： 开启此设置将会在支持的平台和架构中开启 bitcode 当前支持的平台主要是 iPhoneOS(armv7/arm64)，watchOS 等； 注意不包括 iPhoneSimulator(i386/x86_64) 和 macos，也就是说模拟器架构下不会编出 bitcode。这个限制只是 Xcode 自身的限制，并非编译器的限制，我们使用编译器提供的命令行工具自行操作仍然可以编译出这些架构下的bitcode，本文中的示例就是基于 macos 平台/x86_64 架构。 进行 Archive 时，bitcode 会被嵌入到链接后的二进制文件中，用于提交给 App Store Enable Bitcode 设置为 YES 时，从编译日志中可以看出，Archive 时多了一个编译参数 -fembed-bitcode 进行其他类型的 Build(非 Archive)时，编译器只会检查是否满足开启 bitcode 的条件，但并不会真正生成 bitcode 非 Archive 编译时，Enable Bitcode 将会增加编译参数 -fembed-bitcode-marker， 只是在 object 文件中做了标记，表明可以有 bitcode，但是现在暂时没有带上它。因为本地编译调试时并不需要 bitcode，只有 AppStore 需要这玩意儿，去掉这个不必要的步骤，会加快编译速度。 这就是为什么有的同学在开发 SDK 时，明明开启了 Enable Bitcode，交给客户后客户却说：你的 sdk 里没有bitcode，因为你没有使用 Archive 方式打包。 当然，你可以将 Enable Bitcode 设置为 NO， 然后在 Other Compiler Flags 和 Other Linker Flags 中手动为真机架构添加 -fembed-bitcode 参数，这样任何类型的 Build 都会带上 bitcode。 接下来看一下 Enable Bitcode 之后，编译出的文件发生了什么变化， 直接在 clang 的参数中添加 -fembed-bitcode 即可。 $ clang -fembed-bitcode -c test.c -o test_bitcode.o 编译之后可以通过 otool 工具查看 object 文件的结构，此时你需要对 Mach-O 文件有一些基本的了解。 otool -l test_bitcode.otest_bitcode.o:Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedfacf 16777223 3 0x00 1 4 672 0x00002000Load command 0 cmd LC_SEGMENT_64 cmdsize 552 segname vmaddr 0x0000000000000000 vmsize 0x0000000000000a88 fileoff 704 filesize 2696 maxprot 0x00000007 initprot 0x00000007 nsects 6 flags 0x0Section sectname bitcode segname LLVM addr 0x0000000000000040 size 0x00000000000009a0 offset 768 align 2^4 (16) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Section sectname cmdline segname LLVM addr 0x00000000000009e0 size 0x0000000000000042 offset 3232 align 2^4 (16) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Load command 1 cmd LC_VERSION_MIN_MACOSX cmdsize 16 version 10.13 sdk n/aLoad command 2 cmd LC_SYMTAB cmdsize 24 symoff 3424 nsyms 4 stroff 3488 strsize 56Load command 3 cmd LC_DYSYMTAB cmdsize 80 ilocalsym 0 nlocalsym 2 iextdefsym 2 nextdefsym 1 iundefsym 3 nundefsym 1 tocoff 0 ntoc 0 modtaboff 0 nmodtab 0 extrefsymoff 0 nextrefsyms 0 indirectsymoff 0 nindirectsyms 0 extreloff 0 nextrel 0 locreloff 0 nlocrel 0 或者使用 MachOView 软件。 可以发现生成的 object 文件中多了两个 Section，分别是 __LLVM,__bitcode 和 __LLVM,__cmdline，并且 otool 的输出中给出了这两个 section 在 object 文件中的偏移和大小，通过 dd 命令可以很方便地将这两个 Section 提取出来（待验证） $ dd bs=1 skip=768 count=0x00000000000009a0 if=test_bitcode.o of=test_bitcode.o.bc $ dd bs=1 skip=3608 count=0x0000000000000042 if=test_bitcode.o of=test_bitcode.o.cmdline 还有一种更便捷的方式，Xcode 提供的 segedit 命令可以直接将指定的 Section 导出，只需要给定 Section 的名字，和上面的命令效果是一样的，并且更为方便。 $ segedit -extract __LLVM __bitcode test_bitcode.o.bc -extract __LLVM __cmdline test_bitcode.o.cmdline test_bitcode.o $ segedit -extract __LLVM __bitcode test_bitcode.o.bc \\> -extract __LLVM __cmdline test_bitcode.o.cmdline \\> test_bitcode.o 观察导出的文件： $ file test_bitcode.o.bctest_bitcode.o.bc: LLVM bitcode, wrapper x86_64$ cat test_bitcode.o.cmdline | tr ‘\\0’ ‘ ‘-triple x86_64-apple-macosx10.13.0 -emit-obj -disable-llvm-passes$ md5 test.bc test_bitcode.o.bcMD5 (test.bc) = 718d88a109ba9e1a75119b04eac566f8MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828 不难得出结论： object 文件中嵌入的 __LLVM,__bitcode 正是完整的，未经任何加密或者压缩的 bitcode 文件，通过 -fembed-bitcode 参数，clang 把对应的 bitcode 文件整个嵌入到了 object 文件中。 __LLVM,__cmdline 是编译这个文件所用到的参数，如果要通过导出的 bitcode 重新编译这个 object 文件，必须带上这些参数 导出的参数是 cc1 也就是 clang 中真正”前端”部分的参数(clang 命令其实是整合了各个环节，所以 clang 一个命令可以从源代码编出可执行文件)，所以编译时要带上 -cc1 导出的 bitcode 文件似乎和直接编译的 bitcode 不一样，先留个疑问，后面再研究。 首先， 来测试一下导出的 bitcode 文件结合 cmdline 能否编译出正常的 object： $ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes test_bitcode.o.bc -o test_rebuild.owarning: overriding the module target triple with x86_64-apple-macosx10.14.01 warning generated.$ file test_rebuild.otest_rebuild.o: Mach-O 64-bit object x86_64$ md5 test.o test_rebuild.oMD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bdMD5 (test_rebuild.o) = d647be2f0a5cd4ff96b815aef8af5943 没有任何问题，并且通过内嵌的 bitcode 编译出的 object 文件与直接从源代码编译出来的 object 完全一样！ 回到遗留的问题：为什么导出的 bitcode 文件和直接编译的 bitcode 会不一样？明明编出的 object 都是一模一样的！ 这是因为二进制的 bitcode 文件中还保存了一些与实际代码无关的 meta 信息。如果能将 bitcode 转换为文本格式，将能更直观地进行对比。前面已经提到，xcode 中并没有附带转换工具，但是我们依然可以通过 clang 来完成这一操作，还记得前面用过的 -emit-llvm -S 吗？ $ clang -emit-llvm -S test_bitcode.o.bc -o test_bitcode.o.ll 神奇吧？输入虽然已经是 bitcode 了，并非源代码，但是 clang 也能”编译”出 LLVM Assembly。其实 clang 内部是先将输入的文件转换成 Module 对象，然后再执行对应的处理： 如果输入是源代码，会先进行前端编译，得到一个 Module； 如果输入是 bitcode 或者 LLVM Assembly，那么直接进行 parse 操作，即可得到 Module 对象； 如果输出类型是 LLVM Assembly，将 Module 对象序列化为文本格式； 如果输出类型是 bitcode，则将 Module 对象序列化为二进制格式 所以完全可以通过 clang 进行 bitcode 和 LLVM Assembly 的相互转换。 现在，可以对比一下前后两次生成的.ll文件：（待验证） $ diff test_bitcode.o.ll test.ll $ diff /Users/cykj/Desktop/Chart/Chart/test_bitcode.o.ll /Users/cykj/Desktop/Chart/Chart/test.ll1c1&lt; ; ModuleID = ‘test_bitcode.o.bc’---> ; ModuleID = ‘test.c’ 除了 ModuleID，也就是来源的文件名以外，其余部分完全相同，这也就解决了前面的疑虑。 再来回顾一下，前文提到非 Archive 类型的 build，比如直接 ⌘ + B，即使开启了 bitcode，也不会编出 bitcode，那么会产生什么样的文件呢？通过观察编译日志可以看出 xcode 在此时使用了 -fembed-bitcode-marker 这样一个参数，试一下： $ clang -fembed-bitcode-marker -c test.c -o test_bitcode_marker.o$ otool -l test_bitcode_marker.oSection sectname bitcode segname LLVM addr 0x0000000000000039 size 0x0000000000000001 offset 761 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0Section sectname cmdline segname LLVM addr 0x000000000000003a size 0x0000000000000001 offset 762 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0$ objdump -s -section=__bitcode test_bitcode_marker.o test_bitcode_marker.o: file format Mach-O 64-bit x86-64 Contents of section __bitcode: 0039 00 这样的方式编译出的文件结构与 -fembed-bitcode 的结果是一样的，唯一的区别就是 __LLVM,__bitcode 和 __LLVM,__cmdline 的内容并没有将实际的 bitcode 文件和编译参数嵌入进来，取而代之的一个字节的占位符 0x00 Bitcode Bundle已经搞清楚了 bitcode 是如何嵌入在 object 文件里的，但是 object 只是编译过程的中间产物，真正运行的代码是多个 object文件经过链接之后的可执行文件，接下来要分析下 object 中嵌入的 bitcode 是如何被链接的： $ clang test.o -o test # 链接原始 object $ clang -fembed-bitcode test_bitcode.o -o test_bitcode # 链接带 bitcode 的object $ clang test.o -o test$ ./testhello, world.$ clang -fembed-bitcode test_bitcode.o -o test_bitcode$ ./test_bitcodehello, world.$ otool -l test_bitcodeSection sectname bundle segname LLVM addr 0x0000000100002000 size 0x0000000000001264 offset 8192 align 2^0 (1) reloff 0 nreloc 0 flags 0x00000000 reserved1 0 reserved2 0 object 中的 __LLVM,__bitcode 和 __LLVM,__cmdline不见了，取而代之的是一个 __LLVM,__bundle 的 Section， 通过名字可以基本推断出 object 中的 bitcode 被打包在了一起，把它从可执行文件中 dump 出来一探究竟： $ segedit -extract __LLVM __bundle bundle test_bitcode$ file bundlebundle: xar archive version 1, SHA-1 checksum 这个 bundle 文件是一个 xar 格式的压缩包，xar 格式包含了一个 xml 格式的文件头(TOC)，里面用于存放各种文件的基本属性以及一些附加附加信息，可以通过 xar 命令查看并解压： $ xar -d toc.xml -f bundle # 导出文件头 $ xar -x -C bundle.extract -f bundle # 解压文件 $ xar -d toc.xml -f bundle$ mkdir bundle.extract$ xar -x -C bundle.extract -f bundle$ ls bundle.extract1$ file bundle.extract/1bundle.extract/1: LLVM bitcode, wrapper x86_64$ md5 bundle.extract/1 test_bitcode.o.bcMD5 (bundle.extract/1) = 1b3bd72eb7f380cfd6c6528674d90828MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828 查看导出的 toc.xml &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 1.0 x86_64 MacOSX 10.13.0 {SDKPATH}/usr/lib/libSystem.B.dylib -execute -macosx_version_min 10.13.0 -e _main -executable_path test_bitcode 20 0 2019-01-11T10:21:54 1 file d64be6fc7a9551555ccb4e8a78a87864cbef40b7 d64be6fc7a9551555ccb4e8a78a87864cbef40b7 2464 20 2464 Bitcode -triple x86_64-apple-macosx10.13.0 -emit-obj -disable-llvm-passes header 的结构非常清晰，内容基本包含这些： ld 的基本参数，我们链接时使用的是 clang，实际上 clang 内部调用了 ld，这里记录的是 ld的参数 version: bitcode bundle 的版本号 architecture: 目标架构 platform: 目标平台 sdkversion: sdk版本 dylibs: 链接的动态库 link-options: 其他链接参数 文件目录 checksum类型 创建时间 每个文件的信息 文件名，这里并非原始文件名，而是按照链接时输入的顺序被重命名为数字序号 基本属性，包括 checksum、偏移、大小等 文件类型，一般是 Bitcode，还有两种特殊类型，Object 以及 Bundle 编译器类型(clang/swift)及编译参数，这部分就是 object 文件中 __LLVM,__cmdline 的内容 下一个文件的信息(如有) 重复 从 bundle 中解压出来的文件，就是 object 中嵌入的 bitcode，通过 MD5 对比可以看出链接时对 bitcode 文件自身没有做任何处理。可以注意到，用于编译各个 bitcode 文件的参数(cmdline)被放进了 TOC 中文件描述的区域，而 TOC 中多出了一个部分用于存放链接时所需要的信息和必要的参数，有了这些信息， 我们不难通过 bitcode 重新编译，并链接出一个新的可执行文件： # 首先根据文件目录，将解压出的每一个bitcode文件编译为object$ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes bundle.extract/1 -o bundle.extract/1.o -x ir# 由于解压出的文件没有后缀名，clang无法判断输入文件的格式，因此使用 -x ir 强制指定输入文件为ir格式# 也可以将其重命名为1.bc，这样就不用指定-x ir # 根据toc.xml中提供的链接参数，将所有object文件链接为可执行文件，本例中只有一个文件$ ld \\ -arch x86_64 # architecture \\ -syslibroot `xcrun –show-sdk-path –sdk macosx` # platform \\ -sdk_version 10.14.0 # sdkversion \\ -lSystem # dylibs \\ -execute # link-options \\ -macosx_version_min 10.14.0 # link-options \\ -e _main # link-options \\ -executable_path test # link-options \\ -o test_rebuild # 输出文件 \\ bundle.extract/1.o # 输入文件$ ./test_rebuildhello, world.$ md5 test_rebuild testMD5 (test_rebuild) = f4786288582decf2b8a1accb1aaa4a3cMD5 (test) = f4786288582decf2b8a1accb1aaa4a3c 看！我们成功利用 bitcode 重新编了一份一模一样的可执行文件出来。 现在可以理解，为什么苹果要强推 bitcode 了吧？开发者把 bitcode 提交到 iTunes Connect 之后，如果苹果发布了使用新芯片的 iPhone，支持更高效的指令，开发者不需要做任何操作，iTunes Connect 自己就可以编译出针对新产品优化过的 app 并通过 App Store 分发给用户，不需要开发者自己重新打包上架，这样一来苹果的商店生态就不需要依赖开发者的积极性了。 使用 Bitcode 导出 ipa前面已经提到，如果要以 bitcode 方式上传 app，必须在开启 bitcode 的状态下，进行 Archive 打包，才会得到带有 bitcode 的 app。大部分 app 都会依赖一堆第三方 sdk，如果此时项目里依赖的某一个或者几个 sdk 没有开启 bitcode，那么很遗憾，Xcode 会拒绝编译并给出类似这样的提示： ld: ‘name_of_the_library_or_framework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. ld: bitcode bundle could not be generated because ‘name_of_the_library_or_framework’ was built without full bitcode. 第一种提示表示这个第三方库完全没有开启 bitcode，而第二种提示表示它只有 bitcode-marker，也就是说它的开发者虽然在工程配置中设置了 Enable Bitcode 为 YES，但并没有以 Archive 方式编译，可能只是 ⌘ + B，然后顺手把 Products 拷贝出来交付了。 遇到这种问题，也需要分两种情况来看： 如果这个库是在本地编译的， 比如自己项目里或者子项目里的 target，或者通过 Pods 引入了源代码，那么这个 target 一定没有开启 bitcode，在工程中找到这个 target 的 Build Settings 把 Enable Bitcode 置为 YES 即可； 但如果是第三方提供的二进制库文件，则需要联系 sdk 的提供方确认是否能提供带 bitcode 的版本，否则只能关闭自己项目中的 bitcode。这也是 bitcode 时至今日都没有得到大面积应用的最大障阻碍。 当使用 Archive 方式打包出带有 bitcode 的包时，你会发现这个包里的二进制文件比没有开启 bitcode 时大出了许多，多出来的其实就是 bitcode 的体积，并且 bitcode 的体积，一般要比二进制文件本身还要大出许多。 $ ls -al test.o test_bitcode.o test.bc-rw-r–r– 1 xelz staff 2848 12 19 18:42 test.bc-rw-r--r--@ 1 xelz staff 784 12 19 18:24 test.o-rw-r--r--@ 1 xelz staff 3920 12 19 18:59 test_bitcode.o$ ls -al test test_bitcode-rwxr-xr-x@ 1 xelz staff 8432 12 19 21:38 test-rwxr-xr-x@ 1 xelz staff 16624 12 19 20:50 test_bitcode 当然，这部分内容并不会导致用户下载到的 APP 变大，因为用户下载到的代码中只会有机器码，不会包含 bitcode。有的项目开启 bitcode 之后会发现二进制的体积增大到超出了苹果对二进制体积的限制，但是完全不用担心，苹果的限制只是针对TEXT 段，而嵌入的 bitcode 是存储在单独的 LLVM 段，不在苹果的限制范围内。 打包出带有 bitcode 的 xcarchive 之后，可以导出 Development IPA 进行上线前的最终测试，或者上传到 App Store Connect进行提审上架。进行此类操作时会发现 Xcode Organizer 中多出了 bitcode 相关的选项： 导出 Development 版本时，可以勾选 Rebuild from Bitcode，这时导出会变的很慢，因为 Xcode 在后台通过 bitcode 重新编译代码，这样导出的 ipa 最接近最终用户从 AppStore 下载的版本，为什么说是接近呢，因为苹果使用的编译器版本很可能和本地 Xcode 不一样，并且苹果可能在编译时增加额外的优化步骤，这些都会导致苹果编译后的二进制文件跟本地编译的版本产生差异。而如果不勾选此选项，则会直接使用 Archive 时编译出的二进制代码，并把 bitcode 从二进制中去除以减小体积。 导出 Store 版本或者直接进行上传时，默认会勾选 Include bitcode for iOS content，如果不勾选，则跟前面类似，将会去除内嵌的 bitcode，直接使用本地编译的二进制代码。 勾选后生成的 ipa 中将会只包含 bitcode，这个 ipa 是无法重签后安装到设备上进行测试的，因为里面没有任何可执行代码： TEXT 和 DATA 等跟已编译好的二进制相关的内容会被全部去除，但是会保留 __LINKEDIT 中的部分信息，其中最重要的就是 LC_UUID，用于在重编之后能跟原始的符号文件对应起来，如果用户下载经过 AppStore 重编之后的 app 发生了Crash，得到的 backtrace 地址是跟本地编译的版本对应不起来的，需要结合 UUID 和从 App Store Connect 下载的dSYM 文件才能得到符号化的 crash 信息。 Thread 0 name: Dispatch queue: com.apple.main-threadThread 0 Crashed:0 libsystem_kernel.dylib 0x23269c84 __pthread_kill + 81 libsystem_pthread.dylib 0x2330bb46 pthread_kill + 622 libsystem_c.dylib 0x232000c4 abort + 1083 libc++abi.dylib 0x22d7a7dc __cxa_bad_cast + 04 libc++abi.dylib 0x22d936a0 default_unexpected_handler() + 05 libobjc.A.dylib 0x22d9f098 _objc_terminate() + 1926 libc++abi.dylib 0x22d90e16 std::terminate(void ()()) + 787 libc++abi.dylib 0x22d905f4 __cxxabiv1::exception_cleanup_func(_Unwind_Reason_Code, _Unwind_Exception) + 08 libobjc.A.dylib 0x22d9eed2 objc_exception_throw + 2509 CoreFoundation 0x234e831e -[NSArrayI objectAtIndex:] + 18610 test 0x000791f2 __hidden#5_ (__hidden#43_:35)11 libdispatch.dylib 0x2316fdd6 _dispatch_call_block_and_release + 1012 libdispatch.dylib 0x231794e6 _dispatch_after_timer_callback + 6613 libdispatch.dylib 0x2316fdc2 _dispatch_client_callout + 2214 libdispatch.dylib 0x231826d2 _dispatch_source_latch_and_call + 204215 libdispatch.dylib 0x23171d16 _dispatch_source_invoke + 73816 libdispatch.dylib 0x231741fe _dispatch_main_queue_callback_4CF + 39417 CoreFoundation 0x23594fc4 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 818 CoreFoundation 0x235934be __CFRunLoopRun + 159019 CoreFoundation 0x234e5bb8 CFRunLoopRunSpecific + 51620 CoreFoundation 0x234e59ac CFRunLoopRunInMode + 10821 GraphicsServices 0x2475faf8 GSEventRunModal + 16022 UIKit 0x277d1fb4 UIApplicationMain + 14423 test 0x000797de main (__hidden#317_:14)24 libdyld.dylib 0x23198872 start + 2 ---------------------------------------------------------------------- File: /Users/Breeze/Desktop/crash/test.app.dSYM/Contents/Resources/DWARF/test (armv7)----------------------------------------------------------------------.debug_info contents: 0x00000000: Compile Unit: length = 0x00000073 version = 0x0002 abbr_offset = 0x00000000 addr_size = 0x04 (next CU at 0x00000077) 0x0000000b: TAG_compile_unit [1] * AT_producer( “__hidden#30_” ) AT_language( DW_LANG_ObjC ) AT_name( “__hidden#43_” ) AT_stmt_list( 0x00000000 ) AT_comp_dir( “__hidden#41_“ ) AT_APPLE_optimized( 0x01 ) AT_APPLE_major_runtime_vers( 0x02 ) AT_low_pc( 0x0000a0b0 ) AT_high_pc( 0x0000a206 ) 0x00000028: TAG_subprogram [2] AT_low_pc( 0x0000a0b0 ) AT_high_pc( 0x0000a154 ) AT_name( “__hidden#45_” ) 0x00000035: TAG_subprogram [2] AT_low_pc( 0x0000a154 ) AT_high_pc( 0x0000a166 ) AT_name( “__hidden#1_” ) 0x00000042: TAG_subprogram [2] AT_low_pc( 0x0000a168 ) AT_high_pc( 0x0000a16e ) AT_name( “__hidden#2_” ) 0x0000004f: TAG_subprogram [2] AT_low_pc( 0x0000a170 ) AT_high_pc( 0x0000a176 ) AT_name( “__hidden#3_” ) 0x0000005c: TAG_subprogram [2] AT_low_pc( 0x0000a178 ) AT_high_pc( 0x0000a1a4 ) AT_name( “__hidden#44_” ) 0x00000069: TAG_subprogram [2] AT_low_pc( 0x0000a1a4 ) AT_high_pc( 0x0000a206 ) AT_name( “__hidden#42_” ) 0x00000076: NULL 0x00000077: Compile Unit: length = 0x000000db version = 0x0002 abbr_offset = 0x00000000 addr_size = 0x04 (next CU at 0x00000156) 0x00000082: TAG_compile_unit [1] * AT_producer( “__hidden#30_” ) AT_language( DW_LANG_ObjC ) AT_name( “__hidden#301_” ) AT_stmt_list( 0x000000bf ) AT_comp_dir( “__hidden#41_“ ) AT_APPLE_optimized( 0x01 ) AT_APPLE_major_runtime_vers( 0x02 ) AT_low_pc( 0x0000a208 ) AT_high_pc( 0x0000a796 ) 0x0000009f: TAG_subprogram [2] AT_low_pc( 0x0000a208 ) AT_high_pc( 0x0000a20c ) AT_name( “__hidden#315_” ) 0x000000ac: TAG_subprogram [2] AT_low_pc( 0x0000a20c ) AT_high_pc( 0x0000a20e ) AT_name( “__hidden#314_” ) 0x000000b9: TAG_subprogram [2] AT_low_pc( 0x0000a210 ) AT_high_pc( 0x0000a212 ) AT_name( “__hidden#313_” ) 0x000000c6: TAG_subprogram [2] AT_low_pc( 0x0000a214 ) AT_high_pc( 0x0000a216 ) AT_name( “__hidden#312_” ) 0x000000d3: TAG_subprogram [2] AT_low_pc( 0x0000a218 ) AT_high_pc( 0x0000a21a ) AT_name( “__hidden#311_” ) 0x000000e0: TAG_subprogram [2] AT_low_pc( 0x0000a21c ) AT_high_pc( 0x0000a22c ) AT_name( “__hidden#310_” ) 0x000000ed: TAG_subprogram [2] AT_low_pc( 0x0000a22c ) AT_high_pc( 0x0000a2a2 ) AT_name( “__hidden#309_” ) 0x000000fa: TAG_subprogram [2] AT_low_pc( 0x0000a2a4 ) AT_high_pc( 0x0000a372 ) AT_name( “__hidden#308_” ) 0x00000107: TAG_subprogram [2] AT_low_pc( 0x0000a374 ) AT_high_pc( 0x0000a5b6 ) AT_name( “__hidden#307_” ) 0x00000114: TAG_subprogram [2] AT_low_pc( 0x0000a5b8 ) AT_high_pc( 0x0000a65c ) AT_name( “__hidden#306_” ) 0x00000121: TAG_subprogram [2] AT_low_pc( 0x0000a65c ) AT_high_pc( 0x0000a702 ) AT_name( “__hidden#305_” ) 0x0000012e: TAG_subprogram [2] AT_low_pc( 0x0000a704 ) AT_high_pc( 0x0000a714 ) AT_name( “__hidden#304_” ) 0x0000013b: TAG_subprogram [2] AT_low_pc( 0x0000a714 ) AT_high_pc( 0x0000a73a ) AT_name( “__hidden#302_” ) 0x00000148: TAG_subprogram [2] AT_low_pc( 0x0000a73c ) AT_high_pc( 0x0000a796 ) AT_name( “__hidden#300_” ) 0x00000155: NULL 0x00000156: Compile Unit: length = 0x00000032 version = 0x0002 abbr_offset = 0x00000000 addr_size = 0x04 (next CU at 0x0000018c) 0x00000161: TAG_compile_unit [1] * AT_producer( “__hidden#30_” ) AT_language( DW_LANG_ObjC ) AT_name( “__hidden#317_” ) AT_stmt_list( 0x00000320 ) AT_comp_dir( “__hidden#41_“ ) AT_APPLE_optimized( 0x01 ) AT_APPLE_major_runtime_vers( 0x02 ) AT_low_pc( 0x0000a798 ) AT_high_pc( 0x0000a7f4 ) 0x0000017e: TAG_subprogram [2] AT_low_pc( 0x0000a798 ) AT_high_pc( 0x0000a7f4 ) AT_name( “__hidden#316_” ) 0x0000018b: NULL bitcode 不是 bytecodebitcode 不能翻译为字节码(bytecode)，显然从字面上看这两个词代表的含义并不等同：字节码是按照字节存取的，一般其控制代码的最小宽度是一个字节(也即 8 个bits)，而 bitcode 是按位(bit)存取，最大化利用空间。比如用 bitcode 中使用 6-bit characters来编码只包含字母/数字的字符串。 ‘a’ .. ‘z’ — 0 .. 25 —&gt; 00 0000 .. 01 1001‘A’ .. ‘Z’ — 26 .. 51 —&gt; 01 1010 .. 11 0011‘0’ .. ‘9’ — 52 .. 61 —&gt; 11 0100 .. 11 1101 ‘.’ --- 62 —&gt; 11 1110 ‘_’ — 63 —&gt; 11 1111 在这种编码模式下，4 字节的字符串 abcd只用 3 个字节就可以表示 char: a | b | c | dbinary: 00 00 00|00|00 01|00 00|10|00 00 11 hex: 00 | 10 | 83 完整的编码格式可以参考官方文档LLVM Bitcode File Format bitcode 的兼容性bitcode 的格式目前是一直在变化的，且无法向前兼容，举例来说 Xcode8 的编译器无法读取并解析 xcode9 产生的 bitcode。 另外苹果的 bitcode 格式与社区版 LLVM 的 bitcode 有一定差异，但苹果并不会及时开源 Xcode 最新版编译器的代码，所以如果你使用第三方基于社区版 LLVM 制作的编译器进行开发，不要尝试开启并提交 bitcode 到 App Store Connect，否则会因为App Store Connect 解析不了你的 bitcode 而被拒。 bitcode 不是架构无关代码如果一个 app 同时要支持 armv7 和 arm64 两种架构，那么同一个源代码文件将会被编译出两份 bitcode，也就是说，在一开始介绍 LLVM 的那张图中，并不是代表同一份 bitcode 代码可以直接被编译为不同目标机器的机器码。 LLVM 只是统一了中间语言的结构和语法格式，但不能像 Java 那样，Compile Once &amp; Run Everywhere。 如何判断是否开启 bitcode可以通过 otool 检查二进制文件，网上有很多类似这样的方法： otool -arch armv7 -l xxxx.a | grep __LLVM | wc -l 通过判断是否包含 LLVM 或者关键字来判断是否支持 bitcode，其实这种方式是完全错误的，通过前面的测试可以知道，这种方式区分不了 bitcode 和 bitcode-marker，确定是否包含 bitcode，还需要检查 otool 输出中 LLVM Segment 的长度，如果长度只有 1 个字节，则并不能代表真正开启了 bitcode： $ otool -l test_bitcode.o | grep -A 2 __LLVM | grep size size 0x0000000000000b10 size 0x0000000000000042$ otool -l test_bitcode_marker.o | grep -A 2 __LLVM | grep size size 0x0000000000000001 size 0x0000000000000001 bitcode 是否能反编译出源代码从科学严谨的角度来说，无法给出确定的答案，但是这个问题跟”二进制文件是否能反编译出源代码”是一样的道理。编译是一个将源代码一层一层不断低级化的过程，每一层都可能会丢失一些特性，产生不可逆的转换，把源代码编译为 bitcode 或是二进制机器码是五十步之于百步的关系。在通常情况下，反编译 bitcode 跟反编译二进制文件比要相对容易一些，但通过 bitcode 反编译出和源代码语义完全相同的代码，也是几乎不可能的。 另外，从安全的角度考虑，Xcode 引入了 Symbol Hiding 和 Debug info Striping 机制，在链接时，bitcode 中所有非导出符号均被隐藏，取而代之的是 __hidden#0_ 或者 __ir_hidden#1_ 这样的形式，debug 信息也只保留了 line-table，所有跟文件路径、标识符、导出符号等相关的信息全部都从 bitcode 中移除，相当于做了一层混淆，防止源代码级别的信息泄露，可谓是煞费苦心。","tags":[]},{"title":" Bitcode（1）\t\t","date":"2019-01-11T08:43:12.000Z","path":"2019/01/11/bitcode/","text":"前言在 What is app thinning? (iOS, tvOS, watchOS) 一节中有以下定义： Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the App Store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store. bitcode 是被编译程序的一种中间形式的代码。包含 bitcode 配置的程序将会在 iTunes Connect 上被编译和链接。bitcode 允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到 store 上。 Bitcode. When you archive for submission to the App Store, Xcode will compile your app into an intermediate representation. The App Store will then compile the bitcode down into the 64 or 32 bit executables as necessary. 当提交程序到 App Store 上时，Xcode 会将程序编译为一个中间表现形式(bitcode)。然后 App Store 会再将这个 bitcode 编译为可执行的 64 位或 32 位程序。 来个直观图就可以明白了： 这样可以减少包的大小。 Bitcode 配置 You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64 要么让所有引入的第三方库都支持 bitcode，要么关闭 target 的 bitcode 选项。 在最新的 Xcode 中，新建项目默认就打开了 bitcode 设置，这导致在不知情的情况下出现项目编译失败，而这些因为 bitcode 而编译失败的的项目都链接了第三方二进制的库或者框架(.a、.framework)，而编译失败的原因就是，这些框架或者库恰好没有设置 bitcode。所以每当遇到这个情况时候大部分人都是直接设置 Xcode 关闭 bitcode 功能，全部不生成 bitcode。 平台 bitcode iOS 可选的 watchOS 必须的 Mac OS 不支持 苹果的要求为什么苹果默认要求 watchOS 和 tvOS 的 App 要上传 bitcode？ 因为把 bitcode 上传到苹果的中心服务器后，它可以为目标安装 App 的设备进行优化二进制，减小安装包的下载大小。当然 iOS 开发者也可以上传多个版本而不是打包到单个包里，但这样会占用更多的存储空间。最重要的是允许苹果可以在后台服务器对应用程序进行签名，而不用导出任何密钥到终端开发者那。 上传到服务器的 bitcode 给苹果带来更好处是：以后新设计了新指令集的新 CPU，可以继续从这份 bitcode 开始编译出新 CPU 上执行的可执行文件，以供用户下载安装。 bitcode 给开发者带来的不便之处：没用 bitcode 之前，当应用程序崩溃后，开发者可以根据获取的的崩溃日志再配上上传到苹果服务器的二进制文件的调试符号表信息，还原程序运行过程到崩溃时后调用栈信息，对问题进行定位排查。但用了 bitcode 之后，用户安装的二进制不是开发者这边生成的，而是苹果服务器经过优化后生成的，其对应的调试符号信息丢失了，也就无法进行前面说的还原崩溃现场找原因了。 打开 BitCode 时，在iTunes Connect 里”我的App”-&gt;项目-&gt;活动-&gt;所有构建版本-&gt;具体版本的”综合信息”下”包含符号”那里可以下载到 dSYM 文件。（待验证） 相当于在编译的时候加一个标记：embed-bitcode-marker(调试构建) embed-bitcode(打包/真机构建)。这个在 clang 编译器的参数是-fembed-bitcode，swift 编译器的参数是-embed-bitcode。 拓展知识目前苹果采用的编译器工具链是 LLVM，Bitcode 是 LLVM 编译器的中间代码的一种编码。LLVM 的前端可以理解为C/C++/OC/Swift 等编程语言，后端可以理解为各个芯片平台上的汇编指令或者可执行机器指令数据，那么 BitCode 就是位于这两者之间的中间码。 LLVM 的编译工作原理是前端负责把项目程序源代码翻译成 Bitcode 中间码，然后再根据不同目标机器芯片平台转换为相应的汇编指令以及翻译为机器码。这样设计就可以让 LLVM 成为了一个编译器架构，可以轻而易举的在 LLVM 架构之上发明新的语言(前端)，以及在 LLVM 架构下面支持新的 CPU(后端)指令输出。虽然 Bitcode 仅仅只是一个中间码，不能在任何平台上运行，但是它可以转化为任何被支持的 CPU 架构，包括还未被发明的 CPU 架构，也就是说现在打开 Bitcode 功能提交一个 App 到应用商店，如果以后苹果使用全新设计的 CPU，在苹果后台服务器一样可以从这个 App 的 Bitcode 开始编译转化为新 CPU 上的可执行程序，可供新手机用户下载运行这个 App。 在 iPhone 出来之前，苹果主要的编译器技术是用经过稍微改进的 GCC 工具链来把 Objective-C 语言编写的代码编译出所指定的机器处理器上原生的可执行程序。编译器产生的可执行程序叫做”Fat Binaries”–类似于 Windows 中 PE 格式的 exe 和 Linux 下的 ELF 格式的二进制。 区别是，一个”Fat Binary”可以包含同一个程序的很多版本，所以同一个可执行文件可以在不同的处理器上运行。主要就是这个技术让苹果的硬件很容易的从 PowerPC 迁移到 PowerPC64 的处理器，以及后来再迁移到 Intel 和 Intel64 处理器。这个方案带来的负面影响就是同一个文件中存了多份可执行代码，除了当前机器可执行的那一份之外其他都是无用的，这个在市场上被称为”Universal Binary”。在苹果从 PowerPC 迁移到 Intel 处理器的事情开始存在的(一个二进制文件包含一份 PowerPC 版本和一份 Intel 版本)。慢慢的后来又支持同时包含 Intel 32bit 和 Intel 64bit。 在一个 Fat binary 中，有操作系统运行时根据处理器类型动态选择正确的二进制版本来运行，但是应用程序要支持不同平台的处理器的话，应用程序本身要多占用一些空间。当然也有一些瘦身的工具，比如 lipo，可以用来移除那些当前机器中不被支持的或者多余的可执行代码达到瘦身目的，lipo不会改变程序执行逻辑，仅仅只是文件的大小瘦身。 随着移动设备移动互联网的深入发展，程序大小变得越来越重要了。主要是因为移动设备中不会有电脑上那么大的硬盘驱动器，还有就是苹果早就从原始的 ARM 处理器迁移到自家设计的 A4、A5、A5X、A6、A7、A8、A8X、A9、A9X 以及后续的 A10 处理器，它们的指令集已经发生了改变和原始 ARM 设计的有所区别，iOS 操作系统底层以及 Xcode/LLVM 编译工具一定程度上透明了这些变化，编译出来的程序会包含很多执行代码版本。面对这个问题，苹果投入大量成本迁移到 LLVM 编译器架构并使用 bitcode 的必要性越来越大。从最开始的把 OPENGL 编译为特定的 GPU 指令到把 Clang 编译器(LLCM的C/OC编译前端)支持 Objective-C 的改进并作为 Xcode 的默认编译器。 LLVM 提供了一个虚拟指令集机制，它可以翻译出指定的所支持的处理器架构的执行代码(机器码)。这个就使得为 iOS 应用程序的编译开发一个完全基于 LLVM 架构的工具链成为可能。而 LLVM 的这个虚拟的通用的指令集可以用很多种表示格式： 叫做 IR 的文本表示的汇编格式（像汇编语言） 转换为二进制数据表示的格式（像目标代码），这个二进制格式就是我们所说的 bitcode。 Bitcode 和传统的可执行指令集不同，它维护的是函数功能的类型和签名。比如，传统可执行指令集中，一系列(&lt;=8)的布尔值可以压缩存储到单个字节中，但是在 bitcode 中它们是各自独自表示的；此外，逻辑运算操作(比如寄存器清零操作)也有它们对应的逻辑表示方法($R=0)，当这些 BitCode 要转换为特定机器平台的指令集时，它可以用经过针对特定机器平台优化过的汇编指令来代替：xor eax, eax。（这个汇编指令同样是寄存器清零操作）。 然而 bitcode 也不是完全独立于处理器平台和调用约定的，寄存器的大小在指令集中是一个相当重要的特性。众所周知，64bit 寄存器可以比 32bit 寄存器存储更多的数据，生成 64bit 平台的 bitcode 和 32bit 平台的是明显不同的；还有，调用约定可以根据函数定义或者函数调用来定义，这些可以确定函数的参数传递是传寄存器值还是压栈。一些编程语言还有如 sizeof(long) 这样的预处理指令，这些将在 bitcode 生成之前前被翻译。一般情况下，对于支持 fastcc(fast calling convention)调用的 64bit 平台会生成与其一致的 bitcode 代码。 代码验证①、在 Objective-C 代码中实现 c 方法 @implementation Test void Greeting(void){ NSLog(@”hello world!”);} @end @implementation Demo void Demo(void){ NSLog(@”demo func!”);} @end ②、用 Clang 编译成 ARM64 格式且带 bitcode 的目标文件 Test.o Demo.o。 xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c Test.m Demo.m ③、把两个目标文件打包为一个静态库文件。 xcrun -sdk iphoneos ar-r libTest.a Test.o Demo.o ④、用 Shell 命令 otool 查看静态库文件是否包含 bitcode 段。 otool -l Test.o | grep bitcode 或 otool -l libTest.a | grep bitcode 如果输出了 2 行 sectname __bitcode，就是说明这个静态库中的两个目标文件包含了 bitcode。 ⑤、用下面的命令把 Demo.m 的 C 代码转换为 ARM64 汇编语言格式 demo.s。 xcrun -sdk iphoneos clang -arch arm64 -S Demo.m ⑥、删除 Demo.m，仅留下 Test.m 和 Demo.s。 rm Demo.m 或者手动在目录中删除 ⑦、把 Test.m 和 Dmeo.s 这个汇编源代码来一起带着 -fembed-bitcode 参数来生成目标代码并打包为一个静态库。 xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c Test.m Demo.s xcrun -sdk iphoneos ar -r libTest.a Test.o Demo.o ⑧、再运行 otool 工具来检查这个新的静态库中包含的 2 个目标文件是否都带有 bitcode 段。 otool -l libTest.a | grep bitcode 从上可以看到，包含 Test.o、Demo.o 的静态库有两行 sectname __bitcode 输出，包含 Test.o、Demo.s 的静态库只有一行输出。这就说明从 ARM64 汇编语言编译过来的目标文件 Demo.s 不带有 bitcode 段，哪怕在编译的时候指定了参数 -fembed-bitcode 也没有用。 结论：bitcode 的生成是由汇编语言以上的上层语言编译而来，它是上层语言与汇编语言(机器语言)之间的一个中间码。 目前日常的 iOS 应用开发中，一般不会需要用到汇编层面去优化的代码，所以我们主要关注第三方(开源)C代码，尤其是音视频编码解码这些计算密集型项目代码，关键计算的代码针对特定平台都有对应平台的汇编版本实现，当然也有 C 的实现，但是默认编译一般都是用的汇编版本，这样就会导致我们在编译这个开源代码的时候哪怕你带了 -fembed-bitcode 参数也仅仅只是让项目中的部分 C 代码的目标文件带了 bitcode 段，而那少数的汇编代码的目标文件一样不带 bitcode 段，这样编译出这个库交给上层开发者使用的时候，就会出现在打包上传或者真机调试的时候因为 Xcode 默认开了 bitcode 功能而链接失败，导致不能真机调试或者不能上传应用到 AppStore。（需要再研究） .s 也是支持 -fembed-bitcode 的，只是并非真正带了 bitcode(通过 .s 无法编译出 bitcode)，只是在 .o 里做了标记以兼容 bitcode 模式。 参考文章lansekuangtu：《理解Bitcode：一种中间代码》戴维营教育：《深入理解iOS开发中的BitCode功能》 LLVM 官方文档介绍的 bitcode 文件的格式：LLVM Bitcode File Format Understanding and Analyzing Application Crash Reports Troubleshooting App Thinning and Bitcode Build Failures","tags":[]},{"title":" OpenGL - 5 纹理\t\t","date":"2019-01-10T15:31:59.000Z","path":"2019/01/10/opengl-5-e7-ba-b9-e7-90-86/","text":"原文：https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/ 我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。 艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。 除了图像以外，纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上，但是这不是我们现在的主题。 下面你会看到之前教程的那个三角形贴上了一张砖墙图片。 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。 纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。 我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。 纹理坐标看起来就像这样： float texCoords[] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中 }; 对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理采样。 纹理环绕方式纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择： 环绕方式 描述 GL_REPEAT 对纹理的默认行为。重复纹理图像。 GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的。 GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子： 前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）： glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。 如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值： float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 纹理过滤纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。 译注1 Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）： GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似： glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 多级渐远纹理想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的： 手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式： 过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一： glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。 加载与创建纹理使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。 另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的stb_image.h库。 stb_image.hstb_image.h是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h可以在这里下载。下载这一个头文件，将它以stb_image.h的名字加入你的工程，并另创建一个新的C++文件，输入以下代码： `#define STB_IMAGE_IMPLEMENTATION #include “stb_image.h”` 通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。 下面的教程中，我们会使用一张木箱的图片。要使用stb_image.h加载图片，我们需要使用它的stbi_load函数： int width, height, nrChannels; unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); 这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个int作为它的第二、第三和第四个参数，stb_image.h将会用图像的宽度、高度和颜色通道的个数填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。 生成纹理和之前生成的OpenGL对象一样，纹理也是使用ID引用的。让我们来创建一个： unsigned int texture; glGenTextures(1, &amp;texture); glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中（我们的例子中只是单独的一个unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理： glBindTexture(GL_TEXTURE_2D, texture); 现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成： glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); 函数很长，参数也不少，所以我们一个一个地讲解： 第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。 第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。 第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。 第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。 下个参数应该总是被设为0（历史遗留的问题）。 第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。 最后一个参数是真正的图像数据。 当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。 生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。 stbi_image_free(data); 生成一个纹理的过程应该看起来像这样： unsigned int texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); // 为当前绑定的纹理对象设置环绕、过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 加载并生成纹理 int width, height, nrChannels; unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); if (data) { glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); } else { std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl; } stbi_image_free(data); 应用纹理后面的这部分我们会使用glDrawElements绘制「你好，三角形」教程最后一部分的矩形。我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据： float vertices[] = { // ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // 左上 }; 由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式： glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); glEnableVertexAttribArray(2); 注意，我们同样需要调整前面两个顶点属性的步长参数为8 * sizeof(float)。 接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器： `#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord; out vec3 ourColor;out vec2 TexCoord; void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexCoord;}` 片段着色器应该接下来会把输出变量TexCoord作为输入变量。 片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。 `#version 330 coreout vec4 FragColor; in vec3 ourColor;in vec2 TexCoord; uniform sampler2D ourTexture; void main() { FragColor = texture(ourTexture, TexCoord);}` 我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。 现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器： glBindTexture(GL_TEXTURE_2D, texture); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 如果你跟着这个教程正确地做完了，你会看到下面的图像： 如果你的矩形是全黑或全白的你可能在哪儿做错了什么。检查你的着色器日志，并尝试对比一下源码。 如果你的纹理代码不能正常工作或者显示是全黑，请继续阅读，并一直跟进我们的代码到最后的例子，它是应该能够工作的。在一些驱动中，必须要对每个采样器uniform都附加上纹理单元才可以，这个会在下面介绍。 我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色： FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0); 最终的效果应该是顶点颜色和纹理颜色的混合色： 我猜你会说我们的箱子喜欢跳70年代的迪斯科。 纹理单元你可能会奇怪为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。 纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元： glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元 glBindTexture(GL_TEXTURE_2D, texture); 激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。 OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。 我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了： `#version 330 core… uniform sampler2D texture1;uniform sampler2D texture2; void main() { FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);}` 最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。 我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。对于第二个纹理我们使用一张你学习OpenGL时的面部表情图片。 为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元： `glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2); glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);` 我们还要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面： ourShader.use(); // 别忘记在激活着色器前先设置uniform！ glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置 ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置 while(...) { [...] } 通过使用glUniform1i设置采样器，我们保证了每个uniform采样器对应着正确的纹理单元。你应该能得到下面的结果： 你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。很幸运，stb_image.h能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可： stbi_set_flip_vertically_on_load(true); 在让stb_image.h在加载图片时翻转y轴之后你就应该能够获得下面的结果了： 如果你看到了一个开心的箱子，你就做对了。你可以对比一下源代码。 练习为了更熟练地使用纹理，建议在继续之后的学习之前做完这些练习： 修改片段着色器，仅让笑脸图案朝另一个方向看，参考解答 尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸：参考解答，结果。记得一定要试试其它的环绕方式。 尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰：参考解答 使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度：参考解答。","tags":[]},{"title":" iOS App的启动过程\t\t","date":"2019-01-02T07:30:30.000Z","path":"2019/01/02/ios-app-e7-9a-84-e5-90-af-e5-8a-a8-e8-bf-87-e7-a8-8b/","text":"原文：黄文臣 深入理解 iOS App的启动过程 启动时间是衡量应用品质的重要指标。 本文首先会从原理上出发，讲解 iOS 系统是如何启动 App 的，然后从 main 函数之前和之后两个角度去分析如何优化启动时间。 Mach-O哪些名词指的是 Mach-o Executable 可执行文件 Dylib 动态库 Bundle 无法被连接的动态库，只能通过 dlopen() 加载 Image 指的是 Executable、Dylib 或者 Bundle 的一种，文中会多次使用 Image 这个名词。 Framework 动态库和对应的头文件和资源文件的集合 Apple 出品的操作系统的可执行文件格式几乎都是 mach-o，iOS 当然也不例外。 mach-o 可以大致的分为三部分： Header 头部，包含可以执行的 CPU 架构，比如 x86、arm64 Load commands 加载命令，包含文件的组织架构和在虚拟内存中的布局方式 Data 数据，包含 load commands 中需要的各个段（segment）的数据，每一个 Segment 的大小都是 Page 的整数倍。 用 MachOView 打开工程的可以执行文件，来验证下 mach-o 的文件布局： 绝大多数 mach-o 包括以下三个段（支持用户自定义 Segment，但是很少使用） __TEXT 代码段，只读。包括函数，和只读的字符串，上图中类似 __TEXT、text 的都是代码段__DATA 数据段，读写。包括可读写的全局变量等，上图类似中的 __DATA、data 都是数据段__LINKEDIT 包含了方法和变量的元数据（位置，偏移量），以及代码签名等信息。 关于 mach-o 更多细节，可以看看文档：《Mac OS X ABI Mach-O File Format Reference》。 dylddyld 的全称是 dynamic loader，它的作用是加载一个进程所需要的 image，dyld 是开源的。 Virtual Memory 虚拟内存是在物理内存上建立的一个逻辑地址空间，它向上（应用）提供了一个连续的逻辑地址空间，向下隐藏了物理内存的细节。虚拟内存使得逻辑地址可以没有实际的物理地址，也可以让多个逻辑地址对应到一个物理地址。虚拟内存被划分为一个个大小相同的 Page（64 位系统上是 16KB），提高管理和读写的效率。 Page 又分为只读和读写的 Page。 虚拟内存是建立在物理内存和进程之间的中间层。在 iOS 上，当内存不足的时候，会尝试释放那些只读的 Page，因为只读的Page 在下次被访问的时候，可以再次从磁盘读取。如果没有可用内存，会通知在后台的 App（也就是在这个时候收到了 memory warning），如果在这之后仍然没有可用内存，则会杀死在后台的 App。 Page fault在应用执行的时候，它被分配的逻辑地址空间都是可以访问的，当应用访问一个逻辑 Page，而在对应的物理内存中并不存在的时候，这时候就发生了一次 Page fault。当 Page fault 发生的时候，会中断当前的程序，在物理内存中寻找一个可用的 Page，然后从磁盘中读取数据到物理内存，接着继续执行当前程序。 Dirty Page &amp; Clean Page 如果一个 Page 可以从磁盘上重新生成，那么这个 Page 称为 Clean Page 如果一个 Page 包含了进程相关信息，那么这个 Page 称为 Dirty Page 像代码段这种只读的 Page 就是 Clean Page。而像数据段 _DATA 这种读写的 Page，当写数据发生的时候，会触发 COW（Copy on write），也就是写时复制，Page 会被标记成 Dirty，同时会被复制。 想要了解更多细节，可以阅读文档：Memory Usage Performance Guidelines 启动过程使用 dyld2 启动应用的过程如图： 大致的过程如下： 加载 dyld 到 App 进程 加载动态库（包括所依赖的所有动态库） Rebase Bind 初始化 Objective-C Runtime 其它的初始化代码 加载动态库 首先，dyld 会读取 mach-o 文件的 Header 和 load commands。 接着，就知道了这个可执行文件依赖的动态库。例如加载动态库 A 到内存，接着检查 A 所依赖的动态库，就这样的递归加载，直到所有的动态库加载完毕。通常一个 App 所依赖的动态库在 100-400 个左右，其中大多数都是系统的动态库，它们会被缓存到 dyld shared cache，这样读取的效率会很高。 查看 mach-o 文件所依赖的动态库，可以通过 MachOView 的图形化界面（展开 Load Command 就能看到) 也可以通过命令行：otool -L Demo Rebase &amp;&amp; Bind 这里先来讲讲为什么要 Rebase？ 有两种主要的技术来保证应用的安全：ASLR 和 Code Sign。 ASLR 的全称是 Address space layout randomization，翻译过来就是“地址空间布局随机化”。App 启动的时候，程序会被影射到逻辑的地址空间，这个逻辑的地址空间有一个起始地址，而 ASLR 技术使得这个起始地址是随机的。如果是固定的，那么黑客很容易就可以由起始地址+偏移量找到函数的地址。 Code Sign 相信大多数开发者都知晓，这里要提一点的是，在进行 Code sign 的时候，加密哈希不是针对于整个文件，而是针对于每一个 Page 的。这就保证了在 dyld 进行加载的时候，可以对每一个 page 进行独立的验证。 mach-o 中有很多符号，有指向当前 mach-o 的，也有指向其他 dylib 的，比如 printf。那么，在运行时代码如何准确的找到 printf 的地址呢？ mach-o 中采用了 PIC 技术，全称是 Position Independ code。当你的程序要调用 printf 的时候，会先在 __DATA 段中建立一个指针指向 printf，再通过这个指针实现间接调用。dyld 这时候需要做一些 fix-up 工作，即帮助应用程序找到这些符号的实际地址。主要包括两部分： Rebase 修正内部（指向当前 mach-o 文件）的指针指向 Bind 修正外部指针指向 之所以需要 Rebase，是因为刚刚提到的 ASLR 使得地址随机化，导致起始地址不固定，另外由于 Code Sign，导致不能直接修改Image。Rebase 的时候只需要增加对应的偏移量即可。待 Rebase 的数据都存放在 __LINKEDIT 中。 可以通过 MachOView 查看：Dynamic Loader Info -&gt; Rebase Info 也可以通过命令行：xcrun dyldinfo -bind Demo Rebase 解决了内部的符号引用问题，而外部的符号引用则是由 Bind 解决。在解决 Bind 的时候，是根据字符串匹配的方式查找符号表，所以这个过程相对于 Rebase 来说是略慢的。 同样，也可以通过 xcrun dyldinfo 来查看 Bind 的信息，比如我们查看 bind 信息中，包含 UITableView 的部分：xcrun dyldinfo -bind demo | grep UITableView Objective-CObjective-C 是动态语言，所以在执行 main 函数之前，需要把类的信息注册到一个全局的 Table 中。同时，Objective-C支持Category，在初始化的时候，也会把 Category 中的方法注册到对应的类中，同时会唯一 Selector，这也是为什么当你的 Cagegory实现了类中同名的方法后，类中的方法会被覆盖。 category 是实现了类似覆盖原同名方法的功能，但是实现上不是覆盖，而是将 category 的方法放到原方法的前面，methodlist 中就有了两个同名的方法，第一个方法是 category 方法，而第二个方法是原方法。这样在命中方法的时候，就会命中这个 category方法。 系统的实现方法是这样的： for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist&gt;count; m++) { SEL sel = method\\_list\\_nth(mlist, m)-&gt;name; if (scanForCustomRR &amp;&amp; isRRSelector(sel)) { cls-&gt;setHasCustomRR(); scanForCustomRR = false; } else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) { cls-&gt;setHasCustomAWZ(); scanForCustomAWZ = false; } } // Fill method list arraynewLists[newCount++] = mlist;… // Copy old methods to the method list arrayfor (i = 0; i &lt; oldCount; i++) { newLists[newCount++] = oldLists[i];} 另外，由于 iOS 开发是基于 Cocoa Touch 的，所以绝大多数的类起始都是系统类，所以大多数的 Runtime 初始化起始在 Rebase和 Bind 中已经完成。 Initializers接下来就是必要的初始化部分了，主要包括几部分： +load方法。 C／C++ 静态初始化对象和标记为 __attribute__(constructor) 的方法 这里要提一点的就是，+load 方法已经被弃用了，如果你用 Swift 开发，你会发现根本无法去写这样一个方法，官方的建议是使用 initialize。区别就是，load 是在类装载的时候执行，而 initialize 是在类第一次收到 message 前调用。 dyld3上文的讲解是 dyld2 的加载方式。而最新的是 dyld3 加载方式略有不同： dyld2 是纯粹的 in-process，也就是在程序进程内执行的，也就意味着只有当应用程序被启动的时候，dyld2 才能开始执行任务。 dyld3 则是部分 out-of-process，部分 in-process。图中，虚线之上的部分是 out-of-process 的，在 App 下载安装和版本更新的时候会去执行，out-of-process 会做如下事情： 分析Mach-o Headers 分析依赖的动态库 查找需要Rebase &amp; Bind之类的符号 把上述结果写入缓存 这样，在应用启动的时候，就可以直接从缓存中读取数据，加快加载速度。 启动时间冷启动 VS 热启动 如果你刚刚启动过 App，这时候 App 的启动所需要的数据仍然在缓存中，再次启动的时候称为热启动。如果设备刚刚重启，然后启动 App，这时候称为冷启动。 启动时间小于 400ms 是最佳的，因为从点击图标到显示 Launch Screen，到 Launch Screen 消失这段时间是400ms。启动时间不可以大于 20s，否则会被系统杀掉。 在 Xcode 中，可以通过设置环境变量来查看 App 的启动时间，DYLD_PRINT_STATISTICS 和DYLD_PRINT_STATISTICS_DETAILS。 Total pre-main time: 582.39 milliseconds (100.0%) dylib loading time: 169.23 milliseconds (29.0%) rebase/binding time: 337.04 milliseconds (57.8%) ObjC setup time: 44.48 milliseconds (7.6%) initializer time: 31.52 milliseconds (5.4%) slowest intializers : libSystem.B.dylib : 12.06 milliseconds (2.0%) libMainThreadChecker.dylib : 12.12 milliseconds (2.0%) total time: 904.01 milliseconds (100.0%) total images loaded: 257 (0 from dyld shared cache) total segments mapped: 764, into 103339 pages with 7230 pages pre-fetched total images loading time: 465.37 milliseconds (51.4%) total load time in ObjC: 44.48 milliseconds (4.9%) total debugger pause time: 296.13 milliseconds (32.7%) total dtrace DOF registration time: 0.10 milliseconds (0.0%) total rebase fixups: 2,520,346 total rebase fixups time: 343.84 milliseconds (38.0%) total binding fixups: 283,141 total binding fixups time: 18.27 milliseconds (2.0%) total weak binding fixups time: 0.41 milliseconds (0.0%) total redo shared cached bindings time: 25.48 milliseconds (2.8%) total bindings lazily fixed up: 0 of 0 total time in initializers and ObjC +load: 31.52 milliseconds (3.4%) libSystem.B.dylib : 12.06 milliseconds (1.3%) libBacktraceRecording.dylib : 2.54 milliseconds (0.2%) CoreFoundation : 1.46 milliseconds (0.1%) Foundation : 1.69 milliseconds (0.1%) libMainThreadChecker.dylib : 12.12 milliseconds (1.3%)total symbol trie searches: 132718total symbol table binary searches: 0total images defining weak symbols: 20total images using weak symbols: 61 对于这个 libMainThreadChecker.dylib 估计很多人会有点陌生，这是 XCode 9 新增的动态库，用来做主线成检查的。 优化启动时间启动时间这个名词，不同的人有不同的定义。在我看来 启动时间是用户点击 App 图标，到第一个界面展示的时间。 以 main 函数作为分水岭，启动时间其实包括了两部分：main 函数之前和 main 函数到第一个界面的 viewDidAppear:。所以，优化也是从两个方面进行的，个人建议优先优化后者，因为绝大多数 App 的瓶颈在自己的代码里。 Main 函数之后 首先来分析下，从 main 函数开始执行，到你的第一个界面显示，这期间一般会做哪些事情。 执行 AppDelegate 的代理方法，主要是 didFinishLaunchingWithOptions: 初始化 Window，初始化基础的 ViewController 结构（一般是 UINavigationController+UITabViewController） 获取数据（Local DB/Network），展示给用户。 UIViewController 延迟初始化那些不必要的 UIViewController。 比如网易新闻： 在启动的时候只需要初始化首页的头条页面即可。像”要闻”、”我的”等页面，则延迟加载，即启动的时候只是一个 Controller 作为占位符给 TabController，等到用户点击了再去进行真正的数据和视图的初始化工作。系统的 UITabBarController 已经这样做了，但是很多 App 都是自定义的。 AppDelegate通常我们会在 AppDelegate 的代理方法里进行初始化工作，主要包括了两个方法： didFinishLaunchingWithOptions applicationDidBecomeActive 优化这些初始化的核心思想就是： 能延迟初始化的尽量延迟初始化，不能延迟初始化的尽量放到后台初始化。 这些工作主要可以分为几类： 三方 SDK 初始化，比如 Crash 统计；像分享之类的，可以等到第一次调用再初始化。 初始化某些基础服务，比如 WatchDog，远程参数。 启动相关日志，日志往往涉及到 DB 操作，一定要放到后台去做 业务方初始化，这个交由每个业务自己去控制初始化时间。 对于 didFinishLaunchingWithOptions: 的代码，建议按照以下的方式进行划分： @interface AppDelegate ()//业务方需要的生命周期回调@property (strong, nonatomic) NSArray&lt;id&gt; * eventQueues;//主框架负责的生命周期回调@property (strong, nonatomic) id basicDelegate;@end 然后，你会得到一个非常干净的 AppDelegate 文件： - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ for (id delegate in self.eventQueues) { [delegate application:application didFinishLaunchingWithOptions:launchOptions]; } return [self.basicDelegate application:application didFinishLaunchingWithOptions:launchOptions];} 由于对这些初始化进行了分组，在开发期就可以很容易的控制每一个业务的初始化时间： CFTimeInterval startTime = CACurrentMediaTime();// 执行方法CFTimeInterval endTime = CACurrentMediaTime(); 用 Time Profiler 找到元凶Time Profiler 在分析时间占用上非常强大。实用的时候注意三点 在打包模式下分析（一般是 Release），这样和线上环境一样。 记得开启 dsym，不然无法查看到具体的函数调用堆栈 分析性能差的设备，对于支持 iOS 8 的，一般分析 iphone 4s 或 iphone 5。 一个典型的分析界面如下： 几点要注意： 分析启动时间，一般只关心主线程 选择 Hide System Libraries 和 Invert Call Tree，这样我们能专注于自己的代码 右侧可以看到详细的调用堆栈信息 在某一行上双击，我们可以进入到代码预览界面，去看看实际每一行占用了多少时间： 小结不同的 App 在启动的时候做的事情往往不同，但是优化起来的核心思想无非就两个： 能延迟执行的就延迟执行。比如 SDK 的初始化、界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取、原始 JSON 数据转对象、日志发送。 Main 函数之前Main 函数之前是 iOS 系统的工作，所以这部分的优化往往更具有通用性。 dylibs 启动的第一步是加载动态库，加载系统的动态库是很快的，因为可以缓存，而加载内嵌的动态库速度较慢。所以，提高这一步的效率的关键是：减少动态库的数量。 合并动态库，比如公司内部由私有 Pod 建立了如下动态库：XXTableView、XXHUD、XXLabel，强烈建议合并成一个 XXUIKit来提高加载速度。 Rebase &amp; Bind &amp; Objective-C Runtime Rebase 和 Bind 都是为了解决指针引用的问题。对于 Objective-C 开发来说，主要的时间消耗在 Class/Method 的符号加载上，所以常见的优化方案是： 减少 __DATA 段中的指针数量。 合并 Category 和功能类似的类。比如：UIView+Frame、UIView+AutoLayout… 合并为一个 删除无用的方法和类。 多用 Swift Structs，因为 Swfit Structs 是静态分发的。 Initializers 通常，我们会在 +load 方法中进行 method-swizzling，这也是 NSHipster 推荐的方式。 用 initialize 替代 load。不少同学喜欢用 method-swizzling 来实现 AOP 去做日志统计等内容，强烈建议改为在 initialize 进行初始化。 减少 __atribute__((constructor)) 的使用，而是在第一次访问的时候才用 dispatch_once 等方式初始化。 不要创建线程 使用Swfit重写代码。 参考资料WWDC 2016: Optimizing App Startup TimeWWDC 2017: App Startup Time: Past, Present, and Future","tags":[]},{"title":" 多个异步网络请求全部返回\t\t","date":"2019-01-02T03:12:49.000Z","path":"2019/01/02/e5-a4-9a-e4-b8-aa-e5-bc-82-e6-ad-a5-e7-bd-91-e7-bb-9c-e8-af-b7-e6-b1-82-e5-85-a8-e9-83-a8-e8-bf-94-e5-9b-9e/","text":"原文：iOS 多个异步网络请求全部返回后再执行具体逻辑的方法 提起 ios 中多个异步函数后的同步问题，自然会想到 dispatch group，那么它能够解决异步网络请求的问题吗？ /*! * @function dispatch_group_async * * @abstract * Submits a block to a dispatch queue and associates the block with the given dispatch group. * * @discussion * Submits a block to a dispatch queue and associates the block with the given * dispatch group. The dispatch group may be used to wait for the completion * of the blocks it references. */ #ifdef __BLOCKS__API_AVAILABLE(macos(10.6), ios(4.0))DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROWvoiddispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); #endif / __BLOCKS__ / 从官方对 dispatch_group_async 的介绍可以看出，是用于同步工作的，但是，它的判断标准是放入的 block 是否执行完毕，如果我们放入 block 中包含异步的网络请求，这个方法无法在网络数据返回后再进行同步。 看一段使用 dispatch_group_async 处理网络问题的代码： - (void)viewDidLoad { [super viewDidLoad]; NSURLSession * session = \\[NSURLSession sharedSession\\]; dispatch\\_queue\\_t dispatchQueue = dispatch\\_queue\\_create(&quot;test.queue&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch\\_group\\_t dispatchGroup = dispatch\\_group\\_create(); dispatch\\_group\\_async(dispatchGroup, dispatchQueue, ^(){ NSURLSessionDataTask \\*task = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData \\* \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务一完成&quot;); }\\]; \\[task resume\\]; }); dispatch\\_group\\_async(dispatchGroup, dispatchQueue, ^(){ NSURLSessionDataTask \\*task = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData \\* \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务二完成&quot;); }\\]; \\[task resume\\]; }); dispatch\\_group\\_notify(dispatchGroup, dispatch\\_get\\_main_queue(), ^(){ NSLog(@&quot;Group End！&quot;); }); } 2019-01-02 10:43:15.715637+0800 Demo[46351:695969] Group End！2019-01-02 10:43:15.776094+0800 Demo[46351:696017] 任务二完成2019-01-02 10:43:15.838367+0800 Demo[46351:696016] 任务一完成 完全没有达到效果。这是因为这里的网络请求是个异步的方法，没有等待具体的数据返回，放入的 dispatch queue 的 block 就执行完毕了。所以没收到 2 个网络数据，就提前调用了 dispatch_group_notify 指定的结束方法。 看完了错误的方法，再看看正确的方法： - (void)viewDidLoad{ [super viewDidLoad]; NSURLSession * session = \\[NSURLSession sharedSession\\]; dispatch\\_group\\_t group = dispatch\\_group\\_create(); dispatch\\_group\\_enter(group); // 任务 + 1 NSURLSessionDataTask * task = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData * \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务一完成&quot;); dispatch\\_group\\_leave(group); // 任务 - 1 }\\]; \\[task resume\\]; NSLog(@&quot;*********&quot;); dispatch\\_group\\_enter(group); // 任务 + 1 NSURLSessionDataTask * task2 = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData * \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务二完成&quot;); dispatch\\_group\\_leave(group); // 任务 - 1 }\\]; \\[task2 resume\\]; NSLog(@&quot;#########&quot;); dispatch\\_group\\_notify(group, dispatch\\_get\\_main_queue(), ^(){ NSLog(@&quot;Group End！&quot;); }); } 2019-01-02 10:49:49.629628+0800 Demo[46476:700259] *2019-01-02 10:49:49.629893+0800 Demo[46476:700259] #########2019-01-02 10:49:49.810857+0800 Demo[46476:700300] 任务一完成2019-01-02 10:49:49.930557+0800 Demo[46476:700297] 任务二完成2019-01-02 10:49:49.930675+0800 Demo[46476:700259] Group End！ 我们看看关于 dispatch_group_enter 的具体说明 Calling this function increments the current count of outstanding tasks in the group. Using this function (with dispatch_group_leave) allows your application to properly manage the task reference count if it explicitly adds and removes tasks from the group by a means other than using the dispatch_group_async function. A call to this function must be balanced with a call to dispatch_group_leave. You can use this function to associate a block with more than one group at the same time. /*! * @function dispatch_group_enter * * @abstract * Manually indicate a block has entered the group * * @discussion * Calling this function indicates another block has joined the group through * a means other than dispatch_group_async(). Calls to this function must be * balanced with dispatch_group_leave(). */API_AVAILABLE(macos(10.6), ios(4.0))DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROWvoiddispatch_group_enter(dispatch_group_t group); 简单来说，就是 dispatch_group_enter 会对 group 的内部计数 +1，dispatch_group_leave 会对 group 的内部计数 -1，就类似以前的 retain 和 release 方法。也就是维护了一个计数器。 自己维护计数器的做法：在发送网络请求前，记下发送总数，数据返回后，在同一个 thread 中（或者在一个DISPATCH_QUEUE_SERIAL 类型的 dispatch_queue 中），对计数器进行 +1 操作，当计数器和网络请求数相等时，调用最后的处理。 相比自己处理的计数器，dispatch_group_enter 处理方法可能显得更正规一些，代码更规范了，但执行效果是一样的。 有一个值，需要 2 个异步操作查询回 2 个值进行计算，因此必须在 2 个异步操作结束后才能进行计算操作。开始试着使用了OperationQueue，想用 addDependency(依赖，顺序执行) 方法，但是这个方法无法灵活地控制，只适合 block 内容已经确定的情况。对于我遇到的这种异步操作，block 的内容是不定的，需要依赖异步的返回，用 operation queue 会遇到各种问题，无法解决问题，十分复杂！ 今天看到了 dispatch_barrier_async 函数，说明如下： Calls to this function always return immediately after the block has been submitted and never wait for the block to be invoked. When the barrier block reaches the front of a private concurrent queue, it is not executed immediately. Instead, the queue waits until its currently executing blocks finish executing. At that point, the barrier block executes by itself. Any blocks submitted after the barrier block are not executed until the barrier block completes. The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_async function. 简单地说，就是在这个函数之前被提交到 quque 里的 block 一定会被先执行，之后执行 dispatch_barrier_async 设定的 block，最后执行调用 dispatch_barrier_async 之后才提交到 queue 里的 block。 - (void)viewDidLoad{ [super viewDidLoad]; NSURLSession * session = \\[NSURLSession sharedSession\\]; dispatch\\_queue\\_t dispatchQueue = dispatch\\_queue\\_create(&quot;test.queue&quot;, DISPATCH\\_QUEUE\\_CONCURRENT); dispatch_async(dispatchQueue, ^{ NSURLSessionDataTask * task1 = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData * \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务一完成&quot;); }\\]; \\[task1 resume\\]; }); dispatch_async(dispatchQueue, ^{ NSURLSessionDataTask * task2 = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData * \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务二完成&quot;); }\\]; \\[task2 resume\\]; }); dispatch\\_barrier\\_async(dispatchQueue, ^{ NSLog(@&quot;Barrier block is called！&quot;); }); dispatch_async(dispatchQueue, ^{ NSLog(@&quot;The last block is called！&quot;); }); } 2019-01-02 11:01:39.209755+0800 Demo[46644:705935] Barrier block is called！2019-01-02 11:01:39.209893+0800 Demo[46644:705935] The last block is called！2019-01-02 11:01:39.912047+0800 Demo[46644:705938] 任务一完成2019-01-02 11:01:39.935593+0800 Demo[46644:705937] 任务二完成 完全没有达到 2 个网络请求都返回后，再执行 the last block 的效果。 原因和 dispatch_group_async 无法达到目的的原因是一样的：它认为一个 block 返回后就是逻辑结束了，就会继续执行其他代码，对于 block 中异步返回的网络数据，没有对应的处理手段。 NSUrlSession 用的是 NSOperation Queue，能不能直接利用 Operation Queue 来解决这个问题？ 我们知道NSOperation中有addDependency这个方法，我们能不能把几个网络请求分别封装一下： \\[NSBlockOperation blockOperationWithBlock:^{ NSURLSessionDataTask * task = \\[session dataTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSData * \\_Nullable data, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { NSLog(@&quot;任务一完成&quot;); }\\]; \\[task resume\\]; }\\]; // 再添加依赖 结论：仅仅使用 NSBlockOperation 来构建 operation 是不可以的。 这里的错误原因和使用 dispatch_group_async 是一样的。 但是，如果把 NSUrlConnection 的请求封装成 NSOperation 子类，使这个子类有这个效果：”当网络数据返回时，才算这个operation 的结束”，就可以利用这个子类和 NSOperationQueue 达到我们的目的！ 题外话：NSOperationQueue 不同于 dispatch_queue，它没有 dispatch_queue 中的并行、串行类型，但是，有个类似功能的属性 maxConcurrentOperationCount，当 maxConcurrentOperationCount = 1 时，自然就是串行了。 以下总结出了使用 urlSession 进行下载的通用方法，这个方法加入了对最大并发数的限制，也加入了全部完成后的回调。 - (void)viewDidLoad{ [super viewDidLoad]; dispatch\\_semaphore\\_t semaphore = dispatch\\_semaphore\\_create(3); // 初始信号量 = 3 dispatch\\_group\\_t group = dispatch\\_group\\_create(); NSURLSession * session = \\[NSURLSession sharedSession\\]; for (int i = 0; i &lt; 10; i++) { NSURLSessionDownloadTask * task =\\[session downloadTaskWithURL:\\[NSURL URLWithString:@&quot;https://www.baidu.com&quot;\\] completionHandler:^(NSURL * \\_Nullable location, NSURLResponse * \\_Nullable response, NSError * _Nullable error) { sleep(5.0); dispatch\\_group\\_leave(group); // 任务 + 1 dispatch\\_semaphore\\_signal(semaphore); // 信号 + 1 }\\]; dispatch\\_group\\_enter(group); //为了所有下载完成后能调用函数，引入 dispatch group。如果信号量是 1 的话，可以不使用 group dispatch\\_semaphore\\_wait(semaphore, DISPATCH\\_TIME\\_FOREVER); // 为了最大并发数，加入信号量机制 \\[task resume\\]; } dispatch\\_group\\_notify(group, dispatch\\_get\\_main_queue(), ^(){ NSLog(@&quot;End！&quot;); }); }","tags":[]},{"title":" OpenGL - 4 着色器\t\t","date":"2019-01-01T08:44:39.000Z","path":"2019/01/01/opengl-4-e7-9d-80-e8-89-b2-e5-99-a8/","text":"在 Hello Triangle 教程中提到，着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。 前面的教程里我们简要地触及了一点着色器的皮毛，并了解了如何恰当地使用它们。现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。 GLSL着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。 着色器的开头总是要声明版本，接着是输入和输出变量、uniform 和 main 函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是 uniform 也不用担心，我们后面会进行讲解。 一个典型的着色器有下面的结构： #version version_numberin type in_variable_name;in type in_variable_name; out type out_variable_name; uniform type uniform_name; int main(){ // 处理输入并进行一些图形操作 … // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;} 当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL 确保至少有 16 个包含 4 分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS 来获取具体的上限： int nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);std::cout &lt;&lt; “Maximum nr of vertex attributes supported: “ &lt;&lt; nrAttributes &lt;&lt; std::endl; 通常情况下它至少会返回 16 个，大部分情况下是够用了。 数据类型和其他编程语言一样，GLSL 有数据类型可以来指定变量的种类。GLSL 中包含 C 等其它语言大部分的默认基础数据类型：int、float、double、uint 和 bool。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)，其中矩阵我们会在之后的教程里再讨论。 向量GLSL 中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n 代表分量的数量）： 类型 含义 vecn 包含 n 个 float 分量的默认向量 bvecn 包含 n 个 bool 分量的向量 ivecn 包含 n 个 int 分量的向量 uvecn 包含 n 个 unsigned int 分量的向量 dvecn 包含 n 个 double 分量的向量 大多数时候我们使用 vecn，因为 float 足够满足大多数要求了。 一个向量的分量可以通过 vec.x 这种方式获取，这里 x 是指这个向量的第一个分量。你可以分别使用 .x、.y、.z 和 .w 来获取它们的第1、2、3、4个分量。GLSL 也允许你对颜色使用 rgba，或是对纹理坐标使用 stpq 访问相同的分量。 向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法： vec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy; 你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个 vec2 向量中去获取 .z 元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量： vec2 vect = vec2(0.5, 0.7);vec4 result = vec4(vect, 0.0, 0.0);vec4 otherResult = vec4(result.xyz, 1.0); 向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。学完教程你会看到很多新颖的管理向量的例子。 输入与输出虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL 定义了 in 和 out 关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。 顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用 location 这一元数据指定输入变量，这样我们才可以在 CPU 上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的 layout 标识，这样我们才能把它链接到顶点数据。 你也可以忽略 layout (location = 0) 标识符，通过在 OpenGL 代码中使用glGetAttribLocation 查询属性位置值(Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你和 OpenGL 的工作量。 另一个例外是片段着色器，它需要一个 vec4 颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL 会把你的物体渲染为黑色（或白色）。 所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL 就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。 顶点着色器 #version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0 out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main(){ gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色} 片段着色器 #version 330 coreout vec4 FragColor; in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main(){ FragColor = vertexColor;} 你可以看到我们在顶点着色器中声明了一个 vertexColor 变量作为 vec4 输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的 vertexColor 就和顶点着色器中的 vertexColor 链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。下面的图片展示了输出结果： 完成了！我们成功地从顶点着色器向片段着色器发送数据。让我们更上一层楼，看看能否从应用程序中直接给片段着色器发送一个颜色！ UniformUniform 是一种从 CPU 中的应用向 GPU 中的着色器发送数据的方式，但 uniform 和顶点属性有些不同。首先，uniform 是全局的(Global)。全局意味着 uniform 变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色： #version 330 coreout vec4 FragColor; uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main(){ FragColor = ourColor;} 我们在片段着色器中声明了一个 uniform vec4 的 ourColor，并把片段着色器的输出颜色设置为 uniform 值的内容。因为 uniform 是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个 uniform，所以我们不用在那里定义它。 如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！ 这个 uniform 现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中 uniform 属性的索引/位置值。当我们得到 uniform 的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色： float timeValue = glfwGetTime();float greenValue = (sin(timeValue) / 2.0f) + 0.5f;int vertexColorLocation = glGetUniformLocation(shaderProgram, “ourColor”);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 首先我们通过 glfwGetTime() 获取运行的秒数。然后我们使用sin函数让颜色在 0.0 到 1.0 之间改变，最后将结果储存到 greenValue里。 接着，我们用 glGetUniformLocation 查询 uniform ourColor 的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果 glGetUniformLocation 返回 -1 就代表没有找到这个位置值。最后，我们可以通过 glUniform4f函数设置 uniform 值。注意，查询 uniform 地址不要求你之前使用过着色器程序，但是更新一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。 因为 OpenGL 在其核心是一个 C 库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform 是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有： 后缀 含义 f 函数需要一个float作为它的值 i 函数需要一个int作为它的值 ui 函数需要一个unsigned int作为它的值 3f 函数需要3个float作为它的值 fv 函数需要一个float向量/数组作为它的值 每当你打算配置一个 OpenGL 的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定 uniform 的 4 个 float 值，所以我们通过 glUniform4f 传递我们的数据（注意，我们也可以使用 fv 版本）。 现在你知道如何设置uniform变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的每一次迭代中（所以他会逐帧改变）更新这个 uniform，否则三角形就不会改变颜色。下面我们就计算greenValue然后每个渲染迭代都更新这个 uniform： while(!glfwWindowShouldClose(window)){ // 输入 processInput(window); // 渲染 // 清除颜色缓冲 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL\\_COLOR\\_BUFFER_BIT); // 记得激活着色器 glUseProgram(shaderProgram); // 更新uniform颜色 float timeValue = glfwGetTime(); float greenValue = sin(timeValue) / 2.0f + 0.5f; int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // 绘制三角形 glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); // 交换缓冲并查询IO事件 glfwSwapBuffers(window); glfwPollEvents(); } 这里的代码对之前代码是一次非常直接的修改。这次，我们在每次迭代绘制三角形前先更新 uniform 值。如果你正确更新了uniform，你会看到你的三角形逐渐由绿变黑再变回绿色。 如果你在哪儿卡住了，可以到这里查看源码。 可以看到，uniform 对于设置一个在渲染迭代中会改变的属性是一个非常有用的工具，它也是一个在程序和着色器间数据交互的很好工具，但假如我们打算为每个顶点设置一个颜色的时候该怎么办？这种情况下，我们就不得不声明和顶点数目一样多的 uniform了。在这一问题上更好的解决方案是在顶点属性中包含更多的数据，这是我们接下来要做的事情。 更多属性！在前面的教程中，我们了解了如何填充 VBO、配置顶点属性指针以及如何把它们都储存到一个 VAO 里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为 3 个 float 值至vertices 数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色： float vertices[] = { // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部}; 由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用 layout 标识符来把 aColor 属性的位置值设置为 1： #version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1 out vec3 ourColor; // 向片段着色器输出一个颜色void main(){ gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色} 由于我们不再使用 uniform 来传递片段的颜色了，现在使用 ourColor 输出变量，我们必须再修改一下片段着色器： #version 330 coreout vec4 FragColor;in vec3 ourColor; void main(){ FragColor = vec4(ourColor, 1.0);} 因为我们添加了另一个顶点属性，并且更新了 VBO 的内存，我们就必须重新配置顶点属性指针。更新后的 VBO 内存中的数据现在看起来像这样： 知道了现在使用的布局，我们就可以使用 glVertexAttribPointer 函数更新顶点格式， // 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 sizeof(float), (void)0);glEnableVertexAttribArray(0);// 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 sizeof(float), (void)(3* sizeof(float)));glEnableVertexAttribArray(1); glVertexAttribPointer 函数的前几个参数比较明了。这次我们配置属性位置值为 1 的顶点属性。颜色值有 3 个 float 那么大，我们不去标准化这些值。 由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个 x 分量）我们必须向右移动 6 个 float，其中 3 个是位置值，另外 3 个是颜色值。这使我们的步长值为 6 乘以 float 的字节数（= 24字节）。同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是 0。颜色属性紧随位置数据之后，所以偏移量就是 3 * sizeof(float)，用字节来计算就是 12 字节。 运行程序你应该会看到如下结果： 如果你在哪卡住了，可以在这里查看源码。 这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。 基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。 这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。 我们自己的着色器类编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。 我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构： #ifndef SHADER_H #define SHADER_H #include &lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件 #include #include #include #include class Shader{public: // 程序ID unsigned int ID; // 构造器读取并构建着色器 Shader(const GLchar* vertexPath, const GLchar* fragmentPath); // 使用/激活程序 void use(); // uniform工具函数 void setBool(const std::string &amp;name, bool value) const; void setInt(const std::string &amp;name, int value) const; void setFloat(const std::string &amp;name, float value) const; }; #endif 在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor Directives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。 着色器类储存了着色器程序的 ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：use 用来激活着色器程序，所有的 set… 函数能够查询一个 unform 的位置值并设置它的值。 从文件读取我们使用 C++ 文件流读取着色器内容，储存到几个 string 对象里： Shader(const char vertexPath, const char fragmentPath){ // 1. 从文件路径中获取顶点/片段着色器 std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // 保证ifstream对象可以抛出异常： vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); try { // 打开文件 vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // 读取文件的缓冲内容到数据流中 vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // 关闭文件处理器 vShaderFile.close(); fShaderFile.close(); // 转换数据流到string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); } catch(std::ifstream::failure e) { std::cout &lt;&lt; “ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ” &lt;&lt; std::endl; } const char vShaderCode = vertexCode.c_str(); const char fShaderCode = fragmentCode.c_str(); […]} 下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）： // 2. 编译着色器unsigned int vertex, fragment;int success;char infoLog[512]; // 顶点着色器vertex = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex, 1, &amp;vShaderCode, NULL);glCompileShader(vertex);// 打印编译错误（如果有的话）glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);if(!success){ glGetShaderInfoLog(vertex, 512, NULL, infoLog); std::cout &lt;&lt; “ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n” &lt;&lt; infoLog &lt;&lt; std::endl;}; // 片段着色器也类似[…] // 着色器程序ID = glCreateProgram();glAttachShader(ID, vertex);glAttachShader(ID, fragment);glLinkProgram(ID);// 打印连接错误（如果有的话）glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);if(!success){ glGetProgramInfoLog(ID, 512, NULL, infoLog); std::cout &lt;&lt; “ERROR::SHADER::PROGRAM::LINKING_FAILED\\n” &lt;&lt; infoLog &lt;&lt; std::endl;} // 删除着色器，它们已经链接到我们的程序中了，已经不再需要了glDeleteShader(vertex);glDeleteShader(fragment); use 函数非常简单： void use(){ glUseProgram(ID);} uniform 的 setter 函数也很类似： void setBool(const std::string &amp;name, bool value) const{ glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);}void setInt(const std::string &amp;name, int value) const{ glUniform1i(glGetUniformLocation(ID, name.c_str()), value);}void setFloat(const std::string &amp;name, float value) const{ glUniform1f(glGetUniformLocation(ID, name.c_str()), value);} 现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了： Shader ourShader(“path/to/shaders/shader.vs”, “path/to/shaders/shader.fs”);…while(…){ ourShader.use(); ourShader.setFloat(“someUniform”, 1.0f); DrawStuff();} 我们把顶点和片段着色器储存为两个叫做 shader.vs 和 shader.fs 的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用 .vs 和 .fs 作为扩展名很直观。 你可以在这里找到使用新着色器类的源代码。注意你可以点击源码中的着色器文件路径来查看每一个着色器的源代码。 练习 修改顶点着色器让三角形上下颠倒：参考解答 使用 uniform 定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧：参考解答 使用 out 关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?：参考解答","tags":[]},{"title":" OpenGL - 3 绘制三角形\t\t","date":"2018-12-26T15:18:40.000Z","path":"2018/12/26/opengl-3/","text":"原文：https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/ 在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线管理的。 Graphics Pipeline大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。 图形渲染管线可以被划分为两个主要部分：第一部分把你的 3D 坐标转换为 2D 坐标；第二部分是把 2D 坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。 2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。 图形渲染管线接受一组 3D 坐标，然后把它们转变为屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在 GPU 上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。 有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在 GPU 上，所以它们可以给我们节约宝贵的 CPU 时间。OpenGL 着色器是用 OpenGL 着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中再花更多时间研究它。 下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是开发者可以注入自定义的着色器的部分。 如图所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。我们会概括性地解释一下渲染管线的每个部分，让你对图形渲染管线的工作方式有个大概了解。 首先，以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据Vertex Data；顶点数据是一系列顶点的集合。一个顶点是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，还是假定每个顶点只由一个 3D 位置和一些颜色值组成的吧。 当我们谈论一个”位置”的时候，它代表在一个”空间”中所处地点的这个特殊属性；同时”空间”代表着任何一种坐标系，比如 x、y、z 三维坐标系，x、y 二维坐标系，或者一条直线上的 x 和 y 的线性关系，只不过二维坐标系是一个扁扁的平面空间，而一条直线是一个很瘦的长长的空间。 为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给 OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并 把所有的点装配成指定图元的形状。本节例子是一个三角形。 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器（Fragment Shader）使用的片段（Fragment）。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等），这些数据可以被用来计算最终像素的颜色。 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 Alpha 测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板 Stencil）值，用它们来判断这个像素是在其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，开发者只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。 在现代 OpenGL 中，我们必须定义至少一个顶点着色器和一个片段着色器（因为 GPU 中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代 OpenGL 的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。 顶点输入开始绘制图形之前，我们必须先给 OpenGL 输入一些顶点数据。OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x、y 和 z）。OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素；OpenGL 仅当 3D 坐标在 3 个轴（x、y 和 z）上都为 [-1.0, 1.0] 的范围内时才处理它。所有的在标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上。 由于我们希望渲染一个三角形，那么一共要指定三个顶点，每个顶点都有一个 3D 位置。我们会将它们以标准化设备坐标的形式定义为一个 float 数组。 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f}; 由于 OpenGL 是在 3D 空间中工作的，而我们渲染的是一个 2D 三角形，将它顶点的 z 坐标设置为 0.0。这样三角形每一点的深度(Depth)都是一样的，从而使它看上去像是 2D 的。 通常深度可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。 标准化设备坐标(Normalized Device Coordinates, NDC) 一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 [-1.0, 1.0] 的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略 z 轴)： 与通常的屏幕坐标不同，y 轴正方向为向上，(0, 0) 坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。 你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在 GPU 上创建内存用于储存我们的顶点数据，还要配置 OpenGL 如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。 顶点缓冲对象是在OpenGL教程中第一个出现的 OpenGL 对象。就像 OpenGL 中的其它对象一样，这个缓冲有一个独一无二的 ID，所以我们可以使用 glGenBuffers 函数和一个缓冲 ID 生成一个 VBO 对象： unsigned int VBO;glGenBuffers(1, &amp;VBO); OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 glBindBuffer 函数把新创建的缓冲绑定到 GL_ARRAY_BUFFER目标上： glBindBuffer(GL_ARRAY_BUFFER, VBO); 从这一刻起，我们使用的任何（在 GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用 glBufferData 函数，它会把之前定义的顶点数据复制到缓冲的内存中： glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData 是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到 _GL_ARRAY_BUFFER_目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的 sizeof 计算出顶点数据大小就行。第三个参数是希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ： 数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ： 数据每次绘制时都会改变。 三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是 GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是 GL_DYNAMIC_DRAW或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。 现在我们已经把顶点数据储存在显卡的内存中，用 VBO这个顶点缓冲对象管理。下面我们会创建一个顶点和片段着色器来真正处理这些数据。现在我们开始着手创建它们吧。 顶点着色器顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代 OpenGL 需要我们至少设置一个顶点和一个片段着色器。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。下一节中我们会更详细的讨论着色器。 我们需要做的第一件事是用着色器语言 GLSL(OpenGL Shading Language) 编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的 GLSL 顶点着色器的源代码： #version 330 corelayout (location = 0) in vec3 aPos; void main(){ gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);} 可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和OpenGL 的版本是匹配的（比如说 GLSL 420 版本对应于 OpenGL 4.2）。我们同样明确表示我们会使用核心模式。 下一步，使用 in 关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 float 分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个 3D 坐标，我们就创建一个 vec3 输入变量 aPos。我们同样也通过 layout (location = 0) 设定了输入变量的位置值(Location)，后面会看到为什么我们会需要这个位置值。 向量(Vector) 在图形编程中经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 vec.x、vec.y、vec.z 和 vec.w 来获取。注意 vec.w分量不是用作表达空间中的位置的（我们处理的是 3D 不是 4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。 为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 gl_Position 变量，它在幕后是 vec4 类型的。在 main 函数的最后，我们将 gl_Position 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为 4 分量的。我们可以把 vec3 的数据作为 vec4 构造器的参数，同时把 w 分量设置为 1.0f（我们会在后面解释为什么）来完成这一任务。 当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内。 编译着色器我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码。 我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的。所以我们储存这个顶点着色器为 unsigned int，然后用glCreateShader 创建这个着色器： unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER); 我们把需要创建的着色器类型以参数形式提供给 glCreateShader。由于创建的是一个顶点着色器，所以传递的参数是GL_VERTEX_SHADER。 下一步我们把这个着色器源码附加到着色器对象上，然后编译它： glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader); glShaderSource 函数第一个参数是要编译的着色器对象；第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为 NULL。 你可能会希望检测在调用 glCompileShader 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现： int success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); 首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用 glGetShaderiv 检查是否编译成功。如果编译失败，我们会用 glGetShaderInfoLog 获取错误消息，然后打印它。 if(!success){ glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; “ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n” &lt;&lt; infoLog &lt;&lt; std::endl;} 如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。 片段着色器片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。 在计算机图形中颜色被表示为有 4 个元素的数组：红色、绿色、蓝色和 alpha(透明度)分量，通常缩写为 RGBA。当在 OpenGL 或 GLSL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过 1600 万种不同的颜色！ #version 330 coreout vec4 FragColor; void main(){ FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);} 片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用 out 关键字声明输出变量，这里我们命名为 FragColor。下面，我们将一个 alpha 值为 1.0(1.0 代表完全不透明)的橘黄色的 vec4 赋值给颜色输出。 编译片段着色器的过程与顶点着色器类似，只不过我们使用 GL_FRAGMENT_SHADER常量作为着色器类型： unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader); 两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。 着色器程序着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。 创建一个程序对象很简单： unsigned int shaderProgram;shaderProgram = glCreateProgram(); glCreateProgram 函数创建一个程序，并返回新创建程序对象的 ID 引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用 glLinkProgram 链接它们： glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 代码应该很清楚，我们把着色器附加到了程序上，然后用 glLinkProgram 链接。 就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，这里调用： glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); …} 得到的结果就是一个程序对象，我们可以调用 glUseProgram 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象： glUseProgram(shaderProgram); 在 glUseProgram 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器）了。 对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了： glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL怎么做。 链接顶点属性顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定 OpenGL 该如何解释顶点数据。 我们的顶点缓冲数据会被解析为下面这样子： 位置数据被储存为 32 位（4 字节）浮点值。 每个位置包含 3 个这样的值。 在这 3 个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。 数据中第一个值在缓冲开始的位置。 有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL 该如何解析顶点数据（应用到逐个顶点属性上）了： glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); glVertexAttribPointer 函数的参数非常多，所以逐一介绍它们： 第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用 layout(location = 0) 定义了 position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为 0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。 第二个参数指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。 第三个参数指定数据的类型，这里是 GL_FLOAT(GLSL中 vec* 都是由浮点数值组成的)。 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为 GL_TRUE，所有数据都会被映射到 0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为 GL_FALSE。 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float之后，我们把步长设置为 3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为 0 来让 OpenGL 决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注：这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组 0 位置之间有多少字节）。 最后一个参数的类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是 0。我们会在后面详细解释这个参数。 每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用glVetexAttribPointer 时绑定到 GL_ARRAY_BUFFER的 VBO 决定的。由于在调用 glVetexAttribPointer 之前绑定的是先前定义的 VBO对象，顶点属性 0 现在会链接到它的顶点数据。 现在我们已经定义了 OpenGL 该如何解释顶点数据，我们现在应该使用 glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。在 OpenGL 中绘制一个物体，代码会像是这样： // 0. 复制顶点数组到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 1. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0);// 2. 当我们渲染一个物体时要使用着色器程序glUseProgram(shaderProgram);// 3. 绘制物体someOpenGLFunctionThatDrawsOurTriangle(); 每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？ 顶点数组对象顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在VAO 中 OpenGL 的核心模式要求我们使用 VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定 VAO 失败，OpenGL 会拒绝绘制任何东西。 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray 和 glDisableVertexAttribArray 的调用。 通过 glVertexAttribPointer 设置的顶点属性配置。 通过 glVertexAttribPointer 调用与顶点属性关联的顶点缓冲对象。 创建一个 VAO 和创建一个 VBO 很类似： unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用 VAO，要做的只是使用 glBindVertexArray 绑定 VAO。从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。这段代码应该看起来像这样： // ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..// 1. 绑定VAOglBindVertexArray(VAO);// 2. 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); […] // ..:: 绘制代码（渲染循环中） :: ..// 4. 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle(); 就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO。 我们一直期待的三角形要想绘制我们想要的物体，OpenGL 给我们提供了 glDrawArrays 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元。 glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3); glDrawArrays 函数第一个参数是我们打算绘制的 OpenGL 图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填 0。最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有 3 个顶点长）。 现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果： 完整的程序源码可以在这里找到。 如果你的输出和这个看起来不一样，你可能做错了什么。去查看一下源码，检查你是否遗漏了什么东西，或者你也可以在评论区提问。 索引缓冲对象在渲染顶点中，还有最后一个需要讨论的–索引缓冲对象(Element Buffer Object, EBO，也叫 Index Buffer Object, IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL 主要处理三角形）。这会生成下面的顶点的集合： float vertices[] = { // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角}; 可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有 4 个而不是 6 个顶点，这样就产生 50% 的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果 OpenGL 提供这个功能就好了，对吧？ 很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO 也是一个缓冲，它专门储存索引，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引： float vertices[] = { 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角}; unsigned int indices[] = { // 注意索引从0开始! 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形}; 你可以看到，当时用索引的时候，我们只定义了 4 个顶点，而不是 6 个。下一步我们需要创建索引缓冲对象： unsigned int EBO;glGenBuffers(1, &amp;EBO); 与 VBO 类似，我们先绑定 EBO 然后用 glBufferData 把索引复制到缓冲里。同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 要注意的是，我们传递了 GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用 glDrawElements 来替换glDrawArrays 函数，来指明我们从索引缓冲渲染。使用 glDrawElements 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制： glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 第一个参数指定了我们绘制的模式，这个和 glDrawArrays 的一样。第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。第三个参数是索引的类型，这里是 GL_UNSIGNED_INT。最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0。 glDrawElements 函数从当前绑定到 GL_ELEMENT_ARRAY_BUFFER目标的 EBO 中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象。绑定 VAO 的同时也会自动绑定 EBO。 当目标是 GL_ELEMENT_ARRAY_BUFFER的时候，VAO 会储存 glBindBuffer 的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑 VAO 之前解绑索引数组缓冲，否则它就没有这个 EBO 配置了。 最后的初始化和绘制代码现在看起来像这样： // ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 sizeof(float), (void)0);glEnableVertexAttribArray(0); […] // ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)glBindVertexArray(0); 运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。 线框模式(Wireframe Mode) 要想用线框模式绘制你的三角形，你可以通过 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置 OpenGL 如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用 glPolygonMode(GL_FRONT_AND_BACK, GL_FILL) 将其设置回默认模式。 如果你遇到任何错误，回头检查代码，看看是否遗漏了什么。同时，可以在这里找到全部源码。 如果你像我这样成功绘制出了这个三角形或矩形，那么恭喜你，你成功地通过了现代 OpenGL 最难部分之一：绘制你自己的第一个三角形。这部分很难，因为在可以绘制第一个三角形之前你需要了解很多知识。幸运的是我们现在已经越过了这个障碍，接下来的教程会比较容易理解一些。 OC 示例 #import &lt;GLKit/GLKit.h&gt; @interface ViewController : GLKViewController@end @interface ViewController ()@property (nonatomic, strong) EAGLContext * context;@property (nonatomic, assign) GLint mCount;@end @implementation ViewController - (void)viewDidLoad{ [super viewDidLoad]; // 设置上下文 self.context = \\[\\[EAGLContext alloc\\] initWithAPI:kEAGLRenderingAPIOpenGLES3\\]; \\[EAGLContext setCurrentContext:self.context\\]; GLKView * glkView = (GLKView *)self.view; glkView.context = self.context; glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888; glkView.enableSetNeedsDisplay = NO; float vertexs\\[\\] = { -0.5, -0.5, 0.0, // 左下 -0.5, 0.5, 0.0, // 左上 0.5, -0.5, 0.0, // 右下 0.5, 0.5, 0.0 // 右上 }; GLuint indecs\\[\\] = { 0, 1, 2, 1, 2, 3 }; self.mCount = sizeof(indecs) / sizeof(GLuint); GLuint VBO; glGenBuffers(1, &amp;VBO); glBindBuffer(GL\\_ARRAY\\_BUFFER, VBO); // 之前定义的顶点数据复制到缓冲的内存中 glBufferData(GL\\_ARRAY\\_BUFFER, sizeof(vertexs), vertexs, GL\\_STATIC\\_DRAW); GLuint VEO; glGenBuffers(1, &amp;VEO); glBindBuffer(GL\\_ELEMENT\\_ARRAY_BUFFER, VEO); glBufferData(GL\\_ELEMENT\\_ARRAY\\_BUFFER, sizeof(indecs), indecs, GL\\_STATIC_DRAW); // 顶点着色器 GLuint vertexShader; vertexShader = glCreateShader(GL\\_VERTEX\\_SHADER); NSString * shaderFile = \\[\\[NSBundle mainBundle\\] pathForResource:@&quot;shader&quot; ofType:@&quot;vsh&quot;\\]; const GLchar * shaderString; NSString * string = \\[NSString stringWithContentsOfFile:shaderFile encoding:NSUTF8StringEncoding error:nil\\]; shaderString = (GLchar *)\\[string UTF8String\\]; glShaderSource(vertexShader, 1, &amp;shaderString, NULL); glCompileShader(vertexShader); // 编译 GLint success; glGetShaderiv(vertexShader, GL\\_COMPILE\\_STATUS, &amp;success); if (success != GL_TRUE) { GLint logLength; glGetShaderiv(vertexShader, GL\\_INFO\\_LOG_LENGTH, &amp;logLength); if (logLength &gt; 0) { GLchar * log = (GLchar *)malloc(logLength); glGetShaderInfoLog(vertexShader, logLength, &amp;logLength, log); NSLog(@&quot;顶点着色器编译错误信息：%s&quot;, log); free(log); } } // 片段着色器 GLuint fragmentShader; fragmentShader = glCreateShader(GL\\_FRAGMENT\\_SHADER); NSString * fragFile = \\[\\[NSBundle mainBundle\\] pathForResource:@&quot;Frag&quot; ofType:@&quot;fsh&quot;\\]; const GLchar * fragString; fragString = (GLchar *)\\[\\[NSString stringWithContentsOfFile:fragFile encoding:NSUTF8StringEncoding error:nil\\] UTF8String\\]; glShaderSource(fragmentShader, 1, &amp;fragString, NULL); glCompileShader(fragmentShader); glGetShaderiv(fragmentShader, GL\\_COMPILE\\_STATUS, &amp;success); if (success != GL_TRUE) { GLint logLength; glGetShaderiv(fragmentShader, GL\\_INFO\\_LOG_LENGTH, &amp;logLength); if (logLength &gt; 0) { GLchar * log = (GLchar *)malloc(logLength); glGetShaderInfoLog(vertexShader, logLength, &amp;logLength, log); NSLog(@&quot;片段着色器编译错误信息：%s&quot;, log); free(log); } } // 着色器程序 GLuint program; program = glCreateProgram(); // 附加 glAttachShader(program, vertexShader); glAttachShader(program, fragmentShader); glLinkProgram(program); glGetProgramiv(program, GL\\_LINK\\_STATUS, &amp;success); if (success != GL_TRUE) { GLint logLength; glGetProgramiv(program, GL\\_INFO\\_LOG_LENGTH, &amp;logLength); GLchar * log; if (logLength &gt; 0) { log = (GLchar *)malloc(logLength); glGetProgramInfoLog(program, logLength, &amp;logLength, log); NSLog(@&quot;链接着色器程序错误信息：%s&quot;, log); free(log); } } glUseProgram(program); // 删除着色器 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); glEnableVertexAttribArray(GLKVertexAttribPosition); /\\* 解析顶点数据 1、指定要配置的顶点属性。此处与 layout (location = 0) 对应 2、指定顶点属性的大小。顶点属性是一个 vec3，它由 3个值组成，所以大小是3 3、 */ glVertexAttribPointer(GLKVertexAttribPosition, 3, GL\\_FLOAT, GL\\_FALSE, 3 * sizeof(float), (void *)0); \\[glkView display\\]; } - (void)glkView:(GLKView *)view drawInRect:(CGRect)rect{ glClearColor(0, 1.0, 0, 1.0); glClear(GL_COLOR_BUFFER_BIT); // glDrawArrays(GL_TRIANGLES, 0, 3); glDrawElements(GL_TRIANGLES, self.mCount, GL_UNSIGNED_INT, 0);} 附加资源 antongerdelan.net/hellotriangle：Anton Gerdelan的渲染第一个三角形教程。 open.gl/drawing：Alexander Overvoorde的渲染第一个三角形教程。 antongerdelan.net/vertexbuffers：顶点缓冲对象的一些深入探讨。 调试：这个教程中涉及到了很多步骤，如果你在哪卡住了，阅读一点调试的教程是非常值得的（只需要阅读到调试输出部分）。 练习建议在继续下一节的学习之前先做完这些练习，确保你对这些知识有比较好的理解。 添加更多顶点到数据中，使用 glDrawArrays，尝试绘制两个彼此相连的三角形：参考解答 创建相同的两个三角形，但对它们的数据使用不同的 VAO 和 VBO：参考解答 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色：参考解答","tags":[]},{"title":" OpenGL 2\t\t","date":"2018-12-25T15:16:21.000Z","path":"2018/12/25/opengl-2/","text":"原文：https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/ 在绘制图形之前，需先创建一个 OpenGL 上下文和一个用于显示的窗口。然而，这些操作在每个系统上都是不一样的，OpenGL 有目的地从这些操作抽象出去。这意味着开发者不得不自己处理创建窗口，定义 OpenGL 上下文以及处理用户输入。 有几个流行的库 GLUT、SDL、SFML 和 GLFW，这些库节省了我们书写操作系统相关代码的时间，提供给我们一个窗口和上下文用来渲染。 不同平台有不同的库，在 Mac OSX 上已经由系统处理好了。 MacOSXGL functions on OSX have been weak linked since OSX 10.2; this means that you can call them directly and unimplemented extensions will resolve to NULL. Note that this means that you must parse the extension string to determine if a function is valid or not, or your program will crash. Apple recommends that programs which need getProcAddress functionality use NSSymbol to look up the function pointer directly. Sample code is provided in their documentation to accomplish this.","tags":[]},{"title":" OpenGL 1\t\t","date":"2018-12-25T14:44:28.000Z","path":"2018/12/25/opengl-1/","text":"原文：https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/ 一、OpenGL OpenGL 通常被认为是一个 API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而它本身并不是一个 API，它仅仅是一个由 Khronos组织制定并维护的规范( Specification )。 OpenGL 规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现的，将由编写 OpenGL 库的开发者自行决定。因为 OpenGL 规范并没有规定实现的细节，具体的 OpenGL 库允许使用不同的实现，只要其功能和结果与规范相匹配。 实际的 OpenGL 库的开发者通常是显卡的生产商。 二、核心模式与立即渲染模式 早期的 OpenGL 使用立即渲染模式(immediate mode，也就是固定渲染管线)，这个模式下 OpenGL 的大多数功能都被库隐藏起来，开发者很少能控制 OpenGL 内部计算的过程。 然而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从 OpenGL3.2 开始，规范文档开始废弃立即渲染模式，并鼓励开发者在 OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。 当使用 OpenGL 的核心模式时，OpenGL 迫使使用现代的函数。当试图使用一个已废弃的函数时，OpenGL 会抛出一个错误并终止绘图。 立即渲染模式从 OpenGL 实际运作中抽象掉了很多细节，因此它在易于学习的同时，很难让人去把握 OpenGL 具体是如何运作的。现代函数要求使用者真正理解 OpenGL 和图形编程，它更难于学习，然而提供了更高的灵活性和效率，更重要的是可以更深入的理解图形编程。 三、扩展 OpenGL 的一大特性就是对扩展的支持。当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以在一个新的 OpenGL 规范面世之前使用这个扩展提供的这些更先进更有效的图形功能。 四、状态机 OpenGL 是一个巨大的状态机：一系列的变量描述 OpenGL 此刻应当如何运行。 OpenGL 的状态通常被称为 OpenGL 上下文(context)。通常使用如下途径去更改 OpenGL 状态：设置选项、操作缓冲。最后在当前 OpenGL 上下文中渲染。 假设当我们想告诉 OpenGL 去画线段而不是三角形时，可以通过改变一些上下文变量来改变 OpenGL 状态，从而告诉 OpenGL如何去绘图。一旦改变了 OpenGL 的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。 当使用 OpenGL 时，会遇到一些状态设置函数 State-changing Function，这类函数将会改变上下文。以及状态使用函数 State-using Function，这类函数会根据当前 OpenGL 的状态执行一些操作。只要记住 OpenGL 本质上是个大状态机，就能更容易理解它的大部分特性。 五、对象 OpenGL 库是用 C 语言写的，同时也支持多种语言的派生，但其内核仍是一个 C 库。由于 C 的一些语言结构不易被翻译到其它的高级语言，因此 OpenGL 开发的时候引入了一些抽象层。”对象(Object)”就是其中一个。 在 OpenGL 中一个对象是指一些选项的集合，它代表 OpenGL 状态的一个子集。比如，可以用一个对象来代表绘图窗口的设置，之后就可以通过设置这个对象来改变绘制窗口的大小、支持的颜色位数等。可以把对象看做一个 C 风格的结构体： struct object_name { float option1; int option2; char[] name;}; 当我们使用一个对象时，通常看起来如下： // 将 OpenGL 上下文看成一个大的结构体struct OpenGL_Context { … object * object_Window_Target; …}; // 创建对象unsigned int objectId = 0;glGenObject(1, &amp;objectId);// 绑定对象至上下文glBindObject(GL_WINDOW_TARGET, objectId);// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);// 将上下文对象设回默认glBindObject(GL_WINDOW_TARGET, 0); 这一小段代码展现了你以后使用 OpenGL 时常见的工作流。 ①、创建一个对象 ②、用一个 id 保存它的引用（实际数据被储存在后台） ③、将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成 _GL_WINDOW_TARGET_） ④、设置窗口的选项 ⑤、将目标位置的对象 id 设回 0，解绑这个对象。 设置的选项将被保存在 objectId 所引用的对象中，一旦我们重新绑定这个对象到 _GL_WINDOW_TARGET_ 位置，这些选项就会重新生效。 使用对象的一个好处是在程序中，我们可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用 OpenGL 状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说有一些作为 3D 模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。 六、附加资源 opengl.org：OpenGL 官方网站。 OpenGL registry：包含 OpenGL 各版本的规范和扩展。","tags":[]},{"title":" 不重复随机数\t\t","date":"2018-12-24T14:20:44.000Z","path":"2018/12/24/e4-b8-8d-e9-87-8d-e5-a4-8d-e9-9a-8f-e6-9c-ba-e6-95-b0/","text":"一、iOS 随机数 srand((unsigned)time(0)); // 不加这句每次运行产生的随机数不变int i = rand() % 5; srandom(time(0)); // 不加这句每次运行产生的随机数不变int i = random() % 5; int i = arc4random() % 5; int i = arc4random_uniform(5); rand() 和 random() 实际并不是一个真正的伪随机数发生器，在使用之前需要先初始化随机种子，否则每次生成的随机数一样。 arc4random() 是一个真正的伪随机算法，不需要生成随机种子，因为第一次调用的时候就会自动生成。而且范围是 rand() 的两倍。在 iPhone 中，RAND_MAX 是 0x7fffffff (2147483647)，而 arc4random_uniform() 和 arc4random() 返回的最大值则是 0x100000000 (4294967296)。 精确度比较：arc4random_uniform() = arc4random() &gt; random() &gt; rand()。 1、在一些产品的源代码中，经常会发现有这样的语句：srand(unsigned(time(NULL))); ①、time() 函数表示返回 1970-1-1 00:00:00 到当前时间的秒数，而 time(NULL) 表示获取一个时间，准确的说是获取一个指针的地址。 ②、srand() 函数是产生随机数种子的。在产生随机数 rand() 被调用的时候，它会查看：如果用户之前调用过 srand(seed) 的话，它会重新调用一遍 srand(seed) 以产生随机数种子；如果发现没有调用过 srand(seed) 的话，会自动调用 srand(1) 一次。所以，如果希望 rand() 每次调用产生的值都不一样，就需要每次调用 srand(seed) 一次，而且 seed 不能相同。 综合上述两点，那就很明了了。 srand(unsigned(time(NULL))) 表示产生随机数种子以保证 rand() 调用的时候不会出现重复的随机值。 2、利用 arc4random_uniform() 产生随机数 Objective-C 中 arc4random() 函数用来生成随机数且不需要种子，但是这个函数生成的随机数范围比较大，需要用取模的算法对随机值进行限制，有点麻烦。 arc4random_uniform(x) 随机数函数更方便，可以用来产生 0～(x-1) 范围内的随机数，不需要再进行取模运算。如果要生成1～x 的随机数，可以写成：arc4random_uniform(x) ＋1。 二、生成浮点数 #define ARC4RANDOM_MAX 0x100000000 double val = floorf(((double)arc4random() / ARC4RANDOM_MAX) * 100.0f); 三、生成不重复随机数 原理：利用两个数组，第一个数组存放要随机的原始数据，第二个数组存放结果；然后 arc4random() 产生一个随机数，将这个随机数用作下标，把原始数组对应下标的数据取出并删除。取出后存入第二个数组。然后循环往复就可以了。即便两次 arc4random 产生的随机数是相同的，但原始数组对应下标的数据却是不一样的。 例：0-7 乱序输出 { // 原始数据数组 NSMutableArray originArr = [[NSMutableArray alloc] initWithObjects:@1, @2, @3, @4, @5, @6, @7, @8, @9, nil]; // 结果数组 NSMutableArray resultArr = [[NSMutableArray alloc] initWithCapacity:0]; // 只取出 5 个数 for (int i = 0; i &lt; 5; i++) { int t = arc4random() % originArr.count; resultArr\\[i\\] = originArr\\[t\\]; originArr\\[t\\] = \\[originArr lastObject\\]; \\[originArr removeLastObject\\]; } }","tags":[]},{"title":" addChildViewController\t\t","date":"2018-12-16T07:36:58.000Z","path":"2018/12/16/addchildviewcontroller/","text":"/* These two methods are public for container subclasses to call when transitioning between child controllers. If they are overridden, the overrides should ensure to call the super. The parent argument in both of these methods is nil when a child is being removed from its parent; otherwise it is equal to the new parent view controller. addChildViewController: will call [child willMoveToParentViewController:self] before adding the child. However, it will not call didMoveToParentViewController:. It is expected that a container view controller subclass will make this call after a transition to the new child has completed or, in the case of no transition, immediately after the call to addChildViewController:. Similarly, removeFromParentViewController does not call [self willMoveToParentViewController:nil] before removing the child. This is also the responsibilty of the container subclass. Container subclasses will typically define a method that transitions to a new child by first calling addChildViewController:, then executing a transition which will add the new child’s view into the view hierarchy of its parent, and finally will call didMoveToParentViewController:. Similarly, subclasses will typically define a method that removes a child in the reverse manner by first calling [child willMoveToParentViewController:nil]. */ - (void)willMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0); - (void)didMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0); 使用： [parentVC addChildViewController:childVC];childVC.view.frame = parentVC.view.bounds;[parentVC.view addSubview:childVC.view];[childVC didMoveToParentViewController:parentVC]; // 添加（系统不会自动调用） [childVC willMoveToParentViewController:nil]; // 移除","tags":[]},{"title":" lldb\t\t","date":"2018-12-10T08:02:51.000Z","path":"2018/12/10/lldb/","text":"1、根据内存地址获取对应的类名 (lldb) p ((id)0x00000001017921d0)-&gt;isa (Class) $3 = UILabel https://www.jianshu.com/p/a023c325ee23 https://www.jianshu.com/p/97c2493e3e88","tags":[]},{"title":" Flutter\t\t","date":"2018-12-09T12:17:08.000Z","path":"2018/12/09/flutter/","text":"1、-bash: fultter: command not found 终端输入以下命令让配置立即生效。 source ~/.bashrc 2、检查依赖项 $ brew update ①、解决 “brew update” 无响应。如果已翻墙则不必修改镜像地址。 $ cd /usr/local/Homebrew$ git remote -vorigin https://github.com/Homebrew/brew (fetch)origin https://github.com/Homebrew/brew (push) 清华镜像源：git://mirrors.tuna.tsinghua.edu.cn/homebrew.git中科大镜像源：http://mirrors.ustc.edu.cn/homebrew.git 以下命令更换镜像地址： git remote set-url origin git://mirrors.tuna.tsinghua.edu.cn/homebrew.git 其他按照指示下载或更新，其中有些与 Xcode 的版本有关。 文章：Flutter安装其他依赖遇到的问题（Windows）","tags":[]},{"title":" UITableView\t\t","date":"2018-12-07T09:34:49.000Z","path":"2018/12/07/uitableview/","text":"一、SwipeTableView 使用问题 测试手机：iPhone 7、iOS 12.0.1代码：UICollectionView + UITableView /// UICollectionView- (UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath )indexPath{ MyCell cell = [collectionView dequeueReusableCellWithReuseIdentifier:@”MyCell” forIndexPath:indexPath]; \\[cell.tableView reloadData\\]; return cell; } /// UITableView- (CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath{ if (indexPath.item % 5 == 0 || indexPath.item % 5 == 4) { return 50; } else if (indexPath.item % 5 == 1 || indexPath.item % 5 == 2) { return 55; } return 60; } UITableView 执行 reloadData 刷新时，会调用 scrollViewDidScroll 代理方法，导致 SwipeTableView 类库监听时设置 contentOffset 出错。在其他场景还可能出现页面跳动的问题或者执行动画的时候出现了动画异常。 原因： 在 iOS 11中默认启用 Self-Sizing。 开启 Self-Sizing 之后，tableView 使用 estimateRowHeight 属性，这会造成 contentSize 和 contentOffset 值的变化，如果是有动画是观察这两个属性的变化进行的，就会造成动画的异常，因为在估算行高机制下，contentSize 的值是一点点地变化更新的，所有 cell 显示完后才是最终的 contentSize 值。 因为不会缓存正确的行高，tableView reloadData 时会重新计算 contentSize，这可能会引起 contentOffset 的变化。 解决： iOS11 下不想使用 Self-Sizing 的话，可以通过以下方式关闭： self.tableView.estimatedRowHeight = 0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0; 二、退出界面时设置 contentOffset (lldb) po NSThread.callStackSymbols &lt;_NSCallStackArray 0x600003d8a190&gt;(0 ??? 0x000000012128c177 0x0 + 4851286391,1 Demo 0x0000000104d685a0 main + 0,2 Foundation 0x000000010525dfeb NSKeyValueNotifyObserver + 332,3 Foundation 0x0000000105261696 NSKeyValueDidChange + 489,4 Foundation 0x0000000105260f85 -[NSObject(NSKeyValueObservingPrivate) _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:] + 790,5 Foundation 0x00000001052618ad -[NSObject(NSKeyValueObservingPrivate) _changeValueForKey:key:key:usingBlock:] + 68,6 Foundation 0x000000010525c6f3 _NSSetPointValueAndNotify + 281,7 UIKitCore 0x000000010b9163f5 -[UIScrollView(UIScrollViewInternal) _adjustContentOffsetIfNecessary] + 53,8 UIKitCore 0x000000010b8f35af -[UIScrollView setContentSize:] + 2131,9 UIKitCore 0x000000010b6c27f7 -[UITableView setContentSize:] + 42,10 UIKitCore 0x000000010b6c286f -[UITableView setContentSize:skipContentOffsetAdjustment:] + 97,11 UIKitCore 0x000000010b694b6c -[UITableView _updateContentSizeSkippingContentOffsetAdjustment:] + 679,12 UIKitCore 0x000000010b6c3a1f -[UITableView _rebuildGeometryForcingRowDataUpdate:skipContentOffsetAdjustment:updateImmediatelyIfPossible:] + 113,13 UIKitCore 0x000000010b6c146f -[UITableView didMoveToWindow] + 145,14 UIKitCore 0x000000010b974585 -[UIView(Internal) _didMoveFromWindow:toWindow:] + 1820,15 UIKitCore 0x000000010b8f5a40 -[UIScrollView _didMoveFromWindow:toWindow:] + 88,16 UIKitCore 0x000000010b97412b -[UIView(Internal) _didMoveFromWindow:toWindow:] + 706,17 UIKitCore 0x000000010b97412b -[UIView(Internal) didMoveFromWindow:toWindow:] + 706,18 UIKitCore 0x000000010b966814 \\_45-[UIView(Hierarchy) _postMovedFromSuperview:]_block_invoke + 151,19 UIKitCore 0x000000010b9666f3 -[UIView(Hierarchy) _postMovedFromSuperview:] + 804,20 UIKitCore 0x000000010b977125 -[UIView(Internal) _addSubview:positioned:relativeTo:] + 1951,21 UIKitCore 0x000000010b938e6f -[UITransitionView transition:fromView:toView:removeFromView:] + 1548,22 UIKitCore 0x000000010b93884b -[UITransitionView transition:fromView:toView:] + 63,23 UIKitCore 0x000000010b93857d -[UITransitionView transition:toView:] + 155,24 UIKitCore 0x000000010ada63c1 -[UITabBarController transitionFromViewController:toViewController:transition:shouldSetSelected:] + 1764,25 UIKitCore 0x000000010ada532c -[UITabBarController transitionFromViewController:toViewController:] + 59,26 UIKitCore 0x000000010ada1381 -[UITabBarController _setSelectedViewController:] + 410,27 UIKitCore 0x000000010ada1155 -[UITabBarController setSelectedViewController:] + 109,28 UIKitCore 0x000000010ada5255 -[UITabBarController _tabBarItemClicked:] + 599,29 UIKitCore 0x000000010b494ecb -[UIApplication sendAction:to:from:forEvent:] + 83,30 UIKitCore 0x000000010ac7e73e -[UITabBar _sendAction:withEvent:] + 597,31 UIKitCore 0x000000010b494ecb -[UIApplication sendAction:to:from:forEvent:] + 83,32 UIKitCore 0x000000010aed00bd -[UIControl sendAction:to:forEvent:] + 67,33 UIKitCore 0x000000010aed03da -[UIControl _sendActionsForEvents:withEvent:] + 450,34 UIKitCore 0x000000010ac810ad -[UITabBar _buttonUp:] + 113,35 UIKitCore 0x000000010b494ecb -[UIApplication sendAction:to:from:forEvent:] + 83,36 UIKitCore 0x000000010aed00bd -[UIControl sendAction:to:forEvent:] + 67,37 UIKitCore 0x000000010aed03da -[UIControl _sendActionsForEvents:withEvent:] + 450,38 UIKitCore 0x000000010aecf31e -[UIControl touchesEnded:withEvent:] + 583,39 UIKitCore 0x000000010b4d00a4 -[UIWindow sendTouchesForEvent:] + 2729,40 UIKitCore 0x000000010b4d17a0 -[UIWindow sendEvent:] + 4080,41 UIKitCore 0x000000010b4af394 -[UIApplication sendEvent:] + 352,42 UIKitCore 0x000000010b5845a9 dispatchPreprocessedEventFromEventQueue + 3054,43 UIKitCore 0x000000010b5871cb handleEventQueueInternal + 5948,44 CoreFoundation 0x0000000106635721 \\_CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17,45 CoreFoundation 0x0000000106635054 CFRunLoopDoSources0 + 436,46 CoreFoundation 0x000000010662f63f CFRunLoopRun + 1263,47 CoreFoundation 0x000000010662ee11 CFRunLoopRunSpecific + 625,48 GraphicsServices 0x000000010ea411dd GSEventRunModal + 62,49 UIKitCore 0x000000010b49381d UIApplicationMain + 140,50 Demo 0x0000000104d68610 main + 112,51 libdyld.dylib 0x0000000107b6d575 start + 1) 系统在切换界面时，会将 contentOffset 设置 CGPoint{ 0, 0 }，如果观察了 “contentOffset” 属性，并修改 contentOffset 属性，那么就会滚动到顶部了。文章。 也有出现切换界面后，TableVIew 被移除了，但还是执行代理方法的，只需要： - (void)dealloc{ self.tableView.delegate = nil; self.tableView.dataSource = nil;}","tags":[]},{"title":" Block\t\t","date":"2018-12-02T16:28:05.000Z","path":"2018/12/03/block/","text":"一、什么是闭包在 wikipedia 上，闭包的定义是: In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function. 翻译过来，闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量（有时候也称作自由变量）。 block 实际上就是 Objective-C 语言对于闭包的实现。 block 配合上 dispatch_queue，可以方便地实现简单的多线程编程和异步编程，《使用GCD》。 本文主要介绍 Objective-C 语言的 block 在编译器中的实现方式。主要包括： block 的内部实现数据结构介绍 block 的三种类型及其相关的内存管理方式 block 如何通过 capture 变量来达到访问函数外的变量 二、实现方式 block 本身也是一个 OC 对象，它里面也有 isa 指针 block 是封装了函数调用（存储函数调用地址，函数访问变量）和函数调用环境的 OC 对象 在 main.m 中写入一个 block： int main(int argc, char * argv[]) { @autoreleasepool { int a = 15; void (^ block)(int, int) = ^ (int b, int c) { NSLog(@&quot;%d&quot;, a); }; block(10, 10); return UIApplicationMain(argc, argv, nil, NSStringFromClass(\\[AppDelegate class\\])); } } 终端进到项目 main.m 的目录下通过反编译成 c++ 文件： xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian.cpp 得到 main.cpp，找到这个 block 对象的底层结构： int main(int argc, char argv[]) { /\\ @autoreleasepool / { __AtAutoreleasePool __autoreleasepool; int a = 15; void ( block)(int, int) = ((void ()(int, int))&amp;__main_block_impl_0((void )__main_block_func_0, &amp;__main_block_desc_0_DATA, a)); ((void ()(__block_impl , int, int))((__block_impl )block)-&gt;FuncPtr)((__block_impl )block, 10, 10); return UIApplicationMain(argc, argv, \\_\\_null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc\\_msgSend)((id)objc\\_getClass(&quot;AppDelegate&quot;), sel\\_registerName(&quot;class&quot;)))); } } 实际上 block 在底层对应的就是 __main_block_impl_0： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0 Desc; int a; __main_block_impl_0(void \\fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; 里面存储着 __block_impl 的结构体 impl，以及 __main_block_desc_0 的结构体指针 Desc. 搜索对象的内容我们可以找到: struct __block_impl { void isa; int Flags; int Reserved; void FuncPtr;}; static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; 这里可以看到 __block_impl 包含着 isa 指针，以及 FuncPtr。FuncPtr 就是 block 的调用地址，是在声明 block 的时候初始化传递进来的。以及 __main_block_desc_0 包含着的 Block_size 为 block 的内存大小。还有 int a 也封装到了Block 内部，我们知道 OC 对象的特征就是 isa 指针，所以，block 就是封装了函数调用、以及函数调用环境的 OC 对象。 反编译成 C 文件： xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.c block 的数据结构定义如下： 对应的结构体定义如下： struct Block_descriptor { unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void src); void (\\dispose)(void *);}; struct Block_layout { void isa; int flags; int reserved; void (\\invoke)(void *, …); struct Block_descriptor descriptor; / Imported variables. */}; 通过该图，我们可以知道，一个 block 实例实际上由 6 部分构成： isa 指针，所有对象都有该指针，用于实现对象相关的功能。 flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 reserved，保留变量。 invoke，函数指针，指向具体的 block 实现的函数调用地址。 descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。 三、Capture (捕获)对于局部变量：值传递，Block 只是把局部变量的值捕获存储在了 block 的结构体内存储。 int a = 10;void (^block)(void) = ^{ NSLog(@”%d”, a);};a = 20;block(); // 输出 10 对于 Static：指针传递，Block 把 static 的变量的指针存储在 block 的结构体内，所以取值的话就是取对应最后的赋值。 static int a = 10;void (^block)(void) = ^{ NSLog(@”%d”, a);};a = 20;block(); // 输出 20 全局变量：直接访问 static int a = 20;int b = 15; int main(int argc, const char * argv[]) { @autoreleasepool { void (^block)(void) = ^{ NSLog(@&quot;%d&quot;, a); NSLog(@&quot;%d&quot;, b); }; a = 25; b = 10; block(); // 输出 25 10 } return 0; } 四、block 的类型block 分为 3 种类型，但是最终都是继承自 NSObject。 _NSConcreteGlobalBlock 全局的静态 block，内部没有访问 auto 变量，不会访问任何外部变量。 _NSConcreteStackBlock 保存在栈中的 block，内部访问了 auto 变量，当函数返回时会被销毁。 _NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。 Tip：stack block 存放在栈内存，如果 block 存放在函数内，一旦函数作用域结束，则 block 内容则会被清除，如果存放在堆内存（调用 copy），就会变成 malloc block，则不会自动清除，这也是为什么 block 需要用 copy 修饰的原因。 1、NSConcreteGlobalBlock 类型的 block 的实现 #include &lt;stdio.h&gt; int main(){ ^{ printf(“Hello, World!\\n”); } (); return 0; } 在终端命令行中输入 clang -rewrite-objc block.cpp(文件名) 即可在目录中看到 clang 输出了一个名为 block.cpp 的文件。该文件就是 block 在 c 语言实现，将 block.cpp 中一些无关的代码去掉，将关键代码引用如下： struct __block_impl { void isa; int Flags; int Reserved; void FuncPtr;}; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0 Desc; __main_block_impl_0(void \\fp, struct __main_block_desc_0 *desc, int flags=0) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }}; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { printf(“Hello, World!\\n”);} static struct __main_block_desc_0 { size_t reserved; size_t Block_size;}__main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0) }; int main(){ (void ()())&amp;__main_block_impl_0((void )__main_block_func_0, &amp;__main_block_desc_0_DATA) (); return 0;} 具体看一下是如何实现的。__main_block_impl_0 就是该 block 的实现，从中可以看出： ①、一个 block 实际是一个对象，它主要由一个 isa 和一个 impl 和一个 descriptor 组成。 ②、在本例中，isa 指向 _NSConcreteGlobalBlock，主要是为了实现对象的所有特性，在此我们就不展开讨论了。 ③、impl 是实际的函数指针，本例中，它指向 __main_block_func_0。这里的 impl 相当于之前提到的 invoke 变量，只是clang 编译器对变量的命名不一样而已。 ④、descriptor 是用于描述当前这个 block 的附加信息的，包括结构体的大小，需要 capture 和 dispose 的变量列表等。结构体大小需要保存是因为，每个 block 因为会 capture 一些变量，这些变量会加到 __main_block_impl_0 这个结构体中，使其体积变大。在该例子中我们还看不到相关 capture 的代码，后面将会看到。 2、NSConcreteStackBlock 类型的block的实现 #include &lt;stdio.h&gt; int main(){ int a = 100; void (^block)(void) = ^{ printf(“%d\\n”, a); }; block(); return 0; } 反编译之后： struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0 Desc; int a; __main_block_impl_0(void \\fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) { impl.isa = &amp;NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void \\_main_block_func_0(struct __main_block_impl_0 *cself) { int a = cself-&gt;a; // bound by copy printf(“%d\\n”, a);} static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; int main(){ int a = 100; void (*block)(void) = (void (*)())&amp;__main_block_impl_0((void )__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void ()(__block_impl ))((__block_impl )block)-&gt;FuncPtr)((__block_impl *)block); return 0; } 在本例中，我们可以看到： ①、本例中，isa 指向 _NSConcreteStackBlock，说明这是一个分配在栈上的实例。 ②、main_block_impl_0 中增加了一个变量 a，在 block 中引用的变量 a 实际是在申明 block 时，被复制到 main_block_impl_0 结构体中的那个变量 a。因为这样，我们就能理解，在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a。 ③、main_block_impl_0 中由于增加了一个变量 a，所以结构体的大小变大了，该结构体大小被写在了 main_block_desc_0 中。 3、NSConcreteMallocBlock 类型的block的实现 NSConcreteMallocBlock 类型的 block 通常不会在源码中直接出现，因为默认它是当一个 block 被 copy 的时候，才会将这个 block 复制到堆中。以下是一个 block 被 copy 时的示例代码（来自这里），可以看到，在第 8 步，目标的 block 类型被修改为 _NSConcreteMallocBlock。 static void *_Block_copy_internal(const void *arg, const int flags) { struct Block_layout *aBlock; const bool wantsOne = (WANTS_ONE &amp; flags) == WANTS_ONE; // 1 if (!arg) return NULL; // 2 aBlock = (struct Block_layout *)arg; // 3 if (aBlock-&gt;flags &amp; BLOCK\\_NEEDS\\_FREE) { // latches on high latching\\_incr\\_int(&amp;aBlock-&gt;flags); return aBlock; } // 4 else if (aBlock-&gt;flags &amp; BLOCK\\_IS\\_GLOBAL) { return aBlock; } // 5 struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size); if (!result) return (void *)0; // 6 memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first // 7 result-&gt;flags &amp;= ~(BLOCK\\_REFCOUNT\\_MASK); // XXX not needed result-&gt;flags |= BLOCK\\_NEEDS\\_FREE | 1; // 8 result-&gt;isa = _NSConcreteMallocBlock; // 9 if (result-&gt;flags &amp; BLOCK\\_HAS\\_COPY_DISPOSE) { (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup } return result; } 五、变量的复制block 内部默认是无法修改 auto 变量的，因为在 block 底部的话执行 block、声明局部变量 a（main 函数）的地方分别是两个不同的函数，并没有办法从一个函数去修改另一个函数的局部变量，而如果使用 static 或者使用全局变量是可以的，因为block 在底层存储 static 变量是存储它的指针地址，全局变量就全部都可以访问。 如果要修改 auto 变量的话，则需要使用 __block。 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的： 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的： 修改上面的源码，在变量前面增加 __block 关键字： #include &lt;stdio.h&gt; int main(){ __block int i = 1024; void (^block)(void) = ^{ printf(“%d\\n”, i); i = 1023; }; block(); return 0;} 生成的关键代码如下，可以看到，差异相当大： struct __Block_byref_a_0 { void __isa;__Block_byref_a_0 forwarding; int flags; int __size; int a;}; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0 Desc; __Block_byref_a_0 a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 _a, int flags=0) : a(_a-&gt;__forwarding) { impl.isa = &amp;NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void \\_main_block_func_0(struct __main_block_impl_0 cself) { __Block_byref_a_0 *a = cself-&gt;a; // bound by ref printf(&quot;%d\\\\n&quot;, (a-&gt;__forwarding-&gt;a)); (a-&gt;__forwarding-&gt;a) = 1023; } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void)&amp;dst-&gt;a, (void)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);} static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);} static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0); void (\\dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main(int argc, char argv[]) { /\\ @autoreleasepool / { __AtAutoreleasePool __autoreleasepool; __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void)0,(__Block_byref_a_0 )&amp;a, 0, sizeof(__Block_byref_a_0), 1024}; void (\\block)(void) = ((void (*)())&amp;__main_block_impl_0((void )__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 )&amp;a, 570425344)); ((void ()(__block_impl ))((__block_impl )block)-&gt;FuncPtr)((__block_impl )block); return UIApplicationMain(argc, argv, \\_\\_null, NSStringFromClass(((Class (*)(id, SEL))(void *)objc\\_msgSend)((id)objc\\_getClass(&quot;AppDelegate&quot;), sel\\_registerName(&quot;class&quot;)))); } } 从代码中可以看到： ①、源码中增加一个名为 __Block_byref_i_0 的结构体，用来保存我们要 capture 并且修改的变量 a。 ②、main_block_impl_0 中引用的是 Block_byref_i_0 的结构体指针，这样就可以达到修改外部变量的作用。 ③、__Block_byref_i_0 结构体中带有 isa、a以及 __forwarding（指向自己的指针）等其他信息，它也是一个对象。 ④、我们需要负责 Block_byref_i_0 结构体相关的内存管理，所以 main_block_desc_0 中增加了 copy 和 dispose 函数指针，对于在调用前后修改相应变量的引用计数。 __attribute__((__blocks__(byref))) __Block_byref_a_0 a = {(void)0,(__Block_byref_a_0 )&amp;a, 0, sizeof(__Block_byref_a_0), 1024};void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void )__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 )&amp;a, 570425344)); 这里声明了一个 __Block_byref_a_0 的对象，并把 &amp;a 传递给了 __forwarding，10 传递给了 a。 static void __main_block_func_0(struct __main_block_impl_0 __cself) { __Block_byref_a_0 a = __cself-&gt;a; // bound by ref printf(&quot;%d\\\\n&quot;, (a-&gt;__forwarding-&gt;a)); (a-&gt;__forwarding-&gt;a) = 1023; } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void)&amp;dst-&gt;a, (void)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);} 这里执行 block 时，取出了 __Block_byref_a_0 所存储的 &amp;a（__forwarding：__Block_byref_a_0 的指针地址），再取出 a，最后进行修改/使用。 六、ARC 对 block 类型的影响在 ARC 开启的情况下，将只会有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。 原本的 NSConcreteStackBlock 的 block 会被 NSConcreteMallocBlock 类型的 block 替代。在苹果的官方文档中也提到，当把栈中的 block 返回时，不需要调用 copy 方法了。 int main(int argc, char * argv[]) { @autoreleasepool { int i = 1024; void (^block)(void) = ^{ printf(“%d\\n”, i); }; block(); NSLog(@”%@”, block); return UIApplicationMain(argc, argv, nil, NSStringFromClass(\\[AppDelegate class\\])); } } 个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。 七、问题1、block 原理是什么？本质是什么？ 封装了函数调用以及调用环境的 OC 对象。 2、Block 属性的修饰词为什么是 copy？__block 的作用是什么？有什么注意的点？ 一旦没有进行 copy 操作，block 就不会在堆上。__block 能够修改自动变量的值。注意循环引用。 3、block 修改 NSMutableArray 时，是否需要添加 __block？ { NSMutableArray mArr1 = [NSMutableArray arrayWithObjects:@”a”, @”b”, @”abc”, nil]; NSMutableArray mArr2 = [NSMutableArray arrayWithCapacity:mArr1.count]; \\[mArr1 enumerateObjectsUsingBlock: ^(NSString * obj, NSUInteger idx, BOOL *stop){ \\[mArr2 addObject:@(obj.length)\\]; }\\]; NSLog(@&quot;%@&quot;, mArr2); } 2018-12-03 00:24:41.754700+0800 Demo[13081:1899280] ( 1, 1, 3) 这里确实没有修改 mArr2 这个局部变量。mArr2 是一个指针，指向一个可变长度的数组。在 block 里面，并没有修改这个指针，而是修改了这个指针指向的数组。换句话说，mArr2 保存的是一块内存区域的地址，在 block 里，并没有改变这个地址，而是读取出这个地址，然后去操作这块地址空间的内容。 因为声明 block 的时候实际上是把当时的临时变量又复制了一份，在 block 里即使修改了这些复制的变量，也不影响外面的原始变量。即所谓的闭包。 但是当变量是一个指针的时候，block 里只是复制了一份这个指针，两个指针指向同一个地址。所以，在 block 里面对指针指向内容做的修改，在 block 外面也一样生效。 八、学习文章宁夏灼雪__ iOS底层day6 - 探索block","tags":[]},{"title":" Category\t\t","date":"2018-12-02T13:28:00.000Z","path":"2018/12/02/category/","text":"原文：宁夏灼雪__ iOS底层day4 - 探索Category的实现 分类可以拓展类的属性、方法、协议等信息 一、底层结构在 objc-4 的源码中，搜索 category_t 可以看到: struct category_t { const char name; classref_t cls; struct method_list_t instanceMethods; struct method_list_t classMethods; struct protocol_list_t protocols; struct property_list_t instanceProperties; // Fields below this point are not always present on disk. struct property_list_t _classProperties; method\\_list\\_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property\\_list\\_t \\*propertiesForMeta(bool isMeta, struct header_info \\*hi); }; category_t 就是一个分类的结构体，而我们所创建的的一个分类其实就是一个 category_t 的结构体，category_t 里面的结构跟类对象的结构很相似，包含了 name（名称，类名），instanceMethods（对象方法）、classMethods（类方法）、protocols（协议）、属性等。 在编译的时候，分类的属性、方法、协议等会先存储在这个结构体里面，在运行的时候，使用 runtime 动态的把分类里面的方法、属性、协议等添加到类对象（元类对象）中，具体源码可以查看。源码解读顺序： objc-os.mm _objc_init() map_images() map_images_nolock() objc-runtime-new.mm _read_images() remethodizeClass() attachCategories() attachLists() realloc、memmove、memcpy 最终可以找到这个方法 attachCategories static voidattachCategories(Class cls, category_list *cats, bool flush_caches){ if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); // 判断是否元类 bool isMeta = cls-&gt;isMetaClass(); // fixme rearrange to remove these intermediate allocations /\\* 方法数组 @\\[ @\\[method\\_t, method\\_t\\], @\\[method_t .....\\] \\] */ method\\_list\\_t \\*\\*mlists = (method\\_list\\_t \\*\\*) malloc(cats-&gt;count * sizeof(*mlists)); /\\* 属性数组 @\\[ @\\[property\\_t, property\\_t\\], @\\[property_t .....\\] \\] */ property\\_list\\_t \\*\\*proplists = (property\\_list\\_t \\*\\*) malloc(cats-&gt;count * sizeof(*proplists)); /\\* 协议数组 @\\[ @\\[peotocol\\_t, peotocol\\_t\\], @\\[peotocol_t .....\\] \\] */ protocol\\_list\\_t \\*\\*protolists = (protocol\\_list\\_t \\*\\*) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; int propcount = 0; int protocount = 0; int i = cats-&gt;count; bool fromBundle = NO; while (i--) { auto&amp; entry = cats-&gt;list\\[I\\]; // 将所有分类的对象方法，附加到类对象列表中 method\\_list\\_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) { mlists\\[mcount++\\] = mlist; fromBundle |= entry.hi-&gt;isBundle(); } // 将所有分类的属性，附加到类属性列表中 property\\_list\\_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta, entry.hi); if (proplist) { proplists\\[propcount++\\] = proplist; } // 将所有分类的协议，附加到类协议列表中 protocol\\_list\\_t *protolist = entry.cat-&gt;protocols; if (protolist) { protolists\\[protocount++\\] = protolist; } } auto rw = cls-&gt;data(); prepareMethodLists(cls, mlists, mcount, NO, fromBundle); rw-&gt;methods.attachLists(mlists, mcount); free(mlists); if (flush_caches &amp;&amp; mcount &gt; 0) flushCaches(cls); rw-&gt;properties.attachLists(proplists, propcount); free(proplists); rw-&gt;protocols.attachLists(protolists, protocount); free(protolists); } 这里，取出所有分类的方法、属性、协议，并将他们各自添加到一个二维数组里，最后再通过 attachLists 将他们添加到类对象中。 二、Category和Class Extension 的区别Class Extension: @interface Person ()@property (nonatomic, assign) int sex;- (void)isBig;@end 将属性、方法等封装在 .m 文件里面，类似 private 的应用。 区别：Class Extension 在编译的时候，数据就已经包含类信息里了；Category 是在运行时，通过 runtime 将数据合并到类信息中。 三、+ Load 和 +initialize 方法的区别Load：在 runtime 加载类、分类的时候根据函数地址直接调用，程序初始化就会调用，在 Category 中，先调用类的 load（根据编译顺序），再调用分类的 load（根据编译顺序）。 initialize：在类第一次接收到消息时调用，给类发送消息（objc_msgSend）才会调用，优先调用父类的 initialize，再调用子类的 initialize，且只会调用一次（父类的 initialize 可能会调用多次） 四、objc_msgSend() 方法实现在 objc4 源码中搜索 objc_msgSend 发现这个方法是由汇编实现的 /******************************************************************** * * id objc_msgSend(id self, SEL _cmd, …); * IMP objc_msgLookup(id self, SEL _cmd, …); * * objc_msgLookup ABI: * IMP returned in x17 * x16 reserved for our use but not used * **/ .data .align 3 .globl \\_objc\\_debug\\_taggedpointer\\_classes _objc_debug_taggedpointer_classes: .fill 16, 8, 0 .globl _objc_debug_taggedpointer_ext_classes_objc_debug_taggedpointer_ext_classes: .fill 256, 8, 0 ENTRY \\_objc\\_msgSend UNWIND \\_objc\\_msgSend, NoFrame MESSENGER_START cmp x0, #0 // nil check and tagged pointer check b.le LNilOrTagged // (MSB tagged pointer looks negative) ldr x13, \\[x0\\] // x13 = isa and x16, x13, #ISA_MASK // x16 = class 但是可以大概猜出它的实现思路: 由于 initialize 是第一次接受到消息调用，所以 initialize 的调用是在 objc_msgSend 方法里，所以它的调用顺序应该是在最前面，而且是只调用一次的判断； 通过 isa 寻找类/元类对象，寻找方法调用； 如果 isa 没有寻找到对应的方法，则通过 superClass 寻找父类是否有这个方法，调用。","tags":[]},{"title":" Object & Class & Meta Class\t\t","date":"2018-12-02T12:34:00.000Z","path":"2018/12/02/object-class-meta-class/","text":"原文：宁夏灼雪__ iOS底层day2 - isa和Superclass Object[[NSObject alloc] init]创建出来的就是一个记录着 isa 指针和其他成员变量等的实例对象。 @interface NSObject { #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wobjc-interface-ivars” Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop} 再看 OC 语言参数类型 id，它是指向某个类的实例的指针。定义如下： typedef struct objc_object *id;struct objc_object { Class isa; }; objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。 注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 runtime 的 object_getClass() 方法。 Direct access to Objective-C’s isa is deprecated in favor of object_getClass() Class类的本质也是一个对象，就是类对象。类对象由编译器生成。 在 objc/runtime.h 文件中： typedef struct objc_class *Class; Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下： struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ /* 父类 / Class _Nullable super_class OBJC2_UNAVAILABLE; /\\ 类名 / const char _Nonnull name OBJC2_UNAVAILABLE; /\\* 类的版本信息，默认为 0 */ long version OBJC2_UNAVAILABLE; /\\* 类信息，供运行时期使用的一些位标识。 如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量; CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; */ long info OBJC2_UNAVAILABLE; /\\* 实例变量大小（包括从父类继承下来的实例变量）*/ long instance\\_size OBJC2\\_UNAVAILABLE; /\\* 成员变量地址列表 */ struct objc\\_ivar\\_list * \\_Nullable ivars OBJC2\\_UNAVAILABLE; /\\* 方法地址列表，与 info 的一些标志位有关。 如 CLS\\_CLASS (0x1L)，则存储实例方法；CLS\\_META (0x2L)，则存储类方法; */ struct objc\\_method\\_list * \\_Nullable * \\_Nullable methodLists OBJC2_UNAVAILABLE; /\\* 缓存最近使用的方法地址，用于提升效率 */ struct objc\\_cache * \\_Nonnull cache OBJC2_UNAVAILABLE; /\\* 存储该类声明遵守的协议的列表 */ struct objc\\_protocol\\_list * \\_Nullable protocols OBJC2\\_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，说明 objc_class 也是一个对象，分别称作实例对象（instance object）和类对象（class object）。 实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）； 类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。 在源码 objc-runtime-new.h 文件中： struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class\\_rw\\_t *data() { return bits.data(); } ... } struct objc_object {private: isa_t isa; public: …} class_rw_t data() { return (class_rw_t )(bits &amp; FAST_DATA_MASK);} struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class\\_ro\\_t *ro; ... } struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name; method\\_list\\_t * baseMethodList; protocol\\_list\\_t * baseProtocols; const ivar\\_list\\_t * ivars; const uint8_t * weakIvarLayout; property\\_list\\_t *baseProperties; method\\_list\\_t *baseMethods() const { return baseMethodList; } }; objc_class 继承自 objc_object 存储着 isa、superclass、cache、bits，而 bits 通过位运算可以获得表 class_rw_t，其中包含着 methods（方法）、properties（属性）和 protocol 等，而 class_rw_t 表又存储着 class_ro_t 表，class_ro_t 表存储着 name（类名），ivars（成员变量）等信息。 最后用一张图来总结类对象的结构体存储。 Meta Class元类是对类的描述，记录着类的类方法以及 isa 指针和 superClass 指针等，类对象和元类对象在内存中的结构是一样的。 为了处理类和对象的关系，runtime 库创建了 Meta Class（元类），类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。 开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。 当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 Root Meta Class 的实例。所有元类的 isa 指针最终都指向根元类。 [NSObject.class alloc]; // [NSObject alloc] 所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。 实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。 isa1、实例对象 isa 指向类对象 当创建一个对象，并调用它的对象方法，但是实例对象的对象方法是存储在类对象里面，而我们调用对象方法实际上是给对象发送消息，如果实例对象和类对象没有什么关联的话，最终方法是没办法调用成功的，所以这里 isa 是指向类对象。 例如： Person * p = [[Person alloc] init];[p doWork]; p 调用 doWork 对象方法，是通过 p 的 isa 指针，找到 p 类对象所存储的对象方法执行。 2、类对象 isa 指向元类对象 同理，由于类方法存储在元类对象内，而我们调用类方法 isa 指向元类对象，才能执行类方法 [Person log]; Person 调用 log 对象方法，是通过 Person 的 isa 指针，找到 Person 元类对象所存储的类方法执行。 这里用一幅图总结 isa 在实例对象 &amp; 类对象 &amp; 元类对象的指向 3、isa 扩充 在 64 位系统下 isa 并不是直接存储指向的对象地址，而是需要位运算(&amp;)ISA_MASK # if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL …# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL …# endif __arm64__ : iOS64 位系统__x86_64__ : Mac 64 位系统 Superclass@interface Student : Person@end { Student * stu = [[Student alloc] init]; [stu doWork];} Student 类调用父类 Person 的类方法，首先 Student 通过本身的 isa 指针找到 Student 元类对象，发现没有 doWork 方法，便去 Person 元类对象找，这时候就需要通过 Student 的 Superclass 指针，才能找到 Person 元类对象，并调用方法 用一幅图来总结 Superclass 的指向 Superclass 就是直接指向父类的内存地址值。","tags":[]},{"title":" NSObject 占用内存\t\t","date":"2018-12-02T06:51:40.000Z","path":"2018/12/02/nsobject-e5-8d-a0-e7-94-a8-e5-86-85-e5-ad-98/","text":"原文：宁夏灼雪__ iOS底层day1 - 探索一个NSObject占用多少内存 一 、NSObject 的内存大小#import &lt;malloc/malloc.h&gt; { NSObject obj = [[NSObject alloc] init]; NSLog(@”%zu”, class_getInstanceSize(obj.class)); NSLog(@”%zu”, malloc_size((__bridge const void )obj));} 2018-12-02 12:22:51.665900+0800 Demo[10206:1312177] 82018-12-02 12:22:51.666111+0800 Demo[10206:1312177] 16 二、 反编译在 OC 中，我们所编写的代码，都是由编译器先编译成 c/c++ 语言，最终再编译成汇编语言执行，要探索一个 NSObject 占用多少内存，得先反编译成 c/c++ 代码 首先，在 main.m 中创建一个 NSObject 对象 int main(int argc, char argv[]) { @autoreleasepool { NSObject obj = [[NSObject alloc] init]; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 打开终端，目录切换到 main.m 下，执行 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o mian.cpp 生成文件 main.cpp。因为 main.m 中引入了 UIKit.framework，所以反编译时需要添加参数，让它找到该 framework。 三、isa指针struct NSObject_IMPL { Class isa;}; typedef struct objc_class * Class; // 在 objc/objc.h 文件中 NSObject_IMPL 里面放着一个 objc_class 的结构体指针 isa，这里可以发现一个指针在 64 位系统内存中所占的内存大小是 8 个字节，而 NSObject 对象里就只放了这个 isa 指针，那么一个 NSObject 只占 8 个字节吗? 四、objc源码进入到苹果源码网站搜索 objc4 并下载最新的源码。把源码导入到我们的工程，进入 class_getInstanceSize 方法： size_t class_getInstanceSize(Class cls){ if (!cls) return 0; return cls-&gt;alignedInstanceSize();} 然后再进入 alignedInstanceSize 可以看到: // Class’s ivar size rounded up to a pointer-size boundary.uint32_t alignedInstanceSize() { return word_align(unalignedInstanceSize());} 可以在注释上看到，class_getInstanceSize 方法返回的是成员变量的大小，而在 NSObject 中 ，只包含了 isa 指针，所以我们可以知道：class_getInstanceSize 在 NSObject 中，所返回的只是这个 isa 指针的大小，而不是 NSObject 对象的大小。 五、探索对象所开辟的内存大小通过 malloc_size 所得到的就是 NSObject 实际分配的内存大小，怎么证明呢？我们知道，iOS 中，给一个对象分配内存都是使用 allocWithZone: 方法，我们进入 allocWithZone 方法: // Replaced by ObjectAlloc+ (id)allocWithZone:(struct _NSZone )zone { return _objc_rootAllocWithZone(self, (malloc_zone_t )zone);} 进入 _objc_rootAllocWithZone : id_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone){ id obj; #if __OBJC2__ // allocWithZone under __OBJC2__ ignores the zone parameter (void)zone; obj = class_createInstance(cls, 0); #else if (!zone) { obj = class_createInstance(cls, 0); } else { obj = class_createInstanceFromZone(cls, 0, zone); } #endif if (slowpath(!obj)) obj = callBadAllocHandler(cls); return obj; } 再进入: idclass_createInstanceFromZone(Class cls, size_t extraBytes, void *zone){ return _class_createInstanceFromZone(cls, extraBytes, zone);} static __attribute__((always_inline))id_class_createInstanceFromZone(Class cls, size_t extraBytes, void zone, bool cxxConstruct = true, size_t outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // Read class&apos;s info bits all at once for performance bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocNonpointer(); size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { obj = (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc\\_zone\\_calloc ((malloc\\_zone\\_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = \\_objc\\_constructOrFree(obj, cls); } return obj; } 这里，我们可以看到实际是使用 calloc分配内存，而传入的 size则是由 instanceSize方法获得，我们进入 instanceSize查看： size_t instanceSize(size_t extraBytes) { size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;} 我们可以发现，分配的大小就是 alignedInstanceSize + 额外传入的大小，而且当 size小于 16 个字节时自动扩展到 16 个字节，例如：在 NSObject中，这里我们的 alignedInstanceSize只有 isa指针，所以自动扩展到了 16 个字节。 六、其他对象{ NSString string = [[NSString alloc] initWithString:@”ssss”]; // = @”ssss” 数据在常量区 NSLog(@”%zu”, class_getInstanceSize(string.class)); NSLog(@”%zu”, malloc_size((__bridge const void )string)); NSMutableString * mString = \\[\\[NSMutableString alloc\\] initWithString:@&quot;ssss&quot;\\]; NSLog(@&quot;%zu&quot;, class_getInstanceSize(mString.class)); NSLog(@&quot;%zu&quot;, malloc\\_size((\\_\\_bridge const void *)mString)); NSArray * arr = \\[NSArray array\\]; NSLog(@&quot;%zu&quot;, class_getInstanceSize(arr.class)); NSLog(@&quot;%zu&quot;, malloc\\_size((\\_\\_bridge const void *)arr)); NSArray * mArr = \\[NSArray array\\]; NSLog(@&quot;%zu&quot;, class_getInstanceSize(mArr.class)); NSLog(@&quot;%zu&quot;, malloc\\_size((\\_\\_bridge const void *)mArr)); } 2018-12-02 14:35:46.014228+0800 Demo[10900:1389318] 82018-12-02 14:35:46.014398+0800 Demo[10900:1389318] 02018-12-02 14:35:46.014527+0800 Demo[10900:1389318] 82018-12-02 14:35:46.014646+0800 Demo[10900:1389318] 482018-12-02 14:35:46.014768+0800 Demo[10900:1389318] 82018-12-02 14:35:46.014895+0800 Demo[10900:1389318] 162018-12-02 14:35:46.014986+0800 Demo[10900:1389318] 82018-12-02 14:35:46.015081+0800 Demo[10900:1389318] 16 七、结论系统给 NSObject 对象所分配的内存为 16 个字节，而 NSObject 对象只使用了 8 个字节（在 64 位下）class_getInstanceSize 方法返回的是这个对象需要占用多少空间（结构体内存对齐 8 的倍数）malloc_size 方法返回的是系统给这个对象分配了多少空间（iOS 系统内存对齐 16 的倍数 )","tags":[]},{"title":" KVC\t\t","date":"2018-12-02T04:15:03.000Z","path":"2018/12/02/kvc/","text":"键值编码提供了一种间接访问其属性方法或成员变量的机制，可以通过字符串来访问对应的属性方法或成员变量。 Person * p = [[Person alloc] init];[p setValue:@”D” forKey:@”name”];[p setValue:@”D” forKeyPath:@”name”];[p valueForKey:@”name”];[p valueForKeyPath:@”name”]; 其中 keyPath 比 key 的用法更为广泛。 key：只能接受当前类所具有的属性，不管是自己的，还是从父类继承过来的。 keypath：除了能接受当前类的属性，还能接受当前类属性的属性，即可以接受关系链。 [view setValue:@(CGRectZero) forKey:@”frame”];[view setValue:@5 forKeyPath:@”layer.cornerRadius”]; 一、执行过程当执行 setValue:forKey: 方法时，KVC 会先去寻找 setKey 方法，如果 setKey 方法找不到，会去寻找 _setKey 方法，如果还没找到这个方法，则会去寻找 accessInstanceVariablesDirectly 这个方法，这个方法返回 BOOL 值（默认返回 YES），告诉 KVC 是否可以设置成员变量，如果返回 YES，KVC 则会以 _Key、_isKey、Key、isKey 的顺序去设置成员变量。 同理，当我们执行 valueForKey: 方法时，KVC 会以 getKey、key、isKey、_key 的顺序去寻找值，如果都没找到，则会去寻找 accessInstanceVariablesDirectly 这个方法，这个方法返回 BOOL 值（默认返回 YES），告诉 KVC 是否访问成员变量，如果返回 YES，KVC 则会以 _Key、_isKey、Key、isKey 的顺序去取值。 二、kvc会触发kvo吗?会。首先 kvo 的实现就是重写 setter 方法，实现 willChangeValueForKey 和 didChangeValueForKey，来实现监听回调，而 kvc 的实现就是调用 setter 方法，此外，如果对象没有实现 setter 方法，而是直接用 kvc 设置成员变量的值，那么也会走 kvo 监听，因为使用 kvc 设置成员变量的值的时候，底层会调用 willChangeValueForKey 和 didChangeValueForKey，但是如果是以对象直接设置成员变量的值的话，则不会走 kvo 监听。 三、学习文章宁夏灼雪__ iOS底层day3 - 探索KVO/KVC的实现","tags":[]},{"title":" KVO\t\t","date":"2018-12-02T02:55:16.000Z","path":"2018/12/02/kvo/","text":"KVO 是实现 Cocoa Bindings 的基础，它提供了一种方法，当某个属性改变时，相应的 objects 会被通知到。在其他语言中，这种观察者模式通常需要单独实现，而在 Objective-C 中，通常无须增加额外代码即可使用。 一、概览@interface Person : NSObject@property (nonatomic, copy) NSString * name;@end KVO 怎么实现的呢？其实这都是通过 Objective-C 强大的运行时实现的。当你第一次观察某个 object 时，runtime 会创建一个新的继承原先 class 的 subclass。在这个新的 class 中，它重写了所有被观察的 key，然后将 object 的 isa 指针指向新创建的 class（这个指针告诉 Objective-C 运行时某个 object 到底是哪种类型的 object）。所以 object 神奇地变成了新的子类的实例。 这些被重写的方法实现了如何通知观察者们。当改变一个 key 时，会触发 setKey 方法，但这个方法被重写了，并且在内部添加了发送通知机制。 如果觉得 KVO 是监听某个对象属性的变化那就错了，KVO 其实监听的是值的改变，不仅仅是属性，.m 成员变量也是可以监听的。 二、验证{ Person p1 = [[Person alloc] init]; Person p2 = [[Person alloc] init]; \\[p1 addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL\\]; /\\* 断点，执行 po */ NSLog(@&quot;%@&quot;, object_getClass(p1)); NSLog(@&quot;%@&quot;, object_getClass(p2)); } (lldb) po p1.isaNSKVONotifying_Person Fix-it applied, fixed expression was: p1-&gt;isa(lldb) po p2.isaPerson Fix-it applied, fixed expression was: p2-&gt;isa(lldb) po NSStringFromClass(([NSKVONotifying_Person class]).superclass)Person 2018-12-02 08:13:45.466367+0800 Demo[9052:1094203] NSKVONotifying_Person2018-12-02 08:13:45.466580+0800 Demo[9052:1094203] Person 在程序运行的过程中，使用 runtime 动态地创建了 NSKVONotifying_Person 这个类，这个类是 Person 的子类。 - (void)getClsMethods:(Class)cls{ uint count = 0; // 方法列表 Method * methodList = class_copyMethodList(cls, &amp;count); for (NSInteger i = 0; i &lt; count; i++) { NSLog(@&quot;%@&quot;, NSStringFromSelector(method_getName(methodList\\[i\\]))); } } [p1 getClsMethods]; 2018-12-02 08:26:09.601216+0800 Demo[9094:1104114] setName:2018-12-02 08:26:09.601327+0800 Demo[9094:1104114] class2018-12-02 08:26:09.601448+0800 Demo[9094:1104114] dealloc2018-12-02 08:26:09.601571+0800 Demo[9094:1104114] _isKVOA 这里，子类重写了 set 方法，并调用了 c 语言方法 _NSSetXXXValueAndNotify 方法（XXX 为属性的类型，如：Int）。_NSSetIntValueAndNotify() 方法的实现： 属性将要改变时调用 willChangeValueForKey: 调用 [supr setXXX:] 方法来真正的改变属性的值 属性的值改变完成之后再调用 didChangeValueForKey:，这个方法会回调给监听者，来通知监听者属性值已经改变。 NSKVONotifying_Person类的伪代码： @implementation NSKVONotifying_Person - (void)setName:(int)name{ _NSSetIntValueAndNotify(); } void __NSSetObjectValueAndNotify(){ [self willChangeValueForKey:@”name”]; [super setName:name]; [self didChangeValueForKey:@”name”];} - (void)didChangeValueForKey:(NSString *)key{ [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];} @end 下面验证子类重写了 set 方法 { NSLog(@”添加观察之前 P1_IMP = %p p2_IMP = %p”, [p1 methodForSelector:@selector(setName:)], [p2 methodForSelector:@selector(setName:)]); [p1 addObserver:self forKeyPath:@”name” options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL]; NSLog(@”添加观察之后 P1_IMP = %p p2_IMP = %p”, [p1 methodForSelector:@selector(setName:)], [p2 methodForSelector:@selector(setName:)]);} 2018-12-02 10:09:45.345298+0800 Demo[9579:1175905] 添加观察之前 P1_IMP = 0x10687c550 p2_IMP = 0x10687c5502018-12-02 10:09:45.345728+0800 Demo[9579:1175905] 添加观察之后 P1_IMP = 0x106e67efe p2_IMP = 0x10687c550 然后使用 LLDB 打印一下 0x10687c550 和 0x106e67efe 这两个地址的 IMP，把地址强制转化为 IMP 然后转化出来： (lldb) p (IMP)0x10687c550(IMP) $0 = 0x000000010687c550 (Demo-\\[Person setName:\\] at Person.h:13) (lldb) p (IMP)0x106e67efe (IMP) $1 = 0x0000000106e67efe (Foundation_NSSetObjectValueAndNotify) 这里已经清楚的表明：添加监听后生成了新的子类并重写了 set 方法，并变成了调用 _NSSetObjectValueAndNotify 这样一个 C 函数。 三、KVO内部调用顺序也就是 _NSSetIntValueAndNotify 函数的执行过程。前面的伪代码写过这个 C 函数的执行过程大概分三步： [self willChangeValueForKey:@”xxx”];[super setXXX:xxx];[self didChangeValueForKey:@”xxx”]; 由于无法去窥探 _NSSetObjectValueAndNotify 的真实结构，也无法去重写 NSKVONotifying_Person 这个类，所以我们只能利用它的父类 Person 类来分析其执行过程。 在 Person 类里面重写 willChangeValueForKey: 和 didChangeValueForKey: 这两个方法，但是只是简单的调用父类的方法，除此之外不做其他的有效处理，这样不会影响其执行。 @implementation Person - (void)setValue:(id)value forKey:(NSString *)key{ NSLog(@”赋值前 name = %@”, _name); [super setValue:value forKey:key]; NSLog(@”赋值后 name = %@”, _name);} - (void)willChangeValueForKey:(NSString *)key{ NSLog(@”调用 willChangeValueForKey 前”); [super willChangeValueForKey:key]; NSLog(@”调用 willChangeValueForKey 后”);} - (void)didChangeValueForKey:(NSString *)key{ NSLog(@”调用 didChangeValueForKey 前”); [super didChangeValueForKey:key]; NSLog(@”调用 didChangeValueForKey 后”);} @end { Person * p = [[Person alloc] init]; p.name = @”A”; \\[p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:NULL\\]; \\[p setValue:@&quot;D&quot; forKey:@&quot;name&quot;\\]; } - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; )change context:(void *)context{ NSLog(@”收到监听回调 name = %@”, change[NSKeyValueChangeNewKey]);} 调用结果： 2018-12-02 10:26:40.968461+0800 Demo[9670:1194334] 赋值前 name = A2018-12-02 10:26:40.968702+0800 Demo[9670:1194334] 调用 willChangeValueForKey 前2018-12-02 10:26:40.968853+0800 Demo[9670:1194334] 调用 willChangeValueForKey 后2018-12-02 10:26:40.968963+0800 Demo[9670:1194334] 调用 didChangeValueForKey 前2018-12-02 10:26:40.969127+0800 Demo[9670:1194334] 收到监听回调 name = D2018-12-02 10:26:40.969264+0800 Demo[9670:1194334] 调用 didChangeValueForKey 后2018-12-02 10:26:40.969384+0800 Demo[9670:1194334] 赋值后 name = D 四、NSKVONotifying_Person 的内部方法 在上面的结构图里，有 isa、superclass、setName: 等方法。-dealloc 主要做移除监听器等收尾工作。那么这个 class 方法主要是干什么的呢？ NSLog(@”%@ %@”, object_getClass(p1), object_getClass(p2)); // runtimeNSLog(@”%@ %@”, p1.class, p2.class); 输出结果： 2018-12-02 10:41:58.111769+0800 Demo[9732:1210614] NSKVONotifying_Person Person2018-12-02 10:41:58.111986+0800 Demo[9732:1210614] Person Person 可以看到，通过 runtime 打印出来的是对的，但是通过 p1.class 这种方式打印出来的结果是错误的。原因就是NSKVONotifying_Person 这个类重写了 class 方法，很可能就是直接返回了 [Person class]。 (Class)class{ return [Person class];} 为什么要重写 class 这个方法呢？ 苹果并不希望把 NSKVONotifying_Person 这个类暴露出来，屏蔽内部实现，隐藏这个类的存在。 五、直接修改成员变量会触发KVO吗？不会。KVO 的本质是 setter 方法，只有调用了 setter 方法才会触发 KVO。 手动修改的话是直接对实例变量赋值，跨过了 kvc 的操作，kvc 底层赋值会从 setter、_A、_isA、A、isA 这样的顺序去查找。kvc 触发 kvo 是通过在赋值前调用 willChangeValueForKey，赋值后 didChangeValueForKey。如果是属性监听，点语法或者 kvc 都会先走 setter 方法，然后在 didChangeValueForKey: 中会触发 kvo 的回调observeValueForKeyPath。 六、如何手动触发KVO手动调用 willChangeValueForKey: 和 didChangeValueForKey: 方法。willChangeValueForKey: 和 didChangeValueForKey: 不是 kvc 调用的，是 kvo 根据 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key 这个方法判断你是不是要自动触发 kvo。自动触发的话，会在 kvo 监听的值赋值前后添加方法触发回调。 七、学习文章KVO的本质","tags":[]},{"title":" 重构 AppDelegate\t\t","date":"2018-12-01T05:49:08.000Z","path":"2018/12/01/e9-87-8d-e6-9e-84-appdelegate/","text":"原文：最佳实践：重构AppDelegate 一、Massive AppDelegateAppDelegate 是应用程序的根对象，它连接应用程序和系统，确保应用程序与系统以及其他应用程序正确的交互，通常被认为是每个 iOS 项目的核心。随着开发的迭代升级，不断增加新的功能和业务，它的代码量也不断增长，最终导致了 Massive AppDelegate。 在复杂 AppDelegate 里修改任何东西的成本都是很高的，因为它将会影响你的整个 APP，一不留神产生 bug。毫无疑问，保持AppDelegate 的简洁和清晰对于健康的 iOS 架构来说是至关重要的。本文将使用多种方法来重构，使之简洁、可重用和可测。 AppDelegate 常见的业务代码如下： 日志埋点统计数据分析 初始化数据存储系统 配置 UIAppearance 管理 App Badge 数字 管理通知：请求权限，存储令牌，处理自定义操作，将通知传播到应用程序的其余部分 管理 UI 堆栈配置：选择初始视图控制器，执行根视图控制器转换 管理 UserDefaults：设置首先启动标志，保存和加载数据 管理后台任务 管理设备方向 更新位置信息 初始化第三方库（如分享、日志、第三方登陆、支付） 这些臃肿的代码是反模式的，导致难于维护，显然支持扩展和测试这样的类非常复杂且容易出错。Massive AppDelegates 与我们经常谈的 Massive ViewController 的症状非常类似。 看看以下可能的解决方案，每个 Recipe（方案）遵循单一职责、易于扩展、易于测试原则。 二、命令模式 Command Design Pattern命令模式是一种数据驱动的设计模式，属于行为型模式。 请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。因此命令的调用者无需关心命令做了什么以及响应者是谁。 可以为 AppDelegate 的每一个职责定义一个命令，这个命令的名字自行指定。 /// 命令协议@protocol Command - (void)execute;@end /// 初始化第三方库@interface InitializeThirdPartiesCommand : NSObject @end /// 初始化主视图@interface InitializeRootViewControllerCommand : NSObject @property (nonatomic, strong) UIWindow * keyWindow;@end /// 初始化视图全局配置@interface InitializeAppearanceCommand : NSObject @end /// … 然后定义一个统一调用的类 StartupCommandsBuilder 来封装如何创建命令的详细信息。AppDelegate 调用这个 builder 去初始化命令并执行这些命令。 @implementation StartupCommandsBuilder // 返回数组，元素为遵守 Command 协议的对象- (NSArray&lt;id&gt; *)build{ return @[ [InitializeAppearanceCommand new], [InitializeRootViewControllerCommand new], [InitializeThirdPartiesCommand new] ];} @end - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ [[[[StartupCommandsBuilder alloc] init] build] enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { [obj execute]; }]; return YES; } 如果 AppDelegate 需要添加新的职责，则可以创建新的命令，然后把命令添加到 Builder 里而无需去改变 AppDelegate。解决方案满足单一职责、易于扩展、易于测试原则。 三、组合设计模式 Composite Design Pattern组合模式又叫部分整体模式，用于把一组相似的对象当作一个单一的对象。 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。一个很明显的例子就是 iOS 里的 UIView 以及它的 subviews。 这个想法主要是有一个组装类和叶子类，每个叶子类负责一个职责，而组装类负责调用所有叶子类的方法。 /// 组装类@interface CompositeAppDelegate : UIResponder + (instancetype)makeDefault;@end @implementation CompositeAppDelegate + (instancetype)makeDefault{ // 这里要实现单例 return [[CompositeAppDelegate alloc] init];} - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ [[PushNotificationAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; [[ThirdPartiesConfiguratorAppDelegate new] application:application didFinishLaunchingWithOptions:launchOptions]; return YES; } @end 实现执行具体职责的叶子类。 /// 叶子类。推送消息处理@interface PushNotificationAppDelegate : UIResponder @end /// 叶子类。初始化第三方库@interface ThirdPartiesConfiguratorAppDelegate : UIResponder @end @implementation PushNotificationAppDelegate - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ NSLog(@”PushNotificationAppDelegate”); return YES; } @end @implementation ThirdPartiesConfiguratorAppDelegate - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ NSLog(@”ThirdPartiesConfiguratorAppDelegate”); return YES; } @end 在 AppDelegate 通过工厂方法创建组装类，然后通过它去调用所有的方法 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ [[CompositeAppDelegate makeDefault] application:application didFinishLaunchingWithOptions:launchOptions]; return YES; } 它满足我们在开始时提出的所有要求，如果要添加一个新的功能，很容易添加一个叶子类，无需改变 AppDelegate，解决方案满足单一职责、易于扩展、易于测试原则。 四、中介者模式 Mediator Design Pattern中介者模式是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 如果想了解有关此模式的更多信息，建议查看 Mediator Pattern Case Study。或者阅读文末老峰也给出关于设计模式比较经典的书籍。 让我们定义 AppLifecycleMediator 将 UIApplication 的生命周期通知底下的监听者，这些监听者必须遵循AppLifecycleListener 协议，如果需要监听者要能扩展新的方法。 @interface APPLifeCycleMediator : NSObject + (instancetype)makeDefaultMediator; @end @implementation APPLifeCycleMediator{ @private NSArray&lt;id&gt; * _listeners;}- (void)dealloc{ [[NSNotificationCenter defaultCenter] removeObserver:self];} - (instancetype)initWithListeners:(NSArray&lt;id&gt; *)listeners{ if (self = [super init]) { _listeners = listeners; // 通知 \\[\\[NSNotificationCenter defaultCenter\\] addObserver:self selector:@selector(onAppWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil\\]; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:self selector:@selector(onAppDidEnterBackgroud) name:UIApplicationDidEnterBackgroundNotification object:nil\\]; \\[\\[NSNotificationCenter defaultCenter\\] addObserver:self selector:@selector(onAppDidFinishLaunching) name:UIApplicationDidFinishLaunchingNotification object:nil\\]; } return self; } /// 定义好静态类方法，初始化所有监听者+ (instancetype)makeDefaultMediator{ static APPLifeCycleMediator * mediator; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ mediator = [[APPLifeCycleMediator alloc] initWithListeners:@[[VideoListener new], [SocketListener new]]]; }); return mediator;} - (void)onAppWillEnterForeground{ [_listeners[1] onAppWillEnterForeground];} - (void)onAppDidEnterBackgroud{ [_listeners[0] onAppDidEnterBackgroud];} - (void)onAppDidFinishLaunching{ } @end 定义 AppLifecycleListener 协议，以及协议的的实现者。 /// 监听协议@protocol AppLifeCycleListener @optional- (void)onAppWillEnterForeground;- (void)onAppDidEnterBackgroud;- (void)onAppDidFinishLaunching; @end @interface VideoListener : NSObject @end @interface SocketListener : NSObject @end @implementation VideoListener - (void)onAppDidEnterBackgroud{ NSLog(@”停止视频播放”);} @end @implementation SocketListener - (void)onAppWillEnterForeground{ NSLog(@”开启长链接”);} @end 加入到 AppDelegate 中 - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ [APPLifeCycleMediator makeDefaultMediator]; return YES; } 这个中介者自动订阅了所有的事件。AppDelegate 仅仅需要初始化它一次，就能让它正常工作。每个监听者都有一个单一职责，很容易添加一个监听者，而无需改变 Appdelgate 的内容，每个监听者以及中介者能够容易的被单独测试。 五、总结大多数 AppDelegates 的设计都不太合理，过于复杂并且职责过多。我们称这样的类为 Massive App Delegates。 通过应用软件设计模式，Massive App Delegate 可以分成几个单独的类，每个类都有单一的责任，可以单独测试。 这样的代码很容易更改维护，因为它不会在您的应用程序中产生一连串的更改。它非常灵活，可以在将来提取和重用。 六、学习文章Refactoring Massive App Delegate iOSTips OC设计模式：《Objective-C 编程之道：iOS 设计模式解析》 Swift 设计模式：《Design_Patterns_by_Tutorials_v0.9.1》 重构：《重构改善既有代码的设计》","tags":[]},{"title":" RunLoop(2)\t\t","date":"2018-11-30T07:32:31.000Z","path":"2018/11/30/runloop2/","text":"RunLoop 官方文档 一、概念一般来讲，每一个线程有且仅有一个与之关联的 runloop，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的： function loop() { initialize(); do { var message = get\\_next\\_message(); process_message(message); } while(message != quit); } 这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。 实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 开源代码CFRunLoopRef 源码下载 二、RunLoop 与线程的关系iOS 开发中里的两个线程对象: pthread_t 和 NSThread。过去有份文档/tn/tn2028.html)表明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。 CFRunLoop 是基于 pthread 来管理的。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: // 全局字典，用来存放线程对应的RunLoop// key - 线程，value - RunLoop实例，线程与 RunLoop一一对应static CFMutableDictionaryRef __CFRunLoops = NULL;static CFSpinLock_t loopsLock = CFSpinLockInit; // 当t == 0 的时候，代表主线程CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) { // 如果存进来的线程等于 0 if (pthread_equal(t, kNilPthreadT)) { // 那么当前线程等于主线程 t = pthread\\_main\\_thread_np(); } // 给操作加锁 __CFSpinLock(&amp;loopsLock); // 如果当前 RunLoop 为空，创建。 if (!__CFRunLoops) { __CFSpinUnlock(&amp;loopsLock); CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); CFRunLoopRef mainLoop = \\_\\_CFRunLoopCreate(pthread\\_main\\_thread\\_np()); // 把线程与 RunLoop一一对应的存进字典 CFDictionarySetValue(dict, pthreadPointer(pthread\\_main\\_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) { CFRelease(dict); } CFRelease(mainLoop); __CFSpinLock(&amp;loopsLock); } // 获取当前线程的RunLoop CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); __CFSpinUnlock(&amp;loopsLock); // 如果不是主线程并且之前没有创建，也即是为空 if (!loop) { CFRunLoopRef newLoop = __CFRunLoopCreate(t); __CFSpinLock(&amp;loopsLock); loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); if (!loop) { // 把当前子线程和创建的 RunLoop 一一对应的存进字典 CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; } // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFSpinUnlock(&amp;loopsLock); CFRelease(newLoop); } if (pthread\\_equal(t, pthread\\_self())) { \\_CFSetTSD(\\_\\_CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == \\_CFGetTSD(\\_\\_CFTSDKeyRunLoopCntr)) { \\_CFSetTSD(\\_\\_CFTSDKeyRunLoopCntr, (void *)(PTHREAD\\_DESTRUCTOR\\_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); } } return loop; }// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; // 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) { OSSpinLockLock(&amp;loopsLock); if (!loopsDic) { // 第一次进入时，初始化全局字典，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread\\_main\\_thread_np(), mainLoop); } // 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) { // 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); // 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 \\_CFSetTSD(..., thread, loop, \\_\\_CFFinalizeRunLoop); } OSSpinLockUnLock(&amp;loopsLock); return loop; } CFRunLoopRef CFRunLoopGetMain() { return _CFRunLoopGet(pthread_main_thread_np());} CFRunLoopRef CFRunLoopGetCurrent() { return _CFRunLoopGet(pthread_self());} 上面是获取 RunLoop 的源代码和伪代码。这个方法需要传进一个 pThread，利用这个 pThread 作为全局字典中的 key，并创建与之对应的 RunLoop 作为 Value。RunLoop 在获取的时候创建，不获取不创建，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop，主线程除外，主线程的 RunLoop 在一开始就自动创建。 三、RunLoop 对外的接口在 CoreFoundation 里关于 RunLoop 有 5 个类: CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。它们的关系如下: 一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，它被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 1、CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。 ①、Source0 只包含了一个回调，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 ②、Source1 包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 2、CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是 toll-free bridged 的，可以混用。其包含一个时间长度和一个回调。当其加入到 RunLoop 时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 3、CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调，当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入 Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出 Loop}; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 四、RunLoop 的 ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： struct __CFRunLoopMode { CFStringRef _name; // Mode Name, 例如 @”kCFRunLoopDefaultMode” CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array …}; struct __CFRunLoop { CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set …}; 这里有个概念叫 “CommonModes“：一个 Mode 可以通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中，将自己标记为”Common”属性。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。 主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。 应用场景：当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。 有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有 “Common” 属性的 Mode 里去。 CFRunLoop 对外暴露的管理 Mode 接口只有下面 2 个: CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); CFRunLoopRunInMode(CFStringRef modeName, …); Mode 暴露的管理 mode item 的接口有下面几个： CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop 会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 五、RunLoop 的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下: // 用DefaultMode启动void CFRunLoopRun(void) { CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);} // 用指定的 Mode 启动，允许设置 RunLoop 超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) { return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);} // RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) { // 首先根据 modeName 找到对应 mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); // 如果 mode 里没有 source/timer/observer，直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; // 1\\. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); // 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) { Boolean sourceHandledThisLoop = NO; int retVal = 0; do { // 2\\. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); // 3\\. 通知 Observers: RunLoop 即将触发 Source0 (非 port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); // 执行被加入的 block __CFRunLoopDoBlocks(runloop, currentMode); // 4\\. RunLoop 触发 Source0 (非 port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); // 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); // 5\\. 如果有 Source1 (基于 port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; } // 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } // 7\\. 调用 mach\\_msg 等待接受 mach\\_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 // ? 一个基于 port 的 Source 的事件。 // ? 一个 Timer 到时间了 // ? RunLoop 自身的超时时间到了 // ? 被其他什么调用者手动唤醒 \\_\\_CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg\\_buffer), &amp;livePort) { mach\\_msg(msg, MACH\\_RCV_MSG, port); // thread wait for receive msg } // 8\\. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); // 9 收到消息，处理消息。 handle_msg: // 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg\\_is\\_timer) { \\_\\_CFRunLoopDoTimers(runloop, currentMode, mach\\_absolute_time()) } // 9.2 如果有 dispatch 到 main_queue 的 block，执行 block。 else if (msg\\_is\\_dispatch) { \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_(msg); } // 9.3 如果一个 Source1 (基于 port) 发出事件了，处理这个事件 else { CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) { mach\\_msg(reply, MACH\\_SEND_MSG, reply); } } // 执行加入到 Loop 的 block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) { // 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; } else if (timeout) { // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; } else if (__CFRunLoopIsStopped(runloop)) { // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { // source/timer/observer 一个都没有了 retVal = kCFRunLoopRunFinished; } // 如果没超时，mode 里没空，loop 也没被停止，那继续 loop。 } while (retVal == 0); } // 10\\. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); } 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 六、RunLoop 的底层实现从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。 苹果官方将整个系统大致划分为上述 4 个层次： 1、应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。 2、应用框架层即开发人员接触到的 Cocoa 等框架。 3、核心框架层包括各种核心框架、OpenGL 等内容。 4、Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。 深入看一下 Darwin 这个核心的架构： 在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。 XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC 等非常少量的基础服务。BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。 Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些 API 非常基础，如果没有这些 API 的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 Mach 的消息定义是在头文件的，很简单： typedef struct { mach_msg_header_t header; mach_msg_body_t body;} mach_msg_base_t; typedef struct { mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;} mach_msg_header_t; 一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port， 发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向： mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图： 这些概念可以参考维基百科: System_call、Trap_(computing))。 RunLoop 的核心就是一个 mach_msg() (见上面代码的第 7 步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。 关于具体的如何利用 mach port 发送信息，可以看看 NSHipster 这一篇文章，或者这里 。 七、苹果用 RunLoop 实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： CFRunLoop { current mode = kCFRunLoopDefaultMode common modes = { UITrackingRunLoopMode kCFRunLoopDefaultMode } common mode items = { // source0 (manual) CFRunLoopSource {order =-1, { callout = _UIApplicationHandleEventQueue}} CFRunLoopSource {order =-1, { callout = PurpleEventSignalCallback }} CFRunLoopSource {order = 0, { callout = FBSSerialQueueRunLoopSourceHandler}} // source1 (mach port) CFRunLoopSource {order = 0, {port = 17923}} CFRunLoopSource {order = 0, {port = 12039}} CFRunLoopSource {order = 0, {port = 16647}} CFRunLoopSource {order =-1, { callout = PurpleEventCallback}} CFRunLoopSource {order = 0, {port = 2407, callout = \\_ZL20notify\\_port\\_callbackP12\\_\\_CFMachPortPvlS1_}} CFRunLoopSource {order = 0, {port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback}} CFRunLoopSource {order = 0, {port = 1b03, callout = __IOHIDEventSystemClientQueueCallback}} CFRunLoopSource {order = 1, {port = 1903, callout = __IOMIGMachPortPortCallback}} // Ovserver CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler} CFRunLoopObserver {order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver} CFRunLoopObserver {order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler} CFRunLoopObserver {order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = \\_ZN2CA11Transaction17observer\\_callbackEP19__CFRunLoopObservermPv} CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler} // Timer CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = \\_ZN2CAL14timer\\_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)} }, modes ＝ { CFRunLoopMode { sources0 = { /* same as &apos;common mode items&apos; */ }, sources1 = { /* same as &apos;common mode items&apos; */ }, observers = { /* same as &apos;common mode items&apos; */ }, timers = { /* same as &apos;common mode items&apos; */ }, }, CFRunLoopMode { sources0 = { /* same as &apos;common mode items&apos; */ }, sources1 = { /* same as &apos;common mode items&apos; */ }, observers = { /* same as &apos;common mode items&apos; */ }, timers = { /* same as &apos;common mode items&apos; */ }, }, CFRunLoopMode { sources0 = { CFRunLoopSource {order = 0, { callout = FBSSerialQueueRunLoopSourceHandler}} }, sources1 = (null), observers = { CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000, callout = \\_ZN2CA11Transaction17observer\\_callbackEP19__CFRunLoopObservermPv} )}, timers = (null), }, CFRunLoopMode { sources0 = { CFRunLoopSource {order = -1, { callout = PurpleEventSignalCallback}} }, sources1 = { CFRunLoopSource {order = -1, { callout = PurpleEventCallback}} }, observers = (null), timers = (null), }, CFRunLoopMode { sources0 = (null), sources1 = (null), observers = (null), timers = (null), } } } 可以看到，系统默认注册了 5 个 Mode: 1、kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 2、UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 3、UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 4、GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 5、kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 可以在这里看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out)，在代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了： { // 1. 通知 Observers，即将进入 RunLoop // 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do { // 2\\. 通知 Observers: 即将触发 Timer 回调。 \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_AN\\_OBSERVER\\_CALLBACK\\_FUNCTION\\_\\_(kCFRunLoopBeforeTimers); // 3\\. 通知 Observers: 即将触发 Source (非基于port 的 Source0) 回调。 \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_AN\\_OBSERVER\\_CALLBACK\\_FUNCTION\\_\\_(kCFRunLoopBeforeSources); \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_(block); // 4\\. 触发 Source0 (非基于 port 的) 回调。 \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_SOURCE0\\_PERFORM\\_FUNCTION\\_\\_(source0); \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_BLOCK\\_\\_(block); // 6\\. 通知 Observers，即将进入休眠 // 此处有 Observer 释放并新建 AutoreleasePool: \\_objc\\_autoreleasePoolPop(); \\_objc\\_autoreleasePoolPush(); \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_AN\\_OBSERVER\\_CALLBACK\\_FUNCTION\\_\\_(kCFRunLoopBeforeWaiting); // 7\\. sleep to wait msg. mach\\_msg() -&gt; mach\\_msg_trap(); // 8\\. 通知Observers，线程被唤醒 \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_AN\\_OBSERVER\\_CALLBACK\\_FUNCTION\\_\\_(kCFRunLoopAfterWaiting); // 9\\. 如果是被Timer唤醒的，回调Timer \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_TIMER\\_CALLBACK\\_FUNCTION\\_\\_(timer); // 9\\. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_(dispatched_block); // 9\\. 如果如果Runloop是被 Source1 (基于 port 的) 的事件唤醒了，处理这个事件 \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_A\\_SOURCE1\\_PERFORM\\_FUNCTION\\_\\_(source1); } while (...); // 10\\. 通知 Observers，即将退出 RunLoop // 此处有 Observer 释放 AutoreleasePool: \\_objc\\_autoreleasePoolPop(); \\_\\_CFRUNLOOP\\_IS\\_CALLING\\_OUT\\_TO\\_AN\\_OBSERVER\\_CALLBACK\\_FUNCTION\\_\\_(kCFRunLoopExit); } 八、AutoreleasePoolApp 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry（即将进入 Loop），其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 九、事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。 SpringBoard 只接收按键(锁屏/静音等)、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 十、手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 十一、界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 十二、定时器NSTimer 其实就是 CFRunLoopTimerRef，它们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。 十三、PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 十四、关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop 会被唤醒，并从消息中取得这个 block，并在回 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 十五、关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 下面主要介绍下 NSURLConnection 的工作过程。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会获取 currentRunLoop，然后在其中的 DefaultMode 添加了 4 个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 十六、RunLoop 的实际应用举例AFNetworking AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： + (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@”AFNetworking”]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }} + (NSThread )networkRequestThread { static NSThread _networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 - (void)start { [self.lock lock]; if ([self isCancelled]) { [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } else if ([self isReady]) { self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } [self.lock unlock];} 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKit AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。 UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 十七、学习文章Etund # iOS—RunLoop深度剖析ibireme#深入理解RunLoop CFRunLoop – API","tags":[]},{"title":" RunLoop(1)\t\t","date":"2018-11-30T05:28:15.000Z","path":"2018/11/30/runloop1/","text":"文章：崔江涛（KenshinCui）/iOS刨根问底-深入理解RunLoop、一个低调的iOS开发/Runloop 事件源、iOS 多线程：『RunLoop』详尽总结 RunLoop 实际上是一个对象，这个对象循环处理程序运行过程中出现的各种事件（如触摸事件、UI 刷新事件、定时器事件、Selector 事件），从而保持程序的持续运行。 RunLoop 在没有事件处理的时候，会使线程进入睡眠模式，从而节省 CPU 资源，提高程序性能。 一、CFRunloopRefCFRunloopRef 是纯 C 的函数，而 NSRunloop 仅仅是 CFRunloopRef 的 OC 封装，没有增加额外的功能，因此主要分析 CFRunloopRef。苹果已经开源了 CFRunloop 源代码。 从代码可以看出 CFRunloopRef 其实是 __CFRunloop 这个结构体的指针。 struct __CFRunLoop { CFRuntimeBase _base; pthread_mutex_t lock; / locked for accessing mode list / \\_CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data _perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item _blocks_head; struct _block_item *_blocks_tail; CFTypeRef _counterpart;}; rl-&gt;_blocks_headrl-&gt;_commonModes 从代码的执行顺序 CFRunLoopRun()/CFRunLoopRunInMode() -&gt; CFRunLoopRunSpecific() -&gt; CFRunloopRun() 可知 RunLoop 的核心方法是 CFRunloopRun()。 SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) { / DOES CALLOUT / if (currentMode-&gt;\\_observerMask &amp; kCFRunLoopEntry ) \\_\\_CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); if (currentMode-&gt;\\_observerMask &amp; kCFRunLoopExit ) \\_\\_CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); return result; } /* 在默认模式下运行当前线程的 runloop。 通过执行 CFRunLoopStop(_:)或者从 defaultMode 移除所有的 sources 和 timers,来停止 runloop 停止。 runloop 能够递归运行，你可以通过这个方法在一个 runloop 调用里创建一个嵌套的 runloop 并且加入当前线程的调用栈。CFRunLoopStop() 仅当前 runloop 及其子 runloop 会停止，不影响父 runloop() /void CFRunLoopRun(void) { / DOES CALLOUT */ int32_t result; do { result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);} /** * 判断其他 runloop 是否处于等待状态，如果用于判断当前 runloop，则永远返回 false */Bool CFRunLoopIsWaiting() { } /** * 在指定的模式下运行当前线程的runloop, runloop能够被递归调用,你能够在当前线程的调用栈激活子runloop。你能在你可使用的模式激活任意runloop。 * @parma mode: 指定模式,可以是任意CFString类型的字符串(即:可以隐式创建一个模式)但是一个模式必须至少包括一个source或者timer才能运行。不必具体说明 runloop运行在commonModes中的哪个mode,runloop会在一个特定的模式运行。 只有当你注册一个observer时希望observer运行在不止一个模式的时候需要具体说明 * * @parma seconds: 指定runloop运行时间. 如果为0,在runloop返回前会被执行一次;忽略returnAfterSourceHandled的值, 如果有多个sources或者timers已准备好立刻运行,仅有一个能被执行(除非sources中有source0)。 * @parma returnAfterSourceHandled: 判断运行了一个source之后runloop是否退出。如果为false,runloop继续执行事件直到第二次调遣结束 * * @return runloop 退出的原因: kCFRunLoopRunFinished:runloop 中已经没有sources和timers kCFRunLoopRunStopped:runloop 通过 CFRunLoopStop(_:)方法停止 kCFRunLoopRunTimedOut:runloop 设置的时间已到 kCFRunLoopRunHandledSource: 当 returnAfterSourceHandled值为 ture 时,一个 source 被执行完/SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) { / DOES CALLOUT */ CHECK_FOR_FORK(); return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);} 为了方便阅读不再直接贴源代码，放一段伪代码： int32_t __CFRunLoopRun(){ // 通知即将进入 runloop __CFRunLoopDoObservers(KCFRunLoopEntry); do { // 通知将要处理 timer 和 source __CFRunLoopDoObservers(kCFRunLoopBeforeTimers); __CFRunLoopDoObservers(kCFRunLoopBeforeSources); // 处理非延迟的主线程调用 __CFRunLoopDoBlocks(); // 处理 Source0 事件 Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(...); if (sourceHandledThisLoop) { __CFRunLoopDoBlocks(); } /// 如果有 Source1 (基于 port) 处于 ready 状态，直接处理这个 Source1，然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(); if (hasMsg) goto handle_msg; } /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } // GCD dispatch main queue CheckIfExistMessagesInMainDispatchQueue(); // 即将进入休眠 __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting); // 等待内核 mach_msg 事件 mach\\_port\\_t wakeUpPort = SleepAndWaitForWakingUpPorts(); // 等待 ... // 从等待中醒来 __CFRunLoopDoObservers(kCFRunLoopAfterWaiting); // 处理因 timer 的唤醒 if (wakeUpPort == timerPort) __CFRunLoopDoTimers(); // 处理异步方法唤醒,如 dispatch_async else if (wakeUpPort == mainDispatchQueuePort) \\_\\_CFRUNLOOP\\_IS\\_SERVICING\\_THE\\_MAIN\\_DISPATCH\\_QUEUE\\_\\_() // 处理 Source1 else __CFRunLoopDoSource1(); // 再次确保是否有同步的方法需要调用 __CFRunLoopDoBlocks(); } while (!stop &amp;&amp; !timeout); // 通知即将退出runloop __CFRunLoopDoObservers(CFRunLoopExit); } 现在只要了解上面的伪代码知道核心的方法 __CFRunLoopRun() 内部其实是一个 do-while 循环，这也正是 Runloop 运行的本质。执行这个函数以后就一直处于 “等待-处理” 的循环之中，直到循环结束。只是不同于我们写的循环，它在休眠时几乎不会占用系统资源，当然这是由于系统内核负责实现的，也是 Runloop 精华所在。 随着 Swift 的开源，苹果也维护着一个 Swift 版本的跨平台 CoreFoundation，除了 Mac 平台，它还适配了 Linux 和 Windows 平台。 下图描述了 Runloop 运行流程（基本描述了上面 Runloop 的核心流程，当然可以查看官方 The Run Loop Sequence of Events 描述）： 需要注意的是黄色区域的消息处理中并不包含 source0，因为它在循环开始之初就被处理了，之后的循环中不再处理。 整个流程其实就是一种 Event Loop 的实现，其他平台均有类似的实现，只是名称不同。 既然 RunLoop 是一个消息循环，谁来管理和运行 Runloop ？那么它接收什么类型的消息？休眠过程是怎么样的 ？如何保证休眠时不占用系统资源 ？如何处理这些消息以及何时退出循环？还有一系列问题需要解开。 注意：尽管 CFRunLoopPerformBlock() 在上图中作为唤醒机制（手动）有所体现，但事实上执行 CFRunLoopPerformBlock() 只是入队，下次 RunLoop 运行才会执行，而如果需要立即执行则必须调用 CFRunLoopWakeUp()。 当一个 runloop 正在等一个 source 准备或者 timer 执行 fire 的时候，runloop 处于休眠状态。如果没有 source 或者 timer 准备好，runloop 会保持休眠直到超时或者被唤醒。当 runloop 被修改，例如添加了一个 source，你需要唤醒 runloop 将其加入队列。 二、Runloop Mode从源码很容易看出，每次运行 __CFRunLoopRun() 函数时必须指定 Mode，Runloop 总是运行在某种特定的 CFRunLoopModeRef 下。 而通过 CFRunloopRef 对应的结构体 __CFRunLoop 的定义可以很容易知道每种 Runloop 都可以包含若干个 Mode，每个 Mode 又包含 Source/Timer/Observer。 struct __CFRunLoop { … CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; …}; struct __CFRunLoopMode { … CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; …}; 每次调用 __CFRunLoopRun() 时指定的 Mode 是 _currentMode，当切换 Mode 时必须退出当前 Mode，然后重新进入 Runloop 以保证不同 Mode 的 Source/Timer/Observer 互不影响。 系统提供的 Mode 有 kCFRunLoopCommonModes (NSRunLoopCommonModes) kCFRunLoopDefaultMode (NSDefaultRunLoopMode) UITrackingRunLoopMode 进入 iOS 程序默认不做任何操作就处于 NSDefaultRunLoopMode 中，此时滑动视图，主线程就切换 Runloop 到 UITrackingRunLoopMode，不再接受其他事件操作，除非你将其他 Source/Timer 设置到 UITrackingRunLoopMode 下。 NSRunLoopCommonModes 并不是某种具体的 Mode，而是一种模式组合，在 iOS 系统中默认包含了 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。 注意：并不是 Runloop 会运行在 kCFRunLoopCommonModes 这种模式下，而是相当于分别注册了 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。 当然你也可以通过调用 CFRunLoopAddCommonMode() 方法将自定义 Mode 放到 kCFRunLoopCommonModes 组合中）。 系统框架自定义 Mode，例如 Foundation 中 NSConnectionReplyMode 系统私有 Mode，例如：GSEventReceiveRunLoopMode 接受系统事件，UIInitializationRunLoopMode App 启动过程中初始化 Mode。 更多系统或框架 Mode 查看这里 CFRunLoopRef 和 CFRunloopMode、CFRunLoopSourceRef/CFRunloopTimerRef/CFRunLoopObserverRef 关系如下图： CFRunLoopRef：代表 RunLoop 的对象 CFRunLoopModeRef：代表 RunLoop 的运行模式 CFRunLoopSourceRef：就是 RunLoop 模型图中提到的输入源/事件源 CFRunLoopTimerRef：就是 RunLoop 模型图中提到的定时源 CFRunLoopObserverRef：观察者，能够监听 RunLoop 的状态改变 那么 CFRunLoopSourceRef、CFRunLoopTimerRef 和 CFRunLoopObserverRef 究竟是什么？它们在 Runloop 运行流程中起到什么作用呢？ 三、SourceRun Loop 处理两大类事件源：Timer Source 和 Input Source（包括 performSelector** 方法簇、Port 或者自定义 Input Source），每个事件源都会绑定在 Run Loop 的某个特定模式 mode 上，而且只有 RunLoop 在这个模式运行的时候才会触发该 Timer 和 Input Source。 首先看一下官方 Runloop 结构图（注意下图右侧的 Input Source Port 和前面流程图中的 Source0 并不对应，而是对应 Source1。当然 Source0 也是 Input Source 中的一类，Input Source 还包括 Custom Input Source，由其他线程手动发出。Source1 和 Timer 都属于端口事件源，不同的是所有的 Timer 都共用一个端口 “Mode Timer Port”，而每个 Source1 都有不同的对应端口）： 结合前面 RunLoop 核心运行流程可以看出 Source0（负责 App 内部事件，由 App 负责管理触发，例如 UITouch 事件）和 Timer（又叫 Timer Source，基于时间的触发器，上层对应 NSTimer）是两个不同的 Runloop 事件源，RunLoop 被这些事件唤醒之后就会处理并调用事件处理方法（CFRunLoopTimerRef 和 CFRunLoopSourceRef 均包含对应的回调指针）。 但是对于 CFRunLoopSourceRef 除了 Source0 之外还有另一个版本就是 Source1，Source1 除了包含回调指针外包含一个 mach port，和 Source0 需要手动触发不同，Source1 可以监听系统端口和其他线程相互发送消息，它能够主动唤醒 RunLoop（由操作系统内核进行管理，例如 CFMessagePort 消息）。 官方也指出可以自定义 Source，因此对于 CFRunLoopSourceRef 来说它更像一种协议，框架已经默认定义了两种实现，如果有必要开发人员也可以自定义，官方文档。 四、Observerstruct __CFRunLoopObserver { CFRuntimeBase _base; pthread_mutex_t _lock; CFRunLoopRef _runLoop; CFIndex _rlCount; CFOptionFlags _activities; / immutable / CFIndex _order; / immutable / CFRunLoopObserverCallBack _callout; / immutable / CFRunLoopObserverContext _context; / immutable, except invalidation /}; 相对来说 CFRunloopObserverRef 理解起来并不复杂，它相当于消息循环中的一个监听器，随时通知外部当前 RunLoop 的运行状态（它包含一个函数指针 _callout 将当前状态及时告诉观察者）。具体的 Observer 状态如下： /* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 进入 RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将开始 Timer 处理 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将开始 Source 处理 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 从休眠状态唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 退出 RunLoop kCFRunLoopAllActivities = 0x0FFFFFFFU}; 通过代码监听 runloop 的状态变化。 - (void)viewDidLoad{ [super viewDidLoad]; // 创建观察者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { NSLog(@&quot;监听到 RunLoop 状态发生变化----%zd&quot;, activity); }); // 添加观察者到当前 runloop 中 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); } 2019-03-28 14:00:56.349332+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-2…2019-03-28 14:01:00.002807+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-322019-03-28 14:02:00.002030+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-642019-03-28 14:02:00.003182+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-22019-03-28 14:02:00.003376+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-42019-03-28 14:02:00.003634+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-32 五、Call out开发过程中，无论是 Observer 的状态通知还是 Timer、Source 的处理，几乎所有的操作都是通过 Call out 进行回调的，而系统在回调时通常使用如下几个函数进行回调，换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听 Observer 也会先调用下面的函数然后间接通知你，所以在调用堆栈中经常看到这些函数： static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(); 例如在控制器的 touchBegin 中打入断点查看堆栈（由于 UIEvent 是 Source0，所以可以看到一个 Source0 的 Call out 函数****CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION****调用）： 六、RunLoop 休眠对于 Event Loop 而言，RunLoop 最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。 RunLoop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 Darwin 中的 Mach 来完成的。可以从下图最底层 Kernel 中找到 Mach： Mach 是 Darwin 的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。 在 Mach 中，进程、线程间的通信是以消息的方式来完成的，消息在两个 Port 之间进行传递（这也正是 Source1 之所以称之为 Port-based Source 的原因，因为它就是依靠系统发送消息到指定的 Port 来触发的）。消息的发送和接收使用 &lt;mach/message.h&gt; 中的 mach_msg() 函数： /** * Routine: mach_msg * Purpose: * Send and/or receive a message. If the message operation * is interrupted, and the user did not request an indication * of that fact, then restart the appropriate parts of the * operation silently (trap version does not restart). /__WATCHOS_PROHIBITED __TVOS_PROHIBITEDextern mach_msg_return_t mach_msg( mach_msg_header_t msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 而 mach_msg() 的本质是一个调用 mach_msg_trap()，这相当于一个系统调用，会触发内核状态切换。当程序静止时，RunLoop 停留在 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy)，而这个函数内部就是调用了 mach_msg() 让程序处于休眠状态。 七、Runloop 与线程的关系Runloop 是基于 pthread 进行管理的，pthread 是基于 c 的跨平台多线程操作底层 API。它是 mach thread 的上层封装（可以参见 Kernel Programming Guide），和 NSThread 一一对应。 苹果没有开放直接创建 Runloop 的接口，如果需要，通常调用 CFRunLoopGetMain() 和 CFRunLoopGetCurrent() 两个方法来获取。 通过代码不难发现，只有当我们使用线程的方法主动 get 时才会在第一次创建该线程的 Runloop，同时将它保存在全局的字典中（线程和 Runloop 一一对应），默认情况下线程并不会创建 Runloop（主线程的 Runloop 比较特殊，任何线程创建之前都会保证主线程的已经存在），同时在线程结束的时也会销毁对应的 Runloop。 CFRunLoopRef CFRunLoopGetMain(void) { CHECK_FOR_FORK(); static CFRunLoopRef main = NULL; // no retain needed if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed return main;} CFRunLoopRef CFRunLoopGetCurrent(void) { CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self());} NSRunloop 默认提供了三个常用的 run 方法： /** * 对应上面 CFRunloopRef 中的 CFRunLoopRun() ，并且不会退出，除非调用 CFRunLoopStop()。通常如果想要永远不会退出 runloop 才会使用此方法，否则可以使用 runUntilData。 */- (void)run; /** * 对应 CFRunLoopRunInMode(mode, limiteData, true) 方法，只执行一次，执行完就退出。通常用于手动控制 runloop。 */- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate; /** * 其实是 CFRunLoopRunInMode(kCFRunLoopDefaultMode, limiteDate, false)，执行完并不会退出，继续下一次 RunLoop 直到 timeout。 */- (void)runUntilDate:(NSDate *)limitDate; 一条线程对应一个 RunLoop 对象，每条线程都有唯一一个与之对应的 RunLoop 对象。 RunLoop 并不保证线程安全。只能在当前线程内部操作当前线程的 RunLoop 对象，而不能去操作其他线程的 RunLoop 对象方法。 RunLoop 对象在第一次获取 RunLoop 时创建，销毁则是在线程结束的时候。 主线程的 RunLoop 对象系统自动帮助我们创建好了，而子线程的 RunLoop 对象需要我们主动创建和维护。 我们在启动一个 iOS 程序的时候，系统会调用创建项目时自动生成的 main.m 的文件。main.m 文件如下所示： int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} 其中 UIApplicationMain 函数内部帮我们开启了主线程的 RunLoop，UIApplicationMain 内部拥有一个无限循环的代码，只要程序不退出/崩溃，它就一直循环。上边的代码中主线程开启 RunLoop 的过程可以简单的理解为如下代码： int main(int argc, char * argv[]) { BOOL running = YES; do { // 执行各种任务，处理各种事件 // ...... } while (running); // 判断是否需要退出 return 0; } 八、RunLoop 应用1、NSTimer 前面提到的 Timer Source 作为事件源，事实上它的上层对应就是 NSTimer（其实就是 CFRunloopTimerRef，底层基于使用 mk_timer 实现），甚至很多开发者接触 RunLoop 还是从 NSTimer 开始的。 其实 NSTimer 定时器的触发正是基于 RunLoop 运行的，所以使用 NSTimer 之前必须注册到 RunLoop。但是 RunLoop 为了节省资源并不会在非常准确的时间点调用定时器，如果一个任务执行时间较长，那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer 提供了一个 tolerance 属性用于设置宽容度，如果确实想要 NSTimer 尽可能的准确，可以设置此属性）。 NSTimer 的创建通常有两种方式，尽管都是类方法，一种是 timerWithXXX:，另一种 scheduedTimerWithXXX:。 + (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo;+ (NSTimer )timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer )timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer timer))block;+ (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation )invocation repeats:(BOOL)yesOrNo;+ (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer timer))block;+ (NSTimer )scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo; schedued 方式不仅创建一个定时器，而且会自动以 NSDefaultRunLoopMode 添加到当前线程 RunLoop 中，不添加到 RunLoop 中的 NSTimer 是无法正常工作的。 同时注意，如果触发滚动事件，NSDefaultRunLoopMode 下 NSTimer 是无法正常工作的，但将 NSDefaultRunLoopMode 改为 NSRunLoopCommonModes 则可以正常工作，这也解释了前面介绍的 Mode 内容。 @interface MyViewController ()@property (nonatomic, weak) NSTimer timer1;@property (nonatomic, weak) NSTimer timer2;@end - (void)viewDidLoad{ [super viewDidLoad]; self.timer1 = \\[NSTimer scheduledTimerWithTimeInterval:...\\]; NSTimer * tempTimer = \\[NSTimer timerWithTimeInterval:...\\]; // 如果不把 tempTimer 添加到 RunLoop 中是无法正常工作的 \\[\\[NSRunLoop currentRunLoop\\] addTimer:tempTimer forMode:NSDefaultRunLoopMode\\]; self.timer2 = tempTimer; } 注意上面的 timer1 和 timer2 并没有强引用，对于其他的对象而言，执行完 viewDidLoad 方法后的的一个 RunLoop 运行结束，二者应该会被释放，但事实上二者并没有被释放。 为了确保定时器正常运转，当加入到 RunLoop 以后系统会对 NSTimer 执行一次 retain 操作。 特别注意：tempTimer 创建时并没直接赋值给 timer2，原因是 timer2 是 weak 属性，timerWithXXX: 方法创建的 NSTimer 默认并没有加入 RunLoop，如果直接赋值给 timer2 会被立即释放，只有加入 RunLoop 以后才可以将引用指向 timer2。 但是即使使用了弱引用，MyViewController 对象也无法正常释放 创建 NSTimer 时指定了 target:self，导致 NSTimer 对象对 self 有一个强引用。 解决这个问题的方法通常有两种： ①、将 target 分离出来独立成一个对象，在对象内创建 NSTimer 并将对象本身作为 NSTimer 的 target，Controller 通过这个对象间接使用 NSTimer； ②、增加 NSTimer 分类，让 NSTimer 自身作为 target，同时可以将操作 selector 封装到 block 中。后者相对优雅，也是目前使用较多的方案，例如：NSTimer+Block。 显然苹果也认识到了这个问题，如果你确保工程只支持 iOS10 运行就可以使用 iOS10 新增的系统级 block 方案。 NSTimer timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer _Nonnull timer) { }]; 使用上面第 ② 种方法可以解决控制器无法释放的问题，但是会发现即使控制器被释放了两个定时器仍然正常运行，要解决这个问题就需要调用 NSTimer 的 invalidate 方法（注意：一次性的定时器执行完操作后会自动调用 invalidate 方法）。 - (void)dealloc{ [self.timer1 invalidate]; [self.timer2 invalidate];} 其实和定时器相关的另一个问题大家也经常碰到，那就是 NSTimer 不是一种实时机制。官方文档明确说明： 在一个循环中，如果 RunLoop 没有被识别（这个时间大概在 50-100ms），或者说 currentRunLoop 在执行一个长的 call out（例如执行某个循环操作）则 NSTimer 可能就会存在误差，RunLoop 在下一次循环中继续检查并根据情况确定是否执行。 NSTimer 的执行时间总是固定在一定的时间间隔，例如 1:00:00、1:00:01、1:00:02、1:00:05 则跳过了第 4、5 次运行循环。 要演示这个问题请看下面的例子（注意：有些示例中可能会让一个线程中启动一个定时器，再在主线程启动一个耗时任务来演示这个问，如果实际测试可能效果不会太明显，因为现在的 iPhone 都是多核运算的，这样一来这个问题会变得相对复杂，因此下面的例子选择在同一个 RunLoop 中即加入定时器和执行耗时任务） #import “MyViewController.h”@interface MyViewController ()@property (nonatomic, weak) NSTimer timer;@property (nonatomic, strong) NSThread thread;@end@implementation MyViewController - (void)dealloc{ [self.timer invalidate]; // 取消定时器} - (void)viewDidLoad{ [super viewDidLoad]; self.thread = \\[\\[NSThread alloc\\] initWithTarget:self selector:@selector(performTask) object:nil\\]; \\[self.thread start\\]; } - (void)performTask{ // 使用下面的方式创建定时器虽然会自动加入到当前线程的 RunLoop 中，但是除了主线程外其他线程的 RunLoop 默认是不会运行的，必须手动调用 __weak typeof(self) weakSelf = self; self.timer = \\[NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) { if (\\[NSThread currentThread\\].isCancelled) { //\\[NSObject cancelPreviousPerformRequestsWithTarget:weakSelf selector:@selector(longTimeTask) object:nil\\]; //\\[NSThread exit\\]; \\[weakSelf.timer invalidate\\]; } NSLog(@&quot;111111111&quot;); }\\]; NSLog(@&quot;runloop before performSelector:%@&quot;,\\[NSRunLoop currentRunLoop\\]); // 区分直接调用和「performSelector:withObject:afterDelay:」区别,下面的直接调用无论是否运行RunLoop一样可以执行，但是后者则不行。 //\\[self longTimeTask\\]; \\[self performSelector:@selector(longTimeTask) withObject:nil afterDelay:2.0\\]; // 取消当前 RunLoop 中注册的 @selector（注意：只是当前 RunLoop，所以也只能在当前 RunLoop 中取消） // \\[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(longTimeTask) object:nil\\]; NSLog(@&quot;runloop after performSelector:%@&quot;,\\[NSRunLoop currentRunLoop\\]); // 非主线程RunLoop必须手动调用 \\[\\[NSRunLoop currentRunLoop\\] run\\]; NSLog(@&quot;注意：如果RunLoop 还在运行中，这里的代码并不会执行，RunLoop 本身就是一个循环.&quot;); } // 长时间任务：打印 9999 次- (void)longTimeTask{ for (int i = 0;i &lt; 9999;++i) { NSLog(@”%i, %@”, i, [NSThread currentThread]); if (\\[NSThread currentThread\\].isCancelled) { return; } } } // 取消线程- (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ [self.thread cancel];} @end 如果运行并且不退出上面的程序会发现，前两秒 NSTimer 可以正常执行，但是两秒后由于同一个 RunLoop 中 longTimeTask 循环操作的执行造成定时器跳过了中间执行的机会一直到 longTimeTask 循环完毕，这也正说明了 NSTimer 不是实时系统机制的原因。 以上程序还有几点需要说明一下： ①、NSTimer 会对 target 进行强引用直到任务结束或 exit 之后才会释放。如果上面的程序没有进行线程 cancel 而终止任务，则即使关闭控制器也无法正确释放。 ②、非主线程的 RunLoop 并不会自动运行。同时注意，默认情况下非主线程的 RunLoop 直到第一次使用之前并不会自动创建，RunLoop 运行必须要在加入 NSTimer 或 Source0、Sourc1、Observer 输入后运行否则会直接退出。例如上面代码如果 run 放到 NSTimer 创建之前，则既不会执行定时任务也不会执行循环运算。 ③、performSelector:withObject:afterDelay: 执行的本质还是通过创建一个 NSTimer 然后加入到当前线程 RunLoop（通过前后两次打印 RunLoop 信息可以看到此方法执行之后 RunLoop 的 timer 会增加 1 个。类似的还有performSelector:onThread:withObject:afterDelay:，只是它会在另一个线程的 RunLoop 中创建一个 Timer），所以此方法事实上在任务执行完之前会对触发对象形成引用，任务执行完进行释放（例如上面会对 MyViewController 形成引用，注意：performSelector:withObject: 等方法则等同于直接调用，原理与此不同）。 ④、同时上面的代码也充分说明了 RunLoop 是一个循环事实，run 方法之后的代码不会立即执行，直到 RunLoop 退出。 ⑤、上面程序的运行过程中如果突然 dismiss/pop，则程序的实际执行过程要分为两种情况考虑：如果循环任务 longTimeTask 还没有开始则会停止 timer 运行（停止了线程中第一个任务），然后等待 longTimeTask 执行并 break（停止线程中第二个任务）后线程任务执行结束释放对控制器的引用；如果循环任务 longTimeTask 执行过程中 dismiss/pop 则 longTimeTask 任务执行结束，等待 timer 下个周期运行（因为当前线程的 RunLoop 并没有退出，timer 引用计数器并不为 0）时检测到线程取消状态则执行 invalidate 方法（第二个任务也结束了），此时线程释放对于控制器的引用。 CADisplayLink 默认时是一个执行频率 fps 和屏幕刷新相同的定时器，它也需要加入到 RunLoop 才能执行。 CADisplayLink 同样是基于 CFRunloopTimerRef 实现，底层使用 mk_timer。它比 NSTimer 精度更高（尽管 NSTimer 可以修改精度）。不过遇到大任务它和 NStimer 一样存在丢帧现象。 通常情况下 CADisaplayLink 用于构建帧动画，看起来相对更加流畅，而 NSTimer 则有更广泛的用处。 2、AutoreleasePool AutoreleasePool 是另一个与 RunLoop 相关讨论较多的话题。其实从 RunLoop 源代码分析，AutoreleasePool 与 RunLoop 并没有直接的关系，之所以将两个话题放到一起讨论最主要的原因是因为在 iOS 应用启动后会注册两个 Observer 管理和维护 AutoreleasePool。不妨在应用程序刚刚启动时打印 currentRunLoop 可以看到系统默认注册了很多个 Observer，其中有两个 Observer 的 callout 都是 ** _ wrapRunLoopWithAutoreleasePoolHandler**，这两个是和自动释放池相关的两个监听。 {valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = {type = mutable-small, count = 0, values = ()}} {valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = {type = mutable-small, count = 0, values = ()}} 第一个 Observer 会监听 RunLoop 的进入，它会回调 objc_autoreleasePoolPush() 向当前的 AutoreleasePoolPage 增加一个哨兵对象标志创建自动释放池。这个 Observer 的 order 是 -2147483647 优先级最高，确保发生在所有回调操作之前。 第二个 Observer 会监听 RunLoop 的进入休眠和即将退出 RunLoop 两种状态，在即将进入休眠时会调用**objc_autoreleasePoolPop()** 和 **objc_autoreleasePoolPush() 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出 RunLoop 时会调用 objc_autoreleasePoolPop() 释放自动自动释放池内对象。这个 Observer 的 order 是 2147483647，优先级最低，确保发生在所有回调操作之后。 主线程的其他操作通常均在这个 AutoreleasePool 之内（main 函数中），以尽可能减少内存维护操作。当然你如果需要显式释放（例如循环）时可以自己创建 AutoreleasePool 否则一般不需要自己创建。 其实在应用程序启动后系统还注册了其他 Observer（例如即将进入休眠时执行注册回调 _UIGestureRecognizerUpdateObserver 用于手势处理、回调为 _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv 的 Observer 用于界面实时绘制更新）和多个 Source1（例如 context 为 CFMachPort 的 Source1 用于接收硬件事件响应进而分发到应用程序一直到 UIEvent），这里不再一一详述。 3、UI 更新 如果打印 App 启动之后的主线程 RunLoop 可以发现另外一个 callout 为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv 的 Observer，这个监听专门负责 UI 变化后的更新，比如修改了 frame、调整了 UI 层级（UIView/CALayer）或者手动设置了 setNeedsDisplay/setNeedsLayout 之后就会将这些操作提交到全局容器。而这个 Observer 监听了主线程 RunLoop 的即将进入休眠和退出状态，一旦进入这两种状态则会遍历所有的 UI 更新并提交进行实际绘制更新。 通常情况下这种方式是完美的，因为除了系统的更新，还可以利用 setNeedsDisplay 等方法手动触发下一次 RunLoop 运行的更新。但是如果当前正在执行大量的逻辑运算可能 UI 的更新就会比较卡，因此 facebook 推出了AsyncDisplayKit来解决这个问题。 AsyncDisplayKit 其实是将 UI 排版和绘制运算尽可能放到后台，将 UI 的最终更新操作放到主线程（这一步也必须在主线程完成），同时提供一套类 UIView 或 CALayer 的相关属性，尽可能保证开发者的开发习惯。这个过程中 AsyncDisplayKit 在主线程 RunLoop 中增加了一个 Observer 监听即将进入休眠和退出 RunLoop 两种状态，收到回调时遍历队列中的待处理任务一一执行。 4、NSURLConnection 在前面的网络开发的文章中已经介绍过 NSURLConnection 的使用，一旦启动 NSURLConnection 以后就会不断调用 delegate 方法接收数据，这样一个连续的的动作正是基于 RunLoop 来运行。 一旦 NSURLConnection 设置了 delegate 会立即创建一个线程 com.apple.NSURLConnectionLoader，同时内部启动RunLoop 并在 NSDefaultMode 模式下添加 4 个 Source0。其中 CFHTTPCookieStorage 用于处理 cookie；CFMultiplexerSource 负责各种 delegate 回调并在回调中唤醒 delegate 内部的 RunLoop（通常是主线程）来执行实际操作。 早期版本的 AFNetworking 库也是基于 NSURLConnection 实现，为了能够在后台接收 delegate 回调 AFNetworking 内部创建了一个空的线程并启动了 RunLoop，当需要使用这个后台线程执行任务时 AFNetworking 通过 performSelector: onThread: 将这个任务放到后台线程的 RunLoop 中。 九、GCD 和 RunLoop的关系在 RunLoop 的源代码中可以看到用到了 GCD 的相关内容，但是 RunLoop 本身和 GCD 并没有直接的关系。当调用了dispatch_async(dispatch_get_main_queue(), ^(void)block) 时 libDispatch 会向主线程 RunLoop 发送消息唤醒 RunLoop，RunLoop 从消息中获取 block，并且在 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE 回调里执行这个 block。不过这个操作仅限于主线程，其他线程 dispatch 操作是全部由 libDispatch 驱动的。 十、更多 RunLoop 使用前面看了很多 RunLoop 的系统应用和一些知名第三方库使用，那么除了这些究竟在实际开发过程中我们自己能不能适当的使用RunLoop 帮我们做一些事情呢？ 思考这个问题其实只要看 RunLoopRef 的包含关系就知道了，RunLoop 包含多个 Mode，而它的 Mode 又是可以自定义的，这么推断下来其实无论是 Source1、Timer 还是 Observer 开发者都可以利用，但是通常情况下不会自定义 Timer，更不会自定义一个完整的 Mode，利用更多的其实是 Observer 和 Mode 的切换。 例如很多人都熟悉的使用 perfromSelector 在默认模式下设置图片，防止 UITableView 滚动卡顿。 [[[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)] performSelector:@selector(setImage:) withObject:myImage afterDelay:0.0 inModes:@NSDefaultRunLoopMode]; 我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），最好能让这条线程常驻内存。 做法：添加一条用于常驻内存的强引用的子线程，在该线程的 RunLoop 下添加一个 Sources，开启 RunLoop。 具体实现过程如下： 在项目的 ViewController.m 中添加一条强引用的 thread 线程属性 #import “ViewController.h” @interface ViewController ()@property (nonatomic, strong) NSThread * thread;@end 在 viewDidLoad 中创建线程 self.thread，使线程启动并执行 addToRunLoop 方法。 - (void)viewDidLoad{ [super viewDidLoad]; // 创建线程 self.thread = \\[\\[NSThread alloc\\] initWithTarget:self selector:@selector(addToRunLoop) object:nil\\]; // 开启线程 \\[self.thread start\\]; } - (void)addToRunLoop{ NSLog(@”–addToRunLoop–”); // 添加下边两句代码，就可以开启 RunLoop，之后 self.thread 就变成了常驻线程，可随时添加任务，并交于 RunLoop 处理 \\[\\[NSRunLoop currentRunLoop\\] addPort:\\[NSPort port\\] forMode:NSDefaultRunLoopMode\\]; \\[\\[NSRunLoop currentRunLoop\\] run\\]; // 测试是否开启了 RunLoop，如果开启 RunLoop，则来不了这里，因为 RunLoop 开启了循环。 NSLog(@&quot;--after addToRunLoop--&quot;); } 运行之后发现打印了—-addToRunLoop—–，而 –after addToRunLoop– 未打印。 - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{ [self performSelector:@selector(run2) onThread:self.thread withObject:nil waitUntilDone:NO];} - (void)run2{ NSLog(@”run2”); /// 可以打印。如果 thread 没有永驻 runloop，会打印 –after addToRunLoop–，不会打印 run2} 还有 sunnyxx 的 UITableView+FDTemplateLayoutCell 利用 Observer 在界面空闲状态下计算出 UITableViewCell 的高度并进行缓存。 再有老谭的 PerformanceMonitor 关于 iOS 实时卡顿监控，同样是利用 Observer 对 RunLoop 进行监视。 关于如何自定义一个 Custom Input Source官网给出了详细的流程。","tags":[]},{"title":" 感知哈希算法\t\t","date":"2018-11-29T15:55:02.000Z","path":"2018/11/29/e6-84-9f-e7-9f-a5-e5-93-88-e5-b8-8c-e7-ae-97-e6-b3-95/","text":"感知哈希算法 Perceptual hash algorithm 是哈希算法的一类，主要用来做相似图片的搜索工作。 PHA 是一类比较哈希方法的统称。图片所包含的特征被用来生成一组指纹字符串（不过它不是唯一的），然后比较不同图片的指纹。结果越接近，就说明图片越相似。 1、基于低频的均值哈希 一张图片就是一个二维信号，它包含了不同频率的成分。亮度变化小的区域是低频成分，它描述大范围的信息。而亮度变化剧烈的区域就是高频成分，它描述具体的细节。或者说高频可以提供图片详细的信息，而低频可以提供一个框架。 而一张大的，详细的图片有很高的频率，而小图片缺乏图像细节，所以都是低频的。所以我们平时的下采样，也就是缩小图片的过程，实际上是损失高频信息的过程。 算法运算过程： ①、缩小尺寸。 将图片缩小到 8*8 的尺寸，总共 64 个像素。这一步的作用是最快速的去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。 ②、简化色彩。 将缩小后的图片，转为 64 级灰度。也就是说，所有像素点总共只有 64 种颜色。 ③、计算所有 64 个像素的灰度平均值。 ④、比较像素的灰度。 将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为 1；小于平均值，记为 0。 ⑤、计算哈希值。 将上一步的比较结果，组合在一起，就构成了一个 64 位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。 得到指纹以后，就可以对比不同的图片，看看 64 位中有多少位是不一样的。在理论上，这等同于计算“汉明距离”（Hamming distance）。如果不相同的数据位不超过 5，就说明两张图片很相似；如果大于 10，就说明这是两张不同的图片。 优点：简单快速，不受图片大小缩放的影响 缺点：图片的内容不能变更。如果在图片上加几个文字，它就认不出来了。 所以，它的最佳用途是根据缩略图找出原图。 实际应用中，往往采用更强大的 pHash 算法和 SIFT 算法，它们能够识别图片的变形。只要变形程度不超过 25%，它们就能匹配原图。这些算法虽然更复杂，但是原理与上面的简便算法是一样的，就是先将图片转化成 Hash 字符串，然后再进行比较。 文章：iOS实现感知哈希算法 2、增强版：pHash 均值哈希虽然简单，但受均值的影响非常大。例如对图像进行伽马校正或直方图均衡就会影响均值，从而影响最终的 hash 值。存在一个更健壮的算法叫 pHash。它将均值的方法发挥到极致。使用离散余弦变换来获取图片的低频成分。 离散余弦变换 DCT是种图像压缩算法，它将图像从像素域变换到频率域。然后一般图像都存在很多冗余和相关性的，所以转换到频率域之后，只有很少的一部分频率分量的系数才不为 0，大部分系数都为 0（或者说接近于 0）。下图的右图是对lena图进行离散余弦变换（DCT）得到的系数矩阵图。从左上角依次到右下角，频率越来越高，由图可以看到，左上角的值比较大，到右下角的值就很小很小了。换句话说，图像的能量几乎都集中在左上角这个地方的低频系数上面了。 pHash的工作过程如下： （1）缩小尺寸：pHash以小图片开始，但图片大于8*8，32*32是最好的。这样做的目的是简化了DCT的计算，而不是减小频率。 （2）简化色彩：将图片转化成灰度图像，进一步简化计算量。 （3）计算DCT：计算图片的DCT变换，得到32*32的DCT系数矩阵。 （4）缩小DCT：虽然DCT的结果是32*32大小的矩阵，但我们只要保留左上角的8*8的矩阵，这部分呈现了图片中的最低频率。 （5）计算平均值：如同均值哈希一样，计算DCT的均值。 （6）计算hash值：这是最主要的一步，根据8*8的DCT矩阵，设置0或1的64位的hash值，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。 文章：三种基于感知哈希算法的相似图像检索技术","tags":[]},{"title":" 内存监控\t\t","date":"2018-11-29T07:10:12.000Z","path":"2018/11/29/e5-86-85-e5-ad-98-e7-9b-91-e6-8e-a7/","text":"原文：https://cloud.tencent.com/developer/article/1359436、Memory Usage Performance Guidelines、No pressure, Mon! 一、导读目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，用于 App 上线后发现内存问题。 FOOM(Foreground Out Of Memory)是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。Facebook 早在 2015 年 8 月提出 FOOM 检测办法。 微信自 15 年年底上线 FOOM 上报，从最初数据来看，每天 FOOM 次数与登录用户数比例接近 3%，同期 crash 率 1% 不到。而后发现 kv 上报频繁打 log 引起 FOOM。接着分析大量日志还是不能找到 FOOM 原因。微信急需一个有效的内存监控工具来发现问题。 二、实现原理微信内存监控最初版本是使用 Facebook 的 FBAllocationTracker 工具监控 OC 对象分配，用 fishhook 工具 hook malloc/free 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP200 最大堆内存及其分配堆栈，用文本 log 输出到本地。该方案实现简单，一天内完成，通过给用户下发 TestFlight，最终发现联系人模块因迁移 DB 加载大量联系人导致FOOM。 不过这方案有不少缺点： ①、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用； ②、输出 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io 频繁等性能问题； ③、上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。 所以二期版本以 Instruments 的 Allocations 为参考，着重四个方面优化：数据收集、存储、上报及展现。 1、数据收集 16 年 9 月底为了解决 ios10 nano crash，研究了 libmalloc 源码，无意中发现这几个接口： typedef void (malloc_logger_t)(uint32_t type, uintptr_t arg1, uintptr_t arg2, uintptr_t arg3, uintptr_t result, uint32_t num_hot_frames_to_skip);extern malloc_logger_t *__syscall_logger; // use this to set up syscall logging (e.g., vm_allocate, vm_deallocate, mmap, munmap) malloc_logger_t *malloc_logger = NULL; 当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。 有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址 =堆栈地址 - slide。 另外为了更好的归类数据，每个内存对象应该有它所属的分类 Category。如上图所示。对于堆内存对象，它的 Category 名是 “Malloc” +分配大小，如 “Malloc 48.00KiB”。 对于虚拟内存对象，调用 vm_allocate 创建时，最后的参数 flags 代表它是哪类虚拟内存，而这个 flags 正对应于上述函数指针 __syscall_logger 的第一个参数 type，每个 flag 具体含义可以在头文件 &lt;mach/vm_statistics.h&gt; 找到； 对于 OC 对象，它的 Category 名是 OC 类名，我们可以通过 hook OC方法 +[NSObject alloc] 来获取： @implementation NSObject (Logger) + (void)load{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ SEL originSEL = @selector(alloc); SEL swizzeSEL = @selector(event_logging_alloc); Method originMethod = class_getClassMethod(self.class, originSEL); Method swizzeMethod = class_getClassMethod(self.class, swizzeSEL); method_exchangeImplementations(originMethod, swizzeMethod); }); } + (instancetype)event_logging_alloc{ id object = [self event_logging_alloc]; // 对于 NSAutoreleasePool 对象会崩掉 nsobject\\_set\\_last\\_allocation\\_event\\_name(object, class\\_getName(self.class)); return object; } void nsobject_set_last_allocation_event_name(id obj, const char * clsName){ NSLog(@”%s”, clsName); // 输出类名} 但后来发现，NSData创建对象的类静态方法没有调用 +[NSObject alloc]，里面实现是调用 C 方法 NSAllocateObject 来创建对象，也就是说类方式创建的 OC 对象无法通过 hook 来获取 OC 类名。最后在苹果开源代码 CF-1153.18 找到了答案，当CFOASafe=true 并且 CFObjectAllocSetLastAllocEventNameFunction != NULL 时，CoreFoundation 创建对象后通过这个函数指针告诉上层当前对象是什么类型： // CFRuntime.c bool CFOASafe = false;void (*CFObjectAllocSetLastAllocEventNameFunction)(void *, const char *) = NULL; 通过上面方式，我们的监控数据来源基本跟 Allocations 一样了，当然是借助了私有 API，这是可能会被苹果打回的。只能退而求其次，修改 malloc_default_zone 函数返回的 malloc_zone_t 结构体里的 malloc、free 等函数指针，也是可以监控堆内存分配，效果等同于 malloc_logger；而虚拟内存分配只能通过 fishhook 方式。 2、数据存储 ①、存活对象管理 APP 在运行期间会大量申请/释放内存。以上图为例，微信启动 10 秒内，已经创建了 80 万对象，释放了 50 万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了 sqlite，改用了更轻量级的平衡二叉树来存储。 伸展树 Splay Tree，也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是 O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过 “伸展” 操作搬移到离树根更近的地方。 大部分情况下，内存申请很快又被释放，如 autoreleased 对象、临时变量等；而 OC 对象申请内存后紧接着会更新它所属Category。所以用伸展树管理最适合不过了。 传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。 ②、堆栈存储 据统计，微信运行期间，backtrace 的堆栈有成百万上千万种，在捕获最大栈长 64 情况下，平均栈长 35。如果 36bits 存储一个地址（armv8 最大虚拟内存地址 48bits，实际上 36bits 够用了），一个堆栈平均存储长度 157.5bytes，1M 个堆栈需要157.5M 存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后 7 个地址是一样的： 为此，可以用 Hash Table 来存储这些堆栈。思路是整个堆栈以链表的方式插入到 table 里，链表结点存放当前地址和上一个地址所在 table 的索引。每插入一个地址，先计算它的 hash 值，作为在 table 的索引，如果索引对应的 slot 没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash 命中，继续处理下一个地址；数据不一致，意味着 hash 冲突，需要重新计算 hash 值，直到满足存储条件。举个例子（简化了 hash 计算）： Stack1 的 G、F、E、D、C、A、依次插入到哈希表，索引 1～6 结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1 索引入口是 6 轮到插入 Stack2，由于 G、F、E、D、C 结点数据跟 Stack1 前 5 个结点一致，hash 命中；B 插入新的 7 号位置 (B, 5)。Stack2 索引入口是 7 最后插入 Stack3，G、F、E、D 结点 hash 命中；但由于 Stack3 的 A 的上一个地址 D 索引是 4，而不是已有的 (A, 5)，hash 不命中，查找下一个空白位置 8，插入结点 (A, 4)；B 上一个地址 A 索引是 8，而不是已有的 (B, 5)，hash 不命中，查找下一个空白位置 9，插入结点 (B, 9)。Stack3 索引入口是 9 经过这样的后缀压缩存储，平均栈长由原来的 35 缩短到 5 不到。而每个结点存储长度为 64bits（36bits 存储地址，28bits 储存 parent 索引），hashTable 空间利用率 60%+，一个堆栈平均存储长度只需要 66.7bytes，压缩率高达 42%。 ③、性能数据 经过上述优化，内存监控工具在 iPhone6Plus 运行占用 CPU 占用率 13% 不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量 20M 左右，都用 mmap 方式把文件映射到内存。有关 mmap 好处可自行google。 三、数据上报由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现 FOOM 时，不可能全量上报，而是按某些规则有选择性的上报。 首先把所有对象按 Category 进行归类，统计每个 Category 的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对 Category 下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些 Category，如分配大小 TOP N，或者UI相关的（如 UIViewController、UIView 之类的），它里面分配大小 TOP M 的堆栈才做上报。上报格式类似这样： { “items” : [{ “name” : “NSObject”, # 分类名字 “size” : 123456, # 该分类下分配内存总大小 “count” : 123, “stacks” : [{ “size” : 21313, # 总大小 “count” : 123, # 对象个数 “frames” : [{ “uuid” : uuid1, # 地址所在 image 的 uuid “offset” : offset1 # 地址所在 image 的偏移 }] }] }]} 四、页面展现页面展现参考了 Allocations，可看出有哪些 Category，每个 Category 分配大小和对象数，某些 Category 还能看分配堆栈。 为了突出问题，提高解决问题效率，后台先根据规则找出可能引起 FOOM 的 Category（如上面的 Suspect Categories），规则有： UIViewController 数量是否异常 UIView 数量是否异常 UIImage 数量是否异常 其它 Category 分配大小是否异常，对象个数是否异常 接着对可疑的 Category 计算特征值，也就是 OOM 原因。特征值是由 “Caller1”、”Caller2” 和 “Category, Reason” 组成。Caller1 是指申请内存点，Caller2 是指具体场景或业务，它们都是从 Category 下分配大小第一的堆栈提取。Caller1 提取尽量是有意义的，并不是分配函数的上一地址。例如： 所有 report 计算出特征值后，可以对它们进行归类了。一级分类可以是 Caller1，也可以是 Category，二级分类是与Caller1/Category 有关的特征聚合。效果如下： 一级分类 二级分类 五、运营策略上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概 300K 左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做 100% 开启。本地最多只保留最近三次数据。 六、降低误判先回顾 Facebook 如何判定上一次启动是否出现 FOOM： App 没有升级 App 没有调用exit() 或abort() 退出 App 没有出现 crash 用户没有强退 App 系统没有升级/重启 App 当时没有后台运行 App 出现FOOM 1、2、4、5 比较容易判断，3 依赖于自身 CrashReport 组件的 crash 回调，6、7 依赖于 ApplicationState 和前后台切换通知。微信自上线 FOOM 数据上报以来，出现不少误判，主要情况有： 1、ApplicationState 不准 部分系统会在后台短暂唤起 app，ApplicationState 是 Active，但又不是 BackgroundFetch；执行完didFinishLaunchingWithOptions 就退出了，也有收到 BecomeActive 通知，但很快也退出；整个启动过程持续 5～8 秒不等。解决方法是收到 BecomeActive 通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。 2、群控类外挂 这类外挂是可以远程控制 iPhone 的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。 3、CrashReport 组件出现 crash 没有回调上层 微信曾经在 17 年 5 月底爆发大量 GIF crash，该 crash 由内存越界引起，但收到 crash 信号写 crashlog 时，由于内存池损坏，组件无法正常写 crashlog，甚至引起二次 crash；上层也无法收到 crash 通知，因此误判为 FOOM。目前改成不依赖 crash回调，只要本地存在上一次 crashlog（不管是否完整），就认为是 crash 引起的 APP 重启。 4、前台卡死引起系统 watchdog 强杀 也就是常见的 0x8badf00d，通常原因是前台线程过多，死锁，或 CPU 使用率持续过高等，这类强杀无法被 App 捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被 watchdog 强杀。同时我们从 FOOM 划分出新的重启原因叫“App 前台卡死导致重启”，列入重点关注。 七、**成果**微信自 2017 年三月上线内存监控以来，解决了 30 多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM 率由 17 年年初 3%，降到目前 0.67%，而前台卡死率由 0.6% 下降到 0.3%，效果特别明显。 八、**常见问题**1、UIGraphicsEndImageContext UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode 的 Analyze 也能扫出这类问题。 2、UIWebView 无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 APP 大量内存。而 WKWebView 不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。 3、autoreleasepool 通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。 4、互相引用 比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer的 target、CAAnimation 的 delegate，是对 Obj 强引用。目前微信通过自己实现的 MMNoRetainTimer 和 MMDelegateCenter 来规避这类问题。 5、大图片处理 举个例子，以往图片缩放接口是这样写的： - (UIImage )scaleImage:(UIImage )originIamge newSize:(CGSize)newSize{ UIGraphicsBeginImageContextWithOptions(originIamge.size, NO, 0); [originIamge drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)]; UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } 但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很耗内存的。解决方法是使用更低层的 ImageIO 接口，避免中间 bitmap 产生： + (UIImage )scaleImageWithData:(NSData )data withSize:(CGSize)size scale:(CGFloat)scale orientation:(UIImageOrientation)orientation{ CGFloat maxPixelSize = MAX(size.width, size.height); CGImageSourceRef sourceRef = CGImageSourceCreateWithData((bridge CFDataRef)data, nil); NSDictionary * options = @{ (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue, (bridge id)kCGImageSourceThumbnailMaxPixelSize : @(maxPixelSize)}; CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(sourceRef, 0, (__bridge CFDictionaryRef)options); UIImage * resultImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation]; CGImageRelease(imageRef); CFRelease(sourceRef); return resultImage; } 6、大视图 大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。","tags":[]},{"title":" 哈希算法\t\t","date":"2018-11-28T16:16:49.000Z","path":"2018/11/29/e5-93-88-e5-b8-8c-e7-ae-97-e6-b3-95/","text":"Hash 一般翻译做”散列”，也有直接音译为”哈希”的，就是把任意长度的输入（又叫做预映射，pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。 哈希算法将数据进行摘要计算，将大小不一的数据源计算为统一长度的值，便于查找。 关键特性：单向性、抗冲突性、映射分布均匀性和差分分布均匀性。 MD5 可以说是目前应用最广泛的 Hash 算法。MD5 算法将文件或者数据源（字符串、数值等）计算出一个固定值，主要应用场景是：文件的数字签名、文件是否被篡改。 MD2、MD4、MD5#import &lt;CommonCrypto/CommonDigest.h&gt;{ const char * cStr = [@”” UTF8String]; u_char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5( cStr, (unsigned int)strlen(cStr), digest ); NSMutableString * output = \\[NSMutableString stringWithCapacity:CC\\_MD5\\_DIGEST_LENGTH * 2\\]; for(int i = 0; i &lt; CC\\_MD5\\_DIGEST_LENGTH; i++) { \\[output appendFormat:@&quot;%02x&quot;, digest\\[i\\]\\]; } } SHA1、SHA224、SHA256、SHA384、SHA512#import &lt;CommonCrypto/CommonDigest.h&gt; { uint8_t digest[CC_SHA1_DIGEST_LENGTH]; CC_SHA1(data.bytes, (unsigned int)data.length, digest); NSMutableString * output = \\[NSMutableString stringWithCapacity:CC\\_SHA1\\_DIGEST_LENGTH\\]; for (int i = 0; i &lt; CC\\_SHA1\\_DIGEST_LENGTH; i++) { \\[output appendFormat:@&quot;%02x&quot;, digest\\[i\\]\\]; } }","tags":[]},{"title":" Memory warning\t\t","date":"2018-11-28T14:58:20.000Z","path":"2018/11/28/memory-warning/","text":"在 iOS4 和 iOS5 系统中，当内存不足，应用收到 Memory warning 时，系统会自动调用当前没在界面上的 Controller 的 viewDidUnload 方法。 通常情况下，这些未显示在界面上的 ViewController 是 Navigation Push 栈中未在栈顶的，以及 UITabBarVC中未显示的子 VC。这些 VC 都会在 Memory Warning 事件发生时，被系统自动调用 viewDidUnload 方法。 由于 viewDidUnload 事件在 iOS6 中任何情况都不会被触发，所以苹果在文档中建议，应该将回收内存的相关操作移到另一个回调函数：didReceiveMemoryWarning 中。但是如果仅仅是把以前 viewDidUnload 的代码进行移动，那就错了。 错误的示例代码： - (void)didReceiveMemoryWarning{ [super didReceiveMemoryWarning]; if(\\[self isViewLoaded\\] &amp;&amp; !\\[\\[self view\\] window\\]) { self.view = nil; } } iOS6 不推荐你将 view 置为 nil 的原因如下： UIView 有一个 CALayer 的成员变量，CALayer 是具体用于将自己画到屏幕上的。CALayer 是一个 bitmap 图像的容器类，当 UIView 调用自身的 drawRect 时，CALayer 才会创建这个 bitmap 图象类。 具体占内存的其实是一个 bitmap 图像类，CALayer 只占 48bytes，UIView 只占 96bytes。而 iPad 上全屏的 UIView 的 bitmap 类会占到 12M 的大小！ 在 iOS6 时，当系统发出 MemoryWarning 时，系统会自动回收 bitmap 类。但是不回收 UIView 和 CALayer 对象。这样即回收了大部分内存，又能在需要 bitmap 对象时，通过调用 UIView 的 drawRect: 方法重建。 一、内存优化另外还提到苹果的操作系统对此做的一个内存优化技巧，解释如下： ①、当一段内存被分配时，它会被标记成 “In use”，以防止被重复使用。当内存被释放时，这段内存会被标记成 “Not in use”，这样，在有新的内存申请时，这块内存就可能被分配给其它变量。 ②、CALayer 包括的具体的 bitmap 内容的私有成员变量类型为 CABackingStore， 当收到 MemroyWarning 时，CABackingStore 类型的内存区会被标记成 volatile 类型，volatile 表示这块内存可能被再次被原变量重用。 有了上面的优化后，当收到 MemoyWarning 时，虽然所有的 CALayer 所包含的 bitmap 内存都被标记成 volatile 了，但是只要这块内存没有再次被复用，那么当需要重建 bitmap 内存时，它就可以直接被复用，而避免了再次调用 UIView 的 drawRect: 方法。 二、总结所以，对于 iOS6，你不需要做任何以前 viewDidUnload 的事情，更不需要把以前 viewDidUnload 的代码移动到 didReceiveMemoryWarning 方法中。 引用 WWDC 2012 中的一段话来给 viewDidUnload 说再见： The method viewWillUnload and viewDidUnload. We’re not going to call them anymore. I mean, there’s kind of a cost-benifit equation and analysis that we went through. In the early days, there was a real performance need for us to ensure that on memory warnings we unloaded views. There was all kinds of graphics and backing stores and so forth that would also get unloaded. We now unload those independently of the view, so it isn’t that big of a deal for us for those to be unloaded, and there were so many bugs where there would be pointers into。","tags":[]},{"title":" CoreAnimation\t\t","date":"2018-11-28T07:53:56.000Z","path":"2018/11/28/coreanimation/","text":"官方文档 1 官方文档 2 Core Animation does the rest, handing most of the actual drawing work off to the onboard graphics hardware to accelerate the rendering. This automatic graphics acceleration results in high frame rates and smooth animations without burdening the CPU and slowing down your app. 开发者设置动画参数之后，Core Animation 处理剩余的，将大部分实际绘图工作交给机载图形硬件以加速渲染。这种自动图形加速导致高帧速率和平滑的动画，没有给 CPU负担和放慢应用程序。","tags":[]},{"title":" 开闭原则\t\t","date":"2018-11-28T06:46:00.000Z","path":"2018/11/28/e5-bc-80-e9-97-ad-e5-8e-9f-e5-88-99/","text":"开闭原则（OCP）是面向对象设计中 “可复用设计” 的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。 软件实体应当对扩展开放，对修改关闭。 通俗来讲：软件系统中包含的各种组件，例如模块、类以及功能等等，应该在不修改现有代码的基础上，引入新功能。 开，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的； 闭，是指对于原有代码的修改是封闭的，对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。 一、实现方法实现开闭原则的关键就在于 “抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。 我们在软件开发的过程中，一直都是提倡需求导向的。这就要求我们在设计的时候，要非常清楚地了解用户需求，判断需求中包含的可能的变化，从而明确在什么情况下使用开闭原则。 关于系统可变的部分，还有一个更具体的对可变性封装原则（Principle of Encapsulation of Variation, EVP），它从软件工程实现的角度对开闭原则进行了进一步的解释。EVP要求在做系统设计的时候，对系统所有可能发生变化的部分进行评估和分类，每一个可变的因素都单独进行封装。 我们在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。 二、好处可复用性好。我们可以在软件完成以后，仍然可以对软件进行扩展，加入新的功能，非常灵活。因此，这个软件系统就可以通过不断地增加新的组件，来满足不断变化的需求。 可维护性好。由于对于已有的软件系统的组件，特别是它的抽象底层不去修改，因此，我们不用担心软件系统中原有组件的稳定性，这就使变化中的软件系统有一定的稳定性和延续性。","tags":[]},{"title":" 门面模式\t\t","date":"2018-11-28T06:41:49.000Z","path":"2018/11/28/e9-97-a8-e9-9d-a2-e6-a8-a1-e5-bc-8f/","text":"门面 (facade) 模式，是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。 一、实现形式①、定义一个（或多个）具备所需接口的新类（门面类）②、新类门户使用原来的系统③、客户使用门面类对象与原系统打交道 二、使用场景①、客户只需要使用某个复杂系统的子集，或者需要以一种特殊的方式与系统交互时，使用门面模式。 ②、当需要跟踪原系统的使用情况时，使用门面模面模式。因为所有对系统的访问都经过 facade，所以可以很容易地监视系统的使用。 ③、希望封装和隐藏原系统时。 ④、编写新类的成本小于所有人使用和维护原系统使用所需的成本时。 三、门面模式优点①、当你要为一个复杂子系统提供一个简单接口时。在上面已经描述了原因。 ②、由于抽象类的实现部分与客户程序之间存在着很大的依赖性。引入 facade 将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 ③、当你需要构建一个层次结构的子系统时，使用 facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 facade 进行通讯，从而简化了它们之间的依赖关系。 ④、它可以对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。 ⑤、它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade 模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。 Facade 模式可以消除复杂的循环依赖关系，这一点在客户程序与子系统是分别实现的时候尤为重要。在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。用 Facade 可以降低编译依赖性，限制重要系统中较小的变化所需的重编译工作。 Facade 模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。 ⑥、如果应用需要，它并不限制它们使用子系统类。因此你可以让客户程序在系统易用性和通用性之间加以选择。 四、门面模式缺点不符合开闭原则。所谓的开闭原则是软件工程里面一个最基本的原则：对扩展开放，对修改关闭。换句话说，你的系统可以提供新的功能模块而不必进行修改。","tags":[]},{"title":" 迪米特法则\t\t","date":"2018-11-28T06:31:54.000Z","path":"2018/11/28/e8-bf-aa-e7-b1-b3-e7-89-b9-e6-b3-95-e5-88-99/","text":"迪米特法则 Law of Demeter 又叫作最少知识原则（Least Knowledge Principle 简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。英文简写为: LoD. 迪米特法则可以简单说成：talk only to your immediate friends。 对于 OOD 来说，又被解释为下面几种方式：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系，这在一定程度上增加了系统的复杂度。 有兴趣可以研究一下设计模式的门面模式（Facade）和中介模式（Mediator），都是迪米特法则应用的例子。 一、狭义的迪米特法则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 “朋友”条件： ①、当前对象本身 ②、以参量形式传入到当前对象方法中的对象 ③、当前对象的实例变量直接引用的对象 ④、当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友 ⑤、当前对象所创建的对象 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。 狭义的迪米特法则的缺点： 在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。 遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。 二、广义的迪米特法则在类的设计上的体现： ①、优先考虑将一个类设置成不变类。 ②、尽量降低一个类的访问权限。 ③、谨慎使用 Serializable。 ④、尽量降低成员的访问权限。","tags":[]},{"title":" SwipeTableView\t\t","date":"2018-11-27T14:58:37.000Z","path":"2018/11/27/swipetableview/","text":"代码 Mode1 Mode2 Mode1 与 Mode2 的不同在于 SwipTableView 顶部留白的方式： Mode1 使用contentInset Mode2 使用tableHeaderView Mode1 的刷新控件在contentInset 底部，Mode2 的刷新控件在SwipTableView 的顶部。 SwipTableView 实现：1、底层视图 2、刷新控件的处理 3、滚动视图的逻辑 4、监听 问题 &amp; 解决：http://www.dzliving.com/2018/12/07/uitableview/ STCollectionView 实现：1、UICollectionView 代理 2、自定义 FlowLayout(重点看下) /** * 重写系统方法 */- (void)prepareLayout { }- (UICollectionViewLayoutAttributes )layoutAttributesForSupplementaryViewOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath { }- (UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath { }- (NSArray )layoutAttributesForElementsInRect:(CGRect)rect { }- (CGSize)collectionViewContentSize { }- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds { } /** * 自定义方法 */- (void)calculateTopHeaderAttributes { } // 计算顶部高度- (void)prepareLayoutInSection:(NSUInteger)section numberOfItems:(NSUInteger)items { } // 计算 item 的高度- (CGFloat)heightOfItemsContentInSection:(NSUInteger)sectionIdx { } // 计算 section 的高度- (NSInteger)numberOfItemsForColumn:(NSInteger)columnIdx inSection:(NSInteger)sectionIdx { }- (CGFloat)lastItemMaxYForColumn:(NSInteger)columnIdx inSection:(NSInteger)sectionIdx { } // 最后一个 item 的 MaxY- (NSInteger)shortestColumnIndexInSection:(NSInteger)sectionIdx { } // 最短列 item 的索引- (CGRect)rectForSectionAtIndex:(NSInteger)sectionIdx { }- (NSArray )searchVisibleLayoutAttributesInRect:(CGRect)rect { } // 查找可见的 items- (NSIndexSet )sectionIndexesInRect:(CGRect)rect { } // rect 范围内的 item 索引数组 STHeaderView 实现：可拖拽 &amp; 同时触发底部滚动视图滚动。重点关注 UIDynamic 的相关处理。 @property (nonatomic, strong) UIPanGestureRecognizer panGestureRecognizer; // 手势@property (nonatomic, strong) UIDynamicAnimator animator;@property (nonatomic, strong) UIDynamicItemBehavior decelerationBehavior;@property (nonatomic, strong) UIAttachmentBehavior springBehavior;@property (nonatomic, strong) STDynamicItem *dynamicItem; STRefreshHeader 实现：下拉控件。重点关注动画效果。 - (void)startLoadingAnimation { } // 开始动画。对圆环进行 strokeStart、strokeEnd 动画- (void)stopLoadingAnimation { } // 结束动画。直接设置 strokeStart、strokeEnd、strokeColor 属性值- (void)willMoveToSuperview:(UIView *)newSuperview { } // 添加到父视图。需判断父视图是否是 UIScrollView，然后对 contentOffset 字段进行监听 - (void)observeValueForKeyPath:(NSString )keyPath ofObject:(id)object change:(NSDictionary&lt;NSString ,id&gt; )change context:(void )context{ // 拖拽 if (self.scrollView.isDragging) { CGFloat pullPercent = fmin(moveOffsetY/kSTRefreshHeaderHeight, 1); // 计算出下拉比例，用于 layer 的状态 _circleLayer.strokeEnd = pullPercent; _contentView.alpha = pullPercent; \\_headerImageV.transform = CGAffineTransformMakeRotation(pullPercent * (M\\_PI - 0.001)); if (self.state == STRefreshStateRefeshing) { return; } self.state = STRefreshStatePulling; if (moveOffsetY &gt; kSTRefreshHeaderHeight) { self.state = STRefreshStateWillRefesh; } } // 松手刷新 或 返回 else { if (self.state == STRefreshStateWillRefesh) { \\[self beganRefreshing\\]; } else if (self.state != STRefreshStateNormal) { CGFloat pullPercent = fmin(moveOffsetY/kSTRefreshHeaderHeight, 1); _circleLayer.strokeEnd = pullPercent; _contentView.alpha = pullPercent; \\_headerImageV.transform = CGAffineTransformMakeRotation(pullPercent * (M\\_PI - 0.001)); } } } - (void)executeRefreshingCallback { } // 执行回调 STTransitions 实现：自定义转场动画，遵守 UIViewControllerAnimatedTransitioning 协议 - (NSTimeInterval)transitionDuration:(id )transitionContext{ return _transitionDuration; // 转场时间} - (void)animateTransition:(id )transitionContext{ UIView containerView = [transitionContext containerView]; UIViewController fromVC = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController toVC = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView fromView = fromVC.view; UIView * toView = toVC.view; // 展示视图 if (_isPresenting) { STImageController * imageVC = (STImageController *)toVC; UIImageView * fromImageView = _fromView.imageView; UIImageView * toImageView = imageVC.imageView; CGFloat imageH = fromImageView.image.size.height/fromImageView.image.size.width * kScreenWidth; CGRect toFrame = CGRectMake(0, (kScreenHeight - imageH)/2, kScreenWidth, imageH); // 结束位置为居中 toImageView.image = fromImageView.image; toImageView.frame = toFrame; UIImageView * transitionView = \\[\\[UIImageView alloc\\] initWithImage:fromImageView.image\\]; fromView.alpha = 1.0f; toView.alpha = 0.3f; fromImageView.hidden = YES; toImageView.hidden = YES; transitionView.frame = \\[containerView convertRect:fromImageView.frame fromView:fromImageView.superview\\]; \\[containerView addSubview:toVC.view\\]; \\[containerView addSubview:transitionView\\]; \\[UIView animateWithDuration:\\[self transitionDuration:transitionContext\\] animations:^{ transitionView.frame = \\[containerView convertRect:toFrame fromView:toImageView.superview\\]; fromView.alpha = 0.0f; toView.alpha = 1.0f; } completion:^(BOOL finished) { toImageView.hidden = NO; \\[transitionView removeFromSuperview\\]; \\[transitionContext completeTransition:YES\\]; }\\]; } // 隐藏视图 else { STImageController * imageVC = (STImageController *)fromVC; UIImageView * fromImageView = imageVC.imageView; UIImageView * toImageView = _fromView.imageView; UIImageView * transitionView = \\[\\[UIImageView alloc\\] initWithImage:fromImageView.image\\]; fromView.alpha = 1.0f; toView.alpha = 0; fromImageView.hidden = YES; // presenting 时的 toImageView toImageView.hidden = YES; // presenting 时的 fromImageView transitionView.frame = \\[containerView convertRect:fromImageView.frame fromView:fromImageView.superview\\]; \\[containerView addSubview:toVC.view\\]; \\[containerView addSubview:transitionView\\]; \\[UIView animateWithDuration:\\[self transitionDuration:transitionContext\\] animations:^{ transitionView.frame = \\[containerView convertRect:toImageView.frame fromView:toImageView.superview\\]; fromView.alpha = 0.0f; toView.alpha = 1.0f; } completion:^(BOOL finished) { toImageView.hidden = NO; \\[transitionView removeFromSuperview\\]; \\[transitionContext completeTransition:YES\\]; }\\]; } } 另一种思路实现 使用 UITableView &amp; UIScrollView &amp; UITableView 的方式实现，因为 sectionHeader 自然吸顶（plain + numberOfSection），剩下就只需要更新 tableView 的 cell 高度和处理滚动问题。 @implementation CYEMSimultaneouslyTV /** * @brief 同时识别多个手势 */- (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer{ return YES;} @end","tags":[]},{"title":" Vue\t\t","date":"2018-11-27T03:28:43.000Z","path":"2018/11/27/vue/","text":"","tags":[]},{"title":" 引用计数\t\t","date":"2018-11-26T07:16:27.000Z","path":"2018/11/26/e5-bc-95-e7-94-a8-e8-ae-a1-e6-95-b0/","text":"一、简介 OC 在创建对象时，不会直接返回该对象，而是返回一个指向对象的指针。 OC 在内存管理上采用了引用计数，它是一个简单而有效管理对象生命周期的方式。在对象内部保存一个用来表示被引用次数的数字，init、new 和 copy 都会让计数 +1，调用 release 让计数 -1。当计数等于 0 的时候，系统调用 dealloc 方法来销毁对象。 A * a = [[A alloc] init]; // retain count = 1 A * b = a; // 指针赋值时，retain count 不会自动增加 [b retain]; // retain count = 2 { OBJC_EXTERN int _objc_rootRetainCount(id); NSObject * obj = \\[\\[NSObject alloc\\] init\\]; // 创建对象并引用，引用计数为 1 NSLog(@&quot;obj retainCount:%lu&quot;, (unsigned long)\\_objc\\_rootRetainCount(obj)); NSObject * obj1 = \\[\\[NSObject alloc\\] init\\]; // 创建对象并引用，引用计数为 1 NSLog(@&quot;obj1 retainCount:%lu&quot;, (unsigned long)\\_objc\\_rootRetainCount(obj1)); // obj 指向了 obj1 所指的对象 B，失去了对原来对象A的引用,所以对象A的引用计数-1，为 0。A 被销毁 // 对于 B，obj 引用了它，所以引用计数 +1，为 2 obj = obj1; // self.obj 又引用了 A,所以引用计数 +1，为 3 self.obj = obj; NSLog(@&quot;strong obj1 retainCount:%lu&quot;,(unsigned long)\\_objc\\_rootRetainCount(obj1)); NSLog(@&quot;strong obj retainCount:%lu&quot;,(unsigned long)\\_objc\\_rootRetainCount(obj)); } 引用计数分为自动引用计数「ARC : Automatic Reference Counting」和手动引用计数「MRC : Manual Reference Counting」。 二、原理 三、示例NSObject * obj1 = [NSObject new];NSLog(@”引用计数: %lu”, (unsigned long)[obj1 retainCount]); NSObject obj2 = [obj1 retain];NSObject obj3 = [obj1 retain]; NSLog(@”引用计数: %lu”, (unsigned long)[obj1 retainCount]); [obj1 release];NSLog(@”引用计数: %lu %@”, (unsigned long)[obj1 retainCount], obj1); [obj1 release];NSLog(@”引用计数: %lu %@”, (unsigned long)[obj1 retainCount], obj1); [obj1 release];NSLog(@”引用计数: %lu %@”, (unsigned long)[obj1 retainCount], obj1); 引用计数：1引用计数：3引用计数：2 &lt;NSObject：0x60400001ecd0&gt;引用计数：1 &lt;NSObject：0x60400001ecd0&gt;*** -[NSObject retainCount]: message sent to deallocated instance 0x60400001ecd0 根据 Debug 输出可以看到：obj1 可以调用多次 release 方法。 从两次打印 obj1 的地址相同可以猜测，在 [obj1 release] 执行之后对象的引用计数 -1，不再强引用对象，但 obj1 仍然指向对象所在的那片内存空间。在第三次执行 release 后，对象的引用计数为 0，对象所在的内存空间被销毁，但是 obj1 指针仍然存在，此时调用 retainCount 会报野指针错误。可以通过置 obj1 = nil 解决这个问题。 对 Linux 文件系统比较了解的可能发现，引用计数的这种管理方式类似于文件系统里面的硬链接。在 Linux 文件系统中，我们用 ln 命令可以创建一个硬链接（相当于 retain），当删除一个文件时（相当于 release），系统调用会检查文件的 link count 值，如果大于 1，则不会回收文件所占用的磁盘区域。直到最后一次删除前，系统发现 link count 值为 1，则系统才会执行直正的删除操作，把文件所占用的磁盘区域标记成未用。 四、僵尸对象、野指针、空指针僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用。 野指针：指向僵尸对象（不可用内存）的指针，给野指针发送消息会报错（EXC\\_BAD\\_ACCESS）。 空指针：没有指向任何对象的指针（存储的是 nil、NULL），给空指针发送消息不会报错；空指针的一个经典使用场景就是在开发中获取服务器 API 数据时，转换野指针为空指针，避免发送消息报错。 五、为什么需要引用计数？引用计数真正派上用场的场景是在面向对象的程序设计架构中，用于对象之间传递和共享数据。 举个例子： 对象 A 生成了一个对象 O，需要调用对象 B 的某个方法，并将对象 O 作为参数传递过去。 [objB doSomething:O]; 在没有引用计数的情况下，一般内存管理的原则是「谁申请谁释放」。 那么对象 A 就需要在对象 B 不再需要 O 的时候，将 O 销毁。但对象 B 可能临时用一下 O，也可能将它设置为自己的一个成员变量，在这种情况下，什么时候销毁就成了一个难题了。 对于以上情况有两种做法： ①、对象 A 在调用完对象 B 的某个方法之后，马上销毁参数 O；然后对象 B 需要将对象 O 复制一份，生成另一个对象 O2，同时自己来管理对象 O2 的生命周期。 这种做法带来更多的内存申请、复制、释放的工作。本来可以复用的对象，因为不方便管理它的生命周期，就简单地把它销毁，又重新构造一份一样的，实在太影响性能。 ②、对象 A 只负责生成 O，之后就由对象 B 负责完成 O 的销毁工作。如果对象 B 只是临时用一下 O，就可以用完后马上销毁；如果对象 B 需要长时间使用 O，就不销毁它。 这种做法看似解决了对象复制的问题，但是它强烈依赖于 A 和 B 两个对象的配合，代码维护者需要明确地记住这种编程约定。而且，由于 O 的生成和释放在不同对象中，使得它的内存管理代码分散在不同对象中，管理起来也很费劲。如果这个时候情况更加复杂一些，例如对象 B 需要再向对象 C 传递参数 O，那么这个对象在对象 C 中又不能让对象 C 管理。所以这种方法带来的复杂度更高，更加不可取。 引用计数的出现很好地解决这个问题，在参数 O 的传递过程中，哪些对象需要长时间使用它，就把它的引用计数 +1，使用完就 -1。所有对象遵守这个规则，对象的生命周期管理就可以完全交给引用计数了。我们也可以很方便地享受到共享对象带来的好处。 六、ARC 下的内存管理问题问题主要体现在： 过度使用 block 之后，无法解决循环引用问题。 遇到底层 Core Foundation 对象，需要手工管理它们的引用计数时，显得一筹莫展。 1、循环引用 引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁又依赖于对象 A 的销毁，这样就造成了循环引用 Reference Cycle 的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 不止两对象存在循环引用问题，多个对象依次持有对方，形式一个环状，也可以造成循环引用问题，而且在真实编程环境中，环越大就越难被发现。下图是 4 个对象形成的循环引用问题。 2、主动断开循环引用 解决循环引用问题主要有两个办法。第一个办法：明确知道这里会存在循环引用，在合理的位置主动断开环中的一个引用，使得对象得以回收。如下图所示： 主动断开循环引用这种方式常见于各种与 block 相关的代码逻辑中。 不过，主动断开循环引用这种操作依赖于程序员自己手工显式地控制，相当于回到了以前 “谁申请谁释放” 的内存管理年代，它依赖于程序员自己有能力发现循环引用并且知道在什么时机断开循环引用回收内存，所以这种解决方法并不常用，更常见的办法是使用弱引用的办法。 3、使用弱引用 弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。在 iOS 开发中，弱引用通常在 delegate 模式中使用。如下所示： 4、弱引用的实现原理 弱引用的实现原理是这样，系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 从这个原理中，我们可以看出，弱引用的使用是有额外的开销的。虽然这个开销很小，但是如果一个地方我们肯定它不需要弱引用的特性，就不应该盲目使用弱引用。举个例子，有人喜欢在手写界面的时候，将所有界面元素都设置成 weak 的，这某种程度上与 Xcode 通过 Storyboard 拖拽生成的新变量是一致的。但是我个人认为这样做并不太合适。因为： ①、在创建这个对象时，需要注意临时使用一个强引用持有它，否则因为 weak 变量并不持有对象，就会造成一个对象刚被创建就销毁掉。 ②、大部分 ViewController 的视图对象的生命周期与 ViewController 本身是一致的，没有必要额外做这个事情。 ③、早先苹果这么设计，是有历史原因的。在早年，当时系统收到 Memory Warning 的时候，ViewController 的 View 会被 unLoad 掉。这个时候，使用 weak 的视图变量是有用的，可以保持这些内存被回收。但是这个设计已经被废弃了，替代方案是将相关视图的 CALayer 对应的 CABackingStore 类型的内存区会被标记成 volatile 类型，详见《再见，viewDidUnload方法》。 5、检测循环引用 七、学习文章iOS 内存管理 iOS 的内存管理","tags":[]},{"title":" weak\t\t","date":"2018-11-26T07:00:50.000Z","path":"2018/11/26/weak-1/","text":"一、基本用法weak 是弱引用。用 weak 修饰或者所引用对象的计数不会 +1，并且会在引用的对象被释放的时候自动被设置为 nil，大大避免了野指针访问坏内存引起崩溃的情况，另外 weak 还可以用于解决循环引用。 二、原理概括weak 表其实是一个 hash（哈希）表。key:所引用对象的地址，value:weak 指针的地址数组（这个地址的值是指向对象的指针的地址）。 weak 的底层实现的原理是什么？ runtime 维护了一个 weak 表，用于存储指向某个对象的所有 weak 指针。weak 表是由单个自旋锁管理的散列表。 为什么 value 是数组？ 因为一个对象可能被多个弱引用指针指向。 三、实现步骤weak 的实现原理可概括三步： ①、初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。 ②、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 ③、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 四、详细过程1、初始化时：runtime 会调用 objc_initWeak 函数，objc_initWeak 函数会初始化一个新的 weak 指针指向对象的地址。 NSObject * obj = [[NSObject alloc] init]; id __weak obj1 = obj; 当初始化一个 weak 变量时，runtime 会调用 NSObject.mm 中的 objc_initWeak 函数。 这个函数在 Clang 中的声明如下： id objc_initWeak(id *object, id value); 而对于 objc_initWeak() 方法的实现如下： id objc_initWeak(id location, id newObj){ // 查看对象实例是否有效，无效对象直接导致指针释放 if (!newObj) { location = nil; return nil; } // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/\\*old\\*/, true/\\*new\\*/, true/\\*crash\\*/&gt;(location, (objc_object*)newObj); } 这里先判断了其指针指向的类对象是否有效，无效直接释放返回，不再往深层调用函数。否则 object 将被注册为一个指向 value 的 __weak 对象，而这事应该是 objc_storeWeak 函数干的。可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断）。 注意：objc_initWeak 函数有一个前提条件：就是 object 必须是一个没有被注册为 __weak 对象的有效指针。而 value 则可以是 null，或者指向一个有效的对象。 2、添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 objc_storeWeak() 的函数声明如下： id objc_storeWeak(id *location, id value); objc_storeWeak() 的具体实现如下，请参考 weak弱引用实现的方式。 // HaveOld: true - 变量有值// false - 需要被及时清理，当前值可能为 nil// HaveNew: true - 需要被分配的新值，当前值可能为 nil// false - 不需要分配新值// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停// false - 用 nil 替代存储template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt; static id storeWeak(id *location, objc_object *newObj) { // 该过程用来更新弱引用指针的指向 // 初始化 previouslyInitializedClass 指针 Class previouslyInitializedClass = nil; id oldObj; // 声明两个 SideTable // ①、创建新旧散列 SideTable oldTable; SideTable newTable; // 获得新值和旧值的锁存位置（用地址作为唯一标示） // 通过地址来建立索引标志，防止桶重复 // 下面指向的操作会改变旧值retry: if (HaveOld) { // 如果 HaveOld 为 true，更改指针，获得以 oldObj 为索引所存储的值地址 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; } else { oldTable = nil; } if (HaveNew) { // 更改新值指针，获得以 newObj 为索引所存储的值地址 newTable = &amp;SideTables()\\[newObj\\]; } else { newTable = nil; } // 加锁操作，防止多线程中竞争冲突 SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 避免线程冲突重处理 // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (HaveOld &amp;&amp; *location != oldObj) { SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); goto retry; } // 防止弱引用间死锁 // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向 if (HaveNew &amp;&amp; newObj) { // 获得新对象的 isa 指针 Class cls = newObj-&gt;getIsa(); // 判断 isa 非空且已经初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) { // 解锁 SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 对其 isa 指针进行初始化 \\_class\\_initialize(\\_class\\_getNonMetaClass(cls, (id)newObj)); // 如果该类已经完成执行 +initialize 方法是最理想情况 // 如果该类 +initialize 在线程中 // 例如 +initialize 正在调用 storeWeak 方法 // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; // 重新尝试 goto retry; } } // ② 清除旧值 if (HaveOld) { weak\\_unregister\\_no\\_lock(&amp;oldTable-&gt;weak\\_table, oldObj, location); } // ③ 分配新值 if (HaveNew) { newObj = (objc\\_object *)weak\\_register\\_no\\_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // 如果弱引用被释放 weak\\_register\\_no_lock 方法返回 nil // 在引用计数表中设置若引用标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { // 弱引用位初始化操作 // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用 newObj-&gt;setWeaklyReferenced_nolock(); } // 之前不要设置 location 对象，这里需要更改指针指向 *location = (id)newObj; } else { // 没有新值，则无需更改 } SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj; } 撇开源码中各种锁操作，来看看这段代码都做了些什么。 ①、SideTable SideTable 这个结构体，我给它起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。使用 spinlock_lock 自旋锁来防止操作表结构时可能的竞态条件。它用一个 64*128 大小的 uint8_t 静态数组作为 buffer 来保存所有的 SideTable。实例在 NSObject.mm 中声明其数据结构： struct SideTable { // 保证原子操作的自旋锁 spinlock_t slock; // 引用计数的 hash 表 RefcountMap refcnts; // weak 引用全局 hash 表 weak_table_t weak_table;} slock 是为了防止竞争选择的自旋锁，用来保证线程安全； refcnts 是协助对象的 isa 指针的 extra_rc 共同引用计数的变量，每个对象的引用计数保存在全局的引用计数表中，一个对象地址对应一个引用计数； weak_table 就是接下来要讲的 weak 表，所有的 weak 变量会被加入到全局的 weak 表中，表的 key 是 weak 修饰的变量指向的对象， value 值就是 weak 修饰的变量。这里主要看 weak 全局 hash 表的结构与作用。 ②、weak 表 weak 表是一个弱引用表，实现为一个 weak_table_t 结构体，存储了某个对象相关的所有的弱引用信息。其定义如下（具体定义在 objc-weak.h中）： struct weak_table_t { // 保存了所有指向指定对象的 weak 指针 weak_entry_t * weak_entries; // 存储空间，即 entries 的数目 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;}; 这是一个全局弱引用 hash 表，它的作用就是在对象执行 dealloc 的时候将所有指向该对象的 weak 指针的值设为 nil，避免悬空指针。使用不定类型对象的地址的 hash 化后的数值作为 key，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。 weak_entry_t 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下： typedef objc_object ** weak_referrer_t;// 存储在弱引用表中的一个内部结构体struct weak_entry_t { DisguisedPtr&lt;objc\\_object&gt; referent; // 封装 objc\\_object 指针，即 weak 修饰的变量指向的对象 union { struct { weak\\_referrer\\_t *referrers; uintptr\\_t out\\_of\\_line : 1; // LSB 最低有效元。当标志位为0时，增加引用表指针纬度，当其为0的时候， weak\\_referrer_t 成员将扩展为静态数组型的 hash table uintptr\\_t num\\_refs : PTR\\_MINUS\\_1; // 引用数值，这里记录弱引用表中引用有效数字，即里面元素的数量 uintptr_t mask; uintptr\\_t max\\_hash_displacement; // hash 元素上限阀值 }; struct { // out\\_of\\_line=0 is LSB of one of these (don&apos;t care which) weak\\_referrer\\_t inline\\_referrers\\[WEAK\\_INLINE_COUNT\\]; }; } } 在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题，其内容可以理解为对象的内存地址。 从注释中写 out_of_line 成员为最低有效位，当其为 0 的时候， weak_referrer_t 成员将扩展为一个静态数组型的 hash table。其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。 那么在有效位未生效的时候，out_of_line、num_refs、mask、max_hash_displacement 有什么作用？以下是笔者自身的猜测： out_of_line：最低有效位，也是标志位。当标志位 0 时，增加引用表指针纬度。 num_refs：引用数值。这里记录弱引用表中引用有效数字，因为弱引用表使用的是静态 hash 结构，所以需要使用变量来记录数目。 mask：计数辅助量。 max_hash_displacement：hash 元素上限阀值。 其实 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT。 每个对象的 SideTable 中的 weak_table_t 都是全局 weak 表的入口，以引用计数对象为键找到其所记录的 weak 修饰的对象。 weak_entry_t 中的 referrers 有两种形式：当 out_of_line 为 0 的时候，referrers 是一个静态数组型的表，数组大小默认为 WEAK_INLINE_COUNT 大小；当 out_of_line 不为 0 的时候，referrers 是一个动态数组，内容随之增加。 StripedMap[] 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。 ③、旧对象解除注册操作 weak_unregister_no_lock void weak_unregister_no_lock(weak_table_t weak_table, id referent_id, id referrer_id){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak\\_entry\\_t *entry; if (!referent) return; if ((entry = weak\\_entry\\_for\\_referent(weak\\_table, referent))) { remove_referrer(entry, referrer); bool empty = true; if (entry-&gt;out\\_of\\_line &amp;&amp; entry-&gt;num_refs != 0) { empty = false; } else { for (size\\_t i = 0; i &lt; WEAK\\_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers\\[i\\]) { empty = false; break; } } } if (empty) { weak\\_entry\\_remove(weak_table, entry); } } // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change. } 该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。 来看看这个函数的逻辑： 首先参数是 weak_table_t 表、键和值。声明 weak_entry_t 变量，如果 key，也就是引用计数对象为空，直接返回。根据全局入口表和键获取对应的 weak_entry_t 对象，也就是 weak 表记录。获取到记录后，将记录表以及 weak 对象作为参数传入 remove_referrer 函数中，这个函数就是解除操作。然后判断这个 weak 记录是否为空，如果为空，从全局记录表中清除相应的引用计数对象的 weak 记录表。 从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。 再来了解一下解除对象的函数： static void remove_referrer(weak_entry_t *entry, objc_object **old_referrer){ if (! entry-&gt;out_of_line) { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == old_referrer) { entry-&gt;inline_referrers[i] = nil; return; } } _objc_inform(“Attempted to unregister unknown __weak variable “ “at %p. This is probably incorrect use of “ “objc_storeWeak() and objc_loadWeak(). “ “Break on objc_weak_error to debug.\\n”, old_referrer); objc_weak_error(); return; } size\\_t index = w\\_hash\\_pointer(old\\_referrer) &amp; (entry-&gt;mask); size\\_t hash\\_displacement = 0; while (entry-&gt;referrers\\[index\\] != old_referrer) { index = (index+1) &amp; entry-&gt;mask; hash_displacement++; if (hash\\_displacement &gt; entry-&gt;max\\_hash_displacement) { \\_objc\\_inform(&quot;Attempted to unregister unknown __weak variable &quot; &quot;at %p. This is probably incorrect use of &quot; &quot;objc\\_storeWeak() and objc\\_loadWeak(). &quot; &quot;Break on objc\\_weak\\_error to debug.\\\\n&quot;, old_referrer); objc\\_weak\\_error(); return; } } entry-&gt;referrers\\[index\\] = nil; entry-&gt;num_refs--; } 这个函数传入的是 weak 对象，当 out_of_line 为 0 时，遍历数组，找到对应的对象，置 nil，如果未找到，报错并返回。当 out_of_line 不为 0 时，根据对象的地址 hash 化并和 mask 做与操作作为下标，查找相应的对象，若没有，报错并返回，若有，相应的置为 nil，并减少元素数量，即 num_refs 减 1。 ④、新对象添加注册操作 weak_register_no_lock id weak_register_no_lock(weak_table_t weak_table, id referent_id, id referrer_id, bool crashIfDeallocating){ objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) { deallocating = referent-&gt;rootIsDeallocating(); } else { BOOL (\\*allowsWeakReference)(objc_object \\*, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == \\_objc\\_msgForward) { return nil; } deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); } if (deallocating) { if (crashIfDeallocating) { \\_objc\\_fatal(&quot;Cannot form weak reference to instance (%p) of &quot; &quot;class %s. It is possible that this object was &quot; &quot;over-released, or is in the process of deallocation.&quot;, (void*)referent, object_getClassName((id)referent)); } else { return nil; } } // now remember it and where it is being stored weak\\_entry\\_t *entry; if ((entry = weak\\_entry\\_for\\_referent(weak\\_table, referent))) { append_referrer(entry, referrer); } else { weak\\_entry\\_t new_entry; new_entry.referent = referent; new\\_entry.out\\_of_line = 0; new\\_entry.inline\\_referrers\\[0\\] = referrer; for (size\\_t i = 1; i &lt; WEAK\\_INLINE_COUNT; i++) { new\\_entry.inline\\_referrers\\[i\\] = nil; } weak\\_grow\\_maybe(weak_table); weak\\_entry\\_insert(weak\\_table, &amp;new\\_entry); } // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id; } 这一步与上一步相反，通过 weak_register_no_lock 函数把新的对象进行注册操作，完成与对应的弱引用表进行绑定操作。 一大堆 if-else 主要是为了判断该对象是不是 taggedPoint 以及是否正在调用 dealloc 等。下面操作开始，同样是先获取 weak 表记录，如果获取到，则调用 append_referrer 插入对象，若没有，则新建一个 weak 表记录，默认为 out_of_line，然后将新对象放到 0 下标位置，其他位置置为 nil 。下面两个函数 weak_grow_maybe 是用来判断是否需要重申请内存重 hash，weak_entry_insert 函数是用来将新建的 weak 表记录插入到全局 weak 表中。插入时同样是以对象地址的 hash 化和 mask 值相与作为下标来记录的。 接下来看看 append_referrer 函数，源代码如下： static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ if (! entry-&gt;out_of_line) { // Try to insert inline. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } // Couldn&apos;t insert inline. Allocate out of line. weak\\_referrer\\_t \\*new\\_referrers = (weak\\_referrer_t \\*) calloc(WEAK\\_INLINE\\_COUNT, sizeof(weak\\_referrer\\_t)); // This constructed table is invalid, but grow\\_refs\\_and_insert // will fix it and rehash it. for (size\\_t i = 0; i &lt; WEAK\\_INLINE_COUNT; i++) { new\\_referrers\\[i\\] = entry-&gt;inline\\_referrers\\[i\\]; } entry-&gt;referrers = new_referrers; entry-&gt;num\\_refs = WEAK\\_INLINE_COUNT; entry-&gt;out\\_of\\_line = 1; entry-&gt;mask = WEAK\\_INLINE\\_COUNT-1; entry-&gt;max\\_hash\\_displacement = 0; } assert(entry-&gt;out\\_of\\_line); if (entry-&gt;num\\_refs &gt;= TABLE\\_SIZE(entry) * 3/4) { return grow\\_refs\\_and\\_insert(entry, new\\_referrer); } size\\_t index = w\\_hash\\_pointer(new\\_referrer) &amp; (entry-&gt;mask); size\\_t hash\\_displacement = 0; while (entry-&gt;referrers\\[index\\] != NULL) { index = (index+1) &amp; entry-&gt;mask; hash_displacement++; } if (hash\\_displacement &gt; entry-&gt;max\\_hash_displacement) { entry-&gt;max\\_hash\\_displacement = hash_displacement; } weak\\_referrer\\_t &amp;ref = entry-&gt;referrers\\[index\\]; ref = new_referrer; entry-&gt;num_refs++; } ⑤、初始化弱引用对象流程一览 弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图： 这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然，storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。 3、释放时，调用 clearDeallocating 函数。clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。 当 weak 引用指向的对象被释放时，又是如何去处理 weak 指针的呢？当释放对象时，其基本流程如下： ①、调用 objc_release②、因为对象的引用计数为 0，所以执行 dealloc③、在 dealloc 中，调用了_objc_rootDealloc 函数④、在 _objc_rootDealloc 中，调用了 object_dispose 函数⑤、调用 objc_destructInstance⑥、最后调用 objc_clear_deallocating，详细过程如下： a. 从 weak 表中获取废弃对象的地址为键值的记录b. 将包含在记录中的所有附有 weak 修饰符变量的地址，赋值为 nilc. 将 weak 表中该记录删除d. 从引用计数表中删除废弃对象的地址为键值的记录 重点看对象被释放时调用的 objc_clear_deallocating 函数。该函数实现如下： void objc_clear_deallocating(id obj){ assert(obj); assert(!UseGC); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating(); } 这个函数只是做一些判断以及更深层次的函数调用。 void objc_object::sidetable_clearDeallocating(){ SideTable&amp; table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); // 迭代器 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) { if (it-&gt;second &amp; SIDE\\_TABLE\\_WEAKLY_REFERENCED) { weak\\_clear\\_no\\_lock(&amp;table.weak\\_table, (id)this); } table.refcnts.erase(it); } table.unlock(); } 也就是调用了 clearDeallocating()，继续追踪可以发现，它最终是使用了迭代器来取 weak 表的 value，然后调用 weak_clear_no_lock，然后查找对应的 value，将该 weak 指针置空，weak_clear_no_lock 函数的实现如下： /** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used. * * @param weak_table * @param referent The object being deallocated. /void weak_clear_no_lock(weak_table_t weak_table, id referent_id){ objc_object *referent = (objc_object *)referent_id; weak\\_entry\\_t *entry = weak\\_entry\\_for\\_referent(weak\\_table, referent); if (entry == nil) { /// XXX shouldn&apos;t happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\\\n&quot;, referent); return; } // zero out references weak\\_referrer\\_t *referrers; size_t count; if (entry-&gt;out\\_of\\_line) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK\\_INLINE\\_COUNT; } for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers\\[i\\]; if (referrer) { if (*referrer == referent) { *referrer = nil; } else if (*referrer) { \\_objc\\_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc\\_storeWeak() and objc\\_loadWeak(). &quot; &quot;Break on objc\\_weak\\_error to debug.\\\\n&quot;, referrer, (void*)\\*referrer, (void\\*)referent); objc\\_weak\\_error(); } } } weak\\_entry\\_remove(weak_table, entry); } 简单来说，这个方法首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组，把每个地址存储的数据设为 nil ，最后把这个 key-value entry 从 weak 表中删除。 注意： ①、从实现中可以看出，weak 指针的使用涉及到 hash 表的增删改查，存在一定的性能开销。②、使用 weak 指针的时候，应首先获取一个 Strong 指针再使用。倒不是为了防止在使用过程中对象被回收，形成野指针。这个不用担心，因为你使用了 weak 指针，对象就会被加入到 autoreleasepool 中，可以放心使用。但是要注意的是，如果在一个代码块中频繁使用 weak 指针，还是应首先获取一个 Strong 指针，否则这个对象会被一次又一次的加入 autoreleasepool 中，也存在一定的性能开销。 五、拓展补充weak、__unsafe_unretained、unowned 与 assign 区别 __unsafe_unretained：不会对对象进行 retain，当对象销毁时，会依然指向之前的内存空间（野指针） weak：不会对对象进行 retain，当对象销毁时，会自动置为 nil __unsafe_unretained 可以修饰代表基础数据类型的 property，weak 不能修饰基础数据类型的 property。 使用 weak 是有代价的，因为通过上面的原理可知，weak 需要检查对象是否已经消亡，而为了知道是否已经消亡，自然也需要一些信息去跟踪对象的使用情况，因此 __unsafe_unretained 比 weak 快。所以当明确知道对象的生命期时，选择 __unsafe_unretained 会有一些性能提升，这种性能提升是很微小的。但当很清楚的情况下，__unsafe_unretained 也是安全的，自然能快一点是一点。而当情况不确定的时候，应该优先选用 __weak 。 unowned 使用在 Swift 中，也会分 weak 和 unowned。unowned 的含义跟 __unsafe_unretained 差不多。 假如很明确的知道对象的生命期，也可以选择 unowned。 assign：实质与 __unsafe_unretained 等同 通过上面的描述，我们基本能了解一个 weak 引用从生到死的过程。从这个流程可以看出，一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 weak 修饰符。 六、学习文章 weak 弱引用的实现方式iOS 底层解析weak的实现原理（包含weak对象的初始化，引用，释放的分析）iOS weak 的底层实现weak 的生命周期：具体实现方法 iOS 中 weak 的实现","tags":[]},{"title":" dispatch_once\t\t","date":"2018-11-21T15:49:14.000Z","path":"2018/11/21/dispatch-once/","text":"dispatch_once 在单例模式可以保证代码被执行一次。 + (MyObject )sharedInstance{ static MyObject instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[MyObject alloc] init]; }); return instance;} dispatch_once_t 在 usr/include/dispatch/once.h 文件中定义: /*! * @typedef dispatch_once_t * * @abstract * A predicate for use with dispatch_once(). It must be initialized to zero. * Note: static and global variables default to zero. */typedef long dispatch_once_t; dispatch_once 展开： #define dispatch_once _dispatch_once void _dispatch_once(dispatch_once_t predicate, DISPATCH_NOESCAPE dispatch_block_t block){ if (DISPATCH_EXPECT(predicate, ~0l) != ~0l) { dispatch_once(predicate, block); } else { dispatch_compiler_barrier(); } DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~0l);} ~0l 是 long 的 0 取反，结果是 一大堆 1。 再展开 DISPATCH_EXPECT #if __GNUC__ #define DISPATCH_EXPECT(x, v) __builtin_expect((x), (v)) #else #define DISPATCH_EXPECT(x, v) (x) #endif __builtin_expect 是 GCC(version &gt;= 2.9) 引进的宏，其作用就是帮助编译器判断条件跳转的预期值，避免跳转造成时间浪费。并没有改变其对真值的判断。 所以 dispatch_once 可以看成 + (MyObject )sharedInstance{ static MyObject instance; static long onceToken = 0; if (onceToken != 0){ 1… { instance = [[MyObject alloc] init]; } 2… } return format;} 我们可以猜测在下面的 2… 里的代码是修改了 onceToken 的值。 输出查看一下： + (MyObject )sharedInstance{ static MyObject instance; static dispatch_once_t onceToken; NSLog(@&quot;##111## %ld&quot;, onceToken); dispatch_once(&amp;onceToken, ^{ NSLog(@&quot;##222## %ld&quot;, onceToken); instance = \\[\\[MyObject alloc\\] init\\]; }); NSLog(@&quot;##333## %ld&quot;, onceToken); return instance; }2018-05-04 16:34:17.486360+0800 Demo[27355:1941829] ##111## 02018-05-04 16:34:17.486527+0800 Demo[27355:1941829] ##222## 7682018-05-04 16:34:17.486637+0800 Demo[27355:1941829] ##333## -12018-05-04 16:34:17.486730+0800 Demo[27355:1941829] ##111## -12018-05-04 16:34:17.486843+0800 Demo[27355:1941829] ##333## -1 发现在 1 里改变了一次，然后在 2 里改成了 -1。这样我们就不难理解 dispatch_once 的逻辑了。 dispatch_once 实现单例的优点： ①、线程安全 ②、很好满足静态分析器要求 ③、和自动引用计数（ARC）兼容 ④、仅需要少量代码 完整的单例模式代码。 #if __has_feature(objc_arc) static id _instace;+ (instancetype)sharedInstance{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instace = [[self alloc] init]; }); return _instace;} + (id)allocWithZone:(struct _NSZone *)zone{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instace = [super allocWithZone:zone]; }); return _instace;} - (id)copyWithZone:(NSZone *)zone{ return _instace;} #else static id _instace;+ (instancetype)sharedInstance{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instace = [[self alloc] init]; }); return _instace;} + (id)allocWithZone:(struct _NSZone *)zone{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ _instace = [super allocWithZone:zone]; }); return _instace;} - (id)copyWithZone:(NSZone *)zone{ return _instace;} - (oneway void)release { }- (id)retain { return self; }- (NSUInteger)retainCount { return 1;}- (id)autorelease { return self;} #endif","tags":[]},{"title":" String\t\t","date":"2018-11-21T14:39:08.000Z","path":"2018/11/21/string-0/","text":"@property (nonatomic, copy) NSString string1;@property (nonatomic, weak) NSString string2; { NSString * temp = @”AAAA”; self.s1 = temp; NSLog(@&quot;temp -&gt; %p&quot;, temp); self.s2 = self.s1; self.s1 = nil; NSLog(@&quot;s1 = %@，s2 = %@&quot;, self.s1, self.s2); NSLog(@&quot;s1 -&gt; %p，s2 -&gt; %p&quot;, self.s1, self.s2); NSLog(@&quot;retainCount = %@&quot;, \\[temp valueForKey:@&quot;retainCount&quot;\\]); } temp -&gt; 0x108551118s1 = (null)，s2 = AAAAs1 -&gt; 0x0，s2 -&gt; 0x108551118retainCount = 18446744073709551615 一、代码解释1、temp 字符串常量是由系统创建管理的，通常情况下存放在内存的常量区。不管有多少对象引用，它本身都不受程序的影响，直到程序结束，由系统进行回收。 即使 s1 设置为 nil， temp 本身只要没有出这个程序，或者函数，都不会被释放，所以 s2 仍然有值。 另外 s2 = s1 并不是把 s2 指向了 s1，而是 s2 指向了 s1 的值。要想 s2 指向 s1 差不多是下边这个样子： NSString ** s2 = s1; // 需要关闭 arc 才能使用二级指针 这样 s1 = nil 后 s2 也是 nil 了。 2、@”AAAA” 是个字符串常量，既然是个常量，这块内存不可修改，不可修改就谈不上所谓的释放不释放。 self.s1 = nil; 本意是将 @”AAAA” 置为 nil，但由于没办法修改字符串常量，那么指针只能指向 nil 地址，对原来地址所存内容无修改。 字符串在 c 系语言里面是个很特殊的存在，特殊到什么程度呢，它在编译阶段就已经确定了，所以运行时是没办法修改的。 致于为什么搞成这样，我觉得是因为 c 语言里面没有专门用来存储字符串变量的类型，不过可以退而求其次的使用数组，比如：char a[10] = “abcd” 来保存，但是这种写法既浪费空间效率又低。 { NSString temp1 = [[NSString alloc] initWithFormat:@”%@”, @”AAAAAAA”]; NSString temp2 = [[NSString alloc] initWithFormat:@”%@”, @”AAAAAAA”]; NSString temp3 = [[NSString alloc] initWithFormat:@”%@”, @”BBBBBBBBBBBB”]; NSString temp4 = [[NSString alloc] initWithFormat:@”%@”, @”BBBBBBBBBBBB”]; NSLog(@&quot;%p %p&quot;, temp1, temp2); NSLog(@&quot;%p %p&quot;, temp3, temp4); } 0xa414141414141417 0xa4141414141414170x60000022a3a0 0x60000022a260 通过 [[NSString alloc] initWithFormat:@””] 创建的 NSString 对象存储在内存中的堆区： 如果字符串长度在 10 以下，那么如果字符串内容一致，内存中只会有一份；如果字符串长度在 10 以上，那么就算字符串内容一致，内存中也会有多份。 二、学习文章问一个非常基础的 strong weak问题。。 ShenYj、字符串为什么用copy修饰","tags":[]},{"title":" clang -rewrite-objc\t\t","date":"2018-11-21T07:10:54.000Z","path":"2018/11/21/clang-rewrite-objc/","text":"clang -rewrite-objc 是把 oc 代码转成 c/c++ 代码，常用它来窥探 OC 的底层实现。 /* MyObject.m */ #import “MyObject.h” @implementation MyObject @end 打开终端 cd 到 MyObject.m 所在目录，执行如下命令： $ cd Desktop/Demo/Demo$ clang -rewrite-objc MyObject.m 执行之后，目录下多出一个名为 MyObject.cpp 的 C++ 语言文件，可以打开看具体实现。 1、指定 SDK 有的 oc 代码在转成 c 代码时，在真机和模拟器上差别还是挺大的。如果需要指定 SDK，那么要结合 xcrun 命令。 // 查看机器上装有的的 sdk~ $ xcodebuild -showsdks // 真机xcrun -sdk iphoneos clang -rewrite-objc main.m // 模拟器xcrun -sdk iphonesimulator clang -rewrite-objc main.m // 指定 SDK 版本xcrun -sdk iphonesimulator11.2 clang -rewrite-objc main.m 2、指定 framework /* MyObject.m */ #import “MyObject.h” #import &lt;UIKit/UIKit.h&gt; @implementation MyObject @end .m 文件中引入了 UIKit.framework，运行 clang -rewrite-objc。 忘了引入 UIKit.framework，clang 不知到何处去找，这时需要用 -F 开关告诉它 xcrun -sdk iphonesimulator clang -rewrite-objc -F /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/UIKit.framework MyObject.m 执行命令后成功了。实际上可以同时指定多个源文件、多个 framework。 3、.h 文件 .h 文件执行 clang 转换后生成一个 .gch 的文件。 /* MyObject.h */ #import &lt;Foundation/Foundation.h&gt; @interface MyObject : NSObject{ int val0; int val1;}@end 报错是因为没有使用 iphoneOS.sdk。","tags":[]},{"title":" JSON\t\t","date":"2018-11-19T14:48:37.000Z","path":"2018/11/19/json/","text":"1、什么是 JSon ？ JSon 是一种与开发语言无关的、轻量级的数据格式。全称 JavaScript Object Notation。 优点：易于人的阅读和编写，易于程序解析与生产。简单 2、标准的 JSon 数据表示 数据结构：Object、Array 基本类型：string、number、true、false、null Object：使用花括号{}包含的键值对结构。Key 必须是 string类型，value 为任何基础类型或数据结构。 Array：使用中括号[]来起始，并用逗号来分隔元素。 Json 是 Android SDK 官方库 Gson 服务端、后台应用。比 Json 更强大 3、Json 库 功能：映射 Java Object 与 json 格式数据 ①、通过 Annotation 注解来声明 ②、支持自定义属性名称 ③、支持包含或排除属性 &lt; p style=”padding-left: 60px;”&gt;④、支持自定义接口自己完成解析/生成过程","tags":[]},{"title":" Git 撤销更改\t\t","date":"2018-11-19T08:04:48.000Z","path":"2018/11/19/git-e6-92-a4-e9-94-80-e6-9b-b4-e6-94-b9/","text":"下面所有讨论都假设只使用一个分支，也就是主分支 master。 一、基本概念1、3 个步骤 正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线： git add . // 把所有文件放入暂存区git commit -m “备注” // 把所有文件从暂存区提交进本地仓库git push // 把所有文件从本地仓库推送进远程仓库 2、4 个区 git 之所以令人费解，主要是它相比于 svn 等传统的版本管理工具，多引入了一个暂存区 (Stage) 的概念： 工作区 Working Area 暂存区 Stage 本地仓库 Local Repository 远程仓库 Remote Repository 3、5 种状态 以上 4 个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是 5 种状态： 未修改 Origin 已修改 Modified 已暂存 Staged 已提交 Committed 已推送 Pushed 二、检查修改首先，要了解这 3 个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是 diff，只是参数有所不同。 1、本地已修改，未暂存 git diff 首先只是简单地在浏览器里保存了一下文件，还没有做 git add .，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验： 在文件中胡乱加了 4 个数字 1234，存盘，这时本地文件进入了已修改状态，但是还没有进入暂存区，我们运行 git diff，结果如下： git diff 的结果告诉我们哪些文件已经做了哪些修改。 2、已暂存，未提交 git diff –cached 把修改放入暂存区看一下：先执行 git add .，然后执行git diff，你会发现没有任何结果： 这说明 git diff 这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数 –cached： 这时候我们看到的差异是暂存区和本地仓库之间的差异。 3、已提交，未推送 git diff master 把修改从暂存区提交到本地仓库，再看一下差异。先执行 git commit，然后再执行 git diff –cached： 没有差异，执行 git diff master，可以看到差异： 在这里，master 就是你的本地仓库，而 origin/master 就是你的远程仓库。master 是主分支的意思，因为我们都在主分支上工作，所以这里两边都是 master，而 origin 就代表远程。 三、撤销修改1、已修改，未暂存 如果我们只是在编辑器里修改了文件，但还没有执行 git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用： git checkout . 或者 git reset –hard 来进行撤销操作。 可以看到，在执行完 git checkout . 之后，修改已被撤销，git diff没有任何内容了。 git add . 的反义词是 git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行 git checkout .。 2、已暂存，未提交 已经执行 git add .，但还没有执行 git commit -m “comment”。 git reset // 退回到 git add . 之前，即本地文件处于已修改未暂存状态 git checkout . // 撤销修改 或者 git reset –hard 可以发现 1、2 两种情况都可以用同一个命令 git reset –hard 来完成。这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。 3、已提交，未推送 执行 git commit 后，代码已经进入了本地仓库 git reset –hard origin/master 还是这个 git reset –hard 命令，只不过这次多了一个参数 origin/master，正如我们上面讲过的，origin/master 代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。 4、已推送 如果执行了 git add -&gt; git commit -&gt; git push 了，这时你的代码已经进入远程仓库。如果想恢复的话，只需要先撤销本地修改，再强制 push 到远程仓库： git reset –hard HEAD^ git push -f 四、学习文章&lt; p class=”line” data-line=”143”&gt;算法爱好者 # Git 的 4 个阶段的撤销更改","tags":[]},{"title":" 队列\t\t","date":"2018-11-19T03:32:54.000Z","path":"2018/11/19/e9-98-9f-e5-88-97/","text":"一、简介队列是一种先进先出的线性表，只允许在表的一端进行插入，而在另一端删除元素。插入端叫队头，删除端叫队尾。 根据存储空间的分配方式可以分为 ①、用连续内存空间的数组实现的顺序队列 ②、用动态分配的堆空间实现的链队列 二、顺序队列 rear &gt; front /* 顺序队列结构。元素存放在连续的内存空间（系统数组）。 采用循环存储。当 rear 到达 MAXSIZE 时，对 MAXSIZE 取余并赋值给 rear rear = (rear + 1) % MAXSIZE； 保留一个空的内存，用于判断队列是否已满。 */typedef struct Queue{ int data[MAXSIZE]; int front; int rear; // 注意：rear &gt; front} Queue; /// 初始化队列void initQueue(Queue * queue){ queue-&gt;rear = queue-&gt;front = 0;} /// 空队列bool isEmptyQueue(Queue * queue){ return (queue-&gt;rear == queue-&gt;front);} /// 满队列bool isFullQueue(Queue * queue){ // 如果队尾”追上”队头，则已满 return (queue-&gt;rear + 1) % MAXSIZE == queue-&gt;front;} /// 入队bool inputQueue(Queue * queue, int data){ if (isFullQueue(queue)) { return NO; } queue-&gt;data\\[queue-&gt;rear\\] = data; // 队尾存入 queue-&gt;rear = (queue-&gt;rear + 1) % MAXSIZE; // 队尾对应的索引值增加 return YES; } /// 出队。由 data 返回删除的值bool outputQueue(Queue queue, int data){ if (isEmptyQueue(queue)) return NO; *data = queue-&gt;data\\[queue-&gt;front\\]; // 取出队头的值 queue-&gt;front = (queue-&gt;front + 1) % MAXSIZE; return YES; } /// 打印队列的内容void printQueue(Queue * queue){ if (isEmptyQueue(queue)) return; int i = queue-&gt;front; while (i != queue-&gt;rear) { printf(&quot;%d\\\\t&quot;, queue-&gt;data\\[i\\]); i = (i + 1) % MAXSIZE; } printf(&quot;\\\\r\\\\n&quot;); } /// 调用{ int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int i = 0; int data = 0; Queue queue = { 0 }; initQueue(&amp;queue); for (i = 0; i &lt; sizeof(array)/sizeof(int); i++) { inputQueue(&amp;queue, array\\[i\\]); } printQueue(&amp;queue); outputQueue(&amp;queue, &amp;data); printf(&quot;%d\\\\n&quot;, data); outputQueue(&amp;queue, &amp;data); printf(&quot;%d\\\\n&quot;, data); printQueue(&amp;queue); inputQueue(&amp;queue, 11); inputQueue(&amp;queue, 12); printQueue(&amp;queue); } 1 2 3 4 5 6 7 8 9123 4 5 6 7 8 93 4 5 6 7 8 9 11 12 三、链队列 /* 链队列结构。元素存放在动态分配的堆上，非连续的内存空间。 采用线性存储。队列不会满。 /typedef struct Node{ int data; struct Node next;} Node; typedef struct Queue{ Node front; Node rear;} Queue; /// 初始化队列void initQueue(Queue queue){ queue-&gt;front = queue-&gt;rear = (Node )malloc(sizeof(Node));} /// 空队列bool isEmptyQueue(Queue * queue){ return (queue-&gt;rear == queue-&gt;front);} /// 入队void inputQueue(Queue queue, int data){ Node node = (Node *)malloc(sizeof(Node)); node-&gt;data = data; node-&gt;next = NULL; queue-&gt;rear-&gt;next = node; // 将上一个节点的 next 指向 node queue-&gt;rear = node; // 移动 rear 的位置 } /// 出队。若队列不空，由 data 返回删除的值bool outputQueue(Queue queue, int data){ if (isEmptyQueue(queue)) return NO; Node * firstNode = queue-&gt;front-&gt;next; // 指向第一个结点 *data = firstNode-&gt;data; queue-&gt;front-&gt;next = firstNode-&gt;next; // 将头节点指向新的&quot;第一个结点&quot; if (queue-&gt;rear == firstNode) { // 删除的正好是队尾结点 queue-&gt;rear = queue-&gt;front; // 将 rear 指针指向头结点 } return YES; } /// 打印队列的内容void printQueue(Queue * queue){ if (isEmptyQueue(queue)) return; Node * node = queue-&gt;front-&gt;next; // 指向头结点 while (node) { printf(&quot;%d\\\\t&quot;, node-&gt;data); node = node-&gt;next; } printf(&quot;\\\\r\\\\n&quot;); }/// 调用{ int array[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int i = 0; int data = 0; Queue queue = { 0 }; initQueue(&amp;queue); for (i = 0; i &lt; sizeof(array)/sizeof(int); i++) { inputQueue(&amp;queue, array\\[i\\]); } printQueue(&amp;queue); outputQueue(&amp;queue, &amp;data); printf(&quot;%d\\\\n&quot;, data); outputQueue(&amp;queue, &amp;data); printf(&quot;%d\\\\n&quot;, data); printQueue(&amp;queue); inputQueue(&amp;queue, 11); inputQueue(&amp;queue, 12); printQueue(&amp;queue); } 1 2 3 4 5 6 7 8 9123 4 5 6 7 8 93 4 5 6 7 8 9 11 12 四、循环队列 循环链实现队列 循环队列与链队列的比较 ①、时间：循环队列和链队列的基本操作都是 O(1)。不过循环队列是事先已申请好空间，使用期间不会释放。而对于链队列，每次申请和释放结点也会存在一些时间开销。如果入队和出队频繁，链队列会耗费更多的时间。 ②、空间：循环队列必须有一个固定的长度，所以就会有存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但是是可以接受的。所以从空间上说，链队列更加灵活。 总的来说，在可以确定链队列最大长度的情况下，建议使用循环队列。如果无法预估队列的长度，则使用链队列。 五、队列实现栈","tags":[]},{"title":" 数据结构\t\t","date":"2018-11-19T02:52:07.000Z","path":"2018/11/19/e6-95-b0-e6-8d-ae-e7-bb-93-e6-9e-84/","text":"数据结构是计算机存储、组织数据的方式。 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。 数据结构包含： 数组 栈 队列 堆 链表 图 树 散列表 一、顺序表 顺序表是在计算机内存中以数组的形式保存的线性表，是指使用一组地址连续的存储单元依次存储数据元素的线性结构。 顺序表的存储结构表示： #define MAXSIZE 10 typedef struct { // 顺序表的结构类型 int data\\[MAXSIZE\\]; int length; } SqList; 优点：它具有随机存取的特点，能够快速查找。缺点：做插入或删除操作时，需要移动大量元素，效率较低。 学习文章&lt; p class=”line” data-line=”39”&gt; 静默虚空 # 算法和数据结构 天山老妖S # 算法和数据结构","tags":[]},{"title":" 浅拷贝、深拷贝\t\t","date":"2018-11-18T13:21:12.000Z","path":"2018/11/18/e6-b5-85-e6-8b-b7-e8-b4-9d-e3-80-81-e6-b7-b1-e6-8b-b7-e8-b4-9d/","text":"深拷贝和浅拷贝的本质区别是地址是否相同。 浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址； 深拷贝是真正的复制了一份，复制的对象指向了新的地址。 一、非容器类对象对象的 copy 是浅拷贝，mutableCopy 是深拷贝。 1、不可变 NSString s1 = @”AAA”;NSString s2 = [s1 copy];NSString * s3 = [s1 mutableCopy]; NSLog(@”%p %@”, s1, s1.class);NSLog(@”%p %@”, s2, s2.class);NSLog(@”%p %@”, s3, s3.class); 0x1083a40e8 NSCFConstantString0x1083a40e8 NSCFConstantString0x60400044f840 __NSCFString 结论： ①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝；②、浅拷贝返回不可变对象，深拷贝返回可变对象。 2、可变 NSMutableString ms1 = [NSMutableString stringWithString:@”1”];NSMutableString ms2 = [ms1 copy];NSString * ms3 = [ms1 mutableCopy]; NSLog(@”%p %@”, ms1, ms1.class);NSLog(@”%p %@”, ms2, ms2.class);NSLog(@”%p %@”, ms3, ms3.class); 0x6040004500b0 NSCFString0xa000000000000311 NSTaggedPointerString0x60400044fc60 NSCFString 结论： ①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝；②、copy 和 mutableCopy 返回对象都为可变对象。 二、容器对象1、不可变 NSMutableString * ms = [NSMutableString stringWithString:@”1”]; NSArray arr1 = [NSArray arrayWithObjects:ms, @”2”, nil];NSArray arr2 = [arr1 copy];NSArray * arr3 = [arr1 mutableCopy]; NSLog(@”%p %@ %p %@ %p %@”, arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);NSLog(@”%p %@ %p %@ %p %@”, arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);NSLog(@”%p %@ %p %@ %p %@”, arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]); 0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 NSCFConstantString0x600000037620 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 NSCFConstantString0x60000025a940 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝； ②、浅拷贝返回不可变对象，深拷贝返回可变对象。 ③、容器内的元素始终都是浅拷贝。 2、可变 NSMutableString * ms = [NSMutableString stringWithString:@”1”]; NSMutableArray mArr1 = [NSMutableArray arrayWithObjects:ms, @”2”, nil];NSMutableArray mArr2 = [mArr1 copy];NSMutableArray * mArr3 = [mArr1 mutableCopy]; NSLog(@”%p %@ %p %@ %p %@”, mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);NSLog(@”%p %@ %p %@ %p %@”, mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);NSLog(@”%p %@ %p %@ %p %@”, mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]); 0x60000025aeb0 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 NSCFConstantString0x600000037640 __NSArrayI 0x60000025ab80 __NSCFString 0x1032b2148 NSCFConstantString0x60000025ae80 __NSArrayM 0x60000025ab80 __NSCFString 0x1032b2148 __NSCFConstantString 结论： ①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；②、copy 返回不可变对象，mutableCopy 返回可变对象；③、容器内的元素始终是浅拷贝。 三、自定义类对象的深浅拷贝自定义的类需要遵循 才支持 copy，遵循 支持 mutableCopy。 @interface Person : NSObject &lt;NSCopying, NSMutableCopying&gt;@end@implementation Person - (instancetype)copyWithZone:(NSZone *)zone{ return [Person allocWithZone:zone]; // return self;} - (instancetype)mutableCopyWithZone:(NSZone *)zone{ return [Person allocWithZone:zone];} @end Person p1 = [[Person alloc] init];Person p2 = [p1 copy];Person * p3 = [p1 mutableCopy]; NSLog(@”%p %@”, p1, p1.class);NSLog(@”%p %@”, p2, p2.class);NSLog(@”%p %@”, p3, p3.class); 0x600000011e30 Person0x600000011f70 Person0x600000011f90 Person 四、实现容器对象的完全拷贝NSMutableString * ms = [NSMutableString stringWithFormat:@”1”]; NSArray * arr = [NSArray arrayWithObjects:ms, @”2”, nil];NSLog(@”%p %p”, arr[0], arr[1]); NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];NSLog(@”%p %p”, mArr[0], mArr[1]); NSData data = [NSKeyedArchiver archivedDataWithRootObject:mArr];NSMutableArray newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];NSLog(@”%p %p”, newMutableArr[0], newMutableArr[1]); 0x6040004434b0 0x109c931000xa000000000000311 0x109c931000xa000000000000311 0xa000000000000321 由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。 自定义类对象需要遵循 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。 - (instancetype)initWithCoder:(NSCoder *)aDecoder{ self.xxx = [aDecoder decodeObjectForKey:@”key”]; return self;} - (void)encodeWithCoder:(NSCoder *)aCoder{ [aCoder encodeObject:self.xxx forKey:@”key”];} 五、总结只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。 六、学习文章深刻理解iOS中的“深拷贝”和“浅拷贝”","tags":[]},{"title":" XML 解析\t\t","date":"2018-11-18T13:16:35.000Z","path":"2018/11/18/xml-e8-a7-a3-e6-9e-90/","text":"XML文件 Demo.xml 一、简介1、XML 优点 ①、格式统一，符合标准②、容易与其他系统进行远程交互，数据共享比较方便 2、XML 缺点 ①、XML 文件庞大，文件格式复杂，传输占带宽②、服务器端和客户端都需要花费大量代码来解析 XML，导致服务器端和客户端代码变得异常复杂且不易维护③、客户端不同浏览器之间解析 XML 的方式不一致，需要重复编写很多代码④、服务器端和客户端解析 XML 花费较多的资源和时间 3、解析方式 通常有 DOM 和 SAX 两种解析 XML 方式： DOM 解析 XML 时，读入整个 XML 文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意 XML 节点，读取它的属性和值。而且通常情况下，可以借助 XPath，直接查询 XML 节点。 SAX 解析 XML，是基于事件通知的模式，一边读取 XML 文档一边处理，不必等整个文档加载完之后才采取操作，当在读取解析过程中遇到需要处理的对象，会发出通知对其进行处理。 二、解析库1、NSXMLParser 使用 SAX 方式解析 XML 的类库，默认包含在 iOS SDK 中。 #pragma mark - SAX解析 /// SAX 逐行解析{ NSXMLParser * xmlParser = [[NSXMLParser alloc] initWithData:xmlData]; xmlParser.delegate = self; // 开始解析 \\[xmlParser parse\\]; } # pragma mark - Delegate/// 开始解析- (void)parserDidStartDocument:(NSXMLParser *)parser{ } /// 获取开始节点- (void)parser:(NSXMLParser )parser didStartElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName attributes:(NSDictionary )attributeDict{ NSLog(@”开始节点：%@”, elementName);}// 获取节点的值 (这个方法在 didStartElement: 和 didEndElement: 后会分别调用一次)- (void)parser:(NSXMLParser )parser foundCharacters:(NSString *)string{ NSLog(@”节点的值：%@”, string);} /// 获取结束节点- (void)parser:(NSXMLParser )parser didEndElement:(NSString )elementName namespaceURI:(NSString )namespaceURI qualifiedName:(NSString )qName{ NSLog(@”结束节点：%@”, elementName);} /// 解析结束- (void)parserDidEndDocument:(NSXMLParser *)parser{ NSLog(@”结束”);} 2、libxml2 默认包含在 iOS SDK 中的开源类库，它是基于 C 语言的 API，所以使用起来可能不如 NSXMLParser 方便。 它同时支持 DOM 和 SAX 解析。libxml2 的 SAX 解析方式还是非常酷的，因为它可以边读取边解析，尤其是在从网上下载一个很大的 XML 文件时，可以一边下载一边对已经下载好的内容进行解析，极大的提高解析效率。 3、TBXML ①、轻量级的 DOM 方式的 XML 解析类库②、有很好的性能和低内存占用，③、不对 XML 格式进行校验④、不支持 XPath⑤、并且只支持解析，不支持对 XML 进行修改。 4、TouchXML ①、DOM 方式的 XML 解析类库；②、支持 XPath；③、不支持 XML 的修改。 5、KissXML ①、基于 TouchXML 的 XML 解析类库②、支持 XML 的修改。 6、TinyXML ①、基于 C 语言的 DOM 方式解析的类库；②、支持对 XML 的读取和修改；③、不直接支持 XPath，需要借助另一个相关的类库 TinyXPath 才可以支持 XPath。 7、GDataXML ①、Google 开发的 DOM 方式解析类库②、支持读取和修改 XML 文档③、支持 XPath 方式查询。 /* 1、添加 libxml2.tbd 2、Header Search Paths 设置 /usr/include/libxml2 3、GDataXMLNode.m 设置 -fno-objc-arc/{ GDataXMLDocument xmlDocument = [[GDataXMLDocument alloc] initWithData:xmlData options:0 error:&amp;error]; // 获取根节点 GDataXMLElement * rootElement = \\[xmlDocument rootElement\\]; // 获取根节点下的所有子节点 NSArray * elementArray = rootElement.children; for (GDataXMLElement * element in elementArray) { } } 8、XMLReader ①、基于 NSXMLParser 的 SAX 方式解析类库 三、选择类库NSXML libxml2(SAX) TBXML TouchXML KissXML TinyXML GDataXML libxml2(DOM) SDK? Yes Yes No No No No No Yes 解析时间 1.87 1.19 0.68 1.1 1.37 1.27 1.07 0.84 内存占用 3.11 3.01 3.07 6.5 5.25 4.8 4.15 4.97 边下载边解析 No Yes No No No No No No 编辑 No No No No Yes Yes Yes Yes XPath No No No Yes Yes Yes* Yes Yes 语言 Obj-C C Obj-C Obj-C Obj-C C Obj-C C License Apple MIT MIT MIT MIT ZLib Apache MIT * = with TinyXPath 如果是读取很小的XML文档，性能基本上没有什么差别，不过从调用的方便性来说，建议使用 TouchXML、KissXML或GDataXML 如果是需要读取和修改 XML 文档，建议使用 KissXML 或 GDataXML 如果需要读取非常大的 XML 文档，则建议使用 libxml2 或 TBXML 如果你不想去调用第三方类库，那么可以使用 NSXMLParser。 解析速率 内存占用 四、学习文章&lt; p class=”line” style=”padding-left: 30px;” data-line=”154”&gt;《How To Choose The Best XML Parser for Your iPhone Project》宝玉 # iOS平台XML解析类库对比和安装说明PhelanGeek # iOS下XML文件的三种解析方式","tags":[]},{"title":" 组件化讨论之四\t\t","date":"2018-04-10T23:47:37.000Z","path":"2018/04/11/modularization4/","text":"原文地址：https://casatwy.com/iOS-Modulization.html 一、蘑菇街是以两种方式来做跨组件操作的1、通过 MGJRouter 的 registerURLPattern:toHandler: 进行注册，将 URL 和 block 绑定。这个方法前面一个参数传递的是 URL，例如 mgj://detail?id=:id 这种，后面的 toHandler: 传递的是一个 ^(NSDictionary * routerParameters){ // 此处可以做任何事 } 的 block。 当组件执行 [MGJRouter openURL:@”mgj://detail?id=404”] 时，根据之前 registerURLPattern:toHandler: 的信息，找到之前通过 toHandler: 收集的block，然后将 URL 中带的 GET 参数，此处是 id=404，传入 block 中执行。如果在 block 中执行 NSLog(routerParameters) 的话，就会看到@{ @”id”:@”404” } ，因此 block 中的业务就能够得到执行。 然后为了业务方能够不生写 URL，蘑菇街列出了一系列宏或者字符串常量（具体是宏还是字符串我就不是很确定，没看过源码，但 limboy 文章中有提到通过一个后台系统生成一个装满 URL 的源码文件）来表征 URL。在 openURL 时，无论是远程应用调用还是本地组件间调用，只要传递的参数不复杂，就都会采用 openURL 的方式去唤起页面，因为复杂的参数和非常规参数这种调用方式就无法支持了。 缺陷在于：这种注册的方式其实是不必要的，而且还白白使用 URL 和 block 占用了内存。另外还有一个问题就是，即便是简单参数的传递，如果参数比较多，业务工程师不看原始 URL 字符串是无法知道要传递哪些参数的。 蘑菇街之所以采用 id=:id 的方式，我猜是为了怕业务工程师传递多个参数顺序不同会导致问题，而使用的占位符。这种做法在持久层生成 sql 字符串时比较常见。不过这个功能我没在 limboy 的文章中看到有写，不知道实现了没有。 在本文提供的组件化方案中，因为没有注册，所以就没有内存的问题。因为通过 category 提供接口调用，就没有参数的问题。对于蘑菇街来说，这种做法其实并没有做到拆分远程应用调用和本地组件间调用的目的，而不拆分会导致的问题我在文章中已经论述过了，这里就不多说了。 2、新开了一个对象叫做 ModuleManager，提供了一个 registerClass:forProtocol: 的方法，在应用启动时，各组件都会有一个专门的 ModuleEntry 被唤起，然后 ModuleEntry 将 @protocol 和 Class 进行配对。因此 ModuleManager 中就有了一个字典来记录这个配对。 当有涉及非常规参数的调用时，业务方就不会去使用 [MGJRouter openURL:@”mgj://detail?id=404”] 的方案了，转而采用 ModuleManager 的 classForProtocol: 方法。业务传入一个 @protocol 给 ModuleManager，然后 ModuleManager 通过之前注册过的字典查找到对应的 Class 返回给业务方，然后业务方再自己执行 alloc 和 init 方法得到一个符合刚才传入 @protocol 的对象，然后再执行相应的逻辑。 这里的 ModuleManager 其实跟之前的 MGJRouter 一样，是没有任何必要去注册协议和类名的。而且无论是服务提供者调用 registerClass:forProtocol: 也好，服务的调用者调用 classForProtocol:，都必须依赖于同一个 protocol。蘑菇街把所有的 protocol 放入了一个 publicProtocol.h 的文件中，因此调用方和响应方都必须依赖于同一个文件。这个我在文章中也论述过：响应方在提供服务的时候，是不需要依赖任何人的。 二、回应 蘑菇街分开了远程应用调用和本地组件调用的说法是不成立的，蘑菇街分开的只是普通参数调用和非常规参数调用。而没有区分远程应用调用和本地组件间调用。 蘑菇街确实不只有 openURL 方式，还提供了 ModuleManager 方式，分为「组件间调用」和「页面间跳转」两个维度，只要 app 响应某个 URL，无论是 app 内还是 app 外都可以，而「组件间」调用走的完全是另一条路，所以也不会有安全上的问题。这种说法其实也是不成立的，因为 openURL 方式也出现在了本地组件间调用中，这在他第一篇文章里的组件间通信小节中就已经说了采用 openURL 方式调用了，这是有可能产生安全问题的。而且这段话也承认了 openURL 方式被用于本地组件间调用，又印证了我刚才说的第一点。 根据上面两点，蘑菇街在 openURL 场景下，还是出现了以远程调用的方式为本地间调用提供服务的问题，这个问题我也已经在文中论述过了。 蘑菇街在本地间调用同时采用了 openURL 方案和 protocol-class 方案，所以其实之前我指出蘑菇街本地间调用不能传递非常规参数和复杂参数是不对的，应该是蘑菇街在本地间调用时如果是普通参数，那就采用 openURL，如果是非常规参数，那就采用 protocol-class 了，这个做法对于本地间调用的管理和维护，显而易见是不利的。。。 limboy 说必须要在 app 启动时注册 URL 响应者这步不可避免，但没有说原因。我的 demo 已经证实了注册是不必要的。 架构图画错了 按照蘑菇街的方案来看，红圈的地方是不可能没有依赖的。。。 三、limboy 对本文方案提出的看法1、认为 category 在某种意义上也是一个注册过程。 蘑菇街的注册和我的 category 其实是两回事，而且我无论如何也无法理解把 category 和注册 URL 等价联系的逻辑。 一个很简单的事实就可以证明两者完全不等价了：我的方案如果没有 category，照样可以跑，就是业务方调用丑陋一点。蘑菇街如果不注册 URL，整个流程就跑不起来了～ 2、认为 openURL 的好处是可以更少地关心业务逻辑，本文方案的好处是可以很方便地完成参数传递。 并没觉得本文方案关心的业务逻辑比 openURL 更多，因为两者比较起来，都是传参数发调用请求，在关心业务逻辑的条件下，两者完全一样。唯一的不同就是，我能传非常规参数而 openURL 不能。本文方案的整个过程中，在调用者这一方是完全没有涉及到任何属于响应者的业务逻辑的。 3、认为 protocol/URL 注册和将 target-action 抽象出调用接口是等价的 这其实只是效果等价了，两者真正的区别在于：protocol 对业务产生了侵入，且不符合黑盒模型。 我来解释一下 protocol 侵入业务的原因 由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的 protocol，然而这个 protocol 又不存在于当前业务领域，于是当前业务就不得不依赖 publicProtocol。这对于将来的业务迁移是有非常大的影响的。 另外再解释一下为什么不符合黑盒模型 蘑菇街的 protocol 方式使对象要在调用者处使用，由于调用者并不包含对象原本所处的业务领域，当完成任务需要多个这样的对象的时候，就需要多次通过 protocol 获得 class 来实例化多个对象，最终才能完成需求。 但是 target-action 模式保证了在执行组件间调用的响应时，执行的上下文处于响应者环境中，这跟蘑菇街的 protocol方案相比就是最大的差别。因为从黑盒理论上讲，调用者只管发起请求，请求的执行应该由响应者来负责，因此执行逻辑必须存在于响应者的上下文内，而不能存在于调用者的上下文内。 举个具体一点的例子就是，当你发起了一个网页请求，后端取好数据渲染好页面，无论获取数据涉及多少渠道，获取数据的逻辑都在服务端完成，然后再返回给浏览器展示。这个是正确的做法，target-action 模式也是这么做的。 但是蘑菇街的方案就变成了这样：你发起了一个网络请求，后端返回的不是数据，返回的竟然是一个数据获取对象(DAO)，然后你再通过 DAO 去取数据，去渲染页面，如果渲染页面的过程涉及多个 DAO，那么你还要再发起更多请求， 拿到的还是 DAO，然后再拿这个 DAO 去获取数据，然后渲染页面。这是一种非常诡异的做法。。。 如果说这么做是为了应对执行业务的过程中，需要根据中间阶段的返回值来决定接下来的逻辑走向的话，那也应该是多次调用获得数据，然后决定接下来的业务走向，而不是每次拿到的都是 DAO 啊。。。使用 target-action 方式来应对这种场景其实也很自然啊～","tags":[]},{"title":" 组件化讨论之三\t\t","date":"2018-04-09T15:29:52.000Z","path":"2018/04/09/modularization3/","text":"原文：蘑菇街 App 的组件化之路·续 一、统一的调用实现将「URL 调用」和「组件间调用」通过 runtime 达到统一，通过 prefix 的方式来避免安全上的一些漏洞。看起来确实会舒服些，也比较灵活。 二、通过 Category 来统一组件对外暴露的接口支持 openURL: 但最终还是走的 target-action，跟内部调用无差别。 这也是我们目前有待提升的点，想知道某个组件支持哪些 URL 或哪些 Protocol 不够方便，URL 的参数传递也是个问题，将来 URL 发生变动的话，调整起来也比较麻烦。后续会在这块再加强下。 当初决定使用 openURL: 来做页面间的跳转，而不是方法调用，主要是考虑到我们的大部分场景都可以通过这种方式解决，因此就这么定了。openURL: 更像 Android 里的 「隐式 Intent」，不关心谁来处理这个 URL，由系统（MGJRouter）来决定。而方法调用更像「显式 Intent」或者 RPC，明确地知道应该由谁来处理。前者的好处是可以更少地关心业务逻辑，后者的好处是可以很方便地完成参数传递。 三、更明确的表述 openURL 只是页面间的调用方式 组件间的调用通过 protocol 来实现 每个组件都有一个 Entry，这个 Entry 主要做了三件事： 注册这个组件关心的 URL 注册这个组件能够被调用的方法/属性 在 App 生命周期的不同阶段做不同的响应 1、注册这个组件关心的 URL MGJRouter registerURLPattern:@”mgj://detail?id=:id” toHandler:^(NSDictionary * routerParameters) { NSNumber * id = routerParameters\\[@&quot;id&quot;\\]; // create view controller with id. push view controller }]; URL 的注册会有对应的 block，拿到这个 URL 后，想怎么折腾就怎么折腾。 2、注册这个组件能够被调用的方法/属性 当有一些场景不适合用 URL 的方式时，就可以通过注册 protocol 来实现 [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。 [ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么，反正实现了 ProtocolA 协议，拿来用就行。 这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。 四、在 App 生命周期的不同阶段做不同的响应上一篇文章中有提到，这里简单说下，ModuleEntry实现某个特定的协议(该协议继承自 UIApplicationDelegate)，然后实现对应的方法即可。 五、针对 casatwy 那篇文章的一些回应1、单纯以 openURL 的方式是无法胜任让一个 App 去实施组件化架构的 同意，所以我们并不只有 openURL 2、一种方式根本无法表达非常规对象 单纯地通过 openURL 确实不太好表达，但我们并不只有 openURL 3、一种方式注册 URL 的目的其实是一个服务发现的过程，在 iOS 领域中，服务发现的方式是不需要通过主动注册的，使用runtime 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime 由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。由于通过 runtime 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。 尽管通过 runtime 可以做到这些，但最终还是要通过维护 Category 来暴露新增的 Target-Action，所以 runtime 虽然不存在注册过程，但实际使用过程中，还是会有注册过程，还是需要去维护。 4、没有拆分远程调用和本地间调用 从上面的图可以看到，我们其实是分为「组件间调用」和「页面间跳转」两个维度，只要 app 响应某个 URL，无论是 app 内还是 app 外都可以，而「组件间」调用走的完全是另一条路，所以也不会有安全上的问题。 5、以远程调用的方式为本地间调用提供服务 同上 6、本地间调用无法传递非常规参数，复杂参数的传递方式非常丑陋 同上，使用 Protocol 7、必须要在 app 启动时注册 URL 响应者 是的，就蘑菇街的方案来说，这步不可避免。 8、这个不必要的操作会导致不必要的维护成本 维护只是在组件内部做调整，并不需要在主工程里做修改。如果采用 Category 的方式，好处是不用在启动时注册，但当组件的接口有变动时，依然要维护 Category，这个成本是免不了的。 9、新增组件化的调用路径时，蘑菇街的操作相对复杂 在本文给出的组件化方案中，响应者唯一要做的事情就是提供 Target 和 Action，并不需要再做其它的事情 提供了 Target-Action 之后，还是要在 Category 里添加一个 wrapper 的吧? 10、没有针对 target 层做封装这种做法使得所有的跨组件调用请求直接 hit 到业务模块，业务模块必然因此变得臃肿难以维护，属于侵入式架构。应该将原本属于调用相应的部分拿出来放在 target-action 中，才能尽可能保证不将无关代码侵入到原有业务组件中，才能保证业务组件未来的迁移和修改不受组件调用的影响，以及降低为项目的组件化实施而带来的时间成本。 「将原本属于调用相应的部分拿出来放在 target-action 中」并不是唯一可行的方式，使用 Protocol/URL 注册也可以达到效果。","tags":[]},{"title":" 组件化讨论之二\t\t","date":"2018-04-08T14:41:59.000Z","path":"2018/04/08/e7-bb-84-e4-bb-b6-e5-8c-96-e8-ae-a8-e8-ae-ba-e5-a7-8b-e6-9c-ab-e4-b9-8b-e4-ba-8c/","text":"原文地址：iOS应用架构谈 组件化方案、demo 这个 Demo 对业务敏感的边界情况处理比较简单，这需要根据不同 App 的特性和不同产品的需求才能做，所以只是为了说明组件化架构用的。如果要应用在实际场景中的话，可以根据代码里给出的注释稍加修改。 一、蘑菇街组件化方案的问题蘑菇街的组件化是怎么做的： App 启动时实例化各组件模块，然后这些组件向 ModuleManager 注册 Url。有时不需要实例化，使用 class 注册。 当组件 A 需要调用组件 B 时，向 ModuleManager 传递 URL，参数跟随 URL 以 GET 方式传递，类似 openURL。然后由ModuleManager 负责调度组件 B，最后完成任务。 这里的两步中，每一步都存在问题。 1、第一步的问题 在组件化的过程中，注册 URL 并不是充分必要条件，组件是不需要向组件管理器注册 Url 的。而且注册了 Url 之后，会造成不必要的内存常驻，如果只是注册 Class，内存常驻量就小一点，如果是注册实例，内存常驻量就大了。至于蘑菇街注册的是 Class 还是实例，Limboy 分享时没有说，文章里我也没看出来，也有可能是我看漏了。不过这还并不能算是致命错误，只能算是小缺陷。 真正的致命错误在第二步。 2、第二部的问题 在 iOS 领域里，一定是组件化的中间件为 openUrl 提供服务，而不是 openUrl 方式为组件化提供服务。 什么意思呢？ 也就是说，一个 App 的组件化方案一定不是建立在 URL 上的，openURL 的跨 App 调用是可以建立在组件化方案上的。当然，如果 App 还没有组件化，openURL 方式也是可以建立的，就是丑陋一点而已。 为什么这么说？ 因为组件化方案的实施过程中，需要处理的问题的复杂度，以及拆解、调度业务的过程的复杂度比较大，单纯以 openURL 的方式是无法胜任让一个 App 去实施组件化架构的。如果在给 App 实施组件化方案的过程中是基于 openURL 的方案的话，有一个致命缺陷：非常规对象无法参与本地组件间调度。关于非常规对象我会在详细讲解组件化方案时有一个辨析。 实际 App 场景下，如果本地组件间采用 GET 方式的 URL 调用，就会产生两个问题： 根本无法表达非常规对象 比如你要调用一个图片编辑模块，不能传递 UIImage 到对应的模块上去的话，这是一个很悲催的事情。 当然，这可以通过给方法新开一个参数，然后传递过去来解决。比如原来是： [a openUrl:”http://casa.com/detail?id=123&amp;type=0&quot;\\]; 同时就也要提供这样的方法： [a openUrl:”http://casa.com/detail&quot; params:@{ @”id” : “123”, @”type” : “0”, @”image” : [UIImage imageNamed:@”test”] }]; 如果不像上面这么做，复杂参数和非常规参数就无法传递。如果这么做了，那么事实上这就是拆分远程调用和本地调用的入口了，这就变成了我文章中提倡的做法，也是蘑菇街方案没有做到的地方。 另外，在本地调用中使用 URL 的方式其实是不必要的，如果业务工程师在本地间调度时需要给出 URL，那么就不可避免要提供 params，在调用时要提供哪些 params 是业务工程师很容易懵逼的地方。。。在文章下半部分给出的 demo 代码样例已经说明了业务工程师在本地间调用时，是不需要知道 URL 的，而且 demo 代码样例也阐释了如何解决业务工程师遇到传 params容易懵逼的问题。 URL 注册对于实施组件化方案是完全不必要的，且通过 URL 注册的方式形成的组件化方案，拓展性和可维护性都会被打折 注册 URL 的目的其实是一个服务发现的过程，在 iOS 领域中，服务发现的方式是不需要通过主动注册的，使用 runtime 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime 由于不存在注册过程，那也就不会产生维护的操作，维护成本就降低了。 由于通过 runtime 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。 二、小总结蘑菇街采用了 openURL 的方式来进行 App 的组件化是一个错误的做法，使用注册的方式发现服务是一个不必要的做法。而且这方案还有其它问题，随着下文对组件化方案介绍的展开，相信各位自然心里有数。 三、正确的组件化方案先来看一下方案的架构图： 这幅图是组件化方案的一个简化版架构描述，主要是基于 Mediator 模式和 Target-Action 模式，中间采用了 runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务，与蘑菇街方案正好相反。 四、调用方式先说本地应用调用，本地组件 A 在某处调用 [[CTMediator sharedInstance] performTarget:targetName action:actionName params:@{…}] 向 CTMediator 发起跨组件调用，CTMediator 根据获得的 target 和 action 信息，通过 objective-C 的 runtime 转化生成 target 实例以及对应的 action 选择器，然后最终调用到目标业务提供的逻辑，完成需求。 在远程应用调用中，远程应用通过 openURL 的方式，由 iOS 系统根据 info.plist 里的 scheme 配置找到可以响应 URL 的应用，应用通过 AppDelegate 接收到 URL 之后，调用 CTMediator 的 openUrl: 方法将接收到的 URL 信息传入。当然，CTMediator 也可以用 openUrl:options: 的方式顺便把随之而来的 option 也接收，这取决于你本地业务执行逻辑时的充要条件是否包含 option 数据。传入 URL 之后，CTMediator 通过解析 URL，将请求路由到对应的 target 和 action，随后的过程就变成了上面说过的本地应用调用的过程了，最终完成响应。 针对请求的路由操作很少会采用本地文件记录路由表的方式，服务端经常处理这种业务，在服务端领域基本上都是通过正则表达式来做路由解析。App 中做路由解析可以做得简单点，制定 URL 规范就也能完成，最简单的方式就是 scheme://target/action 这种，简单做个字符串处理就能把 target 和 action 信息从 URL 中提取出来了。 五、组件仅通过 Action 暴露可调用接口所有组件都通过组件自带的 Target-Action 来响应，也就是说，模块与模块之间的接口被固化在了 Target-Action 这一层，避免了实施组件化的改造过程中，对 Business 的侵入，同时也提高了组件化接口的可维护性。 可以看到，虚线圈起来的地方就是用于跨组件调用的 target 和 action，这种方式避免了由 BusinessA 直接提供组件间调用会增加的复杂度，而且任何组件如果想要对外提供调用服务，直接挂上 target 和 action 就可以了，业务本身在大多数场景下去进行组件化改造时，是基本不用动的。 六、复杂参数和非常规参数，以及组件化相关设计思路统一术语的理解： 复杂参数是指由普通类型的数据组成的多层级参数。在本文中，我们定义只要是能够被 json 解析的类型就都是普通类型，包括 NSNumber、NSString、NSArray、NSDictionary，以及相关衍生类型，比如来自系统的 NSMutableArray 或者你自己定义的都算。 总结：在本文讨论的场景中，复杂参数的定义是由普通类型组成的具有复杂结构的参数。普通类型的定义就是指能够被 json 解析的类型。 非常规参数是指由普通类型以外的类型组成的参数，例如 UIImage 等这些不能够被 json 解析的类型。然后这些类型组成的参数在文中就被定义为非常规参数。 总结：非常规参数是包含非常规类型的参数。非常规类型的定义就是不能被 json 解析的类型都叫非常规类型。 边界情况： ①、假设多层级参数中有存在任何一个内容是非常规参数，本文中这种参数就也被认为是非常规参数。 ②、如果某个类型当前不能够被 json 解析，但通过某种转化方式能够转化成 json，那么这种类型在场景上下文中，我们也称为普通类型。举个例子就是通过 json 描述的自定义 view。如果这个 view 能够通过某个组件被转化成 json，那么即使这个 view 本身并不是普通类型，在具有转化器的上下文场景中，我们依旧认为它是普通类型。 ③、如果上下文场景中没有转化器，这个 view 就是非常规类型了。 ④、假设转化出的 json 不能够被还原成 view，比如组件 A 有转化器，组件 B 中没有转化器，因此在组件间调用过程中 json 在组件 B 里不能被还原成 view。在这种调用方向中，只要调用者能将非常规类型转化成 json 的，我们就依然认为这个 view 是普通类型。如果调用者是组件 A，转化器在组件 B 中，A 传递 view 参数时是没办法转化成 json 的，那么这个 view 就被认为是非常规类型，哪怕它在组件 B 中能够被转化成 json。 七、为什么应该由本地组件间调用来支持远程应用调用？远程 App 是不可能通过 URL 来提供非常规参数的，最多只能以 json string 的方式经过 URLEncode 之后再通过 GET来提供复杂参数，然后再在本地组件中解析 json，最终完成调用。在组件间调用时，通过 performTarget:action:params:是能够提供非常规参数的，于是我们可以知道，远程 App 调用时的上下文环境以及功能是本地组件间调用时上下文环境以及功能的子集。 因此这个逻辑注定了必须由本地组件间调用来为远程 App 调用来提供服务，只有符合这个逻辑的设计思路才是正确的组件化方案的设计思路，其他跟这个不一致的思路一定就是错的。因为逻辑上子集为父集提供服务说不通，所以强行这么做的话，用一个成语来总结就叫做倒行逆施。 另外，远程 App 调用和本地组件间调用必须要拆分开，远程 App 调用只能走 CTMediator 提供的专用远程的方法，本地组件间调用只能走 CTMediator 提供的专用本地的方法，两者不能通过同一个接口来调用。这里有两个原因： ①、远程 App 调用处理入参的过程比本地多了一个 URL 解析的过程，这是远程 App 调用特有的过程。 ②、架构师没有充要条件可以认为远程 App 调用对于无响应请求的处理方式和本地组件间调用无响应请求的处理方式在未来产品的演进过程中是一致的。 在远程 App 调用中，用户通过 url 进入 app，当 app 无法为这个 url 提供服务时，常见的办法是展示一个的 404 界面，告诉用户“当前没有相对应的内容，不过你可以在 app 里别的地方再逛逛”。这个场景多见于用户使用的 App 版本不一致。比如有一个 URL 只有 v1.1 版本的 app 能完整响应，v1.0 版本的 app 虽然能被唤起，但是无法完成整个响应过程，那么 v1.0 的 app 就要展示一个 404 页面了。 在组件间调用中，如果遇到了无法响应的请求，就要分两种场景考虑了。 场景 1 如果这种无法响应的请求发生场景是在开发过程中，比如两个组件同时在开发，组件 A 调用组件 B 时，组件 B 还处于旧版本没有发布新版本，因此响应不了，那么这时候的处理方式可以相对随意，只要能体现 B 模块是旧版本就行了，最后在RC 阶段统测时是一定能够发现的，只要 App 没发版，怎么处理都来得及。 场景 2 如果这种无法响应的请求发生场景是在已发布的 App 中，有可能展示个 404 就结束了，那这就跟远程 App 调用时的 404 处理场景一样。但也有可能需要为此做一些额外的事情，有可能因为做了额外的事情，就不展示 404 了，展示别的页面了，这一切取决于产品经理。 那么这种场景是如何发生的呢？ 举一个例子：当用户在 v1.0 版本时收藏了一个东西，然后用户升级 App 到 v1.1 版本。v1.0 版本的收藏项目在本地持久层存入的数据有可能是会跟 v1.1 版本收藏时存入的数据是不一致的。此时用户在 v1.1 版本的 app 中对 v1.0 版本收藏的东西做了一些操作，触发了本地组件间调用，这个本地间调用又与收藏项目本身的数据相关，那么这时这个调用就是有可能变成无响应调用，此时的处理方式就不见得跟以前一样展示个 404 页面就结束了，因为用户已经看到了收藏了的东西，结果你还告诉他找不到，用户立刻懵逼。。。这时候的处理方式就会用很多种，至于产品经理会选择哪种，你作为架构师是没有办法预测的。如果产品经理提的需求落实到架构上，对调用入口产生要求然而你的架构又没有拆分调用入口，对于你的选择就只有两个：要么打回产品需求，要么加个班去拆分调用入口。 当然，架构师可以选择打回产品经理的需求，最终挑选一个自己的架构能够承载的需求。但是，如果这种是因为你早期设计架构时挖的坑而打回的产品需求，你不觉得丢脸么？ 鉴于远程 app 调用和本地组件间调用下的无响应请求处理方式不同，以及未来不可知的产品演进，拆分远程 app 调用入口和本地组件间调用入口是功在当代利在千秋的事情。 八、组件化方案中的去 model 设计组件间调用时，是需要针对参数做去 model 化的。如果组件间调用不对参数做去 model 化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。 假设模块 A 和模块 B 之间采用 model 化的方案去调用，那么调用方法时传递的参数就会是一个对象。 如果对象不是一个面向接口的通用对象，那么 mediator 的参数处理就会非常复杂，因为要区分不同的对象类型。如果mediator 不处理参数，直接将对象以范型的方式转交给模块 B，那么模块 B 必然要包含对象类型的声明。假设对象声明放在模块 A，那么 B 和 A 之间的组件化只是个形式主义。如果对象类型声明放在 mediator，那么对于 B 而言，就不得不依赖mediator。但是，大家可以从上面的架构图中看到，对于响应请求的模块而言，依赖 mediator 并不是必要条件，因此这种依赖是完全不需要的，这种依赖的存在对于架构整体而言，是一种污染。 如果参数是一个面向接口的对象，那么 mediator 对于这种参数的处理其实就没必要了，更多的是直接转给响应方的模块。而且接口的定义就不可能放在发起方的模块中了，只能放在 mediator 中。响应方如果要完成响应，就也必须要依赖mediator，然而前面我已经说过，响应方对于 mediator 的依赖是不必要的，因此参数其实也并不适合以面向接口的对象的方式去传递。 因此，使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。 在这种跨模块场景中，参数最好还是以去 model 化的方式去传递，在 iOS 的开发中，就是以字典的方式去传递。这样就能够做到只有调用方依赖 mediator，而响应方不需要依赖 mediator。然而在去 model 化的实践中，由于这种方式自由度太大，我们至少需要保证调用方生成的参数能够被响应方理解，然而在组件化场景中，限制去 model 化方案的自由度的手段，相比于网络层和持久层更加容易得多。 因为组件化天然具备了限制手段：参数不对就无法调用！无法调用时直接 debug 就能很快找到原因。所以接下来要解决的去model 化方案的另一个问题就是：如何提高开发效率。 在去 model 的组件化方案中，影响效率的点有两个：调用方如何知道接收方需要哪些 key 的参数？调用方如何知道有哪些target 可以被调用？其实后面的那个问题不管是不是去 model 的方案，都会遇到。为什么放在一起说，因为我接下来要说的解决方案可以把这两个问题一起解决。 九、使用 categorymediator 这个 repo 维护了若干个针对 mediator 的 category，每一个对应一个 target，每个 category 里的方法对应了这个 target 下所有可能的调用场景，这样调用者在包含 mediator 的时候，自动获得了所有可用的 target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是 category 而不是其他： ①、category 本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用 category 封装是很合理的。 ②、在 category 的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category 就提供了补救的入口。 ③、category 可以很轻松地做请求转发，如果不采用 category，请求转发逻辑就非常难做了。 ④、category 统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。 ⑤、由于 category 统一了所有的调用入口，使得在跨模块调用时，对于 param 的 hardcode 在整个 App 中的作用域仅存在于 category 中，在这种场景下的 hardcode 就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。 本文对应的 Demo 展示了如何使用 category 来实现去 model 的组件调用。上面的代码片段也是摘自这个 demo。 十、基于其他考虑还要再做的一些额外措施1、基于安全考虑 我们需要防止黑客通过 URL 的方式调用本属于 native 的组件，比如支付宝的个人财产页面。如果在调用层级上没有区分好，没有做好安全措施，黑客就有通过 safari 查看任何人的个人财产的可能。 安全措施其实有很多，大部分取决于 App 本身以及产品的要求。在架构层面要做的最基础的一点就是区分调用是来自于远程 App 还是本地组件，我在 demo 中的安全措施是采用给 action 添加 native 前缀去做的，凡是带有 native 前缀的就都只允许本地组件调用，如果在 url 阶段发现调用了前缀为 native 的方法，那就可以采取停止响应的措施了。这也是将远程 app 调用入口和本地组件调用入口区分开来的重要原因之一。 当然，为了确保安全的做法有很多，但只要拆出远程调用和本地调用，各种做法就都有施展的空间了。 2、基于动态调度考虑 动态调度的意思就是，今天可能这个跳转是要展示 A 页面，但是明天可能同样的跳转就要去展示 B 页面了。这个跳转有可能是来自于本地组件间跳转也有可能是来自于远程 app。 做这个事情的切点在本文架构中，有很多个： ①、以 url parse 为切点 ②、以实例化 target 时为切点 ③、以 category 调度方法为切点 ④、以 target 下的 action 为切点 如果以 url parse 为切点的话，那么这个动态调度就只能够对远程 App 跳转产生影响，失去了动态调度本地跳转的能力，因此是不适合的。 如果以实例化 target 时为切点的话，就需要在代码中针对所有 target 都做一次审查，看是否要被调度，这是没必要的。假设 10 个调用请求中，只有 1 个要被动态调度，那么就必须要审查 10 次，只有那 1 次审查通过了，才走动态调度，这是一种相对比较粗暴的方法。 如果以 category 调度方法为切点的话，那动态调度就只能影响到本地件组件的跳转，因为 category 是只有本地才用的，所以也不适合。 以 target 下的 action 为切点是最适合的，因为动态调度在一般场景下都是有范围的，大多数是活动页需要动态调度，今天这个活动明天那个活动，或者今天活动正在进行明天活动就结束了，所以产生动态调度的需求。我们在可能产生动态调度的 action 中审查当前 action 是否需要被动态调度，在常规调度中就没必要审查了，例如个人主页的跳转，商品详情的跳转等，这样效率就能比较高。 大家会发现，如果要做类似这种效率更高的动态调度，target-action 层被抽象出来就是必不可少的，然而蘑菇街并没有抽象出 target-action 层，这也是其中的一个问题。 当然，如果你的产品要求所有页面都是存在动态调度需求的，那就还是以实例化 target 时为切点去调度了，这样能做到审查每一次调度请求，从而实现动态调度。 说完了调度切点，接下来要说的就是如何完成审查流程。完整的审查流程有几种，我每个都列举一下： ①、App 启动时下载调度列表，或者定期下载调度列表。然后审查时检查当前 target 是否存在要被动态调度跳转的 action，如果存在，则跳转到另一个 action ②、每一次到达新的 action 时，以 action 为参数调用 API 获知是否需要被跳转，如果需要被跳转，则 API 告知要跳转的 action，然后再跳转到 API 指定的 action 这两种做法其实都可以，如果产品对即时性的要求比较高，那么采用第二种方案，如果产品对即时性要求不那么高，第一种方案就可以了。由于本文的方案是没有 URL 注册列表的，因此服务器只要给出原始 target-action 和对应跳转的 target-action 就可以了，整个流程不是只有注册 URL 列表才能达成的，而且这种方案比注册 URL 列表要更易于维护一些。 另外，说采用 url rewrite 的手段来进行动态调度，也不是不可以。但是这里我需要辨析的是，URL 的必要性仅仅体现在远程 App 调度中，是没必要蔓延到本地组件间调用的。这样，当我们做远程 App 的 URL 路由时（目前的 demo 没有提供 URL 路由功能，但是提供了 URL 路由操作的接入点，可以根据业务需求插入这个功能），要关心的事情就能少很多，可以比较干净。在这种场景下，单纯以 URL rewrite 的方式其实就与上文提到的以 url parse 为切点没有区别了。 十一、蘑菇街的组件化方案的缺陷 蘑菇街没有拆分远程调用和本地间调用 不拆分远程调用和本地间调用，就使得后续很多手段难以实施，这个我在前文中都已经有论述了。另外再补充一下，这里的拆分不是针对来源做拆分。比如通过 URL 来区分是远程 App 调用还是本地调用，这只是区分了调用者的来源。 这里说的区分是指：远程调用走远程调用路径，也就是 openUrl -&gt; urlParse -&gt; perform -&gt; target-action。本地组件间调用就走本地组件间调用路径：perform -&gt; target-action。这两个是一定要作区分的，蘑菇街方案并没有对此做好区分。 蘑菇街以远程调用的方式为本地间调用提供服务 这是本末倒置的做法，倒行逆施导致的是未来架构难以为业务发展提供支撑。因为前面已经论述过，在 iOS 场景下，远程调用的实现是本地调用实现的子集，只有大的为小提供服务，也就是本地调用为远程调用提供服务，如果反过来就是倒行逆施了。 蘑菇街的本地间调用无法传递非常规参数，复杂参数的传递方式非常丑陋 注意这里复杂参数和非常规参数的辨析。 由于采用远程调用的方式执行本地调用，在前面已经论述过两者功能集的关系，因此这种做法无法满足传递非常规参数的需求。而且如果基于这种方式不变的话，复杂参数的传递也只能依靠经过 urlencode 的 json string 进行，这种方式非常丑陋，而且也不便于调试。 蘑菇街必须要在 app 启动时注册 URL 响应者 这个条件在组件化方案中是不必要条件，demo 也已经证实了这一点。这个不必要的操作会导致不必要的维护成本，如果单纯从只要完成业务就好的角度出发，这倒不是什么大问题。这就看架构师对自己是不是要求严格了。 新增组件化的调用路径时，蘑菇街的操作相对复杂 在本文给出的组件化方案中，响应者唯一要做的事情就是提供 Target 和 Action，并不需要再做其它的事情。蘑菇街除此之外还要再做很多额外不必要措施，才能保证调用成功。 蘑菇街没有针对 target 层做封装 这种做法使得所有的跨组件调用请求直接 hit 到业务模块，业务模块必然因此变得臃肿难以维护，属于侵入式架构。应该将原本属于调用相应的部分拿出来放在 target-action 中，才能尽可能保证不将无关代码侵入到原有业务组件中，才能保证业务组件未来的迁移和修改不受组件调用的影响，以及降低为项目的组件化实施而带来的时间成本。 十二、总结本文提供的组件化方案是采用 Mediator 模式和苹果体系下的 Target-Action 模式设计的。 然而这款方案有一个很小的缺陷在于对 param 的 key 的 hardcode，这是为了达到最大限度的解耦和灵活度而做的权衡。在我的网络层架构和持久层架构中，都没有 hardcode 的场景，这也从另一个侧面说明了组件化架构的特殊性。 权衡时，考虑到这部分 hardcode 的影响域仅仅存在于 mediator 的 category 中。在这种情况下，hardcode 对于调用者的调用是完全透明的。对于响应者而言，处理方式等价于对 API 返回的参数的处理方式，且响应者的处理方式也被限制在了Action 中。 因此这部分的 hardcode 的存在虽然确实有点不干净，但是相比于这些不干净而带来的其他好处而言，在权衡时是可以接受的，如果不采用 hardcode，那势必就会导致请求响应方也需要依赖 mediator，然而这在逻辑上是不必要的。另外，在我的各个项目的实际使用过程中，这部分 hardcode 是没有影响的。 另外要谈的是，之所以会在组件化方案中出现 harcode，而网络层和持久层的去 model 化都没有发生 hardcode 情况，是因为组件化调用的所有接受者和调用者都在同一片上下文里。网络层有一方在服务端，持久层有一方在数据库。再加上设计时针对 hardcode 部分的改进手段其实已经超出了语言本身的限制。也就是说，harcode 受限于语言本身。objective-C 也好，swift 也好，它们的接口设计哲学是存在缺陷的。如果我们假设在 golang 的背景下，是完全可以用 golang 的接口体系去做一个最优美的架构方案出来的。不过这已经不属于本文的讨论范围了，有兴趣的同学可以去了解一下相关知识。架构设计有时就是这么无奈。 组件化方案在 App 业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它有助于将复杂 App 分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过 MVP 阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。 当决定要实施组件化方案时，对于组件化方案的架构设计优劣直接影响到架构体系能否长远地支持未来业务的发展，对 App 的组件化不只是仅仅的拆代码和跨业务调页面，还要考虑复杂和非常规业务参数参与的调度，非页面的跨组件功能调度，组件调度安全保障，组件间解耦，新旧业务的调用接口修改等问题。 蘑菇街的组件化方案只实现了跨业务页面调用的需求，本质上只实现了我在 view 层架构的文章中跨业务页面调用的内容，这还没有到成为组件化方案的程度，且蘑菇街的组件化方案距离真正的 App 组件化的要求还是差了一段距离的，且存在设计逻辑缺陷，希望蘑菇街能够加紧重构，打造真正的组件化方案。","tags":[]},{"title":" 组件化讨论之一\t\t","date":"2018-04-08T14:30:46.000Z","path":"2018/04/08/modularization1/","text":"原文地址：蘑菇街 App 的组件化之路 一、蘑菇街 App 的组件化之路进行组件化之前，蘑菇街 App 的代码都是在一个工程里开发，在人比较少、业务发展不是很快的时候，这样是比较合适的，能一定程度地保证开发效率。 慢慢地代码量多了起来，开发人员也多了起来，业务发展也快了起来，这时单一工程开发模式就会显露出一些弊端： ①、耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多） ②、容易出现冲突（尤其是使用 Xib，还有就是 Xcode Project，虽说有脚本可以改善） ③、业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起） 为了解决这些问题，就采取了「组件化」策略。它能带来这些好处： ①、加快编译速度（不用编译主客那一大坨代码了） ②、自由选择开发姿势（MVC / MVVM / FRP） ③、方便 QA 有针对性地测试 ④、提高业务开发效率 先来看下，组件化之后的一个大概架构： 「组件化」顾名思义就是把一个大的 App 拆成一个个小的组件，相互之间不直接引用。那如何做呢？ 二、实现方式1、组件间通信 以 iOS 为例，由于之前就是采用的 URL 跳转模式，理论上页面之间的跳转只需 open 一个 URL 即可。所以对于一个组件来说，只要定义「支持哪些 URL」即可，比如详情页大概可以这么做： [MGJRouter registerURLPattern:@”mgj://detail?id=:id” toHandler:^(NSDictionary * routerParameters) { NSNumber * id = routerParameters\\[@&quot;id&quot;\\]; // create view controller with id, push view controller. 以 id 来创建 vc }]; 首页只需调用 [MGJRouter openURL:@”mgj://detail?id=404”] 就可以打开相应的详情页。 那问题又来了，我怎么知道有哪些可用的 URL？为此，蘑菇街做了一个后台专门来管理。 然后可以把这些短链生成不同平台所需的文件，iOS 平台生成 .{h,m} 文件，Android 平台生成 .java 文件，并注入到项目中。这样开发人员只需在项目中打开该文件就知道所有的可用 URL 了。（个人理解：第一句的意思是生成包含短链信息的不同平台所需的文件。） 目前还有一块没有做，就是参数这块，虽然描述了短链，但真想要生成完整的 URL，还需要知道如何传参数，这个正在开发中。 还有一种情况会稍微麻烦点，就是「组件A」要调用「组件B」的某个方法，比如在商品详情页要展示购物车的商品数量，就涉及到向购物车组件拿数据。 类似这种同步调用，iOS 之前采用了依托于 MGJRouter 的方案，不过添加了新的方法 - (id)objectForURL:，注册时也使用新的方法进行注册： [MGJRouter registerURLPattern:@”mgj://cart/ordercount” toObjectHandler:^id(NSDictionary * routerParamters) { // do some calculation return @42; }]; 使用时 NSNumber * orderC = [MGJRouter objectForURL:@”mgj://cart/ordercount”] 这样就拿到了购物车里的商品数。 稍微复杂但更具通用性的方法是使用「协议」 「类」绑定的方式，还是以购物车为例，购物车组件可以提供以下协议： @protocol MGJCart + (NSInteger)orderCount; // 获取购物车的商品数 @end 可以看到通过协议可以直接指定返回的数据类型。然后在购物车组件内再新建一个类实现此协议，假设这个类名为MGJCartImpl，将它与协议关联起来： [ModuleManager registerClass:MGJCartImpl forProtocol:@protocol(MGJCart)]; 对于使用方来说，要拿到这个 MGJCartImpl，需要调用： [ModuleManager classForProtocol:@protocol(MGJCart)]; 拿到之后再调用 + orderCount 方法就可以了。 那么，这个协议放在哪里比较合适呢？如果跟组件放在一起，使用时还是要先引入组件，如果有多个这样的组件就会比较麻烦。所以我们把这些公共的协议统一放到了 PublicProtocolDomain.h 下，只依赖这一个文件就可以了。 2、组件生命周期管理 理想中的组件可以很方便地集成到主客中，并且有跟 AppDelegate 一致的回调方法。这也是 ModuleManager 做的事情。 先来看看现在的入口方法： - (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions{ [MGJApp startApp]; // 主要负责一些 SDK 的初始化 \\[\\[ModuleManager sharedInstance\\] loadModuleFromPlist:\\[\\[NSBundle mainBundle\\] pathForResource:@&quot;modules&quot; ofType:@&quot;plist&quot;\\]\\]; NSArray * modules = \\[\\[ModuleManager sharedInstance\\] allModules\\]; for (id&lt;ModuleProtocol&gt; module in modules) { if (\\[module respondsToSelector:_cmd\\]) { \\[module application:application didFinishLaunchingWithOptions:launchOptions\\]; } } \\[self trackLaunchTime\\]; // 用来监测从 main 方法开始到入口方法调用结束花了多长时间 return YES; } loadModuleFromPlist:pathForResource: 方法会读取 bundle 里的一个 plist 文件，这个文件的内容大概是这样的： 每个 Module(模块) 都实现了 ModuleProtocol，其中有一个 - (BOOL)applicaiton:didFinishLaunchingWithOptions: 方法，如果实现了的话，就会被调用。 还有一个问题就是，系统的一些事件会有通知，比如 applicationDidBecomeActive 会有对应的 UIApplicationDidBecomeActiveNotification，组件如果要做响应的话，只需监听这个系统通知即可。但也有一些事件是没有通知的，比如 - application:didRegisterUserNotificationSettings:，这时组件如果也要做点事情，怎么办？ 一个简单的解决方法是在 AppDelegate 的各个方法里，手动调一遍组件对应的方法，如果有就执行。 - (void)application:(UIApplication )application didRegisterForRemoteNotificationsWithDeviceToken:(NSData )deviceToken{ NSArray * modules = [[ModuleManager sharedInstance] allModules]; for (id&lt;ModuleProtocol&gt; module in modules) { if (\\[module respondsToSelector:_cmd\\]) { \\[module application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken\\]; } } } 3、壳工程 既然已经拆出去了，那拆出去的组件总得有个载体，这个载体就是壳工程，壳工程主要包含一些基础组件和业务 SDK，这也是主工程包含的一些内容，所以如果在壳工程可以正常运行的话，到了主工程也没什么问题。不过这里存在版本同步问题，之后会说到。 三、遇到的问题1、组件拆分 由于之前的代码都是在一个工程下的，所以要单独拿出来作为一个组件就会遇到不少问题。首先是组件的划分，当时在定义组件粒度时也花了些时间讨论，究竟是粒度粗点好，还是细点好。粗点的话比较有利于拆分，细点的话灵活度比较高。最终还是选择粗一点的粒度，先拆出来再说。 假如要把详情页迁出来，就会发现它依赖了一些其他部分的代码，那最快的方式就是直接把代码拷过来，改个名使用。比较简单暴力。说起来比较简单，做的时候也是挺有挑战的，因为正常的业务并不会因为「组件化」而停止，所以开发同学们需要同时兼顾正常的业务和组件的拆分。 2、版本管理 组件以及第三方库都是通过 Cocoapods 来管理，其中组件使用了私有库。 之所以选择 Cocoapods，一是因为它比较方便，二是因为用户基数比较大，且社区也比较活跃。当然也有其他的管理方式，如 submodule / subtree。在开发人员比较多的情况下，方便、灵活的方案容易占上风（虽然它也有版本同步和更新/编译慢等问题）。 假如基础组件做了个 API 接口升级，这个升级会对原有的接口做改动，自然就会增加版本号。而我们在 Podfile 里都是用 ~ 指定的，这样就会出现主工程的 pod 版本升上去了，但是壳工程没有同步到，然后就会有各种反馈编译不过，而且有时能拖上两三天。 然后我们就想了个办法，如果不在壳工程里指定基础库的版本，只在主工程里指定呢，理论上应该可行，只要不出现某个基础库要同时维护多个版本的情况。但实践中发现，壳工程有时会莫名其妙地升不上去，在 podfile 里指定最新的版本又可以升上去，所以此路不通。 还有一个问题是 pod update时间过长，经常会在 Analyzing Dependency 上卡 10 多分钟，非常影响效率。后来排查下来是跟组件的 Podspec 有关，配置了 subspec，且依赖比较多。 然后就是 pod update 之后的编译，由于是源码编译，所以这块的时间花费也不少，接下去会考虑 framework 的方式。 四、持续集成在刚开始，持续集成还不是很完善，业务方升级组件，直接把 podspec 扔到 private repo 里就完事了。这样最简单，但也经常会带来编译通不过的问题。而且这种随意的版本升级也不太能保证质量。于是我们就搭建了一套持续集成系统，大概如此： 每个组件升级之前都需要先通过编译，然后再决定是否升级。这套体系看起来不复杂，但在实施过程中经常会遇到后端的并发问题，导致业务方要么集成失败，要么要等不少时间。而且也没有一个地方可以呈现当前版本的组件版本信息。还有就是业务方对于这种命令行的升级方式接受度也不是很高。 基于此，在经过了几轮讨论之后，有了新版的持续集成平台，升级操作通过网页端来完成。 大致思路是，业务方如果要升级组件，假设现在的版本是 0.1.7，添加了一些 feature 之后，壳工程测试通过，想集成到主工程里看看效果，或者其他组件也想引用这个最新的，就可以在后台手动把版本升到 0.1.8-rc.1，这样的话，原先依赖 ~> 0.1.7 的组件，不会升到 0.1.8，同时想要测试这个组件的话，只要手动把版本调到 0.1.8-rc.1 就可以了。这个过程不会触发 CI 的编译检查。 当测试通过后，就可以把尾部的 -rc.n 去掉，然后点击「集成」，就会走 CI 编译检查，通过的话，会在主工程的 podfile 里写上固定的版本号 0.1.8。也就是说，podfile 里所有的组件版本号都是固定的。 五、公共 UI 组件组件化之后还有一个问题就是资源的重复性，以前在一个工程里的时候，资源都可以很方便地拿到，现在独立出去了，也不知道哪些是公用的，哪些是独有的，索性都放到自己的组件里，这样就会导致包变大。 还有一个问题是每个组件可能是不同的产品经理在跟，而他们很可能只关注于自己关心的页面长什么样，而忽略了整体的样式。公共 UI 组件就是用来解决这些问题的，这些组件甚至可以跨 App 使用。（目前还未实现） 六、小结「组件化」是 App 膨胀到一定体积后的解决方案，能一定程度上解决问题，提高开发效率。","tags":[]},{"title":" html 静态资源缓存与更新\t\t","date":"2018-04-03T06:04:22.000Z","path":"2018/04/03/html-e9-9d-99-e6-80-81-e8-b5-84-e6-ba-90-e7-bc-93-e5-ad-98-e4-b8-8e-e6-9b-b4-e6-96-b0/","text":"原文：https://www.2cto.com/kf/201801/710436.html facebook 是这个领域的鼻祖，可以用梯子去看看 facebook 的页面源代码，体会一下什么叫工程化。 接下来，我(原作者)想从原理展开讲述，多图、较长，希望能有耐心看完。 让我们返璞归真，从原始的前端开发讲起。上图是一个 index.html 页面和它的样式文件 a.css。 当访问页面，看到效果，再查看一下网络请求，200 正常！那么，研发完成。。。。了么？ 等等，这还没完呢！对于大公司来说，那些变态的访问量和性能指标，将会让前端一点也不”好玩”。 看看那个 a.css 的请求吧，如果每次用户访问页面都要加载，是不是很影响性能，很浪费带宽啊，我们希望最好这样： 利用 304 让浏览器使用本地缓存。但这样也就够了吗？不成！304 叫协商缓存，这玩意还是要和服务器通信一次，我们的优化级别是变态级，所以必须彻底灭掉这个请求，变成这样： 强制浏览器使用本地缓存 (cache-control/expires)，不要和服务器通信。好了，请求方面的优化已经达到变态级别，那问题来了：你都不让浏览器发资源请求了，这缓存咋更新？ 很好，相信有人想到了办法：通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。好像这样： 下次上线时把链接地址改成新的版本，就更新资源了。OK，问题解决了么？当然没有！大公司的变态又来了，思考这种情况： 页面引用了 3 个 css，而某次上线只改了其中的 a.css，如果所有链接都更新版本，就会导致 b.css、c.css 的缓存也失效，那岂不是又有浪费了？！ 重新开启变态模式。我们不难发现，要解决这种问题，必须让 url 的修改与文件内容关联，也就是说，只有文件内容变化，才会导致相应 url 的变更，从而实现文件级别的精确缓存控制。 什么东西与文件内容相关呢？很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。好了，我们把 url 改成带摘要信息的： 这回再有文件修改，就只更新那个文件对应的 url 了，想到这里貌似很完美了。你觉得这就够了么？大公司告诉你：图样图森破！ 现代互联网企业，为了进一步提升网站性能，会把静态资源和动态网页分集群部署，静态资源会被部署到CDN 节点上，网页中引用的资源也会变成对应的部署路径： 好了，当我要更新静态资源的时候，同时也会更新 html 中的引用吧，就好像这样： 这次发布，同时改了页面结构和样式，也更新了静态资源对应的 url 地址，现在要发布代码上线，亲爱的前端研发同学，你来告诉我，咱们是先上线页面，还是先上线静态资源？ 先部署页面，再部署资源：在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。 先部署资源，再部署页面：在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。 好的，上面想说的就是：先部署谁都不成！都会导致部署过程中发生页面错乱的问题。所以，访问量不大的项目，可以让研发同学苦逼一把，等到半夜偷偷上线，先上静态资源，再部署页面，看起来问题少一些。 但是，大公司超变态，没有这样的”绝对低峰期”，只有”相对低峰期”。So，为了稳定的服务，还得继续追求极致啊！ 这个奇葩问题，起源于资源的覆盖式发布，用待发布资源覆盖已发布资源，就有这种问题。解决它也好办，就是实现非覆盖式发布。 看上图，用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面，整个问题就比较完美的解决了。 所以，大公司的静态资源优化方案，基本上要实现这么几个东西： 1、配置超长时间的本地缓存 —— 节省带宽，提高性能 2、采用内容摘要作为缓存更新依据 —— 精确的缓存控制 3、静态资源 CDN 部署 —— 优化网络请求 4、更资源发布路径实现非覆盖式发布 —— 平滑升级 全套做下来，就是相对比较完整的静态资源缓存控制方案了，而且，还要注意的是，静态资源的缓存控制要求在前端所有静态资源加载的位置都要做这样的处理 。是的，所有！什么 js、css 自不必说，还要包括js、css 文件中引用的资源路径，由于涉及到摘要信息，引用资源的摘要信息也会引起引用文件本身的内容改变，从而形成级联的摘要变化，大概示意图就是：","tags":[]},{"title":" SVProgressHUD\t\t","date":"2018-03-20T11:06:24.000Z","path":"2018/03/20/svprogresshud/","text":"原文：http://blog.csdn.net/thanklife/article/details/78150398 SVProgerssHUD 是一款由第三方提供的等待视图控件。常见用于发起请求之后，页面数据加载完成之前这段时间的界面展示，可以阻隔用户的交互操作。 使用的场景： 比较合理的场景是用户操作之前确定需要执行其他任务的时候，而不是在刷新、无限的滑动或者发送消息等场景。 一、SVPIndefiniteAnimatedView 无限旋转视图组件 原理：不断地旋转一张具有渐变颜色的图片。通过设置 layer 层的 mask 来遮住不需要的部分。 下面先讲一讲 iOS 动画中的 CALayer 以及 Mask。常见的场景就是通过 CAShapeLayer 和 mask 结合使用。 /* A layer whose alpha channel is used as a mask to select between the * layer’s background and the result of compositing the layer’s * contents with its filtered background. Defaults to nil. When used as * a mask the layer’s `compositingFilter’ and `backgroundFilters’ * properties are ignored. When setting the mask to a new layer, the * new layer must have a nil superlayer, otherwise the behavior is * undefined. Nested masks (mask layers with their own masks) are * unsupported. /@property (nullable, strong) CALayer mask; 以上是 CALayer 的头文件关于 mask 的说明，mask 实际上 layer 内容的一个遮罩。 如果把 mask 设置为透明的，那么实际看到的 layer 也会是完全透明的，也就是说只有 mask 不透明的内容和 layer 的叠加部分才会显示。如下图： 有许多很炫酷的动画效果都是通过这样实现的。比如： 组件的绘制由 willMoveToSuperview: 方法触发。其中整个显示图层采用的是懒加载方式，在更新参数之后，直接修改图层的绘制属性或者重新绘制。 UIBezierPath smoothedPath = [UIBezierPath bezierPathWithArcCenter:arcCenter radius:self.radius startAngle:(CGFloat)(M_PI3/2) endAngle:(CGFloat)(M_PI/2 + M_PI*5) clockwise:YES]; // 圆环_indefiniteAnimatedLayer = [CAShapeLayer layer];… // 设置图层参数_indefiniteAnimatedLayer.path = smoothedPath.CGPath; // 初始化 mask, 从资源库中读取图片，将图片设置为 maskLayer 的 contentsCALayer * maskLayer = [CALayer layer];…maskLayer.contents = (__bridge id)[[UIImage imageWithContentsOfFile:path] CGImage];maskLayer.frame = _indefiniteAnimatedLayer.bounds;_indefiniteAnimatedLayer.mask = maskLayer; // 动画：1、图片旋转 2、动画组，处理圆环转圈圈。两个动画的时间相同CABasicAnimation * animation = [CABasicAnimation animationWithKeyPath:@”transform.rotation”]; …animation.removedOnCompletion = NO;animation.repeatCount = INFINITY; // 很大的数…[_indefiniteAnimatedLayer.mask addAnimation:animation forKey:@”rotate”]; CAAnimationGroup animationGroup = [CAAnimationGroup animation];// strokeStart 动画CABasicAnimation strokeStartAnimation = [CABasicAnimation animationWithKeyPath:@”strokeStart”];strokeStartAnimation.fromValue = @0.015;strokeStartAnimation.toValue = @0.515;// strokeEnd 动画CABasicAnimation * strokeEndAnimation = [CABasicAnimation animationWithKeyPath:@”strokeEnd”];strokeEndAnimation.fromValue = @0.485;strokeEndAnimation.toValue = @0.985;// 将动画加到动画组animationGroup.animations = @[strokeStartAnimation, strokeEndAnimation];[_indefiniteAnimatedLayer addAnimation:animationGroup forKey:@”progress”]; 可以仔细考虑 strokeStart 的执行时间 0.015~0.515 和 strokeEnd 的执行时间 0.485~0.985 的巧妙，可以通过修改数值来看效果。 其他的内容就是懒加载和 setter 方法。 二、SVProgressAnimatedView 进度视图组件用于处理进度的视图组件，实现进度的原理就是不断改变 strokeEnd 的值。 .m 文件的实现大致和 SVIndefiniteAnimatedView 一样。在 willMoveToSuperview: 方法中添加 layer。实现进度的关键就是重写 strokeEnd 属性的 setter 方法。 - (void)setStrokeEnd:(CGFloat)strokeEnd{ … \\_ringAnimatedLayer.strokeEnd = \\_strokeEnd; } 三、SVProgressHUD 管理类这个类相当于管理类的作用，负责和外部交互和调用视图组件。进行重要逻辑判断。 .h 文件 5 个通知的 name 值： DidReceiveTouchEventNotification 接收点击事件通知DidTouchDownInsideNotification 按下通知WillAppearNotification 控件即将显示的通知DidAppearNotification 控件已经显示的通知WillDisappearNotification 控件即将消失的通知DidDisappearNotification 控件已经消失的通知 SVProgressHUDStatusUserInfoKey 获取通知传递的数据的 key 值 3 个样式枚举值： SVProgressHUDStyle Light(白色控件，黑色文本)、Dark(黑色控件，白色文本)、Custom(自定义前景色和背景色) 5 个 mask 类型枚举值： SVProgressHUDMaskType None(允许交互)、Clear | Black | Gradient | Custom(不允许交互) 2 个转圈样式枚举值： SVProgressHUDAnimationType Flat(自定义的转圈动画)、Native(系统的菊花动画) UI_APPEARANCE_SELECTOR: 用于外观属性。遵守 UIAppearance 协议的类可以通过 appearance 实例方法调用属性。实例说明： [[UIBarButtonItem appearance] setTintColor:[UIColor redColor]]; 可以定制应用中所有条形按钮的颜色为 redColor。没有它之前，只能一个个的去修改控件，现在可以批量设置控件的颜色了。深入了解可以看看使用UIAppearance协议自定义视图 属性： containerView 父视图(容器)，如果为空使用默认窗口(default window level) 类方法： 一种是 setXX 一种是 showXX。前者用于设置外观样式，后者是直接使用的方式。 __attribute__((deprecated(“Use XX: and YY: instead.”))) // 注意废弃方法的写法 .m文件 常量的定义： 可以查查 define 和 static const 定义常量的区别。提醒一下，尽量用 static const 来定义更符合风格吧。 readonly 及 getter 的使用。虽然这样的用法有些麻烦，对于有强迫症的程序员还是蛮推荐这种写法的 @property (nonatomic, readonly, getter = isClear) BOOL clear; - (BOOL)isClear // 自定义 getter 方法名{ return …;} 事先定义好私有方法，也就是外界不能直接调用的实例方法 使用单例： 常见的一些关于 UI 的第三方都是通过类方法调用，而且全局可以只用一个实例对象来维护。 + (SVProgressHUD )sharedView{ static dispatch_once_t once; static SVProgressHUD sharedView; #if !defined(SV_APP_EXTENSIONS) // 创建单例对象。设置 frame dispatch_once( &amp;once, ^{ sharedView = [[self alloc] initWithFrame:[[[UIApplication sharedApplication] delegate] window].bounds]; }); #else dispatch_once( &amp;once, ^{ sharedView = [[self alloc] initWithFrame:[[UIScreen mainScreen] bounds]]; }); #endif return sharedView;} 图层： 黄色图层：controlView 白色图层：SVProgressHUD 绿色图层：backgroundView 红色图层：hudView(包括透明的) 橙色图层：indefiniteAnimatedView(左图) 具体可以查看代码，或者设置颜色查看图层 show 方法参数化： 方法的参数化就是为了实现代码的复用。因为有存在相同的逻辑，则把相同部分抽离出来，不同的部分通过传入不同参数来控制来达到代码的复用。在实际工作中，这一点也非常重要。 经过整理，最终得出所有调用 showXX 方法最终调用的只有两个方法： 1、+ (void)showProgress:(float)progress status:(NSString *)status // 当显示的是无限旋转提示的时候，会传入 progrerss = -1 来区别显示进度的样式。[self showProgress:SVProgressHUDUndefinedProgress status:status]; // SVProgressHUDUndefinedProgress = -1; 这里需要提一提的是，设置遮罩样式没有通过参数传递来设置而是通过设置属性的方式来做的。 { // 设置新的遮罩样式 [self setDefaultMaskType:maskType]; … // 显示完后回到默认的遮罩样式 [self setDefaultMaskType:existingMaskType];} 简单分析一下不通过参数来传递遮罩样式的原因应该是为了每次显示完之后保证下一次遮罩的样式依然是默认的样式。可以看到每次调用完 showXX 之后都会把 mask 恢复到默认值。 下面分析实际操作的过程： - (void)showProgress:(float)progress status:(NSString )status{ __weak SVProgressHUD weakSelf = self; // 与 __strong 结合处理循环引用问题 \\[\\[NSOperationQueue mainQueue\\] addOperationWithBlock:^{ __strong SVProgressHUD * strongSelf = weakSelf; if(strongSelf){ if(strongSelf.fadeOutTimer) { // 如果正处于隐藏阶段，设置活动数量为 0 strongSelf.activityCount = 0; } strongSelf.graceTimer = nil; // 淡入等待时的计时器，执行 fadeIn: strongSelf.fadeOutTimer = nil; // 淡出等待时的计时器，执行 dismiss // 检查和更新视图的层级以确保 HUD 能够显示。见下面解释 \\[strongSelf updateViewHierarchy\\]; strongSelf.imageView.hidden = YES; strongSelf.imageView.image = nil; // 隐藏掉图片。与旋转 ring 互斥 strongSelf.statusLabel.hidden = status.length == 0; strongSelf.statusLabel.text = status; // 设置文本信息 strongSelf.progress = progress; // 设置当前进度 // 如果进度数值大于 0，说明当前使用进度圆环，移除无限旋转动画 if (progress &gt;= 0) { \\[strongSelf cancelIndefiniteAnimatedViewAnimation\\]; // 开启进度，修改 strokeEnd 属性 \\[CATransaction begin\\]; \\[CATransaction setDisableActions:YES\\]; strongSelf.ringView.strokeEnd = progress; \\[CATransaction commit\\]; } else { \\[strongSelf cancelRingLayerAnimation\\]; \\[(id)strongSelf.indefiniteAnimatedView startAnimating\\]; } } // 添加淡入定时器 if (self.graceTimeInterval &gt; 0.0 &amp;&amp; self.backgroundView.alpha == 0.0f) { \\[... selector:@selector(fadeIn:) userInfo:nil repeats:NO\\] \\[\\[NSRunLoop mainRunLoop\\] addTimer:strongSelf.graceTimer forMode:NSRunLoopCommonModes\\]; } else { \\[strongSelf fadeIn:nil\\]; } // Tell the Haptics Generator to prepare for feedback, which may come soon #if TARGET_OS_IOS &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000 if (@available(iOS 10.0, *)) { [strongSelf.hapticGenerator prepare]; } #endif } }];} 2、+ (void)showImage:(UIImage )image status:(NSString )status 显示信息后自动消失。最终调用的方法为 -showImage:status:duration:, 显示的时长： + (NSTimeInterval)displayDurationForString:(NSString )string{ CGFloat minimum = MAX((CGFloat)string.length 0.06 + 0.5, [self sharedView].minimumDismissTimeInterval); // 显示时间根据文本长度来判断 return MIN(minimum, \\[self sharedView\\].maximumDismissTimeInterval); } 每次调用方法之后，在系统 iOS 10 以后的手机上，触发振动效果： #if TARGET_OS_IOS &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000 if (@available(iOS 10, *)) { // 只有 iOS10 及以上能执行 dispatch_async(dispatch_get_main_queue(), ^{ // 进入主线程 \\[... notificationOccurred:UINotificationFeedbackTypeSuccess\\]; }); // 发送&quot;警告&quot;振动反馈通知。其它的还有：success、error 通知 } #endif 下面分析实际操作 UI 的方法： - (void)showImage:(UIImage )image status:(NSString )status duration:(NSTimeInterval)duration{ __weak SVProgressHUD * weakSelf = self; // 与 __strong 结合处理循环引用问题 \\[\\[NSOperationQueue mainQueue\\] addOperationWithBlock:^{ __strong SVProgressHUD * strongSelf = weakSelf; if (strongSelf) { strongSelf.fadeOutTimer = nil; // 淡出等待时的计时器，执行 dismiss strongSelf.graceTimer = nil; // 淡入等待时的计时器，执行 fadeIn: /* 检查和更新视图的层级以确保 HUD 能够显示 内部逻辑：1、_controlView存在父视图 -》移至父视图最上层 2、_controlView不存在父视图 ①、开发人员自定的 _containerView 存在，设为父视图; ②、开发人员没有定义宏 SV\\_APP\\_EXTENSIONS，使用指定窗口; ③、定义了宏，使用开发人员自定义的 viewForExtension */ \\[strongSelf updateViewHierarchy\\]; strongSelf.progress = SVProgressHUDUndefinedProgress; // 重设进度 \\[strongSelf cancelRingLayerAnimation\\]; // 取消进度圆环的动画 \\[strongSelf cancelIndefiniteAnimatedViewAnimation\\];// 取消无限旋转圆环的动画 /\\* 需要统一设置图片的颜色。那么图片的绘制模式需要设置为 Template */ if (self.shouldTintImages) { { \\[image imageWithRenderingMode:...AlwaysTemplate\\]; } strongSelf.imageView.tintColor = ...; } else { strongSelf.imageView.image = image; } strongSelf.imageView.hidden = NO; // 设置、显示/隐藏文本 strongSelf.statusLabel.hidden = status.length == 0; strongSelf.statusLabel.text = status; // Fade in delayed if a grace time is set // An image will be dismissed automatically. Thus pass the duration as userInfo. // 淡入等待时间大于 0 &amp; 当前 HUD 是隐藏状态 -》设置定时器，展示淡入动画 if (self.graceTimeInterval &gt; 0.0 &amp;&amp; self.backgroundView.alpha == 0.0f) { \\[... @selector(fadeIn:) userInfo:@(duration) repeats:NO\\]; \\[\\[NSRunLoop mainRunLoop\\] addTimer:strongSelf.graceTimer forMode:NSRunLoopCommonModes\\]; } else { \\[strongSelf fadeIn:@(duration)\\]; // 直接执行淡入动画 } } }\\]; } dismiss 方法参数化： 最终调用 + (void)dismissWithDelay:completion: 方法。 - (void)dismissWithDelay:(NSTimeInterval)delay completion:(…)completion{ __weak SVProgressHUD * weakSelf = self; \\[\\[NSOperationQueue mainQueue\\] addOperationWithBlock:^{ __strong SVProgressHUD * strongSelf = weakSelf; if (strongSelf) { strongSelf.graceTimer = nil; \\[\\[NSNotificationCenter defaultCenter\\] postNotificationName:SVProgressHUDWillDisappearNotification object:nil userInfo:\\[strongSelf notificationUserInfo\\]\\]; // 即将消失的通知 // Reset activity count strongSelf.activityCount = 0; // 动画完成时的状态回调 __block void (^ animationsBlock)(void) = ^{ // 缩小 loading 视图的大小 strongSelf.hudView.transform = CGAffineTransformScale(strongSelf.hudView.transform, 1/1.3f, 1/1.3f); // Fade out all effects (colors, blur, etc.) \\[strongSelf fadeOutEffects\\]; }; // 动画完成时的回调 __block void (^ completionBlock)(void) = ^{ // 确保界面已经隐藏，取消所有动画，为下一次 show 做准备 if (self.backgroundView.alpha == 0.0f){ \\[strongSelf.controlView removeFromSuperview\\];\\[strongSelf.backgroundView removeFromSuperview\\]; \\[strongSelf.hudView removeFromSuperview\\]; \\[strongSelf removeFromSuperview\\]; strongSelf.progress = SVProgressHUDUndefinedProgress; \\[strongSelf cancelRingLayerAnimation\\]; \\[strongSelf cancelIndefiniteAnimatedViewAnimation\\]; \\[\\[NSNotificationCenter defaultCenter\\] removeObserver:...\\]; \\[\\[NSNotificationCenter defaultCenter\\] postNotificationName:SVProgressHUDDidDisappearNotification object:strongSelf userInfo:\\[strongSelf notificationUserInfo\\]\\]; // 发送已经隐藏的通知 // Tell the rootViewController to update the StatusBar appearance #if !defined(SV_APP_EXTENSIONS) &amp;&amp; TARGET_OS_IOS [rootController setNeedsStatusBarAppearanceUpdate]; #endif if (completion) { completion(); } } }; dispatch\\_time\\_t dipatchTime = dispatch\\_time(DISPATCH\\_TIME\\_NOW, (int64\\_t)(delay * NSEC\\_PER\\_SEC)); dispatch\\_after(dipatchTime, dispatch\\_get\\_main\\_queue(), ^{ if (strongSelf.fadeOutAnimationDuration &gt; 0) { \\[UIView animateWithDuration:strongSelf.fadeOutAnimationDuration delay:0 options:option animations:^{ animationsBlock(); } completion:^(BOOL finished) { completionBlock(); }\\]; } else { animationsBlock(); completionBlock(); } }); \\[strongSelf setNeedsDisplay\\]; } }\\]; } 四、UIAccessibilityUIAccessibility 协议用于让外界程序了解到自身的执行情况。Accessibility 是一个交互协议，基于查询 应答，通知 监听模型的协议。外部程序通过查询来获取 APP 应答，从而了解程序。另外通过监听来自 APP 的消息，来通知用户当前状态。 UIAccessibility 是在 UIKit 里的一个非正式协议，提供关于 UI 元素的辅助功能信息。这个信息能够通过 VoiceOver(iOS11为”旁白”) 和其他辅助科技帮助肢体障碍者用户与 App 进行交互。 在 UIKit 里的所有标准视图和控件都实现了 UIAccessibility 协议，所以你的应用默认是可以被肢体障碍者使用的。于是提高你应用的肢体障碍者可用性其实只需要一些细微的调整，而不必全盘重新实现。 1、常用的协议与元素包括： UIAccessibility 核心协议。UIAccessibilityAction 添加行为的协议。 UIAccessibilityElement 类。UIAccessibilityContainer 容器协议。 2、常用函数 UIAccessibilityPostNotification。 可以看到 SVProgressHUD 支持 UIAccessibility self.accessibilityIdentifier = @”SVProgressHUD”;self.accessibilityLabel = @”SVProgressHUD”;self.isAccessibilityElement = YES; 官方介绍： UIAccessibility is implemented on all standard UIKit views and controls so that assistive applications can present them to users with disabilities. Custom items in a user interface should override aspects of UIAccessibility to supply details where the default value is incomplete. For example, a UIImageView subclass may need to override accessibilityLabel, but it does not need to override accessibilityFrame. A completely custom subclass of UIView might need to override all of the UIAccessibility methods except accessibilityFrame. 官方地址：https://developer.apple.com/documentation/uikit/accessibility/uiaccessibility iOS 辅助功能编程指南、参考文章 五、SVProgressHUD 的缺点依次发起两个请求 A 和请求 B，请求 A 和 请求 B 都需要 show loading。因为 SVProgressHUD 某一时刻只能显示一个视图，所以会显示请求 B 的 loading 视图，当请求完成时都执行 dismiss。请求的过程异步的，无法知道先来后到的顺序，很可能请求 A 先完成，执行了 dismiss，将与自己不匹配的 loading 视图给隐藏，导致界面出现空白，然而此时请求 B 还未完成。 SVProgressHUD 只显示一个 loading 视图的机制是合理的，且不大好更改。所以将修改的目光转向 dismiss 方法的执行。 既然只显示一个 loading 视图，那必然是显示最后一个 show 出来的，此时可以思考是否用一个 key 值作为判断条件，每次 show 时重置 SVProgressHUD 的 key 参数，如果当前 dismiss 的 key 值与当前 SVProgressHUD 保存的 key 不匹配，dismiss 操作无效；如果匹配，那么可以隐藏。 在上面的基础上思考一下，如果某一个很重要的 loading，不希望被别人覆盖掉，希望一直显示直到自己来 dismiss，那么该怎么处理？ 这里可以使用设置优先级的方法来处理。 一般的 loading 的优先级设为很低，想长期保持的优先级设为大的数值。在显示 loading 的时候，永远显示最高优先级的。 .h 文件 typedef NS_ENUM(NSUInteger, SVProgressHUDPriority) { SVProgressHUDPriorityDefault = 0, // default SVProgressHUDPriorityLow = 1, SVProgressHUDPriorityMid = 500, SVProgressHUDPriorityHigh = 1000,}; @property (assign, nonatomic) SVProgressHUDPriority svPriorty;// 设置优先级。(方法可以优化)+ (void)setSVPriority:(SVProgressHUDPriority)priority;// 需要匹配时调用，如果只是普通的 loading 视图，可以调用 dismiss+ (void)dismissWithPriority:(SVProgressHUDPriority)priority; .m 文件 @property (nonatomic, readwrite) BOOL isGreaterPriority; // 当前有更大优先级的需要显示 - (instancetype)initWithFrame:(CGRect)frame{ if((self = [super initWithFrame:frame])) { _isGreaterPriority = NO; _svPriorty = SVProgressHUDPriorityDefault; }} + (void)setSVPriority:(SVProgressHUDPriority)priority{ // 设置上限为 1000 if (priority &gt; SVProgressHUDPriorityHigh) { priority = SVProgressHUDPriorityHigh; } // 如果设置的优先级大于/等于当前的优先级，则重新设置 if (\\[self sharedView\\].svPriorty &lt;= priority) { \\[self sharedView\\].isGreaterPriority = YES; \\[self sharedView\\].svPriorty = priority; } else { \\[self sharedView\\].isGreaterPriority = NO; } } + (void)showProgress:(float)progress status:(NSString *)status{ // 当前为非默认(default)的优先级 &amp;&amp; 当前优先级没有比上一次更大 if ( [self sharedView].svPriorty != SVProgressHUDPriorityDefault &amp;&amp; [self sharedView].isGreaterPriority == NO) return; \\[self sharedView\\].isGreaterPriority = NO; \\[\\[self sharedView\\] showProgress:progress status:status\\]; } /// 根据优先级来 dismiss+ (void)dismissWithPriority:(SVProgressHUDPriority)priority{ if ([self sharedView].svPriorty == priority) { [[self sharedView] dismissWithDelay:0.0 completion:nil]; [self sharedView].svPriorty = SVProgressHUDPriorityDefault; }} /// 如果当前有优先级高的 loading 在显示，不能调用 dismiss+ (void)dismissWithDelay:(NSTimeInterval)delay completion:(SVProgressHUDDismissCompletion)completion{ if ([self sharedView].svPriorty == SVProgressHUDPriorityDefault) { [[self sharedView] dismissWithDelay:delay completion:completion]; }} 目前这些可以解决一些问题，代码还可以完善。","tags":[]},{"title":" NSData + ImageContentType\t\t","date":"2018-03-19T09:59:00.000Z","path":"2018/03/19/nsdata-imagecontenttype/","text":"参考文章：http://www.cnblogs.com/machao/p/6126826.html typedef NS_ENUM(NSInteger, SDImageFormat) { SDImageFormatUndefined = -1, JPEG = 0, PNG, GIF, TIFF, WebP, HEIC }; 图片格式。是 SDWebImage 自定义的枚举类型，与系统的类型相对应。 文件头 文件头是位于文件开头的一段承担一定任务的数据。一般都在开头的部分。 文件头和 C 语言中的头文件读起来很像，但这两个东西没有一点关系：头文件是一种包含功能函数、数据接口声明的载体文件；而文件头则是直接位于文件中的一段数据，是文件的一部分。 说的简单一点就是：当文件都使用二进制流作为传输时，需要制定一套规范，用来区分该文件到底是什么类型的。 在这里只介绍一些主流的且跟图片相关的文件头： JPEG 文件头：FFD8FFE1 PNG 文件头：89504E47 GIF 文件头：47494638 TIFF 文件头：0x49492A00 / 0x4D4D002A RAR Archive 文件头：52617221 WebP 文件头：524946462A73010057454250 可以看出来我们通过每个文件头的第一个字节就能判断出是什么类型。但是值得注意的是 52 开头的，这个要做特别的判断。 WebP 这种格式很特别，是由 12 个字节组成的文件头，我们如果把这些字节通过 ASCII 编码后会得到下边这样一张表格： + (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data { if (!data) { return SDImageFormatUndefined; } // File signatures table: http://www.garykessler.net/library/file_sigs.html 文件头文档 uint8_t c; [data getBytes:&amp;c length:1]; switch (c) { case 0x89: return SDImageFormatPNG; case 0x47: return SDImageFormatGIF; case 0xFF: return SDImageFormatJPEG; case 0x49: case 0x4D: return SDImageFormatTIFF; case 0x52: { if (data.length &gt;= 12) { // WebP 的特殊判断RIFF…WEBP NSData * cTypeData = [data subdataWithRange:NSMakeRange(0, 12)]; NSString * cType = [[NSString alloc] initWithData:cTypeData encoding:NSASCIIStringEncoding]; if ([cType hasPrefix:@”RIFF”] &amp;&amp; [cType hasSuffix:@”WEBP”]) { return SDImageFormatWebP; } } break; } case 0x00: { if (data.length &gt;= 12) { NSData * cTypeData = [data subdataWithRange:NSMakeRange(4, 8)]; NSString * cType = [[NSString alloc] initWithData:cTypeData encoding:NSASCIIStringEncoding]; // ….ftypheic ….ftypheix ….ftyphevc ….ftyphevx if ( [cType isEqualToString:@”ftypheic”] || [cType isEqualToString:@”ftypheix”] || [cType isEqualToString:@”ftyphevc”] || [cType isEqualToString:@”ftyphevx”]) { return SDImageFormatHEIC; } } break; } } return SDImageFormatUndefined; } JPEG/PNG/GIF/TIFF 是最好判断的。当第一个字节为 52 时，如果长度 12 且数据头部包含 RIFF、尾部也包含 WEBP，那么就认定该图片格式为 webp。 演示 下面是 webp 图片文件的二进制内容： —–image/webp——&lt;52494646 72370000 57454250 56503858 0a000000 10000000 190200bd 0000414c 50484711 00000187 40906d33 83cd9ff7 778888a4 b3e53068 db4650c2 9f747a77 ff1822fa 9f927ff8 9224460e c3301c46 86216224 932431e6 1f5edfb6 6dd76d6c db56c195 20884bfb ffaf959d c214d01a 39e6f521 a2ffe95b b6edbaad 6ddb2a20 c03b40e4 ffffdade fbb0500b 2ddb2146 8c8788fe a7feff26 7ecae76a 9f2e77a3 fd9ce513 3ffc8fdd a7d286ec b65aa2d3 b3f6c735 44ef3ad6 ac879cce 21fafd58 929e6eac 53ccce25 e9c33bb8 d779b52f 438ccf59 9fdcc1bd ee7871ac f284be4f fad40eee 75c77b63 93b5d1ca 27de1de5 6c4376cf a28fece0 5e77bc36 3659b94a 64311e75 c8562dfa bc0eee75 c75b4393 efb32636 c3d165a7 167d5807 f7bae3a5 aecaf72b a1e28f21 1bb5e893 3ab8d71d 2f5da67c 9ba7472f 36d93892 3ea6a58e 30a6e39d 53e56b71 其中 52494646 72370000 57454250 正好占用了 12 字节。正好符合上边解释的 webp 文件头。 + (nonnull CFStringRef)sd_UTTypeFromSDImageFormat:(SDImageFormat)format 将 SDWebImage 自定义的枚举值与系统枚举值对应起来。默认是 PNG。 kUTTypeJPEG kUTTypePNG kUTTypeGIF kUTTypeTIFF kSDUTTypeWebP kSDUTTypeHEIC #define kSDUTTypeHEIC ((__bridge CFStringRef)@”public.heic”) #define kSDUTTypeWebP ((__bridge CFStringRef)@”public.webp”)","tags":[]},{"title":" SDWebImage\t\t","date":"2018-03-19T03:46:27.000Z","path":"2018/03/19/778/","text":"一、SDWebImageCompat原文：https://www.cnblogs.com/machao/p/6137517.html 该配置文件主要是兼容 Apple 的其他设备。也许真实的开发平台只有一个，但还是需要考虑各个平台的兼容性，这对于框架有着很重要的意义。这些用法能够在项目开发中提高效率。 #ifdef __OBJC_GC__ #error SDWebImage does not support Objective-C Garbage Collection #endif __OBJC_GC__表示宏内引用的文件确保只被使用 Objective-C 语言的文件所引用，保证引用关系的清晰。 SDWebImage 不支持垃圾回收机制，垃圾回收(Gargage-collection)是 Objective-C 提供的一种自动内存回收机制。当启动这个功能后，所有的 retain、autorelease、release 和 dealloc 方法都将被系统忽略。 #if !TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_IOS &amp;&amp; !TARGET_OS_TV &amp;&amp; !TARGET_OS_WATCH #define SD_MAC 1 #else #define SD_MAC 0 #endif Apple’s defines from TargetConditionals.h are a bit weird. Seems like TARGET_OS_MAC is always defined (on all platforms). To determine if we are running on OSX, we can only rely on TARGET_OS_IPHONE=0 and all the other platforms. 用于判断当前平台是不是 MAC。因为 TARGET_OS_MAC 在 TargetConditionals.h 文件中总是被定义，所以单纯使用 TARGET_OS_MAC 是不靠谱的，那么可以根据举反的方式来判断。当然这样判断的缺点是：当 Apple 出现新的平台时，判断条件要修改。 #if TARGET_OS_IOS || TARGET_OS_TV #define SD_UIKIT 1 #else #define SD_UIKIT 0 #endif iOS and tvOS are very similar, UIKit exists on both platforms. Note: watchOS also has UIKit, but it’s very limited. 用于判断当前平台是不是 iOS 和 tvOS。iOS 和 tvOS 平台非常相似，这两个平台中都存在 UIKit，watchOS 也有 UIKit，但是使用是受限的。 #if TARGET_OS_IOS #define SD_IOS 1 #else #define SD_IOS 0 #endif #if TARGET_OS_TV #define SD_TV 1 #else #define SD_TV 0 #endif #if TARGET_OS_WATCH #define SD_WATCH 1 #else #define SD_WATCH 0 #endif 用于判断当前平台是不是 iOS/tvOS/watchOS 平台。 #if SD_MAC #import &lt;AppKit/AppKit.h&gt; #ifndef UIImage #define UIImage NSImage // mac 平台下UIImage -&gt; NSImage #endif #ifndef UIImageView #define UIImageView NSImageView // mac 平台下UIImageView -&gt; NSImageView #endif #ifndef UIView #define UIView NSView // mac 平台下UIView -&gt; NSView #endif #else #if __IPHONE_OS_VERSION_MIN_REQUIRED !=20000 &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_5_0 // SDWebImage 不支持5.0 以下的iOS 版本 #error SDWebImage doesn’t support Deployment Target version &lt; 5.0 #endif #if SD_UIKIT #import &lt;UIKit/UIKit.h&gt; #endif #if SD_WATCH #import &lt;WatchKit/WatchKit.h&gt; #endif #endif #ifndef NS_ENUM #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #endif #ifndef NS_OPTIONS #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif 实际上是将 enum 定义和typedef 合二为一，并且采用不同的宏来从代码角度来区分。NS_OPTIONS 一般用来定义位移相关操作的枚举值。 这两个宏的定义在 Foundation.framework 的NSObjCRuntime.h 中： #if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum)) #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #if (__cplusplus) #define NS_OPTIONS(_type, _name) _type _name; enum : _type #else #define NS_OPTIONS(_type, _name) enum _name : _type _name; enum _name : _type #endif #else #define NS_ENUM(_type, _name) _type _name; enum #define NS_OPTIONS(_type, _name) _type _name; enum #endif 将 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { 展开得到： typedef enum UIViewAnimationTransition : NSInteger UIViewAnimationTransition; enum UIViewAnimationTransition : NSInteger { 从枚举定义来看，NS_ENUM 和 NS_OPTIONS 本质是一样的，仅仅从字面上来区分其用途。NS_ENUM 是通用情况，NS_OPTIONS 一般用来定义具有位移操作或特点的情况(bitmask)。 #ifndef dispatch_queue_async_safe #define dispatch_queue_async_safe(queue, block)\\ if ( strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(queue)) == 0) {\\ block();\\ }\\ else {\\ dispatch_async(queue, block);\\ } #endif #ifndef dispatch_main_async_safe #define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block) #endif 按理说使用 dispatch_main_async 就可以了，为什么要加入 safe 呢？ 可以像这样在定义宏的时候使用换行，但需要添加 \\ 操作符 如果当前线程已经是主线程了，那么在调用 dispatch_async(dispatch_get_main_queue(), block) 有可能会出现 crash 如果当前线程是主线程，直接调用；如果不是则调用 dispatch_async(dispatch_get_main_queue(), block) #if !__has_feature(objc_arc) #error SDWebImage is ARC only. Either turn on ARC for the project or use -fobjc-arc flag #endif 用于判断当前是 MRC 环境。SDWebImage 只能在 ARC 环境中使用。 #if !OS_OBJECT_USE_OBJC #error SDWebImage need ARC for dispatch object #endif 首先看下 OS_OBJECT_USE_OBJC 宏定义常见用处： #if OS_OBJECT_USE_OBJC @property (strong, nonatomic) dispatch_queue_t barrierQueue; #else@property (assign, nonatomic) dispatch_queue_t barrierQueue; #endif 这段代码表示 GCD 中的对象在 6.0 之前是不参与ARC的，6.0 之后在 ARC 模式下使用 GCD 也不用关心释放问题。 6.0 版本之前，在 dealloc 方法中应该加上： #if !OS_OBJECT_USE_OBJC // 在 sdk6.0 之前OS_OBJECT_USE_OBJC 为0 dispatch_release(_barrierQueue); #endif 当然了，也可以使用： #if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; 60000 // sdk6.0 之前 dispatch_release(_barrierQueue); #endif 这里的宏 __IPHONE_OS_VERSION_MIN_REQUIRED 就是工程的设置项里设置的最低部署 sdk 版本。 在 sdk &lt; 6.0 的时候,即使我们开启了 ARC，这个宏 OS_OBJECT_USE_OBJC 也是没有的，也就是说这个时候，GCD 对象还必须得自己管理。 inline UIImage SDScaledImageForKey(NSString _Nullable key, UIImage * _Nullable image) { … #if SD_MAC … #elif SD_UIKIT || SD_WATCH if ((image.images).count &gt; 0) { … // 循环递归添加图片 for (UIImage * tempImage in image.images) { [scaledImages addObject:SDScaledImageForKey(key, tempImage)]; } // animatedImage 方法将多张图片创建成UIImage UIImage * animatedImage = [UIImage animatedImageWithImages:scaledImages duration:image.duration]; … return animatedImage; } else { #if SD_WATCH … #elif SD_UIKIT if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) { #endif CGFloat scale = 1; if (key.length &gt;= 8) { NSRange range = [key rangeOfString:@”@2x.”]; if (range.location != NSNotFound) { scale = 2.0; } range = [key rangeOfString:@”@3x.”]; if (range.location != NSNotFound) { scale = 3.0; } } UIImage * scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation]; image = scaledImage; } return image; } #endif } 根据 key 来修改图片的尺寸。scale = 2 即为缩小一倍。","tags":[]},{"title":" 三国群英传7原味强化版 5.0地图\t\t","date":"2018-03-14T03:34:58.000Z","path":"2018/03/14/e4-b8-89-e5-9b-bd-e7-be-a4-e8-8b-b1-e4-bc-a07-e5-8e-9f-e5-91-b3-e5-bc-ba-e5-8c-96-e7-89-88-5-0-e5-9c-b0-e5-9b-be/","text":"","tags":[]},{"title":" 三国群英传7原味强化版 5.0专属装备\t\t","date":"2018-03-02T04:13:47.000Z","path":"2018/03/02/e4-b8-89-e5-9b-bd-e7-be-a4-e8-8b-b1-e4-bc-a07-e5-8e-9f-e5-91-b3-e5-bc-ba-e5-8c-96-e7-89-88-5-0-e4-b8-93-e5-b1-9e-e8-a3-85-e5-a4-87/","text":"所有的专属装备都是通过刷红点(白玉麒麟、妖虎、水妖皇、4000 人以上的山贼或者叛将)获得。除此之外，当你的武将最高等级超过 35 级时，刷一般据点(比如铁门峡)也有几率获得。 曹操 武器：倚天剑、青釭剑 坐骑：绝影 典韦 武器：精钢双戟 许褚 武器：猛虎霸刀 张辽 武器：天狼偃月刀 坐骑：灰影 乐进 武器：啸风破军枪 坐骑：踏风 于禁 武器：傲云镇地剑 坐骑：嵩镇 张郃 武器：撼岳狂刀 坐骑：奔雷 徐晃 武器：破军战斧 坐骑：冲雷 夏侯惇 武器：雷霆破空刀 郭嘉 武器：王佐之剑 坐骑：白雪 司马懿 武器：九渊幽冥扇 坐骑：乌孙 刘备 武器：仁义无双 坐骑：祥瑞的卢 关羽 武器：翔龙偃月刀 坐骑：御皇赤兔马 张飞 武器：万胜丈八矛 坐骑：追风白凰 马超 武器：绝地虎魄枪 坐骑：万里飞沙 黄忠 武器：养由弓 坐骑：疾风燎原 赵云 武器：九天龙魂贯 坐骑：玉兰白龙驹 魏延 武器：绝地贪狼刀 坐骑：霸王乌骓 王平 武器：无当破蛮刀 诸葛亮 武器：乾坤八卦扇 坐骑：伏云龙 庞统 武器：真火朱雀扇 坐骑：浴火凰 黄月英 武器：幻月长空戟 坐骑：黄雾 孙坚 武器：雷斩刀 坐骑：破虏战兽 孙策 武器：天羽凤凰枪 坐骑：霸皇陆吾 孙权 武器：共工穿浪刃 坐骑：快航 周瑜 武器：英气翔空 坐骑：英鸿 鲁肃 武器：纵横玄机 坐骑：纵云 吕蒙 武器：川浪天雄枪 坐骑：横渡 陆逊 武器：祥虹天际 坐骑：火烧云 黄盖 武器：雷公鞭 太史慈 武器：断空绝影戟 甘宁 武器：翻浪狂鲛 周泰 坐骑：黑云 孙仁 武器：翔凤雁翎刀 吕布 武器：神鬼方天戟 坐骑：紫金赤兔马 袁绍 武器：尊祖傲龙刃 坐骑：御轩龙驹 张角 武器：黄天冲云剑 坐骑：黄天御龙马 董卓 武器：暴虐狂魔刀 坐骑：祸皇 孟获 武器：兽皇神斧 坐骑：蛮王战象 貂蝉 武器：风华燕翎鎚 坐骑：芳华灵凤 左慈 武器：苍天镜水杖 于吉 武器：黄天妖龙杖","tags":[]},{"title":" 建站（粗略）\t\t","date":"2018-02-27T11:14:22.000Z","path":"2018/02/27/e5-bb-ba-e7-ab-99/","text":"一、购买域名 GoDaddy：https://sg.godaddy.com/zh 购买的过程按照页面填写即可，主要讲配置域名服务器。 二、购买主机 老薛主机：http://laoxuehost.com/ 主机是存放网站内容的空间。购买之后可以看到自己的产品 点击香港空间-香港2号，可以查看产品详情 主机 ip 用于 dns 解析。 三、dns 解析 可以使用免费的域名解析服务，我使用的是：dnspod、dns.com 1、dnspod ①、登录后点击域名解析 ②、添加域名 ③、点击域名，进行设置 ④、添加解析记录，创建两个 A 类型的记录和两个 NS 类型记录。NS 类型记录的记录值为域名服务器，A 类型记录的记录值为主机 ip。 域名服务器需要在域名下设置，所以需要前往 Godaddy 网站 姓名 -> 我的产品 域名 -> DNS 域名服务器 -&gt;设置 这样域名就可以和网站主机 ip 关联了。 2、dns.com 步骤和 dnspod 基本一样。 四、搭建网站。 五、问题 1、 解答：主域名没有解析，有 www 记录，没有 @ 记录。 ![](http://www.dzliving.com/wp-content/uploads/2018/02/Website1.jpg) 2、宕机 原因与解答：联系主机服务商(例:老薛主机)，提交工单 -“主机所在的 ip 被攻击了，更换服务器”，接下来等待回复。","tags":[]},{"title":" Block 循环引用问题\t\t","date":"2018-02-26T12:10:39.000Z","path":"2018/02/26/block-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e9-97-ae-e9-a2-98/","text":"原文：http://blog.csdn.net/qq_30513483/article/details/52587551 前言 实际使用 Block 的过程中，还是会遇到一些问题，比如 Retain Circle 的问题。 目录 1、Retain Circle 的由来 2、weak、strong 的实现原理 3、weakSelf、strongSelf 的用途 4、@weakify、@strongify 实现原理 一、RetainCircle的由来 当 A 对象里面强引用了 B 对象，B 对象又强引用了 A 对象，这样两者的 retainCount 值一直都无法为 0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。 这是 2 个对象之间的，相应的，这种循环还能存在于 3、4 … n 个对象之间，只要相互形成环，就会导致 Retain Cicle 的问题。 当然也存在自身引用自身的。当一个对象内部的一个 obj，强引用的自身，也会导致循环引用的问题出现。常见的就是 block 里面引用的问题。 二、weak、strong 的实现原理 在 ARC 环境下，id 类型和对象类型、C 语言其他类型不同，类型前必须加上所有权的修饰符。 所有权修饰符总共有 4 种： ①、strong 修饰符②、weak 修饰符③、__unsafe_unretained 修饰符④、__autoreleasing 修饰符 一般我们如果不写，默认的修饰符是 __strong。 要想弄清楚 strong、weak 的实现原理，我们就需要研究研究 clang(LLVM编译器)和 objc4 Objective-C runtime 库了。 关于 clang 有一份关于ARC详细的文档，有兴趣的可以仔细研究一下文档里面的说明和例子，很有帮助。 以下的讲解，也会来自于上述文档中的函数说明。 1、__strong 的实现原理 ①、对象持有自己 首先我们先来看看生成的对象持有自己的情况，利用 alloc/new/copy/mutableCopy 生成对象。 当我们声明了一个 __strong 对象 { id __strong obj = [[NSObject alloc] init]; } LLVM 编译器会把上述代码转换成下面的样子 id __attribute__((objc_ownership(strong))) obj = ((NSObject ()(id, SEL))(void )objc_msgSend)((id)((NSObject ()(id, SEL))(void )objc_msgSend)((id)objc_getClass(“NSObject”), sel_registerName(“alloc”)), sel_registerName(“init”)); 相应的会调用 id obj = objc_msgSend(NSObject, @selector(alloc)); objc_msgSend(obj,selector(init)); objc_release(obj); 上述这些方法都好理解。在 ARC 有效的时候就会自动插入 release 代码，在作用域结束的时候自动释放。 ②、对象不持有自己 生成对象的时候不用 alloc/new/copy/mutableCopy 等方法。 { id __strong obj = [NSMutableArray array]; } LLVM 编译器会把上述代码转换成下面的样子 id __attribute__((objc_ownership(strong))) array = ((NSMutableArray ()(id, SEL))(void *)objc_msgSend)((id)objc_getClass(“NSMutableArray”), sel_registerName(“array”)); 查看 LLVM 文档，其实是下述的过程，相应的会调用 id obj = objc_msgSend(NSMutableArray, @selector(array)); objc_retainAutoreleasedReturnValue(obj); objc_release(obj); 与之前对象会持有自己的情况不同，这里多了一个 objc_retainAutoreleasedReturnValue 函数。 这里有 3 个函数需要说明： 1、id objc_retainAutoreleaseReturnValue(id value); Precondition: value is null or a pointer to a valid object. If value is null, this call has no effect. Otherwise, it performs a retain operation followed by the operation described in objc_autoreleaseReturnValue. Equivalent to the following code: id objc_retainAutoreleaseReturnValue(id value) { return objc_autoreleaseReturnValue(objc_retain(value)); } Always returns value 2、id objc_retainAutoreleasedReturnValue(id value); Precondition: value is null or a pointer to a valid object. If value is null, this call has no effect. Otherwise, it attempts to accept a hand off of a retain count from a call to objc_autoreleaseReturnValue on value in a recently-called function or something it calls. If that fails, it performs a retain operation exactly like objc_retain. Always returns value 3、id objc_autoreleaseReturnValue(id value); Precondition: value is null or a pointer to a valid object. If value is null, this call has no effect. Otherwise, it makes a best effort to hand off ownership of a retain count on the object to a call toobjc_retainAutoreleasedReturnValue for the same object in an enclosing call frame. If this is not possible, the object is autoreleased as above. Always returns value 这 3 个函数其实都是在描述一件事情：it makes a best effort to hand off ownership of a retain count on the object to a call to objc_retainAutoreleasedReturnValue for the same object in an enclosing call frame。 这属于 LLVM 编译器的一个优化。objc_retainAutoreleasedReturnValue 函数是用于自己持有(retain)对象的函数，它持有的对象应为返回注册在 autoreleasepool 中对象的方法或者是函数的返回值。 在 ARC 中原本对象生成之后是要注册到 autoreleasepool 中，但是调用了objc_autoreleasedReturnValue 之后，紧接着调用了 objc_retainAutoreleasedReturnValue，objc_autoreleasedReturnValue 函数会去检查该函数方法或者函数调用方的执行命令列表，如果里面有objc_retainAutoreleasedReturnValue() 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 autoreleasepool 中，也可以返回拿到相应的对象。 2、__weak 的实现原理 声明一个 __weak 对象 { id __weak obj = strongObj; } // 假设这里的 strongObj 是一个已经声明好了的对象。 LLVM 转换成对应的代码 id __attribute__((objc_ownership(none))) obj1 = strongObj; 相应的会调用 id obj ; objc_initWeak(&amp;obj,strongObj); objc_destoryWeak(&amp;obj); 看看文档描述 id objc_initWeak(id *object, id value); Precondition: object is a valid pointer which has not been registered as a weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object is registered as a weak object pointing to value Equivalent to the following code: id objc_initWeak(id _object, id value) { _ object = nil; return objc_storeWeak(object, value); } Returns the value of object after the call.Does not need to be atomic with respect to calls to objc_storeWeak on object objc_initWeak 的实现其实是这样的： id objc_initWeak(id * object, id value) { *object = nil; return objc_storeWeak(object, value); } 会把传入的 object 变成 0 或者 nil，然后执行 objc_storeWeak 函数。 那么 objc_destoryWeak 函数是干什么的呢？ void objc_destroyWeak(id *object); Precondition: object is a valid pointer which either contains a null pointer or has been registered as a __weak object. object is unregistered as a weak object, if it ever was. The current value of object is left unspecified; otherwise, equivalent to the following code: void objc_destroyWeak(id * object) { objc_storeWeak(object, nil); } Does not need to be atomic with respect to calls to objc_storeWeak on object objc_destoryWeak 函数的实现： void objc_destroyWeak(id * object) { objc_storeWeak(object, nil); } 也是会去调用 objc_storeWeak 函数。objc_initWeak 和 objc_destroyWeak 函数都会去调用 objc_storeWeak 函数，唯一不同的是调用的入参不同，一个是 value，一个是 nil。 那么重点就都落在 objc_storeWeak 函数上了。 id objc_storeWeak(id *object, id value); Precondition: object is a valid pointer which either contains a null pointer or has been registered as a __weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is assigned null and unregistered as a __weak object. Otherwise, object is registered as a __weak object or has its registration updated to point to value Returns the value of object after the call. objc_storeWeak 函数的用途就很明显了。由于 weak 表也是用 Hash table 实现的，所以objc_storeWeak 函数就把第一个入参的变量地址注册到 weak 表中，然后根据第二个入参来决定是否移除。如果第二个参数为 0，那么就把 __weak 变量从 weak 表中删除记录，并从引用计数表中删除对应的键值记录。 所以如果 weak 引用的原对象如果被释放了，那么对应的 weak 对象就会被指为 nil。原来就是通过 objc_storeWeak 函数这些函数来实现的。 以上就是 ARC 中strong 和 weak 的简单的实现原理，更加详细的还请大家去看看这一章开头提到的那个 LLVM 文档，里面说明的很详细。 三、weakSelf、strongSelf 的用途 在提 weakSelf、strongSelf 之前，我们先引入一个 Retain Cicle 的例子。 假设自定义的一个 student 类 例子 1： Student.h 文件 #import &lt;Foundation/Foundation.h&gt; typedef void(^ Study)(); @interface Student : NSObject @property (nonatomic, copy) NSString * name; @property (nonatomic, copy) Study study; @end ViewController.m 文件 #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @”Hello World”; student.study = ^{ NSLog(@”my name is = %@”, student.name); }; } 到这里，大家应该看出来了，这里肯定出现了循环引用了。student 的 study 的 Block 里面强引用了 student 自身。根据上篇文章的分析，可以知道，_NSConcreteMallocBlock 捕获了外部的对象，会在内部持有它。retainCount 值会加一。 我们用 Instruments 来观察一下。添加 Leak 观察器。 当程序运行起来之后，在 Leak Checks观察器里面应该可以看到红色的❌，点击它就会看到内存 leak了。有 2 个泄露的对象。Block 和 Student 相互循环引用了。 打开 Cycles &amp; Roots 观察一下循环的环。 这里形成环的原因 block 里面持有 student 本身，student 本身又持有 block。 那再看一个例子 2： #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @”Hello World”; student.study = ^(NSString * name){ NSLog(@”my name is = %@”,name); }; student.study(student.name); } 我把 block 新传入一个参数，传入的是 student.name。这个时候会引起循环引用么？ 答案肯定是不会。 如上图，并不会出现内存泄露。原因是因为，student 是作为形参传递进 block 的，block 并不会捕获形参到 block 内部进行持有。所以肯定不会造成循环引用。 再改一下。看例子 3： #import “ViewController.h” #import “Student.h” @interface ViewController () @property (nonatomic, copy) NSString * name; @property (nonatomic, strong) Student * stu; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; self.name = @”halfrost”; self.stu = student; student.study = ^{ NSLog(@”my name is = %@”, self.name); }; student.study(); } 这样会形成循环引用么？ 答案也是会的(ARC 环境)。 vc → student → block → vc 已经成环。这里即使是 self.name 也是循环引用了，因为 block 不可能说去单独的强持有某个实例的变量，这不符合内存管理规则(交叉管理了)，但是instruments 检测不出来。 (原文写着没有循环引用，我在 ARC 环境测试时，dealloc 不会被调用，说明还被引用这。可以自行验证)。 那遇到循环引用我们改如何处理呢？？类比平时我们经常写的 delegate，可以知道，只要有一边是__weak 就可以打破循环。 先说一种做法，利用 __block 解决循环的做法。例子 4： #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; __block Student * stu = student; student.name = @”Hello World”; student.study = ^{ NSLog(@”my name is = %@”, stu.name); stu = nil; }; } 这样写会循环么？看上去应该不会。但是实际上却是会的。 由于没有执行 study 这个 block，现在 student 持有该 block，block 持有 block 变量，block 变量又持有 student 对象。3 者形成了环，导致了循环引用了。 想打破环就需要破坏掉其中一个引用。__block 不持有 student 即可。 只需要执行一下 block 即可。例子 5： student.study(); 这样就不会循环引用了。 使用 block 解决循环引用虽然可以控制对象持有时间，在 block 中还能动态的控制 block 变量的值，可以赋值 nil，也可以赋值其他的值，但是有一个唯一的缺点就是需要执行一次 block 才行。否则还是会造成循环引用。 值得注意的是，在 ARC 下 __block**会导**致对象被 retain，有可能导致循环引用。而在 MRC 下，则不会 retain 这个对象，也不会导致循环引用。 接下来可以正式开始讲讲 weakSelf 和 strongSelf 的用法了。 1、weakSelf 说道 weakSelf，需要先来区分几种写法。 ①、__weak __typeof(self)weakSelf = self; // 这是 AFN 里面的写法。。 ②、#define WEAKSELF typeof(self) __weak weakSelf = self; 先区分 __typeof() 和 typeof() AFNetWorking 的库里面的代码都很整洁，里面各方面的代码都可以当做代码范本来阅读。遇到不懂疑惑的，都要深究，肯定会有收获。这里就是一处，平时我们的写法是不带__的，AFN 里面用这种写法有什么特殊的用途么？ 在 SOF 上能找到相关的答案： __typeof__() and __typeof() are compiler-specific extensions to the C language, because standard C does not include such an operator. Standard C requires compilers to prefix language extensions with a double-underscore (which is also why you should never do so for your own functions, variables, etc.)typeof() is exactly the same, but throws the underscores out the window with the understanding that every modern compiler supports it. (Actually, now that I think about it, Visual C++ might not. It does support decltype() though, which generally provides the same behaviour as typeof().)All three mean the same thing, but none are standard C so a conforming compiler may choose to make any mean something different. 其实两者都是一样的东西，只不过是 C 里面不同的标准，兼容性不同罢了。更加详细的官方说明 那么抽象出来就是这 2 种写法。 #define WEAKSELF __weak typeof(self)weakSelf = self; #define WEAKSELF typeof(self) __weak weakSelf = self; 这样子看就清楚了，两种写法就是完全一样的。 我们可以用 WEAKSELF 来解决循环引用的问题。例子 6： #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc]init]; student.name = @”Hello World”; __weak typeof(student) weakSelf = student; student.study = ^{ NSLog(@”my name is = %@”,weakSelf.name); }; student.study(); } 这样就解决了循环引用的问题了。 解决循环应用的问题一定要分析清楚哪里出现了循环引用，只需要把其中一环加上 weakSelf 这类似的宏，就可以解决循环引用。如果分析不清楚，就只能无脑添加 weakSelf、strongSelf，这样的做法不可取。 在上面的例子 3 中，就完全不存在循环引用，要是无脑加 weakSelf、strongSelf 是不对的。在例子 6 中，也只需要加一个 weakSelf 就可以了，也不需要加 strongSelf。 曾经在 segmentfault 也看到过这样一个问题，问：为什么 iOS 的 Masonry 中的 self 不会循环引用? UIButton * testButton = [[UIButton alloc] init]; [self.view addSubview:testButton]; testButton.backgroundColor = [UIColor redColor]; [testButton mas_makeConstraints:^(MASConstraintMaker * make) { make.width.equalTo(@100); make.height.equalTo(@100); make.left.equalTo(self.view.mas_left); make.top.equalTo(self.view.mas_top); }]; [testButton bk_addEventHandler:^(id sender) { [self dismissViewControllerAnimated:YES completion:nil]; } forControlEvents:UIControlEventTouchUpInside]; 如果我用 blocksKit 的 bk_addEventHandler方法，其中使用 strong self，该 viewController 就无法 dealloc，我理解是因为 self → self.view → testButton → self。 但是如果只用 Mansonry 的 mas_makeConstraints方法，同样使用 strong self，该 viewController 却能正常 dealloc，请问为什么 Masonry 没有导致循环引用？ 看到这里，读者应该就应该能回答这个问题了。 - (NSArray )mas_makeConstraints:(void(^)(MASConstraintMaker ))block { self.translatesAutoresizingMaskIntoConstraints = NO; MASConstraintMaker * maker = [[MASConstraintMaker alloc] initWithView:self]; block(maker); return [maker install]; } 关于 Masonry ，它捕获了变量 self，然后对其执行了 setTranslatesAutoresizingMaskIntoConstraints:方法。但是，因为执行完毕后，block会被销毁，没有形成环。所以，没有引起循环依赖。 2、strongSelf 上面介绍完了 weakSelf，既然 weakSelf 能完美解决 Retain Circle 的问题了，那为何还需要strongSelf 呢？ 还是先从 AFN 经典说起，以下是 AFN 其中的一段代码： #pragma mark - NSOperation - (void)setCompletionBlock:(void (^)(void))block { [self.lock lock]; if (!block) { [super setCompletionBlock:nil]; } else { __weak __typeof(self)weakSelf = self; [super setCompletionBlock:^ { __strong __typeof(weakSelf)strongSelf = weakSelf; #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wgnu” dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group(); dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue(); #pragma clang diagnostic pop dispatch_group_async(group, queue, ^{ block(); }); dispatch_group_notify(group, url_request_operation_completion_queue(), ^{ [strongSelf setCompletionBlock:nil]; }); }]; } [self.lock unlock]; } 如果 block 里面不加 __strong __typeof(weakSelf)strongSelf = weakSelf 会如何呢？ #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc]init]; student.name = @”Hello World”; __weak typeof(student) weakSelf = student; student.study = ^{ dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@”my name is = %@”,weakSelf.name); }); }; student.study(); } 输出： my name is = (null) 为什么输出是这样的呢？ 重点就在 dispatch_after 这个函数里面。在 study() 的 block 结束之后，student 被自动释放了。又由于 dispatch_after 里面捕获的 weak 的 student，根据第二章讲过的 weak的实现原理，在原对象释放之后 __weak 对象就会变成 null，防止野指针。所以就输出了 null了。 那么我们怎么才能在 weakSelf 之后，block里面还能继续使用 weakSelf 之后的对象呢？ 究其根本原因就是 weakSelf 之后，无法控制什么时候会被释放，为了保证在 block 内不会被释放，需要添加 __strong。 在 block 里面使用的 __strong 修饰的 weakSelf 是为了在函数生命周期中防止 self 提前释放。strongSelf 是一个自动变量当 block 执行完毕就会释放自动变量 strongSelf 不会对 self 进行一直进行强引用。 #import “ViewController.h” #import “Student.h” @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; Student * student = [[Student alloc] init]; student.name = @”Hello World”; __weak typeof(student) weakSelf = student; student.study = ^{ __strong typeof(student) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@”my name is = %@”,strongSelf.name); }); }; student.study(); } 输出 my name is = Hello World 至此，我们就明白了 weakSelf、strongSelf 的用途了。 weakSelf 是为了 block 不持有 self，避免 Retain Circle 循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。 strongSelf 的目的是因为一旦进入 block 执行，假设不允许 self 在这个执行过程中释放，就需要加入 strongSelf。block 执行完后这个 strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。 关于 Retain Circle 最后总结一下，有 3 种方式可以解决循环引用。 结合《Effective Objective-C 2.0》(编写高质量 iOS 与 OS X 代码的 52 个有效方法)这本书的例子，来总结一下。 EOCNetworkFetcher.h 文件 typedef void (^ EOCNetworkFetcherCompletionHandler)(NSData * data); @interface EOCNetworkFetcher : NSObject @property (nonatomic, strong, readonly) NSURL * url; - (id)initWithURL:(NSURL *)url; - (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion; @end EOCNetworkFetcher.m 文件 @interface EOCNetworkFetcher () @property (nonatomic, strong, readwrite) NSURL * url; @property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler; @property (nonatomic, strong) NSData * downloadData; @end @implementation EOCNetworkFetcher - (id)initWithURL:(NSURL *)url { if (self = [super init]) { _url = url; } return self; } - (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion { self.completionHandler = completion; // 开始网络请求 dispatch_async(dispatch_get_global_queue(0, 0), ^{ _downloadData = [[NSData alloc] initWithContentsOfURL:_url]; dispatch_async(dispatch_get_main_queue(), ^{ // 网络请求完成 [self p_requestCompleted]; }); }); } - (void)p_requestCompleted { if(_completionHandler) { _completionHandler(_downloadData); } } @end EOCClass.m 文件 @implementation EOCClass { NSData * _fetchedData; EOCNetworkFetcher * _networkFetcher; } - (void)downloadData { NSURL * url = [NSURL URLWithString:@”http://www.baidu.com&quot;\\]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { _fetchedData = data; }]; } @end 在这个例子中，存在 3 者之间形成环 ①、completion handler 的 block 因为要设置 _fetchedData 实例变量的值，所以它必须捕获 self变量，也就是说 handler 块保留了 EOCClass 实例； ②、EOCClass 实例通过 strong 实例变量保留了 EOCNetworkFetcher，最后EOCNetworkFetcher 实例对象也会保留了 handler 的 block。 书上说的 3 种方法来打破循环。 方法一：手动释放 EOCNetworkFetcher 使用之后持有的 _networkFetcher，这样可以打破循环引用 - (void)downloadData { NSURL * url = [NSURL URLWithString:@”http://www.baidu.com&quot;\\]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { _fetchedData = data; _networkFetcher = nil; // 加上此行，打破循环引用 }]; } 方法二：直接释放 block。因为在使用完对象之后需要人为手动释放，如果忘记释放就会造成循环引用了。如果使用完 completion handler 之后直接释放 block 即可。打破循环引用 - (void)p_requestCompleted { if(_completionHandler) { _completionHandler(_downloadData); } self.completionHandler = nil; // 加上此行，打破循环引用 } 方法三：使用 weakSelf、strongSelf - (void)downloadData { __weak __typeof(self) weakSelf = self; NSURL * url = [NSURL URLWithString:@”http://www.baidu.com&quot;\\]; _networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url]; [_networkFetcher startWithCompletionHandler:^(NSData * data) { __typeof(&amp;*weakSelf) strongSelf = weakSelf; if (strongSelf) { strongSelf.fetchedData = data; } }]; } 四、@weakify、@strongify 实现原理 上面讲完了 weakSelf、strongSelf 之后，接下来再讲讲 @weakify、@strongify，这两个关键字是 RAC 中避免 Block 循环引用而开发的 2 个宏，这 2 个宏的实现过程很牛，值得我们学习。 @weakify、@strongify 的作用和 weakSelf、strongSelf 对应的一样。这里我们具体看看大神是怎么实现这 2 个宏的。 直接从源码看起来。 #define weakify(…) \\ rac_keywordify \\ metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__) #define strongify(…) \\ rac_keywordify \\ _Pragma(“clang diagnostic push”) \\ _Pragma(“clang diagnostic ignored \\“-Wshadow\\“”) \\ metamacro_foreach(rac_strongify_,, __VA_ARGS__) \\ _Pragma(“clang diagnostic pop”) 看到这种宏定义，咋一看什么都不知道。那就只能一层层的往下看。 1、weakify 先从 weakify(…) 开始。 #if DEBUG #define rac_keywordify autoreleasepool {} #else #define rac_keywordify try {} @catch (…) {} #endif 这里在 debug 模式下使用 @autoreleasepool 是为了维持编译器的分析能力，而使用 @try/@catch 是为了防止插入一些不必要的 autoreleasepool。rac_keywordify 实际上就是autoreleasepool {}的宏替换。因为有了 autoreleasepool {}的宏替换，所以 weakify 要加上 @，形成 @autoreleasepool {}。 #define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, …) \\ metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__) __VA_ARGS__：总体来说就是将左边宏中 … 的内容原样抄写在右边 __VA_ARGS__ 所在的位置。它是一个可变参数的宏，是新的 C99 规范中新增的，目前似乎只有 gcc支持(VC 从 VC2005 开始支持)。 那么我们使用 @weakify(self) 传入进去。__VA_ARGS__ 相当于 self。此时我们可以把最新开始的 weakify 套下来。于是就变成了这样： rac_weakify_,, __weak, __VA_ARGS__ 整体替换MACRO, SEP, CONTEXT, … 这里需要注意的是，源码中就是给的两个”,”逗号是连着的，所以我们也要等效替换参数，相当于 SEP 是空值。 替换完成之后就是下面这个样子： autoreleasepool {} metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self))(rac_weakify_, , __weak, self) 现在我们需要弄懂的就是 metamacro_concat 和 metamacro_argcount 是干什么用的。 继续看看 metamacro_concat 的实现 #define metamacro_concat(A, B) \\ metamacro_concat_(A, B) #define metamacro_concat_(A, B) A ## B 是宏连接符。举个例子：假设宏定义为 #define XNAME(n) x##n，代码为：XNAME(4)，则在预编译时，宏发现XNAME(4) 与 XNAME(n) 匹配，则令 n 为 4，然后将右边的 n 的内容也变为 4，然后将整个XNAME(4) 替换为 x##n，亦即 x4，故最终结果为 XNAME(4) 变为 x4。所以 A##B 就是 AB。 metamacro_argcount 的实现 #define metamacro_argcount(…) \\ metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) #define metamacro_at(N, …) \\ metamacro_concat(metamacro_at, N)(__VA_ARGS__) metamacro_concat 是上面讲过的连接符，那么 metamacro_at，N = metamacro_atN，由于 N = 20，于是 metamacro_atN = metamacro_at20。 #define metamacro_at0(…) metamacro_head(__VA_ARGS__) #define metamacro_at1(_0, …) metamacro_head(__VA_ARGS__) #define metamacro_at2(_0, _1, …) metamacro_head(__VA_ARGS__) #define metamacro_at3(_0, _1, _2, …) metamacro_head(__VA_ARGS__) #define metamacro_at4(_0, _1, _2, _3, …) metamacro_head(__VA_ARGS__) #define metamacro_at5(_0, _1, _2, _3, _4, …) metamacro_head(__VA_ARGS__) #define metamacro_at6(_0, _1, _2, _3, _4, _5, …) metamacro_head(__VA_ARGS__) #define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, …) metamacro_head(__VA_ARGS__) #define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, …) metamacro_head(__VA_ARGS__) #define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, …) metamacro_head(__VA_ARGS__) #define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, …) metamacro_head(__VA_ARGS__) #define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, …) metamacro_head(__VA_ARGS__) #define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, …) metamacro_head(__VA_ARGS__) #define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, …) metamacro_head(__VA_ARGS__) #define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, …) metamacro_head(__VA_ARGS__) #define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, …) metamacro_head(__VA_ARGS__) #define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, …) metamacro_head(__VA_ARGS__) #define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, …) metamacro_head(__VA_ARGS__) #define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, …) metamacro_head(__VA_ARGS__) #define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, …) metamacro_head(__VA_ARGS__) #define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, …) metamacro_head(__VA_ARGS__) metamacro_at20 的作用就是截取前 20 个参数，剩下的参数传入 metamacro_head。 #define metamacro_head(…) \\ metamacro_head_(__VA_ARGS__, 0) #define metamacro_head_(FIRST, …) FIRST metamacro_head 的作用返回第一个参数。返回到上一级 metamacro_at20，如果我们从最源头的@weakify(self)，传递进来，那么 metamacro_at20(self, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)，截取前 20 个参数，最后一个留给metamacro_head_(1)，那么就应该返回 1。 metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self)) = metamacro_concat(metamacro_foreach_cxt, 1) 最终可以替换成 metamacro_foreach_cxt1。 在源码中继续搜寻。 // metamacro_foreach_cxt expansions #define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT) #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) #define metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \\ metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) \\ SEP \\ MACRO(1, CONTEXT, _1) #define metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \\ metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \\ SEP \\ MACRO(2, CONTEXT, _2) #define metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \\ metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \\ SEP \\ MACRO(3, CONTEXT, _3) #define metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \\ metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \\ SEP \\ MACRO(4, CONTEXT, _4) #define metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \\ metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \\ SEP \\ MACRO(5, CONTEXT, _5) #define metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \\ metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \\ SEP \\ MACRO(6, CONTEXT, _6) #define metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \\ metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \\ SEP \\ MACRO(7, CONTEXT, _7) #define metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \\ metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \\ SEP \\ MACRO(8, CONTEXT, _8) #define metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \\ metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \\ SEP \\ MACRO(9, CONTEXT, _9) #define metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \\ metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \\ SEP \\ MACRO(10, CONTEXT, _10) #define metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \\ metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \\ SEP \\ MACRO(11, CONTEXT, _11) #define metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \\ metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \\ SEP \\ MACRO(12, CONTEXT, _12) #define metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \\ metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \\ SEP \\ MACRO(13, CONTEXT, _13) #define metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \\ metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \\ SEP \\ MACRO(14, CONTEXT, _14) #define metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \\ metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \\ SEP \\ MACRO(15, CONTEXT, _15) #define metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \\ metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \\ SEP \\ MACRO(16, CONTEXT, _16) #define metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \\ metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \\ SEP \\ MACRO(17, CONTEXT, _17) #define metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \\ metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \\ SEP \\ MACRO(18, CONTEXT, _18) #define metamacro_foreach_cxt20(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \\ metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \\ SEP \\ MACRO(19, CONTEXT, _19) metamacro_foreach_cxt 这个宏定义有点像递归，这里可以看到 N 最大就是 20，于是metamacro_foreach_cxt19 就是最大，metamacro_foreach_cxt19 会生成rac_weakify_(0,__weak,_18)，然后再把前 18 个数传入 metamacro_foreach_cxt18，并生成rac_weakify_(0,__weak,_17)，依次类推，一直递推到 metamacro_foreach_cxt0。 #define metamacro\\_foreach\\_cxt0(MACRO, SEP, CONTEXT) metamacro_foreach_cxt0 就是终止条件，不做任何操作了。 于是最初的 @weakify 就被替换成 autoreleasepool {} metamacro_foreach_cxt1(rac_weakify_, , __weak, self) #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) 代入参数 autoreleasepool {} rac_weakify_（0,__weak,self） 最终需要解析的就是 rac_weakify_ #define rac_weakify_(INDEX, CONTEXT, VAR) \\ CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR); 把 (0,__weak,self) 的参数替换进来 (INDEX, CONTEXT, VAR)。 INDEX = 0， CONTEXT = __weak，VAR = self， 于是 CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR); 等效替换为 __weak __typeof__(self) self_weak_ = self; 最终 @weakify(self) = __weak __typeof__(self) self_weak_ = self; 这里的 self_weak_ 就完全等价于我们之前写的 weakSelf。 2、strongify 再继续分析 strongify(…) rac_keywordify 还是和 weakify 一样，是 autoreleasepool {}，只为了前面能加上 @ _Pragma(“clang diagnostic push”) \\ _Pragma(“clang diagnostic ignored \\“-Wshadow\\“”) \\ _Pragma(“clang diagnostic pop”) strongify 比 weakify 多了这些 _Pragma 语句。 关键字 _Pragma 是 C99 里面引入的。_Pragma 比 #pragma(在设计上)更加合理，因而功能也有所增强。 上面的等效替换 #pragma clang diagnostic push #pragma clang diagnostic ignored “-Wshadow” #pragma clang diagnostic pop 这里的 clang 语句的作用：忽略当一个局部变量或类型声明遮盖另一个变量的警告。 最初的 #define strongify(…) \\ rac_keywordify \\ _Pragma(“clang diagnostic push”) \\ _Pragma(“clang diagnostic ignored \\“-Wshadow\\“”) \\ metamacro_foreach(rac_strongify_,, __VA_ARGS__) \\ _Pragma(“clang diagnostic pop”) strongify 里面需要弄清楚的就是 metamacro_foreach 和 rac_strongify_。 #define metamacro_foreach(MACRO, SEP, …) \\ metamacro_foreach_cxt(metamacro_foreach_iter, SEP, MACRO, __VA_ARGS__) #define rac_strongify_(INDEX, VAR) \\ __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); 我们先替换一次，SEP = 空 ， MACRO = rac_strongify_ ， __VA_ARGS__ , 于是替换成这样。 metamacro_foreach_cxt(metamacro_foreach_iter,,rac_strongify_,self) 根据之前分析，metamacro_foreach_cxt 再次等效替换，metamacro_foreach_cxt##1(metamacro_foreach_iter,,rac_strongify_,self) 根据 #define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0) 再次替换成 metamacro_foreach_iter(0, rac_strongify_, self) 继续看看 metamacro_foreach_iter 的实现 #define metamacro_foreach_iter(INDEX, MACRO, ARG) MACRO(INDEX, ARG) 最终替换成 rac_strongify_(0,self) #define rac_strongify_(INDEX, VAR) \\ __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); INDEX = 0, VAR = self, 于是 @strongify(self) 就等价于 __strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); 等价于 __strong __typeof__(self) self = self_weak_; 注意 @strongify(self) 只能使用在 block 中，如果用在 block 外面，会报错，因为这里会提示你Redefinition of ‘self’。 实例 #ifndef weakify #if DEBUG // 判断当前代码运行模式 #if __has_feature(objc_arc) // 判断 ARC 环境 #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object; // ## 为连接符 #else #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object; #endif // 结束 if _has_feature() #else #if __has_feature(objc_arc) #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object; #endif // 结束 if _has_feature() #endif // 结束 if DEBUG #endif // 结束 ifndef weakify #ifndef strongify #if DEBUG #if __has_feature(objc_arc) #define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object; #else #define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object; #endif #else #if __has_feature(objc_arc) #define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object; #else #define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object;、#endif #endif #endif 总结一下 @weakify(self) = @autoreleasepool{} __weak __typeof__ (self) self_weak_ = self; @strongify(self) = @autoreleasepool{} __strong __typeof__(self) self = self_weak_; 经过分析以后，其实 @weakify(self) 和 @strongify(self) 就是比我们日常写的 weakSelf、strongSelf 多了一个 @autoreleasepool{} 而已，至于为何要用这些复杂的宏定义来做，目前我还没有理解。如果有大神指导其中的原因，还请多多指点。","tags":[]},{"title":" SOA\t\t","date":"2018-02-24T04:27:18.000Z","path":"2018/02/24/soa/","text":"SOA Service-Oriented Architecture 面向服务的架构 面向服务的架构是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。 接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。 面向服务的架构可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。 SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。 特征： 01、可从企业外部访问 02、随时可用 03、粗粒度的服务接口分级 04、松散耦合 05、可重用的服务 06、服务接口设计管理 07、标准化的服务接口 08、支持各种消息模式 09、精确定义的服务契约 10、SOA 服务具有平台独立的自我描述 XML 文档。Web服务描述语言是用于描述服务的标准语言。 11、SOA 服务用消息进行通信，该消息通常使用 XML Schema 来定义(也叫做 XSD:XML Schema Definition)。消费者和提供者或消费者和服务之间的通信多见于不知道提供者的环境中。服务间的通讯也可以看作企业内部处理的关键商业文档。 12、在一个企业内部，SOA 服务通过一个扮演目录列表(directory listing)角色的登记处(Registry)来进行维护。应用程序在登记处(Registry)寻找并调用某项服务。统一描述，定义和集成(UDDI:Universal Description Definition and Integration)是服务登记的标准。 13、每项 SOA 服务都有一个与之相关的服务品质(QoS:quality of service)。QoS 的一些关键元素有安全需求(例如认证和授权)，可靠通信(译注：可靠消息是指，确保消息”仅且仅仅”发送一次，从而过滤重复信息。)，以及谁能调用服务的策略。","tags":[]},{"title":" 动态\t\t","date":"2018-02-08T10:29:27.000Z","path":"2018/02/08/e5-8a-a8-e6-80-81-e7-b1-bb-e5-9e-8b-e5-92-8c-e5-8a-a8-e6-80-81-e7-bb-91-e5-ae-9a/","text":"iOS 的动态性主要来自以下方面：动态类型、动态绑定、动态载入、SEL 类型 1、iOS 动态类型 (强类型)id 可以在代码运行时判断对象的类型。使用 id 类型(又称强类型)可以在运行的时候使用任何数据类型来替换。动态类型让程序更加灵活，但会使数据的统一性降低。我们常用的静态类型如：NSString 等是有着自己的优势的，使用静态类型编译器可以完全分析代码的性能，可预知性更高。 2、iOS 动态绑定 可以在代码运行的时候判断需要调用什么方法。动态类型和动态绑定使得选择哪个接收者以及调用哪个方法都可以在运行时决定。 3、动态载入 应用可以根据需要加载可执行代码以及资源，而不是在启动时就加载所有资源。 4、SEL 类型 iOS 在编译的时候会根据方法名字(包括参数序列)，生成一个用来区分这个方法的唯一的 ID，这个 ID 是 SEL 类型的，SEL 的本质就是类方法的编号(函数地址)。 5、关联 动态添加属性。 使用 Category 可以很方便地为现有的类增加方法，但却无法直接增加实例变量。不过从 Mac OS X v10.6 开始，系统提供了 Associative References，这个问题就很容易解决了。 我们可以在 runtime 期间动态地添加任意多的属性，并且随时读取。 所用到的两个重要 runtime API： OBJC_EXPORT void objc_setAssociatedObject( id object, const void * key, id value, objc_AssociationPolicy policy) OBJC_EXPORT id objc_getAssociatedObject( id object, const void * key) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);","tags":[]},{"title":" iOS 开发者证书\t\t","date":"2018-01-30T07:30:32.000Z","path":"2018/01/30/ios-e5-bc-80-e5-8f-91-e8-80-85-e8-af-81-e4-b9-a6/","text":"苹果开发者账号 一、Certification(证书) 证书是对电脑开发资格的认证，每个开发者帐号有一套。分为两种： ①、Developer Certification(开发证书) 安装在电脑上提供权限：开发人员通过设备进行真机测试。可以生成副本供多台电脑安装； ②、Distribution Certification(发布证书) 安装在电脑上提供发布 iOS 程序的权限：开发人员可以制做测试版和发布版的程序。不可生成副本，仅有配置该证书的电脑才可使用； 二、Provisioning Profile(授权文件) 授权文件是对设备如 iPod Touch、iPad、iPhone 的授权，文件内记录的是设备的 UUID 和程序的AppId，即：使被授权的设备可以安装或调试 Bundle identifier 与授权文件中记录的 AppId 对应的程序。 开发者帐号在创建授权文件时候会选择 AppId和 UUID(开发者帐号下 Devices 中添加最多 100 个，多选）。 授权文件分为两种，对应相应的证书使用： ①、Developer Provisioning Profile(开发授权文件) 在装有开发证书或副本的电脑上使用，开发人员选择该授权文件通过电脑将程序安装到授权文件记录的设备中，即可进行真机测试。 注意：确保电脑有权限真机调试，即安装了开发证书或副本；在开发工具中程序的 Bundle identifier 和选中使用的授权文件的 AppId 要一致；连接调试的设备的 UUID 在选中的授权文件中有记录。 ②、Distribution Provisioning Profile(发布授权文件) 在装有发布证书的电脑上(即配置证书的电脑，只有一台)制做测试版和发布版的程序。 发布版就是发布到 AppStore 上的程序文件，开发者帐号创建授权文件时选择 store 选项，选择 AppId，无需选择 UUID； 测试版就是在发布之前交给测试人员可同步到设备上的程序文件，开发者帐号创建授权文件时选择 AdHoc，选择 AppId 和 UUID；只有选中的 UUID 对应的设备才可能安装上通过该授权文件制做的程序。 三、Keychain(开发密钥) 安装证书成功的情况下，证书下都会生成 Keychain，上面提到的证书副本(导出证书重新命名)就是通过配置证书的电脑导出 Keychain(就是 .p12 文件)安装到其他机子上，让其他机子得到证书对应的权限。 Developer Certification 就可以制作副本 Keychain 分发到其他电脑上安装，使其可以进行真机测试。 注意：Distribution Certification只有配置证书的电脑才可使用，因此即使导出 Keychain 安装到其他电脑上，其他电脑也不可能具有证书的权限。 以下内容原文地址：https://www.cnblogs.com/sk-fengzi/p/5670087.html 四、申请流程 1、申请钥匙串文件 进入(Launchpad)，找到 (钥匙串访问) 存储在桌面，然后完成退出钥匙串工具就可以了。 2、申请开发证书，发布证书 打开苹果开发者中心(https://developer.apple.com) 3、注册项目的 BundleID 4、添加测试设备 填写完下一步就好了。 获取设备的 UDID：设备连接 Mac 打开 iTunes 如果觉得麻烦，或则条件不允许可以选择蒲公英提供的方(https://www.pgyer.com/doc/view/udid) 5、配置证书 这里不用担心会选择错误，你配置开发证书，那这里就只有开发证书供你选择。配置发布证书，这里就只有发布证书供你选择。 如果是配置开发证书，就还会需要你设置，在这个项目中添加哪些设备作为真机调试的设备 完成创建后，只要下载这个配置文件，双击运行就可以了。然后退出网页。证书就已经申请好了，配置好了。你也可以真机调试，也能发布了。(Xcode7 以后不需要开发者账号也能真机调试，只要你在 Xcode 登陆 AppleID 账号，不过发布还是需要开发者账号的)步骤： 登陆成功后： 然后下面会出现 Fix Issue 按钮点击就好了，系统自动帮你调试好。 五、发布流程 打开 iTunes Connect(https://itunesconnect.apple.com)登陆账号。 不懂填写什么，可以点问号都是中文的提示 创建后就进入 填写完了，右上”存储”按钮，保存下。然后继续： 先上传 APP 截图，最新的规定是只要上传 5.5 寸的截图就可以了；视频，看个人，好像是十几秒左右吧。图片、视频的内容要是 APP 中真实存在的；然后就是 APP 描述(描述的内容要与 APP 相符合)，关键词(据说不能出现竞品的名字，没考证过)，技术支持网址，营销网址(两个网址没有也可以用公司的网站)；下面部分： 都填写完了，就存储下。然后检查有没有错误，或者写错的。 (填写过程中，最好填写完一些就存储下，防止网络出问题，白弄，特别是上传完截图)然后回到 Xcode，打开你的项目： 下面是导出 ipa 的提交方式： 后面几步也是选择发布证书，检查发布配置文件(注：如果是导出到分发网站的 ipa，发布的配置文件必须是 Ad-hoc 的，企业级账号还可以是 In-house ，详细参考：蒲公英的说明），然后选择保存路径。然后在 Xcode 里面打开： 运行后，登陆开发者账号。把 ipa 文件添加进去，下一步 ，下一步，就可以提交到 iTunes Connect了。(提交到分发网站的请参考：https://www.pgyer.com/doc/view/app_upload)步骤差不多，就不详解了。提交过程的快慢跟网速有关，成功后就可以关闭 Xcode 了，回到 iTunes Connect。 进入活动。查看项目是否构建状态；如果完成了，就继续： 添加完构建版本，存储下，整个资料的填写提交差不多完成。然后设置： 这个根据个人需求，设置价格、销售范围等等。完了检查下，看有没有错误的地方。没有就可以点击右上角的提交以供审核了。 还有一个，你也可以添加 APP 在 APPStore 上的本地化，APPStore 会根据你做的本地化，实现不同地区的账号看到你的 APP 显示的是本地化的语言，如果你没做本地化，那么显示就是你的APPStore 主要语言。 最后就是这个页面了，还是一样有就有，没有就没有，选择提交。就是等待审核了。 六、问题 1、制作 cer签名文件需要上传的 CSR 文件时，一直报错 Invalid Certificate 这个原因是在使用钥匙串证书助理，从颁发机构申请 证书填写信息的时候少写了”常用名称”导致的。","tags":[]},{"title":" git add -A 和 git add . 的区别\t\t","date":"2018-01-10T09:13:45.000Z","path":"2018/01/10/git-add-a-e5-92-8c-git-add-e7-9a-84-e5-8c-ba-e5-88-ab/","text":"原文：https://www.cnblogs.com/skura23/p/5859243.html git add -A 和git add . 、git add -u 在功能上看似很相近，但还是存在一点差别 git add . 它会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区。包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u git add –update 的缩写。它仅监控已经被 add 的文件(即 tracked file)，它会将被修改的文件提交到暂存区。add -u 不会提交新文件(untracked file)。 git add -A git add –all 的缩写。是上面两个功能的合集。 总结： git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 git 版本不同会有所区别： Git Version 1.x: Git Version 2.x:","tags":[]},{"title":" Git 教程\t\t","date":"2018-01-10T08:52:36.000Z","path":"2018/01/10/git-e6-95-99-e7-a8-8b/","text":"原文：http://www.yiibai.com/git/git_pull.html","tags":[]},{"title":" Git\t\t","date":"2018-01-10T08:42:16.000Z","path":"2018/01/10/git/","text":"以 xcode 下载、更新、提交的顺序解释： 一、从存储库中下载工程 git clone https://…xxx.git 问题 1：工程包太大，下载超时 解决： git clone –depth=1 https://…xxx.git 问题 2：工程包太大，空间不足 解决： git config –global http.postBuffer 800000000 注意 global 前面为两个横线，800000000 为提供项目下载的空间，单位为 B。 二、从存储库下载某个分支 git clone –depth=1 -b branch_1.0 https://…xxx.git branch_1.0 为分支名称 三、Xcode 提交修改的代码到本地代码库 在 Xcode 顶部的菜单中选中 Source Control -&gt; Commit 此时是将修改提交到本地代码库。 四、更新代码 原本更新代码(update)是必须要放在提交(commit)之前的，因为要避免在本地版本低于远程版本时提交，会报错。如果提交上去了，那么远程的代码会被覆盖掉。 由于第三步是提交到本地的代码库，所以没问题。 更新代码有两种方式：一种是 Xcode 操作，一种是终端操作。 1、Xcode 操作 Source Control -&gt; Pull 2、终端操作 git pull 四、提交到远程代码库 git add . Git会递归地将你执行命令时所在的目录中的所有文件添加上去。可以理解为”暂存”。 git commit -m “备注” 生成一个 commit git push origin master / git push origin branch_1.1 推送至远程服务器。master 主干，branch_1.1 是分支 五、回滚到某一本地版本 学习文章：http://blog.csdn.net/qq_25730711/article/details/53581231 1、git log -3 查看最近 3 个版本，可以获得版本 id。 2、git revert becc004d3cb9f0811d64bc07cbd8fdd443bb5805 回滚到指定版本。","tags":[]},{"title":" SpriteKit 圆角化\t\t","date":"2017-11-28T08:25:44.000Z","path":"2017/11/28/spritekit-e5-9c-86-e8-a7-92-e5-8c-96/","text":"一、使用 SKShapeNode 设置圆角 - (SKNode *)roundFunc1:(CGSize)size cornerRadius:(CGFloat)radius { SKShapeNode * node = [SKShapeNode shapeNodeWithRectOfSize:size cornerRadius:radius]; node.fillColor = [SKColor colorWithRed:1.0 green:1.0 blue:0 alpha:0.4]; return node; } 二、使用 CoreGraphics 绘制圆角图片，将图片作为纹理创建 SKSpriteNode 对象 - (SKNode *)roundFunc2:(CGRect)rect cornerRadius:(CGFloat)radius { UIGraphicsBeginImageContext(rect.size); [[SKColor colorWithRed:1.0 green:1.0 blue:0 alpha:0.4] setFill]; [[UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius] fill]; UIImage * image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return [SKSpriteNode spriteNodeWithTexture:[SKTexture textureWithImage:image]];; } 三、使用 mask 遮罩裁剪圆角 - (SKNode *)roundFunc3:(CGRect)rect cornerRadius:(CGFloat)radius { SKCropNode * cropNode = [SKCropNode node]; SKShapeNode * mask = [SKShapeNode node]; [mask setPath:CGPathCreateWithRoundedRect(rect, radius, radius, nil)]; mask.fillColor =[SKColor colorWithRed:1.0 green:1.0 blue:0 alpha:0.4]; [cropNode setMaskNode:mask]; return cropNode; }","tags":[]},{"title":" SpriteKit 编程指南\t\t","date":"2017-11-28T06:31:12.000Z","path":"2017/11/28/spritekit-e7-bc-96-e7-a8-8b-e6-8c-87-e5-8d-97/","text":"Sprite Kit编程指南.pdf","tags":[]},{"title":" SpriteKit 样例\t\t","date":"2017-11-28T05:23:40.000Z","path":"2017/11/28/spritekit-e6-a0-b7-e4-be-8b/","text":"用 Xcode 8 直接创建 game 工程，系统会帮助创建 GameViewController、GameScene.sks、Actions.sks、GameScene 文件，下面手动创建、编写这些文件，以便熟悉过程： 1、创建视图控制器并在 storyboard 中将 view 的类型设置为 SKView，在 vc.h 文件可以设置显示FPS 等信息。 SKView * skView = (SKView *)self.view; skView.showsDrawCount = YES; // 使用多少绘画传递来渲染内容的详情，越少越好 skView.showsFPS= YES; // 帧率 skView.showsNodeCount = YES; // 节点数 2、创建 GameScene.sks 文件 创建新文件时选择 SpriteKit Scene 类型： 样例中只是简单的在场景中添加了一个文本子节点，注意修改文本子节点的 name(便于用代码获取对象)、文本内容、对齐方式。 3、创建 GameScene 文件 继承自 SKScene，先不在里面写代码。打开 GameScene.sks，关联 GameScene 类 4、创建 Actions.sks 文件 创建新文件时选择 SpriteKit Action 类型： ①、点击左下角创建一个新的动作，名称自己决定； ②、关联到 GameScene.sks，这样就可以在 GameScene 类中直接获取上一步创建的动作对象 ③、拖动系统动作至面板，调整动作开始时间、时长、特效等。 5、完善各类的代码 ①、创建 GameScene 对象并渲染到屏幕 GameScene * scene = (GameScene *)[SKScene nodeWithFileNamed:@”GameScene”]; scene.scaleMode = SKSceneScaleModeAspectFill; // 这样可以使场景不超出屏幕 [skView presentScene:scene]; ②、GameScene 类代码及注释 @implementation GameScene { SKShapeNode * _shapeNode; // 形状节点 SKLabelNode * _labelNode; // 文本节点 } - (void)didMoveToView:(SKView *)view { _labelNode = (SKLabelNode *)[self childNodeWithName:@”HelloLabel”]; _labelNode.alpha = 0.0; [_labelNode runAction:[SKAction fadeInWithDuration:2.0]]; // 显示 CGFloat w = (self.size.width + self.size.height) * 0.05; _shapeNode = [SKShapeNode shapeNodeWithRectOfSize:CGSizeMake(w, w) cornerRadius:w * 0.3]; _shapeNode.lineWidth = 2.5; // 线框宽度 SKAction * repeatAction = [SKAction rotateByAngle:M_PI duration:1]; [_shapeNode runAction:[SKAction repeatActionForever:repeatAction]]; SKAction * waitAction = [SKAction waitForDuration:0.5]; SKAction * fOAction = [SKAction fadeOutWithDuration:0.5]; SKAction * removeAction = [SKAction removeFromParent]; [_shapeNode runAction:[SKAction sequence:@[ waitAction, fOAction, removeAction ]]]; } - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { [_labelNode runAction:[SKAction actionNamed:@”Pulse”] withKey:@”fadeInOut”]; for (UITouch * touch in touches) { SKShapeNode * shapeNode = [_shapeNode copy]; shapeNode.position = [touch locationInNode:self]; shapeNode.strokeColor = SKColor.greenColor; [self addChild:shapeNode]; } } - (void)touchesMoved:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { SKShapeNode * shapeNode = [_shapeNode copy]; shapeNode.position = [touch locationInNode:self]; shapeNode.strokeColor = SKColor.blueColor; [self addChild:shapeNode]; } } - (void)touchesEnded:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { SKShapeNode * shapeNode = [_shapeNode copy]; shapeNode.position = [touch locationInNode:self]; shapeNode.strokeColor = SKColor.redColor; [self addChild:shapeNode]; } } - (void)touchesCancelled:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { SKShapeNode * shapeNode = [_shapeNode copy]; shapeNode.position = [touch locationInNode:self]; shapeNode.strokeColor = SKColor.redColor; [self addChild:shapeNode]; } } 一、锚点 锚点对应着一个在父视图上的坐标，该坐标就是自身的 position，可以通过这两个值来计算子视图的位置信息。子视图锚点位置上的点与父视图上 position 位置重合。 锚点是 CGPoint 类型数据，锚点的取值范围为 (0, 0)~(1, 1) 之间。如下图所示. 默认值为 (0.5, 0.5) 表示子视图的中心点在 position 位置； 图上灰色方块在设置时的 position.y 属性值相同，间距相同。修改它们的 anchorPoint 之后，渲染的位置发生了改变，与实际的位置有差别。 从左往右的，它们的锚点值分别为 (1.0, 1.0)、(0.5, 0.5)、(1.0/3, 1.0/3)、(0, 0)。 二、xScale、yScale 场景中上层精灵的缩放值也作用于下层精灵，这将改变它的有效尺寸，而不改变它的实际 frame。 三、着色和混合模式 node.color = SKColor.redColor; node.colorBlendFactor = 0.5; // 默认情况下的颜色混合因子为 0.0，这表明纹理未经更改地使用 当你增加混合因子的值，更多的纹理颜色就会被混合颜色替换。例如在你的游戏中的角色受到伤害时，你可能要添加一个红色的色调。 SKAction * attacked = [SKAction colorizeWithColorBlendFactor:0.5 duration:0.25]; SKAction * normal = [SKAction colorizeWithColorBlendFactor:0.0 duration:0.25]; [spaceshipNode runAction:[SKAction sequence:@[ attacked, normal ]]]; 渲染的最终阶段是把精灵的纹理混合(blend)到其目标帧缓冲区。默认行为使用纹理的 alpha 值混合纹理与目标像素。但是，当你想添加其他的特效到场景时你可以使用其他混合模式。 你可以使用 BlendMode 属性来控制精灵的混合行为。例如，附加混合模式在把多个精灵结合在 一起时很有用，比如开枪(fire)或发光(lighting)。 lightFlareSprite.blendMode = SKBlendModeAdd 三、使用纹理对象 虽然 SpriteKit 可以在你创建一个精灵时为你创建纹理，但在一些更复杂的游戏中，你需要对纹理有更多的控制。你可能需要做以下任何一项: 多个精灵之间共享一个纹理。 在精灵创建后更改它的纹理。 通过一系列的纹理让精灵动起来。 用不直接存储在应用程序 bundle 中的数据创建纹理。 把节点树渲染成纹理。例如，你可能要对游戏进行截屏，在玩家完成了关卡(level)后分享。 你通过直接使用 SKTexture 对象可以做所有这些事情。纹理对象是可应用于精灵的可复用的图像。你可以创建纹理对象独立于创造精灵。然后，你可以使用纹理对象来创建新的的精灵或改变现有精灵的纹理。它跟 SpriteKit 为你创建纹理相似，但你对过程有更多的控制权。 1、从存储在 App Bundle 的图像创建纹理 SKTexture * texture = [SKTexture textureWithImageNamed:@”rocket.png”]; … SKSpriteNode * rocket = [SKSpriteNode spriteNodeWithTexture:texture]; … [self addChild:rocket]; 通常情况下，你会加载一次纹理，并保持对它的强引用，以便每次需要创建一个新的精灵时都可以使用它。 纹理对象本身只是实际的纹理数据的一个占位符。纹理数据占用(intensive)更多的资源，所以当使用它的精灵在屏幕上且可见时，SpriteKit 只保存它在内存中。 2、纹理图册 通常情况下，存储在应用程序 bundle 中的美术资源是不相干的图像，却是一起用于相同精灵的图像的集合。例如，下面是一些常见的美术资源的集合: 一个角色的动画帧 用来创建游戏关卡或者迷宫的地形瓦片 用于用户界面控件的图像，如按钮、开关和滑块 如果你把这些逻辑分组看成单独的纹理，SpriteKit 和图形硬件必须更加艰难的运行来渲染场景， 而且游戏的性能可能会受到影响。所以 SpriteKit 使用纹理图册把相关的图像收集起来。你指定哪些资源一起使用，然后 Xcode 会自动构建纹理图册。然后在你的游戏加载纹理图册时， SpriteKit 可以更好地管理性能和内存使用。 Xcode 可以自动为你从图像集合构建纹理图册。 在创建一个纹理图册时，在收集太多的纹理与太少的纹理到图册之间，有一个平衡的做法。如果 你使用的项目数量不足，那么纹理之间切换的开销可能仍然太大。如果你把太多的图像放在一个 单一的图册中，那更多的纹理数据会存储在内存中。因为 Xcode 为你构建图册，它可以相对容易地在不同的图册配置之间切换。对你的纹理图册不同的配置做实验，并选择为你供最佳性能的结合。 加载纹理图册 SpriteKit 首先搜索指定的文件名的图像文件，但如果它没有找到，那么它会在内置到应用程序 bundle 里面的任何纹理图册内部进行搜索。这意味着，在你的游戏中你不必作出任何编码上的更改来支持它，美工试验新的纹理时不需要重新构建(rebuild)你的游戏。美工把纹理拖放到应用程序 bundle 中，覆盖任何之前内置到纹理图册的版本，然后就可以自动发现它们。一旦美工对纹理满意了，然后你就可以将它们添加到项目中且合并到你的纹理图册中。 如果你想显式使用纹理图册，你可以使用 SKTextureAtlas 类。首先，你使用图册的名称创建 一个纹理图册对象。然后使用图册中存储的图像文件的名字查看各自的纹理。 下面的例子采用了纹理图册装载一个角色的多个动画帧。代码加载这些帧，并将它们存储在一个数组中。 SKTextureAtlas * atlas = [SKTextureAtlas atlasNamed:@”monster.atlas”]; for (int i = 1; i &lt;= atlas.textureNames.count; i++) { SKTexture * temp = [atlas textureNamed:[NSString stringWithFormat:@”%d”, i]]; [self.monsterWalkTextures addObject:temp]; } // for (int i = 0; i &lt; atlas.textureNames.count; i++) { // SKTexture * temp = [atlas textureNamed:atlas.textureNames[i]]; // [self.monsterWalkTextures addObject:temp]; // } //self.node = [[SKSpriteNode alloc] initWithTexture:self.monsterWalkTextures[0] // color:SKColor.clearColor // size:CGSizeMake(30, 40)\\]; self.node = [SKSpriteNode spriteNodeWithTexture:self.monsterWalkTextures[0]]; - (void)run { SKAction * repeat = [SKAction animateWithTextures:self.monsterWalkTextures timePerFrame:0.03f resize:NO restore:YES\\]; [self.noderunAction:[SKAction repeatActionForever:repeat]]; } 如果出现红色叉，原因是无法正确获取到纹理，需要检查纹理名称与图片名称是否对应。 3、从已有的纹理的一个区域创建新纹理 SKTexture * rectTexture = [SKTexture textureWithRect:CGRectMake(0, 0, 0.5, 0.5) inTexture:texture]; 区域是处在一个单元坐标系统中，左下角为 (0, 0)。 (0, 0, 0.5, 0.5) 表示以左下角为起点，选中原纹理宽度的一半 * 高度的一半的区域。 图中分别有完整纹理以及它的四个部分。 4、其他创建纹理的方法 使用 SKTexture 初始化方法通过内存中正确格式化的像素数据、核心图像或对现有的纹理应用一个Core Image 滤镜来创建纹理。 SKView 类的textureFromNode 方法可以把一个节点树的内容渲染成纹理。纹理被指定好尺寸，以便它可以包含节点的内容和所有它的可见后代节点。 当你从应用程序 bundle 中的文件之外的其他来源创建一个纹理时，纹理数据不能被清除，因为 Sprite Kit不保留用于生成纹理的原始数据的引用。基于这个原因，你应该有节制地使用这些纹 理。一旦不再需要它们，马上移除对它们的强引用。 四、预加载纹理来提高帧率 使用 SpriteKit 的一个主要优点是它自动为你执行了大量的内存管理。Sprite Kit 从图像文件加 载纹理，将这些数据转换成图形硬件可以使用的格式，并将其上传到图形硬件。 Sprite Kit 很擅长于确定当前帧纹理是否需要渲染。如果纹理不在内存中，它会加载纹理。如果纹理在内存中并且有一段时间没有使用，纹理数据会被丢弃，以便可以加载其他需要的纹理。 如果一次有太多没加载纹理的精灵变为可见，它可能无法在一个单一的动画帧内加载所有这些纹理。纹理加载的延迟可能会导致帧速率突然丢失，这是对用户可见的。Sprite Kit 提供了在精灵变为可见之前预加载纹理的选项。因为你非常熟悉你的游戏的设计，你往往更清楚地知道什么时 候即将要使用一套新的纹理。例如，在一个滚动的游戏中，当用户在宇宙间移动时，你知道玩家即将进入宇宙的哪一部分，然后你可以在动画的每一帧加载三两个纹理，这样当玩家到达那里时纹理已经在内存中了。 [newSectionTexture preload]; 预加载代码的正确设计要依赖于你的游戏的引擎。这里有两种可能设计要考虑: 当玩家开始一个新的关卡，预加载这个关卡的所有纹理。游戏被划分成各个关卡，每个关卡能保持所有纹理资产同时在内存中。这保证了所有纹理在游戏开始前就加载好，消除任何纹理加载的延迟。 如果一个游戏需要比上面在内存中存储更多的纹理，那么你需要动态地预加载纹理。通常，这意味着当你能确定它很快就需要会才预加载纹理。例如，在赛车游戏中，玩家总是在同一方向移动，所以你预加载玩家即将看到的部分赛道的纹理。纹理在后台加载，取代赛道中最旧的纹理。在一个允许玩家时刻控制的冒险游戏中，你可能必须临时加载更多的纹理。 五、动作 动作是一个有效不可变的对象，你可以在节点树的多个节点上安全地同时运行相同的动作。因此，如果你有一个在游戏中要反复使用的动作，那么可以构建一个单一的动作实例，然后每当你需要一个节点来执行它时再重用它。 瞬时动作(一帧内完成)或非瞬时动作(每一帧，直到完成) 如果你添加动作到节点时，场景正在处理动作，直到下一帧前，新的动作可能不会执行。 一个节点可以同时运行多个动作，即使那些动作在不同的时间执行。场景跟踪每个动作还要多久才完成并计算动作对节点产生的效果。例如，如果你运行两个动作移动相同的节点，这两个动作对每一帧都应用变化，如果移动动作大小相等、方向相反，则该节点将保持静止。 因为动作处理需要绑定到场景，只有当节点被添加到场景的节点树时动作才会被处理。你可以这样利用此特性：通过创建一个节点并分配动作给它，但等到以后再添加节点到场景。后来，当节点加入到了场景时，会立即开始执行它的动作。这种模式特别有用，因为在复制节点时，一个节点正在运行的动作也被复制和归档。 节点可以添加和移除动作。removeActionForKey: / removeAllActions 新运行一个动作时，如果已经有一个使用相同键的动作在执行，已有的动作会在新的动作添加之前先被移除掉。 序列动作。序列中的每一个动作在前一个动作结束后开始。 组动作。存储在该组中的所有动作在同一时间开始执行。 重复动作。当子动作完成后，它重新启动。 六、动作计时 默认情况下，一个动作的持续时间根据你指定的持续时间线性变化。但是你可以通过一些属性调整动画的计时： 动作的 timingMode 属性可以用来为动画选择一个非线性的计时模式。 动作的 speed 属性可以改变动画播放的速率。speed 值为 1.0 是正常的速度，如果动作的 speed 属性设置为 2.0，当节点执行动作时，它速度快了一倍。要暂停动作，将值设置为 0。如果你调整那些包含其他动作(例如组、序列或重复动作)的动作的速率，速率会应用到所包含的动作。附加的动作也会受到它们自己的 speed 属性的作用。 节点的 speed 属性与动作的 speed 属性具有相同的效果，但节点的速率适用于该节点或节点树中的任意后代所处理的所有动作。 动作最好的工作方式：创建一次然后使用多次。只要有可能，早创建动作，并将它们保存在一个很容易地检索和执行的位置。比如存储在节点的 userData 属性。 虽然动作非常有效，但创建动作并执行它是有成本的。如果你打算在动画的每一帧改变节点的属性，而这些变化在每帧都需要重新计算，你最好直接改变节点而不使用动作来做这些。 七、坐标系 当一个节点被放置在节点树中时，它的 position 属性把它定位在由它的父节点提供的坐标系内。Sprite Kit 在 iOS 和 OS X 中使用相同的坐标系。正数 的 x 坐标在右边而正数的 y 坐标在屏幕上方。 Sprite Kit 还有一个标准的旋转约定(rotation convention)。弧度为 0 的角指定正 x 轴，沿逆时针方向是正角度。 当你仅使用 Sprite Kit 代码时，一致的坐标系意味着你可以轻松地在游戏的 iOS 和 OS X 版本 之间共享代码。然而，它更意味着当你编写特定 OS 专用(OS-specific)的用户界面代码时， 你可能需要在操作系统的视图坐标系与 Sprite Kit 坐标系之间进行转换。最常见的情况就是使用 iOS 视图，它们的坐标系不同。 frame 代表节点在坐标系中的可视区域，calculateAccumulatedFrame 方法包括整个绘制节点及它所有后代的区域，如果父节点没有指定的 size 而子节点有，那么父节点的 size 由子节点决定 。 场景的尺寸以点为单位指定场景中可见部分的尺寸。树中的节点可以定位在该区域之外，这些节点仍由场景处理，但被渲染器(render)忽略。 八、节点树 场景渲染的标准行为遵循以下一对简单的规则： 父节点先绘制自身的内容再渲染子节点。 子节点以它们在子节点数组中的顺序依次渲染。 子节点在树中的顺序会影响场景处理的多个方 面，包括碰撞测试(hit testing)和渲染。 如果修改了同级节点的 zPosition 属性，那么渲染顺序也发生改变： 父节点先绘制自身的内容再渲染子节点(不变)。 父节点从 z 值最大的子节点开始渲染，并以 z 值最小的孩子结束。所以 z 轴位置表示从子节点到一个假想的摄像机位置的距离。如果两个子节点有相同的 z 值，则在数组中较早出现的那个先绘制。 碰撞测试的顺序与绘制顺序相反。当 Sprite Kit 处理场景内的触摸或鼠标事件时，它在场景中查找想接受该事件的最接近节点。如果该节点不处理事件，则检查下一个最接近的节点，依此类推（响应链）。处理碰撞测试的顺序基本上是绘制顺序的反方向： 父节点只在它的子节点传给它后才接受事件。 子节点从最小的 z 值到最大的 z 值进行处理。 如果两个子节点有相同的 z 值，先检测数组中后出现的那个。 Sprite Kit 只使用 zPosition 的值来确定碰撞测试和绘制顺序。但是你可以使用指定的值来实现自己的游戏特效。例如： 使用节点的深度来确定节点在屏幕上移动的速度，模拟视差滚动(parallax scrolling)。 使用节点的深度来影响它渲染的方式。 九、搜索节点树 语法 描述 示例 / 放在搜索字符串的开头：表示应该对树的根节点进行搜索 /MyNode // 放在搜索字符串的开头：指定搜索应从根节点开始，并在整个节点 树中递归进行。这做法在搜索字符串之外的其他地方都是不合法的 //* //MyNode/SubNode .. 表明搜索应该向上移到该节点的父节点中进行 //MyNode/.. / 放在搜索字符串的开头以外的任何地方：表明搜索应该移到节点的子节点中进行 MyNode/SubNode * 搜索匹配零个或多个字符 [以逗号或破折号分隔的字符] 搜索将匹配括号内包含的任意字符 A[0-9] 字母和数字字符 搜索只匹配指定的字符 十、配置过渡期间是否播放动画 过渡对象的 pausesIncomingScene 和 pausesOutgoingScene 属性允许你定义动画是否在过渡期间播放。默认情况下两个场景的动画在过渡期间相继处理。但是可能你有需求暂停一个或两个场景，直到过渡完成。 当一个场景没有使用过渡呈现时，首先移除旧的场景，然后呈现新的场景。当使用过渡时，首先加入 新的场景，然后过渡发生，最后旧的场景被移除。 十一、节点 类 描述 SKNode 所有的节点类都从该类派生。它不绘制任何东西。 SKScene 场景是在节点树的根节点。它控制动画和动作的处理。 SKSpriteNode 绘制纹理精灵的节点。 SKLabelNode 渲染文本字符串的节点。 SKShapeNode 渲染基于 Core Graphics 路径的形状的节点。 SKVideoNode 播放视频内容的节点。 SKEmitterNode 创建和渲染粒子的节点。 SKCropNode 使用遮罩(mask)修剪其子节点的节点。 SKEffectNode 应用 Core Image 滤镜到其子节点的节点。 十一、基础节点 SKNode 类不绘制任何可视化内容。它的主要作用是为其他节点类提供使用的基础行为。然而，这并不意味着在你的游戏中没有使用 SKNode 对象的地方。下面是一些你可能会在你的游戏引擎内使用基础节点的方式： 你有一个由多个节点对象组合的内容(无论是精灵或其他内容的节点)。你想在游戏中把此内容作为一个单独的对象，而不想令其中任何一个内容节点成为根节点。这时用基本节点是合适的，因为你可以给定它在场景树的位置，然后让所有的其他节点作为其后代。 使用节点对象组织绘制的内容到一系列的层。例如，许多游戏有一个世界背景层，有另一个角色层，而文本和其他的游戏信息在第三层，以及有更多的层。创建每个层为基本节点，并把它们按顺序插入到场景中。然后，必要时可以使个别图层可见或不可见。 您需要场景中一个不可见的对象，但要它执行一些其他必要的功能。例如，在一个地牢探索游戏中，一个不可见的节点可能用来代表一个隐藏的陷阱。当另一个节点与它相交时，就会触发陷阱。或另一个例子，你可能会添加一个节点作为另一个节点的子节点，而后者代表玩家在视图中的点的位置。 在树中用这样的节点代表这些概念有以下优势： 您可以通过添加或删除单个节点来添加或删除整个子树。这让场景管理变得有效率。 您可以调整的树中的一个节点的属性，这些属性的效果向下传播到节点的后代。 您可以利用行动、物理接触和其他 Sprite Kit 的功能来实现此概念。","tags":[]},{"title":" SpriteKit 场景编辑器\t\t","date":"2017-11-24T10:28:56.000Z","path":"2017/11/24/spritekit-e5-9c-ba-e6-99-af-e7-bc-96-e8-be-91-e5-99-a8/","text":"学习文章：http://blog.csdn.net/kmyhy/article/details/68488986 一、创建场景 在工程中点击 New File 创建一个 SKSprite 场景文件，后缀为 .sks，如图： viewController 中加载此场景的代码： SKScene * scene = [SKScene nodeWithFileNamed:@”MyScene”]; // MyScene 为上面创建的文件名 [(SKView *)self.view presentScene:scene]; 二、创建玩家、怪兽和文本 1、缩放工作区域的大小，便于操作 2、场景的尺寸 3、场景的锚点，影响子视图布局 4、点击右下角 Media Libray，Assets.xcassets 中的所有图片都被列在这里，将一张图片拖到场景中，编辑器会用这张图片自动创建一个精灵。 5、查看和设置关联类。 三、渲染顺序 场景的节点树按照先父节点后子节点的顺序渲染，兄弟节点之间可以通过 ignoresSiblingOrder 属性进行控制渲染顺序。 创建玩家精灵时，它已经放在了一个 children 数组，这个数组的元素是 SKNode 对象。SKScene 和 SKSpriteNode 都继承自 SKNode。数组是有先后顺序的，如果需要场景在渲染的时候不按照这个顺序，那么如下设置： skView.ignoresSiblingOrder = YES; // 以随机顺序渲染兄弟节点 也可以为每个精灵设定 z 坐标。z 坐标表示了远近深度，与你的视线方向一致。z 坐标小的节点会显示在 z 坐标大的节点后面。这种方式可以让你完全控制精灵显示的层次。 打开 MyScene.sks，在场景编辑器中修改 SKNode 对象的位置属性：Position - Z 四、添加动画 动作编辑器： 在 Object library 中找到 Move 动作，并将它拖到某个精灵上。 选中添加的动画块，在属性检查器中改变它的属性： 五、引用节点 在一个场景中 A 引入另一个场景 B。 先创建好两个场景文件，然后打开场景 A 文件，在右下角Object library 找到 Reference： 然后设置它的属性值，将 Reference 属性指向场景 B。 也可以在场景 A 的界面上，将场景 B 拖拽至场景 A，完成引用。 六、检测触摸事件 - (void)sceneDidLoad { SKNode * b = (SKNode *)[selfchildNodeWithName:@”B”]; } SpiteKit 在场景被加载到内存之后调用 sceneDidLoad 方法，可以通过场景编辑器中的名字很容易地找到这些子节点。 但是 childNodeWithName: 方法只能找到父节点的直系子节点，要遍历更远的层级，你需要在查找字符串中添加两个斜杠 ‘//‘，这会在整个节点树中递归。 在 sceneDidLoad() 方法中加入： SKSpriteNode * plane = (SKSpriteNode *)[self childNodeWithName:@”//B - Plane”]; 新建一个方法，用于跳到其他场景： - (void)goToScene:(SKScene *)scene { scene.scaleMode = SKSceneScaleModeAspectFill; SKTransition * transition = [SKTransition fadeWithColor:SKColor.darkGrayColor duration:1]; [self.view presentScene:scene transition:sceneTransition]; } 这个方法创建了一个渐入渐出变换，然后让 View 用指定的变换呈现这个场景。 触摸处理器： - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { UITouch * touch = [[touches allObjects] firstObject]; if (touch) { CGPoint touchLocation = [touch locationInNode:self]; if ([b containsPoint:touchLocation]) { CGPoint location = [touch locationInNode:b]; if ([plane containsPoint:location]) { } } } } 代码解释如下： 找出第一个触摸点在屏幕上的坐标。 如果触摸位于 b 上，获取触摸在 b 上的坐标。 判断触摸位于哪个按钮，并调用对应的处理。 七、加入声音 在 MyScene.sks 中，从 Object library 拖一个 Audio 节点到场景中。修改属性面板中的数值： 在 sceneDidLoad 方法中获取到该精灵： - (void)sceneDidLoad { SKAudioNode bgm = (SKAudioNode )[self childNodeWithName:@”BGM”]; } 控制声音的播放： - (void)updateBGM { SKAction * action =play ? [SKAction play] : [SKAction pause]; [bgm runAction:action]; [bgm setAutoplayLooped:play]; } 八、物理引擎 有大量物理属性可以修改，比如 mass(体积)、gravity(重力) 和 friction effects(摩擦系数)。 九、粒子 在工程里点击 New File，创建粒子文件，可以选择粒子效果","tags":[]},{"title":" SpriteKit 入门\t\t","date":"2017-11-24T05:58:57.000Z","path":"2017/11/24/spritekit-e5-85-a5-e9-97-a8/","text":"原文：http://blog.csdn.net/jiang314/article/details/53130126 一、什么是 SpriteKit Sprite 的中文译名是精灵。在游戏开发中，精灵指的是以图像方式呈现在屏幕上的一个图像。这个图像也许可以移动，用户可以与其交互，也有可能仅只是游戏的一个静止的背景图。塔防游戏中敌方源源不断涌来的每个小兵都是一个精灵，我方防御塔发出的炮弹也是精灵。可以说精灵构成了游戏的绝大部分主体视觉内容，而一个 2D 引擎的主要工作，就是高效地组织、管理和渲染这些精灵。 SpriteKit 是在 iOS7 SDK 中苹果新加入的一个 2D 游戏引擎框架，之前 iOS 开发平台上已经出现了像 cocos2d 这样的比较成熟的 2D 引擎解决方案。SpriteKit 展现出的是 Apple 将 Xcode 和 iOS/Mac SDK 打造成游戏引擎的野心，但是同时也确实与 IDE 有着更好的集成，减少了开发者的工作。 二、Hello SpriteKit 下面将非常流行的 raywenderlich的经典 cocos2d 教程 使用全新的 SpriteKit 重新实现一遍。这个 cocos2d 入门实在是太经典了，包括了精灵管理、交互检测、声音播放和场景切换等等方面的内容，麻雀虽小，却五脏俱全。 示例中素材，工程示例。 三、配置工程 因为做的是一个横屏游戏，所以在工程 -> target -&gt; General -&gt; Depoyment Info 中Device Orientation 中的 Portrait 勾去掉。 通过 rotation 计算完毕之后再添加新的 Scene，这样得到的 Scene 的尺寸是正确的，如果在appear 之前就使用 bounds.size 添加的话，将会得到竖屏时的尺寸。所以将在 viewWillAppear 中添加 Scene。 - (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; SKView skView = (SKView )self.view; skView.showsFPS = YES; skView.showsNodeCount = YES; SKScene * scene = [MyScene sceneWithSize:skView.bounds.size]; scene.scaleMode = SKSceneScaleModeAspectFill; [skView presentScene:scene]; } 三、加入精灵 SpriteKit是基于场景(Scene)来组织的，每个 SKView(专门用于呈现 SpriteKit 的 View) 中可以渲染和管理一个 SKScene，每个 Scene 中可以装载多个精灵并管理它们的行为。 所有游戏逻辑和精灵管理都会在 Scene 中完成。在自定义的 MyScene.m 中重写 initWithSize 方法： -(id)initWithSize:(CGSize)size { if (self = [super initWithSize:size]) { // 1、设置工程的 Scene 背景 self.backgroundColor = SKColor.whiteColor; } return self; } /// 因为在 initWithSize 中获取的self.size 数值不正确，所以将代码放在didMoveToView - (void)didMoveToView:(SKView *)view { // 2、传入图片名称创建一个精灵 SKSpriteNode * player = [SKSpriteNode spriteNodeWithImageNamed:@”player”]; // 3、设置精灵的位置 player.position = CGPointMake(player.size.width/2, self.size.height/2); // 将精灵添加到当前的场景中 [self addChild:player]; } SKColor 只是一个宏定义，在 iOS 平台下被定义为 UIColor，在 Mac 下被定义为 NSColor。在 SpriteKit 开发时，尽量使用 SK 开头的对应的 UI 类可以统一代码而减少跨 iOS 和 Mac 平台的成本。 实际上一个 SKSpriteNode 中包含了贴图(SKTexture 对象)、颜色、尺寸等等参数。spriteNodeWithImageNamed:方法为我们读取图片，生成贴图，并设定精灵尺寸和图片大小一致。在实际使用中，绝大多数情况这个简便方法就足够了。 SpriteKit 中的坐标系和其他 OpenGL 游戏坐标系是一致的，屏幕左下角为(0, 0)。不过需要注意的是不论是横屏还是竖屏游戏，view 的尺寸都是按照竖屏进行计算的，而不会因为横屏而发生交换。因此在开发时，请千万不要使用绝对数值来进行位置设定及计算。 四、源源不断涌来的怪物大军 怪物与玩家的区别是会移动的 &amp; 怪物是每隔一段时间就会出现一个的。在 MyScene.m 中，加入一个方法： - (void)addMonster { SKSpriteNode * monster = [SKSpriteNode spriteNodeWithImageNamed:@”monster”]; … // 1、计算怪物的位置 monster.position = CGPointMake(x, y); [self addChild:monster]; int duration = …; // 2、计算运动的时间 SKAction * moveAction = [SKAction moveTo:CGPointMake(x, y) duration:duration]; SKAction * completeAction = [SKAction runBlock:^{ [monster removeFromParent]; }]; [monster runAction:[SKAction sequence:@[moveAction, completeAction]]]; } 计算怪物的出生点(移动起始位置)的 Y 值。怪物从右侧屏幕外随机的高度处进入屏幕，为了保证怪物图像都在屏幕范围内，需要指定最小和最大 Y 值。然后从这个范围内随机一个 Y 值作为出生点。 怪物都一样的移动速度显得死板，可以设置不同的 duration SKAction 可以操作 SKNode，完成精灵移动、旋转、消失等等。这里声明了两个 SKAction，moveAction负责将精灵在 duration 的时间间隔内移动到结束点，completeAction负责将精灵移出场景，其实是 run 一段接收到的 block 代码。runAction方法可以让精灵执行某个操作，而在这里我们要做的是先将精灵移动到结束点，当移动结束后，移除精灵。我们需要的是一个顺序执行，这里 sequence: 可以让我们顺序执行多个 action。 然后尝试在上面的 -didMoveToView:里调用这个方法 - (void)didMoveToView:(SKView *)view { … [self addMonster]; } 知道么，游戏的本质是什么？就是一堆能动的图像！ 在 -didMoveToView: 方法中创建源源不断的怪物： - (void)didMoveToView:(SKView *)view { // 添加循环创建动作 SKAction * addAction = [SKAction runBlock:^{ [self addMonster]; }]; SKAction * waitAction = [SKAction waitForDuration:1]; SKAction * sequenceAction = [SKAction sequence:@[addAction, waitAction]]; SKAction * repeatAction = [SKAction repeatActionForever:sequenceAction]; [self runAction:repeatAction]; } 这里声明了一个 SKAction 的序列，run 一个 block，然后等待 1 秒。用这个动作序列生成一个无限重复的动作，然后让 scene 执行。这样就可以实现每秒调用一次 addMonster:来向场景中不断添加敌人了。 如果你对 Cocoa(Touch) 开发比较熟悉的话，可能会说，为什么不用一个 NSTimer 来做同样的事情，而要写这样的 SKAction 呢？能不能用 NSTimer 来达到同样的目的？答案是在对场景或者精灵等 SpriteKit 对象进行类似操作时，尽量不要用 NSTimer。因为 NSTimer 将不受 SpriteKit 的影响和管理，使用 SKAction 可以不加入其它任何代码就获取如下好处： 自动暂停和继续。当设定一个 SKNode 的 paused 属性为 YES 时，这个 SKNode 和它管理的子node 的 action 都会自动被暂停。这里详细说明一下 SKNode 的概念：SKNode是 SpriteKit中要素的基本组织方式，它代表了 SKView 中的一种游戏资源的组织方式。我们现在接触到的SKScene 和 SKSprite 都是 SKNode 的子类，而一个 SKNode 可以有很多的子 Node，从而构成一个 SKNode 的树。在我们的例子中，MyScene 直接加在 SKView 中作为根 node 存在，而英雄或者敌人的精灵都作为 Scene 这个 node 的子 node 被添加进来。SKAction 和 node 上的各种属性的的作用范围是当前这个 node 和它的所有子 node，在这里我们如果设定 MySecnen 这个 node(也就是 self) 的 paused属性被设为 YES 的话，所有的 Action 都会被暂停，包括这个每隔一秒调用一次的 action，而如果使用 NSTimer 的话，必须自行维护它的状态。 当 SKAction 依附的结点被从结点树中拿掉的时候，这个 action 会自动结束并停止，这是符合一般逻辑的。 五、奥特曼打小怪兽是天经地义的 我们打算做的是在用户点击屏幕某个位置时，就由英雄所在的位置向点击位置发射一枚固定速度的飞镖。然后这每飞镖要是命中怪物的话，就把怪物从屏幕中移除。 先来实现发射飞镖吧。检测点击，然后让一个精灵朝向点击的方向以某个速度移动，有很多种SKAction 可以实现，但是为了尽量保持简单，我们使用上面曾经使用过的 moveTo:duration:吧。在发射之前，我们先要来做一点基本的数学运算，希望你还能记得相似三角形之类的概念。我们的飞镖是由英雄发出的，然后经过手指点击的点，两点决定一条直线。简单说我们需要求解出这条直线和屏幕右侧边缘外的交点，以此来确定飞镖的最终目的。一旦我们得到了这个终点，就可以控制飞镖 moveTo 到这个终点，从而模拟出发射飞镖的 action 了。 然后开始写代码吧，还记得我们之前点击会出现一个飞机的精灵么，找到相应的地方，MyScene.m里的 -touchesBegan:withEvent:，用下面的代码替换掉原来的。 -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { CGSize winSize = self.size; SKSpriteNode * projectile = [SKSpriteNode spriteNodeWithImageNamed:@”projectile.png”]; projectile.position = CGPointMake(projectile.size.width/2, winSize.height/2); CGPoint location = [touch locationInNode:self]; CGPoint offset = CGPointMake(location.x - projectile.position.x, location.y - projectile.position.y); if (offset.x &lt;= 0) return; [self addChild:projectile]; int realX = winSize.width + (projectile.size.width/2); float ratio = (float)offset.y / (float)offset.x; int realY = (realX * ratio) + projectile.position.y; CGPoint realDest = CGPointMake(realX, realY); int offRealX = realX - projectile.position.x; int offRealY = realY - projectile.position.y; float length = sqrtf((offRealX offRealX) + (offRealY offRealY)); float velocity = self.size.width / 1; float realMoveDuration = length/velocity; [projectile runAction:[SKAction moveTo:realDest duration:realMoveDuration] completion:^{ [projectile removeFromParent]; }]; } } 为飞镖设定初始位置。 将点击的位置转换为 node 的坐标系的坐标，并计算点击位置和飞镖位置的偏移量。如果点击位置在飞镖初始位置的后方，则直接返回。 根据相似三角形计算屏幕右侧外的结束位置。 移动飞镖，并在移动结束后将飞镖从场景中移除。注意在移动怪物的时候我们用了两个action(actionMove 和 actionMoveDone 来做移动+移除），这里只使用了一个 action 并用带completion block 移除精灵。这里对飞镖的这种做法是比较简明常见高效的，之前的做法只是为了说明 action 的 sequence: 的用法。 运行看看现在的游戏吧，我们有英雄有怪物还有打怪物的小飞镖，好像气氛上已经开始有趣了！ 六、飞镖击中的检测 但是一个严重的问题是，现在的飞镖就算接触到了怪物也是直穿而过，完全就是空气一般的存在。为什么？因为我们还没有写任何检测飞镖和怪物的接触的代码（废话）。我们想要做的是在飞镖和怪物接触到的时候，将它们都移出场景，这样看起来就像是飞镖打中了怪物，并且把怪物消灭了。 基本思路是在每隔一个小的时间间隔，就扫描一遍场景中现存的飞镖和怪物。这里就需要提到SpriteKit 中最基本的每一帧的周期概念。 在 iOS 传统的 view 的系统中，view 的内容被渲染一次后就将一直等待，直到需要渲染的内容发生改变（比如用户发生交互，view 的迁移等）的时候，才进行下一次渲染。这主要是因为传统的 view 大多工作在静态环境下，并没有需要频繁改变的需求。而对于 SpriteKit 来说，其本身就是用来制作大多数时候是动态的游戏的，为了保证动画的流畅和场景的持续更新，在 SpriteKit 中 view 将会循环不断地重绘。 动画和渲染的进程是和 SKScene 对象绑定的，只有当场景被呈现时，这些渲染以及其中的 action 才会被执行。SKScene 实例中，一个循环按执行顺序包括： 每一帧开始时，SKScene 的 -update:方法将被调用，参数是从开始时到调用时所经过的时间。在该方法中，我们应该实现一些游戏逻辑，包括 AI、精灵行为等等，另外也可以在该方法中更新 node的属性或者让 node 执行 action。 在 update 执行完毕后，SKScene 将会开始执行所有的 action。因为 action 是可以由开发者设定的，因此在这一个阶段我们也是可以执行自己的代码的。 在当前帧的 action 结束之后，SKScene 的 -didEvaluateActions 将被调用，我们可以在这个方法里对结点做最后的调整或者限制，之后将进入物理引擎的计算阶段。 然后 SKScene 将会开始物理计算，如果在结点上添加了 SKPhysicsBody 的话，那么这个结点将会具有物理特性，并参与到这个阶段的计算。根据物理计算的结果，SpriteKit 将会决定结点新的状态。 然后 -didSimulatePhysics 会被调用，这类似之前的 -didEvaluateActions。这里是我们开发者能参与的最后的地方，是我们改变结点的最后机会。 一帧的最后是渲染流程，根据之前设定和计算的结果对整个呈现的场景进行绘制。完成之后，SpriteKit 将开始新的一帧。 在了解了一些 SpriteKit 的基础概念后，回到我们的 demo。检测场景上每个怪物和飞镖的状态，如果它们相撞就移除，这是对精灵的计算的和操作，我们可以将其放到 -update: 方法中来处理。在此之前，我们需要保存一下添加到场景中的怪物和飞镖，在 MyScene.m 的 @implementation 之前加入下面的声明： @interface MyScene() @property (nonatomic, strong) NSMutableArray * monsters; @property (nonatomic, strong) NSMutableArray * projectiles; @end 然后在 -initWithSize: 中配置场景之前，初始化这两个数组： -(id)initWithSize:(CGSize)size { if (self = [super initWithSize:size]) { self.monsters = [NSMutableArray array]; self.projectiles = [NSMutableArray array]; //… } return self; } 在将怪物或者飞镖加入场景中的同时，分别将它们加入到数组中 - (void)addMonster { //… [self.monsters addObject:monster]; } - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { //… [self.projectiles addObject:projectile]; } } 同时，在将它们移除场景时，将它们移出所在数组，分别在 [monster removeFromParent] 和[projectile removeFromParent] 后加入[self.monsters removeObject:monster] 和 [self.projectiles removeObject:projectile]。接下来终于可以在 -update: 中检测并移除了： - (void)update:(CFTimeInterval)currentTime { NSMutableArray * projectilesToDelete = [[NSMutableArray alloc] init]; for (SKSpriteNode * projectile in self.projectiles) { NSMutableArray * monstersToDelete = [[NSMutableArray alloc] init]; for (SKSpriteNode * monster in self.monsters) { if (CGRectIntersectsRect(projectile.frame, monster.frame)) { [monstersToDelete addObject:monster]; } } for (SKSpriteNode * monster in monstersToDelete) { [self.monsters removeObject:monster]; [monster removeFromParent]; } if (monstersToDelete.count &gt; 0) { [projectilesToDelete addObject:projectile]; } } for (SKSpriteNode * projectile in projectilesToDelete) { [self.projectiles removeObject:projectile]; [projectile removeFromParent]; } } 代码比较简单，不多解释了。直接运行看结果 七、播放声音 音效绝对是游戏的一个重要环节，还记得一开始下载的那个资源文件压缩包么？里面除了 Art 文件夹外还有个 Sounds 文件夹，我们把 Sounds 加入工程里，整个文件夹拖到工程导航里面，然后勾上 “Copy item”。 我们想在发射飞镖时播出一个音效，对于音效的播放是十分简单的，SpriteKit 为我们提供了一个action，用来播放单个音效。因为每次的音效是相同的，所以只需要在一开始加载一次 action，之后就一直使用这个 action，以提高效率。先在 MyScene.m 的 @interface 中加入 @property (nonatomic, strong) SKAction * soundAction; 然后在 -initWithSize: 一开始的地方加入 self.soundAction = [SKAction playSoundFileNamed:@”pew-pew-lei.caf” waitForCompletion:NO]; 最后，修改发射飞镖的 action，使播放音效的 action 和移动精灵的 action 同时执行。将 -touchesBegan:withEvent:最后 runAction 的部分改为 //… SKAction * moveAction = [SKAction moveTo:realDest duration:realMoveDuration]; SKAction * soundAction = [SKAction group:@[moveAction, self.soundAction]]; [projectile runAction:projectileCastAction completion:^{ [projectile removeFromParent]; [self.projectiles removeObject:projectile]; }]; //… 之前我们介绍了用 -sequence: 连接不同的 action，使它们顺序串行执行。在这里我们用了另一个方便的方法 -group: 可以范围一个新的 action，这个 action 将并行同时开始执行传入的所有action。在这里我们在飞镖开始移动的同时，播放了一个 pew-pew-lei 的音效。 游戏中音效一般来说至少会有效果音(SE)和背景音(BGM)两种，SE 可以用 SpriteKit 的 action 来解决，而 BGM 就要惨一些，至少写这篇教程的时候，SpriteKit 还没有一个 BGM 的专门的对应方案（如果之后新加了的话我会更新本教程）。所以现在我们使用传统的播放较长背景音乐的方法来实现背景音，那就是用AVAudioPlayer。在 @interface MyScene() 中加入一个 bgmPlayer 的声明，然后在 -initWithSize: 中加载背景音并一直播放。 @interface MyScene() //… @property (nonatomic, strong) AVAudioPlayer * bgmPlayer; //… @end @implementation MyScene -(id)initWithSize:(CGSize)size { //… NSString * bgmPath = [[NSBundle mainBundle] pathForResource:@”bgm-aac” ofType:@”caf”]; NSURL * url = [NSURL fileURLWithPath:bgmPath]; self.bgmPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:NULL]; self.bgmPlayer.numberOfLoops = -1; [self.bgmPlayer play]; //… } AVAudioPlayer 用来播放背景音乐相当的合适，唯一的问题是有可能你想在暂停的时候停止这个背景音乐的播放。因为使用的是 SpriteKit 以外的框架，而并非 action，因此 BGM 的播放不会随着设置 Scene 为暂停或者移除这个 Scene 而停止。想要停止播放，必须手动显式地调用[self.bgmPlayer stop]，可以说是比较麻烦，不过有时候你并不想在暂停或者场景切换的时候中断背景音乐的话，这反倒是一个好的选择。 八、结果计算和场景切换 到现在为止，整个关卡作为一个 demo 来说已经比较完善了。最后，我们可以为这个关卡设定一些条件，毕竟不是每个人都喜欢一直无意义地消灭怪物直到手机没电。我们设定规则，当打死 30 个怪物后切换到新的场景，以成功结束战斗的结果；另外，要是有任何一个怪物到达了屏幕左侧边缘，则本场战斗失败。另外我们在显示结果的场景中还需要一个交互按钮，以便我们重新开始一轮游戏。 首先是检测被打死的怪物数，在 MyScene 里添加一个 monstersDestroyed，然后在打中怪物时使这个值 +1，并在随后判断如果消灭怪物数量大于等于 30，则切换场景 @interface MyScene() //… @property (nonatomic, assign) int monstersDestroyed; //… @end - (void)update:(CFTimeInterval)currentTime { //… for (SKSpriteNode * monster in monstersToDelete) { [self.monsters removeObject:monster]; [monster removeFromParent]; self.monstersDestroyed++; if (self.monstersDestroyed &gt;= 30) { //TODO: Show a win scene } } //… } 另外，在怪物到达屏幕边缘的时候也触发场景的切换： - (void)addMonster { //… SKAction * actionMoveDone = [SKAction runBlock:^{ [monster removeFromParent]; [self.monsters removeObject:monster]; //TODO: Show a lose scene }]; //… } 接下来就是制作新的表示结果的场景了。新建一个 SKScene 的子类很简单，和平时我们新建 Cocoa 或者 CocoaTouch 的类没有什么区别。菜单中 File-&gt;New-&gt;File…，选择 Objective-C class，然后将新建的文件取名为 ResultScene，父类填写为 SKScene，并在新建的时候选择合适的 Target 即可。在新建的 ResultScene.m 的 @implementation 中加入如下代码： - (instancetype)initWithSize:(CGSize)size won:(BOOL)won { if (self = [super initWithSize:size]) { self.backgroundColor = SKColor.whiteColor; SKLabelNode * resultLabel = [SKLabelNode labelNodeWithFontNamed:@”Chalkduster”]; resultLabel.text = won ? @”You win!” : @”You lose!”; resultLabel.fontSize = 30; resultLabel.fontColor = [SKColor blackColor]; resultLabel.position = self.view.center; [self addChild:resultLabel]; SKLabelNode * retryLabel = [SKLabelNode labelNodeWithFontNamed:@”Chalkduster”]; retryLabel.text = @”Try again”; retryLabel.fontSize = 20; retryLabel.fontColor = [SKColor blueColor]; retryLabel.position = CGPointMake(resultLabel.position.x, resultLabel.position.y * 0.8); retryLabel.name = @”retryLabel”; [self addChild:retryLabel]; } return self; } 我们在 ResultScene 中自定义了一个含有结果的初始化方法初始化，之后我们将使用这个方法来初始化 ResultScene。在这个 init 方法中我们做了以下这些事： 根据输入添加了一个 SKLabelNode 来显示游戏的结果。SKLabelNode 也是 SKNode 的子类，可以用来方便地显示不同字体、颜色或者样式的文字标签。 在结果标签的下方加入了一个重开一盘的标签 我们为这个 node 进行了命名，通过对 node 命名，我们可以在之后方便地拿到这个 node 的参照，而不必新建一个变量来持有它。在实际运用中，这个命名即可以用来存储一个唯一的名字，来帮助我们之后找到特定的 node(使用 -childNodeWithName:)，也可以一堆特性类似的 node 共用一个名字，这样可以方便枚举(使用 -enumerateChildNodesWithName:usingBlock: 方法)。不过这次的 demo 中，我们只是简单地用字符串比较来确定 node，稍后会看到具体的用法。 最后不要忘了这个方法名写到 .h 文件中去，这样我们才能在游戏场景中调用到。 回到游戏场景，在 MyScene.m 的加入对 ResultScene.h 的引用，然后在实现中加入一个切换场景的方法 #import “ResultScene.h” //… - (void)changeToResultSceneWithWon:(BOOL)won { [self.bgmPlayer stop]; self.bgmPlayer = nil; ResultScene rs = [[ResultScene alloc] initWithSize:self.size won:won]; SKTransition reveal = [SKTransition revealWithDirection:SKTransitionDirectionUp duration:1.0]; [self.scene.view presentScene:rs transition:reveal]; } SKTransition是专门用来做不同的 Scene 之前切换的类，这个类为我们提供了很多”廉价”的场景切换效果。在这里我们建立了一个将当前场景上推的切换效果，来显示新的 ResultScene。另外注意我们在这里停止了 BGM 的播放。之后，将刚才留下来的两个 TODO 的地方，分别替换为以相应参数对这个方法的调用。 最后，我们想要在 ResultScene 中点击 Retry 标签时，重开一盘游戏。在 ResultScene.m 中加入代码： - (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event { for (UITouch * touch in touches) { SKNode * node = [self nodeAtPoint:[touch locationInNode:self]]; if ([node.name isEqualToString:@”retryLabel”]) { MyScene * ms = [MyScene sceneWithSize:self.size]; SKTransition * reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:1.0]; [self.scene.view presentScene:ms transition:reveal]; } } } 运行游戏，消灭足够多的敌人（或者漏过一个敌人），应该能够可能到场景切换和结果显示。然后点击再来一次的话，将重新开始新的游戏。 九、关于 Sprite 的一些个人补充 首先是性能问题，如果有在 iOS 平台下使用 cocos2d 开发的经验的话，很容易看出来 SpriteKit 在很多地方借鉴了 cocos2d。作为 SDK 内置的框架来说，又有 cocos2d 的开源实现进行参考，效率方面超越 cocos2d 应该是理所当然的。在现有的一系列 benchmark 上来看，实际上 SpriteKit 在图形渲染方面也有着很不错的表现。另外，在编写过程中，也有不少技巧可以使用，以进一步进行优化，比如在内存中保持住常用的 action，预先加载资源，使用 Atlas 等等。在进行比较全面和完整的优化后，SpriteKit 的表现应该是可以期待的。 使用 SpriteKit 一个很明显的优点在于，SKView 其实是基于 UIKit 的 UIView 的一套实现，而其中的所有 SKNode 对象都 UIResponder 的子类，并且实现了 NSCoding 等接口。也就是说，其实在SpriteKit 中是可以很容易地使用其他的非游戏 Cocoa/CocoaTouch 框架的。比如可以使用 UIKit或者 Cocoa 来简单地制作 UI，然后只在需要每帧演算的时候使用 SpriteKit，藉此来达到快速开发的目的。这点上 cocos2d 是无法与之比拟的。另外，因为 SKSprite 同时兼顾了 iOS 和 Mac两者，因此在我们进行开发时如果能稍加注意，理论上可以比较容易地完成 iOS 和 Mac 的跨平台。 由于 SKNode 是 UIResponder 的子类，因此在真正制作游戏的时候，对于相应用户点击等操作我们是不必（也不应该）像 demo 中一样全部放在 Scene 点击事件中，而是应该尽量封装游戏中用到的node，并在 node 中处理用户的点击，并且委托到 Scene 中进行处理，可能逻辑上会更加清晰。 关于用户交互事件的处理，另外一个需要注意的地方在于，使用 UIResponder 监测的用户交互事件和 SKScene 的事件循环是相互独立的。如果像我们的 demo 中那样直接处理用户点击并和 SpriteKit 交互的话，我们并不能确定这个执行时机在 SKScene 循环中的状态。比如点击的相关代码也许会在 -update 后执行，也可能在 -didSimulatePhysics 后被调用，这引入了执行顺序的不确定性。对于上面的这个简单的 demo 来说这没有什么太大关系，但是在对于时间敏感的游戏逻辑或者带有物理模拟的游戏中，也许时序会很关键。由于点击事件的时序和精灵动画和物理等的时序不确定，有可能造成奇怪的问题。对此现在暂时的解决方法是仅在点击事件中设置一个标志位记录点击状态，然后在接下来的 -update: 中进行检测并处理(苹果给出的官方 SpriteKit 的 “Adventure” 是这样处理的)，以此来保证时序的正确性。代价是点击事件会延迟一帧才会被处理，虽然在绝大多数情况下并不是什么问题，但是其实这点上并不优雅，至少在现在的 beta 版中，算不上优雅。","tags":[]},{"title":" macro\t\t","date":"2017-11-13T07:31:14.000Z","path":"2017/11/13/macro/","text":"宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大","tags":[]},{"title":" const\t\t","date":"2017-11-13T07:23:52.000Z","path":"2017/11/13/const/","text":"参考文章：http://www.jianshu.com/p/f83335e036b5 通常使用 const 修饰符来定义常量。 常量：共享一块内存空间，即使多处使用，根据 const 修饰的位置来确定是否能修改。在编译阶段会执行类型检查。 常量的四种写法： ①、static const 数据类型 * 常量名 = 值; // 局部常量：用 static 修饰后，不能提供外界访问 ②、 const 数据类型 * 常量名 = 值; // 全局常量：不论定义在哪个文件夹中，外部都能访问 ③、 数据类型 const * 常量名 = 值; ④、 数据类型 * const 常量名= 值; const 修饰位置不同的区别？ 实例： 1、const int *p = NULL; 2、int const *p = NULL; 3、int* const p = NULL; 解析： 1、*p 不能被修改，p 能被修改； int a = 10; p = &a; // 正确 *p = 10; // 报错 2、*p 不能被修改，p 能被修改； int b = 20; p = &b; // 正确 *p = 20; // 报错 3、*p 能被修改，p 不能被修改； int a = 10; p = &a; // 报错 *p = 10; // 正确 注意： ①、1 和2 其实没什么区别。 ②、oc 中字符串的值是在常量区，3 中两种都报错。 结论： const 右边的总不能被修改。","tags":[]},{"title":" SQL\t\t","date":"2017-11-03T08:35:45.000Z","path":"2017/11/03/sql/","text":"一、SQL 语句 1、什么是 SQL SQL：全称 structured query language 结构化查询语言，是一种对关系型数据库中的数据进行定义和操作的语言。语言简洁，语法简单，好学好用。 2、什么是 SQL 语句 使用 SQL 语言编写出来的句子/代码，就是 SQL 语句。在程序运行过程中，要想操作数据库中的数据，必须使用 SQL 语句。 3、SQL 语句的特点 不区分大小写(比如数据库认为 user 和UsEr 是一样的) 每条语句都必须以分号 ‘;’ 结尾 4、SQL 中的常用关键字 select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index 等等。数据库中不可以使用关键字来命名表、字段。 二、SQL 语句的种类 1、数据定义语句(DDL:Data Definition Language)可以用于对数据库中的表进行操作。包括 create(新建)、drop(删除表)。 2、数据操作语句(DML:Data Manipulation Language)可以用于对数据库中的数据进行操作。包括insert(添加)、update(修改)、delete(删除)。 3、数据查询语句(DQL:Data Query Language)可以用于查询获得表中的数据。关键字 select 是DQL(也是所有 SQL)用得最多的操作。其他 DQL 常用的关键字有 where、order by、group by 和 having。 三、基本操作 1、创建表 create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …); 示例： create table t_st (id integer, name text, age integer, score real); 2、字段类型 SQLite 将数据划分为以下几种存储类型： text 文本字符串 real 浮点值 integer 整型值 blob 二进制数据(比如文件) 注意：实际上 SQLite 是无类型的，就算声明为 integer 类型，还是能存储字符串文本(主键除外)。建表时声明任何类型或者不声明类型都可以，也就意味着创表语句可以这么写： create table t_st(name, age); 提示：为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型。 3、删表 drop table 表名; drop table if exists 表名; 示例： drop table t_st; 4、插入数据 insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …); 示例： insert into t_st (name, age) values (‘mj’, 10); 注意：数据库中的字符串内容应该用单引号括住 5、更新数据 update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, …; 示例： update t_st set name = ‘jack’, age = 20; 注意：上面的示例会将 t_st 表中所有记录的 name 都改为 jack，age 都改为 20 6、删除数据 delete from 表名 ; 示例： delete from t_st ; 注意：上面的示例会将 t_st 表中所有记录都删掉。 7、条件语句 如果只想更新或者删除某些固定的记录，那就必须在 DML 语句后加上一些条件。 条件语句的常见格式： where 字段 = 某个值 ; // 不能用 == where 字段 is 某个值 ; // is 相当于 = where 字段 != 某个值 ; where 字段 is not 某个值 ; // is not 相当于!= where 字段 > 某个值 ; where 字段1 = 某个值 and 字段2 &gt; 某个值 ; // and 相当于C 语言中的&amp;&amp; where 字段1 = 某个值 or 字段2 = 某个值 ; // or 相当于C 语言中的|| 示例： ①、将 t_st 表中年龄大于 10 并且 姓名不是 jack 的记录，年龄都改为 5 update t_st set age = 5 where age &gt; 10 and name != ‘jack’ ; ②、删除 t_st 表中年龄小于等于 10 或者年龄大于 30 的记录 delete from t_st where age &lt;= 10 or age &gt; 30 ; ③、将 t_st 表中名字等于 jack 的记录，score 字段的值都改为 age 字段的值 update t_st set score = age where name = ‘jack’ ; 8、DQL 语句 select 字段1, 字段2, … from 表名 ; select * from 表名; // 查询所有的字段 示例： select name, age from t_st where age &gt; 10 ; 9、起别名(字段和表都可以起别名) select 字段1 别名, 字段2 别名, … from 表名 别名 ; select 别名.字段1, 别名.字段2, … from 表名 别名 ; select 字段1 别名, 字段2 as 别名, … from 表名 as 别名 ; 示例： select name myname, s.age from t_st as s ; 10、计算记录的数量 select count (字段) from 表名 ; select count ( * ) from 表名 ; 示例： select count (age) from t_st where score &gt;= 60; 11、排序 select * from t_st order by 字段 ; 默认是按照升序排序(由小到大)，也可以变为降序(由大到小) select * from t_st order by age desc ; // 降序 select * from t_st order by age asc ; // 升序(默认) 也可以用多个字段进行排序。 // 先按照年龄升序，相同年龄再按照身高降序 select * from t_st order by age asc, height desc ; 12、limit 使用 limit 可以精确地控制查询结果的数量，比如每次只查询 10 条数据 select * from 表名 limit 数值1, 数值2 ; 示例： select * from t_st limit 4, 8 ; // 跳过最前面 4 条语句，然后取8 条记录 limit 常用来做分页查询，比如每页固定显示 5 条数据，那么应该这样取数据： 第 n 页：limit 5*(n-1), 5 // limit 5 相当于limit 0, 5 取最前面的5 条 四、约束 1、简单约束 建表时可以给特定的字段设置一些约束条件，常见的约束有 not null 规定字段的值不能为 null unique 规定字段的值必须唯一 default 指定字段的默认值 建议：尽量给字段设定严格的约束，以保证数据的规范性。 示例： create table st (id integer, name text not null unique, age integer not null default 1) ; // name 字段不能为null，并且唯一；age 字段不能为null，并且默认为 1 2、主键约束 ①、简单说明 如果 t_st 表中就 name 和 age 两个字段，而且有些记录的 name 和 age 字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据。 良好的数据库编程规范应该要保证每条记录的唯一性。为此，增加了主键约束，也就是说，每张表都必须有一个主键，用来标识记录的唯一性 ②、什么是主键？ 主键(Primary Key，简称 PK)用来唯一地标识某一条记录。例如：t_st 可以增加一个 id 字段作为主键，相当于人的身份证。主键可以是一个字段或多个字段。 ③、主键的设计原则 主键应当是对用户没有意义的 永远也不要更新主键 主键不应包含动态变化的数据 主键应当由计算机自动生成 ④、主键的声明 在创表的时候用 primary key 声明一个主键 // integer 类型的id 作为t_st 表的主键 create table t_st (id integer primary key, name text, age integer); 只要声明为 primary key，就说明是一个主键字段。主键字段默认就包含了 not null 和 unique 两个约束。 如果想要让主键自动增长(必须是 integer 类型)，应该增加 autoincrement create table t_st (id integer primary key autoincrement, …) ; 3、外键约束 利用外键约束可以用来建立表与表之间的联系。外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段。 新建一个外键： // 以下外键的作用是用 t_st 表中的 class_id 字段引用 t_class 表的 id 字段 create table t_st (id integer primary key autoincrement, name text, age integer, class_id integer, constraint fk_student_class foreign key (class_id) references t_class (id)); // t_st 表中有一个叫做 fk_t_student_class_id_t_class_id 的外键 4、表连接查询 需要联合多张表才能查到想要的数据 表连接的类型： 内连接：inner join 或者join(显示的是左右表都有完整字段值的记录) 左外连接：left outer join(保证左表数据的完整性) 示例： // 查询 0316iOS 班的所有学生 select s.name, s.age from t_st s, t_class c where s.class_id = c.id and c.name = ‘0316iOS’;","tags":[]},{"title":" SSH、SSL 与 HTTPS\t\t","date":"2017-11-02T02:16:25.000Z","path":"2017/11/02/ssh-e3-80-81ssl-e4-b8-8e-https/","text":"一、关于加密 在解释 SSH、SSL 与 HTTPS 协议之前先介绍一下非对称加密协议。在 1976 年以前，所有的加密都采用对称加密，即 A 使用某种加密规则对信息加密，B 收到信息后逆向加密规则解密数据。这通信方式产生了一个难以解决的问题：A 如何安全的把加密规则通知 B？ 在 1976 年有两位数学家提出了一个崭新的非对加密的概念： A 生成一对两把密钥(公钥和私钥)。公钥是公开的，任何人都可以获得，私钥则是保密的。 B 获取乙方的公钥，然后用它对信息加密。 A 得到加密后的信息，用私钥解密。 受这个思路的启发，三位数学家 Rivest、Shamir 和 Adleman 设计了一种具体实现上面描述的非对称加密的算法，以他们三个人的名字命名，就是目前在计算机领域应用非常广泛的非对称加密算法 RSA加密算法。这样网络上传输的数据都经过公钥加密，然后用私钥解密，就算被第三方截获也无法解密出原始数据。想深入理解非对称加密解密的原理可以看这里。 虽然非对称加密很安全很强大，但是它也有缺点，相对于对称加密它计算量更大，计算时间更长。所以在大规模数据的安全通信场景中，普遍采用非对称加密技术来交换对称加密密钥，之后的通信都采用对称加密技术加密。 二、SSH Secure Shell(缩写为SSH)，由 IETF 的网络工作小组(Network Working Group)所制定；SSH为一项创建在应用层和传输层基础上的安全协议，为计算机上的 Shell(壳层)提供安全的传输和使用环境。 传统的网络服务程序，如 rsh、FTP、POP和 Telnet 其本质上都是不安全的，因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到 中间人(man-in-the-middle)攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。 而 SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。通过 SSH 可以对所有传输的数据进行加密，也能够防止 DNS欺骗和 IP 欺骗。 SSH 的另一项优点为其传输的数据可以是经过压缩的，所以可以加快传输的速度。SSH 有很多功能，它既可以代替 Telnet，又可以为 FTP、POP、甚至为 PPP 提供一个安全的”通道”。 客户端 A 与服务器 B 之间需要通信的数据中间经过了 C、D、E、F 等网络路由器设备，这其中任何一个路由器被黑客攻破，你们之间的通信数据就毫无保留的被别人看到。 非对称加密 - 安全的方式来传输密钥： A、B 之间建立TCP 连接 B 生成一对公私密钥 B 把公钥发送给A A 生成一个用于加密数据的密钥K(即客户端想通知给服务器的密钥，之后的数据通信都使用这个密钥加密，这个密钥不可让第三方知道) A 把K 用公钥加密发送给B，B 解密后，从此A、B 之间的通信数据都用K 密钥进行加密和解密。 这样假如中间的 C、D、E 截获了 A 发给 B 的 K 密钥内容的数据包，可是这个密钥是用 B 服务器生成的公钥加密过的，只有 B 服务器知道如何解密。于是我们的数据很安全了。。。 但是如果黑客 H 埋伏在了 A 和 B 之间的某一个路由器上，他假冒 B 生成一对公私密钥，然后把公钥发送给 A，这样 A 与 H 之间就建成了一个加密通道，A 把所有信息发送给 H，H 截获 A 的信息，在假冒 A 与 B 通信。如此一来，A、B 之间的通信就完全暴漏给了 H，而 A、B 却完全不知道，这就是有名的”中间人”攻击。 为解决这个问题，SSH 协议采用由人工判断公钥的 fingerprint 是否可信的方式。当使用 ssh 命令连接服务器时，命令行会提示如下信息: The authenticity of host ‘168.30.9.213 ()’ can’t be established. RSA key fingerprint is 23:42:c1:e4:3f:d2:cc:37:1d:89:cb:e7:5d:be:5d:53. Are you sure you want to continue connecting (yes/no)? 输入 yes 之后才会连接到远程服务器，同时这个信息会存储到用户的 .ssh/known_hosts 文件中，下次再登录的时候，会检查 known_host文件，如果存在相同的公钥信息，就不再提示用户确认了。 这种认证方式假设要登陆服务器的用户已经知道服务器公钥(作为服务器的用户自然有渠道得知服务器公钥)。fingerprint 其实就代表公钥，可以看成是公钥的一个压缩版。有了这个步骤，如果有中间人想冒充服务器 B 发送公钥给 A，它不可能生成一对和 B 生成的一样的公私密钥，他发送给 A 的公钥必然与 B 服务器的不同，所以用户就可以根据 printfinger 判断所连接的服务器是否可信，有没有被中间人冒充。 三、SSH 的实现细节 上面只是粗略讲解 SSH 的安全协议的设计思路，实际上 SSH 通信协议在安全通信过程中分了几个阶段，每个阶段又细分了几个步骤，具体的可参看 SSH原理简介。几个主要阶段如下： 协议协商阶段 服务端认证阶段 客户端认证阶段 数据传输阶段 四、客户端认证 这里我想单独谈谈客户端认证，因为对于使用 linux 远程登录功能的系统管理员来说能有直观感觉的也就是是这个环节了。一般我们能接触到的的认证方式有两种： 密码认证 Public Key 认证 密码认证很好理解，就是我们在登录远程 linux 服务器的时候提供用户名和密码？这里面稍微提示一下，在你的用户名和密码通过网络传输给服务器之前，已经经过了服务器认证协商阶段，这是一个安全的加密信道已经建立，所以你的用户名和密码都是加密后传输给服务器的，保证不会被第三方截获。 每次登录都要输入密码很麻烦，且密码如果简单的话可能还会被暴力破解。Public Key 认证提供了一种更安全便捷的认证客户端的方式。这个技术也用到了非对称加密技术，由客户端生成公私密钥对，然后将公钥保存在服务器上。认证的过程大体如下： 客户端发起一个 Public Key 的认证请求，并发送RSA Key 的模数作为标识符。(RSA Key)) 服务端检查是否存在请求帐号的公钥(Linux 中存储在~/.ssh/authorized_keys文件中)，以及其拥有的访问权限。如果没有则断开连接。 服务端使用对应的公钥对一个随机的 256 位的字符串进行加密，并发送给客户端。 客户端使用私钥对字符串进行解密，并将其结合 session id 生成一个MD5 值发送给服务端。结合session id 的目的是为了避免攻击者采用重放攻击(replay attack)。 服务端采用同样的方式生成 MD5 值与客户端返回的MD5 值进行比较，完成对客户端的认证。 五、为更广大群众设计的 SSL 与 TLS SSH 其实是专门为 shell 设计的一种通信协议，它跨了两个网络层(传输层和应用层)。通俗点讲就是只有 SSH 客户端和 SSH 服务器端之间的通信才能使用这个协议，其他软件服务无法使用它。但是其实我们非常需要一个通用的建立在应用层之下的一个传输层安全协议，它的目标是建立一种对上层应用协议透明的，不管是 HTTP、FTP、还是电子邮件协议或其他任何应用层协议都可以依赖的底层的可安全通信的传输层协议。 网景公司于 1994 年为解决上面的问题，设计了 SSL(Secure Sockets Layer) 协议的 1.0 版本，但并未发布，直到 1996 年发布 SSL3.0 之后，开始大规模应用于互联网服务。可能很多人听说过 TLS(Transport Layer Security)。它相当于是 SSL 协议的一个后续版本，是 SSL 经过 IETF 标准化之后的产物(详细参考传输层安全协议)。 跟 SSH 相比 SSL 所面临的问题要更复杂一些，上面我们提到，SSH 协议通过人工鉴别 Public Key 的 printfinger 来判断与之通信的服务器是否可信(不是伪装的中间人)。可是 SSL 是为了整个互联网上的所有客户端与服务器之间通信而设计的，他们彼此之间不可能自己判断通信的对方是否可信。那么如何解决这个问题呢？ 六、数字签名 以浏览器和网站服务器之间的安全通信举例，首先浏览器要求和某 web 服务器建立安全的 SSL 连接通道，这时需要服务器的公钥用来加密浏览器生成的通信密钥，发给 web 服务器，以确定通信密钥。假如浏览器接受到一个公钥，它如何知道这个公钥确实是来自那个 web 服务器，而不是中间的某个攻击者截获了它的请求，假扮 web 服务器给它的假密钥？浏览器总不能记录所有可信任站点的公钥吧。 解决问题的思路是这样的，在 SSL 协议中引入了一种类似公共机关的概念，就是我们熟知的 CA(数字证书认证机构)。它为浏览器发行一个叫数字证书的东西。这个东西大体上如下图所示，其中比较重要的信息有： 对象的公开密钥 数字签名 有了数字证书，浏览器在建立 SSL 连接之前，并不只是简单获取服务器的公钥，而从服务器获取数字证书。数字证书里有服务器的公钥，并且有 CA 给这个证书签发的签名。这个签名其实是证书内容的摘要经过 CA 私钥加密生成的。这样浏览器得到证书内容和摘要，并用 CA 的公钥(每个浏览器都存储着一些权威 CA 的公钥)对数字签名解密，也得到证书的摘要，比对两个摘要如果相同，说明证书是真的，且未经过修改。信任问题就这么解决了，如果上面这段话不好理解的话，再次建议读一读阮老师的数字签名是什么？。 其他 SSL 的握手，密钥交换，加密的细节这里就不介绍了，普通开发者这要懂上面我介绍的这些基本概念就可以了。 七、HTTPS 全称是 Hypertext Transfer Protocol Secure，也称为 HTTP over TLS、HTTP over SSL，其实就是客户端与服务器之间的 HTTP 通信基于 TLS 或者 SSL 协议。对于 HTTP 协议和 SSL/TLS 协议本身没有任何特殊定制，因为 SSL/STL 本身对 HTTP 协议就是透明的，HTTP 在 SSL/TLS 上运作也不需要任何特殊处理。 作为网站管理员，可能会遇到申请数字证书的任务，理解了上面的概念，申请数字证书就不那么一头雾水了，首先你要为服务器生成一对公司密钥，然后把你网站的信息连同你的公钥一起发送给某个权威的 CA，CA 会通过某种方式认证申请人是否真的是网站的所有人，比如让你在网站的指定路径上传他指定的特殊文字序列。验证通过就会得到证书了。 Alice，Bob 和信鸽？ 你在互联网上的任何活动（阅读这篇文章，在亚马逊上买东西，上传猫咪的图片）都归结为向服务器发送消息和从服务器接收消息。 这么讲听起来可能有点抽象，因此，我们不妨假设这些信息是通过信鸽传递的。我明白这么假设显得很随意，但请相信我：HTTPS 的工作原理就是这样的，只是快得多。 本文中我们并不会使用，服务器，客户端和黑客这样的术语，取而代之的是，我们会依次使用人名 Alice、 Bob 和 Mallory来代替它们。如果你不是第一次尝试理解密码概念，你可以认出这些名字，因为它们被广泛用于技术文献中。 一次简单的通讯 如果 Alice 想要给 Bob 传递一条信息，她将信息绑在信鸽的腿上，然后让信鸽传给 Bob。Bob 收到信息，读取信息。一切都正常。 但要是 Mallory 途中拦截了 Alice 的信鸽，并且改变了信息的内容？Bob 无法知道 Alice 发送的信息在传递途中被修改了。 这就是 HTTP 的工作原理。挺可怕的，对吧？我不会通过 HTTP 协议来发送我的银行凭证，你也不应该这么做。 一个密令 那如果 Alice 和 Bob 都很机灵呢。他们同意将使用密令来写信息。他们将字母表中的每个字母偏移 3 个位置。比如：D -&gt; A, E -&gt; B, F -&gt; C。明文“secret message”将转换成“pbzobq jbppxdb”。 现在，如果 Mallory 拦截了信鸽，她既不能把信息改变成一些有意义的信息，也不能明白信息里说的内容，因为她不知道密令。但是Bob可以简单地反向应用密令（A -&gt; D, B -&gt; E, C -&gt; F）将信息解密。密文“pbzobq jbppxdb”将被解密回“secret message”。 大功告成！ 这被称为对称密钥密码术，因为当你知道如何加密一条信息，你也知道如何给信息解密。 我在上面介绍的密令通常被称为凯撒密码。在现实生活中，我们使用更高级和复杂的密令，但是主要思路是相同的。 我们如何决定密钥是什么？ 如果只有发送方和接收方知道密钥，对称密钥密码术是很安全的。在凯撒密码中，密钥是一个偏移值，这个偏移值决定每个字母应该偏移多少。在我们的例子中，我们使用的偏移值是 3，但是也能是 4 或者 12。 不过这么设计会有个问题：在用信鸽传递信息之前，如果 Alice 和 Bob 之前从没见过，他们没有安全的方式创建一个密钥。如果他们将密钥包含在信息之中，Mallory 将拦截信息并且发现密钥。后果就是：无论 Alice 和 Bob 发送的信息是否加密，Mallory 都能读取或者改变拦截到的信息。 这是一个典型的中间人攻击例子。避免它的唯一方法是改变之前的密码系统。 携带盒子的信鸽 所以 Alice 和 Bob 想出了一个更好的系统。当 Bob 想要发送信息给 Alice 时，Alice 将遵照下面的流程： Bob 向 Alice 传送一只信鸽，信鸽不携带任何信息。 Alice 将这只信鸽传回给 Bob，信鸽携带一只开着锁的盒子以及密钥。 Bob 把信息放到盒子里，将锁锁上，将盒子传送给 Alice。 Alice 收到盒子，使用密钥打开盒子，读取信息。 通过这种方式传递信息，Mallory 不可能通过拦截信鸽的方式来改变信息，因为她没有密钥。当 Alice 想要向 Bob 发送信息时，遵循相同的流程。 Alice 和 Bob 刚刚使用了通常所说的非对称密钥密码术。之所以称它为非对称，是因为即使你可以加密一条信息（锁上盒子）但你也不能将它解密（打开锁住的盒子）。 我怎么信任这个盒子？ 如果你够仔细的话，你可能已经意识到我们仍然有一个问题。当 Bob 收到那个开着的盒子时，他如何确信这是来自 Alice 的盒子，而不是 Mallory 拦截信鸽后，将来自于 Alice 的盒子替换成 Mallory 自己设置了密钥后的盒子。 Alice 决定对盒子进行数字签名，通过这种方式，当 Bob 收到盒子，他通过核对签名的一致性来确定盒子是否来自 Alice。 有些人可能就会想 Bob 如何识别 Alice 的签名？不错的问题。Alice 和 Bob 也有同样的疑问。因此他们决定让 Ted 对盒子进行数字签名，而不是 Alice。 Ted 是谁？Ted 是一个著名且值得信赖的人。每个人都可以从Ted 那里获得签名，每个人都相信Ted 只会为合法的人提供盒子的数字签名服务。 只有当Ted 确信正在请求签名的人是 Alice，Ted 才会为 Alice 提供盒子数字签名的服务。因此 Mallory 不能再像之前那样拦截 Alice 的盒子、替换盒子后传送给 Bob 了，因为 Bob 会发现这个盒子在 Ted 那进行数字签名的是 Mallory，而不是 Alice。 Ted 在技术术语中通常被称为证书颁发机构，你阅读这篇文章所使用的浏览器安装着各种证书颁发机构的签名。 因此当你第一次连接到一个网站，你信任它的盒子，因为你信任 Ted，而 Ted 告诉你这个盒子是合法的。 盒子太重了 Alice 和 Bob 现在有了一个可靠的通信系统，但是他们意识到和仅仅携带信息的信鸽相比，携带盒子的信鸽太慢了。 他们决定只在传递密钥的时候使用盒子的方法（非对称密码术），加密信息使用对称密码术（记得之前提到的凯撒密码？）。 这样的话可谓两全其美：非对称密码术的可靠性和对称密码术的效率都有了。 在现实世界中，“信鸽”的传送速度都很快，但尽管这么讲，使用非对称密码技术加密消息比使用对称密码技术慢，所以我们只使用它来交换加密密钥。 http://www.sohu.com/a/270346684_479559","tags":[]},{"title":" 密码学\t\t","date":"2017-11-02T01:44:51.000Z","path":"2017/11/02/e5-af-86-e7-a0-81-e5-ad-a6/","text":"1、加密方法可以分为两大类： 单钥加密 (private key cryptography)。加密和解密过程都用同一套密码。 双钥加密 ( public key cryptography)。加密和解密过程用的是两套密码。 人类传统的加密方法都是前一种，比如二战期间德军用的 Enigma 电报密码。莫尔斯电码也可以看作是一种私钥加密方法。 2、在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。 3、在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。双钥加密的原理如下： 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。 所有的(公钥、私钥)对都是不同的。 用公钥可以解开私钥加密的信息，反之亦成立。 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。 4、目前，通用的单钥加密算法为 DES(Data Encryption Standard)，通用的双钥加密算法为 RSA(Rivest-Shamir-Adleman)，都产生于上个世纪 70 年代。 5、在双钥体系中，公钥用来加密信息，私钥用来数字签名。 6、因为任何人都可以生成自己的(公钥、私钥)对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的(公钥、私钥)对。目前，世界上最主要的数字服务认证商是位于美国加州的 Verisign公司，它的主要业务就是分发 RSA 数字证书。","tags":[]},{"title":" 数字签名\t\t","date":"2017-11-01T09:25:02.000Z","path":"2017/11/01/e6-95-b0-e5-ad-97-e7-ad-be-e5-90-8d/","text":"原文网址：http://www.youdzone.com/signature.html 学习文章：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html 一、数字签名1、鲍勃有两把钥匙，一把是公钥，另一把是私钥。 2、鲍勃把公钥送给他的朋友们 3、苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。 4、鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 5、鲍勃给苏珊回信，决定采用 “数字签名” 证明自己是鲍勃（身份认证）。他写完后先用 Hash 函数，生成信件的摘要(digest)。 6、然后鲍勃使用私钥对这个摘要加密，生成 “数字签名”(signature)。 7、鲍勃将这个签名，附在信件下面，一起发给苏珊。 8、苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。（疑问） 9、苏珊再对信件本身使用 Hash 函数，将得到的结果与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 10、复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。 11、后来苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去 找 “证书中心”(certificate authority，简称 CA)为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”(Digital Certificate)。 12、鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 13、苏珊收信后，用 CA 的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 下面，我们看一个应用”数字证书”的实例：https 协议。这个协议主要用于网页加密。 14、首先，客户端向服务器发出加密请求。 15、服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 16、客户端(浏览器)的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 17、如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 18、如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 19、如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。（疑问） 二、疑问1、既然道格可以替换鲍勃的公钥，为什么不能伪造 CA 的公钥，然后用自己的私钥伪造成 CA 的数字证书？ CA 都是一些可靠的大机构，它们的公钥在自己网站上提供下载，是可查的，所以无法伪造。比如在 MSDN 里可以查到微软用于签名 driver 的公钥（Base64 码）。 2、什么时候获得 CA 公钥？ CA 的公钥网上可以取得，浏览器中也有预存。 3、CA 公钥如何避免被替换的问题呢？ 上面将数据完整性和数据加密放在一起讲，会让人糊涂。 实际上，数字签名是保证数据完整性的，但它不保证数据加密，不保证数据传输途中无人嗅探窃听。好比一辆敞篷大货车从 A开到 B，中途没有洒落任何东西，完整性得到了保证。但是车上有什么东西也被路人看光光。 数据加密是从 A 到 B 建了一条虚拟隧道，货车在里面开，路人谁也不知道是什么东西。 车子到了 B 后，送货的人给出自己的身份证，证明自己的确是从 A 来的。收货的人可以选择相信这个身份证，也可以把身份证放到自己的身份证校验仪查询，看看是不是公安部发的真的身份证。 如果你的身份证校验仪（CA）已经是假的了，那就啥都别说了，重装系统吧。 因为有 Online Certificate Status Protocol 和 HTTP Public Key Pinnin 这两个东西存在，浏览器会去检查CA的证书是否已被吊销。 浏览器对证书及时的更新，即发给权威机构 CA，CA 用自己的私钥发现解不开假的证书，或者解得的是乱码，则反馈给浏览器，浏览器再警告给用户，证书被人通过隐蔽的方式偷换掉了，此证书是假的，请删除。 4、如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息？ 通常公钥算法用于相互验证，之后会建立 session key（比如 128 位 AES key），后续交互的信息都是用 session key 和对称加密算法（比如 AES）来加解密的，已经与证书本身和公钥密钥无关。因为公私钥算法比对称密钥算法开销大很多。 为了速度，https 只在建立连接时使用服务器的公钥加密，这个阶段是为了交换一个共享密钥，接下来使用的是对称算法。 https 中，第二阶段的服务端与客户端沟通是：客户端拿到服务端的公钥后，产生一个随机的 key，然后用服务端的公钥加密传递给服务端，服务端拿到加密后的 key，利用服务端原有的私钥解密，得到 key 的原文。然后后面跟客户端通讯就使用 key 作为对称加密的私钥，进行通讯了。其实 https 真正的数据传递过程，走的是对称加密。 5、公钥和私钥的算法是一样的吗？为什么私钥加密可以用公钥解密？ 私钥和公钥在算法上是等价的，只不过一个是 private，一个是 public。这个应该是由密钥生成算法保证的。 6、如果鲍勃的公钥被加密，同时 CA 的公钥也在证书中附送，那加密鲍勃公钥有什么意义？ ①、确实是被 CA 的私钥加密的，这里的意义不在于加密（数据的保密性），而是保证证书是由 CA 签发的。 ②、Bob 的公钥被用于后续的会话密钥（session key）交换时的加密传输。 7、加密和认证的区别？ 加密：公钥加密、私钥解密 认证：私钥加密、公钥解密 8、公钥解密数字签名成功是否作为认证条件？ 网上关于数字签名验证时的一个争论：一个观点，公钥解密签名成功就可以证明消息 A 发送的，之后再将 hash 值比较证明的是原文是否被篡改过。另一种观点，公钥的解密不存在成功还是失败的问题，需要结合第 9 步的 hash 值比较来证明，消息确实是 A 发送的且没有被篡改过。 以 RSA 算法为例，单纯的从其原理上来说，确实没有解密失败的概念，因为本身解密过程只是一次乘方和取模的运算。即使以不匹配的公钥去解密，也是可以计算出一个值的。 但根据 RFC2313 来看，数字签名包括 4 个步骤：消息散列 -》DER数据编码 -》RSA 私钥加密 -》字节串到位串的转换。而解密就是上述过程的逆过程，位串到字节串的转换 -》RSA 公钥解密 -》DER 数据解码 -》解密后的散列值，最后与原始数据散列值进行比较。如果是不匹配的公钥解密，可能会因为解密时的标记位不对应等原因而直接报错，即解密失败。也就是根据能否解密成功来达到防抵赖性，根据散列值的比较达到防伪造性。 而大部分语言的标准实现应该都是输入公钥、原内容和签名，输出 true 或 false。即无法知道是内容被伪造还是其他人伪造了签名，总之是签名验证失败。 文章：https://www.jianshu.com/p/94f0a608055c","tags":[]},{"title":" TCP 疑问\t\t","date":"2017-11-01T08:58:15.000Z","path":"2017/11/01/tcpquestion/","text":"1、为什么在 TCP 协议里，建立连接是三次握手，而关闭连接却是四次握手呢？ 因为当处于 LISTEN 状态的服务器端 SOCKET 收到 SYN 报文（客户端希望新建一个 TCP 连接）后，它可以把 ACK（应答作用）和 SYN（同步作用）放在同一个报文里来发送给客户端。 而关闭 TCP 连接时，当收到对方的 FIN 报文时，仅仅表示对方没有数据发送给你了，但未必你的所有数据都已经全部发送给了对方，所以己方可以立即关闭 SOCKET（发送一个 FIN 报文），也可以等你发送完剩余的数据给对方之后，再发送 FIN 报文给对方来表示你同意现在关闭连接了，所以通常情况下，这里的 ACK 报文和 FIN 报文都是分开发送的。 2、可以两次握手吗？ TCP 连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。 TCP ClientFlagsTCP Server1 Send SYN (seq=x)—-SYN—SYN Received 2 SYN/ACK Received&lt;—SYN/ACK—-Send SYN (seq=y)， ACK (x+1)3 Send ACK (y+1)—-ACK—ACK Received，ConnectionEstablishedw: ISN (Initial Sequence Number) oftheClientx: ISN of the Server ①、TCP 的三次握手最主要是防止已过期的连接再次传到被连接的主机。 如果采用两次的话，会出现下面这种情况：比如是 A 机要连到 B 机，结果发送的连接信息由于某种原因没有到达 B 机；于是 A 机又发了一次，结果这次 B 收到了，于是就发信息回来，两机就连接。传完东西后，断开。结果这时候，原先没有到达的连接信息突然又传到了 B 机，于是 B 机发信息给 A，然后 B 机就以为和 A 连上了，这个时候 B 机就在等待 A 传东西过去。而此时 A 已经关闭，A 对于 B 的同一链接请求不予响应，导致 B 一直等待响应，浪费资源。 ②、三次握手改成仅需要两次握手，死锁是可能发生。 考虑计算机 A 和 B 之间的通信，假定 B 给 A 发送一个连接请求分组，A 收到了这个分组，并发送了确认应答分组。按照两次握手的协定，A 认为连接已经成功地建立了，可以开始发送数据分组。可是 B 在A 的应答分组在传输中被丢失的情况下，将不知道 A 是否已准备好，不知道 A 建议什么样的序列号，B甚至怀疑 A 是否收到自己的连接请求分组。在这种情况下，B 认为连接还未建立成功，将忽略 A 发来的任何数据分组，只等待连接确认应答分组。这样就形成了死锁。 3、为什么 TIME_WAIT 状态还需要等 2*MSL 秒之后才能返回到 CLOSED 状态呢？ 因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SENT 状态到 ESTABLISH 状态那样），但是我们必须假想网络是不可靠的，你无法保证最后发送的 ACK 报文一定会被对方收到，就是说对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。 ①、保证发送的最后一个 ACK 报文能被收到 后关闭的一端 B 发送了 FIN+ACK 报文给先关闭的 A，但是 A 可能因为网络等原因未收到请求，B 不能及时收到回复，此时，B 可能会再发一段 FIN+ACK 报文给 A 端。此时如果 A 在 2MSL 时间段内收到这个重传的 FIN+ACK 报文段，接着 A 重传一段确认，重新启动 2MSL 计时器，最终 A、B 进入 close 状态。 如果 A 不等待，即发送完 ACK 报文立即释放，则无法收到 B 重传的 FIN+ACK 报文，所以 A 也就不会重发一段 ACK 报文，则 B 无法正常进入 close 状态。 ②、防止“已失效的连接请求报文段”出现在本连接中 A 在发送完最后一个 ACK 报文段后，再经过 2*MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。 当某个连接的一端处于 TIME_WAIT 状态时，该连接将不能再被使用。 4、关闭 TCP 连接一定需要 4 次挥手吗？ 不一定，4 次挥手关闭 TCP 连接是最安全的做法。但在有些时候，我们不喜欢 TIME_WAIT 状态（如当 MSL 数值设置过大导致服务器端有太多 TIME_WAIT 状态的 TCP 连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源），这时我们可以通过设置 SOCKET 变量的 SO_LINGER 标志来避免 SOCKET 在 close() 之后进入 TIME_WAIT 状态，这时将通过发送 RST 强制终止 TCP 连接（取代正常的 TCP 四次握手的终止方式）。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的。 5、如果已经建立了连接，但是客户端突然出现故障了怎么办？ ①、TCP 设有一个保活计时器。服务器每收到一个客户端的请求，都会重新复位这个计时器，通常设置是 2 小时； ②、若 2 小时内，还没有收到客户端的回复，服务器会发送一个探测报文段，以后每隔 75 分钟发送一次； ③、若一连发送 10 个探测报文仍然无反应，则终止链接。 6、Server 端易受到 SYN 攻击？ ①、服务端的资源分配是在二次握手时分配的，而客户端的资源是在三次握手时分配的； ②、SYN 攻击，即客户端在短时间内伪造大量不存在的 IP 地址，并向 SERVER 端不断的发送 SYN 包，SERVER 收到请求即回复确认，并等待客户端的确认，由于源地址不存在，因此 SERVER 需要不断的重发直到超时； ③、这些伪造的 SYN 包长时间占用未连接队列，导致正常的 SYN 请求因为队列满而丢弃，因为网络拥塞； ④、一般服务端会重试 5 次。 7、SYN Flood 防护措施 ①、无效链接释放，监视系统中的半开链接和不活动的链接，达到阈值时释放资源，但是这样可能也会将正常的链接释放掉； ②、延缓 TCB 分配； ③、正常情况下，当 SYN 报文收到的时候，系统即分配资源，那么可以在收到 SYN 时，不着急分配 TCB，而是先回应一个 ACK 报文，并在一个专用的 Hash 表中，保存这种半开链接，等收到 ACK 再分配。 ④、Syn Cookie：将第一次收到请求的 IP 端口等信息加密生成一字符串，在收到 ACK 的时候，判断是否一致，一致则分配。","tags":[]},{"title":" malloc\t\t","date":"2017-11-01T08:34:15.000Z","path":"2017/11/01/malloc-1/","text":"原文：iOS内存管理和malloc源码解读 在内存管理方面，iOS 和其它操作系统总体上来说是大同小异的：大的框架原理基本相似，小的细节有所创新和不同。 与其它操作系统上运行的进程类似，iOS app 进程的地址空间也分为代码区、数据区、栈区和堆区等。进程开始时，会把 mach-o 文件中的各部分按需加载到内存当中。而对于一般的 iPhone，实际物理内存都在 1G 左右，对于超大的内存需求怎么办呢？ 和其它操作系统一样，都由系统内核维护一套虚拟内存系统，但需要注意的是 iOS 的虚存系统原则略有不同。最截然不同的地方就是当物理内存紧张情况时的处理。当物理内存紧张时，iOS 会把可以通过重新映射来加载的内容直接清理出内存；对于不可再生的数据，iOS 需要 app 进程配合处理，向各进程发送内存警告，要求配合释放内存。对于不能及时释放足够内存的，直接杀掉进程，必要时甚至是前台运行的 app。 如上所述，iOS 在外存没有交换区，没有内存页换出的过程。 一、malloc 基本原理在 iOS app 进程地址空间的各个区域中，堆区最灵活，它为进程动态分配内存，也是开发人员经常和内存打交道的地方。 创建新对象 [NSObject alloc]; 释放对象 [Object release]; 而这些 alloc、release 方法的调用，通常最终都会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，app 进程需要的内存会先请求到这里，但最终它也会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间上。 从苹果公开的 malloc 源码上来看，它的原理大致如下： malloc 内存分配基于malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型，申请时按需进行最适分配。 malloc 在首次调用时，初始化default zone。在 64 位环境下，会初始化default zone 为nano zone，同时初始化一个 scalable zone 作为helper zone。nano zone 负责nano 大小的分配，scalable zone 则负责tiny、small 和large 内存的分配。 每次 malloc 时，根据传入的size 参数，优先交给nano zone 做分配处理，如果大小不在nano 范围，则转交给helper zone 处理。 由于苹果 Open Source 的代码是针对 OS X 的特定版本，具体细节可能与 iOS 上有所不同，如地址空间分布。 二、nano malloc在支持 64 位的条件按下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是 16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn（OSX 上 64 位情况），将地址空间从大到小依次分为 Magazine、Band 和 Slot 几个级别。 Magazine 范围对应于CPU，CPU0 对应Mag0，CPU1 对应Mag1，依次类推 Band 范围为2M，连续内存分配当内存不够时以 Band 为单位向内核请求 Slot 则对应于每个Band 中128K 大小的范围，每个Band 都分为16 个Slot，分别对应于 16B、32B、…256B大小，支持它们的内存分配 分配过程： 确定当前 cpu 对应的mag 和通过size 参数计算出来的slot，去对应 metadata 的链表中取已经被释放过的内存区块缓存，如果取到，检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在nano zone 范围的地址空间上直接分配连续地址内存。 如当前 Band 中当前Slot 耗尽则向系统申请新的Band(每个 Band 固定大小2M，容纳了 16 个128k 的槽)，连续地址分配内存的基地址、limit 地址以及当前分配到的地址由meta data 结构维护起来，而这些 meta data 则以Mag、Slot 为维度(Mag 个数是处理器个数，Slot 是16 个)的二维数组形式，放在 nanozone_t 的meta_data 字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表的形式将这些区块按大小存储起来。这些链表的头部放在 meta data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时，都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放/多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 下图是个人理解(原文作者)梳理出来的一个关系图，图中标出了 nanozone_t、meta_data_t 等相关结构的关键字段画了出来(OSX)。 除了分配和释放，系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data 上挂着的空闲链表上内存区块回收来完成。 三、scalable zone 上内存分配简要分析对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone(下文简称 szone)上分配内存。由于 szone 上的内存分配比起 nano 分配要更为复杂，细节繁多，下面仅作简要介绍。 在 szone 上分配的内存包括 tiny、small 和 large 三大类，其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 tiny、small 的方式也依然遵循 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念极为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样，每个 cpu 有一个 magazine，除此之外还分配了一个 index 为 -1 的 magazine 作为后备之用。 下面是一个简图。 分配时(以 tiny 的情况为例)： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等(都是对齐之后的 slot 大小)，如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到free list 中另外的链表上。这里需要注意的是，在一般情况下free list 分为 64 个槽，0-62 上挂载区块的大小都是按16B 为单位递增，63 为所有更大的内存区块挂载的地方。 上面几项都不行，就在最后一个 region 的尾部或者首部(如果支持内部 ALSR)找空闲区域分配。 如果还是不行，说明所有现有 region 都没空间可用了，那么从一个后备magazine 中取出一个可用region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不成，那只能向内核申请一块新的 region 区域，挂载到当前的magazine 下并分配内存。 要是再不行就没招了，系统也给不到内存，就报错返回。 free 时： 检查指针指向地址是否有问题。 如果 last free 指针上没有挂载内存区块，则放到last free 上就OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到free list 上(在挂载的 free list 前，会先根据region 位图检查前后区块是否能合并成更大区块，如果能会合并成一个)。 合并后所在的 region 如果空闲字节超过一定条件，则将把此region 放到后备的magazine 中(-1)。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，szone 统一维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，只缓存总量 2G 的区块，分为 16 个元素，每个最大为 128M。","tags":[]},{"title":" 堆与栈\t\t","date":"2017-11-01T07:43:16.000Z","path":"2017/11/01/e5-a0-86-e4-b8-8e-e6-a0-88/","text":"一、程序的内存分配 一个由 C/C++ 编译的程序占用的内存分为以下几个部分： ①、栈区 stack 由编译器自动分配释放。存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 ②、堆区 heap 一般由程序员分配释放。若程序员不释放，程序结束时可能由 OS 回收。它与数据结构中的堆是两回事，分配方式类似于链表。 ③、全局区(静态区)static 程序结束后由系统释放。全局变量和静态变量的存储是放在一块的，初始化的全局变量、静态变量在一块区域，未初始化的全局变量、静态变量在相邻的另一块区域。 ④、文字常量区 程序结束后由系统释放。存放常量字符串。 ⑤、程序代码区 存放函数体的二进制代码。 二、例子程序 int a = 0; // 全局初始化区 char * p1; // 全局未初始化区 main() { int b; // 栈 char s[] = “abc”; // 栈 char p2; // 栈 char p3 = “123456”; // 123456/0 在常量区，p3 在栈上 static int c = 0; // 全局(静态)初始化区 p1 = (char )malloc(10); p2 = (char )malloc(20); // 分配得来的 10 和 20 字节的区域就在堆区 strcpy(p1, “123456”); // 123456/0 放在常量区，编译器可能会将它与 p3 所指向的 “123456” 优化成一个地方 } 三、堆与栈的理论知识 申请方式 栈：由系统自动分配 堆：需要程序员申请并指明大小 系统响应 栈：只要栈的剩余空间大于所申请的空间，编译器将为程序提供内存，否则将报异常提示栈溢出 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。释放工作由程序员控制，容易产生 memory Leak。 对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 申请大小 栈：在 Windows 下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是，栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是 2M(也有的说是 1M，总之是一个编译时就确定的常数)，如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 申请效率 栈：由系统自动分配，速度较快，但程序员是无法控制的。 堆：是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。 ps：在 windows下，最好的方式是用 VirtualAlloc 分配内存，即不是在堆，也不是在栈，是直接在进程的地址空间中保留一块内存，虽然用起来最不方便，但是速度快，也最灵活。 存储内容 栈：在函数调用时，第一个进栈的是主函数中的下一条指令(函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数。在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 存取效率 char s1[] = “aaaaaaaaaaaaaaa”; // 运行时赋值 char *s2 = “bbbbbbbbbbbbbbb”; // 编译时确定 在以后的存取中，在栈上的数组比指针所指向的字符串(例如：堆)快。 #include void main() { char a = 1; char c[] = “1234567890”; char *p = “1234567890”; a = c\\[1\\]; a = p\\[1\\]; return; } 对应的汇编代码 a = c[1];00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]0040106A 88 4D FC mov byte ptr [ebp-4],cl a = p[1];0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]00401070 8A 42 01 mov al,byte ptr [edx+1]00401073 88 45 FC mov byte ptr [ebp-4],al 第一种在读取时直接就把字符串中的元素读到寄存器 cl 中，而第二种则要先把指针值读到 edx 中，再根据 edx 读取字符，显然慢了。 栈：是机器系统提供的数据结构，计算机会在底层堆栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，效率比较高。 堆：是 C/C++ 函数库提供的，它的机制是很复杂的。 碎片问题 栈：先进后出的队列，是如此的一一对应，以至于永远都不可能有一个内存块从栈中弹出。 堆：频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。 分配方式 栈：有静态分配和动态分配。静态分配是编译器完成的(如：局部变量的分配)。动态分配是由 alloc 函数进行分配的，但是栈的动态分配和堆是不同的，它的动态分配由编译器进行释放，无需我们手工实现。 堆：动态分配的，没有静态分配。 四、小结(堆和栈的区别) 使用栈：就像我们去饭馆里吃饭，只管点菜(发出申请)、付钱和吃(使用)，吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，它的好处是快捷但自由度小。 使用堆：就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。","tags":[]},{"title":" Push & Pop\t\t","date":"2017-11-01T07:16:32.000Z","path":"2017/11/01/push-pop/","text":"iOS 中的 push 和 pop 是一个很常用的视图切换方法。简而言之，push 就是压栈，pop 就是出栈！ 一、push [self.navigationController pushViewController:VC animated:YES]; 苹果为实现这一句话具体做了： // navigationController 把 vc 添加作为自己的子视图控制器 [self addChildViewController:vc]; // 设置 vc 的根 view 的 frame vc.view.frame = [self fram2eForContentController]; // 把 vc.view 添加到 navigationcontroller.view 上 [self.view addSubview:vc.view]; // 通知已经 push 完毕 [vc didMoveToParentViewController:self]; 二、pop [self.navigationController popViewControllerAnimated:YES]; 苹果为实现这一句话具体做了： // 通知 vc 即将被移除父视图控制器 [vc willMoveToParentViewController:nil]; // 把 vc.view 移除出父视图控制器的 view [vc.view removeFromSuperview]; // 把 vc 彻底移除 [vc removeFromParentViewController];","tags":[]},{"title":" objc_msgSend\t\t","date":"2017-11-01T07:01:48.000Z","path":"2017/11/01/objc-msgsend/","text":"1、为了性能，objc_msgSend 用汇编写成。存在于 objc-msg-x86_64.s 中。 2、在上图代码中可以看到，objc_msgSend 被分为两个过程： ①、在 CacheLookup 中，不断地拿 SEL 与 cache 中的缓存比较 ②、第一步比较失败，则跳转到 LCacheMiss 标签继续在 MethodTable 中寻找 SEL 如果想手动查找 cache，则需要调用 _cache_getimp 函数（汇编实现），此函数是个对外接口层，用于保存与准备环境。 _cache_getImp 在头文件中 objc-private.h 中，链接后 objc/c 代码可以直接调用。 3、MethodTableLookup 是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3 函数(此函数实现于 objc-class.mm)。 4、__class_lookupMethodAndLoadCache3 函数也是个接口层(C编写)，此函数提供相应参数配置，实际功能在 lookUpMethod 函数中。 5、lookUpMethod 函数实现遍历 method_list_t，从子类开始，一直遍历到根类。此函数代码较大。文件在 objc-class 中。 [Cache Of lookUpMethod] To speed the messaging process, the runtime system caches the selectors and addresses of methods as they are used. There’s a separate cache for each class, and it can **contain selectors for inherited methods as well as for methods defined in the class**. Before searching the dispatch tables, the messaging routine first checks the cache of the receiving object’s class (on the theory that a method that was used once may likely be used again). If the method selector is in the cache, messaging is only slightly slower than a function call. Once a program has been running long enough to “warm up” its caches, almost all the messages it sends find a cached method. Caches grow dynamically to accommodate new messages as the program runs. 文章：深入解构 objc_msgSend 函数的实现 一、objc_class（Class对象）结构简介熟悉 OC 语言的 Runtime（运行时）机制以及对象方法调用机制的开发者都知道，所有 OC 方法调用在编译时都会转化为对 C 函数objc_msgSend 的调用。 /* 下面的例子是在 arm64 体系下的函数调用实现，本文中如果没有特殊说明都是指在 arm64 体系下的结论 */objc_msgSend(view1, “addSubview:”, view2); // [view1 addSubview:view2]; CGSize size = objc_msgSend(view1, “sizeThatFits:”, CGSizeZero); // CGSize size = [view1 sizeThatFits:CGSizeZero]; CGFloat alpha = objc_msgSend(view1, “alpha”); // CGFloat alpha = view1.alpha; 系统的 Runtime 库通过函数 objc_msgSend 以及 OC 对象中隐藏的 isa 数据成员来实现多态和运行时方法查找以及执行。每个对象的 isa 中保存着这个对象的类对象指针，类对象是一个 Class 类型的数据，而 Class 则是一个 objc_class 结构体指针类型的别名。定义： typedef struct objc_class * Class; 虽然在对外公开暴露的头文件 #import &lt;objc/runtime.h&gt; 中可以看到关于 struct objc_class 的定义，但可惜的是那只是 objc1.0 版本的定义，而目前所运行的 objc2.0 版本运行时库并没有暴露出 struct objc_class 所定义的详细内容。 下载和查看开源的最新版本的 Runtime 库源代码。 Runtime 库的源代码是用汇编和 C++ 混合实现的，你可以在头文件 objc-runtime-new.h中看到关于 struct objc_class 结构的详细定义。objc_class 结构体用来描述一个 OC 类的类信息：包括类的名字、所继承的基类、类中定义的方法列表描述、属性列表描述、实现的协议描述、定义的成员变量描述等等信息。在 OC 中类信息也是一个对象，所以又称类信息为 Class 对象。 下面是一张 objc_class 结构体定义的静态类图： objc_class 结构体中的数据成员非常的多也非常的复杂，这里并不打算深入的去介绍它，本文主要介绍的是 objc_msgSend 函数内部的实现，因此在下面的代码中将会隐藏大部分数据成员的定义，并在不改变真实结构体定义的基础上只列出 objc_msgSend 方法内部会访问和使用到的数据成员。 二、objc_msgSend 函数的内部实现objc_msgSend 函数是所有 OC 方法调用的核心引擎，它负责查找真实的类或者对象方法的实现，并去执行这些方法函数。因调用频率是如此之高，所以要求其内部实现近可能达到最高的性能。这个函数的内部代码实现是用汇编语言来编写的，并且其中并没有涉及任何需要线程同步和锁相关的代码。你可以在上面说到的官方开源链接中的 Messengers文件夹下查看各种体系架构下的汇编语言的实现。 ;这里列出的是在arm64位真机模式下的汇编代码实现。 0x18378c420 &lt;+0&gt;: cmp x0, #0x0 ; =0x0 0x18378c424 &lt;+4&gt;: b.le 0x18378c48c ; &lt;+108&gt; 0x18378c428 &lt;+8&gt;: ldr x13, \\[x0\\] 0x18378c42c &lt;+12&gt;: and x16, x13, #0xffffffff8 0x18378c430 &lt;+16&gt;: ldp x10, x11, \\[x16, #0x10\\] 0x18378c434 &lt;+20&gt;: and w12, w1, w11 0x18378c438 &lt;+24&gt;: add x12, x10, x12, lsl #4 0x18378c43c &lt;+28&gt;: ldp x9, x17, \\[x12\\] 0x18378c440 &lt;+32&gt;: cmp x9, x1 0x18378c444 &lt;+36&gt;: b.ne 0x18378c44c ; &lt;+44&gt; 0x18378c448 &lt;+40&gt;: br x17 0x18378c44c &lt;+44&gt;: cbz x9, 0x18378c720 ; \\_objc\\_msgSend_uncached 0x18378c450 &lt;+48&gt;: cmp x12, x10 0x18378c454 &lt;+52&gt;: b.eq 0x18378c460 ; &lt;+64&gt; 0x18378c458 &lt;+56&gt;: ldp x9, x17, \\[x12, #-0x10\\]! 0x18378c45c &lt;+60&gt;: b 0x18378c440 ; &lt;+32&gt; 0x18378c460 &lt;+64&gt;: add x12, x12, w11, uxtw #4 0x18378c464 &lt;+68&gt;: ldp x9, x17, \\[x12\\] 0x18378c468 &lt;+72&gt;: cmp x9, x1 0x18378c46c &lt;+76&gt;: b.ne 0x18378c474 ; &lt;+84&gt; 0x18378c470 &lt;+80&gt;: br x17 0x18378c474 &lt;+84&gt;: cbz x9, 0x18378c720 ; \\_objc\\_msgSend_uncached 0x18378c478 &lt;+88&gt;: cmp x12, x10 0x18378c47c &lt;+92&gt;: b.eq 0x18378c488 ; &lt;+104&gt; 0x18378c480 &lt;+96&gt;: ldp x9, x17, \\[x12, #-0x10\\]! 0x18378c484 &lt;+100&gt;: b 0x18378c468 ; &lt;+72&gt; 0x18378c488 &lt;+104&gt;: b 0x18378c720 ; \\_objc\\_msgSend_uncached 0x18378c48c &lt;+108&gt;: b.eq 0x18378c4c4 ; &lt;+164&gt; 0x18378c490 &lt;+112&gt;: mov x10, #-0x1000000000000000 0x18378c494 &lt;+116&gt;: cmp x0, x10 0x18378c498 &lt;+120&gt;: b.hs 0x18378c4b0 ; &lt;+144&gt; 0x18378c49c &lt;+124&gt;: adrp x10, 202775 0x18378c4a0 &lt;+128&gt;: add x10, x10, #0x220 ; =0x220 0x18378c4a4 &lt;+132&gt;: lsr x11, x0, #60 0x18378c4a8 &lt;+136&gt;: ldr x16, \\[x10, x11, lsl #3\\] 0x18378c4ac &lt;+140&gt;: b 0x18378c430 ; &lt;+16&gt; 0x18378c4b0 &lt;+144&gt;: adrp x10, 202775 0x18378c4b4 &lt;+148&gt;: add x10, x10, #0x2a0 ; =0x2a0 0x18378c4b8 &lt;+152&gt;: ubfx x11, x0, #52, #8 0x18378c4bc &lt;+156&gt;: ldr x16, \\[x10, x11, lsl #3\\] 0x18378c4c0 &lt;+160&gt;: b 0x18378c430 ; &lt;+16&gt; 0x18378c4c4 &lt;+164&gt;: mov x1, #0x0 0x18378c4c8 &lt;+168&gt;: movi d0, #0000000000000000 0x18378c4cc &lt;+172&gt;: movi d1, #0000000000000000 0x18378c4d0 &lt;+176&gt;: movi d2, #0000000000000000 0x18378c4d4 &lt;+180&gt;: movi d3, #0000000000000000 0x18378c4d8 &lt;+184&gt;: ret 0x18378c4dc &lt;+188&gt;: nop 毕竟汇编语言代码比较晦涩难懂，因此这里将函数的实现反汇编成 C 语言的伪代码： // 下面的结构体中只列出 objc_msgSend 函数内部访问用到的那些数据结构和成员。 /** * 其实 SEL 类型就是一个字符串指针类型，所描述的就是方法字符串指针 /typedef char SEL; /** * IMP 类型就是所有 OC 方法的函数原型类型。 /typedef id (IMP)(id self, SEL _cmd, …); /** * 方法名和方法实现桶结构体 */struct bucket_t { SEL key; // 方法名称 IMP imp; // 方法的实现，imp 是一个函数指针类型}; /** * 用于加快方法执行的缓存结构体。这个结构体其实就是一个基于开地址冲突解决法的哈希桶。 /struct cache_t { struct bucket_t buckets; // 缓存方法的哈希桶数组指针，桶的数量 = mask + 1 int mask; // 桶的数量 - 1 int occupied; // 桶中已经缓存的方法数量。}; /** * OC 对象的类结构体描述表示，所有 OC 对象的第一个参数保存是的一个 isa 指针。 /struct objc_object { void isa;}; /** * OC 类信息结构体，这里只展示出了必要的数据成员。 /struct objc_class : objc_object { struct objc_class superclass; // 基类信息结构体。 cache_t cache; // 方法缓存哈希表 //… 其他数据成员忽略。}; /** * objc_msgSend 的 C 语言版本伪代码实现。 * receiver: 是调用方法的对象 * op : 是要调用的方法名称字符串 */id objc_msgSend(id receiver, SEL op, …){ // ①............................ 对象空值判断。如果传入的对象是 nil 则直接返回 nil if (receiver == nil) return nil; // ②............................ 获取或者构造对象的 isa 数据。 void *isa = NULL; // 如果对象的地址最高位为 0 则表明是普通的 OC 对象，否则就是 Tagged Pointer 类型的对象 if ((receiver &amp; 0x8000000000000000) == 0) { struct objc\\_object \\*ocobj = (struct objc\\_object\\*) receiver; isa = ocobj-&gt;isa; } // Tagged Pointer 类型的对象中没有直接保存 isa 数据，所以需要特殊处理来查找对应的 isa 数据 else { // 如果对象地址的最高 4 位为 0xF, 那么表示是一个用户自定义扩展的 Tagged Pointer 类型对象 if (((NSUInteger) receiver) &gt;= 0xf000000000000000) { // 自定义扩展的 Tagged Pointer 类型对象中的 52-59 位保存的是一个全局扩展 Tagged Pointer 类数组的索引值。 int classidx = (receiver &amp; 0xFF0000000000000) &gt;&gt; 52 isa = objc\\_debug\\_taggedpointer\\_ext\\_classes\\[classidx\\]; } else { // 系统自带的 Tagged Pointer 类型对象中的 60-63 位保存的是一个全局 Tagged Pointer 类数组的索引值。 int classidx = ((NSUInteger) receiver) &gt;&gt; 60; isa = objc\\_debug\\_taggedpointer_classes\\[classidx\\]; } } // 因为内存地址对齐的原因和虚拟内存空间的约束原因，以及 isa 定义的原因需要将 isa 与上 0xffffffff8 才能得到对象所属的 Class 对象 struct objc\\_class \\*cls = (struct objc\\_class \\*)(isa &amp; 0xffffffff8); // ③............................ 遍历缓存哈希桶并查找缓存中的方法实现。 IMP imp = NULL; // cmd 与 cache 中的 mask 进行与计算得到哈希桶中的索引，来查找方法是否已经放入缓存 cache 哈希桶中。 int index = cls-&gt;cache.mask &amp; op; while (true) { // 如果缓存哈希桶中命中了对应的方法实现，则保存到 imp 中并退出循环。 if (cls-&gt;cache.buckets\\[index\\].key == op) { imp = cls-&gt;cache.buckets\\[index\\].imp; break; } // 方法实现并没有被缓存，并且对应的桶的数据是空的就退出循环 if (cls-&gt;cache.buckets\\[index\\].key == NULL) { break; } // 如果哈希桶中对应的项已经被占用但是又不是要执行的方法，则通过开地址法来继续寻找缓存该方法的桶。 if (index == 0) { index = cls-&gt;cache.mask; // 从尾部寻找 } else { index--; // 索引 -1 继续寻找。 } } /\\*end while\\*/ // ④............................ 执行方法实现或方法未命中缓存处理函数 if (imp != NULL) return imp(receiver, op, ...); // 这里的... 是指传递给 objc_msgSend 的 OC 方法中的参数。 else return objc\\_msgSend\\_uncached(receiver, op, cls, ...); } /** * 方法未命中缓存处理函数：objc_msgSend_uncached的C语言版本伪代码实现，这个函数也是用汇编语言编写。 /id objc_msgSend_uncached(id receiver, SEL op, struct objc_class cls){ //这个函数直接调用了 _class_lookupMethodAndLoadCache3 来查找方法并缓存到struct objc_class中的cache中，最后再返回 IMP 类型 IMP imp = _class_lookupMethodAndLoadCache3(receiver, op, cls); return imp(receiver, op, ....); } 可以看出 objc_msgSend 函数的实现逻辑主要分为 4 个部分： 1、对象空值判断 首先对传进来的方法接收者 receiver 进行是否为空判断，如果是 nil 则函数直接返回，这也就说明了当对一个 nil 对象调用方法时不会产生崩溃，也不会进入到对应的方法实现中去，整个过程其实什么也不会发生而是直接返回 nil。 2、获取或者构造对象的 isa 数据 通常情况下每个 OC 对象的最开始处都有一个隐藏的数据成员 isa，isa 保存有类的描述信息，所以在执行方法前就需要从对象处获取到这个指针值。为了减少内存资源的浪费，苹果提出了 Tagged Pointer 类型对象的概念。比如一些 NSString 和 NSNumber 类型的实例对象就会被定义为 Tagged Pointer 类型的对象。 Tagged Pointer 类型的对象采用一个跟机器字长一样长度的整数来表示一个 OC 对象，而为了跟普通 OC 对象区分开来，每个 Tagged Pointer 类型对象的最高位为 1 而普通的 OC 对象的最高位为 0。因此上面的代码中如果对象 receiver 地址的最高位为 1 则会将对象当做 Tagged Pointer 对象来处理。从代码实现中还可以看出系统中存在两种类型的 Tagged Pointer 对象：如果是高四位全为 1 则是用户自定义扩展的 Tagged Pointer 对象，否则就是系统内置的 Tagged Pointer 对象。因为 Tagged Pointer 对象中是不可能保存一个 isa 的信息的，而是用 Tagged Pointer 类型的对象中的某些 bit 位来保存所属的类信息的索引值。系统分别定义了两个全局数组变量： extern “C” { extern Class objc_debug_taggedpointer_classes[16*2]; extern Class objc_debug_taggedpointer_ext_classes[256];} 来保存所有的 Tagged Pointer 类型的类信息。对于内置 Tagged Pointer 类型的对象来说，其中的高四位保存的是一个索引值，通过这个索引值可以在 objc_debug_taggedpointer_classes 数组中查找到对象所属的 Class 对象；对于自定义扩展 Tagged Pointer 类型的对象来说，其中的高 52~59 位这 8 位 bit 保存的是一个索引值，通过这个索引值可以在 objc_debug_taggedpointer_ext_classes 数组中查找到对象所属的 Class 对象。 思考和实践：Tagged Pointer 类型的对象中获取 isa 数据的方式采用的是享元设计模式，这种设计模式在一定程度上还可以缩小一个对象占用的内存尺寸。还有比如 256 色的位图中每个像素位置中保存的是颜色索引值而非颜色的 RGB 值，从而减少了低色彩位图的文件存储空间。保存一个对象引用可能需要占用 8 个字节，而保存一个索引值时可能只需要占用 1 个字节。 在第二步中不管是普通的 OC 对象还是 Tagged Pointer 类型的对象都需要找到对象所属的 isa 信息，并进一步找到所属的类对象，只有找到了类对象才能查找到对应的方法的实现。 · isa 的内部结构 上面的代码实现中，在将 isa 转化为 struct objc_class 时发现还进行一次和 0xffffffff8 的与操作。 虽然 isa 是一个长度为 8 字节的指针值，但是它保存的值并不一定是一个 struct objc_class 对象的指针。在 arm64 位体系架构下的用户进程最大可访问的虚拟内存地址范围是 0x0000000000 - 0x1000000000，也就是每个用户进程的可用虚拟内存空间是 64GB。同时因为一个指针类型的变量存在着内存地址对齐的因素所以指针变量的最低 3 位一定是 0。所以将 isa 中保存的内容和 0xffffffff8 进行与操作得到的值才是真正的对象的 Class 对象指针。 arm64 体系架构对 isa 中的内容进行了优化设计，它除了保存着 Class 对象的指针外，还保存着诸如 OC 对象自身的引用计数值，对象是否被弱引用标志，对象是否建立了关联对象标志，对象是否正在销毁中等等信息。如果要想更加详细的了解 isa 的内部结构请参考文章：isa 详解。 思考和实践：对于所有指针类型的数据，我们也可以利用其中的特性来使用 0-2 以及 36-63 这两个区段的 bit 位进行一些特定数据的存储和设置，从而减少一些内存的浪费和开销。 3、遍历缓存哈希桶并查找缓存中的方法实现 一个 Class 对象的数据成员中有一个方法列表数组保存着这个类的所有方法的描述和实现的函数地址入口。 如果每次方法调用时都要进行一次这样的查找，而且当调用基类方法时，还需要遍历基类进行方法查找，这样势必会对性能造成非常大的损耗。为了解决这个问题系统为每个类建立了一个哈希表进行方法缓存（objc_class 中的数据成员 cache 是一个 cache_t 类型的对象）。这个哈希表缓存由哈希桶来实现，每次当执行一个方法调用时，总是优先从这个缓存中进行方法查找，如果找到则执行缓存中保存的方法函数，如果不在缓存中才到 Class 对象中的方法列表数组或者基类的方法列表数组中去查找，当找到后将方法名和方法函数地址保存到缓存中以便下次加速执行。所以 objc_msgSend 函数第 3 部分的内容主要实现的就是在 Class 对象的缓存哈希表中进行对应方法的查找： ①、函数首先将方法名 op 与 cache 中的 mask 进行与操作。这个 mask 的值是缓存中桶的数量 -1，一个类初始缓存中的桶的数量是 4，每次桶数量扩容时都乘 2。也就是说 mask 的值的二进制的所有 bit 位数全都是 1，这样当 op 和 mask 进行与操作时也就是取 op 中的低 mask 位数来命中哈希桶中的元素。因此这个哈希算法所得到的 index 索引值一定是小于缓存中桶的数量而不会出现越界的情况。 ②、当通过哈希算法得到对应的索引值后，接下来便判断对应的桶中的 key 值是否和 op 相等。每个桶是一个 struct bucket_t 结构，里面保存着方法的名称（key）和方法的实现地址（imp）。一旦 key 值和 op 值相等则表明缓存命中，然后将其中的 imp 值进行保存并结束查找跳出循环；而一旦 key 值为 NULL 时则表明此方法尚未被缓存，需要跳出循环进行方法未命中缓存处理；而当 key 为非 NULL 但是又不等于 op 时则表明出现冲突了，这里解决冲突的机制是采用开地址法将索引值 -1 来继续循环来查找缓存。 当你读完第 3 部分代码时是否会产生如下几个问题的思考： a. 缓存中哈希桶的数量会随着方法访问的数量增加而动态增加，那么它又是如何增加的？ b. 缓存循环查找是否会出现死循环的情况？ c. 当桶数量增加后 mask 的值也会跟着变化，那么就会存在着前后两次计算 index 的值不一致的情况，这又如何解决? d. 既然哈希桶的数量会在运行时动态添加，那么在多线程访问环境下又是如何做同步和安全处理的？ 这四个问题都会在第 4 步中的 objc_msgSend_uncached 函数内部实现中找到答案。 4、执行方法实现或方法未命中缓存处理函数 当方法在哈希桶中被命中并且存在对应的方法函数实现时就会调用对应的方法实现并且函数返回，整个函数执行完成。 而当方法没有被缓存时则会调用 objc_msgSend_uncached 函数，这个函数的实现也是用汇编语言编写的，它的函数内部做了两件事情：一是调用 _class_lookupMethodAndLoadCache3 函数在 Class 对象中查找方法的实现体函数并返回；二是调用返回的实现体函数来执行对应的方法。可以从 _class_lookupMethodAndLoadCache3 函数名中看出它的功能实现就是先查找后缓存，而这个函数则是用 C 语言实现的，因此可以很清晰的去阅读它的源代码实现。 _class_lookupMethodAndLoadCache3 函数的源代码实现主要就是先从 Class 对象的方法列表或者基类的方法列表中查找对应的方法和实现，并且更新到 Class 对象的缓存 cache 中。如果你仔细阅读里面的源代码就可以很容易回答在第 3 步所提出的四个问题： a. 缓存中哈希桶的数量会随着方法访问的数量增加而动态增加，那么它又是如何增加的？ 每个 Class 类对象初始化时会为缓存分配 4 个桶，并且 cache 中有一个数据成员 occupied 来保存缓存中已经使用的桶的数量，这样每当将一个方法的缓存信息保存到桶中时 occupied 的数量 +1，如果数量到达桶容量的 3/4 时，系统就会将桶的容量增大 2 倍，并按照这个规则依次继续扩展下去。 b. 缓存循环查找是否会出现死循环的情况？ 不会，因为系统总是会将空桶的数量保证有 1/4 的空闲，因此当循环遍历时一定会出现命中缓存或者会出现 key == NULL 的情况而退出循环。 c. 当桶数量增加后 mask 的值也会跟着变化，那么就会存在着前后两次计算 index 的值不一致的情况，这又如何解决? 每次哈希桶的数量扩容后，系统会为缓存分配一批新的空桶，并且不会维护原来老的缓存中的桶的信息。这样就相当于当对桶数量扩充后每个方法都是需要进行重新缓存，所有缓存的信息都清 0 并重新开始。因此不会出现两次 index 计算不一致的问题。 d. 既然哈希桶的数量会在运行时动态添加那么在多线程访问环境下又是如何做同步和安全处理的？ 在整个 objc_msgSend 函数中对方法缓存的读取操作并没有增加任何的锁和同步信息，这样目的是为了达到最佳的性能。在多线程环境下为了保证对数据的安全和同步访问，需要在写写和读写两种场景下进行安全和同步处理： 首先来考察多线程同时写 cache 缓存的处理方法。假如两个线程都检测到方法并未在缓存中而需要扩充缓存或者写桶数据时，在扩充缓存和写桶数据之前使用了一个全局的互斥锁来保证写入的同步处理，而且在锁住的范围内部还做了一次查缓存的处理，这样即使在两个线程调用相同的方法时也不会出现写两次缓存的情况。因此多线程同时写入的解决方法只需要简单的引入一个互斥锁即可解决问题。 再来考察多线程同时读写 cache 缓存的处理方法。上面有提到当对缓存中的哈希桶进行扩充时，系统采用的解决方法是完全丢弃掉老缓存的内存数据，而重新开辟一块新的哈希桶内存并更新 Class 对象 cache 中的所有数据成员。因此如果处理不当就会在 objc_msgSend 函数的第 3 步中访问 cache 中的数据成员时发生异常。为了解决这个问题在 objc_msgSend 函数的第四条指令中采用了一种非常巧妙的方法： 0x18378c430 &lt;+16&gt;: ldp x10, x11, [x16, #0x10] 这条指令中会把 cache 中的哈希桶 buckets 和 mask|occupied 整个结构体数据成员分别读取到 x10 和 x11 两个寄存器中去。因为 CPU 能保证单条指令执行的原子性，而且在整个后续的汇编代码中函数并没有再次去读取 cache 中的 buckets 和 mask 数据成员，而是一直使用 x10 和 x11 两个寄存器中的值来进行哈希表的查找。所以即使其他写线程扩充了 cache 中的哈希桶的数量和重新分配了内存也不会影响当前读线程的数据访问。在写入线程扩充哈希桶数量时会更新 cache 中的buckets 和 mask 两个数据成员的值。这部分的实现代码如下： /** * 设置更新缓存的哈希桶内存和 mask 值。 / void cache_t::setBucketsAndMask(struct bucket_t newBuckets, mask_t newMask){ // objc_msgSend uses mask and buckets with no locks. // It is safe for objc_msgSend to see new buckets but old mask. // (It will get a cache miss but not overrun the buckets’ bounds). // It is unsafe for objc_msgSend to see old buckets and new mask. // Therefore we write new buckets, wait a lot, then write new mask. // objc_msgSend reads mask first, then buckets. // ensure other threads see buckets contents before buckets pointer mega_barrier(); buckets = newBuckets; // ensure other threads see new buckets before new mask mega_barrier(); mask = newMask; occupied = 0; } 这段代码是用 C++ 编写实现的。 代码中先修改哈希桶数据成员 buckets 再修改 mask 中的值。为了保证赋值的顺序不被编译器优化这里添加了 mega_baerrier() 来实现编译内存屏障（Compiler Memory Barrier）。 假如不添加编译内存屏障的话，编译器有可能会优化代码让 mask 先赋值而 buckets 后赋值，这样会造成什么后果呢？当写线程先执行完 mask 赋值并在执行 buckets 赋值前读线程执行 ldp x10, x11, [x16, #0x10] 指令时就有可能读取到新的 mask 值和旧的 buckets 值，而新的 mask 值要比旧的 mask 值大，这样就会出现内存数组越界的情况而产生崩溃。 而如果添加了编译内存屏障，就会保证先执行 buckets 赋值而后执行 mask 赋值，这样即使在写线程执行完 buckets 赋值后而在执行 mask 赋值前，读线程执行 ldp x10, x11, [x16, #0x10] 时得到新的 buckets 值和旧的 mask 值是也不会出现异常。 可见可以在一定的程度上借助编译内存屏障相关的技巧来实现无锁读写同步技术。当然假如这段代码不用高级语言而用汇编语言来编写则可以不用编译内存屏障技术而是用 stp 指令来写入新的 buckets 和 mask 值也能保证顺序的写入。 思考和实践：如果你想了解编译屏障相关的知识请参考文章：理解 Memory barrier（内存屏障） 对于多线程读写的情况还有一个问题需要解决，就是因为写线程对缓存进行了扩充而分配了新的哈希桶内存，同时会销毁老的哈希桶内存，而此时如果读线程中正在访问的是老缓存时，就有可能会因为处理不当时会发生读内存异常而系统崩溃。为了解决这个问题，系统将所有会访问到 Class 对象中的 cache 数据的 6 个 API 函数的开始地址和结束地址保存到了两个全局的数组中： uintptr_t objc_entryPoints[] = {cache_getImp, objc_msgSend, objc_msgSendSuper, objc_msgSendSuper2, objc_msgLookup, objc_msgLookupSuper2}; // LExit开头的表示的是函数的结束地址。 uintptr_t objc_exitPoints[] = {LExit_cache_getImp,LExit_objc_msgSend, LExit_objc_msgSendSuper, LExit_objc_msgSendSuper2, LExit_objc_msgLookup,LExit_objc_msgLookupSuper2}; 当某个写线程对 Class 对象 cache 中的哈希桶进行扩充时，会先将已经分配的老的需要销毁的哈希桶内存块地址，保存到一个全局的垃圾回收数组变量 garbage_refs 中，然后再遍历当前进程中的所有线程，并查看线程状态中的当前 PC 寄存器中的值是否在 objc_entryPoints 和 objc_exitPoints 这个范围内。也就是说查看是否有线程正在执行 objc_entryPoints 列表中的函数，如果没有则表明此时没有任何函数会访问 Class 对象中的 cache 数据，这时候就可以放心的将全局垃圾回收数组变量 garbage_refs 中的所有待销毁的哈希桶内存块执行真正的销毁操作；而如果有任何一个线程正在执行 objc_entryPoints 列表中的函数则不做处理，而等待下次再检查并在适当的时候进行销毁。这样也就保证了读线程在访问 Class 对象中的 cache 中的 buckets 时不会产生内存访问异常。 思考和实践：上面描述的技术解决方案其实就是一种垃圾回收技术的实现。垃圾回收时不立即将内存进行释放，而是暂时将内存放到某处进行统一管理，当满足特定条件时才将所有分配的内存进行统一销毁释放处理。 objc2.0 的 runtime 巧妙的利用了 ldp 指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程数据读写的无锁处理方案，提升了系统的性能。","tags":[]},{"title":" SVN 本地客户端\t\t","date":"2017-10-31T11:39:48.000Z","path":"2017/10/31/svn-e6-9c-ac-e5-9c-b0-e5-ae-a2-e6-88-b7-e7-ab-af/","text":"一、终端命令 /** @brief 从本地导入代码到服务器(初始化导入)。将 ~/…/MyCode 中的所有内容上传到 svn 服务器 iOS 仓库的Code 目录下 @param localhost 使用相对路径 @param -m 表示注释代码作用 */ $ svn import ~/…/MyCode svn://localhost/iOS/Code –username=dbb –password=123 -m “初始化导入” /** @brief 从服务器端下载代码到客户端本地。将 svn 服务器iOS 仓库的内容下载到~/…/LocalCode 目录中 */ $ svn checkout svn://localhost/iOS –username=dbb –password=123 ~/…/LocalCode /** @brief 提交更改过的代码到服务器。将 ~/…/LocalCode 下的所有修改都同步到服务器端。 假如此次只修改了 main.m 文件，可以看到终端的打印信息：Sending Code/Code/main.mTransmitting file data.Committed revision */ $ cd ~/…/LocalCode // 定位到 ~/…/LocalCode 目录 $ svn commit -m “修改了 main.m 文件” // 输入提交命令 /** @brief 更新服务器端的代码到客户端 */ $ cd ~/…/LocalCode $ svn update $ svn help // 查看其他用法 二、第三方客户端使用 例：SmartSVN。在客户端的地址栏中输入 svn://192.168.0.107/SVN/iOS 三、svn 服务器地址变换 $ cd 项目位置 // 进入项目所在的文件夹 $ svn info // 查看 svn 信息 // 输出结果 Path: . Working Copy Root Path: /Users/jpm/Documents/workspaces/ios/MyProject/BSChartNet URL: https://XXXX@10.25.69.13/svn/XXXX Repository Root: https://XXXX@10.25.69.13/svn/XXX Repository UUID: 485b2045-778f-e54e-8a78-595323a4869c Revision: 5562 Node Kind: directory Schedule: normal Last Changed Author: dbb Last Changed Rev: 4837 Last Changed Date: 2013-09-17 11:27:25 +0800 (二, 17 9 2013) // 复制红色部分，执行替换命令 svn switch – relocate https://XXXX@10.25.69.13/svn/XXX https://XXXX@10.25.69.14/svn/XXX 第一次修改需要数据 svn 密码和机器密码，输入就 ok 了。","tags":[]},{"title":" SVN 本地服务器\t\t","date":"2017-10-31T11:16:43.000Z","path":"2017/10/31/svn-e6-9c-ac-e5-9c-b0-e6-9c-8d-e5-8a-a1-e5-99-a8/","text":"一、基础知识 ①、Mac 自带了 svn 的服务器端和客户端功能，所以可以不安装任何第三方软件而使用 svn 功能，不过需要配置一下; ②、svn 上的文件不是以原来的格式存储，而是以 FSFS(the Fast Secure File System) 格式压缩存储; svn 存储格式：FSFS、Berkeley DB 如果是 FSFS 格式，这些数据存放在版本库的 db 目录中，里面的 revs 和 revprops 分别存放着每次提交的差异数据和日志等信息; ③、Mac 自带的 svn 默认使用 3690 端口; ④、上传的文件是以加密形式存在的，所以不可见，只是一堆无序的文件。 二、终端命令 $ svnserve –version // 查看系统自带 svn 版本等信息 // 显示信息 svnserve, version 1.7.19(r1643991) compiled Jun 17 2015, 13:48:11 Copyright (C) 2014 The Apache Software Foundation. … fs_fs:Module for working with a plain file(FSFS) repository. // 创建 svn 路径path。可以使用命令或直接在 Finder 中创建想要存放svn 的路径 $ mkdir /Users/电脑名(如：dbb)/…/SVN // 创建 svn 仓库repository $ svnadmin create /Users/电脑名(如：dbb)/…/SVN/仓库名(如：iOS) 三、配置 svn 的用户权限 打开 iOS/conf 目录下的 svnserve.conf 文件(可以使用文本编辑器打开)，找到下列配置项并将前面的 # 和空格都去掉： anon-access = read auth-access = write password-db = passwd authz-db = authz 再把 anon-access = read 修改为 anon-access = none，这样就禁止了匿名访问，只有输入账号密码才可以访问。 四、配置 svn 账号密码 打开 iOS/conf 目录下的 passwd 文件，仿照里面的注释格式，修改如下： [users] dbb = 123 // 账号 = 密码 zyj = 456 五、配置 svn 用户组和权限 打开 iOS/conf 目录下的 authz 文件，我们可以对上面分配的 svn 账号进行分组管理，可以针对不同的分组和不同的账号进行不同的权限管理。 仿照里面的注释格式，在 [groups] 下面添加组名和用户名，多个用户之间用逗号隔开，修改如下： [groups] groupname = dbb,zyj // 组名 = 用户名1,用户名2 [/foo/bar] // 指定资源 @groupname = r // 对于此资源，groupname 组的所有用户具有只读权限 [/] // svn 服务器中的所有资源库 dbb = rw // 对于此资源，用户 dbb 具有读写权限 六、启动 svn 服务器 终端输入以下指令：svnserve -d -r /Users/电脑名(如：dbb)/…/SVN 没有任何提示就说明了启动成功 七、关闭 svn 服务器 在活动监视器中关闭 svnserve 进程。 八、问题 svn authorization failed // 一般都是 authz 文件中用户组或者用户权限没有配置好","tags":[]},{"title":" 十一、GLEW扩展库\t\t","date":"2017-10-31T06:09:47.000Z","path":"2017/10/31/e5-8d-81-e4-b8-80-e3-80-81glew-e6-89-a9-e5-b1-95-e5-ba-93/","text":"原文：http://www.cnblogs.com/mazhenyu/p/6477663.html 一、关于 GLEW 是一个跨平台的 C++ 扩展库，基于 OpenGL 图形接口。 使用 OpenGL 的朋友都知道，window 目前只支持 OpenGL1.1 的涵数，但 OpenGL 现在都发展到 2.0 以上了，要使用这些 OpenGL 的高级特性，就必须下载最新的扩展。另外，不同的显卡公司，也会发布一些只有自家显卡才支持的扩展函数，你要想用这些函数，不得不去寻找最新的 glext.h，有了 GLEW 扩展库，你就再也不用为找不到函数的接口而烦恼，因为 GLEW 能自动识别你的平台所支持的全部 OpenGL 高级扩展涵数。 也就是说，只要包含一个 glew.h 头文件，你就能使用 gl、glu、glext、wgl、glx 的全部函数。 GLEW 支持目前流行的各种操作系统(including Windows、Linux、Mac OS X、FreeBSD、Irix、and Solaris)。 项目主页：http://glew.sourceforge.net/文档地址：http://glew.sourceforge.net/install.html下载地址：https://sourceforge.net/project/downloading.php?group_id=67586&amp;filename=glew-1.5.1-src.zip 在 OpenGL 编程中，使用 glMultiTexCoord2f( GL_TEXTURE0+i, x, y ); 你会发现这个函数都没有定义的，以及 GL_TEXTURE0 这个常量。因为在 vc 编译器中，OpenGL 的版本是 1.1，版本比较落后，下个 glew 库就可以了。 安装的步骤与 glut 一模一样，将 dll 动态链接库放在 c:\\WINDOWS:\\system32;头文件，可以搜索一下 gl.h或者 gluax.h，会发现在编译器(指 vc)的安装路径下的，vc:\\PlatformSDK:\\include\\gl 文件夹中，将 glew 放在这里就 ok了。 静态库 lib 文件的话，放在 vc:\\PlatformSDK:\\Lib 文件中。 如果在使用了 glew，但是编译出：没有定义的 XXX 函数之类的错误，可以在文件开头加上： #pragma comment(lib, “glew32.lib”) 还有一个问题：查看 glew.h 文件，会发现这么一段话： #if defined(__gl_h_) || defined(__GL_H__) #error gl.h included before glew.h #endif 这句规定不能在 glew 之前引用 gl.h 文件。否则会报错：gl.h included before glew.h GLEW有什么用？你可以把它看作是 windows 上的 OpenGL 的基本库，他取代了原来的 gl.h、wgl.h，让你可以方便的调用最新的 OpenGL 功能，包括 OpenGL 众多的 Extension。 下载地址：http://glew.sourceforge.net/ 二、基本特性 跨操作系统 支持动态链接、静态库，你还可以把 glew.c 复制到工程中一起编译 只依赖于 OPENGL32.dll 和 KERNEL32.dll 因为不依赖于 CRT 所有你使用 single-threaded、multi-threaded 或者 multi-threaded DLL都没有限制 三、文件结构 发布版本包括一个 glew32.dll 和对应的 glew32.lib，头文件 glew.h 和 wglew.h。(windows dll版本)。源文件只有一个 glew.c。 四、glew 基本使用 ①、初始化 #include &lt;GL/glew.h&gt; // 放在一切和 gl 有关的头文件之前，就完成了引用 // 如果 err 为GLEW_OK(实际上返回 0，其宏定义中 GLEW_OK 为0)就完成了初始化 // 应该放在程序的开始部分。现在还是不明白为什么有操作可以早于初始化执行。 GLenum err = glewInit(); ②、检查扩展 if (GLEW_ARB_vertex_program) { glGenProgramsARB(…); } if (GLEW_VERSION_1_3) { } if (glewIsSupported(“GL_VERSION_1_4 GL_ARB_point_sprite”)) { } if (glewGetExtension(“GL_ARB_fragment_program”)) { } GLEW 为了实现扩展检查的功能，编制了大量的代码。简单的看就是即支持宏标签又支持字符串查询。 ③、glew.h 源码结构 // 开头就检测有没有和 GLEW 冲突的库 #if defined(__gl_h_) || defined(__GL_H__) #error gl.h included before glew.h #endif #if defined(__glext_h_) || defined(__GLEXT_H_) #error glext.h included before glew.h #endif #if defined(__gl_ATI_h_) #error glATI.h included before glew.h #endif 这些文件功能上和 GLEW 是重复的，所有开始就屏蔽掉了。 接下来的一堆宏只是为了正确的定义 GLEWAPI GLAPI GLAPIENTRY CALLBACK 等等宏。这些定义本来已经在其他的头文件中定义了，比如 WINGDIAPI 就在 winnt.h 中定义过了。这里画蛇添足的做法只是为了保证 GLEW 的纯洁性，为了不依赖任何不必要的库和头文件。 在下面就是 OpenGL1.1 的定义了。这里很简单就是类型定义和宏定义，API 使用外部函数方式，这就是为什么不需要 gl.h了。 #define GLEW_VERSION_1_1 GLEW_GET_VAR(__GLEW_VERSION_1_1) 唯一让人有点不解的是这句，解析了所有的宏之后 GLEW_VERSION_1_1 被定义为一个 GLboolean 类型的变量。之后就让人很烦了 __GLEW_VERSION_1_1 被初始化为 GL_FALSE，然后作者又在检测到支持 1.1 之后把 GLEW_VERSION_1_1 赋值为真。宏来宏去的让人郁闷。不过想想也是有道理的，GLEW_VERSION_1_1 作为检测标志必须是个宏，而宏是不能修改值的，既然他可能为真也可能为假，那就只有一个办法，找一个变量作为他的存储空间，然后这个宏就可以当变量使用了。 再下面 #include &lt;GL/glu.h&gt; 再下面是 OpenGL1.2 的定义，和 1.1 的定义方式类似，只是函数定义方式不同了。 typedef void (GLAPIENTRY * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); typedef void (GLAPIENTRY * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices); typedef void (GLAPIENTRY * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels); typedef void (GLAPIENTRY * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels); #define glCopyTexSubImage3D GLEW_GET_FUN(__glewCopyTexSubImage3D) #define glDrawRangeElements GLEW_GET_FUN(__glewDrawRangeElements) #define glTexImage3D GLEW_GET_FUN(__glewTexImage3D) #define glTexSubImage3D GLEW_GET_FUN(__glewTexSubImage3D) 4 个函数指针定义对应 4 个 define，看名字就知道他们是一一对应的，但是就是对不上，郁闷吧。但是在文件最后的部分能找到这样的代码。 GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D; GLEW_FUN_EXPORT PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements; GLEW_FUN_EXPORT PFNGLTEXIMAGE3DPROC __glewTexImage3D; GLEW_FUN_EXPORT PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D; 也是 4 个，这下对上号了吧。PFNGLCOPYTEXSUBIMAGE3DPROC 是一个函数指针类型定义 glewCopyTexSubImage3D 是实际被定义的指针函数，#define glCopyTexSubImage3D GLEW_GET_FUN(glewCopyTexSubImage3D) 又指向了 glCopyTexSubImage3D。到最后 glCopyTexSubImage3D 才是真正的 API 接口。真费劲。 再往下 1.3、1.4、1.5、2.0、2.1、3.0 结构完全和 1.2 一致 再往下就是各种扩展了，形式上还是和 1.2 定义的方式一致 再往下就是 GLEW_FUN_EXPORT PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D; 等等了。 再往下是 GLEW_VAR_EXPORT GLboolean __GLEW_VERSION_1_1; 等等。 最后才是 GLEW 的主要函数接口。这里支持一个 GLEW_MX 的定义，就是对 GLEW MX 的支持。 ④、glew.c 源码结构 相对简单的多，除了一些函数的实现以外，全是初始化函数。全部都是从 glewInit 开始的，一路下去初始化各个版本和所有扩展。 ⑤、wglew 看明白上面的，这里就不用说了，比葫芦看瓢吧. 二、生产并添加静态库 ①、静态链接库的创建 在 solution中 new project -&gt; win32 project -&gt; static library 即可创建生成静态链接库的项目。 在该项目的 properties 中可看到： Configuration Properties –&gt; General –&gt; Configuration type 中可以看到是lib Configuration Properties –&gt; General –&gt; Output Directory 是生成lib 的目录 Library –&gt; General –&gt; Output File 是生成的文件名字 将 GLEW 链接为静态库，在你的 project preprocessor settings 中，需要定义GLEW_STATIC 。否则，GLEW 会认为使用的是 DLL 版本。 ②、添加静态链接库 包含头文件 引入 lib 文 调用 lib 库提供的函数 参见：http://technet.microsoft.com/zh-cn/library/ms235627.aspx To use the functionality from the static library in the application 1). After you create a console application, the wizard creates an empty program for you. The name for the source file will be the same as the name that you chose for the project earlier. In this example, it is named MyExecRefsLib.cpp. 2).You must reference the static library you created to use its math routines. To do this, select References from the Projectmenu. From the MyExecRefsLib Property Pages dialog box, expand the Common Properties node and then click Add New Reference. For more information about the References dialog box, see Framework and References, Common Properties, Property Pages Dialog Box. 3). The Add Reference dialog box is displayed. The Projects tab lists the projects in the current solution and any libraries that you can reference. On the Projects tab, select MathFuncsLib.Click OK. 4).To reference the MathFuncsLib.h header file, you must modify the include directories path. In the MyExecRefsLib Property Pages dialog box, expand the Configuration Properties node, expand the C/C++ node, and then select General. In theAdditional Include Directories property value, type the path of the MathFuncsLib directory or browse for it. 5). To browse for the directory path, in the property value drop-down list box, click Edit. In the Additional Include Directoriesdialog box, in the text box, select a blank line and then click the ellipsis button (…) at the end of the line. In the Select Directory dialog box, select the MathFuncsLib directory and then click Select Folder to save your selection and close the dialog box. In the Additional Include Directories dialog box, click OK. 6).You can now use the MyMathFuncs class in this application. To do this, replace the contents of MyExecRefsLib.cpp with the following code. 注意：debug 和 release 模式下生的的 lib 文件是不一样的，在其他项目引用生成的 lib 文件时，处于 debug 模式下必须引用 debug 模式下生成的 lib 文件，release 模式下必须引用release 模式下生成的文件。否则可能会出问题。","tags":[]},{"title":" 顶点数组对象(VAO)\t\t","date":"2017-10-31T03:04:53.000Z","path":"2017/10/31/e9-a1-b6-e7-82-b9-e6-95-b0-e7-bb-84-e5-af-b9-e8-b1-a1vao/","text":"学习文章： VAO wiki 关于VAO的一篇博客 VAO","tags":[]},{"title":" 十、入门与VBO、VAO使用：绘制一个三角形\t\t","date":"2017-10-31T01:46:15.000Z","path":"2017/10/31/e5-8d-81-e3-80-81-e5-85-a5-e9-97-a8-e4-b8-8evbo-e3-80-81vao-e4-bd-bf-e7-94-a8-ef-bc-9a-e7-bb-98-e5-88-b6-e4-b8-80-e4-b8-aa-e4-b8-89-e8-a7-92-e5-bd-a2/","text":"原文：http://www.cnblogs.com/mazhenyu/p/6404242.html 下面的例子是实现绘制一个三角形的简单程序。采用了 VBO、VAO等 OpenGL 的一些新特性。越往后发展，可编程管线肯定是大势所趋，OpenGL 里原来的一些固定管线的内容肯定会被废弃掉。所以从现在开始写程序就要养成使用新特性，采用可编程管线技术的好习惯。 一、VAO、VBO 介绍 VBO:veretx buffer object VAO:vertex array object 随着 OpenGL 状态和固定管线模式的移除，我们不再用任何 glEnable 函数调用，而且也不会有 glVertex、glColor 等函数调用。这就意味着我们需要一种新的方式来将数据传输到图形卡以渲染图形。我们可以采用 VBO，或者是在 OpenGL3 以上版本引入的新的特性，叫做 VAO。通过它，我们可以把顶点数据和颜色存储在不同的 VBO 中，但是在同一个 VAO 中。对于法线数据或者其他的顶点信息也是一样。 VAO 是这样一种方式：把对象信息直接存储在图形卡中，而不是在当我们需要的时候传输到图形卡。这就是 Direct3D 所采用得方式，而在 OpenGL 中只有 OpenGL3.X 以上的版本中采用。这就意味着我们的应用程序不用将数据传输到图形卡或者是从图形卡输出，这样也就获得了额外的性能提升。 使用 VAO 并不难。我们不需要大量的 glVertex 调用，而是把顶点数据存储在数组中，然后放进VBO，最后在 VAO 中存储相关的状态。记住：VAO 中并没有存储顶点的相关属性数据。OpenGL 会在后台为我们完成其他的功能。 二、使用 VAO ①、产生 VAO /** @param n - 要产生的 VAO 对象的数量 @param arrays - 存放产生的 VAO 对象的名称 */ void glGenVertexArrays(GLsizei n, GLuint * arrays); ②、绑定 VAO /** @param array - 要绑定的顶点数组的名字 */ void glBindVertexArray(GLuint array); ③、产生 VBOs /** @brief 产生缓冲区对象的名称。参数含义和 glGenVertexArrays 类似 */ void glGenBuffers(GLsizei n, GLuint * buffers); ④、绑定 VBOs /** @brief 绑定一个缓冲区对象。当进行绑定之后，以前的绑定就失效了 @param target GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER */ void glBindBuffer(GLenum target, GLuint buffer); ⑤、给 VBO 分配数据 /** @param target GL_ARRAY_BUFFER(表示顶点数据), GL_ELEMENT_ARRAY_BUFFER(表示索引数据), GL_PIXEL_PACK_BUFFER(表示从 OpenGL 获取的的像素数据) or GL_PIXEL_UNPACK_BUFFER(表示传递给 OpenGL 的像素数据) @param size 缓冲区对象字节数 @param data 指针：指向用于拷贝到缓冲区对象的数据。或者是 NULL，表示暂时不分配数据 */ void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage); ⑥、定义存放顶点属性数据的数组 /** @brief 首先需要启用 VAO 中对应的顶点属性数组。注意：只在 OpenGL2.0 及其以上版本才有。 @param index 指定了需要启用的顶点属性数组的索引 */ void glEnableVertexAttribArray(GLuint index); ⑦、给对应的顶点属性数组指定数据 /** @param index 要指定数据的顶点属性数组的索引 @param size 每个顶点属性的数据个数。可能的取值是：1、2、3、4。初始值是 4 @param type 数组中每个数据的类型。可能的取值是：GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE。初始值是 GL_FLOAT。注意：如果有个非零的缓冲对象绑定到 GL_ARRAY_BUFFER，那么 pointer 就是对应的缓冲区对象的偏移量 @param normalized 指定顶点数在被访问的时候是否需要被归一化 @param stride 两个连续顶点的属性之间的偏移量 @param pointer 指向数组中的第一个顶点属性的第一个数据 */ void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer); ⑧、然后在进行渲染的时候，只需要绑定对应的 VAO 即可，操作起来十分方便。 glBindVertexArray(vaoHandle); ⑨、使用完毕之后需要清除绑定。 glBindVertexArray(0); 事实上，在这个简单的程序中，不用 VAO，只用 VBO 也一样可以实现。只是采用 VAO 可以进一步提升性能，而且在较新版本的 OpenGL 中不用 VAO 的方式会被逐渐废弃。 二、GLSL 入门 关于 GLSL，可以参考红宝书的附录，上面介绍了 GLSL 的入门知识。英文入门教程：GLSL入门 三、程序实例 下面贴出源代码(OpenGL，GLSL实现)： basic.vert： // 强制要求支持一个特定版本的 GLSL 版本 #version 400 in vec3 VertexPosition; in vec3 VertexColor; out vec3 Color; void main() { Color =VertexColor; gl_Position = vec4(VertexPosition, 1.0); } basic.frag： #version 400 in vec3 Color; out vec4 FragColor; void main() { FragColor = vec4(Color, 1.0); } main.cpp： #pragma comment(lib, “glew32.lib”) #include &lt;GL/glew.h&gt; #include “textfile.h” #include &lt;GL/glut.h&gt; #include using namespace std; GLuint vShader,fShader; // 顶点着色器对象 // 顶点位置数组 float positionData[] = { -0.8f, -0.8f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 0.8f, 0.0f }; // 颜色数组 float colorData[] = { 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f }; GLuint vaoHandle; // vertex array object void initShader(const char *VShaderFile, const char *FShaderFile) { // 1、查看 GLSL 和OpenGL 的版本 const GLubyte * renderer = glGetString( GL_RENDERER ); const GLubyte * vendor = glGetString( GL_VENDOR ); const GLubyte * version = glGetString( GL_VERSION ); const GLubyte * glslVersion = glGetString( GL_SHADING_LANGUAGE_VERSION ); GLint major, minor; glGetIntegerv(GL_MAJOR_VERSION, &amp;major); glGetIntegerv(GL_MINOR_VERSION, &amp;minor); cout &lt;&lt; “GL Vendor :” &lt;&lt; vendor &lt;&lt; endl; cout &lt;&lt; “GL Renderer : “ &lt;&lt; renderer &lt;&lt; endl; cout &lt;&lt; “GL Version (string) : “ &lt;&lt; version &lt;&lt; endl; cout &lt;&lt; “GL Version (integer) : “ &lt;&lt; major &lt;&lt; “.” &lt;&lt; minor &lt;&lt; endl; cout &lt;&lt; “GLSL Version : “ &lt;&lt; glslVersion &lt;&lt; endl; // 2、编译着色器 // 创建着色器对象：顶点着色器 vShader = glCreateShader(GL_VERTEX_SHADER); // 错误检测 if (0 == vShader){ cerr &lt;&lt; “ERROR : Create vertex shader failed” &lt;&lt; endl; exit(1); } // 把着色器源代码和着色器对象相关联 const GLchar *vShaderCode = textFileRead(VShaderFile); const GLchar *vCodeArray[1] = {vShaderCode}; glShaderSource(vShader,1, vCodeArray, NULL); // 编译着色器对象 glCompileShader(vShader); // 检查编译是否成功 GLint compileResult; glGetShaderiv(vShader, GL_COMPILE_STATUS, &amp;compileResult); if (GL_FALSE == compileResult) { GLint logLen; // 得到编译日志长度 glGetShaderiv(vShader, GL_INFO_LOG_LENGTH, &amp;logLen); if (logLen &gt; 0) { char log = (char )malloc(logLen); GLsizei written; // 得到日志信息并输出 glGetShaderInfoLog(vShader,logLen,&amp;written,log); cerr &lt;&lt; “vertex shader compile log : “ &lt;&lt; endl; cerr &lt;&lt; log &lt;&lt; endl; free(log); // 释放空间 } } // 创建着色器对象：片断着色器 fShader = glCreateShader(GL_FRAGMENT_SHADER); // 错误检测 if (0 == fShader) { cerr &lt;&lt; “ERROR : Create fragment shader failed” &lt;&lt; endl; exit(1); } // 把着色器源代码和着色器对象相关联 const GLchar *fShaderCode = textFileRead(FShaderFile); const GLchar *fCodeArray[1] = {fShaderCode}; glShaderSource(fShader,1, fCodeArray, NULL); // 编译着色器对象 glCompileShader(fShader); // 检查编译是否成功 glGetShaderiv(fShader, GL_COMPILE_STATUS, &amp;compileResult); if (GL_FALSE == compileResult) { GLint logLen; // 得到编译日志长度 glGetShaderiv(fShader, GL_INFO_LOG_LENGTH, &amp;logLen); if (logLen &gt; 0) { char *log = (char *)malloc(logLen); GLsizei written; // 得到日志信息并输出 glGetShaderInfoLog(fShader, logLen, &amp;written, log); cerr &lt;&lt; “fragment shader compile log : “ &lt;&lt; endl; cerr &lt;&lt; log &lt;&lt; endl; free(log); // 释放空间 } } // 3、链接着色器对象 // 创建着色器程序 GLuint programHandle = glCreateProgram(); if (!programHandle) { cerr &lt;&lt; “ERROR : create program failed” &lt;&lt; endl; exit(1); } // 将着色器程序链接到所创建的程序中 glAttachShader(programHandle, vShader); glAttachShader(programHandle, fShader); // 将这些对象链接成一个可执行程序 glLinkProgram(programHandle); // 查询链接的结果 GLint linkStatus; glGetProgramiv(programHandle, GL_LINK_STATUS, &amp;linkStatus); if (GL_FALSE == linkStatus) { cerr &lt;&lt; “ERROR : link shader program failed” &lt;&lt; endl; GLint logLen; glGetProgramiv(programHandle, GL_INFO_LOG_LENGTH, &amp;logLen); if (logLen &gt; 0) { char *log = (char *)malloc(logLen); GLsizei written; glGetProgramInfoLog(programHandle, logLen, &amp;written, log); cerr &lt;&lt; “Program log : “ &lt;&lt; endl; cerr &lt;&lt; log &lt;&lt; endl; } } else { // 链接成功，在 OpenGL 管线中使用渲染程序 glUseProgram(programHandle); } } void initVBO() { // Create and populate the buffer objects GLuint vboHandles[2]; glGenBuffers(2, vboHandles); GLuint positionBufferHandle = vboHandles[0]; GLuint colorBufferHandle = vboHandles[1]; // 绑定 VBO 以供使用 glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); // 加载数据到 VBO glBufferData(GL_ARRAY_BUFFER, 9*sizeof(float), positionData, GL_STATIC_DRAW); // 绑定 VBO 以供使用 glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); // 加载数据到 VBO glBufferData(GL_ARRAY_BUFFER, 9*sizeof(float), colorData, GL_STATIC_DRAW); glGenVertexArrays(1, &amp;vaoHandle); glBindVertexArray(vaoHandle); glEnableVertexAttribArray(0); // 顶点坐标 glEnableVertexAttribArray(1); // 顶点颜色 // 调用 glVertexAttribPointer 之前需要进行绑定操作 glBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle); glVertexAttribPointer( 0, 3, GL_FLOAT, GL_FALSE, 0, (GLubyte *)NULL ); glBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle); glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 0, (GLubyte *)NULL ); } void init() { // 初始化 glew 扩展库 GLenum err = glewInit(); if( GLEW_OK != err ) { cout &lt;&lt;”Error initializing GLEW: “ &lt;&lt; glewGetErrorString(err) &lt;&lt; endl; } initShader(“basic.vert”, “basic.frag”); initVBO(); glClearColor(0.0, 0.0, 0.0, 0.0); // glShadeModel(GL_SMOOTH); } void display() { glClear(GL_COLOR_BUFFER_BIT); //// 绘制一个三角形(使用普通方法) // glBegin(GL_TRIANGLES); // glColor3f(0.0f, 1.0f, 0.0f); // glVertex3f(0.0f, 1.0f, 0.0f); // glColor3f(0.0f, 1.0f, 0.0f); // glVertex3f(-1.0f, -1.0f, 0.0f); // glColor3f(0.0f, 0.0f, 1.0f); // glVertex3f(1.0f, -1.0f, 0.0f); // glEnd(); // 使用 VAO、VBO 绘制 glBindVertexArray(vaoHandle); glDrawArrays(GL_TRIANGLES, 0,3); glBindVertexArray(0); glutSwapBuffers(); } void keyboard(unsigned char key, int x, int y) { switch(key) { case 27: glDeleteShader(vShader); glUseProgram(0); break; } } int main(int argc, char** argv) { glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB); glutInitWindowSize(600, 600); glutInitWindowPosition(100, 100); glutCreateWindow(“GLSL Test : Draw a triangle”); init(); glutDisplayFunc(display); glutKeyboardFunc(keyboard); glutMainLoop(); return 0; } 读取 shader 文件的程序 textfile.h： // textfile.h: interface for reading and writing text files #ifndef TEXTFILE_H #define TEXTFILE_H #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char textFileRead(const char fn); int textFileWrite(char *fn, char *s); unsigned char *readDataFromFile(char *fn); #endif textfile.cpp： // textfile.cpp // simple reading and writing for text files #include “textfile.h” unsigned char readDataFromFile(char fn) { FILE *fp; unsigned char * content = NULL; int count=0; if (fn != NULL) { fp = fopen(fn, “rb”); if (fp != NULL) { fseek(fp, 0, SEEK_END); count = ftell(fp); rewind(fp); if (count &gt; 0) { content = (unsigned char )malloc(sizeof(unsigned char)(count+1)); count = fread(content,sizeof(unsigned char), count, fp); content[count] = ‘\\0’; } fclose(fp); } } return content; } char textFileRead(const char fn) { FILE *fp; char *content = NULL; int count=0; if (fn != NULL) { fp = fopen(fn, “rt”); if (fp != NULL) { fseek(fp, 0, SEEK_END); count = ftell(fp); rewind(fp); if (count &gt; 0) { content = (char )malloc(sizeof(char) (count+1)); count = fread(content,sizeof(char),count,fp); content[count] = ‘\\0’; } fclose(fp); } } return content; } int textFileWrite(char *fn, char *s) { FILE *fp; int status = 0; if (fn != NULL) { fp = fopen(fn, “w”); if (fp != NULL) { if (fwrite(s,sizeof(char),strlen(s),fp) == strlen(s)) status = 1; fclose(fp); } } return(status); } 运行结果：","tags":[]},{"title":" gl_NormalMatrix\t\t","date":"2017-10-30T09:30:47.000Z","path":"2017/10/30/gl-normalmatrix/","text":"原文：http://www.cnblogs.com/mazhenyu/p/6065438.html 1、当用 glsl 传 normal 到 fragment 的时候总要用 gl_Normal*gl_NormalMatrix，是为什么呢？2、做 bumpmap 的时候，binormal 和 tangent 需不需要也乘以 gl_NormalMatrix 呢？3、有没有想过 perspective 投影之后模型成什么样子呢？4、如果需要把 TBN 转到世界空间，而不是把灯光转到 TBN 的话需不需要乘以 gl_NormalMatrix 或者是需要乘以其它矩阵？ 在 Direct3D 你不需要关心这些，因为都处理好了，所以一路稀里糊涂下来效果也基本上做的出来，在OpenGL 就不行了。下面解释了什么是 gl_NormalMatrix，简而言之 gl_NormalMatrix 是为了令法线在 perspective projection 之后和投影后的模型平面依然垂直，但是它并不是投影矩阵哦，而是投影矩阵的逆矩阵的翻转矩阵。呵呵，顺便想象下投影后的物体是什么样子吧，这样就会幡然醒悟为什么需要重新找垂直于平面的发现了。 Normal Matrix Normals are funny. They’re vec3’s, since you don’t want perspective on normals. And they don’t actually scale quite right–a 45 degree surface with a 45 degree normal, scaled by glScalef(1,0.1,1), drops the surface down to near 0 degrees, but actually tilts the normal *up*, in the opposite direction from the surface, to near 90 degrees. Mathematically, if between two points a and b on the surface, dot(n,b-a)==0, then after applying a matrix M to the points, you want the normal to still be perpendicular. The question is, what matrix N do you have to apply to the normal to make this happen? In other words, find N such that dot( N n , M a - M * b) == 0 We can solve this by noting that dot product can be expresed as matrix multiplication–dot(x,y) = transpose(x) y, where we treat an ordinary column-vector as a little matrix, and flip it horizontally. So transpose(N n) (M\\a - M*b) == 0 (as above, but write using transpose and matrix multiplication) transpose(N n) M (a-b) == 0 (collect both copies of M) transpose(n) transpose(N) M (a-b) == 0 (transpose-of-product is product-of-transposes in opposite order) OK. This is really similar to our assumption that the original normal was perpendicular to the surface–that dot(n,b-a) == transpose(n) (a-b) == 0. In fact, the only difference is the new matrices wedged in the middle. If we pick N to make the term in the middle the identity, then our new normal will be perpendicular to the surface too: transpose(N) M == I (the identity matrix)This is the definition for matrix inverses, so the “normal matrix” N = transpose(inverse(M)). If you look up the GLSL definition for “gl_NormalMatrix”, it’s defined as “the transpose of the inverse of the gl_ModelViewMatrix”. Now you know why!","tags":[]},{"title":" 九、其他\t\t","date":"2017-10-30T09:21:07.000Z","path":"2017/10/30/e4-b9-9d-e3-80-81-e5-85-b6-e4-bb-96/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580988.html 一、法线矩阵在很多顶点 shader 中都用到了 gl_NormalMatrix。这里将介绍这个矩阵是什么，以及它的作用。 大部分计算是在视图空间内完成的，主要原因是光照的运算要放在这个空间内，否则一些依赖观察点坐标的效果，比如镜面反射光就很难实现。 所以我们需要将法线变换到视图空间。变换一个顶点到视图空间的方法如下： vertexEyeSpace = gl_ModelViewMatrix * gl_Vertex; 对法线也能如此操作吗？一个法线是 3 个浮点数组成的向量，而模型视图矩阵是一个 4×4 的矩阵。另外，因为法线是一个向量，我们只需要变换它的方向，而模型视图矩阵中左上方的 3×3 子矩阵正好包含了旋转变换。所以可不可以用法线来乘这个子矩阵呢？ 下面的代码很简单地实现了这个要求： normalEyeSpace = vec3(gl_ModelViewMatrix * vec4(gl_Normal, 0.0)); 这样的话，gl_NormalMatrix 还有什么用呢？只是为了简化代码书写吗？实际当然不是这么简单，上面的代码在某些情况下是有效的，但不能应对所有情况。 让我们看看潜在的问题：在上图中我们可以看到一个三角面以及它的法线和切线。下图显示了如果模型视图矩阵包含非一致缩放(non-uniform scale)的话会发生什么。注意，如果缩放是一致的(uniform)，那么法线方向保持不变，变的只是长度，而且可以通过归一化修正这个影响。 在上图中，模型视图矩阵应用到所有顶点以及法线上，最后的结果明显错误：法线不再与三角面垂直了。 现在我们知道模型视图矩阵在某些情况下，不能用来变换法线向量。下面的问题就是：那么该使用哪个矩阵？ 考虑一个 3×3 矩阵 G，让我们看看要正确变换法线，这个矩阵该是什么样子。 我们知道，变换前切线和法线是垂直的，即 T • N = 0，在变换后切线和法线同样应该保持垂直，即 T’ • N’ = 0。现在假设 G 是正确变换法线的矩阵，同时模型视图矩阵的左上 3×3 子矩阵 M 可以正确变换切线 T(T 是一个向量，所以 w 成分为 0)。因为 T 可以通过两个顶 点的差来计算，所以变换顶点的矩阵同样可以用来变换 T。由此可以得到如下等式：向量的点乘相当于向量的内积，所以有：我们知道相乘的转置等于分别转置再交换顺序相乘：已知 N 和 T 点乘结果为 0，所以如果下式成立就可以满足等式为 0：即有：可见变换法线的正确矩阵是 M 的逆的转置。OpenGL 计算出的这个矩阵就保存在 gl_NormalMatrix 里。在本节开始讨论过，某些情况下使用模型视图矩阵也可以。当模型视图矩阵的左上 3×3 子矩阵 M 正交时，可以得到：一个正交矩阵的所有行/列都为单位向量，并且互相正交。当两个向量乘上正交矩阵时，它们之间的夹角在变换前后不变。由于这种保角变换的关系，所以法线和切线依然保存垂直。此外，向量的长度也保持不变。 M 在什么时候能确定为正交的呢？当我们把几何变换限制为旋转和平移时(在 OpenGL 应用程序中只使用 glRotate 和 glTranslate，而不使用 glScale)，就可以保证 M 正交。注意：gluLookAt 同样建立正交矩阵。二、关于法线归一化 当一个法线到达顶点 shader 后，我们一般会将它归一化： normal = normalize(gl_NormalMatrix * gl_Normal); 法线与 gl_NormalMatrix 矩阵相乘，将会被变换到视图空间。归一化向量可以保证使用点乘得到余弦值。 我们可以避免归一化计算吗？在某些情况下是可行的。如果 gl_NormalMatrix 是正交矩阵，那么经过变换后输入法线的长度不会变，依然等于 gl_Normal。所以如果在 OpenGL 程序中法线已经是归一化的，那么在 shader 中就不需要在重复了。 也就是说，如果我们使用 gluLookAt 设置照相机，对模型值进行旋转和平移变换，就可以在 shader 中避免使用归一化操作。这对于归一化过的光线向量也是适用的。 三、片断 shader 的情况在片断 shader 中，我们经常发现需要重新归一化在顶点 shader 中已归一化的法线。这是必要的吗？答案是肯定的。 考虑一个包含三个不同顶点法线的三角面。片断 shader 接收经过插值的法线，插值基于距离三个顶点的远近。这样得到的法线方向是对的，但不再是单位长度了。 下图显示了原因。图中黑线表示三角面，顶点法线用蓝色表示，插值得到的片断法线用绿色表示。所有的插值法线排列在黑色的点划线上。从图上可以看出绿色的插值法线大小小于单位长度的顶点法线。注意，如果顶点法线没有单位化，那么得到的插值法线的方向也将是错误的。所以，即使一个顶点没有在顶点 shader 用到，也可能要对它在顶点 shader 中进行归一化。 有一种情况，在片断 shader 中可以避免归一化操作，那就是每个顶点法线方向相同，而且顶点法线是经过归一化的。此时顶点法线插值得到的结果都相同。 以方向光为例，每个片断都需要考虑光线方向，如果光线向量已经在之前归一化了，在片断 shader 中就可以避免归一化这一步。","tags":[]},{"title":" 八、纹理贴图\t\t","date":"2017-10-30T07:24:56.000Z","path":"2017/10/30/e5-85-ab-e3-80-81-e7-ba-b9-e7-90-86-e8-b4-b4-e5-9b-be/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580974.html 一、简单的纹理贴图（Simple Texture） 为了在 GLSL 中应用纹理，我们需要访问每个顶点的纹理坐标。GLSL 中提供了一些属性变量，每个纹理单元一个： attribute vec4 gl_MultiTexCoord0; attribute vec4 gl_MultiTexCoord1; attribute vec4 gl_MultiTexCoord2; attribute vec4 gl_MultiTexCoord3; attribute vec4 gl_MultiTexCoord4; attribute vec4 gl_MultiTexCoord5; attribute vec4 gl_MultiTexCoord6; attribute vec4 gl_MultiTexCoord7; GLSL 还为访问每个纹理的纹理矩阵提供了一个一致变量数组： uniform mat4 gl_TextureMatrix[gl_MaxTextureCoords]; 顶点 shader 可以通过上面所示的内容访问 OpenGL 程序中指定的纹理坐标。然后必须为每个顶点计算纹理坐标，并保存在预先定义的易变变量 gl_TexCoord[i] 中，i 表示纹理单元号。 下面这条语句直接复制 OpenGL 程序中指定的纹理坐标，作为纹理单元 0 的顶点纹理坐标。 gl_TexCoord[0] = gl_MultiTexCoord0; 下面是个简单的例子，在顶点 shader 中设置纹理单元 0 的纹理坐标。 void main() { gl_TexCoord[0] = gl_MultiTexCoord0; gl_Position = ftransform(); } 如果你想使用纹理矩阵，可以这样操作： void main() { gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0; gl_Position = ftransform(); } 前面说过 gl_TexCoord 是一个易变变量，所以在片断 shder 中可以访问经过插值的纹理坐标。 为了访问纹理的数值，在片断 shader 中有必要声明一个特殊的变量，对一个 2D 纹理可以这样写： uniform sampler2D tex; 如果是 1D 或者 3D 的纹理，可以改成 sampler1D 和 sampler3D。 这个用户定义的变量 tex 包含我们将会使用的纹理单元，通过 texture2D 函数我们可以得到一个纹素(texel)，这是一个纹理图片中的像素。函数参数分别为 simpler2D 以及纹理坐标： vec4 texture2D(sampler2D, vec2); 函数的返回值已经考虑了所有在 OpenGL 程序中定义的纹理设置，比如过滤、mipmap、clamp 等。 我们的片断 shader 可以写成如下形式： uniform sampler2D tex; void main() { vec4 color = texture2D(tex, gl_TexCoord[0].st); gl_FragColor = color; } 注意访问 gl_TexCoord 时选择子 st 的使用。在本教程前面关于数据类型和变量的讨论中说过，访问纹理坐标时可以使用如下选择子：s、t、p、q。(r 因为和 rgb 选择子冲突而没有使用) 本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/textureSimple.zip 二、组合纹理与片断OpenGL 允许我们通过多种方式将纹理颜色和片断颜色联合到一起。下表显示了 RGBA 模式时可用的联合方式： GL_REPLACE C = Ct A = At GL_MODULATE C = Ct*Cf A = At * Af GL_DECAL C = Cf (1 – At) + Ct At A = Af 表中 Ct 和 At 表示纹理的颜色和 alpha 值，Cf 和 Af 表示片断(fragment)的颜色和 alpha 值，C和 A 表示最终的颜色和 alpha 值。 上一节的例子就相当于使用了GL_REPLACE 模式。下面我们我们准备在一个立方体上实现与GL_MODULATE 等同的效果。两个 shader 只计算使用一个白色方向光的散射以及环境光成分，关于材质的完整定义请参照光照有关的章节。 因为使用了光照，所以顶点 shader 中必须处理法线信息。必须将法线变换到视图空间然后归一化，光线方向向量也必须归一化(光线方向向量已经由 OpenGL 变换到了视图空间)。现在新的顶点 shader 如下： varying vec3 lightDir, normal; void main() { normal = normalize(gl_NormalMatrix * gl_Normal); lightDir = normalize(vec3(gl_LightSource[0].position)); gl_TexCoord[0] = gl_MultiTexCoord0; gl_Position = ftransform(); } 在片断 shader 中，光照得到的片断的颜色和 alpha 值在 cf 和 af 中分别计算。shader 中剩余代码按照 GL_MODULATE 的公式计算： varying vec3 lightDir, normal; uniform sampler2D tex; void main() { vec3 ct, cf; vec4 texel; float intensity, at, af; intensity = max(dot(lightDir, normalize(normal)), 0.0); cf = intensity * (gl_FrontMaterial.diffuse).rgb + gl_FrontMaterial.ambient.rgb; af = gl_FrontMaterial.diffuse.a; texel = texture2D(tex,gl_TexCoord[0].st); ct = texel.rgb; at = texel.a; gl_FragColor = vec4(ct cf, at af); } 工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/textureComb.zip 三、多重纹理 在 GLSL 中实现多重纹理十分容易，我们只需要访问所有纹理即可。因为我们打算给每个纹理使用相同的纹理坐标，所以顶点 shader 不需要改动。片断 shader 中只需要进行些许改动，加上多个纹理的颜色值。 varying vec3 lightDir, normal; uniform sampler2D tex; void main() { vec3 ct, cf; vec4 texel; float intensity, at, af; intensity = max(dot(lightDir, normalize(normal)), 0.0); cf = intensity * (gl_FrontMaterial.diffuse).rgb + gl_FrontMaterial.ambient.rgb; af = gl_FrontMaterial.diffuse.a; texel = texture2D(tex, gl_TexCoord[0].st) + texture2D(l3d, gl_TexCoord[0].st); ct = texel.rgb; at = texel.a; gl_FragColor = vec4(ct cf, at af); } 效果如下： 下面添加点不同的效果：在黑暗中发光。我们希望第二个纹理能在黑暗中发光，在没有光照时达到最亮，在有光照时变暗。 我们通过两步计算最终的颜色：首先将第一个纹理与片断颜色进行 modulate 计算，然后根据光照强度(indensity)加上第二个纹理单元。 如果 indensity 是 0，第二个纹理单元取最大值，如果 indensity 为 1，只取第二个纹理单元颜色的 10%，当 indensity 在 0 和 1 之间时按这两个大小进行插值。可以使用 smoothstep 函数实现这个要求： genType smoothStep(genType edge0, genType edge1, genType x); 如果 x &lt;= edge0 结果是 0，如果 x &gt;= edge1 结果为 1，如果 edge0 &lt; x &lt; edge1 结果在 0 和 1 之间进行 Hermite 插值。在本例中我们按如下方式调用： coef = smoothStep(1.0, 0.2, intensity); 下面的片断 shader 实现了需要的效果： varying vec3 lightDir, normal; uniform sampler2D tex, l3d; void main() { vec3 ct, cf, c; vec4 texel; float intensity, at, af, a; intensity = max(dot(lightDir, normalize(normal)), 0.0); cf = intensity * (gl_FrontMaterial.diffuse).rgb + gl_FrontMaterial.ambient.rgb; af = gl_FrontMaterial.diffuse.a; texel = texture2D(tex, gl_TexCoord[0].st); ct = texel.rgb; at = texel.a; c = cf * ct; a = af * at; float coef = smoothstep(1.0, 0.2, intensity); c += coef * vec3(texture2D(l3d, gl_TexCoord[0].st)); gl_FragColor = vec4(c, a); } 工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/textureGlow.zip","tags":[]},{"title":" 七、逐像素的光照\t\t","date":"2017-10-30T06:51:54.000Z","path":"2017/10/30/e4-b8-83-e3-80-81-e9-80-90-e5-83-8f-e7-b4-a0-e7-9a-84-e5-85-89-e7-85-a7/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580965.html 一、逐像素的方向光（Directional Light per Pixel）这一节将把前面的 shader 代码改为逐像素计算的方向光。我们需要将工作按照两个 shader 拆分，以确定哪些是需要逐像素操作的。 首先看看每个顶点接收到的信息：• 法线• 半向量• 光源方向 我们需要将法线变换到视点空间然后归一化。我们还需要将半向量和光源方向也归一化，不过它们已经位于视点空间中了。这些归一化之后的向量会进行插值，然后送入片断 shader，所以需要声明易变变量保存这些向量。 我们也可以在顶点 shader 中完成一些与光和材质相关的计算，这样可以帮助平衡顶点 shader 和片断 shader 的负载。 顶点 shader 代码可以写成如下形式： varying vec4 diffuse, ambient; varying vec3 normal, lightDir, halfVector; void main() { / first transform the normal into eye space and normalize the result / normal = normalize(gl_NormalMatrix * gl_Normal); /* now normalize the light’s direction. Note that according to the OpenGL specification, the light is stored in eye space. Also since we’re talking about a directional light, the position field is actually direction */ lightDir = normalize(vec3(gl_LightSource[0].position)); / Normalize the halfVector to pass it to the fragment shader / halfVector = normalize(gl_LightSource[0].halfVector.xyz); / Compute the diffuse, ambient and globalAmbient terms / diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient; ambient += gl_FrontMaterial.ambient * gl_LightModel.ambient; gl_Position = ftransform(); } 接下来在片断 shader 中，首先要声明同样的易变变量。此外还要再次对法线进行归一化，光线向量不需要进行归一化了，因为方向光对所有顶点都是一致的，插值得到的结果自然也不会变。之后就是计算插值过的法线向量与光线向量的点积。 varying vec4 diffuse,ambient; varying vec3 normal,lightDir,halfVector; void main() { vec3 n,halfV; float NdotL,NdotHV; / The ambient term will always be present / vec4 color = ambient; /* a fragment shader can’t write a varying variable, hence we need a new variable to store the normalized interpolated normal */ n = normalize(normal); / compute the dot product between normal and ldir / NdotL = max(dot(n,lightDir),0.0); … } 如果点积结果 NdotL 大于 0，我们就必须计算散射光，也就是用顶点 shader 传过来的散射项乘以这个点积。我们还需要计算镜面反射光，计算时首先对接收到的半向量归一化，然后计算半向量和法线之间的点积。 … if (NdotL &gt; 0.0) { color += diffuse * NdotL; halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += gl_FrontMaterial.specular gl_LightSource[0].specular pow(NdotHV, gl_FrontMaterial.shininess); } gl_FragColor = color; 下图显示了逐像素光照和逐顶点光照效果的区别：本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/dirpixsd.zip 二、逐像素的点光（Point Light Per Pixel）本节基于前面有关方向光的内容，大部分代码都相同。本节内容主要涉及方向光和点光的不同之处。方向光一般假设光源在无限远的地方，所以到达物体时是平行光。相反，点光源有一个空间中的位置，并向四面八方辐射光线。此外，点光的强度会随到达顶点的距离而衰弱。 对于 OpenGL 程序来说，这两种光的区别主要有：• 光源的 position 域的 w 分量：对方向光来说它是 0，表面这个 position 实际是一个方向(direction)；对点光来说，这个分量是 1。• 点光源的衰减由三个系数决定：一个常数项，一个线性项和一个二次项。 对方向光来说，光线的方向对所有顶点相同，但是对点光来说，方向是从顶点指向光源位置的向量。因此对我们来说需要修改的就是在顶点 shader 中加入计算光线方向的内容。 在 OpenGL 中衰减是按照如下公式计算的： 式中 k0 是常数衰减系数，k1 是线性衰减系数，k2 是二次衰减系数，d 是光源位置到顶点的距离。 注意衰减与距离是非线性关系，所以我们不能逐顶点计算衰减再在片断 shader 中使用插值结果，不过我们可以在顶点 shader 中计算距离，然后在片断 shader 中使用距离的插值计算衰减。 使用点光计算颜色值的公式为： 在上面公式中，环境光部分必须分解为两项：使用光照模型的全局环境光设置和光源中的环境光设置。顶点 shader 也必须分别计算这两个环境光成分。新的顶点 shader 如下： varying vec4 diffuse, ambientGlobal, ambient; varying vec3 normal, lightDir, halfVector; varying float dist; void main() { vec4 ecPos; vec3 aux; normal = normalize(gl_NormalMatrix * gl_Normal); / these are the new lines of code to compute the light’s direction / ecPos = gl_ModelViewMatrix * gl_Vertex; aux = vec3(gl_LightSource[0].position - ecPos); lightDir = normalize(aux); dist = length(aux); halfVector = normalize(gl_LightSource[0].halfVector.xyz); / Compute the diffuse, ambient and globalAmbient terms / diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; / The ambient terms have been separated since one of them / / suffers attenuation / ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient; ambientGlobal = gl_FrontMaterial.ambient * gl_LightModel.ambient; gl_Position = ftransform(); } 在片断 shader 中需要计算衰减，还需要将插值得到的光线方向向量归一化，因为一般来说照到每个顶点的光线方向都不同。 varying vec4 diffuse, ambientGlobal, ambient; varying vec3 normal, lightDir, halfVector; varying float dist; void main() { vec3 n, halfV, viewV, ldir; float NdotL, NdotHV; vec4 color = ambientGlobal; float att; /* a fragment shader can’t write a varying variable, hence we need a new variable to store the normalized interpolated normal */ n = normalize(normal); / compute the dot product between normal and normalized lightdir / NdotL = max(dot(n,normalize(lightDir)), 0.0); if (NdotL &gt; 0.0) { att = 1.0 / (gl_LightSource[0].constantAttenuation + gl_LightSource[0].linearAttenuation * dist + gl_LightSource[0].quadraticAttenuation dist dist); color += att (diffuse NdotL + ambient); halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += att gl_FrontMaterial.specular gl_LightSource[0].specular * pow(NdotHV,gl_FrontMaterial.shininess); } gl_FragColor = color; } 下图显示了固定功能的逐顶点与本节中逐像素计算得到的点光效果： 本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/pointlightsd.zip 三、逐像素的聚光（Spot Light Per Pixel）本节内容与上一节基本一致，唯一不同的就是聚光不同于点光，其发出的光线被限制在一个圆锥体中。对于 OpenGL 程序来说，这两种光的区别主要有：• 聚光包含一个方向向量 spotDirection，表示圆锥体的轴。• 圆锥体包含一个角度，在 GLSL 中可以使用应用程序设置的角度值以及对应的余弦值spotCosCutoff。• 最后还有一个衰减速率 spotExponent，它表示从圆锥的中心轴向外表面变化时光强度的衰减。 聚光的顶点 shader 与点光完全相同，我们只需要对片断 shader 进行一些修改。只有当当前片断位于聚光的光锥内时，才需要对散射光、镜面反射光和环境光成分进行着色。所以我们首先要检查这个条件。 光源与某点连线向量以及聚光方向向量(spotDirection)之间夹角的余弦值必须大于 spotCosCutoff，否则此点位于聚光之外，只能接收到全局环境光。 … n = normalize(normal); / compute the dot product between normal and ldir / NdotL = max(dot(n, normalize(lightDir)), 0.0); if (NdotL &gt; 0.0) { spotEffect = dot(normalize(gl_LightSource[0].spotDirection), normalize(-lightDir)); if (spotEffect &gt; gl_LightSource[0].spotCosCutoff) { / compute the illumination in here / } } gl_FragColor = … 下面的光照计算与点光非常相似，唯一区别是衰减必须乘以聚光效果(spotlight effect)，这个值按如下公式计算： 上式中 spotDirection 来自 OpenGL 中设置的状态，lightDir 是光源到某点的向量，spotExp 是聚光衰减率，这个值也是在 OpenGL 程序中设置的，它用来控制从聚光光锥中心到边缘的衰减。spotExp 越大衰减越快，如果为 0 表示在光锥内光强是常数。 spotEffect = pow(spotEffect, gl_LightSource[0].spotExponent); att = spotEffect / (gl_LightSource[0].constantAttenuation + gl_LightSource[0].linearAttenuation * dist + gl_LightSource[0].quadraticAttenuation dist dist); color += att (diffuse NdotL + ambient); halfV = normalize(halfVector); NdotHV = max(dot(n, halfV), 0.0); color += att gl_FrontMaterial.specular gl_LightSource[0].specular * pow(NdotHV, gl_FrontMaterial.shininess); 下图分别显示了使用固定功能流水线的逐顶点光照计算，以及使用本节 shader 的逐像素光照计算得到的聚光效果。本节内容的工程下载地址：http://www.lighthouse3d.com/wp-content/uploads/2011/03/spotlightsd.zip","tags":[]},{"title":" 六、逐顶点的光照\t\t","date":"2017-10-30T06:21:09.000Z","path":"2017/10/30/e5-85-ad-e3-80-81-e9-80-90-e9-a1-b6-e7-82-b9-e7-9a-84-e5-85-89-e7-85-a7/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580960.html 引言在 OpenGL 中有三种类型的光：方向光(directional)、点光(point)、聚光(spotlight)。本教程将从方向光讲起，首先我们将使用 GLSL 来模仿 OpenGL 中的光。 我们将向 shader 中逐渐添加环境光、散射光和高光效果。后面的教程中我们将使用逐像素光照以获得更好的效果。接下来我们将实现逐像素的点光和聚光。这些内容与方向光很相近，大部分代码都是通用的。 在卡通着色的教程中我们接触过在 GLSL 中如何访问 OpenGL 状态中关于光源的部分，这些数据描述了每个光源的参数。 struct gl_LightSourceParameters { vec4 ambient; vec4 diffuse; vec4 specular; vec4 position; vec4 halfVector; vec3 spotDirection; float spotExponent; float spotCutoff; // (range: [0.0, 90.0], 180.0) float spotCosCutoff; // (range: [1.0, 0.0], -1.0) float constantAttenuation; float linearAttenuation; float quadraticAttenuation; }; uniform gl_LightSourceParameters gl_LightSource[gl_MaxLights]; struct gl_LightModelParameters { vec4 ambient; }; uniform gl_LightModelParameters gl_LightModel; 在 GLSL 中也同样可以访问材质参数： struct gl_MaterialParameters { vec4 emission; vec4 ambient; vec4 diffuse; vec4 specular; float shininess; }; uniform gl_MaterialParameters gl_FrontMaterial; uniform gl_MaterialParameters gl_BackMaterial; 在 OpenGL 程序中，这些参数中的大部分，不论属于光源还是材质，用起来都是相似的。我们将使用这些参数实现自己的方向光。 一、方向光 I本节的公式来自《OpenGL 编程指南》中 “和光照有关的数学知识” 这一章。 我们从散射光开始讨论。在 OpenGL 中假定，不管观察者的角度如何，得到的散射光强度总是相同的。散射光的强度与光源中散射光成分以及材质中散射光反射系数相关，此外也和入射光角度与物体表面法线的夹角相关。OpenGL 用下面的公式计算散射光成分：I 是反射光的强度，Ld 是光源的散射成分(gl_LightSource[0].diffuse)，Md 是材质的散射系数(gl_FrontMaterial.diffuse)。 这个公式就是 Lambert 漫反射模型。Lambert 余弦定律描述了平面散射光的亮度，正比于平面法线与入射光线夹角的余弦，这一理论提出已经超过 200 年了。 在顶点 shader 中要实现这个公式，需要用到光源参数中的方向、散射成分强度，还要用到材质中的散射成分值。因此使用此 shader 时，在 OpenGL 中需要像在平时一样设置好光源。注意：由于没有使用固定功能流水线，所以不需要对光源调用 glEnable。 要计算余弦值，首先要确保光线方向向量(gl_LightSource[0].position)与法线向量都是归一化的，然后就可以使用点积得到余弦值。注意：对方向光，OpenGL 中保存的方向是从顶点指向光源，与上面图中画的相反。 OpenGL 将光源的方向保存在视点空间坐标系内，因此我们需要把法线也变换到视点空间。完成这个变换可以用预先定义的一致变量 gl_NormalMatrix。这个矩阵是模型视图变换矩阵的左上 3×3 子矩阵的逆矩阵的转置。 以下就是上述内容的顶点 shader 代码： void main() { vec3 normal, lightDir; vec4 diffuse; float NdotL; / first transform the normal into eye space and normalize the result / normal = normalize(gl_NormalMatrix * gl_Normal); /* now normalize the light’s direction. Note that according to the OpenGL specification, the light is stored in eye space. Also since we’re talking about a directional light, the position field is actually direction */ lightDir = normalize(vec3(gl_LightSource[0].position)); /* compute the cos of the angle between the normal and lights direction. The light is directional so the direction is constant for every vertex. Since these two are normalized the cosine is the dot product. We also need to clamp the result to the [0,1] range. */ NdotL = max(dot(normal, lightDir), 0.0); / Compute the diffuse term / diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; gl_FrontColor = NdotL * diffuse; gl_Position = ftransform(); } 在片断 shader 中要做的就是使用易变变量 gl_Color 设置颜色。 void main() { gl_FragColor = gl_Color; } 下图显示了应用此 shader 的茶壶效果。注意茶壶的底部非常黑，这是因为还没有使用环境光的缘故。加入环境光非常容易，只需要使用一个全局的环境光参数以及光源的环境光参数即可，公式如下所示： 前面的顶点 shader 中需要加入几条语句完成环境光的计算： void main() { vec3 normal, lightDir; vec4 diffuse, ambient, globalAmbient; float NdotL; normal = normalize(gl_NormalMatrix * gl_Normal); lightDir = normalize(vec3(gl_LightSource[0].position)); NdotL = max(dot(normal, lightDir), 0.0); diffuse = gl_FrontMaterial.diffuse * gl_LightSource[0].diffuse; / Compute the ambient and globalAmbient terms / ambient = gl_FrontMaterial.ambient * gl_LightSource[0].ambient; globalAmbient = gl_FrontMaterial.ambient * gl_LightModel.ambient; gl_FrontColor = NdotL * diffuse + globalAmbient + ambient; gl_Position = ftransform(); } 下图显示了最终效果。加入环境光后整个画面都变亮了，不过相对于应用了反射光效果的全局光照模型(global illumination model)，这种计算环境光的方式只能算廉价的解决方案。二、方向光 II下面介绍 OpenGL 方向光中的镜面反射部分。我们使用称为 Blin-Phong 模型的光照模型，这是Phong 模型的简化版。在这之前，我们有必要先看看 Phong 模型，以便于更好地理解 Blin-Phong 模型。 在 Phong 模型中，镜面反射成分和反射光线与视线夹角的余弦相关，如下图：L 表示入射光，N 表示法线，Eye 表示从顶点指向观察点的视线，R 是 L 经镜面反射后的结果，镜面反射成分与 α 角的余弦相关。 如果视线正好和反射光重合，我们将接收到最大的反射强度。当视线与反射光相分离时，反射强度将随之下降，下降速率可以由一个称为 shininess 的因子 控制，shininess 的值越大，下降速率越快。也就是说，shininess 越大的话，镜面反射产生的亮点就越小。在 OpenGL 中这个值的范围是 0 到128。计算反射光向量的公式：OpenGL 中使用 Phong 模型计算镜面反射成分的公式：式中指数 s 就是 shininess 因子，Ls 是光源中镜面反射强度，Ms 是材质中的镜面反射系数。 Blinn 提出了一种简化的模型，也就是 Blinn-Phong 模型。它基于半向量(half-vector)，也就是方向处在观察向量以及光线向量之间的一个向量：现在可以利用半向量和法线之间夹角的余弦来计算镜面反射成分。OpenGL 所使用的 Blinn-Phong 模型计算镜面反射的公式如下： 这个方法与显卡的固定流水线中使用的方法相同。因为我们要模拟 OpenGL 中的方向光，所以在 shader 中也使用此公式。幸运的是：OpenGL 会帮我们算半向量，我们只需要使用下面的代码： / compute the specular term if NdotL is larger than zero / if (NdotL &gt; 0.0) { // normalize the half-vector, and then compute the // cosine (dot product) with the normal NdotHV = max(dot(normal, gl_LightSource[0].halfVector.xyz),0.0); specular = gl_FrontMaterial.specular gl_LightSource[0].specular pow(NdotHV,gl_FrontMaterial.shininess); } 完整的工程下载：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/ogldirsd.zip","tags":[]},{"title":" 五、卡通着色\t\t","date":"2017-10-30T05:40:05.000Z","path":"2017/10/30/e4-ba-94-e3-80-81-e5-8d-a1-e9-80-9a-e7-9d-80-e8-89-b2/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580956.html 引言卡通着色可能是最简单的非真实模式 shader。它使用很少的颜色，通常是几种色调(tone)，因此不同色调之间是突变的效果。下图显示的就是我们试图达到的效果：茶壶上的色调是通过角度的余弦值选择的，这个角度是指光线和面的法线之间的夹角角度。如果法线和光的夹角比较小，我们使用较亮的色调，随着夹角变大，逐步使用更暗的色调。换句话说，角度余弦值将决定色调的强度。 在本教程中，我们先介绍逐顶点计算色调强度(intensity)的方法，之后把这个计算移到片断 shader中，此外还将介绍如何访问 OpenGL 中光源的方向。 一、卡通着色 v1这个版本使用逐顶点计算色调强度的方法，之后片断 shader 使用顶点色调强度的插值来决定片断选择那个色调。因此顶点 shader 必须声明一个易变变量保存强度值，片断 shader 中也需要声明一个同名的易变变量，用来接收经过插值的强度值。在顶点 shader 中，光线方向可以定义为一个局部变量或者常量，不过定义为一个一致变量将可以获得更大的灵活性，因为这样就可以在 OpenGL 程序中任意设置了。所以我们在 shader 中这样定义光的方向： uniform vec3 lightDir; 现在起我们假设光的方向定义在世界空间之中。 顶点 shader 通过属性变量 gl_Normal 来访问在 OpenGL 程序中指定的法线，这些法线在 OpenGL 程序中通过 glNormal 函数定义，因此位于模型空间。 如果在 OpenGL 程序中没有对模型进行旋转或缩放等操作，那么传给顶点 shader 的位于世界空间的gl_Normal 正好等于模型空间中定义的法线。另外法线只包含方向，所以不受移动变换的影响。 由于法线和光线方向定义在相同的空间中，顶点 shader 可以直接进行余弦计算，两个方向分别为lightDir 和 gl_Normal。计算余弦的公式如下： cos(lightDir, normal) = lightDir . normal / (|lightDir| * |normal|) 公式中的 “.” 表示内积，亦称为点积。如果 lightDir 和 gl_Normal 已经经过了归一化：| normal | = 1| lightDir | = 1 那么计算余弦的公式可以简化为： cos(lightDir, normal) = lightDir . normal 因为 lightDir 是由 OpenGL 程序提供的，所以我们可以假定它传到 shader 之前已经归一化了。只有光线方向改变时，才需要重新计算归一化。此外 OpenGL 程序传过来的法线也应该是经过归一化的。 我们将定义一个名为 intensity 的变量保存余弦值，直接使用 GLSL 提供的 dot 函数计算这个值。 intensity = dot(lightDir, gl_Normal); 最后顶点要做的就是变换顶点坐标。顶点 shader 的完整代码如下： uniform vec3 lightDir; varying float intensity; void main() { intensity = dot(lightDir, gl_Normal); gl_Position = ftransform(); } 如果想使用 OpenGL 中的变量作为光的方向，那么可以用 gl_LightSource[0].position 代替一致变量 lightDir，代码如下： varying float intensity; void main() { vec3 lightDir = normalize(vec3(gl_LightSource[0].position)); intensity = dot(lightDir, gl_Normal); gl_Position = ftransform(); } 现在在片断 shader 中唯一要做的就是根据 intensity 定义片断的颜色。前面已经提到，变量intensity 在两个 shader 中都定义为易变变 量，所以它将会在顶点 shader 中写入，然后在片断shader 中读出。片断 shader 中的颜色可以用如下方式计算： vec4 color; if (intensity &gt; 0.95) color = vec4(1.0, 0.5, 0.5, 1.0); else if (intensity &gt; 0.5) color = vec4(0.6, 0.3, 0.3, 1.0); else if (intensity &gt; 0.25) color = vec4(0.4, 0.2, 0.2, 1.0); else color = vec4(0.2, 0.1, 0.1, 1.0); 可以看到，余弦大于 0.95 时使用最亮的颜色，小于 0.25 时使用最暗的颜色。得到这个颜色后只需要再将其写入 gl_FragColor 即可，片断 shader 的完整代码如下： varying float intensity; void main() { vec4 color; if (intensity &gt; 0.95) color = vec4(1.0, 0.5, 0.5, 1.0); else if (intensity &gt; 0.5) color = vec4(0.6, 0.3, 0.3, 1.0); else if (intensity &gt; 0.25) color = vec4(0.4, 0.2, 0.2, 1.0); else color = vec4(0.2, 0.1, 0.1, 1.0); gl_FragColor = color; } 下图显示出本节的最终效果，看起来不是很好。主要原因是因为我们对 intensity 进行插值，插值的结果与用片断法线算出的 intensity 有区别，下一节我们将展示如何更好的实现卡通着色效果。 二、卡通着色 v2本节中我们要实现逐片断的卡通着色效果。为了达到这个目的，我们需要访问每个片断的法线。顶点shader 中需要将顶点的法线写入一个易变变量，这样在片断 shader 中就可以得到经过插值的法线。 顶点 shader 比上一版变得更简单了，因为颜色强度的计算移到片断 shader 中进行了。一致变量lightDir 也要移到片断 shader中，下面就是新的顶点 shader代码： varying vec3 normal; void main() { normal = gl_Normal; gl_Position = ftransform(); } 在片断 shader 中，我们需要声明一致变量 lightDir，还需要一个易变变量接收插值后的法线。片断 shader 的代码如下： varying vec3 normal; uniform vec3 lightDir; void main() { vec4 color; float intensity; intensity = dot(lightDir, normal); if (intensity &gt; 0.95) color = vec4(1.0, 0.5, 0.5, 1.0); else if (intensity &gt; 0.5) color = vec4(0.6, 0.3, 0.3, 1.0); else if (intensity &gt; 0.25) color = vec4(0.4, 0.2, 0.2, 1.0); else color = vec4(0.2, 0.1, 0.1, 1.0); gl_FragColor = color; } 下图就是渲染结果：令人吃惊的是新的渲染结果居然和前一节的一模一样，这是为什么呢？ 让我们仔细看看这两个版本的区别。在第一版中，我们在顶点 shader 中计算出一个 intensity 值，然后在片断 shader 中使用这个值的插值结 果。在第二个版中，我们先对法线插值，然后在片断shader 中计算点积。插值和点积都是线性运算，所以两者运算的顺序并不影响结果。 真正的问题在于片断 shader 中对插值后的法线进行点积运算的时候，尽管这时法线的方向是对的，但是它并没有归一化。 我们说法线方向是对的，因为我们假定传入顶点 shader 的法线是经过归一化的，对法线插值可以得到一个方向正确的向量。但是，这个向量的长度在大部分情况下都是错的，因为对归一化法线进行插值时，只有在所有法线的方向一致时才会得到一个单位长度的向量。（关于法线插值的问题，后面的教程会专门解释） 综上所述，在片断 shader 中，我们接收到的是一个方向正确长度错误的法线，为了修正这个问题，我们必须将这个法线归一化。下面是正确实现的代码： varying vec3 normal; uniform vec3 lightDir; void main() { float intensity; vec4 color; intensity = dot(lightDir, normalize(normal)); if (intensity &gt; 0.95) color = vec4(1.0, 0.5, 0.5, 1.0); else if (intensity &gt; 0.5) color = vec4(0.6, 0.3, 0.3, 1.0); else if (intensity &gt; 0.25) color = vec4(0.4, 0.2, 0.2, 1.0); else color = vec4(0.2, 0.1, 0.1, 1.0); gl_FragColor = color; } 下图就是新版本卡通着色的效果，看起来漂亮多了，虽然并不完美。图中物体还有些锯齿(aliasing)问题，不过这超出了本教程讨论的范围。下一节我们将在 OpenGL 程序中设置 shader 中的光线方向。三、卡通着色 v3结束关于卡通着色的内容之前，还有一件事需要解决：使用 OpenGL 中的光来代替变量 lightDir。 我们需要在 OpenGL 程序中定义一个光源，然后在我们的 shader 中使用这个光源的方向数据。注意：不需要用 glEnable 打开这个光源，因为我们使用了 shader。 我们假设 OpenGL 程序中定义的 1 号光源(GL_LIGHT0)是方向光。GLSL 已经声明了一个 C 语言形式的结构体，描述光源属性。这些结构体组成一个数组，保存所有光源的信息。 struct gl_LightSourceParameters { vec4 ambient; vec4 diffuse; vec4 specular; vec4 position; … }; uniform gl_LightSourceParameters gl_LightSource[gl_MaxLights]; 这意味着我们可以在 shader 中访问光源的方向（使用结构体中的 position 域），这里依然假定OpenGL 程序对光源方向进行了归一化。 OpenGL 标准中规定，当一个光源的位置确定后，将自动转换到视点空间(eye space)的坐标系中，例如摄像机坐标系。如果模型视图矩阵的左上 3×3 子阵是正交的（如果使用 gluLookAt 并且不使用缩放变换就可以满足这 点），便能保证光线方向向量在自动变换到视点空间之后保持归一化。 我们必须将法线也变换到视点空间，然后计算其与光线的点积。只有在相同空间，计算两个向量的点积得到余弦值才有意义。 为了将法线变换到视点空间，我们必须使用预先定义的 mat3 型的一致变量 gl_NormalMatrix。这个矩阵是模型视图矩阵的左上 3×3 子阵的逆矩 阵的转置矩阵(关于这个问题，后面的教程会专门解释)。需要对每个法线进行这个变换，现在顶点 shader 变为如下形式： varying vec3 normal; void main() { normal = gl_NormalMatrix * gl_Normal; gl_Position = ftransform(); } 在片断 shader 中，我们必须访问光线方向来计算 intensity 值： varying vec3 normal; void main() { float intensity; vec4 color; vec3 n = normalize(normal); intensity = dot(vec3(gl_LightSource[0].position),n); if (intensity &gt; 0.95) color = vec4(1.0, 0.5, 0.5, 1.0); else if (intensity &gt; 0.5) color = vec4(0.6, 0.3, 0.3, 1.0); else if (intensity &gt; 0.25) color = vec4(0.4, 0.2, 0.2, 1.0); else color = vec4(0.2, 0.1, 0.1, 1.0); gl_FragColor = color; } 本小节内容的 Shader Desinger 工程下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/toonf2.zip 基于 GLEW 的源代码下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/toonglut_2.0.zip","tags":[]},{"title":" 四、Hello World\t\t","date":"2017-10-29T06:19:14.000Z","path":"2017/10/29/hello-world/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580951.html 这一节中包含一个最基本的 shader，它提供如下功能：顶点变换然后使用单一的颜色渲染图元。 1、顶点 shader前面已经说过，顶点 shader 负责完成顶点变换。这里将按照固定功能的方程完成顶点变换。 固定功能流水线中一个顶点通过模型视图矩阵以及投影矩阵进行变换，使用如下公式： vTrans = projection modelview incomingVertex 首先 GLSL 需要访问 OpenGL 状态，获得公式中的前两个矩阵。前面讲过，GLSL 可以获取某些 OpenGL 状态信息的，这两个矩阵当然包括在内。可以通过预先定义的一致变量来获取它们： uniform mat4 gl_ModelViewMatrix; uniform mat4 gl_ProjectionMatrix; 接下来需要得到输入的顶点。通过预先定义的属性变量，所有的顶点将可以一个个传入顶点 shader 中。 attribute vec4 gl_Vertex; 为了输出变换后的顶点，shader 必须写入预先定义的 vec4 型变量 gl_Position 中，注意这个变量没有修饰符。 现在我们可以写一个仅仅进行顶点变换的顶点 shader 了。注意所有其他功能都将丧失，比如没有光照计算。顶点 shader 必须有一个 main 函数，如下面的代码所示： void main() { gl_Position = gl_ProjectionMatrix gl_ModelViewMatrix gl_Vertex; } 上面代码中变换每个顶点时，投影矩阵都将乘上模型视图矩阵，这显然非常浪费时间，因为这些矩阵不是随每个顶点变化的。注意这些矩阵是一致变量。 GLSL 提供一些派生的矩阵，也就是说 gl_ModelViewProjectionMatrix 是上面两个矩阵的乘积，所以顶点 shader 也可以写成下面这样： void main() { gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex; } 上面的操作能够获得和固定功能流水线相同的结果吗？理论上是如此，但实际上对顶点变换操作的顺序可能会不同。顶点变换通常在显卡中是高度优化的任务，所以有一个利用了这种优化的特定函数用来处理这个任务。这个神奇的函数如下： vec4 ftransform(void); 使用这个函数的另一个原因是 float 数据类型的精度限制。由于数据精度的限制，当使用不同的顺序计算时，可能得到不同的结果，因此 GLSL 提供这个函数保证获得最佳性能的同时，还能得到与固定功能流水线相同的结果。 这个函数按照与固定功能相同的步骤对输入顶点进行变换，然后返回变换后的顶点。所以 shader 可以重新写成如下形式： void main() { gl_Position = ftransform(); } 2、片断 shader 片断 shader 也有预先定义的变量 gl_FragColor，可以向其中写入片断的颜色值。下面的代码就是一个片断 shader，将所有片断绘制成淡蓝色： void main() { gl_FragColor = vec4(0.4, 0.4, 0.8, 1.0); } 可以在此获得本节例子的源码：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl5_2.0.zip 3、颜色 shaderGLSL 可以读取一些 OpenGL 状态，在本节我们将学习如何访问在 OpenGL 中设置的 glColor 变量。 GLSL 有一个属性变量记录当前颜色，也提供易变变量从顶点 shader 向片断 shader 传递颜色值。 attribute vec4 gl_Color; varying vec4 gl_FrontColor; // writable onthe vertex shader varying vec4 gl_BackColor; // writable onthe vertex shader varying vec4 gl_Color; // readable on thefragment shader 变量使用思想如下：1、OpenGL 程序通过 glColor 传送颜色信息。2、顶点 shader 通过属性 gl_Color 接收颜色值。3、顶点 shader 计算正面和反面的颜色，然后分别保存在 gl_FrontColor 和 gl_BackColor 中。4、片断 shader 接收易变变量 gl_Color 中存储的插值产生的颜色，由当前图元的方向决定颜色是 gl_FrontColor 还是 gl_BackColor 插值产生的。5、片断 shader 根据易变变量 gl_Color 设置 gl_FragColor。 前面说过顶点 shader 和片断 shader 中传递的易变变量要有相同的名字，但这里是个例外，顶点 shader 中的 gl_FrontColor和 gl_BackColor 会根据图元的方向，自动转变为片断 shader 中的 gl_Color。还要注意属性变量gl_Color 和易变变量 gl_Color 没有冲突，因为前者只存在于顶点 shader，后者只存在于片断 shader。 下面是顶点 shader 的例子，只计算了正面颜色： void main() { gl_FrontColor = gl_Color; gl_Position = ftransform(); } 片断 shader 更加简单： void main() { gl_FragColor = gl_Color; } 基于 GLEW 的源代码：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/colorglut_2.0.zip 4、扁平 shader（Flatten Shader）着色器编程让我们可以探索一些新效果，本节的例子展示了用奇怪的方法操作顶点得到的效果。 首先我们要得到一个扁平的 3D 模型，只需要在应用模型视图变换时将模型顶点的 z 坐标设为 0 就行了。下面是顶点 shader 的代码： void main(void) { vec4 v = vec4(gl_Vertex); v.z = 0.0; gl_Position = gl_ModelViewProjectionMatrix * v; } 我们先将 gl_Vertex 变量复制到一个局部变量 v 中。gl_Vertex 是一个 GLSL 提供的属性变量，所以在顶点 shader 中它是只读的。 片断 shader 只用设置一种颜色。一个扁平的茶壶效果如下： 更进一步，我们需要在 z 坐标上使用一个正弦函数。将 z 坐标作为 x 坐标的函数，这样茶杯将呈现波浪的效果： void main(void) { vec4 v = vec4(gl_Vertex); v.z = sin(5.0 v.x) 0.25; gl_Position = gl_ModelViewProjectionMatrix * v; } 最后我们需要加入一些顶点动画效果。为了达到这个目的我们需要增加一个变量记录变化的时间，或者帧数。一个顶点 shader是无法记录不同顶点值的，更不用说记录不同的帧了。所以我们需要在 OpenGL 程序中定义这个变量，然后作为一致变量传递给 shader。假设在 OpenGL 程序中有一个名为 time 的 帧计数器，在 shader 中有个同名的一致变量。 顶点 shader 的代码如下： uniform float time; void main(void) { vec4 v = vec4(gl_Vertex); v.z = sin(5.0 v.x + time 0.01) * 0.25; gl_Position = gl_ModelViewProjectionMatrix * v; } 在有关一致变量的小节讲过，在 OpenGL 程序中需要两个步骤：· setup 获取一致变量的存储位置· render 更新一致变量 设置(setup)步骤只有一条语句： loc = glGetUniformLocation(p, “time”); 这里 p 是程序的句柄，time 与顶点 shader 中定义的一致变量名称相同。变量 loc 是 Glint 类型的，必须定义在下面的渲染(render)函数也可以访问到的地方。渲染函数如下所示： void renderScene(void) { glClear(GL_COLOR_BUFFER_BIT| GL_DEPTH_BUFFER_BIT); glLoadIdentity(); gluLookAt( 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0f, 1.0f, 0.0f); glUniform1f(loc, time); glutSolidTeapot(1); time += 0.01; glutSwapBuffers(); } 函数中的变量 time 在程序一开始初始化，然后每帧都会进行自增运算。 本节的 GLEW 源代码：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/flatten_2.0.zip","tags":[]},{"title":" 三、在OpenGL中向shader传递信息\t\t","date":"2017-10-27T08:47:13.000Z","path":"2017/10/27/e4-b8-89-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e5-90-91shader-e4-bc-a0-e9-80-92-e4-bf-a1-e6-81-af/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580946.html 引言一个 OpenGL 程序可以用多种方式和 shader 通信。注意这种通信是单向的，因为 shader 的输出只能是渲染到某些目标，比如颜色和深度缓存。 OpenGL 的部分状态可以被 shader 访问，因此程序改变 OpenGL 某些状态就可以与 shader 进行通信了。例如一个程序想把光的颜色传给 shader，可以直接调用 OpenGL 接口，就像使用固定功能流水线时做的那样。 不过，使用 OpenGL 状态并不是设置 shader 中使用数据的直观方式。比如一个 shader 需要一个表示时间变化的变量来计算动画，在 OpenGL 状态中就没有现成的变量可用。当然，你可以使用没有用到的”镜面光截止角度(cutoffangle)”这样一个变量表示时间，但显然让人难以接受。 幸运的是 GLSL 允许用户自定义变量，实现 OpenGL 应用程序与 shader 通信。有了这个功能，你就可以命名一个叫做 timeElapsed 的变量表示经过的时间。 上文的讨论涉及到了 GLSL 提供的两种类型修饰符(更多的类型将在后面提到)：· 一致变量 - Uniform· 属性 - Attribute 在 shader 中定义的变量如果用这两种类型修饰符，表示对 shader 来说，它们是只读的。下面将详细讲述怎样使用这些类型的变量。 还有一种将变量送给 shader 的方法：使用纹理。一个纹理不止可以表示一张图片，它还可以表示一个数组。事实上，你完全可以决定如何在 shader 中解释纹理数据，即使它真是一幅图片。 1、数据类型和变量下面是 GLSL 中的基本数据类型：· float· bool· int浮点类型与 C 中类似，布尔类型可以为 true 或 false。这些基本类型可以组成 2、3 或 4 维向量，如下所示：· vec{2,3,4} a vector of 2,3,or 4 floats· bvec{2,3,4} bool vector· ivec{2,3,4} vector of integers GLSL 还包括 2×2、3×3 或 4×4 型矩阵，因为这些矩阵类型在图形处理中很常用：· mat2· mat3· mat4 此外，还有一组用来实现纹理访问的特殊类型，它们被称为采样器(sampler)，在读取纹理值(也称为纹素 texel)时用到。下面就是纹理采样用到的数据类型：· sampler1D – for 1D textures· sampler2D – for 2D textures· sampler3D – for 3D textures· samplerCube – for cube map textures· sampler1DShadow – for shadow maps· sampler2DShadow – for shadow maps 在 GLSL 中，可以像 C 一样声明和访问数组，但是不能在声明时初始化数组。GLSL 还可以定义结构体：struct dirlight{vec3 color;vec3 direction;}; 变量声明一个基本类型变量的方法与 C 类似，你还可以在声明它的同时进行初始bool d = true; // d is trueint c = 2; // c is initialized with 2 float a, b; // two vector (yes, the comments are like in C) 声明其它类型变量也是按照这种方法，但是初始化与 C 语言有区别。GLSL 非常依赖构造函数实现初始化和类型转换。float b = 2; // incorrect, there is no automatic type castingfloat e = (float)2; // incorrect, requires constructors for type casting int a = 2; float c = float(a); // correct. c is 2.0 vec3 f; // declaring f as a vec3 vec3 g = vec3(1.0,2.0,3.0); // declaring and initializing g 在 GLSL 中使用一些变量初始化其它变量是非常灵活的。你只需要给出需要的数据成员即可。请看下面的例子：vec2 a = vec2(1.0, 2.0); vec2 b = vec2(3.0, 4.0); vec4 c = vec4(a, b) // c = vec4(1.0, 2.0, 3.0, 4.0); vec2 g = vec2(1.0, 2.0); float h = 3.0; vec3 j = vec3(g, h); 矩阵的初始化也是类似方法，矩阵包含很多种构造函数，下面的例子给出了一些初始化矩阵的构造函数：mat4 m = mat4(1.0) // initializing the diagonal of the matrix with 1.0 vec2 a = vec2(1.0, 2.0); vec2 b = vec2(3.0, 4.0); mat2 n = mat2(a, b); // matrices are assigned in column major order mat2 k = mat2(1.0, 0.0, 1.0, 0.0); // all elements are specified 下面的例子给出了初始化结构体的方法：struct dirlight // type definition { vec3 color;vec3 direction; }; dirlight d1; dirlight d2 = dirlight(vec3(1.0, 1.0, 0.0), vec3(0.8, 0.8, 0.4)); 在 GLSL 中还有一些实用的选择器(selector)，可以简化我们的操作并让代码更简洁。访问一个向量可以使用如下的方法：vec4 a = vec4(1.0, 2.0, 3.0, 4.0); float posX = a.x; float posY = a[1]; vec2 posXY = a.xy; float depth = a.w 在上面的代码片段中，可以使用 x、y、z、w 来访问向量成员。如果是颜色的话可以使用 r、g、b、a，如果是纹理坐标的话可以使用 s、t、p、q。注意表示纹理坐标通常是使用 s、t、r、q，但 r 已经表示颜色中的红色了，所以纹理坐标中需要使用 p 来代替。 矩阵的选择器可以使用一个或两个参数，比如 m[0] 或者 m[2][3]。第一种情况选择了第一列，第二种情况选择了一个数据成员。 对于结构体来说，可以像在 C 语言中一样访问其成员。所以访问前面定义的结构体，可以使用如下的代码：d1.direction = vec3(1.0, 1.0, 1.0); 2、变量修饰符修饰符给出了变量的特殊含义，GLSL 中有如下修饰符：· const 声明一个编译期常量。· attribute 随不同顶点变化的全局变量，由 OpenGL 应用程序传给顶点 shader。这个修饰符只能用在顶点 shader 中，在 shader 中它是一个只读变量。· uniform 随不同图元变化的全局变量（即不能在 glBegin/glEnd 中设置），由 OpenGL 应用程序传给shader。这个修饰符能用在顶点和片断 shader 中，在 shader 中它是一个只读变量。· varying用于顶点 shader 和片断 shader 间传递的插值数据，在顶点 shader 中可写，在片断 shader中只读。 3、一致变量（Uniform Variables）不同于顶点属性在每个顶点有其自己的值，一个一致变量在一个图元的绘制过程中是不会改变的，所以其值不能在 glBegin/glEnd 中设置。一致变量适合描述在一个图元中、一帧中甚至一个场景中都不变的值。一致变量在顶点 shader 和片断 shader 中都是只读的。 首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得。注意，对某些驱动程序，在获得存储位置前还必须使用程序(调用 glUseProgram)。 获取一个一致变量的存储位置只需要给出其在 shader 中定义的变量名即可：/* @param program - the hanuler to the program @param name - the name of the variable / GLint glGetUniformLocation(GLuint program, const char *name); 返回值就是变量位置，可以用此信息设置变量的值。根据变量的数据类型不同，有一系列函数可以用来设置一致变量。用来设置浮点值的一组函数如下：/** @param location - the previously queried location @param v0,v1,v2,v3 - float values @param count - the number of elements in the array @param v - an array of floats / void glUniform1f(GLint location, GLfloat v0); void glUniform2f(GLint location, GLfloat v0, GLfloat v1); void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); GLint glUniform{1, 2, 3, 4}fv(GLint location, GLsizei count, GLfloat \\v); 对 integer 类型也有一组类似的函数，不过要用 i 替换函数中的 f。对 bool 类型没有专门的函数，但可以使用整数的 0 和 1 来表示真假。一旦你使用了一致变量数组，那么就必须使用向量版本的函数。 对 sampler 变量，使用函数 glUniform1i 和 glUniform1iv。 矩阵也是一种 GLSL 的数据类型，所以也有一组针对矩阵的函数：/** @param location - the previously queried location @param count - the number of matrices. 1 if a single matrix is being set, or n for an array of n matrices. @param transpose - wheter to transpose the matrix values. A value of 1 indicates that the matrix values are specified in row major order, zero is column major order @param v – an array of floats. /GLint glUniformMatrix{2,3,4}fv(GLint location, GLsizei count, GLboolean transpose, GLfloat v); 还有一点要注意的是：使用这些函数之后，变量的值将保持到程序再次连接之时。一旦进行重新连接，所有变量的值将被重置为 0。 最后是一些示例代码。假设一个 shader 中使用了如下变量： uniform float specIntensity; uniform vec4 specColor; uniform float t[2]; uniform vec4 colors[3]; 在 OpenGL 程序中可以使用下面的代码设置这些变量： GLint loc1, loc2, loc3, loc4; float specIntensity = 0.98; float sc[4] = {0.8, 0.8, 0.8, 1.0}; float threshold[2] = {0.5, 0.25}; float colors[12] = { 0.4, 0.4, 0.8, 1.0, 0.2, 0.2, 0.4, 1.0, 0.1, 0.1, 0.1, 1.0 }; loc1 = glGetUniformLocation( p, “specIntensity” ); glUniform1f(loc1, specIntensity); loc2 = glGetUniformLocation( p, “specColor” ); glUniform4fv(loc2, 1, sc); loc3 = glGetUniformLocation(p, “t”); glUniform1fv(loc3, 2, threshold); loc4 = glGetUniformLocation(p, “colors”); glUniform4fv(loc4, 3, colors); 例子代码的下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl2_2.0.zip 注意：设置一个数组(例子中的 t)与设置四元向量(例子中的 colors 和 specColor)的区别。中间的count 参数指在 shader 中声明的数组元素数量，而不是在 OpenGL 程序中声明的。所以虽然specColor 包含 4 个值，但 glUniform4fv 函数中的参数是 1，因为它只是一个向量。 另一种设置 specColor 的方法： loc2 = glGetUniformLocation(p, “specColor”); glUniform4f(loc2, sc[0], sc[1], sc[2], sc[3]); GLSL 中还可以获取数组中某个变量的地址。比如，可以获得 t[1] 的地址。下面的代码片段展示了设置 t 数组元素的另一种方法： loct0 = glGetUniformLocation(p, “t[0]“); glUniform1f(loct0, threshold[0]); loct1 = glGetUniformLocation(p, “t[1]“); glUniform1f(loct1, threshold[1]); 注意在 glGetUniformLocation 中使用方括号指示的变量。4、属性变量（Attribute Variables）在前一节提到，一致变量只能针对一个图元全体，就是说不能在 glBegin 和 glEnd 之间改变。 如果要针对每个顶点设置变量，那就需要属性变量了。事实上属性变量可以在任何时刻更新。在顶点 shader 中属性变量是只读的。因为它包含的是顶点数据，所以在片断 shader 中不能直接应用。 与一致变量相似，首先你需要获得变量在内存中的位置，这个信息只有在连接程序之后才可获得。注意，对某些驱动程序，在获得存储位置前还必须使用程序。 /** @param program – the handle to the program @param name – the name of the variable */ GLint glGetAttribLocation(GLuint program, char *name); 上述函数调用的返回变量在存储器中的地址。下面就可以为它指定一个值，类似一致变量，每种数据类型都有对应的函数。 /** @param location – the previously queried location. @param v0, v1, v2, v3 – float values. @param v – an array of floats. */ void glVertexAttrib1f(GLint location, GLfloat v0); void glVertexAttrib2f(GLint location, GLfloat v0, GLfloat v1); void glVertexAttrib3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); void glVertexAttrib4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); 或者 GLint glVertexAttrib{1, 2, 3, 4}fv(GLint location, GLfloat *v); 对于 integer 类型，也有一组类似的函数。与一致变量不同，这里向量版的函数并不支持对向量数组的赋值，所以函数参数用向量或是分别指定的效果没有太大区别，就好像 OpenGL 中 glColor3f 和 glColor3fv 的关系。下面是一个简单的例子，假定顶点 shader 中声明了一个名为 height 的浮点属性变量，在程序连接之后可以进行如下操作： loc = glGetAttribLocation(p, “height”); 在执行渲染的代码中间可以为 shader 中的变量赋值： glBegin(GL_TRIANGLE_STRIP); glVertexAttrib1f(loc, 2.0); glVertex2f(-1, 1); glVertexAttrib1f(loc, 2.0); glVertex2f( 1, 1); glVertexAttrib1f(loc, -2.0); glVertex2f(-1, -1); glVertexAttrib1f(loc, -2.0); glVertex2f( 1, -1); glEnd(); 例子代码的下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl3_2.0.zip、 顶点数组和属性变量也可以一起使用。首先需要使能数组，使用如下函数： /** @param loc - the location of the variable. */ void glEnableVertexAttribArray(GLint loc); 接下来使用函数提交包含数据的数组指针： /** @param loc – the location of the variable @param size – the number of components per element, for instance: 1 for float; 2 for vec2; 3 for vec3, and so on @param type – The data type associated: GL_FLOAT is an example @param normalized – if set to 1 then the array values will be normalized, converted to a range from -1 to 1 for signed data, or 0 to 1 for unsigned data @param stride – the spacing between elements. Exactly the same as in OpenGL @param pointer – pointer to the array containing the data */ void glVertexAttribPointer(GLint loc, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer); 下面是示例代码，首先执行初始化，定义了顶点数组和属性数组。 float vertices[8] = { -1, 1, 1, 1, -1, -1, 1, -1 }; float heights[4] = { 2, 2, -2, -2 }; … loc = glGetAttribLocation(p, “height”); glEnableClientState(GL_VERTEX_ARRAY); glEnableVertexAttribArray(loc); glVertexPointer(2, GL_FLOAT, 0, vertices); glVertexAttribPointer(loc, 1, GL_FLOAT, 0, 0, heights); 接下来的渲染步骤与 OpenGL 中的通常做法一致，比如调用 glDrawArrays。示例源代码下载地址：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl4_2.0.zip 5、易变变量（Varying Variables）前 面说过，shader 包括两种类型：顶点 shader 和片断 shader。为了计算片断的值，往往需要访问顶点的插值数据。例如，当使用逐片断光照时，我 们需要知道当前片断的法线，但是在 OpenGL 中只为每个顶点指定了法线。顶点 shader 可以访问这些法线，而片断 shader 不能，因为法线是 OpenGL 程序作为属性变量指定的。 顶点变换后的数据移动到流水线的下一个阶段，在这个阶段通过使用连接信息，生成了所有图元并完成片断化。对每个片断，有一组变量会被自动进行插值并提供给片断 shader，这些都是固定功能。片断的颜色就是这么处理的，到达片断 shader 的颜色就是组成图元的顶点颜色插值的结果。 像片断 shader 接收到的这种插值产生的变量，就是”易变变量”类型。GLSL 包含一些预先定义的易变变量，例如前面提到的颜色。用户也可以自己定义易变变量，它们必须同时在顶点 shader 和片断 shader中声明： varying float intensity; 一个易变变量必须先在顶点 shader 中声明，然后计算每个顶点的变量值。在片断 shader 中，接收这个变量通过插值得到的结果，注意此时这个变量是只读的。 6、语句和函数①、控制流语句 与 C 语言类似，GLSL 中有类似 if-else 的条件语句，for、while、do-while等循环语句。 if (bool expression) … else … for (initialization; bool expression; loop expression) … while (bool expression) … do … while (bool expression) GLSL 也有跳转语句：· continue – available in loops, causes a jump to thenext iteration of the loop· break – available in loops, causes an exit of theloop· discard最后的 discard 关键字只能在片断 shader 中使用，它将在不写入帧缓存或者深度缓存的情况下，终止当前片断的 shader 程序。 ②、函数 与 C 语言类似，shader 也是由函数组成的结构化程序。至少每类 shader 都必须包含一个如下方式声明的主函数： void main() 此外用户还可以自定义函数。这些函数像 C 函数一样，一般都会有返回值，返回值的类型没有限制，但不能是数组。 函数参数可以有如下修饰符：· in – for input parameters· out – for outputs of the function. The returnstatement is also an option for sending the result of a function.· inout – for parameters that are both input andoutput of a function 如果没有指定修饰符，默认情况下为 in 类型。 最后还有两点要注意：· 允许函数重载，只要参数不同。· 在标准中没有定义递归行为。 结束本节之前来看一个函数的例子： vec4 toonify(in float intensity) { vec4 color; if (intensity &gt; 0.98) color = vec4(0.8, 0.8, 0.8, 1.0); else if (intensity &gt; 0.5) color = vec4(0.4, 0.4, 0.8, 1.0); else if (intensity &gt; 0.25) color = vec4(0.2, 0.2, 0.4, 1.0); else color = vec4(0.1, 0.1, 0.1, 1.0); return(color); }","tags":[]},{"title":" 二、在OpenGL中使用GLSL\t\t","date":"2017-10-27T07:23:23.000Z","path":"2017/10/27/e4-ba-8c-e3-80-81-e5-9c-a8opengl-e4-b8-ad-e4-bd-bf-e7-94-a8glsl/","text":"原文：http://www.cnblogs.com/mazhenyu/p/5580916.html 配置 GLSL在 OpenGL 中，GLSL 的 shader 使用的流程与 C 语言相似，每个 shader 类似一个 C 模块，首先需要单独编译(compile)，然后一组编译好的 shader 连接(link)成一个完整程序。 这里将忽略 ARB 扩展，只列举 OpenGL2.0 的代码。建议使用 GLEW 库。下面的代码检查 OpenGL 2.0 是否可用： #include &lt;GL/glew.h&gt; #include &lt;GL/glut.h&gt; void main(int argc, char **argv) { glutInit(&amp;argc, argv); … glewInit(); if (glewIsSupported(“GL_VERSION_2_0”)) printf(“Ready for OpenGL 2.0n”); else { printf(“OpenGL 2.0 not supportedn”); exit(1); } setShaders(); glutMainLoop(); } 下图显示了创建shader的必要步骤，函数的具体使用方法将在下面各小结描述： 1、创建 shader下图显示了创建 shader 的步骤： 首先创建一个对象作为 shader 的容器，这个创建函数将返回容器的句柄。 /** @param shaderType - GL_VERTEX_SHADER or GL_FRAGMENT_SHADER */ GLuint glCreateShader(GLenum shaderType); 你可以创建许多 shader，但记住所有的顶点 shader 只能有一个 main 函数，所有像素 shader 也一样。 下一步将添加源代码。shader 的源代码是一个字符串数组，添加的语法如下： /** @param shader - the handler to the shader @param numOfStrings - the number of strings in the array @param strings - the array of strings @param lenOfStrings - an array with the length of each string, or NULL, meaning that the strings are NULL terminated. */ void glShaderSource(GLuint shader, int numOfStrings, const char **strings, int *lenOfStrings); 最后编译 shader： /** @param shader - the handler to the shader */ void glCompileShader(GLuint shader); 2、创建程序下图显示了获得一个可以运行的 shader 程序的步骤： 首先创建一个对象，作为程序的容器。此函数返回容器的句柄。 GLuint glCreateProgram(void); 你可以创建任意多个程序，在渲染时，可以在不同程序中切换，甚至在某帧返回固定功能流水线。比如你想用折射和反射 shader 绘制一个茶杯，然后回到固定功能生成立方体环境贴图(cube map)显示背景。 下面将把上一节编译的 shader 附加到刚刚创建的程序中。方法如下： /** @param program - the handler to the program @param shader - the handler to the shader you want to attach */ void glAttachShader(GLuint program, GLuint shader); 如果同时有顶点 shader 和片断 shader，你需要把它们都附加到程序中。你可以把多个相同类型(顶点或像素)的 shader 附加到一个程序中，如同一个 C 程序可以有多个模块一样，但它们只能有一个main 函数。 你也可以把一个 shader 附加到多个程序，比如你想在不同程序中使用某个相同的 shader。 最后一步是连接程序。方法如下： /** @param program - the handler to the program */ void glLinkProgram(GLuint program); 在连接操作之后，shader 的源代码可以被修改并重新编译，并不会影响到整个程序。 程序连接后，可以调用 glUseProgram 来使用程序。每个程序都分配了一个句柄，你可以事先连接多个程序以备使用。 /** @param prog - the handler to the program you want to use, or zero to return to fixed functionality. */ void glUseProgram(GLuint prog); 当一个程序被使用后，如果被再次连接，它将被自动替换并投入使用，所以没有必要再次调用上面这个函数。如果使用的参数为 0，表示将使用固定功能流水线。 3、例子下面的代码包含了上面描述的所有步骤，参数 p, f, v 是全局的 GLuint 型变量。 void setShaders() { v = glCreateShader(GL_VERTEX_SHADER); // 顶点着色器 f = glCreateShader(GL_FRAGMENT_SHADER);// 片元着色器 char *vs, *fs; // 读取 shader 文件 vs = textFileRead(“toon.vert”); fs = textFileRead(“toon.frag”); const char *vv = vs; const char *ff = fs; glShaderSource(v, 1, &amp;vv, NULL); glShaderSource(f, 1, &amp;ff, NULL); free(vs); free(fs); // 释放 glCompileShader(v); glCompileShader(f); p = glCreateProgram(); glAttachShader(p, v); glAttachShader(p, f); glLinkProgram(p); // 连接 glUseProgram(p); // 使用 } GLUT 版的完整例子(包含了 shader 代码及文本文件读入程序)如下：http://lighthouse3d.com/wptest/wp-content/uploads/2011/03/glutglsl_2.0.zip 4、错误处理调试 shader 是很困难的。目前还没有像 printf 这样的东西，虽然未来可能出现有调试功能的开发工具。 编译阶段的状态可以用如下函数获得： /** @param object – the handler to the object. Either a shader or a program @param type - GL_COMPILE_STATUS @param param - the return value, GL_TRUE if OK, GL_FALSE otherwise */ void glGetShaderiv(GLuint object, GLenum type, int *param); 连接阶段的状态可以用如下函数获得： /** @param object – the handler to the object. Either a shader or a program @param type - GL_LINK_STATUS @param param - the return value, GL_TRUE if OK, GL_FALSE otherwise. */ void glGetProgramiv(GLuint object, GLenum type, int *param); 如果发生错误，就需要从 InfoLog 中找到更多的信息。这个日志保存了最后一次操作的信息，比如编译时的警告、错误，连接时发生的各种问题。这个日志甚至可以告诉你硬件是否支持你的 shader。不幸的是 InfoLog 没有一个规范，所以不同的驱动/硬件可能产生不同的日志信息。 为了获得特定 shader 或程序的日志，可以使用如下程序： /** @param object - the handler to the object. Either a shader or a program @param maxLen - The maximum number of chars to retrieve from the InfoLog @param len - returns the actual length of the retrieved InfoLog @param log - The log itself */ void glGetShaderInfoLog(GLuint object, int maxLen, int *len, char *log); void glGetProgramInfoLog(GLuint object, int maxLen, int *len, char *log); GLSL 规范有必要在这里进行一些改进：你必须知道接收 InfoLog 的长度。为了找到这个准确的值，使用下面的函数： /** @param object - the handler to the object. Either a shader or a program @param type - GL_INFO_LOG_LENGTH @param param - the return value, the length of the InfoLog */ void glGetShaderiv(GLuint object, GLenum type, int *param); void glGetProgramiv(GLuint object, GLenum type, int *param); 下面的函数可以用来打印 InfoLog 的内容： void printShaderInfoLog(GLuint obj) { char *infoLog; int infologLength = 0; int charsWritten = 0; glGetShaderiv(obj, GL_INFO_LOG_LENGTH, &amp;infologLength); if (infologLength &gt; 0) { infoLog = (char *)malloc(infologLength); glGetShaderInfoLog(obj, infologLength, &amp;charsWritten, infoLog); printf(“%sn”,infoLog); free(infoLog); // 释放 } } void printProgramInfoLog(GLuint obj) { int infologLength = 0; int charsWritten = 0; char *infoLog; glGetProgramiv(obj, GL_INFO_LOG_LENGTH, &amp;infologLength); if (infologLength &gt; 0) { infoLog = (char *)malloc(infologLength); glGetProgramInfoLog(obj, infologLength, &amp;charsWritten, infoLog); printf(“%sn”, infoLog); free(infoLog); // 释放 } } 5、清理前面的小节讲到了附加一个 shader 到一个程序中，这里的调用是将 shader 从程序中分离： /** @param program - The program to detach from @param shader - The shader to detach */ void glDetachShader(GLuint program, GLuint shader); 注意：只有没有附加到任何程序的 shader 可以被删除，删除 shader 和程序的调用如下： /** @param id - The hanuler of the shader or program to delete */ void glDeleteShader(GLuint id); void glDeleteProgram(GLuint id); 如果一个 shader 还附加在某个程序中，这个 shader 并不能真正删除，只能标记为删除。当这个 shader 从所有程序中分离之后，才会被最终删除。","tags":[]},{"title":" 一、图形流水线\t\t","date":"2017-10-27T03:03:43.000Z","path":"2017/10/27/e4-b8-80-e3-80-81-e5-9b-be-e5-bd-a2-e6-b5-81-e6-b0-b4-e7-ba-bf/","text":"原文链接：http://www.cnblogs.com/mazhenyu/p/5580910.html 一、流水线概述下图描述了一个简化的图形处理流水线，虽然简略但仍然可以展示着色器编程（shader programming）的一些重要概念。 一个固定流水线包括如下功能： 1、顶点变换（Vertex Transformation）这里一个顶点是一个信息集合，包括空间中的位置、顶点的颜色、法线、纹理坐标等。 这一阶段的输入是独立的顶点信息，固定功能流水线在这一阶段通常进行如下工作：· 顶点位置变换· 为每个顶点计算光照· 纹理坐标的生成与变换 2、图元组合和光栅化（Primitive Assembly and Rasterization）此阶段的输入是变换后的顶点和连接信息(connectivity information)。连接信息告诉流水线顶点如何组成图元(三角形、四边形等)。 此阶段还负责视景体(view frustum)裁剪和背面剔除。 光栅化决定了片断(fragment)以及图元的像素位置。这里的片断是指一块数据，用来更新帧缓存(frame buffer)中特定位置的一个像素。一个片断除了包含颜色，还有法线和纹理坐标等属性，这些信息用来计算新的像素颜色值。 本阶段的输出包括：· 帧缓存中片断的位置· 在顶点变换阶段计算出的信息对每个片断的插值 这 个阶段利用在顶点变换阶段算出的数据，结合连接信息计算出片断的数据。例如，每个顶点包含一个变换后的位置，当它们组成图元时，就可以用来计算图元的片断 位置。另一个例子是使用颜色，如果多边形的每个顶点都有自己的颜色值，那么多边形内部片断的颜色值就是各个顶点颜色插值得到的。 3、片断纹理化和色彩化（Fragment Texturing and Coloring）此阶段的输入是经过插值的片断信息。在前一阶段已经通过插值计算了纹理坐标和一个颜色值，这个颜色在本阶段可以用来和纹理元素进行组合。 此外，这一阶段还可以进行雾化处理。通常最后的输出是片断的颜色值以及深度信息。 4、光栅操作（Raster Operations）此阶段的输入：· 像素位置· 片断深度和颜色值 在这个阶段对片断进行一系列的测试，包括：· 剪切测试(scissor test)· Alpha测试· 模版测试 · 深度测试 如果测试成功，则根据当前的混合模式(blend mode)用片断信息来更新像素值。注意混合只能在此阶段进行，因为片断纹理化和颜色化阶段不能访问帧缓存。帧缓存只能在此阶段访问。 5、一幅图总结固定功能流水线（Visual Summary of the Fixed Functionality）下图直观地总结了上述流水线的各个阶段： 6、取代固定的功能（Replacing Fixed Functionality）现在的显卡允许程序员自己编程实现上述流水线中的两个阶段：· 顶点 shader 实现顶点变换阶段的功能· 片断 shader 替代片断纹理化和色彩化的功能 7、顶点处理器顶点处理器用来运行顶点 shader(着色程序)。顶点 shader 的输入是顶点数据，即位置、颜色、法线等。 下面的 OpenGL 程序发送数据到顶点处理器，每个顶点中包含一个颜色信息和一个位置信息。glBegin(…);glColor3f(0.2, 0.4, 0.6);glVertex3f(-1.0, 1.0, 2.0);glColor3f(0.2, 0.4, 0.8);glVertex3f(1.0, -1.0, 2.0);glEnd(); 一个顶点 shader 可以编写代码实现如下功能：· 使用模型视图矩阵以及投影矩阵进行顶点变换· 法线变换及归一化· 纹理坐标生成和变换· 逐顶点或逐像素光照计算· 颜色计算 不一定要完成上面的所有操作，例如你的程序可能不使用光照。但一旦你使用了顶点 shader，顶点处理器的所有固定功能都将被替换。所以你不能只编写法线变换的 shader 而指望固定功能帮你完成纹理坐标生成。 从上一节已经知道，顶点处理器并不知道连接信息，因此这里不能执行拓扑信息有关的操作。比如顶点处理器不能进行背面剔除，它只是操作顶点而不是面。 顶点 shader 至少需要一个变量：gl_Position，通常要用模型视图矩阵以及投影矩阵进行变换。顶点处理器可以访问 OpenGL 状态，所以可以用来处理材质和光照。最新的设备还可以访问纹理。 8、片断处理器片断处理器可以运行片断 shader，这个单元可以进行如下操作：· 逐像素计算颜色和纹理坐标· 应用纹理· 雾化计算· 如果需要逐像素光照，可以用来计算法线 片断处理器的输入是顶点坐标、颜色、法线等计算插值得到的结果。在顶点 shader 中对每个顶点的属性值进行了计算，现在将对图元中的每个片断进行处理，因此需要插值的结果。 如同顶点处理器一样，当你编写片断 shader 后，所有固定功能将被取代，所以不能使用片断 shader对片断材质化，同时用固定功能进行雾化。程序员必须编写程序实现需要的所有效果。 片断处理器只对每个片断独立进行操作，并不知道相邻片断的内容。类似顶点 shader，我们必须访问OpenGL 状态，才可能知道应用程序中设置的雾颜色等内容。 一个片断shader有两种输出：· 抛弃片断内容，什么也不输出· 计算片断的最终颜色 gl_FragColor，当要渲染到多个目标时计算 gl_FragData。 还可以写入深度信息，但上一阶段已经算过了，所以没有必要。 需要强调的是片断 shader 不能访问帧缓存，所以混合(blend) 这样的操作只能发生在这之后。","tags":[]},{"title":" 入门 - 绘制图片到屏幕\t\t","date":"2017-10-27T02:17:41.000Z","path":"2017/10/27/e5-85-a5-e9-97-a8-e7-bb-98-e5-88-b6-e5-9b-be-e7-89-87-e5-88-b0-e5-b1-8f-e5-b9-95-trashed/","text":"","tags":[]},{"title":" 顶点缓存对象(VBO)\t\t","date":"2017-09-03T09:31:04.000Z","path":"2017/09/03/e9-a1-b6-e7-82-b9-e7-bc-93-e5-ad-98-e5-af-b9-e8-b1-a1vbo/","text":"一、顶点缓存对象(VBO)介绍GL_ARB_vertex_buffer_object 一般简称为 VBO，该扩展致力于提供顶点数组与显示列表的优势来提升OpenGL效率，同时避免它们实现上的不足。它可以根据实际情况决定把顶点数据放到显存、AGP内存或系统内存中，且提供高效数据传输。如果缓存对象用于保存像素数据，就被称为像素缓存对象(PBO)。 没有这个扩展的时候，编程人员用顶点数组时，用 glVertexPointer/glNormalPointer 来指定顶点数据，这时顶点数据是放在系统内存中的，每次渲染时，都要把数据从系统内存拷贝到显存，消耗不少时间。 实际上很多拷贝都是不必要的，比如静态对象的顶点数据是不变的，如果能把它们放到显存里面，那么每次渲染时都不需要拷贝操作，可以节约不少时间。 另外现在的显卡大多数是 AGP的，系统会在系统内存中开辟一块区域作为 AGP内存，显卡可以通过 DMA来直接访问 AGP内存，把数据传到显卡，速度很快，并且在传数据时不需要 CPU干涉，显卡可以和 CPU并行运算。我们可以把一些动态对象的顶点数据放在 AGP内存中，更新对象顶点数据后能利用AGP的快速传输能力，把数据传到显卡，这样比从系统内存传到显存要快。 GL_ARB_vertex_buffer_object的使用很简单，和纹理的用法有点相近。驱动程序会以 usage为参考，根据多种条件决定(“target” 与 “Usage” 模式)是把数据放在最合适内存位置(显存、AGP 内存、系统内存)。比如如果还有足够的空余显存，usage指定为 GL_STATIC_DRAW_ARB时，数据会被放在显存中，而如果空间不够，就会被放到 AGP或系统内存中，因此，内存管理能够通过在系统、AGP 与显卡内存三种内存之间做出平衡的方式优化缓存。我们要修改一个 buffer object的数据有两种办法：1、通过 glBufferDataARB/glBufferSubDataARB 函数指定数据；2、通过 glMapBufferARB 获得修改数据的指针，通过指针修改数据，修改完成后通过 glUnmapBufferARB来提交数据。 使用顶点数组可以降低函数调用次数与降低共享顶点的重复使用。然而，顶点数组的不足之处是顶点数组函数处在客户端状态中，且每次引用都须向服务端重新发送数据。此外，显示列表为服务端函数，因此，它并不受限于数据传输的开销。不过，一旦显示列表编译完成，显示列表中的数据不能够修改。 顶点缓存对象(VBO)在服务器端高性能内存中为顶点属性创建”缓存对象”，并且提供引用这些数组的访问函数，这些函数与顶点数组中使用的函数相同，如 glVertexPointer()、glNormalPointer()、glTexCoordPointer()等。 与显示列表不同，可以通过映射缓存到客户端内存空间的方式读取与更新顶点缓存对象中的数据。 VBO的另一个重要优势是就像显示列表与纹理那样可以在多个客户端共享缓存数据。因为 VBO处在服务器端，多个客户端可以通过相应的标示符访问同一个缓存。 只要机器支持 VBO，就尽量使用它，因为就算使用 VBO 在有些情况下(比如显存、AGP 内存空间不够时，数据放在系统内存中)速度不会提升，也不会比原来的 vertex array 慢。而一旦数据放在显存、AGP 内存中，性能将会得到很大的提升。在填充率不是瓶颈时，使用 VBO 比不使用 VBO 的帧数要快一倍。 二、创建 VBO创建 VBO需要 3 个步骤：1、使用 glGenBuffers() 生成新缓存对象；2、使用 glBindBuffer() 绑定缓存对象；3、使用 glBufferData() 将顶点数据拷贝到缓存对象中。 三、glGenBuffers()/ @brief 创建缓存对象并且返回缓存对象的标示符 ID @param n 需要创建的缓存数量 @param buffers 用于存储单一 ID 或多个 ID 的 GLuint 变量或数组的地址 /void glGenBuffers(GLsizei n, GLuint buffers) 四、glBindBuffer()/ @brief 当缓存对象创建之后，使用之前，将缓存对象连接到相应的缓存上 @param target 告诉 VBO 该缓存对象将保存顶点数组数据还是索引数组数据：GL_ARRAY_BUFFER 或GL_ELEMENT_ARRAY。任何顶点属性，如顶点坐标、纹理坐标、法线与颜色分量数组都使用 GL_ARRAY_BUFFER。用于glDraw[Range]Elements()的索引数据需要使用GL_ELEMENT_ARRAY绑定。注意，target 标志帮助 VBO 确定缓存对象最有效的位置，如有些系统将索引保存 AGP 或系统内存中，将顶点保存在显卡内存中。 @param buffer 缓存对象标示符 ID /void glBindBuffer(GLenum target, GLuint buffer) 当第一次调用 glBindBuffer()时 VBO 用 0大小的内存缓存初始化该缓存，并且设置 VBO 的初始状态，如用途与访问属性。 五、glBufferData()/** @brief 当缓存初始化之后，使用 glBufferData() 将数据拷贝到缓存对象 @param target GL_ARRAY_BUFFER 或 GL_ELEMENT_ARRAY @param size 待传递数据字节数量 @param data 源数据数组指针，如 data 为 NULL，则 VBO 仅仅预留给定数据大小的内存空间 * @param usage VBO 的另一个性能提示，它提供缓存对象将如何使用：static、dynamic 或 stream、与 read、copy 或 draw。VBO 为 usage 标志指定 9 个枚举值：glBindBufferARBglDeleteBuffersARBglGenBuffersARBglIsBufferARBglBufferDataARBglBufferSubDataARBglGetBufferSubDataARB GL_STREAM_DRAW_ARBGL_STREAM_READ_ARBGL_STREAM_COPY_ARBGL_STATIC_DRAW_ARBGL_STATIC_READ_ARBGL_STATIC_COPY_ARBGL_DYNAMIC_DRAW_ARBGL_DYNAMIC_READ_ARBGL_DYNAMIC_COPY_ARB 其中： STREAM 表示只赋一次值，只用一次或很少的几次，每帧数据都要改变。这种数据很可能放在系统内存中； STATIC 表示只赋一次值，可以重复使用很多次，数据将不会被改动。这种数据很可能放在显存中； DYNAMIC 表示多次赋值，重复使用，数据将会被频繁改动。这种数据很可能放在 AGP内存中； DRAW 表示赋给 buffer object 的数据来自用户程序，buffer object 作为绘制函数的数据源。数据将被发送到 GPU以待绘制(应用程序到 GL)； COPY 表示赋给 buffer object 的数据来自 OpenGL，buffer object 作为绘制函数的数据源。数据将被客户端程序读取(GL 到应用程序)； READ 表示赋给 buffer object 的数据来自 OpenGL，buffer object 作为用户程序的数据源。数据可用于绘制与读取(GL 到 GL)。 注意：仅仅 draw 标志对 VBO 有用，copy 与 read 标志对顶点/帧缓存对象(PBO 或 FBO)更有意义，如GL_STATIC_DRAW 与 GL_STREAM_DRAW 使用显卡内存，GL_DYNAMIC 使用 AGP 内存。_READ_ 相关缓存更适合在系统内存或 AGP内存，因为这样数据更易访问。 /void glBufferData(GLenum target, GLsizeiptr size, const GLvoid data, GLenum usage); 六、glBufferSubData()/ @brief 与 glBufferData() 类似，glBufferSubData() 用于向 VBO 中拷贝数据，不过它仅仅将从给定 offset开始的一定范围的数据替换到现存缓存中。(在使用 glBufferSubData() 之前，整个缓存必须由 glBufferData() 指定) /void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data); 七、glDeleteBuffers()/ @brief 在 VBO 不再使用时，你可以使用 glDeleteBuffers() 删除一个 VBO 或多个 VBO。在混存对象删除之后，它的内容将丢失。 /void glDrawBuffers(GLsizei n, const GLenum bufs); 八、实例下列代码是为顶点坐标创建单一 VBO 的实例。注意，在拷贝数据到 VBO 之后，可以应用程序中为顶点数组分配的内存。 GLuint vboId; // VBO IDGLfloat vertices = new GLfloat[vCount*3]; // 创建顶点数组… // 创建新的 VBO 并获取相关标示符glGenBuffers(1, &amp;vboId);// 绑定 VBO 以待使用glBindBuffer(GL_ARRAY_BUFFER_ARB, vboId);// 更新数据到 VBOglBufferData(GL_ARRAY_BUFFER_ARB, dataSize, vertices, GL_STATIC_DRAW_ARB);// 在拷贝数据到 VBO 之后，可以安全删除delete [] vertices; … glDeleteBuffers(1, &amp;vboId); // 程序终止时删除 VBO 九、绘制 VBO由于 VBO 基于现有的顶点数组实现之上，渲染 VBO 与使用顶点数组渲染几乎一致。仅有的不同是顶点数组指针现在作为当前绑定缓存对象的偏移值。因此，绘制 VBO 时除了 glBindBuffer() 之外不需别的 api。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 为顶点数组与索引数组绑定 VBO glBindBuffer(GL_ARRAY_BUFFER_ARB, vboId1); // 顶点坐标 glBindBuffer(GL_ELEMENT_ARRAY_BUFFER_ARB, vboId2); // 索引坐标 // 除了指针都与顶点数组一致 glEnableClientState(GL_VERTEX_ARRAY); // 开启顶点坐标数组 glVertexPointer(3, GL_FLOAT, 0, 0); // 最后一个参数为 offset，而非 ptr // 使用索引数组偏移绘制 6 个四边形 glDrawElements(GL_QUADS, 24, GL_UNSIGNED_BYTE, 0); glDisableClientState(GL_VERTEX_ARRAY); // 禁用顶点数组 // 用 0 绑定，因此，切换到标准指针操作 glBindBuffer(GL_ARRAY_BUFFER_ARB, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER_ARB, 0); 使用 0 绑定缓存对象将关闭 VBO 操作。在使用完 VBO 之后，最好将之关闭，因此具有绝对指针的顶点数组操作将重新开启。 十、更新 VBO VBO 相对于显示列表的优势在于客户端可以读取与编辑缓存对象数据，而显示列表不能这样做。更新 VBO的最简便方法是使用 glBufferData() 或 glBufferSubData() 将新数据重新拷贝到绑定的 VBO 中。这种情况下，你的应用程序需要始终拥有一个有效的顶点数组。也就是说，你必须始终拥有 2 份顶点数据：一份在应用程序中，另一份在 VBO 中。 修改缓存对象的另一个方式是将缓存对象映射到客户端内存，客户端可以使用映射缓存的指针更新数据。下文描述如何将 VBO 映射到客户端内存以及如何访问映射数据。 十一、glMapBuffer()/ @brief VBO 提供 glMapBuffer() 以将缓存对象绑定到客户端内存。 @param target 见 glBindBuffer() @param access 指定怎样使用映射数据：读取、改写或读写。GL_READ_ONLYGL_WRITE_ONLYGL_READ_WRITE /void glMapBuffer(GLenum target, GLenum access); 如果 OpenGL 能够将缓存对象映射到客户端地址空间，glMapBuffer() 返回指向缓存的指针。否则它返回NULL。 注意：glMapBuffer() 引起同步问题。如果 GPU 仍然工作于该缓存对象，glMapBuffer() 将一直等待直到 GPU 结束对应缓存对象上的工作。 为了避免等待，你可以首先使用 NULL 调用 glBufferData()，然后再调用 glMapBuffer()。这样，前一个数据将被丢弃且 glMapBuffer() 立即返回一个新分配的指针，即使 GPU 仍然工作于前一个数据。 然而，由于你丢弃了前一个数据，这种方法只有在你想更新整个数据集的时候才有效。如果你仅仅希望更改部分数据或读取数据，你最好不要释放先前的数据。 十一、glUnmapBuffer()/ @brief 在完成 VBO 数据的修改之后，必须将缓存对象从客户端内存解除映射。如果成功，glUnmapBuffer() 返回GL_TRUE。如返回 GL_FALSE，绑定之后的 VBO 缓存内容是坏的。腐坏现象源自显示器分辨率的改变或窗口系统的特定事件。此种情况，数据必须重发。 /GLboolean glUnmapBuffer(GLenum target) 下面是使用绑定方式改变 VBO 的实例代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 绑定然后映射该 VBO glBindBuffer(GL_ARRAY_BUFFER_ARB, vboId); float ptr = (float)glMapBuffer(GL_ARRAY_BUFFER_ARB, GL_WRITE_ONLY_ARB); // 如果指针为空（映射后的），更新 VBO if (ptr) { updateMyVBO(ptr, ...); // 修改缓存数据 glUnmapBufferARB(GL\\_ARRAY\\_BUFFER_ARB); // 使用之后解除映射 } // 你可以绘制更新后的 VBO … 参考文章：http://www.cnblogs.com/hefee/p/3824300.html","tags":[]},{"title":" TinyMCE 编辑器自定义\t\t","date":"2017-09-01T09:23:31.000Z","path":"2017/09/01/tinymce-e7-bc-96-e8-be-91-e5-99-a8-e8-87-aa-e5-ae-9a-e4-b9-89/","text":"一、添加字体选项框 WordPress 自带的 TinyMCE 编辑器没有字体选项框 找到当前主题的 functions.php 文件 将以下代码添加到文件中： function select_my_fontfamily($initArray) { $initArray[‘font_formats’] = “宋体=’宋体’;仿宋=’仿宋’;楷体简=’KaiTi SC’;”; return $initArray; }add_filter(‘tiny_mce_before_init’, ‘select_my_fontfamily’); function show_more_buttons($buttons) { $buttons[] = ‘styleselect’;$buttons[] = ‘fontselect’; return $buttons; }add_filter(“mce_buttons”, “show_more_buttons”); 结果如图： my_fontfamily 方法目的是选择字体，可以按照上面的结构(显示名=’字体font-family’;)自行选择，定义之后原先默认的字体就没有了。 show_more_buttons方法目的是显示字体选择框，默认是不显示的。 网站报错 500，php 文件报错：syntax error, unexpected T_RETURN错误原因：文本中有中文字符，包括空格、小括号、大括号等。 二、添加字体大小及其他按钮 与添加字体框一样，在 show_more_buttons 方法中添加如下代码： $buttons[] = ‘fontsizeselect’;$buttons[] = ‘backcolor’;$buttons[] = ‘underline’; 结果如图： 可用的按钮： 加粗 bold 斜体 italic 下划线 underline删除线 strikethrough 左对齐 justifyleft 居中 justifycenter右对齐 justfyright 两端对齐 justfyfull 无序列表 bullist编号列表 numlist 减少缩进 outdent 缩进 indent剪切 cut 复制 copy 粘贴 paste撤销 undo 重做 redo 插入超链接 link取消超链接 unlink 插入图片 image 清除格式 removeformat帮助 wp_help 打开HTML代码编辑器 code 水平线 hr清除冗余代码 cleanup 格式选择 formmatselect 字体选择 fontselect字号选择 fontsizeselect 样式选择 styleselect 上标 sub下标 sup 字体颜色 forecolor 字体背景色 backcolor特殊符号 charmap 隐藏按钮显示开关 wp_adv 隐藏按钮区起始部分 wp_adv_start隐藏按钮区结束部分 wp_adv_end 锚文本 anchor 新建文本 newdocument插入more标签 wp_more 插入分页标签 wp_page 拼写检查 spellchecker 三、更改编辑器默认视图为”文本” 进行写、编辑文章时，编辑器会自动跳转到”可视化”视图。 对于一些 web 设计者或者经常要插入代码的人来说，可能更习惯使用”文本”视图编辑。要修改这个设定，只需要在当前主题的 functions.php 文件中添加以下代码： add_filter(‘wp_default_editor’, create_function(‘’, ‘return “html”;’)); 四、添加编辑器内可见的默认内容 写新的文章时，编辑器里的内容默认是空的。如果需要自动添加”文章名”、”作者”、”下载地址”等默认内容，需要在当前主题的 functions.php 文件中添加以下代码，而且这些预定义的内容，是可以手动删除的。 function addDefaultMsg($content) {if(!is_feed() &amp;&amp; !is_home()) {$content.= “这里的预定义的文章名、作者等默认内容”;}return $content;}add_filter (‘default_content’, ‘addDefaultMsg’); 五、添加编辑器内文末不可见的默认内容 这里添加的内容在编辑的时候是看不见的，发布后自动添加在内容的最后，用于添加订阅、文章版权信息等等。需要在当前主题的 functions.php文件添加以下代码： function addFootMsg($content) {if(!is_feed() &amp;&amp; !is_home()) {$content.= “这里的预定义内容在编辑器不可见”;}return $content;}add_filter (‘the_content’, ‘addFootMsg’); 六、添加更多的 HTML 标签 因为 WordPress自带的TinyMCE编辑器会默认过滤掉不符合高版本 HTML中的html标签，所以请慎用。需要在当前主题的 functions.php 文件中添加以下代码： function addMoreHTMLTags($initArray) { $ext = ‘pre[id|name|class|style],iframe[align|longdesc| name|width|height|frameborder|scrolling|marginheight| marginwidth|src]‘; if ( isset( $initArray[‘extended_valid_elements’] ) ) {$initArray[‘extended_valid_elements’] .= ‘,’ . $ext;}else {$initArray[‘extended_valid_elements’] = $ext;}return $initArray;}add_filter(‘tiny_mce_before_init’, ‘addMoreHTMLTags’); 格式为”标签1[属性1|…],标签2[属性1|属性2|…]“ 七、WordPress 显示换行、回车问题 在 WordPress 网站后台编辑文章时，默认状态下，文章编辑器里的换行效果是不被解析的。经常有用户写文章时想分段空一个空白行出来，但保存后没有显示空白行。 解决方法 1： 在编辑文章时，把文章编辑器切换到 “文本” 模版，在需要空行的地方输入：为 HTML 换行代码，加入这个代码后再发布就会显示一个空白行了。 该方法的最大的优点就是不需要对程序做任何修改，直接就能使用。但缺点就是你每次都要在 “可视化” 和 “文本” 模式下切换输入并接着发布，你一旦转入“ “可视化编辑器” 下编辑并发布以后，那么你以前做的工作就白费了，还得从头再来。 解决方法 2： 安装 TinyMCE Advanced 插件 TinyMCE Advanced 是一款用来增强和自定义 WordPress 默认编辑器 TinyMCE 的插件。 把 TinyMCE Advanced 插件安装启用后，在插件的设置页面下方，找到 stop removing the p and br tags when saving and show them in the HTML editor(不过滤文章中的 p 和 br 标签)这个选项，打上勾即可。 TinyMCE Advanced 插件下载地址：http://wordpress.org/plugins/tinymce-advanced/ v4.6.3 本地下载： tinymce-advanced.4.6.3 参考文章：https://www.wpdaxue.com/tinymce-custom-methods.html更多信息请查看：https://codex.wordpress.org/","tags":[]},{"title":" Tree 命令\t\t","date":"2017-09-01T07:45:28.000Z","path":"2017/09/01/tree-e5-91-bd-e4-bb-a4/","text":"tree 命令可以像 windows 的文件管理器一样清楚明了的显示目录结构。mac 下默认是没有 tree 命令的。 1、使用 find 命令模拟出 tree 命令的效果，如显示当前目录的 tree 的命令： $ find . -print | sed -e ‘s;[^/]*/;|;g;s;|; |;g’ 2、可以写一个别名来快速执行该命令，运行如下命令，将上面这个命令写到 ~/.bash_profile 里，以后直接运行 tree 命令就更方便了: $ alias tree=”find . -print | sed -e ‘s;[^/]*/;|;g;s;|; |;g’” 3、使用 homebrew 安装 tree 命令行： $ brew install tree $ tree -a 显示所有文件和目录 $ tree -d 显示目录名称而非内容 $ tree -L 2 后面的数字 2 代表几层 截图中 “1”目录下实际上创建了超过 2 层的目录。 tree 命令行参数： 命令 作用 -a 显示所有文件和目录 -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合 -C 在文件和目录清单加上色彩，便于区分各种类型 -d 显示目录名称而非内容 -D 列出文件或目录的更改时间 -f 在每个文件或目录之前，显示完整的相对路径名称 -F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号 -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码 -i 不以阶梯状列出文件或目录名称 -I 不显示符合范本样式的文件或目录名称 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录 -n 不在文件和目录清单加上色彩 -N 直接列出文件和目录名称，包括控制字符 -p 列出权限标示 -P 只显示符合范本样式的文件或目录名称 -q 用”?”号取代控制字符，列出文件和目录名称 -s 列出文件或目录大小 -t 用文件和目录的更改时间排序 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外","tags":[]},{"title":" cloc 代码统计\t\t","date":"2017-09-01T07:37:46.000Z","path":"2017/09/01/cloc-e4-bb-a3-e7-a0-81-e7-bb-9f-e8-ae-a1/","text":"参考文章：https://www.cnblogs.com/abc-begin/p/8136665.html Cloc 是一款使用 Perl 语言开发的开源代码统计工具，支持多平台使用、多语言识别，能够计算指定目标文件或文件夹中的文件数(files)、空白行数(blank)、注释行数(comment)和代码行数(code)。 Cloc 具备很多特性以致于让它更方便于使用、完善、拓展和便携。 1、作为一个单一的独立形式存在的文件，Cloc 只需要下载相应文件并运行这样最少的安装工作即可。 2、能够从源码文件中识别编程语言注释定义； 3、允许通过语言和项目来分开统计计算； 4、能够以纯文本、SQL、XML、YAML、逗号分隔等多样化的格式生成统计结果； 5、能够统计诸如 tar、Zip 等格式的压缩文件中的代码数； 6、有许多排除式的指令； 7、能够使用空格或者不常用的字符处理文件名和目录名； 8、不需要依赖外部标准的 Perl 语言配置； 9、支持多平台使用。 1、安装 homebrew(OS X 系统默认安装了) ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 过程中需要按 return 键以及输入 mac 桌面密码，按照提示进行操作即可。 2、安装 cloc MAC 下安装命令 $ brew install cloc 其他的 Linux 安装 $ aptitude install cloc 3、统计当前目录代码行数 $ cloc ./ 4、排除当前目录下的某个文件夹的代码 比较常见的是排除 Pods 中的代码，因为 Pods 中一般为第三方库 $ cloc ./ –exclude-dir=Pods 5、查看 cloc 的使用文档 $ cloc –help 6、排除更多的文件夹 $ cloc ./ –exclude-dir=Pods,MyTest 7、其他 官网地址：http://cloc.sourceforge.net/ github 地址：https://github.com/AlDanial/cloc","tags":[]},{"title":" Github\t\t","date":"2017-09-01T07:21:04.000Z","path":"2017/09/01/github/","text":"一、注册 github 账号、创建个人的 github 仓库(略过) 二、配置 SSH Keys ①、终端输入命令使隐藏文件可见： defaults write com.apple.finder AppleShowAllFiles -bool true ②、重启 finder：左上角苹果图标 -> 强制退出 -> finder -&gt; 重新开启 ③、前往个人文件查看是否有 .ssh 文件夹：前往 -> 个人。如果有，建议删除后重新配置 ④、创建一个 .ssh 文件夹：mkdir .ssh ⑤、进入刚创建的 .ssh 文件夹：cd .ssh 。输入命令：ssh-Keygen -t rsa -C “注册时的邮箱 YourEmail” ⑥、输入完成后一直按回车，中间会提示要输入密码也不用管，直到如下图： ⑦、输入命令：ls -la 。出现如下信息则说明配置成功： ⑧、输入命令：pbcopy &lt; ~/.ssh/id_rsa.pub 复制到剪切板 ⑨、登录 github 进入 SSH Keys：Settings -&gt; SSH and GPG keys -&gt; New SSH key 。标题随意填写，key 粘贴刚才复制的内容，添加后如下： ⑩、终端输入命令：ssh -T git@github.com . 终端显示 Are you sure you want to continue connecting (yes/no)? 输入 yes 回车，返回 github 页面，如下所示代表成功： 三、上传代码到 github ①、下载 github 客户端并登录账号 ②、clone 刚创建的仓库到本地 ③、打开刚 clone 到本地的文件夹，将需要上传的内容放到文件夹内 ④、回到 github 客户端，选中 clone下来的仓库，可以看见新增了文件且需要提交，填写好 “summary”、”description”，然后点击 commit to master，然后点击右上角按钮 ⑤、在github 网站查看是否提交成功","tags":[]},{"title":" CocoaPods 共有库\t\t","date":"2017-09-01T06:51:32.000Z","path":"2017/09/01/cocoapods-e5-85-b1-e6-9c-89-e5-ba-93/","text":"1、在 github 上创建一个项目 2、通过 github 客户端 clone 到本地。 3、 将一个本地项目放入本地仓库。需要共享的库所在的目录为 Chart-Chart-Chart-Chart，包含两个文件 MyObj.h MyObj.m。 4、推送到远程仓库。 5、打上 tag。 git tag x.x git push origin x.x 6、注册与验证 pod trunk register 1070963935@qq.com “Qmzy” pod trunk me 注册完成后，该邮箱会收到一封邮件，也可以打开发送到邮箱的链接验证是否成功。 删除账号： 显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder 不显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder 显示隐藏文件后，在用户目录下找到 /Users/galahad/.rvm ，直接将隐藏文件 .rvm 删除 7、生成 spec文件 先进入项目目录。链接为 github 上的项目地址。 8、编辑 spec文件。最好使用 Xcode 打开。 字段 描述 s.name pod search 搜索的关键词。注意这里一定要和 .podspec 的名称一样，否则报错 s.version 共享库的版本号 s.ios.deployment_target 支持的 pod 最低版本 s.summary 摘要 - 简单说明共享库的作用。必填，不然会报错 error s.homepage 项目主页地址 s.license 许可证。根据在 github 上创建项目时设置的 { :type =&gt; “MIT”, :file =&gt; “LICENSE” } s.author 作者 s.social_media_url 社交网址 s.source 项目的地址。#{s.version} 根据前面设置的版本号来控制共享库的版本号 s.source 常见写法s.source = { :git =&gt; “项目地址.git”, :commit =&gt; “68defea” }s.source = { :git =&gt; “项目地址.git”, :tag =&gt; 1.0.0 }s.source = { :git =&gt; “项目地址.git”, :tag =&gt; s.version } commit =&gt; “68defea” 将这个 Pod 版本与 git 仓库中某个 commit 绑定 tag =&gt; 1.0.0 将这个 Pod 版本与 git 仓库中某个版本的 commit 绑定 tag =&gt; s.version 将这个 Pod 版本与 git 仓库中相同版本的 commit 绑定 s.source_files 需要包含的源文件。”git上的项目名(库名)”, “真正需要共享的库的路径/*.{h.m}” source_files 常见写法：建议第一种或者第二种“xx/“xx/yy/.{h,m}”“xx/*/.h” 匹配所有文件 *.{h,m} 匹配所有以 .h 和 .m 结尾的文件 ** 匹配所有子目录 s.resources 资源文件 s.requires_arc 是否支持 ARC s.dependency 依赖库。不能依赖未发布的库 s.dependency “Masonry”, “~&gt; 0.6.2” 引用静态库：”(.ios).library”。去掉头尾的 lib，用 “,” 分割 。注意：(.ios)括号括起来代表可以省略 例：引用 libxml2.lib 和 libz.lib spec.libraries = ‘xml2’, ‘z’ 引用公有 framework：”(.ios).framework” 用 “,” 分割。去掉尾部的 .framework 例：spec.frameworks = ‘UIKit’, ‘SystemConfiguration’, ‘Accelerate’ 引用自己生成的 framework:”(.ios).vendored_frameworks” 用 “,” 分割。路径为从 .podspec 所在目录为根目录的相对路径。这个不要省略 .framework 例：spec.ios.vendored_frameworks = ‘Pod/Assets/*.framework’ 引用自己生成的 .a 文件，添加到 Pod/Assets 文件夹里 .Demo 的 Example文件夹里也需要添加一下，不然找不到 例：spec.ios.vendored_libraries = ‘Pod/Assets/*.a’ 注意：在提交到私有仓库的时候需要加上 –use-libraries 9、创建 LICENSE(许可证/授权)文件 这个文件必须有，一般在 github 上新建库的时候直接就创建好了。 MIT License Copyright (c) 2017 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 10、验证、上传 pod spec lint pod trunk push 注意：1、不能有警告和错误，否则验证不会通过 2、相同的版本不能重复的发布否则会报错 3、大多数的错误可以通过升级 cocoapod 来解决 4、发布时会验证 Pod 的有效性，如果你在手动验证 Pod 时使用了 --use-libraries 或 --allow-warnings 等修饰符，那么发布的时候也应该使用相同的字段修饰，否则出现如下的报错。 11、验证以上是否操作成功 $ pod search Chart [!] Unable to find a pod with name, author, summary, or description matching ‘Chart’ 2 天过去了，还是没有搜到…… 处理步骤： 1、pod setup 还是失败……(这个命令执行很慢，可以用 pod repo update) 2、由于 pod setup 成功后会生成 ~/Library/Caches/CocoaPods/search_index.json 文件。所以需要终端删除，输入 rm ~/Library/Caches/CocoaPods/search_index.json 3、删除成功后再执行 pod search 成功！ 12、删除公有库 pod trunk –help 查看有哪些命令，因为有 push 操作也应该会有删除操作。 需要指定要 delete/deprecate 的 pod 名称和版本号，不然报错 然后执行 pod setup。","tags":[]},{"title":" 分辨率、码率、帧率\t\t","date":"2017-09-01T03:41:49.000Z","path":"2017/09/01/e5-88-86-e8-be-a8-e7-8e-87-e3-80-81-e7-a0-81-e7-8e-87-e3-80-81-e5-b8-a7-e7-8e-87/","text":"分辨率 显示分辨率（屏幕分辨率）是屏幕图像的精密度，是指显示器所能显示的像素有多少。 由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越精细，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标之一。可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。 显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。 那么落实到视频上，比如说我们平时进场看到的 1080P 的视频，意思就是分辨率为 1920*1080 的视频（主流屏幕长宽比为16:9）。那么理论上来说肯定是分辨率越高，视频的显示效果越清晰，可是实际生活中我们下载的电影视频文件中，1080P 的文件有的是1GB、3GB、4GB，有的要 10GB 大小。他们的清晰程度当然不同。要解释这个现象，就要引入下面要讲的”码率”这一概念。 码率 由于保存完整的一帧一帧图片的视频原文件太大，必须要通过某种视频压缩算法将视频中的图片压缩，以减小视频文件大小。可以想到，压缩比越大，解压缩还原后用来播放的视频就会有越严重的失真，因为压缩的同时不可避免的丢失了视频中原来图像的数据信息。 一个分辨率为 1080P 的原视频（未经压缩）被压缩成分别为 4GB 和 1GB 的两个视频文件。由于 1GB 的视频的压缩比更大，所以在观看 1GB 视频的明显感觉到没有 4GB 视频清晰（虽然他们的分辨率都是 1080P)。 所谓码率，简单来说就是指在压缩视频的时候给这个视频指定一个参数，用以告诉压缩软件期望的压缩后视频的大小。 码率的英文名为 bps(bit per second)，就是用平均每秒多少 bit 来衡量一个视频大小。下面是百度百科的解释： 比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，传送数据速度越快。 声音中的比特率是指将模拟声音信号转换成数字声音信号后，单位时间内的二进制数据量，是间接衡量音频质量的一个指标。 视频中的比特率（码率）原理与声音中的相同，都是指由模拟信号转换为数字信号后，单位时间内的二进制数据量。 比如那个被压缩的 1080P 的视频，假设它的长度为 100 分钟，大小为 1GB。 100m = 100*60s = 6000s 1GB = 1024MB = 1024*1024KB = 1024*1024*1024Byte = 1024*1024*1024*8bit = 8589934592bit 那么这个视频的码率大概就是 1.4Mbit/s(8589934592/6000)，这个比特率在在线视频中已经是非常高的了，一般主流视频平台的最高码率在1Mbit左右，比如直播网站斗鱼的高清选项实际播放的视频码率是900Kbit/s(0.9Mbit)。 帧率 帧率（Frame rate）是用于测量显示帧数的量度。所谓的测量单位为每秒显示帧数(Frames per Second，简称：FPS)或”赫兹”(Hz)。此词多用于影视制作和电子游戏。 由于人类眼睛的特殊生理结构，如果所看画面之帧率高于 16 的时候，就会认为是连贯的，此现象称之为视觉暂留。这也就是为什么电影胶片是一格一格拍摄出来，然后快速播放的。 而对游戏，一般来说，第一人称射击游戏比较注重 FPS 的高低，如果 FPS&lt;30 的话，游戏会显得不连贯。所以有一句有趣的话：”FPS（指 FPS 游戏）重在FPS（指帧率）。 每秒的帧数(fps)或者说帧率表示图形处理器处理场时每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说 30fps就是可以接受的，但是将性能提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps一般就不容易察觉到有明显的流畅度提升了。如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过刷新率的帧率就浪费掉了。 所以说要想得到非常流畅的画面感，帧率当然是越高越好，但是超过60帧每秒估计人类也可能感知不出效果了。 总结 总结一下它们的关系，对于视频来讲，码率应该是最重要的参数，从上面的例子可以看出，码率直接与视频压缩比相关。直观来讲，码率越大代表一个视频的画质也清晰（不考虑各种压缩算法的优劣问题）。这是直观的感觉，当然作为视频技术者来说，对1080P的视频，采取多大的码率压缩比较合理还需要进行更多研究。","tags":[]},{"title":" CocoaPods\t\t","date":"2017-08-31T01:39:13.000Z","path":"2017/08/31/cocoapods/","text":"CocoaPods 是一个用来管理第三方依赖库的工具; CocoaPods 是自动化的、直观的、集中的; CocoaPods 是以 Ruby gem 包的形式被安装的。 一、安装 RVM Ruby Version Manager：Ruby 版本管理器，包括 Ruby 的版本管理和 Gem 库管理(gems) $ rvm -v 检测安装的 RVM 的版本 $ curl -L get.rvm.io | bash -s stable 安装 rvm 二、ruby 镜像 $ ruby -v 查看当前 ruby 版本 $ rvm list known 列出当前 ruby 的所有版本 $ rvm install 2.3.0 选择一个版本下载。除了需要输入密码，其他等待的地方直接回车 $ gem sources –remove https: //rubygems.org/ 移除系统的 ruby 镜像 $ gem sources -a https: //ruby.taobao.org/ 替换成淘宝的 ruby 镜像。PS：淘宝已经不维护了，替换成 https: //gems.ruby-china.org $ gem sources -l 验证 ruby 镜像是否是只有淘宝。显示如下即为成功： CURRENT SOURCES https: //ruby.taobao.org/ 三、gem 包 $ sudo gem install cocoapods 或 $ sudo gem install -n /usr/local/bin cocoapods 下载/升级 cocoapods $ sudo gem uninstall cocoapods 移除所有版本的 cocoapods $ sudo gem update –system 升级 gem 版本 $ rvm use ruby-1.9.3-p448 路径问题 四、cocoapods 的使用 $ pod init 项目中会出现白色的 podfile 文件 $ pod install 导入类库 $ pod update 编译一个已包含 CocoaPods 类库的项目(先进入该项目 Profile 文件所在目录)。如果类库有升级，执行 install 会报错 $ pod –version 查看 pod 版本，也可以作为安装成功的检测 $ pod setup 检验 cocoapods 是否安装成功 问题 1：如果搜索不到第三方库的最新版，可能需要执行此命令 问题 2：执行太慢，界面长时间没反应，需要手动替换 master 文件夹 cd ~/.cocoapods 进到安装 cocoapods 的 repo 目录 open . 在 finder 中显示 cd ~/.cocoapods/repos git clone https: //github.com/CocoaPods/Specs.git 最后将 Specs 改名为 master。不能自己手动修改，需要通过终端修改 mv 命令。 如果自己手动去 github 下载 Specs 文件夹，然后替换的话，如下： 而正确的应该如下： $ pod search AFNetworking 查找指定类库的信息 $ vim Podfile 在当前工程目录下创建 Podfile 文件 platform :ios, ‘7.0’ pod ‘AFNetworking’, ‘~&gt;2.0’ 7.0 表示类库支持的最低 iOS 版本，AFNetworking 表示类库名，2.0 表示类库版本 $ ping github.com $ pod repo list 查看 repos，如果显示 0 repos 说明没有安装成功 $ cd ~/.cocoapods/ $ sudo -rm -rf ~/.cocoapods/ 进入 cocoapods 目录，删除 .cocoapods 目录 五、可能出现问题 1、输入 sudo gem install cocoapods 出现问题： ERROR: While executing gem … (Gem::DependencyError) Unable to resolve dependencies: cocoapods requires cocoapods-core (= 0.33.1), claide (~&gt; 0.6.1), cocoapods-downloader (~&gt; 0.6.1), cocoapods-plugins (~&gt; 0.2.0), cocoapods-try (~&gt; 0.3.0), cocoapods-trunk (~&gt; 0.1.1), nap (~&gt; 0.7) 解决：升级 gem 版本(sudo gem update –system) 2、ERROR: While executing gem … (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj 解决：①、sudo nvram boot-args=”rootless=0”; sudo reboot ②、电脑重启 ③、sudo gem install cocoapods -V 3、-bash: pod: command not found 解决一：sudo gem install -n /usr/local/bin cocoapods 解决二：①、删除所有已安装 cocoapods(sudo gem uninstall cocoapods) ②、下载安装(sudo gem install -n /usr/local/bin cocoapods) ③、修改usr/local/bin/的系统权限(sudo chmod +rx /usr/local/bin) 4、pod install / pod update 卡在Updating local specs repositories 解决：等待或者使用 pod install –verbose –no-repo-update 进行下载(防火墙的原因) 5、[!] No ‘Podfile’ found in the project directory. 解决：’vim Podfile’ 命令写错 (出现过 Podfile 错写成 Profile) 6、[!] Unable to satisfy the following requirements: - ‘SVProgressHUD (~&gt; 1.1.3)’ required by ‘Podfile’ Specs satisfying the ‘SVProgressHUD (~&gt; 1.1.3)’ dependency were found, but they required a higher minimum deployment target. 解决：命令 platform :ios 后面添加版本号，如 platform :ios, ‘7.0’ 7、[!] The ‘master’ repo requires CocoaPods 1.0.0 - (currently using 0.39.0) 解决：cocoapods 版本过低，需要升级。升级 cocoapods 之前要先升级 ruby，升级 ruby 之前要先升级 RVM 8、[!] The dependency ‘Masonry’ is not used in any concrete target. 解决：新版的 cocoapods 的 podfile 文件有一个 target platform:ios, ‘8.0’ target ‘工程名’ do pod ‘项目名’, ‘~&gt; 版本号’ end 9、[!] /usr/bin/git clone https: //github.com/CocoaPods/Specs.git master —progres Cloning into ‘master’… fatal: unable to access https://github.com/CocoaPods/Specs.git/&#39;: SSLRead() return error -9806 解决：执行 sudo gem install -n /usr/local/bin cocoapods 后报错，需要先执行 pod setup 命令 10、build diff: /../Podfile.lock: No such file or directory 解决：在工程设置中的 Build Phases 下删除 Check Pods Manifest.lock 及 Copy Pods Resources 11、[!] Invalid ‘Podfile’ file: syntax error,unexpected end-of-input, expecting keyword_end. 解决：在 Podfile 的末尾添加 end 12、[!] /usr/bin/git clone https://github.com/CocoaPods/Specs.git master Cloning 解决：执行 sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer (-switch 后面加上你的 Xcode.app 包内容里的 Developer 的文件夹路径即可) 13、Unable to find a pod with name, author, summary, or descriptionmatching 解决：请在终端执行”rm ~/Library/Caches/CocoaPods/search_index.json”命令，然后再”pod search xx” 14、fatal: unable to access ‘https://github.com/xxx.git/&#39;: OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 解决：env 命令设置 GIT_SSL_NO_VERIFY 环境变量为 “ture”，并同时调用正常的 git clone 命令 env GIT_SSL_NO_VERIFY=true git clone https://xxx.git 六、删除项目中已经配置的类库 打开 Podfile 文件，删除该类所在行； cd 到当前项目目录下，执行 pod install 命令； 打开 xcworkspace 文件，检查类库是否已移除。 七、项目中移除 CocoaPods 删除工程文件夹下的 Podfile、Podfile.lock 和 Pods 文件夹; 删除 xcworkspace 文件; 打开 xcodeproj 文件，删除项目中的 libpods.a 和 Pods.xcconfig 使用; 打开 Build Phases 选项，删除 Check Pods Manifest.lock 和 Copy Pods Resources; 完成，编译运行。 文章：http://blog.csdn.net/wzzvictory/article/details/18737437 http://blog.csdn.net/sjl_leaf/article/details/50506057","tags":[]}]