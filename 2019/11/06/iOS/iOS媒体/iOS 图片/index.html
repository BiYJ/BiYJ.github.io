<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 图片 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 图片</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 图片</h1><div class="post-meta"><a href="/2019/11/06/iOS/iOS媒体/iOS 图片/#comments" class="comment-count"></a><p><span class="date">Nov 06, 2019</span><span><a href="/categories/iOS媒体/" class="category">iOS媒体</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、图片加载的工作流"><a href="#一、图片加载的工作流" class="headerlink" title="一、图片加载的工作流"></a>一、图片加载的工作流</h2><p>概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下：</p>
<ol>
<li>假设我们使用 <code>+imageWithContentsOfFile:</code> 方法从磁盘中加载一张图片，此时的图片并没有解压缩；</li>
<li>然后将生成的 UIImage 赋值给 UIImageView；</li>
<li>接着一个隐式的 <code>CATransaction</code> 捕获到了 UIImageView 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：<ul>
<li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li>
<li>将文件数据从磁盘读到内存中；</li>
<li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li>
<li>最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。</li>
</ul>
</li>
</ol>
<p>由上面的步骤可知，图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p>
<h2 id="二、为什么需要解压缩"><a href="#二、为什么需要解压缩" class="headerlink" title="二、为什么需要解压缩"></a>二、为什么需要解压缩</h2><p>既然图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3" target="_blank" rel="noopener">位图</a>：</p>
<blockquote>
<p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.</p>
</blockquote>
<p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。</p>
<p>下面是一张 PNG 图片，像素为 30 × 30，文件大小为 843B：</p>
<center><br><img src="http://dzliving.com/ImageDecode_0.png" alt><br></center>

<p>使用<a href="https://developer.apple.com/library/content/qa/qa1509/_index.html" target="_blank" rel="noopener">下面的代码</a>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"check_green"</span>];</span><br><span class="line"><span class="built_in">CFDataRef</span> rawData = <span class="built_in">CGDataProviderCopyData</span>(<span class="built_in">CGImageGetDataProvider</span>(image.CGImage));</span><br></pre></td></tr></table></figure>
<p>就可以获取到这个图片的原始像素数据，大小为 3600B ：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">01020102</span> <span class="number">032</span>c023c <span class="number">0567048</span>c <span class="number">078</span>d06bf <span class="number">08</span>a006d9 <span class="number">09</span>b307f3 <span class="number">09</span>b307f3 <span class="number">08</span>a006d9 <span class="number">078</span>d06bf</span><br><span class="line"><span class="number">0567048</span>c <span class="number">032</span>c023c <span class="number">01020102</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">01060108</span> <span class="number">05570476</span> <span class="number">09</span>ab07e9 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>ab07e9 <span class="number">05570476</span> <span class="number">01060108</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">033</span>d0353 <span class="number">08</span>a607e2 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line">...</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">08</span>a607e2 <span class="number">033</span>d0353 <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">01060108</span> <span class="number">05570476</span> <span class="number">09</span>ab07e9 <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff</span><br><span class="line"><span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>bb07ff <span class="number">09</span>ab07e9 <span class="number">05570476</span> <span class="number">01060108</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">01020102</span> <span class="number">032</span>c023c <span class="number">0567048</span>c</span><br><span class="line"><span class="number">078</span>d06bf <span class="number">08</span>a006d9 <span class="number">09</span>b307f3 <span class="number">09</span>b307f3 <span class="number">08</span>a006d9 <span class="number">078</span>d06bf <span class="number">0567048</span>c <span class="number">032</span>c023c <span class="number">01020102</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>
<p>也就是说，这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>
<blockquote>
<p>解压缩后的图片大小(3600) = 图片的像素宽(30) <em> 图片的像素高(30) </em> 每个像素所占的字节数(4)</p>
</blockquote>
<p>至于这个公式是怎么得来的，后面会有详细的说明。</p>
<p>至此，我们已经知道了什么是位图，并且直观地看到了它的原始像素数据，那么它与我们经常提到的图片的二进制数据有什么联系吗？是同一个东西吗？事实上，这二者是完全独立的两个东西，它们之间没有必然的联系。为了加深理解，我把这个图片拖进 Sublime Text 2 中，得到了这个图片的二进制数据，大小与原始文件大小一致，为 843B：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8950</span> <span class="number">4e47</span> <span class="number">0</span>d0a <span class="number">1</span>a0a <span class="number">0000</span> <span class="number">000</span>d <span class="number">4948</span> <span class="number">4452</span> <span class="number">0000</span> <span class="number">001</span>e <span class="number">0000</span> <span class="number">001</span>e <span class="number">0806</span> <span class="number">0000</span> <span class="number">003</span>b <span class="number">30</span>ae a200</span><br><span class="line"><span class="number">0000</span> <span class="number">0173</span> <span class="number">5247</span> <span class="number">4200</span> aece <span class="number">1</span>ce9 <span class="number">0000</span> <span class="number">0305</span> <span class="number">4944</span> <span class="number">4154</span> <span class="number">480</span>d c557 <span class="number">4</span>d68 <span class="number">1341</span> <span class="number">149</span>e <span class="number">3709</span> da4d</span><br><span class="line"><span class="number">09</span>c6 <span class="number">8</span>a56 <span class="number">2385</span> <span class="number">9e14</span> f458 <span class="number">4</span>fa2 d092 f4a6 <span class="number">28</span>d8 <span class="number">2222</span> de04 <span class="number">3</span>d09 a1d0 <span class="number">7</span>a50 <span class="number">0954</span> <span class="number">8</span>bad <span class="number">2</span>d05</span><br><span class="line"><span class="number">4</span>fde <span class="number">3</span>c89 <span class="number">482</span>b <span class="number">2</span>ad6 <span class="number">8334</span> d183 e049 ef9e <span class="number">4</span>a41 <span class="number">48</span>b0 <span class="number">42</span>eb a549 <span class="number">6893</span> <span class="number">1</span>ddf <span class="number">9</span>bcd b4d9 d9d9</span><br><span class="line"><span class="number">4</span>dd8 a43a b0d9 <span class="number">9</span>d79 <span class="number">3</span>fdf bc79 <span class="number">3</span>ff3 <span class="number">02</span>ac <span class="number">8591</span> <span class="number">1559</span> <span class="number">3e97</span> <span class="number">9</span>b3e <span class="number">5</span>b05 fb32 <span class="number">6330</span> c098 <span class="number">48</span>a2</span><br><span class="line"><span class="number">183</span>d <span class="number">340</span>a b886 <span class="number">8</span>ff8 <span class="number">1e15</span> fced <span class="number">587</span>a e26b <span class="number">16</span>b2 b643 f2ff <span class="number">057</span>f <span class="number">1263</span> fd9f fbbb <span class="number">7</span>ed7 <span class="number">7</span>edd</span><br><span class="line"><span class="number">1142</span> <span class="number">8</span>c09 <span class="number">268</span>e <span class="number">04</span>f1 <span class="number">2</span>a1a <span class="number">3058</span> <span class="number">0380</span> b9c3 <span class="number">91</span>de a7ab <span class="number">43</span>ab <span class="number">15</span>b5 aebf <span class="number">7</span>d81 ad65 eb0a <span class="number">5</span>a31</span><br><span class="line"><span class="number">8</span>f4f <span class="number">9</span>f2e d4da <span class="number">1</span>c7e e249 <span class="number">64</span>ca c3e5 d726 <span class="number">7</span>eae <span class="number">2</span>fa2 <span class="number">7510</span> cb75 <span class="number">3</span>d62 cc5e <span class="number">0</span>c0f <span class="number">4</span>a5a <span class="number">69</span>c3</span><br><span class="line">...</span><br><span class="line"><span class="number">36</span>ac b11e <span class="number">7006</span> f71b <span class="number">5386</span> a2b7 <span class="number">1e48</span> ad82 a26a <span class="number">2880</span> <span class="number">95</span>db <span class="number">3</span>f8b f525 b880 e0ed <span class="number">7221</span> <span class="number">75</span>f1</span><br><span class="line">fa02 <span class="number">2</span>cd4 <span class="number">1</span>af7 <span class="number">1</span>d0e <span class="number">546</span>a <span class="number">98e5</span> d4ae <span class="number">342</span>a <span class="number">337</span>e <span class="number">6</span>b96 <span class="number">134</span>f <span class="number">1</span>ba0 <span class="number">0</span>c0b c83b a0f2 <span class="number">3593</span> <span class="number">7</span>b5c</span><br><span class="line"><span class="number">6</span>ca9 b541 cb4f <span class="number">254</span>e df58 d958 <span class="number">8955</span> a0fc <span class="number">2638</span> <span class="number">658</span>c <span class="number">2660</span> f986 b5f1 f4dd <span class="number">63</span>f2 <span class="number">5</span>aec ce59</span><br><span class="line">e3b6 b0a7 cdac ee55 <span class="number">145</span>c c7dc <span class="number">8</span>f60 f53f e0a6 b436 e3c0 <span class="number">27</span>b0 <span class="number">8</span>ecf <span class="number">5054</span> <span class="number">336</span>a ccd0 e1d8</span><br><span class="line"><span class="number">2335</span> <span class="number">1</span>f78 <span class="number">323</span>d <span class="number">6141</span> <span class="number">09</span>c3 c1aa <span class="number">5</span>f8b <span class="number">4e37</span> <span class="number">0899</span> e6b0 ed72 <span class="number">4046</span> <span class="number">759</span>e d262 <span class="number">5247</span> <span class="number">9</span>d01 <span class="number">1689</span></span><br><span class="line">a976 <span class="number">55</span>fb c993 <span class="number">6</span>ed5 <span class="number">7</span>d10 <span class="number">8</span>ff4 b162 fe6f cd1e ee4a d4bb c18e <span class="number">594</span>e <span class="number">96</span>ea <span class="number">1</span>da6 c762 <span class="number">6539</span></span><br><span class="line">bdff <span class="number">7943</span> afc0 c91f bdd1 a327 <span class="number">28</span>fc <span class="number">29</span>f7 d47a b337 f192 <span class="number">0</span>cc9 <span class="number">36</span>fa <span class="number">5497</span> <span class="number">73</span>f9 <span class="number">5827</span> aa39</span><br><span class="line"><span class="number">1599</span> <span class="number">4</span>eff <span class="number">69</span>fb <span class="number">0</span>b0d <span class="number">1</span>f7a <span class="number">96</span>cd <span class="number">3</span>eb0 <span class="number">7800</span> <span class="number">0000</span> <span class="number">0049</span> <span class="number">454</span>e <span class="number">44</span>ae <span class="number">4260</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>
<p>事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">return</span> <span class="built_in">image</span> as PNG. May <span class="built_in">return</span> nil <span class="keyword">if</span> <span class="built_in">image</span> has no CGImageRef <span class="keyword">or</span> invalid bitmap format</span><br><span class="line">UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull <span class="built_in">image</span>);</span><br><span class="line"></span><br><span class="line">// <span class="built_in">return</span> <span class="built_in">image</span> as JPEG. May <span class="built_in">return</span> nil <span class="keyword">if</span> <span class="built_in">image</span> has no CGImageRef <span class="keyword">or</span> invalid bitmap format. compression <span class="built_in">is</span> <span class="number">0</span>(most)..<span class="number">1</span>(least)</span><br><span class="line">UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull <span class="built_in">image</span>, CGFloat compressionQuality);</span><br></pre></td></tr></table></figure>
<p>因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>
<h2 id="三、强制解压缩的原理"><a href="#三、强制解压缩的原理" class="headerlink" title="三、强制解压缩的原理"></a>三、强制解压缩的原理</h2><p>既然图片的解压缩不可避免，而我们也不想让它在主线程执行，影响应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。</p>
<p>当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。</p>
<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是  <code>CGBitmapContextCreate</code>：</p>
<figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/* Create a bitmap context. The context draws into a bitmap which <span class="keyword">is</span> `width'</span><br><span class="line">   pixels wide <span class="keyword">and</span> `height' pixels high. The number <span class="keyword">of</span> components <span class="keyword">for</span> each</span><br><span class="line">   pixel <span class="keyword">is</span> specified <span class="keyword">by</span> `space', which may also specify a destination color</span><br><span class="line">   profile. The number <span class="keyword">of</span> bits <span class="keyword">for</span> each component <span class="keyword">of</span> a pixel <span class="keyword">is</span> specified <span class="keyword">by</span></span><br><span class="line">   `bitsPerComponent'. The number <span class="keyword">of</span> bytes <span class="keyword">per</span> pixel <span class="keyword">is</span> equal to</span><br><span class="line">   `(bitsPerComponent * number <span class="keyword">of</span> components + 7)/8'. Each row <span class="keyword">of</span> the bitmap</span><br><span class="line">   consists <span class="keyword">of</span> `bytesPerRow' bytes, which must <span class="keyword">be</span> at least `width * bytes</span><br><span class="line">   <span class="keyword">per</span> pixel' bytes; <span class="keyword">in</span> addition, `bytesPerRow' must <span class="keyword">be</span> an integer multiple</span><br><span class="line">   <span class="keyword">of</span> the number <span class="keyword">of</span> bytes <span class="keyword">per</span> pixel. `data', if non-NULL, points to a block</span><br><span class="line">   <span class="keyword">of</span> memory at least `bytesPerRow * height' bytes. If `data' <span class="keyword">is</span> NULL, the</span><br><span class="line">   data <span class="keyword">for</span> context <span class="keyword">is</span> allocated automatically <span class="keyword">and</span> freed when the context <span class="keyword">is</span></span><br><span class="line">   deallocated. `bitmapInfo' specifies whether the bitmap should contain an</span><br><span class="line">   alpha channel <span class="keyword">and</span> how it's to <span class="keyword">be</span> generated, along with whether the</span><br><span class="line">   components are floating-point <span class="keyword">or</span> integer. </span><br><span class="line"> */</span><br><span class="line">CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</span><br><span class="line"></span><br><span class="line">#### 3.1 Pixel Format</span><br><span class="line"></span><br><span class="line">位图其实就是一个像素数组，而[像素格式](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG)则是用来描述每个像素的组成格式，它包括以下信息：</span><br><span class="line"></span><br><span class="line">* Bits <span class="keyword">per</span> component：一个像素中每个独立的颜色分量使用的 bit 数；</span><br><span class="line">* Bits <span class="keyword">per</span> pixel：一个像素使用的总 bit 数；</span><br><span class="line">* Bytes <span class="keyword">per</span> row：位图中的每一行使用的字节数。</span><br><span class="line"></span><br><span class="line">有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 17 种特定组合：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/Supported Pixel Formats.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant，我们在后面会详细介绍。</span><br><span class="line"></span><br><span class="line">#### 3.2 Color <span class="keyword">and</span> Color Spaces</span><br><span class="line"></span><br><span class="line">什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 (0, 0, 1)。而&lt;font color=#cc0000&gt;颜色空间则是用来说明如何解析这些值的&lt;/font&gt;，离开了颜色空间，它们将变得毫无意义。比如,下面的值都表示蓝色：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/blue_color.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 (0, 0, 1) 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果：</span><br><span class="line"></span><br><span class="line">&lt;center&gt;</span><br><span class="line">![](http://dzliving.com/color_profiles.png)</span><br><span class="line">&lt;/center&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 3.3 Color Spaces <span class="keyword">and</span> Bitmap Layout</span><br><span class="line"></span><br><span class="line">像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供[位图的布局信息](https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB) CGBitmapInfo：</span><br></pre></td></tr></table></figure>
<p>typedef CF_OPTIONS(uint32_t, CGBitmapInfo) {<br>    kCGBitmapAlphaInfoMask = 0x1F,</p>
<pre><code>kCGBitmapFloatInfoMask = 0xF00,
kCGBitmapFloatComponents = (1 &lt;&lt; 8),

kCGBitmapByteOrderMask     = kCGImageByteOrderMask,
kCGBitmapByteOrderDefault  = (0 &lt;&lt; 12),
kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,
kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,
kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,
kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big
</code></pre><p>} CG_AVAILABLE_STARTING(<strong>MAC_10_0, </strong>IPHONE_2_0);<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它主要提供了三个方面的布局信息：</span><br><span class="line"></span><br><span class="line"><span class="comment">* alpha 的信息；</span></span><br><span class="line"><span class="comment">* 颜色分量是否为浮点数；</span></span><br><span class="line"><span class="comment">* 像素格式的字节顺序。</span></span><br><span class="line"></span><br><span class="line">其中，<span class="keyword">alpha</span> 的信息由枚举值 CGImageAlphaInfo 来表示：</span><br></pre></td></tr></table></figure></p>
<p>typedef CF_ENUM(uint32_t, CGImageAlphaInfo) {<br>    kCGImageAlphaNone,               /<em> For example, RGB. </em>/<br>    kCGImageAlphaPremultipliedLast,  /<em> For example, premultiplied RGBA </em>/<br>    kCGImageAlphaPremultipliedFirst, /<em> For example, premultiplied ARGB </em>/<br>    kCGImageAlphaLast,               /<em> For example, non-premultiplied RGBA </em>/<br>    kCGImageAlphaFirst,              /<em> For example, non-premultiplied ARGB </em>/<br>    kCGImageAlphaNoneSkipLast,       /<em> For example, RBGX. </em>/<br>    kCGImageAlphaNoneSkipFirst,      /<em> For example, XRGB. </em>/<br>    kCGImageAlphaOnly                /<em> No color data, alpha data only </em>/<br>};<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>是否包含 alpha；</span><br><span class="line"><span class="bullet">* </span>如果包含 alpha，那么 alpha 信息所处的位置，在像素的[<span class="string">最低有效位</span>](<span class="link">https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D</span>)，比如 RGBA，还是[<span class="string">最高有效位</span>](<span class="link">https://zh.wikipedia.org/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D</span>)，比如 ARGB；</span><br><span class="line"><span class="bullet">* </span>如果包含 alpha，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。</span><br><span class="line"></span><br><span class="line">那么我们在解压缩图片的时候应该使用哪个值呢？根据 [<span class="string">Which CGImageAlphaInfo should we use</span>](<span class="link">http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use</span>) 和官方文档中对 <span class="code">`UIGraphicsBeginImageContextWithOptions`</span> 函数的讨论：</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; You use this function to configure the drawing environment for rendering into a bitmap. The format for the bitmap is a ARGB 32-bit integer pixel format using host-byte order. If the opaque parameter is YES, the alpha channel is ignored and the bitmap is treated as fully opaque (kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host). Otherwise, each pixel uses a premultipled ARGB format (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host).</span></span><br><span class="line"></span><br><span class="line">我们可以知道，当图片不包含 alpha 的时候使用 kCGImageAlphaNoneSkipFirst ，否则使用 kCGImageAlphaPremultipliedFirst。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 kCGBitmapByteOrder32Host，而这个值具体是什么，后面再讨论。</span><br><span class="line"></span><br><span class="line">至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 kCGBitmapFloatComponents 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</span><br><span class="line"></span><br><span class="line">接下来，我们来简单地了解下像素格式的[<span class="string">字节顺序</span>](<span class="link">https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH</span>)，它是由枚举值 CGImageByteOrderInfo 来表示的：</span><br></pre></td></tr></table></figure></p>
<p>typedef CF_ENUM(uint32_t, CGImageByteOrderInfo) {<br>    kCGImageByteOrderMask     = 0x7000,<br>    kCGImageByteOrder16Little = (1 &lt;&lt; 12),<br>    kCGImageByteOrder32Little = (2 &lt;&lt; 12),<br>    kCGImageByteOrder16Big    = (3 &lt;&lt; 12),<br>    kCGImageByteOrder32Big    = (4 &lt;&lt; 12)<br>} CG_AVAILABLE_STARTING(<strong>MAC_10_12, </strong>IPHONE_10_0);<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它主要提供了两个方面的字节顺序信息：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>[<span class="string">小端模式</span>](<span class="link">https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F</span>)还是[<span class="string">大端模式</span>](<span class="link">https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F</span>)；</span><br><span class="line"><span class="bullet">* </span>数据以 16 位还是 32 位为单位。</span><br><span class="line"></span><br><span class="line">对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 [<span class="string">Hardcoding</span>](<span class="link">https://en.wikipedia.org/wiki/Hard_coding</span>)：</span><br></pre></td></tr></table></figure></p>
<p>#ifdef <strong>BIG_ENDIAN</strong></p>
<pre><code>#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big
#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big
</code></pre><p>#else /<em> Little endian. </em>/</p>
<pre><code>#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little
#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little
</code></pre><p>#endif<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 kCGBitmapByteOrder32Host ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</span><br><span class="line"></span><br><span class="line">下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/colorformatrgba32.gif)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</span><br><span class="line"></span><br><span class="line">好了，了解完这些相关知识后，我们再回过头来看看 CGBitmapContextCreate 函数中每个参数所代表的具体含义：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</span><br><span class="line"><span class="bullet">* </span>width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</span><br><span class="line"><span class="bullet">* </span>bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 [<span class="string">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</span>](<span class="link">http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters</span>) 和 [<span class="string">Why is my image’s Bytes per Row more than its Bytes per Pixel times its Width?</span>](<span class="link">http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</span><br><span class="line"><span class="bullet">* </span>bitmapInfo ：就是我们前面提到的位图的布局信息。</span><br><span class="line">到这里，你已经掌握了强制解压缩图片需要用到的最核心的函数，点个赞。</span><br><span class="line"></span><br><span class="line"><span class="section">## 四、开源库的实现</span></span><br><span class="line"></span><br><span class="line">接下来，我们来看看在三个比较流行的开源库 [<span class="string">YYKit</span>](<span class="link">https://github.com/ibireme/YYKit</span>)、[<span class="string">SDWebImage</span>](<span class="link">https://github.com/rs/SDWebImage</span>) 和 [<span class="string">FLAnimatedImage</span>](<span class="link">https://github.com/Flipboard/FLAnimatedImage</span>) 中，对图片的强制解压缩是如何实现的。</span><br><span class="line"></span><br><span class="line">首先，我们来看看 YYKit 中的相关代码，用于解压缩图片的函数 YYCGImageCreateDecodedCopy 存在于 [<span class="string">YYImageCoder</span>](<span class="link">https://github.com/ibireme/YYKit/blob/master/YYKit/Image/YYImageCoder.m</span>) 类中，核心代码如下：</span><br></pre></td></tr></table></figure></p>
<p>CGImageRef YYCGImageCreateDecodedCopy(CGImageRef imageRef, BOOL decodeForDisplay) {<br>    …</p>
<pre><code>if (decodeForDisplay) { // decode with redraw (may lose some precision)
    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef) &amp; kCGBitmapAlphaInfoMask;

    BOOL hasAlpha = NO;
    if (alphaInfo == kCGImageAlphaPremultipliedLast ||
        alphaInfo == kCGImageAlphaPremultipliedFirst ||
        alphaInfo == kCGImageAlphaLast ||
        alphaInfo == kCGImageAlphaFirst) {
        hasAlpha = YES;
    }

    // BGRA8888 (premultiplied) or BGRX8888
    // same as UIGraphicsBeginImageContext() and -[UIView drawRect:]
    CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;
    bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;

    CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);
    if (!context) return NULL;

    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode
    CGImageRef newImage = CGBitmapContextCreateImage(context);
    CFRelease(context);

    return newImage;
} else {
    ...
}
</code></pre><p>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它接受一个原始的位图参数 imageRef，最终返回一个新的解压缩后的位图 newImage，中间主要经过了以下三个步骤：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>使用 CGBitmapContextCreate 函数创建一个位图上下文；</span><br><span class="line"><span class="bullet">2. </span>使用 CGContextDrawImage 函数将原始位图绘制到上下文中；</span><br><span class="line"><span class="bullet">3. </span>使用 CGBitmapContextCreateImage 函数创建一张新的解压缩后的位图。</span><br><span class="line"></span><br><span class="line">事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 CGBitmapContextCreate 函数的部分参数存在细微的差别，如下表所示：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/CGBitmapContextCreate.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">在上表中，用浅绿色背景标记的参数即为我们在前面的分析中所推荐的参数，用这些参数解压缩后的图片渲染的速度会更快。因此，从理论上说 YYKit 中的解压缩算法是三者之中最优的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 五、性能对比</span></span><br><span class="line"></span><br><span class="line">[<span class="string">测试源码 GitHub 地址</span>](<span class="link">https://github.com/leichunfeng/Image-Decompression-Benchmark</span>)。</span><br><span class="line"></span><br><span class="line">采用的测试样例分别为 5 张 PNG 图片和 5 张 JPEG 图片，像素依次为 128x96、256x192 、512x384、1024x768 和 2048x1536，它们其实都长一个样：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/128x96.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">首先，我们来了解下测试的原理，我们可以将从磁盘加载一张图片到最终渲染到屏幕上的过程划分为三个阶段：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>初始化阶段：从磁盘初始化图片，生成一个未解压缩的 UIImage 对象；</span><br><span class="line"><span class="bullet">* </span>解压缩阶段：分别使用 YYKit、SDWebImage 和 FLAnimatedImage 对第 1 步中得到的 UIImage 对象进行解压缩，得到一个新的解压缩后的 UIImage 对象；</span><br><span class="line"><span class="bullet">* </span>绘制阶段：将第 2 步中得到的 UIImage 对象绘制到屏幕上。</span><br><span class="line"></span><br><span class="line">这里我们以绘制阶段的耗时为依据来评测解压缩的性能，解压缩的算法越优秀，那么得到的图片就越符合系统渲染时的需求，绘制的时间也就越短。为了让测试的结果更准确，我们对每张图片都解压缩 10 次，然后取平均值。说明，本次使用的测试设备是 iPhone 5s 。</span><br><span class="line"></span><br><span class="line">首先，我们来看看解压缩 PNG 图片的测试结果：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress<span class="emphasis">_png_</span>compare.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">相应的柱状图如下：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress_png.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">从上图可以看出，就我们采用的测试样例来说，解压缩 PNG 图片的性能 SDWebImage 最好，FLAnimatedImage 次之，YYKit 最差。这与我们前面的理论结果有一定的差距，可能是测试样例太少，也可能这就是真实结果。另外，需要说明的是，我们这里使用的 PNG 图片都是不带 alpha 值，因为 SDWebImage 不支持解压缩带 alpha 值的 PNG 图片。</span><br><span class="line"></span><br><span class="line">接着，我们再来看看解压缩 JPEG 图片的测试结果：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress<span class="emphasis">_jpeg_</span>compare.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">相应的柱状图如下：</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![](http://dzliving.com/decompress_jpeg.png)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">解压缩 JPEG 图片的性能最好，SDWebImage 和 FLAnimatedImage 并列第二。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 六、总结</span></span><br><span class="line"></span><br><span class="line">要理解 iOS 中图片的解压缩并不难，重点是要理解位图的概念。而图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程。了解这些知识，将有助于我们更好地处理图片，管理好它们所占用的内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 七、其他</span></span><br><span class="line"></span><br><span class="line">[<span class="string">飘金</span>](<span class="link">https://www.jianshu.com/u/da7864faa1be</span>) - [<span class="string">iOS 图片解码</span>](<span class="link">https://www.jianshu.com/p/e9843d5b70a2</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.1 图片的存储消耗</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>磁盘空间或者通过网络传输所消耗的空间</span><br><span class="line"><span class="bullet">2. </span>解压缩空间，通常是长 <span class="bullet">* 宽 *</span> 高 * 4字节（RGBA）</span><br><span class="line"><span class="bullet">3. </span>当显示在一个 view 中时，view 本身也需要空间来存储 layer</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.2 图片加载时间</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>从磁盘上 alloc/initUIImage 的时间</span><br><span class="line"><span class="bullet">2. </span>解压缩的时间</span><br><span class="line"><span class="bullet">3. </span>将解压缩后的比特转换成 CGContext 的时间，通常需要改变尺寸、混合、抗锯齿工作。</span><br><span class="line"></span><br><span class="line"><span class="section">#### 7.3 小 Tips</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>如何把 GIF 动图保存到相册？</span><br></pre></td></tr></table></figure></p>
<pre><code>[ALAssetsLibrary writeImageDataToSavedPhotosAlbum:metadata:completionBlock];

// 图像会被强制转码为 PNG 格式
UIImageWriteToSavedPhotosAlbum();
```
</code></pre><ol start="2">
<li><p>将 UIImage 保存到磁盘，用什么方式最好？</p>
<p> 保存 UIImage 有三种方式：</p>
<ul>
<li>直接用 NSKeyedArchiver 把 UIImage 序列化保存；</li>
<li>用 UIImagePNGRepresentation() 先把图片转为 PNG 保存；</li>
<li><p>用 UIImageJPEGRepresentation() 把图片压缩成 JPEG 保存。</p>
<p>实际上，NSKeyedArchiver 是调用了 UIImagePNGRepresentation 进行序列化的，用它来保存图片是消耗最大的。苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。所以如果图片不包含透明像素时，<code>UIImageJPEGRepresentation(0.9)</code> 是最佳的图片保存方式，其次是 UIImagePNGRepresentation()。</p>
</li>
</ul>
</li>
<li><p>UIImage 缓存是怎么回事？</p>
<p> 通过 <code>imageNamed:</code> 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存。</p>
<p> 在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在<font color="#cc0000">(待验证)</font>。</p>
</li>
<li><p>用 imageWithData: 能不能避免缓存呢？</p>
<p> 不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 <code>CGImageSourceCreateWithData()</code> 方法。该方法有个参数叫 <code>ShouldCache</code>，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed: 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p>
</li>
<li><p>怎么能避免缓存?</p>
<ol>
<li>手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。</li>
<li>把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。</li>
</ol>
</li>
<li><p>我能直接取到图片解码后的数据，而不是通过画布取到吗？</p>
<ol>
<li>CGImageSourceCreateWithData(data) 创建 ImageSource。</li>
<li>CGImageSourceCreateImageAtIndex(source) 创建一个未解码的 CGImage。</li>
<li>CGImageGetDataProvider(image) 获取这个图片的数据源。</li>
<li><p>CGDataProviderCopyData(provider) 从数据源获取直接解码的数据。</p>
<p>ImageIO 解码发生在最后一步，这样获得的数据是没有经过颜色类型转换的原生数据（比如灰度图像）。</p>
</li>
</ol>
</li>
<li><p>如何判断一个文件的图片类型？</p>
<p> 通过读取文件或数据的头几个字节然后和对应图片格式标准进行比对。</p>
</li>
<li><p>怎样像浏览器那样边下载边显示图片？</p>
<ul>
<li><p>baseline 逐行扫描。默认情况下，JPEG、PNG、GIF 都是这种保存方式。</p>
<p>  <img src="http://dzliving.com/UIImage_1.gif" alt></p>
</li>
<li><p>interlaced 隔行扫描。PNG 和 GIF 在保存时可以选择这种格式。</p>
<p>  <img src="http://dzliving.com/UIImage_2.gif" alt></p>
</li>
<li><p>progressive 渐进式。JPEG 在保存时可以选择这种方式。</p>
<p>  <img src="http://dzliving.com/UIImage_3.gif" alt></p>
<p>在下载图片时，首先用 CGImageSourceCreateIncremental(NULL) 创建一个空的图片源，随后在获得新数据时调用 CGImageSourceUpdateData(data, false) 来更新图片源，最后在用 CGImageSourceCreateImageAtIndex() 创建图片来显示。</p>
<p>可以用 <a href="https://github.com/pinterest/PINRemoteImage" target="_blank" rel="noopener">PINRemoteImage</a> 或者 <a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="noopener">YYWebImage</a> 来实现这个效果。</p>
</li>
</ul>
</li>
</ol>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="http://blog.leichunfeng.com/" target="_blank" rel="noopener">雷纯锋的技术博客</a> - <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/#jtss-tsina" target="_blank" rel="noopener">谈谈 iOS 中图片的解压缩</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/11/06/iOS/iOS媒体/iOS 图片/">http://yoursite.com/2019/11/06/iOS/iOS媒体/iOS 图片/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/" class="pre">iOS umbrella header</a><a href="/2019/11/05/iOS/iOS优化/iOS 优化实例/" class="next">iOS 优化实例</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、图片加载的工作流"><span class="toc-text">一、图片加载的工作流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、为什么需要解压缩"><span class="toc-text">二、为什么需要解压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、强制解压缩的原理"><span class="toc-text">三、强制解压缩的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文章"><span class="toc-text">文章</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/">iOS UmbrellaFramework</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/">iOS umbrella header</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS媒体/iOS 图片/">iOS 图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS优化/iOS 优化实例/">iOS 优化实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS原理/iOS 操作系统架构/">iOS 操作系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS架构/iOS 网络层设计/">iOS网络层设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS 类簇/">iOS 类簇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS OCR/">iOS OCR</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS IM/">iOS IM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/iOS/iOS原理/iOS 推送/">iOS 推送</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT/">IT</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL/">OpenGL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS动画/">iOS动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS媒体/">iOS媒体</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS安全/">iOS安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">5</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>