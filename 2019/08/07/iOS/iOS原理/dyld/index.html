<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>dyld | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">dyld</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">dyld</h1><div class="post-meta"><a href="/2019/08/07/iOS/iOS原理/dyld/#comments" class="comment-count"></a><p><span class="date">Aug 07, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>在 MacOS 和 iOS 上，可执行程序的启动依赖于 xnu 内核进程运作和动态链接加载器 dyld。</p>
<blockquote>
<p>dyld 全称 the dynamic link editor，即动态链接器，其本质是 Mach-O 文件，是专门用来加载动态库的库。</p>
</blockquote>
<p>源码下载地址：<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/dyld/</a></p>
<p>dyld 会将 App 依赖的动态库和 App 文件加载到内存以后执行，动态库不是可执行文件，无法独自执行。当点击 App 的时候，系统在内核态完成一些必要配置，从 App 的 MachO 文件解析出 dyld 的地址，这里会记录在 MachO 的 LC_LOAD_DYLINKER 命令中，内容参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          cmd LC_LOAD_DYLINKER</span><br><span class="line">      cmdsize 28</span><br><span class="line">         name /usr/lib/dyld (offset 12)</span><br><span class="line">Load command 8</span><br><span class="line">     cmd LC_UUID</span><br><span class="line"> cmdsize 24</span><br><span class="line">    uuid DF0F9B2D-A4D7-37D0-BC6B-DB0297766CE8</span><br><span class="line">Load command 9</span><br><span class="line">      cmd LC_VERSION_MIN_IPHONEOS</span><br></pre></td></tr></table></figure>
<p>dyld 位于 <code>/usr/lib/dyld</code>，可以从越狱机或者 mac 电脑中找到。以 mac 为例，终端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/lib</span><br><span class="line">$ file dyld</span><br></pre></td></tr></table></figure>
<center><br><img src="http://dzliving.com/dyld_path.png" alt><br></center>

<p>dyld 是 <font color="#cc0000">Mach-O 类型的通用二进制文件</font>，支持 x86_64 和 i386 两种架构。iPhone 真机对应的 dyld 支持的为 arm 系列架构。</p>
<h2 id="二、otool"><a href="#二、otool" class="headerlink" title="二、otool"></a>二、otool</h2><blockquote>
<p>otool 是专门用来查看 Mach-O 类型文件的工具</p>
</blockquote>
<p>Mac OS X 下二进制可执行文件的动态链接库是 <code>dylib</code> 文件。</p>
<blockquote>
<p>dylib 也就是 bsd 风格的动态库。基本可以认为等价于 windows 的 dll 和 linux 的so。mac 基于 bsd，所以也使用的是 dylib。</p>
</blockquote>
<p>Linux 下用 ldd 查看，苹果系统用 otool。</p>
<h4 id="2-1-查看-otool-地址"><a href="#2-1-查看-otool-地址" class="headerlink" title="2.1 查看 otool 地址"></a>2.1 查看 otool 地址</h4><p>电脑已安装 Xcode。终端输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ otool</span><br><span class="line">Usage: /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...</span><br><span class="line">	-f print the fat headers</span><br><span class="line">	-a print the archive header</span><br><span class="line">	-h print the mach header</span><br><span class="line">	-l print the load commands</span><br><span class="line">	-L print shared libraries used</span><br><span class="line">	-D print shared library id name</span><br><span class="line">	-t print the text section (disassemble with -v)</span><br><span class="line">	-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">	-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">	-d print the data section</span><br><span class="line">	-o print the Objective-C segment</span><br><span class="line">	-r print the relocation entries</span><br><span class="line">	-S print the table of contents of a library (obsolete)</span><br><span class="line">	-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">	-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">	-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">	-I print the indirect symbol table</span><br><span class="line">	-H print the two-level hints table (obsolete)</span><br><span class="line">	-G print the data in code table</span><br><span class="line">	-v print verbosely (symbolically) when possible</span><br><span class="line">	-V print disassembled operands symbolically</span><br><span class="line">	-c print argument strings of a core file</span><br><span class="line">	-X print no leading addresses or headers</span><br><span class="line">	-m don&apos;t use archive(member) syntax</span><br><span class="line">	-B force Thumb disassembly (ARM objects only)</span><br><span class="line">	-q use llvm&apos;s disassembler (the default)</span><br><span class="line">	-Q use otool(1)&apos;s disassembler</span><br><span class="line">	-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">	-j print opcode bytes</span><br><span class="line">	-P print the info plist section as strings</span><br><span class="line">	-C print linker optimization hints</span><br><span class="line">	--version print the version of /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure>
<p>由上可知 otool 的地址：<font color="#cc0000"><code>/Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</code></font></p>
<p>进入地址发现 otool 文件是一个替身（软连接）。</p>
<p>查看 otool 指向的软连接地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Applications/Xcode10.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/</span><br><span class="line">$</span><br><span class="line">$ ls -l</span><br><span class="line">total 223352</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     33920 10 20  2018 ar</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     28000 10 20  2018 as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     18176 10 20  2018 asa</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    212208 10 20  2018 bison</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    150048 10 20  2018 bitcode_strip</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 c++ -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23152 10 20  2018 c89</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     23248 10 20  2018 c99</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 cc -&gt; clang</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  78705232 10 20  2018 clang</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 clang++ -&gt; clang</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120064 10 20  2018 cmpdylib</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145872 10 20  2018 codesign_allocate</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        17 11 22  2018 codesign_allocate-p -&gt; codesign_allocate</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   4937600 10 20  2018 coremlcompiler</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3344  9 26  2018 cpp</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     27712 10 20  2018 ctags</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    145824 10 20  2018 ctf_insert</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        13 11 22  2018 dsymutil -&gt; llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1006032 10 20  2018 dwarfdump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    219088 10 20  2018 dyldinfo</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    569056 10 20  2018 flex++</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         8 11 22  2018 gcov -&gt; llvm-cov</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 gm4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     90960 10 20  2018 gperf</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     65520 10 20  2018 indent</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    136784 10 20  2018 install_name_tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2480704 10 20  2018 ld</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       230  9 26  2018 lex</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    154592 10 20  2018 libtool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     66000 10 20  2018 lipo</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   3320816 10 20  2018 llvm-cov</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  29723968 10 20  2018 llvm-dsymutil</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  10591472 10 20  2018 llvm-nm</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  11899296 10 20  2018 llvm-objdump</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     32672 10 20  2018 llvm-otool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   1272096 10 20  2018 llvm-profdata</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   2873440 10 20  2018 llvm-size</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      3567  9 26  2018 lorder</span><br><span class="line">-rwxr-xr-x  2 cykj  staff    142336 10 20  2018 m4</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24800 10 20  2018 metal</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-ar</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-as</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-link</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metal-opt</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     24768 10 20  2018 metallib</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      7604  9 26  2018 mig</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 nm -&gt; llvm-nm</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132896 10 20  2018 nm-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    162720 10 20  2018 nmedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        12 11 22  2018 objdump -&gt; llvm-objdump</span><br><span class="line">lrwxr-xr-x  1 cykj  staff        10 11 22  2018 otool -&gt; llvm-otool</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    648720 10 20  2018 otool-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    132784 10 20  2018 pagestuff</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         7 11 22  2018 ranlib -&gt; libtool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59344 10 20  2018 rebase</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    204960 10 20  2018 redo_prebinding</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     73664 10 20  2018 rpcgen</span><br><span class="line">-r-xr-xr-x  1 cykj  staff     48864 10 20  2018 segedit</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         9 11 22  2018 size -&gt; llvm-size</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120080 10 20  2018 size-classic</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    120400 10 20  2018 strings</span><br><span class="line">-r-xr-xr-x  1 cykj  staff    189568 10 20  2018 strip</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  87671328 10 20  2018 swift</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swift-autolink-extract -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031520 10 20  2018 swift-build</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    384480 10 20  2018 swift-build-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff    461136 10 20  2018 swift-demangle</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031552 10 20  2018 swift-package</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031472 10 20  2018 swift-run</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     53024 10 20  2018 swift-stdlib-tool</span><br><span class="line">-rwxr-xr-x  1 cykj  staff   5031504 10 20  2018 swift-test</span><br><span class="line">lrwxr-xr-x  1 cykj  staff         5 11 22  2018 swiftc -&gt; swift</span><br><span class="line">-rwxr-xr-x  1 cykj  staff  12042320 10 20  2018 tapi</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     32592 10 20  2018 unifdef</span><br><span class="line">-rwxr-xr-x  1 cykj  staff      2946  9 26  2018 unifdefall</span><br><span class="line">-rwxr-xr-x  1 cykj  staff     59776 10 20  2018 unwinddump</span><br><span class="line">-rwxr-xr-x  1 cykj  staff       135  9 26  2018 yacc</span><br></pre></td></tr></table></figure>
<p>可以看到 otool 指向 <font color="#cc0000">llvm-otool</font>，而 llvm-otool 和 otool 在同一个目录中。</p>
<p>另外，还可以发现，这个文件夹下面还有很多有用的文件，如 <code>lipo</code>。</p>
<h4 id="2-2-otool-L"><a href="#2-2-otool-L" class="headerlink" title="2.2 otool -L"></a>2.2 otool -L</h4><blockquote>
<p>查看动态链接库</p>
</blockquote>
<p>终端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-fpfdxjbemnwnqcfjimbqpbzpnpem/Build/Products/Debug-iphonesimulator/Demo.app/</span><br><span class="line">$</span><br><span class="line">$ otool -L Demo</span><br><span class="line">Demo:</span><br><span class="line">	/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1560.10.0)</span><br><span class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br><span class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)</span><br><span class="line">	/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1560.10.0)</span><br><span class="line">	/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 61000.0.0)</span><br></pre></td></tr></table></figure>
<p>查看动态库的依赖库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L /usr/lib/system/libdispatch.dylib</span><br><span class="line">/usr/lib/system/libdispatch.dylib:</span><br><span class="line">	/usr/lib/system/libdispatch.dylib (compatibility version 1.0.0, current version 913.60.3)</span><br><span class="line">	/usr/lib/system/libdyld.dylib (compatibility version 1.0.0, current version 551.4.0)</span><br><span class="line">	/usr/lib/system/libcompiler_rt.dylib (compatibility version 1.0.0, current version 62.0.0)</span><br><span class="line">	/usr/lib/system/libsystem_kernel.dylib (compatibility version 1.0.0, current version 4570.71.8)</span><br><span class="line">	/usr/lib/system/libsystem_platform.dylib (compatibility version 1.0.0, current version 161.50.1)</span><br><span class="line">	/usr/lib/system/libsystem_pthread.dylib (compatibility version 1.0.0, current version 301.50.1)</span><br><span class="line">	/usr/lib/system/libsystem_malloc.dylib (compatibility version 1.0.0, current version 140.50.6)</span><br><span class="line">	/usr/lib/system/libsystem_c.dylib (compatibility version 1.0.0, current version 1244.50.9)</span><br><span class="line">	/usr/lib/system/libsystem_blocks.dylib (compatibility version 1.0.0, current version 67.0.0)</span><br><span class="line">	/usr/lib/system/libunwind.dylib (compatibility version 1.0.0, current version 35.3.0)</span><br><span class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-otool-ov"><a href="#2-3-otool-ov" class="headerlink" title="2.3 otool -ov"></a>2.3 otool -ov</h4><blockquote>
<p>显示 Objective-C 类结构及其定义的方法。</p>
</blockquote>
<p>终端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ otool -ov Demo</span><br><span class="line">Demo:</span><br><span class="line">Contents of (__DATA,__objc_classlist) section</span><br><span class="line">00000001000041f0 0x100005080 _OBJC_CLASS_$_HookTool</span><br><span class="line">           isa 0x1000050a8 _OBJC_METACLASS_$_HookTool</span><br><span class="line">    superclass 0x0 _OBJC_CLASS_$_NSObject</span><br><span class="line">         cache 0x0 __objc_empty_cache</span><br><span class="line">        vtable 0x0</span><br><span class="line">          data 0x100004328 (struct class_ro_t *)</span><br><span class="line">                    flags 0x80</span><br><span class="line">            instanceStart 8</span><br><span class="line">             instanceSize 8</span><br><span class="line">                 reserved 0x0</span><br><span class="line">               ivarLayout 0x0</span><br><span class="line">                     name 0x100003555 HookTool</span><br><span class="line">              baseMethods 0x1000042f0 (struct method_list_t *)</span><br><span class="line">		   entsize 24</span><br><span class="line">		     count 2</span><br><span class="line">		      name 0x1000028b3 swizzle_decodeObjectForKey:</span><br><span class="line">		     types 0x1000035c4 @24@0:8@16</span><br><span class="line">		       imp 0x1000015f0 -[HookTool swizzle_decodeObjectForKey:]</span><br><span class="line">		      name 0x100002914 swizzle_button_initWithCoder:</span><br><span class="line">		     types 0x1000035c4 @24@0:8@16</span><br><span class="line">		       imp 0x1000017c0 -[HookTool swizzle_button_initWithCoder:]</span><br><span class="line">            baseProtocols 0x0</span><br><span class="line">                    ivars 0x0</span><br><span class="line">           weakIvarLayout 0x0</span><br><span class="line">           baseProperties 0x0</span><br><span class="line">Meta Class</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h4 id="2-4-otool-tV-Mach-O"><a href="#2-4-otool-tV-Mach-O" class="headerlink" title="2.4 otool -tV [Mach-O]"></a>2.4 otool -tV [Mach-O]</h4><blockquote>
<p>查看 ARM 汇编码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ otool -tV Demo</span><br><span class="line">Demo:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">+[HookTool load]:</span><br><span class="line">0000000100001400	pushq	%rbp</span><br><span class="line">0000000100001401	movq	%rsp, %rbp</span><br><span class="line">0000000100001404	subq	$0x40, %rsp</span><br><span class="line">0000000100001408	movl	$0x2, %eax</span><br><span class="line">000000010000140d	movl	%eax, %edx</span><br><span class="line">000000010000140f	movq	%rdi, -0x8(%rbp)</span><br><span class="line">0000000100001413	movq	%rsi, -0x10(%rbp)</span><br><span class="line">0000000100001417	movq	0x3c1a(%rip), %rsi ## Objc class ref: _OBJC_CLASS_$_NSMutableArray</span><br><span class="line">000000010000141e	movq	0x3b33(%rip), %rdi ## Objc selector ref: arrayWithCapacity:</span><br><span class="line">0000000100001425	movq	%rdi, -0x20(%rbp)</span><br><span class="line">0000000100001429	movq	%rsi, %rdi</span><br><span class="line">000000010000142c	movq	-0x20(%rbp), %rsi</span><br><span class="line">0000000100001430	callq	*0x2bf2(%rip) ## Objc message: +[NSMutableArray arrayWithCapacity:]</span><br><span class="line">0000000100001436	movq	%rax, %rdi</span><br><span class="line">0000000100001439	callq	0x10000265a ## symbol stub for: _objc_retainAutoreleasedReturnValue</span><br><span class="line">000000010000143e	movq	__imageViewImageArray(%rip), %rdx</span><br><span class="line">0000000100001445	movq	%rax, __imageViewImageArray(%rip)</span><br><span class="line">000000010000144c	movq	%rdx, %rdi</span><br><span class="line">000000010000144f	callq	*0x2bdb(%rip) ## literal pool symbol address: _objc_release</span><br><span class="line">0000000100001455	leaq	0x2cb4(%rip), %rax ## Objc cfstring ref: @&quot;emaNecruoseRIU&quot;</span><br><span class="line">000000010000145c	movq	0x3bdd(%rip), %rdx ## Objc class ref: HookTool</span><br><span class="line">0000000100001463	movq	0x3af6(%rip), %rsi ## Objc selector ref: stringByReversed:</span><br><span class="line">000000010000146a	movq	%rdx, %rdi</span><br><span class="line"></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h4 id="2-5-otool-h-Mach-O"><a href="#2-5-otool-h-Mach-O" class="headerlink" title="2.5 otool -h [Mach-O]"></a>2.5 otool -h [Mach-O]</h4><blockquote>
<p>查看 Mach-O 头结构等</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ otool -h Demo</span><br><span class="line">Mach header</span><br><span class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</span><br><span class="line"> 0xfeedfacf 16777223          3  0x00           2    21       3272 0x00200085</span><br></pre></td></tr></table></figure>
<p>一个 Mach-O 的文件头结构为：</p>
<center><br><img src="http://dzliving.com/MachOHeader.png" alt><br></center>

<p>各字段的含义，可参看 <code>/usr/include/mach-o/loader.h</code>。</p>
<h4 id="2-6-otool-l-Mach-O-grep-crypt1"><a href="#2-6-otool-l-Mach-O-grep-crypt1" class="headerlink" title="2.6 otool -l [Mach-O] | grep crypt1"></a>2.6 otool -l [Mach-O] | grep crypt1</h4><blockquote>
<p>查看 ipa 包是否加壳</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ otool -l Demo | grep crypt1</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>没有进行过加壳处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6651904</span><br><span class="line">  cryptid 0</span><br><span class="line"> cryptoff 16384</span><br><span class="line">cryptsize 6553600</span><br><span class="line">  cryptid 0123456</span><br></pre></td></tr></table></figure>
<p>cryptid 代表是否加壳，1 - 加壳，0 - 已脱壳。</p>
<p>上面打印了两遍，其实代表着该可执行文件支持两种架构 armv7 和 arm64。</p>
<p>Mach-O 文件可以用 GUI 图形软件 <a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a> 更加直观的查看相关信息。</p>
<center><br><img src="http://dzliving.com/MachOView.png" alt><br></center>


<h2 id="三、dyld加载"><a href="#三、dyld加载" class="headerlink" title="三、dyld加载"></a>三、dyld加载</h2><blockquote>
<p>动态库链接、load 方法执行都是在 main 函数执行之前的。</p>
</blockquote>
<p>如图所示进行操作：</p>
<center><br><img src="http://dzliving.com/SymbolicBreakPoint.png" alt><br><img src="http://dzliving.com/NSObjectLoad.png" alt><br><img src="http://dzliving.com/ThreadStatck.png" alt><br></center>

<p>由上可知，load 的加载是从 <code>__dyld_start</code> 这个函数开始的。</p>
<h4 id="3-1-dyld-start"><a href="#3-1-dyld-start" class="headerlink" title="3.1 __dyld_start"></a>3.1 __dyld_start</h4><p>系统内核在加载动态库前，会加载 dyld，然后调用去执行 __dyld_start（汇编语言实现）。该函数会执行 dyldbootstrap::start()，后者会执行 _main()函数，dyld 的加载动态库的代码就是从_main()开始执行的。这里可以查看 dyldStartup.s的部分内容（以x86_x64架构做参考)，其中标出了 _dyld_start() 与 dyldbootstrap 的 start 方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	.data</span><br><span class="line">	.align <span class="number">3</span></span><br><span class="line">__dyld_start_static:</span><br><span class="line">	.quad   __dyld_start</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	.text</span><br><span class="line">	.align <span class="number">2</span>,<span class="number">0x90</span></span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	popq	%rdi		# param1 = mh of app</span><br><span class="line">	pushq	$<span class="number">0</span>		# push a zero <span class="keyword">for</span> debugger end of frames marker</span><br><span class="line">	movq	%rsp,%rbp	# pointer to base of kernel frame</span><br><span class="line">	andq    $<span class="number">-16</span>,%rsp       # force SSE alignment</span><br><span class="line">	subq	$<span class="number">16</span>,%rsp	# room <span class="keyword">for</span> local variables</span><br><span class="line"></span><br><span class="line">	# call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">	movl	<span class="number">8</span>(%rbp),%esi	# param2 = argc into %esi</span><br><span class="line">	leaq	<span class="number">16</span>(%rbp),%rdx	# param3 = &amp;argv[<span class="number">0</span>] into %rdx</span><br><span class="line">	movq	__dyld_start_static(%rip), %r8</span><br><span class="line">	leaq	__dyld_start(%rip), %rcx</span><br><span class="line">	subq	 %r8, %rcx	# param4 = slide into %rcx</span><br><span class="line">	leaq	___dso_handle(%rip),%r8 # param5 = dyldsMachHeader</span><br><span class="line">	leaq	<span class="number">-8</span>(%rbp),%r9</span><br><span class="line">	call	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	movq	<span class="number">-8</span>(%rbp),%rdi</span><br><span class="line">	cmpq	$<span class="number">0</span>,%rdi</span><br><span class="line">	jne	Lnew</span><br><span class="line"></span><br><span class="line">    	# clean up <span class="built_in">stack</span> <span class="keyword">and</span> jump to <span class="string">"start"</span> in main executable</span><br><span class="line">	movq	%rbp,%rsp	# restore the unaligned <span class="built_in">stack</span> pointer</span><br><span class="line">	addq	$<span class="number">8</span>,%rsp 	# remove the mh argument, <span class="keyword">and</span> debugger end frame marker</span><br><span class="line">	movq	$<span class="number">0</span>,%rbp		# restore ebp back to zero</span><br><span class="line">	jmp	*%rax		# jump to the entry point</span><br><span class="line"></span><br><span class="line">	# LC_MAIN <span class="keyword">case</span>, <span class="built_in">set</span> up <span class="built_in">stack</span> <span class="keyword">for</span> call to main()</span><br></pre></td></tr></table></figure>
<h4 id="3-2-dyldInitialization-cpp"><a href="#3-2-dyldInitialization-cpp" class="headerlink" title="3.2 dyldInitialization.cpp"></a>3.2 dyldInitialization.cpp</h4><p>__dyld_start 内部调用 dyldbootstrap::start，位于 dyldInitialization.cpp。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span> start(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span><br><span class="line">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span><br><span class="line">				<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    <span class="comment">// ①、获取 dyld 对应的 slide</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">    shouldRebase = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        <span class="comment">// ②、通过 slide 对 dyld 进行 rebase</span></span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">    <span class="comment">// ③、mach 初始化</span></span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">    <span class="comment">// ④、栈溢出保护</span></span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">    <span class="comment">// ⑤、获取应用的 slide（appsSlide）</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ⑥、调用 dyld 的 main 函数</span></span><br><span class="line">	<span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-slide、rebase"><a href="#3-3-slide、rebase" class="headerlink" title="3.3 slide、rebase"></a>3.3 slide、rebase</h4><p>由于 apple 采用了 <a href="https://baike.baidu.com/item/aslr/5779647?fr=aladdin" target="_blank" rel="noopener">ASLR（Address space layout randomization）</a>技术，所以 Mach-O 每次加载到内存中的<font color="#cc0000">首地址是变化的</font>，此时想找到代码在内存中对应的地址需要重定位 rebase。rebase 要用到 slide 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  The kernel may have slid a Position Independent Executable</span><br><span class="line">//</span><br><span class="line">static uintptr_t slideOfMainExecutable(const struct macho_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    // Mach-O 文件中 load commands 数量</span><br><span class="line">	const uint32_t cmd_count = mh-&gt;ncmds;</span><br><span class="line">    </span><br><span class="line">    // 偏移地址到 load commands 的首地址</span><br><span class="line">	const struct load_command* const cmds = (struct load_command*)(((char*)mh)+sizeof(macho_header));</span><br><span class="line">	const struct load_command* cmd = cmds;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	for (uint32_t i = 0; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">        // 选中 cmd = LC_SEGMENT_COMMAND</span><br><span class="line">		if ( cmd-&gt;cmd == LC_SEGMENT_COMMAND ) &#123;</span><br><span class="line">			const struct macho_segment_command* segCmd = (struct macho_segment_command*)cmd;</span><br><span class="line">            // 实际对应 LC_SEGMENT_COMMAND(_TEXT)</span><br><span class="line">			if ( (segCmd-&gt;fileoff == 0) &amp;&amp; (segCmd-&gt;filesize != 0)) &#123;</span><br><span class="line">                </span><br><span class="line">                // Mach-O 文件首地址 - LC_SEGMENT_COMMAND(_TEXT).vmaddr</span><br><span class="line">				return (uintptr_t)mh - segCmd-&gt;vmaddr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        // 偏移 command 指针</span><br><span class="line">		cmd = (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><br><img src="http://dzliving.com/MachOTEXT.png" alt><br></center>

<p>应用本身的 Mach-O 及 dyld 采用的是 <code>slideOfMainExecutable</code> 的方式获取 slide。从上代码得知：side = Mach-O header 首地址 - Load Commands 中 __TEXT 段的 VM Address 的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_slide(<span class="keyword">const</span> mach_header* mh)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_slide(%p)\n"</span>, mh);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Mach-O 文件加载对象</span></span><br><span class="line">    <span class="keyword">const</span> MachOLoaded* mf = (MachOLoaded*)mh;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 mach 文件头没有 magic 值</span></span><br><span class="line">    <span class="keyword">if</span> ( !mf-&gt;hasMachOMagic() )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 MachOLoaded::getSlide() 方法</span></span><br><span class="line">    <span class="keyword">return</span> mf-&gt;getSlide();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> _dyld_get_image_vmaddr_slide(<span class="keyword">uint32_t</span> imageIndex)</span><br><span class="line">&#123;</span><br><span class="line">    log_apis(<span class="string">"_dyld_get_image_vmaddr_slide(%d)\n"</span>, imageIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到 Mach-O 文件</span></span><br><span class="line">    <span class="keyword">const</span> mach_header* mh = gAllImages.imageLoadAddressByIndex(imageIndex);</span><br><span class="line">    <span class="keyword">if</span> ( mh != <span class="literal">nullptr</span> )</span><br><span class="line">        <span class="comment">// 调用上面的方法</span></span><br><span class="line">        <span class="keyword">return</span> dyld3::_dyld_get_image_slide(mh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> MachOLoaded::getSlide() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 诊断对象。</span></span><br><span class="line">    Diagnostics diag;</span><br><span class="line">    __block <span class="keyword">intptr_t</span> slide = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环 load command</span></span><br><span class="line">    forEachLoadCommand(diag, ^(<span class="keyword">const</span> load_command* cmd, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 64 位</span></span><br><span class="line">        <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT_64 ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command_64* seg = (segment_command_64*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT_64(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT_64(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 32 位</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmd-&gt;cmd == LC_SEGMENT ) &#123;</span><br><span class="line">            <span class="keyword">const</span> segment_command* seg = (segment_command*)cmd;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// LC_SEGMENT(__TEXT)</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(seg-&gt;segname, <span class="string">"__TEXT"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="comment">// mach-O 首地址 - LC_SEGMENT(__TEXT).vmaddr</span></span><br><span class="line">                slide = (<span class="keyword">uintptr_t</span>)(((<span class="keyword">uint64_t</span>)<span class="keyword">this</span>) - seg-&gt;vmaddr);</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    diag.assertNoError();   <span class="comment">// any malformations in the file should have been caught by earlier validate() call</span></span><br><span class="line">    <span class="keyword">return</span> slide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态库加载采用的是 <code>\_dyld\_get\_image\_vmaddr\_slide</code> 的方式获取 slide。</p>
<p>简单验证一下，以应用 Mach-O 为例：</p>
<ol>
<li><p>Load Commands __TEXT 段 VM Address 值。</p>
<p> <center><br> <img src="http://dzliving.com/MachOVMAddress.png" alt><br> </center></p>
<p> VM Address 的地址为 4294967296（10进制）。</p>
</li>
<li><p>在 Demo 项目中 ViewController.m <code>viewDidLoad</code> 方法设置断点，触发后，在 lldb 执行 <code>image list</code></p>
 <center><br> <img src="http://dzliving.com/ImageList.png" alt><br> </center>

<p> 应用 Mach-O 的地址为 0x00000001004f8000（16进制）。</p>
</li>
<li><p>计算 viewDidLoad 在应用 Mach-O 文件中的地址，<code>symbol address = stack address - slide</code>。</p>
 <center><br> <img src="http://dzliving.com/LLVMAddress.png" alt><br> </center>

<p> ①、用 Mach-O 的 VM Address 减去对应虚拟地址，得到的 5210112（10进制）为 slide 值；<br> ②、获取 viewDidLoad 函数在当前<font color="#cc0000">内存</font>中的地址；<br> ③、用 viewDidLoad 内存地址减去 slide 得到它在 Mach-O 中对应的虚拟地址；<br> ④、将 10 进制转化为 16 进制。</p>
<p> 计算得到地址：0x00000001000022c0</p>
</li>
<li><p>在 Mach-O 文件中查看。</p>
 <center><br> <img src="http://dzliving.com/ViewDidLoadAddress.png" alt><br> </center>

<p> 可以看到，通过计算得出的值 0x100001750 与 Mach-O 中看到的值一致。</p>
</li>
</ol>
<p>当然，也可以通过命令行直接获取 slide 的值。</p>
<h4 id="3-4-dyld-main"><a href="#3-4-dyld-main" class="headerlink" title="3.4 dyld::_main"></a>3.4 dyld::_main</h4><p>对 ASLR 有了基本认知后，接着看看位于 <code>dyld.cpp</code> 中的 _main 干了什么。</p>
<h5 id="3-4-1-设置运行环境"><a href="#3-4-1-设置运行环境" class="headerlink" title="3.4.1 设置运行环境"></a>3.4.1 设置运行环境</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which</span></span><br><span class="line"><span class="comment">// sets up some registers and call this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns address of main() in target program which __dyld_start jumps to</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">		<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">		<span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">		launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (<span class="keyword">uint64_t</span>)mainExecutableMH, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Grab the cdHash of the main executable from the environment</span></span><br><span class="line">	<span class="keyword">uint8_t</span> mainExecutableCDHashBuffer[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* mainExecutableCDHash = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> ( hexToBytes(_simple_getenv(apple, <span class="string">"executable_cdhash"</span>), <span class="number">40</span>, mainExecutableCDHashBuffer) )</span><br><span class="line">		<span class="comment">// 获取主程序 hash</span></span><br><span class="line">		mainExecutableCDHash = mainExecutableCDHashBuffer;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Trace dyld's load</span></span><br><span class="line">	<span class="comment">// 告知 kernel，dyld 已加载</span></span><br><span class="line">	notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, <span class="string">"dyld_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	<span class="comment">// Trace the main executable's load</span></span><br><span class="line">	<span class="comment">// 告知 kernel，主程序 Mach-O 已加载</span></span><br><span class="line">	notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, <span class="string">"executable_file"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uintptr_t</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 赋值参数。</span></span><br><span class="line">	<span class="comment">// mach_header 类型结构体，表示当前 App 的 Mach-O头部信息。有了头部信息，加载器就可以从头开始，遍历整个 Mach-O 文件的信息。</span></span><br><span class="line">	sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">	<span class="comment">// long 类型数据，表示 ASLR 位移长度</span></span><br><span class="line">	sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">	<span class="comment">// if this is host dyld, check to see if iOS simulator is being run</span></span><br><span class="line">	<span class="comment">// 获取 dyld 路径</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* rootPath = _simple_getenv(envp, <span class="string">"DYLD_ROOT_PATH"</span>);</span><br><span class="line">	<span class="keyword">if</span> ( (rootPath != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">		<span class="comment">// look to see if simulator has its own dyld</span></span><br><span class="line">		<span class="keyword">char</span> simDyldPath[PATH_MAX]; </span><br><span class="line">		strlcpy(simDyldPath, rootPath, PATH_MAX);</span><br><span class="line">		strlcat(simDyldPath, <span class="string">"/usr/lib/dyld_sim"</span>, PATH_MAX);</span><br><span class="line">		<span class="comment">// 打开 dyld_sim 路径</span></span><br><span class="line">		<span class="keyword">int</span> fd = my_open(simDyldPath, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 成功</span></span><br><span class="line">		<span class="keyword">if</span> ( fd != <span class="number">-1</span> ) &#123;</span><br><span class="line">			<span class="comment">// 如果是模拟器，并且正确加载`dyld_sim`，则直接返回主程序地址</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result);</span><br><span class="line">			<span class="keyword">if</span> ( errMessage != <span class="literal">NULL</span> )</span><br><span class="line">				halt(errMessage);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage(<span class="string">"dyld: launch started"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置一个全局链接上下文，包括一些回调函数、参数与标志设置信息，其中的 context 结构体实例、回调函数都是 dyld 自己的实现</span></span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">	<span class="comment">// 获取主程序路径</span></span><br><span class="line">	sExecPath = _simple_getenv(apple, <span class="string">"executable_path"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld</span></span><br><span class="line">	<span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取应用 Mach-O 文件的绝对路径</span></span><br><span class="line">	<span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">'/'</span> ) &#123;</span><br><span class="line">		<span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line">		<span class="keyword">char</span> cwdbuff[MAXPATHLEN];</span><br><span class="line">	    <span class="keyword">if</span> ( getcwd(cwdbuff, MAXPATHLEN) != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">			<span class="comment">// maybe use static buffer to avoid calling malloc so early...</span></span><br><span class="line">			<span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(cwdbuff) + <span class="built_in">strlen</span>(sExecPath) + <span class="number">2</span>];</span><br><span class="line">			<span class="built_in">strcpy</span>(s, cwdbuff);</span><br><span class="line">			<span class="built_in">strcat</span>(s, <span class="string">"/"</span>);</span><br><span class="line">			<span class="built_in">strcat</span>(s, sExecPath);</span><br><span class="line">			sExecPath = s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Remember short name of process for later logging</span></span><br><span class="line">	<span class="comment">// 设置进程名称</span></span><br><span class="line">	sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">'/'</span>);</span><br><span class="line">	<span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sExecShortName = sExecPath;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置进程受限模式。根据当前进程是否受限，再次配置链接上下文以及其他环境参数</span></span><br><span class="line">	configureProcessRestrictions(mainExecutableMH);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 再次检测/设置上下文环境</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">    <span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) &#123;</span><br><span class="line">		pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line">		<span class="comment">// set again because envp and apple may have changed or moved</span></span><br><span class="line">		setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#endif</span><br><span class="line">	&#123;</span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">	<span class="keyword">if</span> (  ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac)</span><br><span class="line">	  &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) &#123;</span><br><span class="line">		gLinkContext.rootPaths = parseColonList(<span class="string">"/System/iOSSupport"</span>, <span class="literal">NULL</span>);</span><br><span class="line">		gLinkContext.marzipan = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths )</span><br><span class="line">			sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths;</span><br><span class="line">		<span class="keyword">if</span> ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths )</span><br><span class="line">			sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果设置了DYLD_PRINT_OPTS，则打印参数</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果设置了DYLD_PRINT_ENV，则打印环境变量</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取主程序架构信息</span></span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>从源码可以看到，在模拟器运行程序时，通过 <code>dyld_sim</code> 来进行后续加载工作的，与正常真机加载流程略有不同。</p>
<p>模拟器：</p>
<center><br><img src="http://dzliving.com/DyldMainSim.png" alt><br></center>

<p>真机：</p>
<center><br><img src="http://dzliving.com/DyldMainPhone.png" alt><br></center>

<p>具体实现在 <code>useSimulatorDyld</code> 这个函数中，本文不做进一步解析。</p>
<p>这里还有一个知识点，环境变量 <font color="#cc0000"><code>DYLD_PRINT_OPTS</code></font> 与 <font color="#cc0000"><code>DYLD_PRINT_ENV</code></font>。在 processDyldEnvironmentVariable 方法中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_IMAGE_SUFFIX"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		gLinkContext.imageSuffix = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_INSERT_LIBRARIES"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		sEnv.DYLD_INSERT_LIBRARIES = parseColonList(value, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在 secheme 添加这两个环境变量，对应的字段会被设置为 true，并不需要设置 value。</p>
<center><br><img src="http://dzliving.com/DyldPrintSetting.png" alt><br><img src="http://dzliving.com/DyldPrintLog.png" alt><br></center>

<p>但是并非每个环境变量都不需要配置 value，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processDyldEnvironmentVariable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* key, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">const</span> <span class="keyword">char</span>* mainExecutableDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FRAMEWORK_PATH);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_FRAMEWORK_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_FRAMEWORK_PATH);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_LIBRARY_PATH);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(key, <span class="string">"DYLD_FALLBACK_LIBRARY_PATH"</span>) == <span class="number">0</span> ) &#123;</span><br><span class="line">		appendParsedColonList(value, mainExecutableDir, &amp;sEnv.DYLD_FALLBACK_LIBRARY_PATH);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h5 id="3-4-2-加载共享缓存"><a href="#3-4-2-加载共享缓存" class="headerlink" title="3.4.2 加载共享缓存"></a>3.4.2 加载共享缓存</h5><p>dyld3 与 dyld 不同点在 _main 方法中可以看出。在 dyld 的 _main 方法中，完成第一步以后会初始化主 App，然后加载共享缓存。到了 dyld3，调整了顺序：加载缓存的步骤可以划分为 mapSharedCache 和 checkVersionedPaths，先执行 mapSharedCache，然后加载主 App，最后checkVersionedPaths。（苹果在 2017 年发布的 dyld3，<a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">视频链接</a>）</p>
<p>对于共享缓存的理解：dyld 加载时，为了优化程序启动，启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被 dyld 映射到内存中，之后，当任何 Mach-O 映像加载时，dyld 首先会检查该 Mach-O 映像及所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// load shared cache</span></span><br><span class="line">	<span class="comment">// 检查共享缓存是否可用</span></span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	<span class="comment">// &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed</span></span><br><span class="line">	gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">	<span class="comment">// &lt;/HACK&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 非 Dont Use</span></span><br><span class="line">	<span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">		<span class="comment">// 映射共享缓存到共享区</span></span><br><span class="line">		mapSharedCache();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 缓存是否兼容（DyldSharedCache * loadAddress 为空 || 版本相同 -》YES）</span></span><br><span class="line">	<span class="keyword">bool</span> cacheCompatible = (sSharedCacheLoadInfo.loadAddress == <span class="literal">nullptr</span>) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//  设置了 DYLD_USE_CLOSURES || 在白名单</span></span><br><span class="line">	<span class="keyword">if</span> ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.verboseWarnings )</span><br><span class="line">			<span class="comment">// 不使用closure，因为共享缓存格式版本与 dyld 不匹配</span></span><br><span class="line">			dyld::<span class="built_in">log</span>(<span class="string">"dyld: not using closure because shared cache format version does not match dyld's\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// could not use closure info, launch old way</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// install gdb notifier</span></span><br><span class="line">	stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB);</span><br><span class="line">	stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages);</span><br><span class="line">	<span class="comment">// make initial allocations large enough that it is unlikely to need to be re-alloced</span></span><br><span class="line">	sImageRoots.reserve(<span class="number">16</span>);</span><br><span class="line">	sAddImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sRemoveImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sAddLoadImageCallbacks.reserve(<span class="number">4</span>);</span><br><span class="line">	sImageFilesNeedingTermination.reserve(<span class="number">16</span>);</span><br><span class="line">	sImageFilesNeedingDOFUnregistration.reserve(<span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WAIT_FOR_SYSTEM_ORDER_HANDSHAKE</span></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process</span></span><br><span class="line">	WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">		<span class="comment">// 添加 dyld 的 UUID 到共享缓存 UUID 列表中</span></span><br><span class="line">		addDyldImageToUUIDList();</span><br><span class="line">		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>检测共享缓存是否可用；</li>
<li>如果可用，映射共享缓存到共享区；</li>
<li>添加 dyld 的 UUID 到缓存列表。</li>
</ul>
<p>其中，检测共享缓存是否可用的函数 <font color="#cc0000"><code>checkSharedRegionDisable</code></font> 中有两句注释：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSharedRegionDisable</span><span class="params">(<span class="keyword">const</span> dyld3::MachOLoaded* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">	<span class="comment">// if main executable has segments that overlap the shared region, then disable using the shared region</span></span><br><span class="line">	<span class="comment">// 如果主程序 Mach-O 有 segments 与共享区重叠，那么共享区不可用。并且，iOS 不开启共享区无法运行。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 检测两者是否重叠</span></span><br><span class="line">	<span class="keyword">if</span> ( mainExecutableMH-&gt;intersectsRange(SHARED_REGION_BASE, SHARED_REGION_SIZE) ) &#123;</span><br><span class="line">		gLinkContext.sharedRegionMode = ImageLoader::kDontUseSharedRegion;</span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.verboseMapping )</span><br><span class="line">			dyld::warn(<span class="string">"disabling shared region because main executable overlaps\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line">	<span class="keyword">if</span> ( !gLinkContext.allowEnvVarsPath ) &#123;</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/15280847&gt; use private or no shared region for suid processes</span></span><br><span class="line">		gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// iOS cannot run without shared region</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体检测代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MachOLoaded::intersectsRange(<span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> length) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> slide = getSlide();</span><br><span class="line">    forEachSegment(^(<span class="keyword">const</span> SegmentInfo&amp; info, <span class="keyword">bool</span>&amp; stop) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            ①、主程序 segment 中的虚拟地址 + 虚拟地址大小 + 偏移量 &gt;= 共享区起始地址</span></span><br><span class="line"><span class="comment">            ②、主程序 segment 中的虚拟地址 + 偏移量 &lt; 共享区终止地址</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            ① 和 ② 同时 YES，那么认为主程序 Mach-O 有 segments 与共享区重叠，此时共享区不可用，从而动态库缓存不可用</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">            疑问：地址是从高到低分配？</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> ( (info.vmAddr+info.vmSize+slide &gt;= start) &amp;&amp; (info.vmAddr+slide &lt; start+length) )</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这段检测代码在满足重叠条件后，并没有设置 stop = true 停止 <font color="#cc0000"><code>forEachLoadCommand</code></font> 中的循环，这里值得深究和讨论。</p>
<p>加载共享缓存最核心的步骤在 <font color="#cc0000"><code>mapSharedCache</code></font> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mapSharedCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dyld3::SharedCacheOptions opts;</span><br><span class="line">	opts.cacheDirOverride	= sSharedCacheOverrideDir;</span><br><span class="line">	opts.forcePrivate		= (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __x86_64__ &amp;&amp; !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	opts.useHaswell			= sHaswell;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	opts.useHaswell			= <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	opts.verbose			= gLinkContext.verboseMapping;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 加载 dyld 缓存</span></span><br><span class="line">	loadDyldCache(opts, &amp;sSharedCacheLoadInfo);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update global state</span></span><br><span class="line">	<span class="comment">// 更新进程的全局状态信息</span></span><br><span class="line">	<span class="keyword">if</span> ( sSharedCacheLoadInfo.loadAddress != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">		gLinkContext.dyldCache 								= sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">		dyld::gProcessInfo-&gt;processDetachedFromSharedRegion = opts.forcePrivate;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheSlide                = sSharedCacheLoadInfo.slide;</span><br><span class="line">		dyld::gProcessInfo-&gt;sharedCacheBaseAddress          = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)sSharedCacheLoadInfo.loadAddress;</span><br><span class="line">		sSharedCacheLoadInfo.loadAddress-&gt;getUUID(dyld::gProcessInfo-&gt;sharedCacheUUID);</span><br><span class="line">		dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_SHARED_CACHE_A, (<span class="keyword">const</span> <span class="keyword">uuid_t</span> *)&amp;dyld::gProcessInfo-&gt;sharedCacheUUID[<span class="number">0</span>], &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;&#123; <span class="number">0</span>, <span class="number">0</span> &#125;&#125;, (<span class="keyword">const</span> mach_header *)sSharedCacheLoadInfo.loadAddress);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SharedCacheRuntime.cpp 文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">loadDyldCache</span><span class="params">(<span class="keyword">const</span> SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    results-&gt;loadAddress        = <span class="number">0</span>;</span><br><span class="line">    results-&gt;slide              = <span class="number">0</span>;</span><br><span class="line">    results-&gt;errorMessage       = <span class="literal">nullptr</span>;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">    <span class="comment">// simulator only supports mmap()ing cache privately into process</span></span><br><span class="line">    <span class="comment">// 模拟器只支持 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">    <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> ( options.forcePrivate ) &#123;</span><br><span class="line">        <span class="comment">// mmap cache into this process only</span></span><br><span class="line">        <span class="comment">// 只加载 mmap（内存映射） 缓存到当前进程</span></span><br><span class="line">        <span class="keyword">return</span> mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fast path: when cache is already mapped into shared region</span></span><br><span class="line">        <span class="keyword">bool</span> hasError = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 已加载过的</span></span><br><span class="line">        <span class="keyword">if</span> ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError = (results-&gt;errorMessage != <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未加载过的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// slow path: this is first process to load cache</span></span><br><span class="line">            hasError = mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasError;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载缓存分三种情况：</p>
<p>①、仅加载到当前进程。通过 <code>mapCachePrivate()</code> 加载并返回错误信息；<br>②、已经加载过的。通过 <code>reuseExistingCache()</code> 加载并返回错误信息，同时返回是否加载过 BOOL 值；<br>③、未加载过的。通过 <code>mapCacheSystemWide()</code> 加载缓存并映射，返回错误信息。</p>
<p>options.forcePrivate 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dyld.cpp</span></span><br><span class="line">opts.forcePrivate = (gLinkContext.sharedRegionMode == ImageLoader::kUsePrivateSharedRegion)</span><br><span class="line">	</span><br><span class="line">gLinkContext.sharedRegionMode		= ImageLoader::kUseSharedRegion;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// ImageLoader.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageLoader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">enum</span> SharedRegionMode &#123; kUseSharedRegion, kUsePrivateSharedRegion, kDontUseSharedRegion, kSharedRegionIsSharedCache &#125;;</span><br><span class="line">	</span><br><span class="line">		...		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gLinkContext.sharedRegionMode 在 setContext() 方法中设置默认值，默认值为 kUseSharedRegion，也就是之前检测共享区是否可用的标识值。</p>
<h5 id="3-4-3-实例化主程序"><a href="#3-4-3-实例化主程序" class="headerlink" title="3.4.3 实例化主程序"></a>3.4.3 实例化主程序</h5><p>系统会对已经映射到进程空间的主程序（在 XNU 解析 MachO 阶段就完成了映射操作）创建一个ImageLoaderMachO，再将其加入到 master list 中（sAllImages）。如果加载的 MachO 的硬件架构与本设备相符，就执行 imageLoader 的创建和添加操作。其中主要实现是ImageLoaderMachO::instantiateMainExecutable方法，该方法将主 App 的 MachHeader、ASLR，文件路径和前面提到的链接上下文作为参数，做 imageLoader 的实例化操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">  		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		<span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">		<span class="comment">// 实例化主程序</span></span><br><span class="line">		sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">		gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">		<span class="comment">// 代码签名</span></span><br><span class="line">		gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">		<span class="comment">// check main executable is not too new for this OS</span></span><br><span class="line">		<span class="comment">// 检测主程序是否支持当前设备版本</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 检查是否是模拟器二进制文件</span></span><br><span class="line">			<span class="keyword">if</span> ( ! isSimulatorBinary((<span class="keyword">uint8_t</span>*)mainExecutableMH, sExecPath) ) &#123;</span><br><span class="line">				throwf(<span class="string">"program was built for a platform that is not supported by this runtime"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">uint32_t</span> mainMinOS = sMainExecutable-&gt;minOSVersion();</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// dyld is always built for the current OS, so we can get the current OS version</span></span><br><span class="line">			<span class="comment">// from the load command in dyld itself.</span></span><br><span class="line">			<span class="comment">// 获取 dyld 中存储的当前 OS 版本</span></span><br><span class="line">			<span class="keyword">uint32_t</span> dyldMinOS = ImageLoaderMachO::minOSVersion((<span class="keyword">const</span> mach_header*)&amp;__dso_handle);</span><br><span class="line">			<span class="comment">// 应用 mach-O 文件的版本超过了当前模拟器设备的版本，抛出异常</span></span><br><span class="line">			<span class="keyword">if</span> ( mainMinOS &gt; dyldMinOS ) &#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WATCH</span></span><br><span class="line">				throwf(<span class="string">"app was built for watchOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">						mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">						dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> TARGET_OS_TV</span></span><br><span class="line">				throwf(<span class="string">"app was built for tvOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">						mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">						dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">				throwf(<span class="string">"app was built for iOS %d.%d which is newer than this simulator %d.%d"</span>,</span><br><span class="line">						mainMinOS &gt;&gt; <span class="number">16</span>, ((mainMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>),</span><br><span class="line">						dyldMinOS &gt;&gt; <span class="number">16</span>, ((dyldMinOS &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>));</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries</span></span><br><span class="line">		<span class="keyword">uint32_t</span> mainSDK = sMainExecutable-&gt;sdkVersion();</span><br><span class="line">		gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">// simulators, iOS, tvOS, and watchOS are always strict</span></span><br><span class="line">		gLinkContext.strictMachORequired = <span class="literal">true</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES</span></span><br><span class="line">		sAllImages.reserve((sAllCacheImagesProxy != <span class="literal">NULL</span>) ? <span class="number">16</span> : INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		sAllImages.reserve(INITIAL_IMAGE_COUNT);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Now that shared cache is loaded, setup an versioned dylib overrides</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_VERSIONED_PATHS</span></span><br><span class="line">		checkVersionedPaths(); <span class="comment">// 设置加载的动态库版本。这里的动态库还没有包括经 DYLD_INSERT_LIBRARIES 插入的库。</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// dyld_all_image_infos image list does not contain dyld</span></span><br><span class="line">		<span class="comment">// add it as dyldPath field in dyld_all_image_infos</span></span><br><span class="line">		<span class="comment">// for simulator, dyld_sim is in image list, need host dyld added</span></span><br><span class="line">		<span class="comment">// dyld 加载的 image_infos 并不包含 dyld 本身，它被放到 dyld_all_image_infos 的 dyldPath 字段中去了。而对于模拟器，dyld 加载的 image_infos 是包含 dyld_sim 的。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">		<span class="comment">// get path of host dyld from table of syscall vectors in host dyld</span></span><br><span class="line">		<span class="keyword">void</span>* addressInDyld = gSyscallHelpers;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">// get path of dyld itself</span></span><br><span class="line">		<span class="keyword">void</span>*  addressInDyld = (<span class="keyword">void</span>*)&amp;__dso_handle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 获取 dyld 路径并与 gProcessInfo-&gt;dyldPath 对比</span></span><br><span class="line">		<span class="keyword">char</span> dyldPathBuffer[MAXPATHLEN+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> len = proc_regionfilename(getpid(), (<span class="keyword">uint64_t</span>)(<span class="keyword">long</span>)addressInDyld, dyldPathBuffer, MAXPATHLEN);</span><br><span class="line">		<span class="keyword">if</span> ( len &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			dyldPathBuffer[len] = <span class="string">'\0'</span>; <span class="comment">// proc_regionfilename() does not zero terminate returned string</span></span><br><span class="line">			<span class="comment">// 如果不同将获取到的路径复制给 gProcessInfo-&gt;dyldPath</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != <span class="number">0</span> )</span><br><span class="line">				gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#cc0000"><code>dyld_all_image_infos</code></font> 是个结构体，同样分为 32 位和 64 位两个版本，分别对应 dyld_all_image_infos_32 与 dyld_all_image_infos_64，由于获取 dyld_all_image_infos 需要用到一些未开源信息，这里为了方便，从侧面验证一下这条注释信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); ++i) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%s"</span>, _dyld_get_image_name(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟器：</p>
<center><br><img src="http://dzliving.com/DyldSimAllImageInfo.png" alt><br></center>

<p>真机：</p>
<center><br><img src="http://dzliving.com/DyldPhoneAllImageInfo.png" alt><br></center>

<p>可以看到：模拟器打印的 image 没有 dyld，第 0 个 image 是 dyld_sim，第一个 image 才是主程序；真机打印出的加载 image 中也没有 dyld，第 0 个 image 是主程序。</p>
<p>回到最核心的 <font color="#cc0000"><code>instantiateFromLoadedImage</code></font> 实例化主程序函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="comment">// kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化成 ImageLoader 加载到内存中交给 dyld 管理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="comment">// CPU 架构是否匹配</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		<span class="comment">// 实例化 ImageLoader 对象。参数：macho header、ASLR、执行路径、链接上下文</span></span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		<span class="comment">// 分配主程序image的内存，更新。</span></span><br><span class="line">		addImage(image);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kernel 在 dyld 之前已经映射了主程序 Mach-O，dyld 判断 Mach-O 的兼容性后，实例化ImageLoader 对象，加载到内存，返回交给 dyld 管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//dyld::log("ImageLoader=%ld, ImageLoaderMachO=%ld, ImageLoaderMachOClassic=%ld, ImageLoaderMachOCompressed=%ld\n",</span></span><br><span class="line">	<span class="comment">//	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span></span><br><span class="line">	<span class="keyword">bool</span> compressed;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> libCount;</span><br><span class="line">	<span class="keyword">const</span> linkedit_data_command* codeSigCmd;</span><br><span class="line">	<span class="keyword">const</span> encryption_info_command* encryptCmd;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// sniffLoadCommands 函数会对主程序 Mach-O进 行一系列的校验：对代码签名，MachO加密，动态库数量，段的数量相关信息的 loadCommand 做解析，提取出 command 数据。</span></span><br><span class="line">	<span class="comment">/*      case LC_DYLD_INFO:</span></span><br><span class="line"><span class="comment">	 	case LC_DYLD_INFO_ONLY:</span></span><br><span class="line"><span class="comment">	 		*compressed = true;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sniffLoadCommands(mh, path, <span class="literal">false</span>, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">	<span class="comment">// instantiate concrete class based on content of load commands</span></span><br><span class="line">	<span class="comment">// 已解密</span></span><br><span class="line">	<span class="keyword">if</span> ( compressed ) </span><br><span class="line">		<span class="comment">// Compressed</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line">		<span class="comment">// Classic</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"missing LC_DYLD_INFO load command"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sniffLoadCommands 的校验并不包括对主程序 Mach-O 的解密操作，解密操作是由 xnu 完成的。</p>
<p>ImageLoaderMachOCompressed::instantiateMainExecutable、ImageLoaderMachOClassic::instantiateMainExecutable 两者内部的逻辑相同，只是返回类型一个是 ImageLoaderMachOCompressed 一个是 ImageLoaderMachOClassic。</p>
<p>以 ImageLoaderMachOCompressed 为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image for main executable</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateMainExecutable(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path, </span><br><span class="line">																		<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, <span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化 image</span></span><br><span class="line">	ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart(mh, path, segCount, libCount);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// set slide for PIE programs</span></span><br><span class="line">	<span class="comment">// 设置 image 偏移量</span></span><br><span class="line">	image-&gt;setSlide(slide);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// for PIE record end of program, to know where to start loading dylibs</span></span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> )</span><br><span class="line">		<span class="comment">// 设置动态库起始地址</span></span><br><span class="line">		fgNextPIEDylibAddress = (<span class="keyword">uintptr_t</span>)image-&gt;getEnd();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 禁用段覆盖检测</span></span><br><span class="line">	image-&gt;disableCoverageCheck();</span><br><span class="line">	<span class="comment">// 结束 image 上下文</span></span><br><span class="line">	image-&gt;instantiateFinish(context);</span><br><span class="line">	<span class="comment">// 设置 image 加载状态为 dyld_image_state_mapped</span></span><br><span class="line">	image-&gt;setMapped(context);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( context.verboseMapping ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: Main executable mapped %s\n"</span>, path);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* name = image-&gt;segName(i);</span><br><span class="line">			<span class="keyword">if</span> ( (<span class="built_in">strcmp</span>(name, <span class="string">"__PAGEZERO"</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(name, <span class="string">"__UNIXSTACK"</span>) == <span class="number">0</span>)  )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segPreferredLoadAddress(i), image-&gt;segPreferredLoadAddress(i)+image-&gt;segSize(i));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"%18s at 0x%08lX-&gt;0x%08lX\n"</span>, name, image-&gt;segActualLoadAddress(i), image-&gt;segActualEndAddress(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::setMapped(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	fState = dyld_image_state_mapped;</span><br><span class="line">	context.notifySingle(dyld_image_state_mapped, <span class="keyword">this</span>, <span class="literal">NULL</span>);  <span class="comment">// note: can throw exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instantiateFinish() 在内部解析 loadCmds、设置动态库连接信息、设置符号表相关信息等。setMapped() 内部调用 notifySingle 进行处理。</p>
<h5 id="3-4-4-加载插入的动态库"><a href="#3-4-4-加载插入的动态库" class="headerlink" title="3.4.4 加载插入的动态库"></a>3.4.4 加载插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// load any inserted libraries</span></span><br><span class="line">	<span class="comment">// 插入动态库</span></span><br><span class="line">	<span class="keyword">if</span>	( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">			loadInsertedDylib(*lib);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// record count of inserted libraries so that a flat search will look at </span></span><br><span class="line">	<span class="comment">// inserted libraries, then main, then others.</span></span><br><span class="line">	<span class="comment">// 记录插入的动态库个数</span></span><br><span class="line">	sInsertedDylibCount = sAllImages.size()<span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果配置了 <font color="#cc0000"><code>DYLD_INSERT_LIBRARIES</code></font> 环境变量，通过loadInsertedDylib() 方法插入配置的动态库。对于越狱插件而言，其实就是通过添加 DYLD_INSERT_LIBRARIES 这个环境变量达到加载插件的目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInsertedDylib</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ImageLoader* image = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> cacheIndex;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		LoadContext context;</span><br><span class="line">		context.useSearchPaths		= <span class="literal">false</span>;</span><br><span class="line">		context.useFallbackPaths	= <span class="literal">false</span>;</span><br><span class="line">		context.useLdLibraryPath	= <span class="literal">false</span>;</span><br><span class="line">		context.implicitRPath		= <span class="literal">false</span>;</span><br><span class="line">		context.matchByInstallName	= <span class="literal">false</span>;</span><br><span class="line">		context.dontLoad			= <span class="literal">false</span>;</span><br><span class="line">		context.mustBeBundle		= <span class="literal">false</span>;</span><br><span class="line">		context.mustBeDylib			= <span class="literal">true</span>;</span><br><span class="line">		context.canBePIE			= <span class="literal">false</span>;</span><br><span class="line">		context.enforceIOSMac		= <span class="literal">true</span>;</span><br><span class="line">		context.origin				= <span class="literal">NULL</span>;	<span class="comment">// can't use @loader_path with DYLD_INSERT_LIBRARIES</span></span><br><span class="line">		context.rpath				= <span class="literal">NULL</span>;</span><br><span class="line">		image = load(path, context, cacheIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.allowInsertFailures )</span><br><span class="line">			dyld::<span class="built_in">log</span>(<span class="string">"dyld: warning: could not load inserted library '%s' into hardened process because %s\n"</span>, path, msg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s' because %s\n"</span>, path, msg));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		halt(dyld::mkstringf(<span class="string">"could not load inserted library '%s'\n"</span>, path));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部构建 context 后调用 load() 函数生成 image。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief  做路径展开，搜索查找，排重，以及缓存查找工作。其中路径的展开和搜索分几个阶段（phase）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">ImageLoader* <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context, <span class="keyword">unsigned</span>&amp; cacheIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 查找 image</span></span><br><span class="line">	ImageLoader* image = loadPhase0(path, orgPath, context, cacheIndex, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 没有找到</span></span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="comment">// 继续查找</span></span><br><span class="line">		CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try all path permutations and try open() until first success</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; exceptions;</span><br><span class="line">	image = loadPhase0(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/16704628&gt; support symlinks on disk to a path in dyld shared cache</span></span><br><span class="line">	<span class="comment">// 在共享缓存中查找</span></span><br><span class="line">	<span class="keyword">if</span> ( image == <span class="literal">NULL</span>)</span><br><span class="line">		image = loadPhase2cache(path, orgPath, context, cacheIndex, &amp;exceptions);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> ( image != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/6916014&gt; leak in dyld during dlopen when using DYLD_ variables</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;::iterator it = exceptions.begin(); it != exceptions.end(); ++it) &#123;</span><br><span class="line">			<span class="built_in">free</span>((<span class="keyword">void</span>*)(*it));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if loaded image is not from cache, but original path is in cache</span></span><br><span class="line">		<span class="comment">// set gSharedCacheOverridden flag to disable some ObjC optimizations</span></span><br><span class="line">		<span class="keyword">if</span> ( !gSharedCacheOverridden &amp;&amp; !image-&gt;inSharedCache() &amp;&amp; image-&gt;isDylib() &amp;&amp; cacheablePath(path) &amp;&amp; inSharedCache(path) ) &#123;</span><br><span class="line">			gSharedCacheOverridden = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>load 方法不仅被 loadInsertedDylib 调用，也会被 dlopen 等运行时加载动态库的方法使用。</p>
<p>内部有一整套 loadPhase0~loadPhase6 的流程来查找及加载 image。如果在共享缓存中找到则直接调用 instantiateFromCache 实例化 image，否则通过 loadPhase5open 打开文件并调用loadPhase6，内部通过 instantiateFromFile 实例化 image，最后再调用 checkandAddImage 将image 加载进内存。</p>
<p> 这些 phase 的搜索路径对应各个环境变量：DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p>
<p> ImageLoaderMachO 的 <code>instantiateFromFile</code>、<code>instantiateFromCache</code> 是 loader 将 MachO 文件解析映射到内存的核心方法，两个都会进入 Compressed 和 Classic 的分叉步骤。以 Compressed 下的 instantiateFromFile 来分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create image by mapping in a mach-o file</span></span><br><span class="line">ImageLoaderMachOCompressed* ImageLoaderMachOCompressed::instantiateFromFile(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* fileData, <span class="keyword">size_t</span> lenFileData,</span><br><span class="line">														<span class="keyword">uint64_t</span> offsetInFat, <span class="keyword">uint64_t</span> lenInFat, <span class="keyword">const</span> struct stat&amp; info, </span><br><span class="line">														<span class="keyword">unsigned</span> <span class="keyword">int</span> segCount, <span class="keyword">unsigned</span> <span class="keyword">int</span> libCount, </span><br><span class="line">														<span class="keyword">const</span> struct linkedit_data_command* codeSigCmd, </span><br><span class="line">														<span class="keyword">const</span> struct encryption_info_command* encryptCmd, </span><br><span class="line">														<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">		ImageLoaderMachOCompressed* image = ImageLoaderMachOCompressed::instantiateStart((macho_header*)fileData, path, segCount, libCount);</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// record info about file  </span></span><br><span class="line">			image-&gt;setFileInfo(info.st_dev, info.st_ino, info.st_mtime);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// if this image is code signed, let kernel validate signature before mapping any pages from image</span></span><br><span class="line">			<span class="comment">// ①、交给内核去验证动态库的代码签名</span></span><br><span class="line">			image-&gt;loadCodeSignature(codeSigCmd, fd, offsetInFat, context);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Validate that first data we read with pread actually matches with code signature</span></span><br><span class="line">			<span class="comment">// ②、映射到内存的 first page, （4k大小）与代码签名是否match。在这里会执行沙盒，签名认证</span></span><br><span class="line">			image-&gt;validateFirstPages(codeSigCmd, fd, fileData, lenFileData, offsetInFat, context);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// mmap segments</span></span><br><span class="line">			image-&gt;mapSegments(fd, offsetInFat, lenInFat, info.st_size, context);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// if framework is FairPlay encrypted, register with kernel</span></span><br><span class="line">			<span class="comment">// 根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了内核代码，应该是根据cryptid是否为1做了解密操作。</span></span><br><span class="line">			image-&gt;registerEncryption(encryptCmd, context);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// probe to see if code signed correctly</span></span><br><span class="line">			image-&gt;crashIfInvalidCodeSignature();</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// finish construction</span></span><br><span class="line">			image-&gt;instantiateFinish(context);</span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中几个需要留意的步骤：</p>
<ul>
<li>交给内核去验证动态库的代码签名 loadCodeSignature。</li>
<li>映射到内存的 first page（4k 大小）与代码签名是否 match。在这里会执行沙盒，签名认证，对于在线上运行时加载动态库的需求，可以重点研究<a href="https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg" target="_blank" rel="noopener">这里</a>。</li>
<li>根据 DYLD_ENCRYPTION_INFO，让内核去注册加密信息 registerEncryption。在该方法中，会调用内核方法 mremap_encrypted，传入加密数据的地址和长度等数据，查看了<a href="http://newosxbook.com/src.jl?tree=xnu-3789.70.16&amp;file=bsd/kern/kern_mman.c#mremap_encrypted" target="_blank" rel="noopener">内核代码</a>，应该是根据 cryptid 是否为 1 做了解密操作。</li>
<li>如果走到 Phase6, 会调 xmap 函数将动态库从本地 mmap 到用户态内存空间。</li>
</ul>
<p>根据上面的分析，<font color="#cc0000">主程序 imageLoader 在全局 image 表的首位</font>，后面的是插入的动态库的 imageLoader，每个动态库对应一个 loader。</p>
<h5 id="3-4-5-链接主程序"><a href="#3-4-5-链接主程序" class="headerlink" title="3.4.5 链接主程序"></a>3.4.5 链接主程序</h5><p>链接所有动态库，进行符号修正绑定工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">        // link main executable</span><br><span class="line">        gLinkContext.linkingMainExecutable = true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">        if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">            // previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">            // work around that by rebasing by inverse amount</span><br><span class="line">            sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">                // 链接主程序</span><br><span class="line">        link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">        sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">        if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">            gLinkContext.bindFlat = true;</span><br><span class="line">            gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">        &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主程序的链接是通过 <code>link</code> 这个函数完成的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</span><br><span class="line">&#123;</span><br><span class="line">	// add to list of known images.  This did not happen at creation time for bundles</span><br><span class="line">	// 添加到已知镜像列表中。这在创建 bundles 时没有处理。</span><br><span class="line">	if ( image-&gt;isBundle() &amp;&amp; !image-&gt;isLinked() )</span><br><span class="line">		addImage(image);</span><br><span class="line">	</span><br><span class="line">	// we detect root images as those not linked in yet</span><br><span class="line">	// 在根镜像中检测是否尚未链接</span><br><span class="line">	if ( !image-&gt;isLinked() )</span><br><span class="line">		addRootImage(image);</span><br><span class="line">	</span><br><span class="line">	// process images</span><br><span class="line">	try &#123;</span><br><span class="line">		const char* path = image-&gt;getPath();</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">		if ( image == sAllCacheImagesProxy )</span><br><span class="line">			path = sAllCacheImagesProxy-&gt;getIndexedPath(cacheIndex);</span><br><span class="line">#endif</span><br><span class="line">		// 调用 ImageLoader::link() 链接</span><br><span class="line">		image-&gt;link(gLinkContext, forceLazysBound, false, neverUnload, loaderRPaths, path);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (const char* msg) &#123;</span><br><span class="line">		// 标记 image 为未使用，处理</span><br><span class="line">		garbageCollectImages();</span><br><span class="line">		throw;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">	//dyld::log(&quot;ImageLoader::link(%s) refCount=%d, neverUnload=%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span><br><span class="line">	</span><br><span class="line">	// clear error strings</span><br><span class="line">	(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line">	</span><br><span class="line">	// 起始时间。用于记录时间间隔</span><br><span class="line">	uint64_t t0 = mach_absolute_time();</span><br><span class="line">	// ①、递归加载主程序依赖的库，完成之后发送一个状态为 dyld_image_state_dependents_mapped的通知。</span><br><span class="line">	this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line">	</span><br><span class="line">	// we only do the loading step for preflights  只做预检的装载步骤</span><br><span class="line">	if ( preflightOnly )</span><br><span class="line">		return;</span><br><span class="line">	</span><br><span class="line">	uint64_t t1 = mach_absolute_time();</span><br><span class="line">	// 清空 image 层级关系</span><br><span class="line">	context.clearAllDepths();</span><br><span class="line">	// 递归更新 image 层级关系</span><br><span class="line">	this-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line">	</span><br><span class="line">	__block uint64_t t2, t3, t4, t5;</span><br><span class="line">	&#123;</span><br><span class="line">		dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);</span><br><span class="line">		t2 = mach_absolute_time();</span><br><span class="line">		// ②、递归修正自己和依赖库的基地址，因为 ASLR 的原因，需要根据随机 slide 修正基地址。</span><br><span class="line">		this-&gt;recursiveRebase(context);</span><br><span class="line">		context.notifyBatch(dyld_image_state_rebased, false);</span><br><span class="line">	</span><br><span class="line">		t3 = mach_absolute_time();</span><br><span class="line">		if ( !context.linkingMainExecutable )</span><br><span class="line">			// ③、递归绑定 noLazy 的符号表，lazy的符号会在运行时动态绑定（首次被调用才去绑定）</span><br><span class="line">			this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line">	</span><br><span class="line">		t4 = mach_absolute_time();</span><br><span class="line">		if ( !context.linkingMainExecutable )</span><br><span class="line">			// ④、绑定弱符号表，比如未初始化的全局变量就是弱符号。</span><br><span class="line">			this-&gt;weakBind(context);</span><br><span class="line">		t5 = mach_absolute_time();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    if ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, false);</span><br><span class="line">	uint64_t t6 = mach_absolute_time();	</span><br><span class="line">	</span><br><span class="line">	std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line">	// ⑤、递归获取/注册程序的 DOF 节区，dtrace 会用其动态跟踪。</span><br><span class="line">	this-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">	// 注册</span><br><span class="line">	context.registerDOFs(dofs);</span><br><span class="line">	uint64_t t7 = mach_absolute_time();	</span><br><span class="line">	</span><br><span class="line">	// interpose any dynamically loaded images</span><br><span class="line">	if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != 0) ) &#123;</span><br><span class="line">		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);</span><br><span class="line">		// 递归应用插入的动态库</span><br><span class="line">		this-&gt;recursiveApplyInterposing(context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// clear error strings</span><br><span class="line">	(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line">	</span><br><span class="line">	// 计算出各种时间间隔</span><br><span class="line">	fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">	fgTotalRebaseTime += t3 - t2;</span><br><span class="line">	fgTotalBindTime += t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">	fgTotalDOF += t7 - t6;</span><br><span class="line">	</span><br><span class="line">	// done with initial dylib loads</span><br><span class="line">	fgNextPIEDylibAddress = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部加载动态库、rebase、绑定符号表、注册dofs信息等，同时还计算各步骤的耗时。如果想获取这些耗时，只需要在环境变量中添加 <font color="#cc0000"><code>DYLD_PRINT_STATISTICS</code></font> 就可以了，这个环境变量不需要 value。</p>
<p>在步骤 ① 里，递归加载主 App 在打包阶段就确定好的动态库的操作，会使用前面提到的 setContext 里的链接上下文，调用它的 loadLibrary 方法；然后优先去加载依赖的动态库。loadLibary 的实现在设置链接上下文的时候就已经赋值确定，即 libraryLocator，在这个方法里会用到上面提到的 load 方法。</p>
<p>在步骤 ③ 里，会有符号绑定的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief   recursiveBind 完成递归绑定符号表的操作。此处的符号表针对的是非延迟加载的符号表，对于 DYLD_BIND_AT_LAUNCH 等特殊情况下的 non-lazy 符号才执行立即绑定。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::recursiveBind(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> neverUnload)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Normally just non-lazy pointers are bound immediately.</span></span><br><span class="line">	<span class="comment">// The exceptions are:</span></span><br><span class="line">	<span class="comment">//   1) DYLD_BIND_AT_LAUNCH will cause lazy pointers to be bound immediately</span></span><br><span class="line">	<span class="comment">//   2) some API's (e.g. RTLD_NOW) can cause lazy pointers to be bound immediately</span></span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_bound ) &#123;</span><br><span class="line">		<span class="comment">// break cycles</span></span><br><span class="line">		fState = dyld_image_state_bound;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// bind lower level libraries first</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = libImage(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> )</span><br><span class="line">					dependentImage-&gt;recursiveBind(context, forceLazysBound, neverUnload);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// bind this image</span></span><br><span class="line">			<span class="comment">// 绑定。this 表示递归调用时，recursiveBind 方法的调用者</span></span><br><span class="line">			<span class="keyword">this</span>-&gt;doBind(context, forceLazysBound);	</span><br><span class="line">			<span class="comment">// mark if lazys are also bound</span></span><br><span class="line">			<span class="keyword">if</span> ( forceLazysBound || <span class="keyword">this</span>-&gt;usablePrebinding(context) )</span><br><span class="line">				fAllLazyPointersBound = <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// mark as never-unload if requested</span></span><br><span class="line">			<span class="keyword">if</span> ( neverUnload )</span><br><span class="line">				<span class="keyword">this</span>-&gt;setNeverUnload();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 通知</span></span><br><span class="line">			context.notifySingle(dyld_image_state_bound, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// restore state</span></span><br><span class="line">			fState = dyld_image_state_rebased;</span><br><span class="line">            CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的核心是 ImageLoaderMach 的 doBind，读取 image 的动态链接信息的 bind_off 与 bind_size 来确定需要绑定的数据偏移与大小，然后挨个对它们进行绑定，绑定操作具体使用 <font color="#cc0000">bindAt</font> 函数；调用 resolve 解析完符号表后，调用 bindLocation 完成最终的绑定操作，需要绑定的符号信息有三种：</p>
<ul>
<li>BIND_TYPE_POINTER：需要绑定的是一个指针。直接将计算好的新值屿值即可。</li>
<li>BIND_TYPE_TEXT_ABSOLUTE32：一个32位的值。取计算的值的低32位赋值过去。</li>
<li>BIND_TYPE_TEXT_PCREL32：重定位符号。需要使用新值减掉需要修正的地址值来计算出重定位值。</li>
</ul>
<p>对延迟绑定的实现感兴趣的可以在Xcode中调试查看，或者参考<a href="https://leylfl.github.io/2018/05/28/dyld%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">这个</a>。</p>
<h5 id="3-4-6-链接插入的动态库"><a href="#3-4-6-链接插入的动态库" class="headerlink" title="3.4.6 链接插入的动态库"></a>3.4.6 链接插入的动态库</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="comment">// link any inserted libraries</span></span><br><span class="line">		<span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line">		<span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line">		<span class="comment">// 链接其他被插入的动态库</span></span><br><span class="line">		<span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="comment">// 循环处理</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				<span class="comment">// 链接</span></span><br><span class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">				<span class="comment">// 递归修改 image 的 fNeverUnload 属性</span></span><br><span class="line">				image-&gt;setNeverUnloadRecursive();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">			<span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">			<span class="comment">// 只有插入可插入的库。在绑定所有插入的库后注册插入信息，以便链接工作</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span></span><br><span class="line">		<span class="comment">// 即使没有 DYLD_INSERT_LIBRARIES，dyld 也应该支持插入</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i=sInsertedDylibCount+<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">			ImageLoader* image = sAllImages[i];</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;inSharedCache() )</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_ACCELERATE_TABLES  <span class="comment">// !TARGET_IPHONE_SIMULATOR，非模拟器</span></span></span><br><span class="line">		<span class="keyword">if</span> ( (sAllCacheImagesProxy != <span class="literal">NULL</span>) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line">			<span class="comment">// Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span></span><br><span class="line">			<span class="comment">// 加速键表不能与隐式插入一起使用，因此在禁用加速键表的情况下重新启动</span></span><br><span class="line">			ImageLoader::clearInterposingTuples();</span><br><span class="line">			<span class="comment">// unmap all loaded dylibs (but not main executable)</span></span><br><span class="line">			<span class="comment">// 取消映射所有加载的 dylib 文件，除了主程序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">1</span>; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i];</span><br><span class="line">				<span class="keyword">if</span> ( image == sMainExecutable )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span> ( image == sAllCacheImagesProxy )</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				image-&gt;setCanUnload();</span><br><span class="line">				ImageLoader::deleteImage(image);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span></span><br><span class="line">			sAllImages.clear();</span><br><span class="line">			sImageRoots.clear();</span><br><span class="line">			sImageFilesNeedingTermination.clear();</span><br><span class="line">			sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">			sAddImageCallbacks.clear();</span><br><span class="line">			sRemoveImageCallbacks.clear();</span><br><span class="line">			sAddLoadImageCallbacks.clear();</span><br><span class="line">			sDisableAcceleratorTables = <span class="literal">true</span>;</span><br><span class="line">			sAllCacheImagesProxy = <span class="literal">NULL</span>;  <span class="comment">// 下次不再进入</span></span><br><span class="line">			sMappedRangesStart = <span class="literal">NULL</span>;</span><br><span class="line">			mainExcutableAlreadyRebased = <span class="literal">true</span>;</span><br><span class="line">			gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">			resetAllImages();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 跳转回上面的步骤，重新执行，加载所有的镜像</span></span><br><span class="line">			<span class="keyword">goto</span> reloadAllImages;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// apply interposing to initial set of images</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line">			<span class="comment">// 是调用 ImageLoader::applyInterposing()，不是 ClosureWriter.cpp。内部递归，最终是执行 doInterpose() 方法</span></span><br><span class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 插入信息存入 dyld 缓存</span></span><br><span class="line">		ImageLoader::applyInterposingToDyldCache(gLinkContext);</span><br><span class="line">		<span class="comment">// 修改主程序插入标识</span></span><br><span class="line">		gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Bind and notify for the main executable now that interposing has been registered</span></span><br><span class="line">		<span class="comment">// 从主程序开始调用，递归执行绑定、通知（插入信息已经注册）</span></span><br><span class="line">		<span class="keyword">uint64_t</span> bindMainExecutableStartTime = mach_absolute_time();</span><br><span class="line">		<span class="comment">// 内部执行 doBind()、notifySingle()</span></span><br><span class="line">		sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">uint64_t</span> bindMainExecutableEndTime = mach_absolute_time();</span><br><span class="line">		<span class="comment">// 绑定和通知处理时间</span></span><br><span class="line">		ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime;</span><br><span class="line">		gLinkContext.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line">		<span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">				<span class="comment">// 绑定插入的动态库</span></span><br><span class="line">				image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里参与链接的动态库根据第 4 步中加载的插入的动态库，从 sAllImages 的第二个 imageLoader 开始，取出 image，重复 <code>link</code> 操作进行连接。registerInterposing 内部会加载 loadCmds 并查找 __interpose 及 __DATA 段，读取段信息保存到 fgInterposingTuples 中，然后调用 applyInterposing，内部调用 recursiveApplyInterposing，通过这个函数调用到 doInterpose。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoaderMachOCompressed::doInterpose(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( context.verboseInterposing )</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: interposing %lu tuples onto image: %s\n"</span>, fgInterposingTuples.size(), <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update prebound symbols。更新预绑定的符号</span></span><br><span class="line">	eachBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line">						<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line">						<span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">						ExtraBindData *extraBindData,</span><br><span class="line">						<span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line">		<span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">													   addend, libraryOrdinal, extraBindData,</span><br><span class="line">													   msg, last, runResolver);</span><br><span class="line">	&#125;);</span><br><span class="line">	eachLazyBind(context, ^(<span class="keyword">const</span> LinkContext&amp; ctx, ImageLoaderMachOCompressed* image,</span><br><span class="line">							<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint8_t</span> type, <span class="keyword">const</span> <span class="keyword">char</span>* symbolName,</span><br><span class="line">							<span class="keyword">uint8_t</span> symbolFlags, <span class="keyword">intptr_t</span> addend, <span class="keyword">long</span> libraryOrdinal,</span><br><span class="line">							ExtraBindData *extraBindData,</span><br><span class="line">							<span class="keyword">const</span> <span class="keyword">char</span>* msg, LastLookup* last, <span class="keyword">bool</span> runResolver) &#123;</span><br><span class="line">		<span class="comment">// 直接调用 interposeAt()</span></span><br><span class="line">		<span class="keyword">return</span> ImageLoaderMachOCompressed::interposeAt(ctx, image, addr, type, symbolName, symbolFlags,</span><br><span class="line">													   addend, libraryOrdinal, extraBindData,</span><br><span class="line">													   msg, last, runResolver);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interposeAt 通过 interposedAddress 在上文提到的 fgInterposingTuples 中找到需要替换的符号地址进行替换。</p>
<h5 id="3-4-7-弱符号绑定"><a href="#3-4-7-弱符号绑定" class="headerlink" title="3.4.7 弱符号绑定"></a>3.4.7 弱符号绑定</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">    <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">    <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">        <span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">        <span class="comment">// 弱符号绑定</span></span><br><span class="line">        sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ImageLoader::weakBind(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind start:\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="comment">// get set of ImageLoaders that participate in coalecsing</span></span><br><span class="line">	ImageLoader* imagesNeedingCoalescing[fgImagesRequiringCoalescing];</span><br><span class="line">	<span class="keyword">unsigned</span> imageIndexes[fgImagesRequiringCoalescing];</span><br><span class="line">	<span class="comment">// 合并所有动态库的弱符号到列表中</span></span><br><span class="line">	<span class="keyword">int</span> count = context.getCoalescedImages(imagesNeedingCoalescing, imageIndexes);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// count how many have not already had weakbinding done</span></span><br><span class="line">	<span class="keyword">int</span> countNotYetWeakBound = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> countOfImagesWithWeakDefinitionsNotInSharedCache = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;weakSymbolsBound(imageIndexes[i]) )</span><br><span class="line">			<span class="comment">// 获取未进行绑定的弱符号的个数</span></span><br><span class="line">			++countNotYetWeakBound;</span><br><span class="line">		<span class="keyword">if</span> ( ! imagesNeedingCoalescing[i]-&gt;inSharedCache() )</span><br><span class="line">			<span class="comment">// 获取在共享缓存中已绑定的弱符号个数</span></span><br><span class="line">			++countOfImagesWithWeakDefinitionsNotInSharedCache;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// don't need to do any coalescing if only one image has overrides, or all have already been done</span></span><br><span class="line">	<span class="keyword">if</span> ( (countOfImagesWithWeakDefinitionsNotInSharedCache &gt; <span class="number">0</span>) &amp;&amp; (countNotYetWeakBound &gt; <span class="number">0</span>) ) &#123;</span><br><span class="line">		<span class="comment">// make symbol iterators for each</span></span><br><span class="line">		ImageLoader::CoalIterator iterators[count];</span><br><span class="line">		ImageLoader::CoalIterator* sortedIts[count];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">			<span class="comment">// 对需要绑定的弱符号排序</span></span><br><span class="line">			imagesNeedingCoalescing[i]-&gt;initializeCoalIterator(iterators[i], i, imageIndexes[i]);</span><br><span class="line">			sortedIts[i] = &amp;iterators[i];</span><br><span class="line">			<span class="keyword">if</span> ( context.verboseWeakBind )</span><br><span class="line">				dyld::<span class="built_in">log</span>(<span class="string">"dyld: weak bind load order %d/%d for %s\n"</span>, i, count, imagesNeedingCoalescing[i]-&gt;getIndexedPath(imageIndexes[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// walk all symbols keeping iterators in sync by </span></span><br><span class="line">		<span class="comment">// only ever incrementing the iterator with the lowest symbol </span></span><br><span class="line">		<span class="keyword">int</span> doneCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ( doneCount != count ) &#123;</span><br><span class="line">			<span class="comment">//for(int i=0; i &lt; count; ++i)</span></span><br><span class="line">			<span class="comment">//	dyld::log("sym[%d]=%s ", sortedIts[i]-&gt;loadOrder, sortedIts[i]-&gt;symbolName);</span></span><br><span class="line">			<span class="comment">//dyld::log("\n");</span></span><br><span class="line">			<span class="comment">// increment iterator with lowest symbol</span></span><br><span class="line">			<span class="comment">// 计算弱符号偏移量及大小，绑定弱符号</span></span><br><span class="line">			<span class="keyword">if</span> ( sortedIts[<span class="number">0</span>]-&gt;image-&gt;incrementCoalIterator(*sortedIts[<span class="number">0</span>]) )</span><br><span class="line">				++doneCount; </span><br><span class="line">			...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程：合并所有动态库的弱符号到列表中 -&gt; 对需要绑定的弱符号排序 -&gt; 计算弱符号偏移量及大小，绑定弱符号</p>
<h5 id="3-4-8-初始化主程序"><a href="#3-4-8-初始化主程序" class="headerlink" title="3.4.8 初始化主程序"></a>3.4.8 初始化主程序</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">_main(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">uintptr_t</span> mainExecutableSlide, </span><br><span class="line">        <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[], </span><br><span class="line">        <span class="keyword">uintptr_t</span>* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		CRSetCrashLogMessage(<span class="string">"dyld: launch, running initializers"</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line">		<span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line">		<span class="keyword">if</span> ( ! gRunInitializersOldWay )</span><br><span class="line">			<span class="comment">// 初始化主程序</span></span><br><span class="line">			initializeMainExecutable(); </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="comment">// run all initializers</span></span><br><span class="line">		<span class="comment">// 初始化主程序</span></span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">// notify any montoring proccesses that this process is about to enter main()</span></span><br><span class="line">		<span class="comment">// 通知任何监视进程，此进程将要进入main（）。</span></span><br><span class="line">		<span class="keyword">if</span> (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">			dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step。开始初始化标识</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			<span class="comment">// 初始化动态库</span></span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up</span></span><br><span class="line">	<span class="comment">// 初始化主程序</span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先初始化动态库，然后初始化主程序。上文提到的 DYLD_PRINT_STATISTICS 环境变量在这里也出现了，除此之外还有个 detail 版的环境变量 <font color="#cc0000">DYLD_PRINT_STATISTICS_DETAILS</font>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::runInitializers(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取线程</span></span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">	<span class="comment">// 在进程中初始化</span></span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	<span class="comment">// 初始化耗时</span></span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;rdar://problem/14412057&gt; upward dylib initializers can be run too soon</span></span><br><span class="line"><span class="comment">// To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs</span></span><br><span class="line"><span class="comment">// have their initialization postponed until after the recursion through downward dylibs</span></span><br><span class="line"><span class="comment">// has completed.</span></span><br><span class="line"><span class="keyword">void</span> ImageLoader::processInitializers(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span><br><span class="line">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		<span class="comment">// 递归调用</span></span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态库和主程序的初始化是调用 runInitializers，内部通过 processInitializers 调用 recursiveInitialization 递归初始化当前 image 所依赖的库。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ImageLoader::recursiveInitialization(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span><br><span class="line">									  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 递归锁</span></span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	recursiveSpinLock(lock_info);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles</span></span><br><span class="line">		<span class="comment">// 退出递归循环</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			<span class="comment">// 先初始化低级别的库</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = libImage(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">					<span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">					<span class="comment">// 不要试图初始化级别高于我的</span></span><br><span class="line">					<span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">						uninitUps.images[uninitUps.count] = dependentImage;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// record termination order. 记录终止命令</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">				context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">			<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			<span class="comment">// </span></span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image</span></span><br><span class="line">			<span class="comment">// 真正初始化镜像</span></span><br><span class="line">			<span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line">	</span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">				<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">				timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// this image is not initialized</span></span><br><span class="line">			fState = oldState;</span><br><span class="line">			recursiveSpinUnLock();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意内部有个调用 context.notifySingle(dyld_image_state_initialized, this, NULL)，其实每次 image 状态改变都会调用 notifySingle 这个方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifySingle</span><span class="params">(dyld_image_states state, <span class="keyword">const</span> ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("notifySingle(state=%d, image=%s)\n", state, image-&gt;getPath());</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;* handlers = stateToHandlers(state, sSingleHandlers);</span><br><span class="line">	<span class="keyword">if</span> ( handlers != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		dyld_image_info info;</span><br><span class="line">		info.imageLoadAddress	= image-&gt;machHeader();</span><br><span class="line">		info.imageFilePath		= image-&gt;getRealPath();</span><br><span class="line">		info.imageFileModDate	= image-&gt;lastModified();</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dyld_image_state_change_handler&gt;::iterator it = handlers-&gt;begin(); it != handlers-&gt;end(); ++it) &#123;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* result = (*it)(state, <span class="number">1</span>, &amp;info);</span><br><span class="line">			<span class="keyword">if</span> ( (result != <span class="literal">NULL</span>) &amp;&amp; (state == dyld_image_state_mapped) ) &#123;</span><br><span class="line">				<span class="comment">//fprintf(stderr, "  image rejected by handler=%p\n", *it);</span></span><br><span class="line">				<span class="comment">// make copy of thrown string so that later catch clauses can free it</span></span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span>* str = strdup(result);</span><br><span class="line">				<span class="keyword">throw</span> str;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( state == dyld_image_state_mapped ) &#123;</span><br><span class="line">		<span class="comment">// &lt;rdar://problem/7008875&gt; Save load addr + UUID for images from outside the shared cache</span></span><br><span class="line">		<span class="keyword">if</span> ( !image-&gt;inSharedCache() ) &#123;</span><br><span class="line">			dyld_uuid_info info;</span><br><span class="line">			<span class="keyword">if</span> ( image-&gt;getUUID(info.imageUUID) ) &#123;</span><br><span class="line">				info.imageLoadAddress = image-&gt;machHeader();</span><br><span class="line">				addNonSharedCacheImageUUID(info);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != <span class="literal">NULL</span>) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">		dyld3::<span class="function">ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line">		<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">uint64_t</span> timeInObjC = t1-t0;</span><br><span class="line">		<span class="keyword">uint64_t</span> emptyTime = (t2-t1)*<span class="number">100</span>;</span><br><span class="line">		<span class="keyword">if</span> ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != <span class="literal">NULL</span>) ) &#123;</span><br><span class="line">			timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// mach message csdlc about dynamically unloaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;addFuncNotified() &amp;&amp; (state == dyld_image_state_terminated) ) &#123;</span><br><span class="line">		notifyKernel(*image, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">loadAddress</span>[] = &#123;</span> image-&gt;machHeader() &#125;;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* loadPath[] = &#123; image-&gt;getPath() &#125;;</span><br><span class="line">		notifyMonitoringDyld(<span class="literal">true</span>, <span class="number">1</span>, loadAddress, loadPath);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 state == dyld_image_state_mapped 时，将 image 对应的 UUID 存起来，当state == dyld_image_state_dependents_initialized 并且有 sNotifyObjCInit 回调时调用sNotifyObjCInit函数。</p>
<p>搜索回调函数赋值入口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// record functions to call</span></span><br><span class="line">    sNotifyObjCMapped   = mapped;</span><br><span class="line">    sNotifyObjCInit     = init;</span><br><span class="line">    sNotifyObjCUnmapped = unmapped;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">void</span> _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">    dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现是通过 _dyld_objc_notify_register 这个函数注册回调的。</p>
<p>[NSObject load] 的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.2</span><br><span class="line">  * frame #0: 0x000000010944f3b1 libobjc.A.dylib`+[NSObject load]</span><br><span class="line">    frame #1: 0x000000010943d317 libobjc.A.dylib`call_load_methods + 691</span><br><span class="line">    frame #2: 0x000000010943e814 libobjc.A.dylib`load_images + 77</span><br><span class="line">    frame #3: 0x0000000108b73b97 dyld_sim`dyld::registerObjCNotifiers(void (*)(unsigned int, char const* const*, mach_header const* const*), void (*)(char const*, mach_header const*), void (*)(char const*, mach_header const*)) + 260</span><br><span class="line">    frame #4: 0x000000010b779bf3 libdyld.dylib`_dyld_objc_notify_register + 113</span><br><span class="line">    frame #5: 0x000000010944ca12 libobjc.A.dylib`_objc_init + 115</span><br><span class="line">    frame #6: 0x000000010b7015c0 libdispatch.dylib`_os_object_init + 13</span><br><span class="line">    frame #7: 0x000000010b70f4e5 libdispatch.dylib`libdispatch_init + 300</span><br><span class="line">    frame #8: 0x0000000109e05a78 libSystem.B.dylib`libSystem_initializer + 164</span><br><span class="line">    frame #9: 0x0000000108b82b96 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + 506</span><br><span class="line">    frame #10: 0x0000000108b82d9c dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + 40</span><br><span class="line">    frame #11: 0x0000000108b7e3fc dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 324</span><br><span class="line">    frame #12: 0x0000000108b7e392 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 218</span><br><span class="line">    frame #13: 0x0000000108b7d5d3 dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + 133</span><br><span class="line">    frame #14: 0x0000000108b7d665 dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + 73</span><br><span class="line">    frame #15: 0x0000000108b71333 dyld_sim`dyld::initializeMainExecutable() + 129</span><br><span class="line">    frame #16: 0x0000000108b75434 dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 4384</span><br><span class="line">    frame #17: 0x0000000108b70630 dyld_sim`start_sim + 136</span><br><span class="line">    frame #18: 0x00000001155c1234 dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2238</span><br><span class="line">    frame #19: 0x00000001155bf0ce dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 522</span><br><span class="line">    frame #20: 0x00000001155ba503 dyld`dyldbootstrap::start(macho_header const*, int, char const**, long, macho_header const*, unsigned long*) + 1167</span><br><span class="line">    frame #21: 0x00000001155ba036 dyld`_dyld_start + 54</span><br></pre></td></tr></table></figure>
<p>可以看到，_dyld_objc_notify_register 是在初始化 libobjc.A.dylib 这个动态库时调用的，然后 _objc_init 内部调用了 load_images，进而调用 call_load_methods，从而调用各个类中的load方法，<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F" target="_blank" rel="noopener">Objc源码</a>。</p>
<p>notifySingle 调用完毕后，开始真正初始化工作 <font color="#cc0000"><code>doInitialization</code></font>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ImageLoaderMachO::doInitialization(<span class="keyword">const</span> LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">    CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">    doImageInit(context);</span><br><span class="line">    doModInitFunctions(context);</span><br><span class="line">    </span><br><span class="line">    CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doImageInit 执行 <code>LC_ROUTINES_COMMAND</code> segment 中保存的函数，doModInitFunctions执行 __DATA,__mod_init_func section 中保存的函数。这个 section 中保存的是 C++ 的构造函数及带有 attribute((constructor)) 的 C 函数，简单验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.mm</span><br><span class="line">	</span><br><span class="line">class Test &#123;</span><br><span class="line">public:</span><br><span class="line">    Test();</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line">Test::Test()&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">Test test;</span><br><span class="line">	</span><br><span class="line">__attribute__((constructor)) void testConstructor() &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">	</span><br><span class="line">    testConstructor();</span><br><span class="line">	</span><br><span class="line">    Test * t = new Test();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">2019-08-19 13:26:33.587051+0800 Demo[7105:314102] testConstructor</span><br><span class="line">2019-08-19 13:26:33.587109+0800 Demo[7105:314102] Test</span><br></pre></td></tr></table></figure>
<p>通过 MachOView 可以看到：</p>
<p>显然，__mod_init_func 中的函数在类对应的 load 方法之后调用。</p>
<ol>
<li>对于 dumpdcrypted 这一类注入方法实现功能的插件，他们添加的静态方法会在 doModInitFunctions方法中被解析出来，位置在 MachO 文件的 __DATA 段的 __mod_init_func section。C++ 的全局对象也会出现在这个section中。</li>
<li>在递归初始化 (recursiveInitialization）中，如果当前执行的是主程序 image，doInitialization 完毕后会执行 notifySingle 方法去通知观察者。在 doInitialization 方法前会发送 state 为 dyld_image_state_dependents_initialized 的通知，由这个通知，会调用 libobjc 的 load_images，最后去依次调用各个 OC 类的 load 方法以及分类的 load 方法。</li>
<li><p>Objective-C 的入口方法是 _objc_init，dyld 唤起它的执行路径是从 runInitializers -&gt; recursiveInitialization -&gt; doInitialization -&gt; doModInitFunctions -&gt;.. _objc_init。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;       </span><br><span class="line">	<span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">	_dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">	dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">	                                         <span class="number">1</span><span class="comment">/*batch*/</span>, &amp;map_2_images);</span><br><span class="line">	dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>_objc_init 会在 dyld 中注册两个通知，对应的回调会分别执行将 OC 类加载到内存和调用 load 方法的操作。后面的就是 OC 类加载的经典方法 map_2_images 了。</p>
</li>
<li><p>从 recursiveInitialization 的以下代码片段可以看出 load 是在全局实例或者方法调用前被触发的。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"><span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">fState = dyld_image_state_initialized;</span><br><span class="line">oldState = fState;</span><br><span class="line">context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="3-4-9-查找主程序入口函数指针并返回"><a href="#3-4-9-查找主程序入口函数指针并返回" class="headerlink" title="3.4.9 查找主程序入口函数指针并返回"></a>3.4.9 查找主程序入口函数指针并返回</h5><p>调用getEntryFromLC_MAIN 获取主程序 main 函数的地址，如果未找到则调用getEntryFromLC_UNIXTHREAD 获取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_MAIN() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_MAIN ) &#123;</span><br><span class="line">			entry_point_command* mainCmd = (entry_point_command*)cmd;</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(mainCmd-&gt;entryoff + (<span class="keyword">char</span>*)fMachOData);</span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"LC_MAIN entryoff is out of range"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">void</span>* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_count = ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">const</span> <span class="title">cmds</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)&amp;<span class="title">fMachOData</span>[<span class="title">sizeof</span>(<span class="title">macho_header</span>)];</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">cmd</span> = <span class="title">cmds</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( cmd-&gt;cmd == LC_UNIXTHREAD ) &#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> __i386__</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">i386_thread_state_t</span>* registers = (<span class="keyword">i386_thread_state_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;eip + fSlide);</span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">x86_thread_state64_t</span>* registers = (<span class="keyword">x86_thread_state64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(registers-&gt;rip + fSlide);</span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> __arm64__ &amp;&amp; !__arm64e__</span></span><br><span class="line">			<span class="comment">// temp support until &lt;rdar://39514191&gt; is fixed</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">uint64_t</span>* regs64 = (<span class="keyword">uint64_t</span>*)(((<span class="keyword">char</span>*)cmd) + <span class="number">16</span>);</span><br><span class="line">			<span class="keyword">void</span>* entry = (<span class="keyword">void</span>*)(regs64[<span class="number">32</span>] + fSlide); <span class="comment">// arm_thread_state64_t.__pc</span></span><br><span class="line">			<span class="comment">// &lt;rdar://problem/8543820&amp;9228031&gt; verify entry point is in image</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;containsAddress(entry) )</span><br><span class="line">				<span class="keyword">return</span> entry;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">		cmd = (<span class="keyword">const</span> struct load_command*)(((<span class="keyword">char</span>*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"no valid entry point"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，入口是在 load_command 的 LC_MAIN 或者 LC_UNIXTHREAD 中 LC_MAIN。</p>
<h2 id="四、dyld-闭包"><a href="#四、dyld-闭包" class="headerlink" title="四、dyld 闭包"></a>四、dyld 闭包</h2><p>在第 2 步和第 3 步之间有一个查找闭包并以其结果作为程序入口返回的代码，这里是 <a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">WWDC 2017</a> 推出的 dyld3 中提出的一种优化 App 启动速度的技术。大致步骤如下：</p>
<ol>
<li>如果满足条件：开启闭包（DYLD_USE_CLOSURES 环境变量为 1），App 的路径在白名单中（目前只有系统 Ap p享有使用闭包的特权），共享缓存加载地址不为空，则往下执行。</li>
<li>去内存中查找闭包数据，这里的方法是 findClosure。如果内存中不存在，再去 <code>/private/var/staged_system_apps</code> 路径下去查找硬盘数据，找到就返回结果。</li>
<li>如果没有闭包数据，就会调用 socket 通信走 RPC 去获取闭包数据，执行方法为 callClosureDaemon，感兴趣可以研究下。</li>
<li>如果闭包数据不为空，就会走核心方法：launchWithClosure，基于闭包去启动 App，并且返回该方法中获取的程序入口地址给外界。这个方法重复了上面的各个步骤。具体实现和内部的数据结构有待分析。</li>
</ol>
<h2 id="五、共享缓存机制"><a href="#五、共享缓存机制" class="headerlink" title="五、共享缓存机制"></a>五、共享缓存机制</h2><p>在 iOS 系统中，每个程序依赖的动态库都需要通过 dyld 一个一个加载到内存，然而，很多系统库几乎是每个程序都会用到的，如果在每个程序运行的时候都重复的去加载一次，势必造成运行缓慢，为了优化启动速度和提高程序性能，共享缓存机制就应运而生。所有默认的动态链接库被合并成一个大的缓存文件，放到 <font color="#cc0000"><code>/System/Library/Caches/com.apple.dyld/</code></font> 目录下，按不同的架构保存分别保存着，原作者的 iPhone6 里面就有 dyld_shared_cache_armv7s 和 dyld_shared_cache_armv64 两个文件，如下图所示。</p>
<p>想要分析某个系统库，就需要从 dyld_shared_cache 里先将的原始二进制文件提取出来，这里从易到难提供 3 种方法：</p>
<h4 id="5-1-dyld-cache-extract-提取"><a href="#5-1-dyld-cache-extract-提取" class="headerlink" title="5.1 dyld_cache_extract 提取"></a>5.1 dyld_cache_extract 提取</h4><p><a href="https://github.com/macmade/dyld_cache_extract" target="_blank" rel="noopener">dyld_cache_extract</a> 是一个可视化的工具，使用极其简单，把 dyld_shared_cache 载入即可解析出来，如下图所示。</p>
<h4 id="5-2-jtool-提取"><a href="#5-2-jtool-提取" class="headerlink" title="5.2 jtool 提取"></a>5.2 jtool 提取</h4><p>以提取 CFNetwork 为例，使用如下命令即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jtool -extract CFNetwork ./dyld_shared_cache_arm64</span><br></pre></td></tr></table></figure>
<h4 id="5-3-dsc-extractor-提取"><a href="#5-3-dsc-extractor-提取" class="headerlink" title="5.3 dsc_extractor 提取"></a>5.3 dsc_extractor 提取</h4><p>在 dyld 源代码的 launch-cache 文件夹里面找到 dsc_extractor.cpp，将 653 行的“#if 0”修改为“#if 1”，然后用如下命令编译生成 dsc_extractor，并使用它提取所有缓存文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ dsc_extractor.cpp dsc_iterator.cpp  -o dsc_extractor</span><br><span class="line">$ ./dsc_extractor ./dyld_shared_cache_arm64 ./</span><br></pre></td></tr></table></figure>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>每个 MachO 都会由一个 imageLoader 来处理加载和依赖管理的操作，这里是由 dyld 来安排。主程序 app 的 image 的加载是由内核来完成的。其他的动态库的加载细节可以参考上面提到的 link 方法实现，当一个 image 加载完毕，dyld 会发送 dyld_image_state_bound 通知；著名的 hook 工具 fishhook 的实现原理也是借助监听这个通知，在回调里完成 hook 操作的。</p>
<h2 id="七、文章"><a href="#七、文章" class="headerlink" title="七、文章"></a>七、文章</h2><p><a href="https://www.jianshu.com/u/02a488e1e71e" target="_blank" rel="noopener">01_Jack</a> &amp; <a href="https://www.jianshu.com/p/82e6fdaa0e41" target="_blank" rel="noopener">dyld源码解读</a><br><a href="https://me.csdn.net/lovechris00" target="_blank" rel="noopener">伊织__</a> &amp; <a href="https://blog.csdn.net/lovechris00/article/details/81561627#otool_0" target="_blank" rel="noopener">Mac - otool</a><br><a href="https://www.jianshu.com/u/3b5a95e93778" target="_blank" rel="noopener">RemisKrlet</a> &amp; <a href="https://www.jianshu.com/p/72e34948dac0" target="_blank" rel="noopener">App启动过程 - dyld加载动态库</a><br><a href="https://www.dllhook.com/post/238.html" target="_blank" rel="noopener">dyld详解</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/07/iOS/iOS原理/dyld/">http://yoursite.com/2019/08/07/iOS/iOS原理/dyld/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/17/iOS/iOS原理/编程思想/" class="pre">编程思想</a><a href="/2019/08/06/工具/终端/" class="next">终端</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、介绍"><span class="toc-text">一、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、otool"><span class="toc-text">二、otool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-查看-otool-地址"><span class="toc-text">2.1 查看 otool 地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-otool-L"><span class="toc-text">2.2 otool -L</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-otool-ov"><span class="toc-text">2.3 otool -ov</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-otool-tV-Mach-O"><span class="toc-text">2.4 otool -tV [Mach-O]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-otool-h-Mach-O"><span class="toc-text">2.5 otool -h [Mach-O]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-otool-l-Mach-O-grep-crypt1"><span class="toc-text">2.6 otool -l [Mach-O] | grep crypt1</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#三、dyld加载"><span class="toc-text">三、dyld加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-dyld-start"><span class="toc-text">3.1 __dyld_start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-dyldInitialization-cpp"><span class="toc-text">3.2 dyldInitialization.cpp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-slide、rebase"><span class="toc-text">3.3 slide、rebase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-dyld-main"><span class="toc-text">3.4 dyld::_main</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-设置运行环境"><span class="toc-text">3.4.1 设置运行环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-加载共享缓存"><span class="toc-text">3.4.2 加载共享缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-实例化主程序"><span class="toc-text">3.4.3 实例化主程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-加载插入的动态库"><span class="toc-text">3.4.4 加载插入的动态库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-链接主程序"><span class="toc-text">3.4.5 链接主程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-6-链接插入的动态库"><span class="toc-text">3.4.6 链接插入的动态库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-7-弱符号绑定"><span class="toc-text">3.4.7 弱符号绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-8-初始化主程序"><span class="toc-text">3.4.8 初始化主程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-9-查找主程序入口函数指针并返回"><span class="toc-text">3.4.9 查找主程序入口函数指针并返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、dyld-闭包"><span class="toc-text">四、dyld 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、共享缓存机制"><span class="toc-text">五、共享缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-dyld-cache-extract-提取"><span class="toc-text">5.1 dyld_cache_extract 提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-jtool-提取"><span class="toc-text">5.2 jtool 提取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-dsc-extractor-提取"><span class="toc-text">5.3 dsc_extractor 提取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、总结"><span class="toc-text">六、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、文章"><span class="toc-text">七、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/图片处理/">图片处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/Premultiplied Alpha/">Premultiplied Alpha</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS架构/垃圾代码/">添加垃圾代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/pthread_rwlock_t/">pthread_rwlock_t</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD实现/">GCD实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD深入/">GCD深入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS原理/NSProxy/">NSProxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS架构/组件化方案/">组件化方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/">iOS 编译过程原理(1)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS音视频/">iOS音视频</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">1</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>