<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>依赖注入 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">依赖注入</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">依赖注入</h1><div class="post-meta"><a href="/2019/08/06/iOS/iOS原理/依赖注入/#comments" class="comment-count"></a><p><span class="date">Aug 06, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>依赖注入可以通过初始化方法（或构造函数）传递所需要的参数，或者通过属性（setter）传递。这里将对这两种方法进行讲解。</p>
<p>初始化方法注入：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDependency1:(Dependency1 *)d1 dependency2:(Dependency2 *)d2;</span><br></pre></td></tr></table></figure>
<p>属性注入：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency1 * dependency1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) Dependency2 * dependency2;</span><br></pre></td></tr></table></figure>
<p>一般更趋向于初始化注入，如果在初始化（构造函数）的时候没办法进行注入，才通过属性进行注入。在通过初始化注入的情况下，这些依赖可能仍然需要作为属性存在，但是这些属性应该被设置为只读（readonly）的。</p>
<h2 id="二、为什么使用依赖注入"><a href="#二、为什么使用依赖注入" class="headerlink" title="二、为什么使用依赖注入"></a>二、为什么使用依赖注入</h2><p>依赖注入的几个重要之处：</p>
<p>①、明确的定义。使用依赖注入很明确的告诉了使用者要操作这个类对象需要做什么事情，初始化哪些变量，并且可以隐藏一些危险的依赖，如全局变量；</p>
<p>②、使用构成。 即一直坚持的<font color="#cc0000">多构成少继承原则</font>。它能提高代码的可重用性；</p>
<p>③、更简单的自定义。在创建一个对象的时候通过传入指定的参数，更容易自定义。</p>
<p>④、明确的所有者。</p>
<p>⑤、可测试性。因为只需根据初始化方法，传入需要的参数即可进行操作，不需要去管理被隐藏的依赖。</p>
<h2 id="三、使用依赖注入"><a href="#三、使用依赖注入" class="headerlink" title="三、使用依赖注入"></a>三、使用依赖注入</h2><h4 id="3-1-注入类的类型"><a href="#3-1-注入类的类型" class="headerlink" title="3.1 注入类的类型"></a>3.1 注入类的类型</h4><p>首先，将类（Class）的分为两种类型（type）：简单的类和复杂的类。</p>
<p>简单的类是一个没有任何依赖或者只是依赖于其他简单的类，这个简单类是不可能被子类化的，因为它们的功能是很明确的并且不可变的，也没有引用其他额外的资源。在 Cocoa 框架中就有很多简单类，如：NSString、NSArray、NSDictionary、NSNumber 等。</p>
<p>复杂类则相反。它们有其他复杂的依赖，包括应用程序等级逻辑（根据应用程序的逻辑不同可能改变）。又或者它们需要访问其他外部的资源，如硬盘、网络或全局变量。这些类在你的应用程序中将变得很复杂，它们可能包含所有的控制器对象或所有的 model对象。Cocoa 框架中的复杂类有：NSURLConnection、UIViewController 等。</p>
<p>分类后，我们就可以很容易的在应用程序中选出哪些是复杂类了，然后开始对它们进行优化。</p>
<h4 id="3-2-在初始化时依赖分配"><a href="#3-2-在初始化时依赖分配" class="headerlink" title="3.2 在初始化时依赖分配"></a>3.2 在初始化时依赖分配</h4><p>原始代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line">         ...</span><br><span class="line">         _engine = [[RCEngine alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用依赖注入改版后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">         ...</span><br><span class="line">         _engine = engine;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-延迟初始化依赖"><a href="#3-3-延迟初始化依赖" class="headerlink" title="3.3 延迟初始化依赖"></a>3.3 延迟初始化依赖</h4><p>通常，有一些对象是初始化之后才需要用到的，甚至有时可能几乎用不到，如在用户的一个收藏列表中，当一个收藏都没有的时候显示一个和谐的页面，但这种情况有时很少遇到，因为只要用户收藏了一个资源，这个页面就不需要了。如下面以灭火器为例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;</span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = [[RCFireExtinguisher alloc] init];</span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在这种情况，汽车当然是希望永远都没事，所以我们可能永远不需要灭火器。因为用到这个灭火器对象的几率很低，我们不想使得每一辆车创建得缓慢直接通过初始化方法创建它。或者，如果我们的汽车需要为多次车祸去恢复，这将需要创建多个灭火器。这种情况，我们可以使用一个工厂方法。</p>
<p>工厂方法是一个标准的 Objective-C 的 block，它要求没有参数并且返回一个具体的实例对象。当一个对象依赖使用这个 block 创建时它不需要知道它具体是怎样被创建的。</p>
<p>下面，通过一个工厂，使用依赖注入创建一个灭火器。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> RCFireExtinguisher *(^RCFireExtinguisherFactory)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RCRaceCar</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) RCEngine * engine;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RCFireExtinguisherFactory fireExtinguisherFactory;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine fireExtinguisherFactory:(RCFireExtinguisherFactory)extFactory</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123; </span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          _engine = engine;  </span><br><span class="line">          _fireExtinguisherFactory = [extFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)recoverFromCrash</span><br><span class="line">&#123; </span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.fire != <span class="literal">nil</span>) &#123;     </span><br><span class="line">          RCFireExtinguisher * fireExtinguisher = <span class="keyword">self</span>.fireExtinguisherFactory();     </span><br><span class="line">          [fireExtinguisher extinguishFire:<span class="keyword">self</span>.fire];   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>工厂在下面的情况下也很有用。当我们需要去创建一个不知道数量的依赖，甚至它是知道初始化之后才被创建的。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RCRaceCar</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(RCEngine *)engine transmission:(RCTransmission *)transmission wheelFactory:(RCWheel *(^)())wheelFactory;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;      </span><br><span class="line"> </span><br><span class="line">          _engine = engine;   </span><br><span class="line">          _transmission    = transmission;   </span><br><span class="line">          _leftFrontWheel  = wheelFactory();   </span><br><span class="line">          _leftRearWheel   = wheelFactory();   </span><br><span class="line">          _rightFrontWheel = wheelFactory();  </span><br><span class="line">          _rightRearWheel  = wheelFactory();   <span class="comment">// 保留轮子工厂，之后还需要一个备胎。   </span></span><br><span class="line">          _wheelFactory    = [wheelFactory <span class="keyword">copy</span>];   </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="四、避免多余的配置"><a href="#四、避免多余的配置" class="headerlink" title="四、避免多余的配置"></a>四、避免多余的配置</h2><p>如果一个对象不应该在其他对象内部进行配置，那就用便利构造器（如 +[NSDictionary dictionary]）。我们将把配置从我们的对象图中移出到我们普通的对象，分开它们使得代码更整洁，可测试，业务逻辑更清晰。</p>
<p>在添加一个便利构造器时，应该先确保是否是必须的。如果一个对象在 init 方法中只有几个参数，并且这些参数没有确切的默认值，那添加一个便利构造器是没必要的并且调用者应该直接使用标准的 init 方法。</p>
<p>为了配置我们的对象，将从 4 个点来收集我们的依赖：</p>
<p>①、没有一个确切的默认值。 包括 boolean 值或 number 值，他们可能根据在不同实例变量中的值各不相同。所以这些值应该作为参数传递到便利构造器中；</p>
<p>②、存在共享对象。 这个也需要作为参数传递到便利构造器中（比如一个无线电频率）。这些对象之前可能已经作为单例或通过父类指针被赋值；</p>
<p>③、被新创建的对象。 如果一个对象没有把这个依赖分享给其他对象，那其他对象（同一个类）应该在遍历构造器内创建一个新的依赖对象。</p>
<p>④、系统单例。 Cocoa 内提供的单例是可以直接被访问的，比如文件管理者单例 [NSFileManager defaultManager]， 这里很明确在你的应用程序中只有一个实例将会被使用。</p>
<p>下面是关于赛车的简单初便利构造器</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)raceCarWithPitRadioFrequency:(RCRadioFrequency *)frequency</span><br><span class="line">&#123;</span><br><span class="line">     RCEngine * engine = [[RCEngine alloc] init];   </span><br><span class="line">     RCTransmission * transmission = [[RCTransmission alloc] init];   </span><br><span class="line"></span><br><span class="line">     RCWheel *(^wheelFactory)() = ^&#123;      </span><br><span class="line">          <span class="keyword">return</span> [[RCWheel alloc] init];   </span><br><span class="line">     &#125;;   </span><br><span class="line">     <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithEngine:engine</span><br><span class="line">                            transmission:transmission </span><br><span class="line">                       pitRadioFrequency:frequency</span><br><span class="line">                            wheelFactory:wheelFactory];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>便利构造器应该放置在一个更加适合的地方与类分离。通常情况下都是放置在相同的 *.m 文件中，但是当指定通过如 Foo 对象配置的时候就应该将它放置在 @interface RaceCar(FooConfiguration) 这个 category 中，并且命名为类似 fooRaceCar 之类的。</p>
<h2 id="五、系统单例"><a href="#五、系统单例" class="headerlink" title="五、系统单例"></a>五、系统单例</h2><p>在 Cocoa 中有许多对象只有一个实例存在，如 [UIApplication sharedApplication]、[NSFileManager defaultManager]、[NSUserDefaults standardUserDefaults] 和 [UIDevice currentDevice] 等。如果一个对象依赖于这些对象中的一个，那就应该被作为参数包含进来。即使在你的应用程序中只有这样一个实例。在你的测试中可能想要模拟实例或在测试前创建一个实例来避免测试依赖。</p>
<p>这里建议<font color="#cc0000">避免在你的代码中创建全局的单例</font>，而是在一个对象中创建一个单一的实例，当它第一次被使用时，将它注入到其他依赖它的对象中去。</p>
<h2 id="六、不可修改的构造函数"><a href="#六、不可修改的构造函数" class="headerlink" title="六、不可修改的构造函数"></a>六、不可修改的构造函数</h2><p>有些时候，一个类的初始化方法/构造方法不能被修改或不能被直接调用。在这种情况下，你需要使用 setter 注入。如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个我们不能直接调用初始化方法的例子。</span></span><br><span class="line">RCRaceTrack * raceTrack = [objectYouCantModify createRaceTrack];</span><br><span class="line"><span class="comment">// 我们仍然可以使用属性来配置我们的赛车路径</span></span><br><span class="line">raceTrack.width = <span class="number">10</span>;</span><br><span class="line">raceTrack.numberOfHairpinTurns = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>setter 注入允许你配置这个对象，但是它引入了额外的可变性使得在这个类的设计中必须做额外的测试和处理。幸运的是，这里有两种主要的场景导致无法访问和修改初始化方法，并且这两种情况都是可以避免的。</p>
<h2 id="七、类注册"><a href="#七、类注册" class="headerlink" title="七、类注册"></a>七、类注册</h2><p>“类注册” 工厂模式的使用意味着对象不能修改它们的初始化方法。见代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * raceCarClasses = @[ [RCFastRaceCar <span class="keyword">class</span>], [RCSlowRaceCar <span class="keyword">class</span>] ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class raceCarClass <span class="keyword">in</span> raceCarClasses) &#123;   </span><br><span class="line">     <span class="comment">// 所有赛车必须有相同的初始化方法 (在这个例子中是 "init" 方法).</span></span><br><span class="line">     <span class="comment">// 这里意味着我们不能自定义不同的子类</span></span><br><span class="line">     [raceCars addObject:[[raceCarClass alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的替换方法是：使用工厂 block 来代替</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> RCRaceCar *(^RCRaceCarFactory)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> * raceCarFactories = @[ ^&#123; <span class="keyword">return</span> [[RCFastRaceCar alloc] initWithTopSpeed:<span class="number">200</span>]; &#125;, </span><br><span class="line">                                ^&#123; <span class="keyword">return</span> [[RCSlowRaceCar alloc] initWithLeatherPlushiness:<span class="number">11</span>]; &#125; ];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *  raceCars = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (RCRaceCarFactory raceCarFactory <span class="keyword">in</span> raceCarFactories) &#123;</span><br><span class="line">    <span class="comment">// 现在这样，我们就不用关心到底是那个初始化方法被调用了</span></span><br><span class="line">    [raceCars addObject:raceCarFactory()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八、Storyboards"><a href="#八、Storyboards" class="headerlink" title="八、Storyboards"></a>八、Storyboards</h2><p>Storyboards 提供了很方便的方法来构建界面，但是在依赖注入中它也带来了问题。 特别是当在 Storyboard 中实例化一个初始化的视图控制器，它不允许你选择调用哪一个初始化方法。 类似的，当在 storyboard 中定义一个 segue 时，目标控制器在实例化时也不能让你指定调用那个初始化方法。</p>
<p>解决方法是<font color="#cc0000">避免使用 storyboard</font>。这看起来是一种极端的解决方案，但是我们发现在大型团队开发中， storyboard 带来了其他问题。另外，不适用 storyboard 并没有丢掉它的所有好处，除了 storyboard 提供的 segues 外，xib 也提供了和 storyboard 相同的好处，而且 xib 可以让你自定义初始化方法。</p>
<h2 id="九、公有和私有"><a href="#九、公有和私有" class="headerlink" title="九、公有和私有"></a>九、公有和私有</h2><p>依赖注入鼓励在你的共有接口上暴露出更多的是对象。正如上面提到的，这有很多好处。但是当在构建框架时，它使你的共有 API变得臃肿。使用依赖注入之前，公有对象 A 已经使用私有对象 B（对象 B 反过来使用私有对象 C），但是对象 B 和对象 C 从来没有从框架中暴露。通过依赖注入，对象 A 在它的公有初始化方法中有对象 B ，而对象 B 反过来使得对象 C 在它的初始化方法中公开。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In public ObjectA.h.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为初始化方法使用了对象 B 的引用，所以我们需要在使用对象 B 之前引入它的头文件</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(ObjectB *)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectB</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也一样：需要暴露 ObjectC.h</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectC:(ObjectC *)objectC;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectC</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>对象 B 和对象 C 都是具体的实现，而你不想让框架的使用者去关心它们。这时可以通过协议（protocol）来解决。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjectA</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjectB:(<span class="keyword">id</span> &lt;ObjectB&gt;)objectB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个协议只暴露 ObjectA 需要原始的 ObjectB。</span></span><br><span class="line"><span class="comment">// 我们并不是在具体的 ObjectB(或 ObjectC）实现创建一个硬依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectB</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodNeededByObjectA;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="十、一次高效的依赖注入"><a href="#十、一次高效的依赖注入" class="headerlink" title="十、一次高效的依赖注入"></a>十、一次高效的依赖注入</h2><h4 id="10-1-问题场景"><a href="#10-1-问题场景" class="headerlink" title="10.1 问题场景"></a>10.1 问题场景</h4><p>如果基于 Cocoapods 和 Git Submodules 来做组件化的时候，我们的依赖关系是这样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ee8e7de4eb46f0b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这里依赖路径有两条：</p>
<p>①、主项目依赖第三方 pods。</p>
<p>②、组件依赖第三方 pods，主项目再依赖组件。</p>
<p><font color="#cc0000">单向的依赖关系</font>决定了从组件到项目的通讯是单向的，即主项目可以主动向组件发起通讯，<font color="#cc0000">组件却没有办法主动和主项目通讯</font>。</p>
<p>可以用通知来与主项目通讯，但是这一点都不优雅，也不好维护和拓展。更加优雅、更加方便日常开发的拓展和维护的方式，叫做“依赖注入”。</p>
<h4 id="10-2-依赖注入"><a href="#10-2-依赖注入" class="headerlink" title="10.2 依赖注入"></a>10.2 依赖注入</h4><p>依赖注入有另外一个名字，叫做“控制反转”。</p>
<p>像上面的组件化的例子，主项目依赖组件，现在有一个需求，组件需要依赖主项目，这种情况就叫做“控制反转”。能把这部分“控制反转”的代码统一起来解耦维护，方便日后拓展和维护的服务，我们就可以叫做依赖注入。</p>
<p>所以依赖注入有两个比较重要的点：</p>
<p>①、要实现这种反转控制的功能。</p>
<p>②、要解耦。</p>
<blockquote>
<p>不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。</p>
<p>出自这篇文章：<a href="https://laravel-china.org/topics/2104/understanding-dependency-injection-and-inversion-of-control" target="_blank" rel="noopener">理解依赖注入与控制反转</a></p>
</blockquote>
<h4 id="10-3-iOS-依赖注入调查"><a href="#10-3-iOS-依赖注入调查" class="headerlink" title="10.3 iOS 依赖注入调查"></a>10.3 iOS 依赖注入调查</h4><p>iOS 平台实现依赖注入功能的开源项目有两个大头：<a href="https://github.com/atomicobject/objection" target="_blank" rel="noopener">objection</a>、<a href="https://github.com/appsquickly/typhoon" target="_blank" rel="noopener">typhoon</a>。</p>
<p>详细对比发现这两个框架都是严格遵循依赖注入的概念来实现的，并没有将 Objective-C 的 runtime 特性发挥到极致，所以使用起来很麻烦。</p>
<p>还有一点，这两个框架使用继承的方式实现注入功能，对项目的侵入性不容小视。如果你觉得这个侵入性不算什么，那等到项目大到一定程度，发现之前选择的技术方案有考虑不周，想切换到其他方案的时，你一定会后悔当时没选择那个不侵入项目的方案。</p>
<p>那有没有其他没那么方案呢？<a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener">libextobjc</a></p>
<p>libextobjc 里有一个 EXTConcreteProtocol 虽然没有直接叫做依赖注入，而是叫做混合协议。它的优点：</p>
<p>①、充分使用了 OC 动态语言的特性，不侵入项目</p>
<p>②、高度自动化</p>
<p>③、框架十分轻量（只有一个 .h 和 .m 文件）</p>
<p>④、使用非常简单（只需要一个 @conreteprotocol 关键字就已经注入好了）。</p>
<h4 id="10-4-EXTConcreteProtocol-实现原理"><a href="#10-4-EXTConcreteProtocol-实现原理" class="headerlink" title="10.4 EXTConcreteProtocol 实现原理"></a>10.4 EXTConcreteProtocol 实现原理</h4><p>有两个比较重要的概念需要提前明白才能继续往下讲。</p>
<p>①、容器。这里的容器是指，我们注入的方法需要有类（class）来装，而装这些方法的器皿就统称为容器。</p>
<p>②、_attribute__() 这是一个 GNU 编译器语法，被 constructor 这个关键字修饰的方法会在所有类的 +load 方法之后，在 main 函数之前被调用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d6694cba798f0df6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>如上图，用一句话来描述注入的过程：将待注入的容器中的方法在 load 方法之后 main 函数之前注入指定的类中。</p>
<h6 id="10-4-1-EXTConcreteProtocol-的使用"><a href="#10-4-1-EXTConcreteProtocol-的使用" class="headerlink" title="10.4.1 EXTConcreteProtocol 的使用"></a>10.4.1 EXTConcreteProtocol 的使用</h6><p>比方说有一个协议 ObjectProtocol。我们只要这样写就已经实现了依赖注入。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ObjectProtocol</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello;</span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">@concreteprotocol(ObjectProtocol)</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)sayHello</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>之后比方说一个 Person 类想要拥有这个注入方法，就只需要遵守这个协议就可以了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">ObjectProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们接下来就可以对 Person 调用注入的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     Person * p = [Person new];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [p age]);</span><br><span class="line">     [p.class sayHello];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">18</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>
<h6 id="10-4-2-源码解析"><a href="#10-4-2-源码解析" class="headerlink" title="10.4.2 源码解析"></a>10.4.2 源码解析</h6><p>先来看一下头文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define concreteprotocol(NAME) \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a class used to contain all the methods used in this protocol</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">     <span class="comment">// 定义一个容器类</span></span><br><span class="line">    interface NAME <span class="meta">## _ProtocolMethodContainer : NSObject <span class="meta-string">&lt; NAME &gt;</span> &#123;&#125; \</span></span><br><span class="line">    <span class="keyword">@end</span> \</span><br><span class="line">    \</span><br><span class="line">    <span class="class"><span class="keyword">@implementation</span> <span class="title">NAME</span> ## <span class="title">_ProtocolMethodContainer</span> \</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * when this class is loaded into the runtime, add the concrete protocol</span></span><br><span class="line"><span class="comment">     * into the list we have of them</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// load 方法添加混合协议</span></span><br><span class="line">    + (<span class="keyword">void</span>)load &#123; \</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * passes the actual protocol as the first parameter, then this class as</span></span><br><span class="line"><span class="comment">         * the second</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        <span class="keyword">if</span> (!ext_addConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME)), <span class="keyword">self</span>)) \</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not load concrete protocol %s\n"</span>, metamacro_stringify(NAME)); \</span><br><span class="line">    &#125; \</span><br><span class="line">    \</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * using the "constructor" function attribute, we can ensure that this</span></span><br><span class="line"><span class="comment">     * function is executed only AFTER all the Objective-C runtime setup (i.e.,</span></span><br><span class="line"><span class="comment">     * after all +load methods have been executed)</span></span><br><span class="line"><span class="comment">     */</span> \</span><br><span class="line">    <span class="comment">// 在 load 之后，main 之前执行方法注入</span></span><br><span class="line">    __attribute__((constructor)) \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> ext_ <span class="meta">## NAME ## _inject (void) &#123; \</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * use this injection point to mark this concrete protocol as ready for</span></span><br><span class="line"><span class="comment">         * loading</span></span><br><span class="line"><span class="comment">         */</span> \</span><br><span class="line">        ext_loadConcreteProtocol(objc_getProtocol(metamacro_stringify(NAME))); \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** implementation details follow ***/</span></span><br><span class="line"><span class="comment">// load 方法添加混合协议</span></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class methodContainer);</span><br><span class="line"><span class="comment">// load 之后，main 之前执行方法注入</span></span><br><span class="line"><span class="keyword">void</span> ext_loadConcreteProtocol (Protocol *protocol);</span><br></pre></td></tr></table></figure>
<p>可以在源码中清楚看到 concreteprotocol 这个宏定义为我们的协议添加了一个容器类，我们主要注入的比如 +sayHello 和 -age 方法都被定义在这个容器类之中。</p>
<p>然后在 +load 方法中调用了 ext_addConcreteProtocol 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// contains the information needed to reference a full special protocol</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// the actual protocol declaration (@protocol block)  用户定义的协议.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> Protocol *protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the injection block associated with this protocol</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this block is RETAINED and must eventually be released by transferring it</span></span><br><span class="line">    <span class="comment">// back to ARC</span></span><br><span class="line">    <span class="comment">// 在 __attribute__((constructor)) 时往指定类里注入方法的 block.</span></span><br><span class="line">    <span class="keyword">void</span> *injectionBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// whether this protocol is ready to be injected to its conforming classes</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this does NOT refer to a special protocol having been injected already</span></span><br><span class="line">    <span class="comment">// 对应的协议是否已经准备好注入.</span></span><br><span class="line">    <span class="built_in">BOOL</span> ready;</span><br><span class="line">&#125; EXTSpecialProtocol;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_addConcreteProtocol (Protocol *protocol, Class containerClass) &#123;</span><br><span class="line">    <span class="keyword">return</span> ext_loadSpecialProtocol(protocol, ^(Class destinationClass)&#123;</span><br><span class="line">        ext_injectConcreteProtocol(protocol, containerClass, destinationClass);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ext_loadSpecialProtocol (Protocol *protocol, <span class="keyword">void</span> (^injectionBehavior)(Class destinationClass)) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(injectionBehavior != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work    加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if we've hit the hard maximum for number of special protocols, we can't</span></span><br><span class="line">        <span class="comment">// continue</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount == SIZE_MAX) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the array has no more space, we will need to allocate additional</span></span><br><span class="line">        <span class="comment">// entries</span></span><br><span class="line">        <span class="comment">// specialProtocols 是一个链表，每个协议都会被组织成为一个 EXTSpecialProtocol，这个 specialProtocols 里存放了了这些 specialProtocols.</span></span><br><span class="line">        <span class="keyword">if</span> (specialProtocolCount &gt;= specialProtocolCapacity) &#123;</span><br><span class="line">            size_t newCapacity;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocolCapacity == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// if there are no entries, make space for just one</span></span><br><span class="line">                newCapacity = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// otherwise, double the current capacity</span></span><br><span class="line">                newCapacity = specialProtocolCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// if the new capacity is less than the current capacity, that's</span></span><br><span class="line">                <span class="comment">// unsigned integer overflow</span></span><br><span class="line">                <span class="keyword">if</span> (newCapacity &lt; specialProtocolCapacity) &#123;</span><br><span class="line">                    <span class="comment">// set it to the maximum possible instead</span></span><br><span class="line">                    newCapacity = SIZE_MAX;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// if the new capacity is still not greater than the current</span></span><br><span class="line">                    <span class="comment">// (for instance, if it was already SIZE_MAX), we can't continue</span></span><br><span class="line">                    <span class="keyword">if</span> (newCapacity &lt;= specialProtocolCapacity) &#123;</span><br><span class="line">                        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// we have a new capacity, so resize the list of all special protocols</span></span><br><span class="line">            <span class="comment">// to add the new entries</span></span><br><span class="line">            <span class="keyword">void</span> * restrict ptr = realloc(specialProtocols, <span class="keyword">sizeof</span>(*specialProtocols) * newCapacity);</span><br><span class="line">            <span class="keyword">if</span> (!ptr) &#123;</span><br><span class="line">                <span class="comment">// the allocation failed, abort</span></span><br><span class="line">                pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            specialProtocols = ptr;</span><br><span class="line">            specialProtocolCapacity = newCapacity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// at this point, there absolutely must be at least one empty entry in the</span></span><br><span class="line">        <span class="comment">// array</span></span><br><span class="line">        assert(specialProtocolCount &lt; specialProtocolCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// disable warning about "leaking" this block, which is released in</span></span><br><span class="line">        <span class="comment">// ext_injectSpecialProtocols()</span></span><br><span class="line">        <span class="meta">#ifndef __clang_analyzer__</span></span><br><span class="line">        ext_specialProtocolInjectionBlock copiedBlock = [injectionBehavior <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// construct a new EXTSpecialProtocol structure and add it to the first</span></span><br><span class="line">        <span class="comment">// empty space in the array</span></span><br><span class="line">        <span class="comment">// 将协议保存为一个 EXTSpecialProtocol 结构体。</span></span><br><span class="line">        specialProtocols[specialProtocolCount] = (EXTSpecialProtocol)&#123;</span><br><span class="line">            .protocol = protocol,</span><br><span class="line">            .injectionBlock = (__bridge_retained <span class="keyword">void</span> *)copiedBlock,</span><br><span class="line">            .ready = <span class="literal">NO</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">        ++specialProtocolCount;</span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ext_loadSpecialProtocol 方法里传进去一个 block，这个 block 里调用了 ext_injectConcreteProtocol 这个方法。</p>
<p>ext_injectConcreteProtocol 这个方法接受三个参数，第一个是协议，就是我们要注入的方法的协议；第二个是容器类，就是框架为我们添加的那个容器；第三个参数是目标注入类，就是我们要把这个容器里的方法注入到哪个类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectConcreteProtocol (Protocol *protocol, Class containerClass, Class <span class="keyword">class</span>) &#123;</span><br><span class="line">    <span class="comment">// get the full list of instance methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的实例方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> imethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *imethodList = class_copyMethodList(containerClass, &amp;imethodCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the full list of class methods implemented by the concrete</span></span><br><span class="line">    <span class="comment">// protocol   获取容器类里所有的类方法方法.</span></span><br><span class="line">    <span class="keyword">unsigned</span> cmethodCount = <span class="number">0</span>;</span><br><span class="line">    Method *cmethodList = class_copyMethodList(object_getClass(containerClass), &amp;cmethodCount);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// get the metaclass of this class (the object on which class</span></span><br><span class="line">    <span class="comment">// methods are implemented)  拿到要注入方法的类的元类.</span></span><br><span class="line">    Class metaclass = object_getClass(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all instance methods in the concrete protocol   注入实例方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; imethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = imethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if such an instance method already exists</span></span><br><span class="line">        <span class="comment">// (on this class or on a superclass)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(<span class="keyword">class</span>, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this instance method to the class in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(<span class="keyword">class</span>, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement instance method -%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject all class methods in the concrete protocol   注入类方法.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> methodIndex = <span class="number">0</span>;methodIndex &lt; cmethodCount;++methodIndex) &#123;</span><br><span class="line">        Method method = cmethodList[methodIndex];</span><br><span class="line">        SEL selector = method_getName(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +initialize is a special case that should never be copied</span></span><br><span class="line">        <span class="comment">// into a class, as it performs initialization for the concrete</span></span><br><span class="line">        <span class="comment">// protocol</span></span><br><span class="line">        <span class="comment">// +initialize 不能被注入.</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">@selector</span>(initialize)) &#123;</span><br><span class="line">            <span class="comment">// so just continue looking through the rest of the methods</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first, check to see if a class method already exists (on this</span></span><br><span class="line">        <span class="comment">// class or on a superclass)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// since 'class' is considered to be an instance of 'metaclass',</span></span><br><span class="line">        <span class="comment">// this is actually checking for class methods (despite the</span></span><br><span class="line">        <span class="comment">// function name)</span></span><br><span class="line">        <span class="comment">// 如果该类已经实现了这个方法，就跳过注入，不至于覆盖用户自定义的实现.</span></span><br><span class="line">        <span class="keyword">if</span> (class_getInstanceMethod(metaclass, selector)) &#123;</span><br><span class="line">            <span class="comment">// it does exist, so don't overwrite it</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add this class method to the metaclass in question</span></span><br><span class="line">        IMP imp = method_getImplementation(method);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *types = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">if</span> (!class_addMethod(metaclass, selector, imp, types)) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not implement class method +%s from concrete protocol %s on class %sn"</span>,</span><br><span class="line">                sel_getName(selector), protocol_getName(protocol), class_getName(<span class="keyword">class</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the instance method list  管理内存</span></span><br><span class="line">    free(imethodList); imethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the class method list</span></span><br><span class="line">    free(cmethodList); cmethodList = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use [containerClass class] and discard the result to call +initialize</span></span><br><span class="line">    <span class="comment">// on containerClass if it hasn't been called yet</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// this is to allow the concrete protocol to perform custom initialization</span></span><br><span class="line">    <span class="comment">// 允许用户在容器类里复写 +initialize 方法，这里调用是保证用户复写的实现能够被执行.</span></span><br><span class="line">    (<span class="keyword">void</span>)[containerClass <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看一下在 +load 之后 main 之前调用 ext_loadConcreteProtocol 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ext_specialProtocolReadyForInjection (Protocol *protocol) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSCParameterAssert</span>(protocol != <span class="literal">nil</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lock the mutex to prevent accesses from other threads while we perform</span></span><br><span class="line">        <span class="comment">// this work   加锁</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_lock(&amp;specialProtocolsLock) != <span class="number">0</span>) &#123;</span><br><span class="line">            fprintf(stderr, <span class="string">"ERROR: Could not synchronize on special protocol data\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop through all the special protocols in our list, trying to find the</span></span><br><span class="line">        <span class="comment">// one associated with 'protocol'</span></span><br><span class="line">        <span class="comment">// 检查要对应的 protocol 是否已经加载进上面的链表中了，如果找到了，就将对应的 EXTSpecialProtocol 结构体的 ready 置为 YES.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (specialProtocols[i].protocol == protocol) &#123;</span><br><span class="line">                <span class="comment">// found the matching special protocol, check to see if it's</span></span><br><span class="line">                <span class="comment">// already ready</span></span><br><span class="line">                <span class="keyword">if</span> (!specialProtocols[i].ready) &#123;</span><br><span class="line">                    <span class="comment">// if it's not, mark it as being ready now</span></span><br><span class="line">                    specialProtocols[i].ready = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// since this special protocol was in our array, and it was not</span></span><br><span class="line">                    <span class="comment">// loaded, the total number of protocols loaded must be less</span></span><br><span class="line">                    <span class="comment">// than the total count at this point in time</span></span><br><span class="line">                    assert(specialProtocolsReady &lt; specialProtocolCount);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ... and then increment the total number of special protocols</span></span><br><span class="line">                    <span class="comment">// loaded – if it now matches the total count of special</span></span><br><span class="line">                    <span class="comment">// protocols, begin the injection process</span></span><br><span class="line">                    <span class="keyword">if</span> (++specialProtocolsReady == specialProtocolCount)</span><br><span class="line">                        <span class="comment">// 如果所有的 EXTSpecialProtocol 结构体都准备好了，就开始执行注入.</span></span><br><span class="line">                        ext_injectSpecialProtocols();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;specialProtocolsLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面都是准备工作，接下来开始进入核心方法进行注入。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This function actually performs the hard work of special protocol injection.</span></span><br><span class="line"><span class="comment"> * It obtains a full list of all classes registered with the Objective-C</span></span><br><span class="line"><span class="comment"> * runtime, finds those conforming to special protocols, and then runs the</span></span><br><span class="line"><span class="comment"> * injection blocks as appropriate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> ext_injectSpecialProtocols (<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * don't lock specialProtocolsLock in this function, as it is called only</span></span><br><span class="line"><span class="comment">     * from public functions which already perform the synchronization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This will sort special protocols in the order they should be loaded. If</span></span><br><span class="line"><span class="comment">     * a special protocol conforms to another special protocol, the former</span></span><br><span class="line"><span class="comment">     * will be prioritized above the latter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 对协议进行排序.</span></span><br><span class="line">    <span class="comment">// 比方说 A 协议继承自 B 协议，但是不一定是 B 协议对应的容器类的  load 方法先执行，A 的后执行. 所以如果 B 协议的类方法中复写了 A 协议中的方法，那么应该保证 B 协议复写的方法被注入，而不是 A 协议的容器方法的实现.</span></span><br><span class="line">    <span class="comment">// 为了保证这个循序，所以要对协议进行排序，上面说的 A 继承自 B，那么循序应该是 A 在 B 前面.</span></span><br><span class="line">    qsort_b(specialProtocols, specialProtocolCount, <span class="keyword">sizeof</span>(EXTSpecialProtocol), ^(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)&#123;</span><br><span class="line">        <span class="comment">// if the pointers are equal, it must be the same protocol</span></span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoA = a;</span><br><span class="line">        <span class="keyword">const</span> EXTSpecialProtocol *protoB = b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A higher return value here means a higher priority</span></span><br><span class="line">        <span class="keyword">int</span> (^protocolInjectionPriority)(<span class="keyword">const</span> EXTSpecialProtocol *) = ^(<span class="keyword">const</span> EXTSpecialProtocol *specialProtocol)&#123;</span><br><span class="line">            <span class="keyword">int</span> runningTotal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">                <span class="comment">// the pointer passed into this block is guaranteed to point</span></span><br><span class="line">                <span class="comment">// into the 'specialProtocols' array, so we can compare the</span></span><br><span class="line">                <span class="comment">// pointers directly for identity</span></span><br><span class="line">                <span class="keyword">if</span> (specialProtocol == specialProtocols + i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (protocol_conformsToProtocol(specialProtocol-&gt;protocol, specialProtocols[i].protocol))</span><br><span class="line">                    runningTotal++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> runningTotal;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This will return:</span></span><br><span class="line"><span class="comment">         * 0 if the protocols are equal in priority (such that load order does not matter)</span></span><br><span class="line"><span class="comment">         * &lt; 0 if A is more important than B</span></span><br><span class="line"><span class="comment">         * &gt; 0 if B is more important than A</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> protocolInjectionPriority(protoB) - protocolInjectionPriority(protoA);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取项目中所有的类</span></span><br><span class="line">    <span class="keyword">unsigned</span> classCount = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!classCount) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: No classes registered with the runtime\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	Class *allClasses = (Class *)malloc(<span class="keyword">sizeof</span>(Class) * (classCount + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (!allClasses) &#123;</span><br><span class="line">        fprintf(stderr, <span class="string">"ERROR: Could not allocate space for %u classes\n"</span>, classCount);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use this instead of ext_copyClassList() to avoid sending +initialize to</span></span><br><span class="line">	<span class="comment">// classes that we don't plan to inject into (this avoids some SenTestingKit</span></span><br><span class="line">	<span class="comment">// timing issues)</span></span><br><span class="line">	classCount = objc_getClassList(allClasses, classCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * set up an autorelease pool in case any Cocoa classes get used during</span></span><br><span class="line"><span class="comment">     * the injection process or +initialize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// loop through the special protocols, and apply each one to all the</span></span><br><span class="line">        <span class="comment">// classes in turn</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// ORDER IS IMPORTANT HERE: protocols have to be injected to all classes in</span></span><br><span class="line">        <span class="comment">// the order in which they appear in specialProtocols. Consider classes</span></span><br><span class="line">        <span class="comment">// X and Y that implement protocols A and B, respectively. B needs to get</span></span><br><span class="line">        <span class="comment">// its implementation into Y before A gets into X.</span></span><br><span class="line">        <span class="comment">// 遍历所有的要注入的协议结构体.</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>;i &lt; specialProtocolCount;++i) &#123;</span><br><span class="line">            Protocol *protocol = specialProtocols[i].protocol;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// transfer ownership of the injection block to ARC and remove it</span></span><br><span class="line">            <span class="comment">// from the structure</span></span><br><span class="line">            <span class="comment">// 使用 __bridge_transfer 把对象的内存管理交给 ARC.</span></span><br><span class="line">            ext_specialProtocolInjectionBlock injectionBlock = (__bridge_transfer <span class="keyword">id</span>)specialProtocols[i].injectionBlock;</span><br><span class="line">            specialProtocols[i].injectionBlock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop through all classes   遍历所有的类</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> classIndex = <span class="number">0</span>;classIndex &lt; classCount;++classIndex) &#123;</span><br><span class="line">                Class <span class="keyword">class</span> = allClasses[classIndex];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// if this class doesn't conform to the protocol, continue to the</span></span><br><span class="line">                <span class="comment">// next class immediately</span></span><br><span class="line">                <span class="comment">// 如果这个类遵守了要注入的协议，那么就执行注入</span></span><br><span class="line">                <span class="comment">// 注意： 这里是 continue 不是 break，因为一个类可以注入多个协议的方法.</span></span><br><span class="line">                <span class="keyword">if</span> (!class_conformsToProtocol(<span class="keyword">class</span>, protocol))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                injectionBlock(<span class="keyword">class</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 管理内存.</span></span><br><span class="line">    <span class="comment">// free the allocated class list</span></span><br><span class="line">    free(allClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that everything's injected, the special protocol list can also be</span></span><br><span class="line">    <span class="comment">// destroyed</span></span><br><span class="line">    free(specialProtocols); specialProtocols = <span class="literal">NULL</span>;</span><br><span class="line">    specialProtocolCount = <span class="number">0</span>;</span><br><span class="line">    specialProtocolCapacity = <span class="number">0</span>;</span><br><span class="line">    specialProtocolsReady = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一路看下来，原理看的明明白白，是不是也没什么特别的，都是 runtime 的知识。主要看思路。 </p>
<h6 id="10-4-3-问题在哪？"><a href="#10-4-3-问题在哪？" class="headerlink" title="10.4.3 问题在哪？"></a>10.4.3 问题在哪？</h6><p>接下来讨论 EXTConcreteProtocol 的缺点。</p>
<p>如果项目不大，只有几百个类，这些都没有问题的，但是当项目有接近 30000 个类或者更多时。我们使用注入的地方有几十上百处，两套 for 循环算下来是一个百万级别的。而且 objc_getClassList 这个方法是非常耗时的而且没有缓存。</p>
<p>这个方法在 iPhone 6Plus 上要耗时一秒，在更老的 iPhone 6 上耗时要 3 秒，iPhone 5 可以想象要更久。而且随着项目迭代，项目中的类会越来越多， 这个耗时也会越来越长。</p>
<p>这个耗时是 pre-main 耗时，就是用户看那个白屏启动图的时候在做这个操作，严重影响用户体验。我们的产品就因为这个点导致闪屏广告展示出现问题，直接影响业务。</p>
<h4 id="10-5-解决方案"><a href="#10-5-解决方案" class="headerlink" title="10.5 解决方案"></a>10.5 解决方案</h4><p>从上面的分析可以知道，导致耗时的原因就是原框架获取所有的类进行遍历。其实这是一个自动化的牛逼思路，这也是这个框架高于前面两个框架的核心原因。但是因为项目规模的原因导致这个点成为了实践中的短板，这也是作者始料未及的。</p>
<p>那我们怎么优化这个点呢？因为要注入方法的类没有做其他的标记，只能扫描所有的类，找到那些遵守了这个协议的再进行注入，这是要注入的类和注入行为的唯一联系点。从设计的角度来说，如果要主动实现注入，确实是这样的，没有更好方案来实现相同的功能。</p>
<p>但是有一个下策，能显著提高这部分性能，就是退回到上面两个框架所做的那样，让用户自己去标识哪些类需要注入。这样我把这些需要注入的类放到一个集合里，遍历注入，这样做性能是最好的。如果我从头设计一个方案，这也是不错的选择。</p>
<p>如果换个思路，我不主动注入，我懒加载，等你调用注入的方法我再执行注入操作呢？如果能实现这个，那问题就解决了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f80ece7045a2e25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>①、开始仍然在 +load 方法中做准备工作，和原有的实现一样，把所有的协议都存到链表中。</p>
<p>②、在 __attribute__((constructor)) 中仍然做是否能执行注入的检查。</p>
<p>③、现在我们 hook NSObject 的 +resolveInstanceMethod: 和 +resolveClassMethod:。</p>
<p>④、在 hook 中进行检查，如果该类有遵守了我们实现了注入的协议，那么就给该类注入容器中的方法。</p>
<p><a href="https://github.com/newyjp/BLMethodInjecting" target="_blank" rel="noopener">https://github.com/newyjp/BLMethodInjecting</a></p>
<h2 id="十一、结语"><a href="#十一、结语" class="headerlink" title="十一、结语"></a>十一、结语</h2><p>依赖注入在 Objective-C、Swift 中是很自然的存在。合理的使用它能让代码可读性更强，可测试性更好，可维护性更高。</p>
<h2 id="十二、文章"><a href="#十二、文章" class="headerlink" title="十二、文章"></a>十二、文章</h2><p><a href="https://blog.csdn.net/linshaolie/article/details/47037941" target="_blank" rel="noopener">依赖注入——让iOS代码更简洁</a></p>
<p><a href="https://blog.csdn.net/Px01Ih8/article/details/84207382" target="_blank" rel="noopener">[iOS]一次高效的依赖注入</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/06/iOS/iOS原理/依赖注入/">http://yoursite.com/2019/08/06/iOS/iOS原理/依赖注入/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/06/算法/二分查找/" class="pre">二分查找</a><a href="/2019/08/06/算法/n次方/" class="next">n 次方</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、简介"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、为什么使用依赖注入"><span class="toc-text">二、为什么使用依赖注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、使用依赖注入"><span class="toc-text">三、使用依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-注入类的类型"><span class="toc-text">3.1 注入类的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-在初始化时依赖分配"><span class="toc-text">3.2 在初始化时依赖分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-延迟初始化依赖"><span class="toc-text">3.3 延迟初始化依赖</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#四、避免多余的配置"><span class="toc-text">四、避免多余的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、系统单例"><span class="toc-text">五、系统单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、不可修改的构造函数"><span class="toc-text">六、不可修改的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、类注册"><span class="toc-text">七、类注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、Storyboards"><span class="toc-text">八、Storyboards</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、公有和私有"><span class="toc-text">九、公有和私有</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、一次高效的依赖注入"><span class="toc-text">十、一次高效的依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-问题场景"><span class="toc-text">10.1 问题场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-依赖注入"><span class="toc-text">10.2 依赖注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-iOS-依赖注入调查"><span class="toc-text">10.3 iOS 依赖注入调查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-EXTConcreteProtocol-实现原理"><span class="toc-text">10.4 EXTConcreteProtocol 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#10-4-1-EXTConcreteProtocol-的使用"><span class="toc-text">10.4.1 EXTConcreteProtocol 的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-4-2-源码解析"><span class="toc-text">10.4.2 源码解析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#10-4-3-问题在哪？"><span class="toc-text">10.4.3 问题在哪？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-解决方案"><span class="toc-text">10.5 解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、结语"><span class="toc-text">十一、结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、文章"><span class="toc-text">十二、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/iOS/iOS原理/NSPredicate/">NSPredicate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/iOS/iOS原理/静态、动态 Pod/">静态、动态 pod</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/iOS/iOS原理/编程思想/">编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/iOS/iOS原理/dyld/">dyld</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/终端/">终端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/Xcode/">Xcode</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/算法设计策略/">算法设计策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/iOS/iOS优化/重构AppDelegate/">重构 AppDelegate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/第 k 小的数/">第 k 小的数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/简单算法/">简单算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>