<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>UITableView优化 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UITableView优化</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">UITableView优化</h1><div class="post-meta"><a href="/2019/08/06/iOS/iOS优化/UITableView优化/#comments" class="comment-count"></a><p><span class="date">Aug 06, 2019</span><span><a href="/categories/iOS优化/" class="category">iOS优化</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、Cell-复用"><a href="#一、Cell-复用" class="headerlink" title="一、Cell 复用"></a>一、Cell 复用</h2><p>在可见的页面会重复绘制页面，每次刷新显示都会去创建新的 Cell，非常耗费性能。 </p>
<p><font color="#008200">解决方案</font>：创建一个<font color="#cc0000">静态变量</font> reuseID，防止重复创建（提高性能），使用系统的缓存池功能。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * CELL_RUID = <span class="string">@"CELL"</span>;  <span class="comment">// 调用次数太多，static 保证只创建一次 reuseID，提高性能</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 缓存池中取已经创建的 cell</span></span><br><span class="line">    <span class="built_in">UITableViewCell</span> * cell = [tableView dequeueReusableCellWithIdentifier:CELL_RUID</span><br><span class="line">                                                             forIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 identifier 标识不同类型的 cell，缓存池中只会保存已经被移出屏幕的不同类型的 cell。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier;  <span class="comment">// Used by the delegate to acquire an already allocated cell, in lieu of allocating a new one.</span></span><br><span class="line">- (__kindof <span class="built_in">UITableViewCell</span> *)dequeueReusableCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier forIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0); <span class="comment">// newer dequeue method guarantees a cell is returned and resized properly, assuming identifier is registered</span></span><br></pre></td></tr></table></figure>
<p><font color="#cc0000">复用 Cell 时 不会调用 awakeFromNib</font>。</p>
<ul>
<li>获取方法的区别</li>
</ul>
<p>dequeueReusableCellWithIdentifier:forIndexPath 如果没有注册复用 identifier，执行这句时会崩溃，提示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reason: 'unable to dequeue a cell with identifier CELL - must register a nib or a class for the identifier or connect a prototype cell in a storyboard'</span><br></pre></td></tr></table></figure>
<p>dequeueReusableCellWithIdentifier 如果没有注册复用 identifier，语句返回 nil，继续执行会崩溃。提示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to obtain a cell from its dataSource</span><br></pre></td></tr></table></figure>
<p>判断 nil 后可以自己创建 cell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MyCell * cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Cell&quot;];</span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[MyCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;Cell&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为什么需要 forIndexPath:</li>
</ul>
<p>因为在返回 cell 之前，会调用委托 tableView:heightForRowAtIndexPath:来确定 cell 尺寸（如果已经定义该函数）。</p>
<p>我们经常在 tableView:cellForRowAtIndexPath: 中为每一个 cell 绑定数据，实际上在调用 cellForRowAtIndexPath: 的时候 cell 还没有被显示出来，为了提高效率我们应该把数据绑定的操作放在 cell 显示出来后再执行，可以在 tableView:willDisplayCell:forRowAtIndexPath: 方法中绑定数据。</p>
<p>注意 willDisplayCell 中 cell 在 tableview 展示之前就会调用，此时 cell 实例已经生成，所以不能更改 cell 的结构，只能是改动 cell 上的 UI 的一些属性，如 label 的内容、控件的隐藏等。</p>
<h2 id="二、定义一种（尽量少）类型的-Cell-及善用-hidden-隐藏（显示）subviews"><a href="#二、定义一种（尽量少）类型的-Cell-及善用-hidden-隐藏（显示）subviews" class="headerlink" title="二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews"></a>二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews</h2><p>分析 Cell 结构，尽可能的将相同内容的抽取到一种样式 Cell 中。UITableView 真正创建出的 Cell 可能只比屏幕显示的多一点。虽然 Cell 的”体积”可能会大点，但是因为 Cell 的<font color="#cc0000">数量不会很多</font>，完全可以接受的。</p>
<p>好处：</p>
<p>①、减少代码量，减少 Nib 文件的数量，在一个 Nib 文件定义 Cell，容易修改、维护；（<font color="#cc0000">多个 Cell 不是更容易维护？</font>）</p>
<p>②、基于复用机制，真正运行时铺满屏幕所需的 Cell 数量大致是固定的，设为 N 个。如果只有一种 cell，那就是只有 N + c 个 cell 的实例；但是如果有 M 种 cell，那么运行时最多可能会是 M * (N + c) 个 cell 的实例，虽然这可能并不会占用太多内存，但能少一些更好。</p>
<p>既然只定义一种 Cell，那么需要把所有不同类型的 view 都定义好，放在 Cell 里面，通过 hidden 属性控制，来显示不同类型的内容。毕竟，在用户快速滑动中，只是单纯的显示/隐藏 subview 比实时创建要快得多。</p>
<p>尽量少用 [cell addSubview:] 动态添加 View，可以初始化时就添加，然后通过 hidden 属性来控制。</p>
<h2 id="三、提前计算并缓存-Cell-的高度"><a href="#三、提前计算并缓存-Cell-的高度" class="headerlink" title="三、提前计算并缓存 Cell 的高度"></a>三、提前计算并缓存 Cell 的高度</h2><h4 id="3-1-固定高度的-cell"><a href="#3-1-固定高度的-cell" class="headerlink" title="3.1 固定高度的 cell"></a>3.1 固定高度的 cell</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="number">88</span>;</span><br></pre></td></tr></table></figure>
<p>直接采用上面方式给定高度，不需要实现 tableView:heightForRowAtIndexPath: 以节省不必要的计算和开销。</p>
<h4 id="3-2-动态高度的-cell"><a href="#3-2-动态高度的-cell" class="headerlink" title="3.2 动态高度的 cell"></a>3.2 动态高度的 cell</h4><p>实现代理方法后，上面的 rowHeight 属性的设置将会变成无效。</p>
<p>tableView:estimatedHeightForRowAtIndexPath: -&gt; tableView:heightForRowAtIndexPath: 获取每个 Cell 即将显示的高度，从而确定表格视图的布局，实际是要获取滚动视图的 contentSize，然后调用 tableView:cellForRowAtIndexPath:，获取每个 Cell，进行赋值。如果有很多个 Cell 要显示，那么方法会执行很多次。</p>
<p><font color="#008200">解决方案</font>：在 Model（Entity）中计算并保存 Cell 的高度。其实 Model 中保存 UI 的参数是很奇怪的，最好放在 MVVM 模式的 ViewModel（视图模型）中，让 Model（数据模型）只负责处理数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Model</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;  <span class="comment">// Cell 高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  计算高度</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">- (<span class="keyword">void</span>)calculateCellHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 tableView:heightForRowAtIndexPath: 中尽量不使用 cellForRowAtIndexPath: 方法来获取 cell，如果你需要用到它，只用一次然后缓存结果。</p>
<p>还可以继续进行优化，提前创建真正显示的、需要加工的数据并缓存。如：接口返回 NSString 而展示 NSAttributeString。</p>
<h2 id="四、异步绘制（自定义-Cell-绘制）"><a href="#四、异步绘制（自定义-Cell-绘制）" class="headerlink" title="四、异步绘制（自定义 Cell 绘制）"></a>四、异步绘制（自定义 Cell 绘制）</h2><p>遇到比较复杂的界面时（复杂点的图文混排），上面缓存行高的方式可能就不能满足要求了。<a href="http://www.cocoachina.com/ios/20150602/11968.html" target="_blank" rel="noopener">详细整理：UITableView 优化技巧</a></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  cell 添加 draw 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)draw</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 异步绘制</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *  @brief  重写 drawRect: 方法 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不需要用 GCD 异步线程，因为 drawRect: 本来就是异步绘制的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绘制的各个信息都是根据之前算好的布局进行绘制的。这里是需要异步绘制。</p>
<h2 id="五、滑动时，按需加载"><a href="#五、滑动时，按需加载" class="headerlink" title="五、滑动时，按需加载"></a>五、滑动时，按需加载</h2><p>自定义 Cell 的种类千奇百怪，但它本来就是用来显示数据的，差不多 100% 带有图片，这个时候就要考虑，下滑的过程中可能会有点卡顿，尤其网络不好的时候，异步加载图片是个程序员都会想到，但是如果给每个循环对象都加上异步加载，开启的线程太多，一样会卡顿。这个时候利用 UIScrollViewDelegate 两个代理方法就能很好地解决这个问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (needLoadArr.count &gt; <span class="number">0</span> &amp;&amp; [needLoadArr indexOfObject:indexPath] == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">         [cell clear];  <span class="comment">// 清掉内容</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定 3 行加载。</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSIndexPath</span> * ip  = [<span class="keyword">self</span>.tableView indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> * cip = [[<span class="keyword">self</span>.tableView indexPathsForVisibleRows] firstObject];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -8 &lt; 当前位置 - 目标位置 &lt; 8</span></span><br><span class="line">    <span class="keyword">if</span> (labs(cip.row - ip.row) &gt; skipCount) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 目标区域的 cell 的 indexPaths</span></span><br><span class="line">        <span class="built_in">NSArray</span> * temp = [<span class="keyword">self</span>.tableView indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.tableView.frame.size.width, <span class="keyword">self</span>.tableView.frame.size.height)];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSMutableArray</span> * arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSIndexPath</span> * indexPath = [temp lastObject];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (indexPath.row + <span class="number">33</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row - <span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思想：识别 UITableView 拖拽即将结束的时候，进行异步加载图片，快滑动过程中，只加载目标范围内的 Cell，这样按需加载，极大的提高流畅度。而 SDWebImage 可以实现异步加载，与这条性能配合就完美了，尤其是大量图片展示的时候。而且也不用担心图片缓存会造成内存警告的问题。</p>
<h2 id="六、缓存-View"><a href="#六、缓存-View" class="headerlink" title="六、缓存 View"></a>六、缓存 View</h2><p>当 Cell 中的部分 View 是非常独立且不便于重用的，”体积”非常小，在内存可控的前提下，完全可以将这些 view 缓存起来。</p>
<h2 id="七、尽量显示“大小刚好合适的”图片资源"><a href="#七、尽量显示“大小刚好合适的”图片资源" class="headerlink" title="七、尽量显示“大小刚好合适的”图片资源"></a>七、尽量显示“大小刚好合适的”图片资源</h2><p>避免大量的图片缩放、颜色渐变等。</p>
<h2 id="八、避免同步的从网络、文件获取数据"><a href="#八、避免同步的从网络、文件获取数据" class="headerlink" title="八、避免同步的从网络、文件获取数据"></a>八、避免同步的从网络、文件获取数据</h2><p>Cell 内实现的内容来自 web，使用异步加载，缓存请求结果。</p>
<h2 id="九、渲染"><a href="#九、渲染" class="headerlink" title="九、渲染"></a>九、渲染</h2><p>1、减少 subviews 的个数和层级</p>
<pre><code>子控件的层级越深，渲染到屏幕上所需要的计算量就越大；如多用 drawRect 绘制元素，替代用 view 显示。
</code></pre><p>2、少用 subviews 的透明图层</p>
<pre><code>渲染最耗时的操作之一就是混合(blending)了。对于不透明的 View，设置 opaque = YES，这样在绘制该 View 时，避免 GPU 对 View 覆盖的其他内容也进行绘制。
</code></pre><p>3、背景色不要使用 clearColor</p>
<p>4、避免 CALayer 特效（shadowPath）</p>
<pre><code>给 Cell 中 View 加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：
</code></pre><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor   = color.CGColor;</span><br><span class="line">view.layer.shadowOffset  = offset;</span><br><span class="line">view.layer.shadowOpacity = <span class="number">1</span>;</span><br><span class="line">view.layer.shadowRadius  = radius;</span><br></pre></td></tr></table></figure>
<p>5、当有图像时，预渲染图像，在 bitmap context 先将其画一遍，导出成 UIImage 对象，然后再绘制到屏幕，这会大大提高渲染速度。具体内容可以自行查找“利用预渲染加速显示 iOS 图像”相关资料。</p>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><p>UITableView 的优化主要从四个方面入手：</p>
<p>1、提前计算并缓存好高度（布局），因为 tableView:heightForRowAtIndexPath: 是调用最频繁的方法；</p>
<p>2、滑动时按需加载，防止卡顿。这个在大量图片展示，网络加载的时候很管用，配合 SDWebImage；</p>
<p>3、异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；</p>
<p>4、缓存一切可以缓存的，这个在开发的时候，往往是性能优化最多的方向。</p>
<p>大概需要关注的：</p>
<p>1、cell 复用</p>
<p>2、cell 高度的计算</p>
<p>3、渲染（混合问题）</p>
<p>4、减少视图的数目（重写 drawRect:）</p>
<p>5、减少多余的绘制操作</p>
<p>6、不要给 cell 动态添加 subView</p>
<p>7、异步化 UI，不要阻塞主线程</p>
<p>8、滑动时按需加载对应的内容</p>
<h2 id="十一、资料"><a href="#十一、资料" class="headerlink" title="十一、资料"></a>十一、资料</h2><p>图片加载优化官方 Demo：<a href="https://developer.apple.com/library/archive/samplecode/LazyTableImages/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009394-Intro-DontLinkElementID_2" target="_blank" rel="noopener">LazyTableImages</a></p>
<p>文章：<a href="http://tutuge.me/2015/02/19/%E6%8F%90%E5%8D%87UITableView%E6%80%A7%E8%83%BD-%E5%A4%8D%E6%9D%82%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">提升 UITableView 性能-复杂页面的优化</a></p>
<p>代码：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/06/iOS/iOS优化/UITableView优化/">http://yoursite.com/2019/08/06/iOS/iOS优化/UITableView优化/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/06/iOS/iOS原理/iOS Category/" class="pre">Category</a><a href="/2019/08/06/算法/01-背包/" class="next">0-1 背包</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Cell-复用"><span class="toc-text">一、Cell 复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、定义一种（尽量少）类型的-Cell-及善用-hidden-隐藏（显示）subviews"><span class="toc-text">二、定义一种（尽量少）类型的 Cell 及善用 hidden 隐藏（显示）subviews</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、提前计算并缓存-Cell-的高度"><span class="toc-text">三、提前计算并缓存 Cell 的高度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-固定高度的-cell"><span class="toc-text">3.1 固定高度的 cell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-动态高度的-cell"><span class="toc-text">3.2 动态高度的 cell</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#四、异步绘制（自定义-Cell-绘制）"><span class="toc-text">四、异步绘制（自定义 Cell 绘制）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、滑动时，按需加载"><span class="toc-text">五、滑动时，按需加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、缓存-View"><span class="toc-text">六、缓存 View</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、尽量显示“大小刚好合适的”图片资源"><span class="toc-text">七、尽量显示“大小刚好合适的”图片资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、避免同步的从网络、文件获取数据"><span class="toc-text">八、避免同步的从网络、文件获取数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、渲染"><span class="toc-text">九、渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、总结"><span class="toc-text">十、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、资料"><span class="toc-text">十一、资料</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/静态、动态 Pod/">静态、动态 pod</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/iOS/iOS原理/NSPredicate/">NSPredicate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/iOS/iOS原理/静态、动态 Pod/">静态、动态 pod</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/iOS/iOS原理/编程思想/">编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/iOS/iOS原理/dyld/">dyld</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/终端/">终端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/Xcode/">Xcode</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/算法设计策略/">算法设计策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/iOS/iOS优化/重构AppDelegate/">重构 AppDelegate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/简单算法/">简单算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>