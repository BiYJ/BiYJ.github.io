<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>最长上升子序列 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">最长上升子序列</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">最长上升子序列</h1><div class="post-meta"><a href="/2019/08/06/算法/最长上升子序列/#comments" class="comment-count"></a><p><span class="date">Aug 06, 2019</span><span><a href="/categories/algorithm/" class="category">algorithm</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。如：[5, <font color="#cc0000">3</font>, <font color="#cc0000">4</font>, 8, <font color="#cc0000">6</font>, <font color="#cc0000">7</font>] 返回 4。</p>
<h2 id="2、算法分析"><a href="#2、算法分析" class="headerlink" title="2、算法分析"></a>2、算法分析</h2><p>面对这个问题，首先要定义一个”<font color="#cc0000">状态</font>“来代表它的子问题， 并且找到它的解。</p>
<p>注意，大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态。</p>
<p>假如考虑求 A[1], A[2], …, A[i], i &lt; N 的最长非降子序列的长度，缩小问题规模，让 i = 1, 2, 3… 来分析，然后定义 d(i)表示前 i 个数中以 A[i] 结尾的最长非降子序列的长度。</p>
<p>这个 d(i) 就是我们要找的状态。 如果我们把 d(1) 到 d(N) 都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p>
<p>以上面的例子来方便理解如何找到状态转移方程的，N 个数的序列是：</p>
<p>5  3  4  8  6  7</p>
<p>根据上面找到的状态，可以得到：</p>
<ul>
<li>i = 1 的 LIS 长度 d(1) = 1, d[] = {5}</li>
<li>i = 2 的 LIS 长度 d(2) = 1, d[] = {3}</li>
<li>i = 3 的 LIS 长度 d(3) = d(2) + 1 = 2, d[] = {3, 4}</li>
<li>i = 4 的 LIS 长度 d(4) = <font color="#cc0000">max{ d(1), d(2), d(3) } + 1</font> = 3, d[] = {3, 4, 8}</li>
</ul>
<p>状态转移方程已经很明显了，如果已经求出了 d(1) 到 d(i-1)， 那么 d(i) 可以用下面的状态转移方程得到：</p>
<pre><code>d(i) = max{ 1, d(j) + 1 }, 其中 j &lt; i, A\[j\] &lt;= A\[i\]
</code></pre><p>想要求 d(i)，就把 i 前面的各个子序列中， 最后一个数不大于 A[i] 的序列长度加 1，然后取出最大的长度即为 d(i)。 当然了，有可能 i 前面的各个子序列中最后一个数都大于 A[i]，那么 d(i) = 1， 即它自身成为一个长度为 1 的子序列。</p>
<p>分析完了，上图。</p>
<center><img src="https://upload-images.jianshu.io/upload_images/5294842-c89874d9e421af0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center>

<h2 id="3、复杂度分析"><a href="#3、复杂度分析" class="headerlink" title="3、复杂度分析"></a>3、复杂度分析</h2><p>时间复杂度：O(n<sup>2</sup>)</p>
<p>空间复杂度：O(n)</p>
<h2 id="4、代码实现"><a href="#4、代码实现" class="headerlink" title="4、代码实现"></a>4、代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *d = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i)&#123;</span><br><span class="line">        </span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="comment">// 如果当前的数值 A[i] 大于 它之前的数值 A[j] &amp;&amp; 最长的段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i] &amp;&amp; d[j] + <span class="number">1</span> &gt; d[i])</span><br><span class="line">                d[i] = d[j] + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; len) len = d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;</span><br><span class="line">        <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">6</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、进阶：O-nlogn-算法"><a href="#5、进阶：O-nlogn-算法" class="headerlink" title="5、进阶：O(nlogn)算法"></a>5、进阶：<a href="https://www.felix021.com/blog/read.php?1587" target="_blank" rel="noopener">O(nlogn)算法</a></h2><p>假设序列 d[9] = { 2, 1, 5, 3, 6, 4, 8, 9, 7 }。</p>
<p>定义一个序列 B，令 i = 1 to 9 循环考察 d 数组。用一个变量 Len 来记录最大的递增长度。<font color="#cc0000">注意：B 的索引从 1 开始</font>。</p>
<pre><code>①、把 d\[0\] 有序地放到 B 里，令 B\[1\] = 2，即当只有一个数字 2 的时候，Len = 1 的 LIS 的末尾最大值是 2。

②、把 d\[2\] 有序地放到 B 里，令 B\[1\] = 1，即 Len = 1 的 LIS 的末尾最大值是 1，d\[1\] = 2 已经没用了，因为 2 &gt; 1。

③、d\[3\] = 5，因为 d\[3\] &gt; B\[1\]，所以令 B\[1+1\] = B\[2\] = d\[3\] = 5，即 Len = 2 的 LIS 的最小末尾是 5，这时 B\[\] = { 1, 5 }。

④、d\[4\] = 3，B\[1\] &lt; d\[3\] &lt; B\[2\]，放在 B\[1\] 的位置显然不合适，因为 1 &lt; 3，不应该替换到小的值，而应该淘汰掉大的值，因为这样容易产生更长的序列，所以 Len = 2 的 LIS 最小末尾是 3，将 5 淘汰掉，这时 B\[\] = { 1, 3 }。

⑤、d\[5\] = 6，因为 d\[5\] &gt; B\[2\]，所以令 B\[2+1\] = B\[3\] = d\[5\] = 6，即 Len = 3 的 LIS 的最小末尾是 6，这时 B\[\] = { 1, 3, 6 }。

⑥、d\[6\] = 4，3 &lt; d\[6\] &lt; 6，于是把 6 替换掉，这时 Len = 3, B\[\] = { 1, 3, 4 }。

⑦、d\[7\] = 8，d\[7\] &gt; B\[3\]，将 8 追加到 B 数组末尾，这时 Len = 4, B\[\] = { 1, 3, 4, 8 }。

⑧、d\[8\] = 9，d\[8\] &gt; B\[4\]，将 9 追加到 B 数组末尾，这时 Len = 5, B\[\] = { 1, 3, 4, 8, 9 }。

⑨、d\[9\] = 7，B\[3\]=4 &lt; d\[9\] &lt; B\[4\]=8，所以最新的 B\[4\] = 7，这时 Len = 5, B\[\] = 1, 3, 4, 7, 9。
</code></pre><font color="#cc0000">注意：{ 1, 3, 4, 7, 9 } 不是 LIS，它只是存储的对应长度 LIS 的最小末尾。</font>

<center><img src="https://upload-images.jianshu.io/upload_images/5294842-94203c725d0f85fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></center>

<p>有了这个末尾，就可以一个一个地插入数据。虽然最后一个 d[9] = 7 更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9（d[11] = { 2, 1, 5, 3, 6, 4, 8, 9, 7, 8, 9 }），那么继续执行下去，8 更新到 d[5]，9 更新到 d[6]，得出 LIS 的长度为 6，B[] = { 1, 3, 4, 7, 8, 9 }。</p>
<p>在 B 中插入数据是有序的，而且是进行替换而不需要挪动，所以可以利用二分查找，将每一个数字的插入时间优化到 O(logn)，于是算法的时间复杂度就降低到了 O(nlogn)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在非递减序列 [left, right]（闭区间）上二分查找第一个大于等于 key 的位置，如果都小于 key，就返回 left+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> B[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="comment">// 将 key 插入到数组末尾</span></span><br><span class="line">    <span class="keyword">if</span> (B[right] &lt; key)</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// num[left] ≤ key &lt; nums[right] 之后 left 将大于 right，循环结束</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (B[mid] &lt; key) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="keyword">int</span>* B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (numsSize + <span class="number">1</span>));</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 无意义</span></span><br><span class="line">    B[<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 从 1 开始是为了让 len、pos 不需要 -1 或 +1</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到插入位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = upper_bound(B, <span class="number">1</span>, len, nums[i]);</span><br><span class="line">        B[pos] = nums[i];</span><br><span class="line">        <span class="comment">// 打印 B 数组，看看每次循环的变化，B[0] 无意义</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d    "</span>, pos);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= pos; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, B[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &lt; pos) &#123;</span><br><span class="line">            len = pos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123; <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, lengthOfLIS(A, <span class="number">11</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/06/算法/最长上升子序列/">http://yoursite.com/2019/08/06/算法/最长上升子序列/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/06/算法/最长回文子串/" class="pre">最长回文子串</a><a href="/2019/08/06/算法/整数划分/" class="next">整数划分</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、问题描述"><span class="toc-text">1、问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、算法分析"><span class="toc-text">2、算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、复杂度分析"><span class="toc-text">3、复杂度分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、代码实现"><span class="toc-text">4、代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、进阶：O-nlogn-算法"><span class="toc-text">5、进阶：O(nlogn)算法</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/">iOS UmbrellaFramework</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/">iOS umbrella header</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS媒体/iOS 图片/">iOS 图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS优化/iOS 优化实例/">iOS 优化实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS原理/iOS 操作系统架构/">iOS 操作系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS架构/iOS 网络层设计/">iOS网络层设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS 类簇/">iOS 类簇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS OCR/">iOS OCR</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS IM/">iOS IM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/iOS/iOS原理/iOS 推送/">iOS 推送</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT/">IT</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL/">OpenGL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS动画/">iOS动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS媒体/">iOS媒体</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS安全/">iOS安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">5</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>