<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Runtime | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Runtime</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Runtime</h1><div class="post-meta"><a href="/2019/08/06/Runtime/#comments" class="comment-count"></a><p><span class="date">Aug 06, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。<font color="#cc0000">函数标识与函数实现之间的关联可以动态修改</font>。</p>
<p><font color="#cc000">OC 把一些决定工作从编译链接推迟到运行时</font>，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，还需要一个运行时系统 （runtime system）来执行编译后的代码，它是整个 OC 运行框架的一块基石。</p>
<p>Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事：</p>
<ol>
<li><p>封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。</p>
</li>
<li><p>传递消息，找出方法的最终执行代码。</p>
<p> ①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）；  </p>
<p> ②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 =&gt; 备用接收者 =&gt; 签名+打包+完整转发）</p>
</li>
</ol>
<blockquote>
<p>动态加载：<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="noopener">NSBundle</a>类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[receiver message];  </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)</span></span><br><span class="line">[receiver message:(<span class="keyword">id</span>)arg...]; </span><br><span class="line"><span class="comment">// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, ...)</span></span><br></pre></td></tr></table></figure>
<p>Runtime 其实有两个版本：modern 和 legacy。我们现在用的 Objective-C 2.0 采用的是现行（Modern）版的 Runtime 系统，只能运行在 iOS 和 OS X 10.5 之后的 64 位程序中。而 OS X 较老的 32 位程序仍采用 Objective-C 1 中的 Legacy 版本。</p>
<p>当更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<p>Runtime 基本是用 C 和汇编（437 版本开始较多使用 mm 文件，但是仍用 C 语法）实现的，可见苹果为了动态系统的高效而作出了很多努力。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime源码</a>，苹果和 GNU 各自维护一个开源的 runtime 版本，两个版本在努力的保持一致。</p>
<h2 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h2><p>Objc 与 Runtime 相关：</p>
<p>①、通过 Objective-C 源代码<br>②、通过 Foundation 框架的 NSObject 类定义的方法<br>③、通过对 Runtime 库函数的直接调用</p>
<h4 id="2-1-Objective-C-源代码"><a href="#2-1-Objective-C-源代码" class="headerlink" title="2.1 Objective-C 源代码"></a>2.1 Objective-C 源代码</h4><p>多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。</p>
<h4 id="2-2-通过-Foundation-框架的-NSObject-类定义的方法"><a href="#2-2-通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="2.2 通过 Foundation 框架的 NSObject 类定义的方法"></a>2.2 通过 Foundation 框架的 NSObject 类定义的方法</h4><p>Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类）</p>
<p>NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。</p>
<p>一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如：</p>
<ul>
<li>-class 方法返回对象的类；</li>
<li>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中</li>
<li>-respondsToSelector: 检查对象能否响应指定的消息；</li>
<li>-conformsToProtocol: 检查对象是否实现了指定协议类的方法；</li>
<li>-methodForSelector: 返回指定方法实现的地址。</li>
</ul>
<h4 id="2-3-通过对-Runtime-库函数的直接调用"><a href="#2-3-通过对-Runtime-库函数的直接调用" class="headerlink" title="2.3 通过对 Runtime 库函数的直接调用"></a>2.3 通过对 Runtime 库函数的直接调用</h4><p>Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。</p>
<p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。</p>
<h2 id="三、Runtime-相关的头文件"><a href="#三、Runtime-相关的头文件" class="headerlink" title="三、Runtime 相关的头文件"></a>三、Runtime 相关的头文件</h2><p>ios 的 sdk 中 usr/include/objc 文件夹下面有这样几个文件</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List.h</span><br><span class="line"><span class="built_in">NSObjCRuntime</span>.h</span><br><span class="line"><span class="built_in">NSObject</span>.h</span><br><span class="line">Object.h</span><br><span class="line">Protocol.h</span><br><span class="line">a.txt</span><br><span class="line">hashtable.h</span><br><span class="line">hashtable2.h</span><br><span class="line">message.h</span><br><span class="line">module.map</span><br><span class="line">objc-api.h</span><br><span class="line">objc-auto.h</span><br><span class="line">objc-<span class="keyword">class</span>.h</span><br><span class="line">objc-exception.h</span><br><span class="line">objc-load.h</span><br><span class="line">objc-runtime.h</span><br><span class="line">objc-sync.h</span><br><span class="line">objc.h</span><br><span class="line">runtime.h</span><br></pre></td></tr></table></figure>
<p>都是和运行时相关的头文件，其中主要使用的函数定义在 message.h 和 runtime.h 这两个文件中。 在 message.h 中主要包含了一些向对象发送消息的函数，这是 OC 对象方法调用的底层实现。 runtime.h 是运行时最重要的文件，其中包含了对运行时进行操作的方法。 主要包括：</p>
<h4 id="3-1-操作对象的类型的定义"><a href="#3-1-操作对象的类型的定义" class="headerlink" title="3.1 操作对象的类型的定义"></a>3.1 操作对象的类型的定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents a method in a class definition.  一个类型，代表着类定义中的一个方法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an instance variable.  代表实例(对象)的变量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents a category.  代表一个分类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C declared property.  代表OC声明的属性</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 代表一个类，它在 objc.h 中这样定义的 typedef struct objc_class *Class;</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>这些类型的定义，对一个类进行了完全的分解，将类定义或者对象的每一个部分都抽象为一个类型 type，对操作一个类属性和方法非常方便。OBJC2_UNAVAILABLE 标记的属性是 Ojective-C 2.0 不支持的，但实际上可以用响应的函数获取这些属性，例如：如果想要获取 Class 的 name 属性，可以按如下方法获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class cls = obj.class;</span><br><span class="line"><span class="comment">// NSLog(@"%s", cls-&gt;name); // 用这种方法已经不能获取 name 了因为OBJC2_UNAVAILABLE</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(cls);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br></pre></td></tr></table></figure>
<h4 id="3-2-函数的定义"><a href="#3-2-函数的定义" class="headerlink" title="3.2 函数的定义"></a>3.2 函数的定义</h4><blockquote>
<p>操作对象的方法一般以 object_ 开头<br>操作类的方法一般以 class_ 开头<br>操作类或对象的方法的方法一般以 method_ 开头<br>操作成员变量的方法一般以 ivar_ 开头<br>操作属性的方法一般以 property_ 开头<br>操作协议的方法一般以 protocol_ 开头</p>
<p>以 objc_ 开头的方法，则是 runtime 最终的管家，可以获取内存中类的加载信息、类的列表、关联对象和关联属性等操作。</p>
</blockquote>
<p>根据以上的函数的前缀可以大致了解到层级关系。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 runtime 对当前的应用中加载的类进行打印</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Class * clsList = objc_copyClassList(&amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * clsName = class_getName(clsList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、术语及其数据结构"><a href="#四、术语及其数据结构" class="headerlink" title="四、术语及其数据结构"></a>四、术语及其数据结构</h2><h4 id="4-1-SEL"><a href="#4-1-SEL" class="headerlink" title="4.1 SEL"></a>4.1 SEL</h4><p>它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，<font color="#cc0000">本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度</font>。它的数据结构是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;  <span class="comment">// An opaque type that represents a method selector.</span></span><br></pre></td></tr></table></figure>
<p>可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。</p>
<blockquote>
<p>注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p>
</blockquote>
<h4 id="4-2-id"><a href="#4-2-id" class="headerlink" title="4.2 id"></a>4.2 id</h4><p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">struct</span> objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<p>objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。</p>
<blockquote>
<p>注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。</p>
<p>Direct access to Objective-C’s isa is deprecated in favor of object_getClass()</p>
</blockquote>
<p><a href="http://lizhaoloveit.com/2014/05/11/KVO/" target="_blank" rel="noopener">KVO</a> 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。</p>
<h4 id="4-3-Class"><a href="#4-3-Class" class="headerlink" title="4.3 Class"></a>4.3 Class</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">/*  父类  */</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;   </span><br><span class="line">    <span class="comment">/*  类名  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类的版本信息，默认为 0 */</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 类信息，供运行时期使用的一些位标识。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;</span></span><br><span class="line"><span class="comment">         CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实例变量大小（包括从父类继承下来的实例变量）*/</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 成员变量地址列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法地址列表，与 info 的一些标志位有关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如 CLS_CLASS (0x1L)，则存储实例方法；CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists   OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 缓存最近使用的方法地址，用于提升效率 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 存储该类声明遵守的协议的列表 */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;  </span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p>
<p>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list &#123;</span><br><span class="line">    <span class="keyword">int</span> ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar ivar_list[<span class="number">1</span>]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法列表</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解 Objective-C: Category</a>。</p>
<p>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p>
<p>值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。</p>
<blockquote>
<p>实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）；</p>
<p>类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。</p>
</blockquote>
<p>为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p>
<p>开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p>当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSObject</span>.class alloc];    <span class="comment">// [NSObject alloc]</span></span><br></pre></td></tr></table></figure>
<p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f45adc9fd1faea0b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Meta Class"></p>
<p>实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。</p>
<p>最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。</p>
<h4 id="4-4-Method"><a href="#4-4-Method" class="headerlink" title="4.4 Method"></a>4.4 Method</h4><p>代表类中某个方法的类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name            OBJC2_UNAVAILABLE;   <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable method_types       OBJC2_UNAVAILABLE;   <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp             OBJC2_UNAVAILABLE;   <span class="comment">// 方法实现</span></span><br><span class="line">&#125;   </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">*   method\_name 类型为 SEL</span><br><span class="line">*   method\_types 是个 <span class="keyword">char</span> 指针，存储方法的参数类型和返回值类型</span><br><span class="line">*   method\_imp 指向了方法的实现，本质是一个函数指针</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 4.5 Ivar</span></span><br><span class="line"></span><br><span class="line">表示成员变量的类型。</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_name                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> * _Nullable ivar_type                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                           OBJC2_UNAVAILABLE;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                 OBJC2_UNAVAILABLE;  <span class="comment">// 占用空间</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-IMP"><a href="#4-6-IMP" class="headerlink" title="4.6 IMP"></a>4.6 IMP</h4><p>objc.h 中定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br></pre></td></tr></table></figure>
<p>它就是一个<font color="#cc0000">由编译器生成的函数指针，指向方法实现的首地址</font>。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<p>如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p>
<p>你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p>
<h4 id="4-7-Cache"><a href="#4-7-Cache" class="headerlink" title="4.7 Cache"></a>4.7 Cache</h4><p>runtime.h 中定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">/* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 实际占用cache buckets的总数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Method _Nullable buckets[<span class="number">1</span>]                              OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<h4 id="4-8-Property"><a href="#4-8-Property" class="headerlink" title="4.8 Property"></a>4.8 Property</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;  <span class="comment">// 这个更常用</span></span><br></pre></td></tr></table></figure>
<p>可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">class_copyPropertyList(Class _Nullable cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT objc_property_t _Nonnull * _Nullable</span><br><span class="line">protocol_copyPropertyList(Protocol * _Nonnull proto,</span><br><span class="line">                          <span class="keyword">unsigned</span> <span class="keyword">int</span> * _Nullable outCount)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。</p>
</blockquote>
<p>property_getName() 用来查找属性的名称，返回 c 字符串。<br>property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。<br>class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e2cb59d1344df2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象结构图"></p>
<h2 id="五、消息"><a href="#五、消息" class="headerlink" title="五、消息"></a>五、消息</h2><p>体会官方文档中的 messages aren’t bound to method implementations until Runtime。<font color="#cc0000">消息直到运行时才会与方法实现进行绑定</font>。</p>
<p>这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-2d3464848b8f4fc2?imageMogr2/auto-orient/strip" alt="消息发送"></p>
<p>①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数；</p>
<p>②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</p>
<p>③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。</p>
<p>④、如果 cache 找不到就找类的方法列表中是否有对应的方法。</p>
<p>⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。</p>
<p>⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。</p>
<p>在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。</p>
<h4 id="5-1-方法中的隐藏参数"><a href="#5-1-方法中的隐藏参数" class="headerlink" title="5.1 方法中的隐藏参数"></a>5.1 方法中的隐藏参数</h4><blockquote>
<p>我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？</p>
</blockquote>
<p>其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。</p>
<p>当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<ul>
<li>self 当前方法的对象指针，接受消息的对象</li>
<li>_cmd 当前方法的 SEL 指针，方法选择器</li>
</ul>
<p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull <span class="keyword">id</span> receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class <span class="keyword">class</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体指明了消息应该被传递给特定的父类。</p>
<p>receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">25.082134</span>+<span class="number">0800</span> Demo[<span class="number">22838</span>:<span class="number">128408</span>] ViewController   <span class="comment">// 当前类</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-获取方法地址"><a href="#5-2-获取方法地址" class="headerlink" title="5.2 获取方法地址"></a>5.2 获取方法地址</h4><p>NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          [<span class="keyword">self</span> fail:<span class="literal">YES</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fail:(<span class="built_in">BOOL</span>)value</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">06</span>:<span class="number">22.683838</span>+<span class="number">0800</span> Demo[<span class="number">36187</span>:<span class="number">211037</span>] <span class="number">4.104993</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>) = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(fail:)];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">CFTimeInterval</span> ti = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">setter</span>(<span class="keyword">self</span>, <span class="keyword">@selector</span>(fail:), <span class="literal">YES</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - ti);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">05</span>:<span class="number">48.480498</span>+<span class="number">0800</span> Demo[<span class="number">36095</span>:<span class="number">209893</span>] <span class="number">3.751424</span></span><br></pre></td></tr></table></figure>
<p>虽然是更高效的调用方法，但这种做法很少用，除非是<font color="#cc0000">需要持续大量重复调用某个方法</font>的情况，才会选择使用，<font color="#cc0000">以免消息发送泛滥</font>。</p>
<blockquote>
<p>注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</p>
</blockquote>
<h2 id="六、动态方法解析"><a href="#六、动态方法解析" class="headerlink" title="六、动态方法解析"></a>六、动态方法解析</h2><p>如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br></pre></td></tr></table></figure>
<p>这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p>
<p>Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP) dynamicIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p>
<blockquote>
<p>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。</p>
</blockquote>
<h2 id="七、消息转发"><a href="#七、消息转发" class="headerlink" title="七、消息转发"></a>七、消息转发</h2><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f7a92a32f8cc7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<p>①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步；</p>
<p>②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步；</p>
<p>③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步；</p>
<p>④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。</p>
<h4 id="7-1-重定向"><a href="#7-1-重定向" class="headerlink" title="7.1 重定向"></a>7.1 重定向</h4><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(xxx:))&#123;</span><br><span class="line">          <span class="keyword">return</span> otherObj;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。</p>
<h4 id="7-2-转发"><a href="#7-2-转发" class="headerlink" title="7.2 转发"></a>7.2 转发</h4><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [otherObj methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @param  anInvocation  封装了原始的消息和消息的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 判断 otherObj 对象是否实现了方法</span></span><br><span class="line">     <span class="keyword">if</span> ([otherObj respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:otherObj];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p>
<blockquote>
<p>参数 anInvocation 是从哪来的？</p>
<p>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</p>
</blockquote>
<p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p>
<p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p>
<blockquote>
<p>forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。</p>
</blockquote>
<h4 id="7-3-转发和多继承"><a href="#7-3-转发和多继承" class="headerlink" title="7.3 转发和多继承"></a>7.3 转发和多继承</h4><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-70cda98ab8c42661?imageMogr2/auto-orient/strip" alt></p>
<p>在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p>
<h4 id="7-4-转发与继承"><a href="#7-4-转发与继承" class="headerlink" title="7.4 转发与继承"></a>7.4 转发与继承</h4><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p>
<p>如果判断上图中的 Warrior 对象是否能响应 negotiate 消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( [aWarrior respondsToSelector:<span class="keyword">@selector</span>(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。</p>
<p>如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector] )</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/* Here, test whether the aSelector message can     *</span></span><br><span class="line"><span class="comment">           * be forwarded to another object and whether that  *</span></span><br><span class="line"><span class="comment">           * object can respond to it. Return YES if it can.  */</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。</p>
<p>如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。</p>
<h2 id="八、应用场景"><a href="#八、应用场景" class="headerlink" title="八、应用场景"></a>八、应用场景</h2><h4 id="8-1-获取属性-成员变量列表"><a href="#8-1-获取属性-成员变量列表" class="headerlink" title="8.1 获取属性/成员变量列表"></a>8.1 获取属性/成员变量列表</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的定义了一个成员变量和两个属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">         <span class="built_in">CGFloat</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用 class_copyIvarList() 函数获取成员变量的列表，使用 class_copyPropertyList() 函数获取属性列表：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"Person"</span>);   <span class="comment">// Class cls = Person.class;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取成员变量数组</span></span><br><span class="line">    Ivar * ivarList = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取成员变量名</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivarList[i]); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivarName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取属性数组</span></span><br><span class="line">    objc_property_t * ptyList = class_copyPropertyList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * ptyName = property_getName(ptyList[i]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ptyName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905326</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905486</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905616</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905745</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">03.905877</span>+<span class="number">0800</span> Demo[<span class="number">5894</span>:<span class="number">1444503</span>] age</span><br></pre></td></tr></table></figure>
<p>从这里就可以看出 @property 做了三件事：</p>
<p>①、生成一个带下划线的成员变量<br>②、生成这个成员变量的 set 方法<br>③、生成这个成员变量的 get 方法</p>
<p>因此会输出三个成员变量 _height、_age 和 _name。并且从上面可知 ivarList 能够获取到 @property 关键字定义的属性 ，而 propertyList 不能获取到成员变量。即用 ivarList 可以获取到所有的成员变量和属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> * name;  <span class="comment">// 只读属性</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"job"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.690815</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _height</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691025</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] _age</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691159</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] name</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">52.691308</span>+<span class="number">0800</span> Demo[<span class="number">6025</span>:<span class="number">1474196</span>] age</span><br></pre></td></tr></table></figure>
<p>当只读属性 name 重写了 getter 方法时，无论使用 ivarList 还是使用 propertyList 都无法获取到 _name 成员变量。</p>
<blockquote>
<p>一个 readonly 的属性，到底是 didSet+set 好，还是重写 getter 好?</p>
</blockquote>
<p>大部分的 readonly 的属性是计算型的，依赖于其他属性，因此可以使用 didSet+set，也就是在其他属性的 set 方法内，将只读属性 set。 但是 didSet+set 有时候完全没有必要，不符合懒加载的规则，浪费了计算能力，用重写 getter 的方法好一些。</p>
<blockquote>
<p>在 KVC 时，想要获取全部的成员变量和属性， 怎么办呢？</p>
</blockquote>
<p>首先要了解 setValue:forKeyPath: 方法的底层实现：</p>
<p>①、首先去类的方法列表去寻找有没有 setter 方法，如果有，就直接调用 [obj setXX:value]<br>②、查找有没有成员变量 _XX，如果有 _XX = value；<br>③、查找有没有成员变量 XX，如果有 XX = value；<br>④、如果都没有找到，直接报错。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSUnknownKeyException', </span><br><span class="line">reason: '[&lt;Person 0x102bb7388&gt; setValue:forUndefinedKey:]: </span><br><span class="line"><span class="keyword">this</span> <span class="keyword">class</span> is not key value coding-compliant <span class="keyword">for</span> the key name.<span class="string">'</span></span><br></pre></td></tr></table></figure>
<p>首先，只读属性为什么要为它赋值呢，因此对它进行 kvc 也不合情理。</p>
<p>另外，对于重写了 getter 的只读属性而言：如果对 propertyList 的属性一次使用 kvc，就会报错，因此为保证代码正常，不能使用 propertyList 的属性进行 kvc；</p>
<p>使用 ivaList 时是无法获取到重写了 getter 的只读属性，因此是 kvc 的最佳方案。再者，使用 propertyList 无法获取成员变量 _height，无法对成员变量进行赋值。而使用 ivaList 是可以将需要赋值的成员变量都获取的。</p>
<p>要想不对 _height 成员变量赋值，在 kvc 时又可以这样改进一下，通过 ivarList 获取，去掉 propertyList 中没有的成员变量，这样就过滤掉了 _height。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> * timer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSThread</span> * thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) AModel * a;  <span class="comment">// 自定义对象</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     objc_property_t * propertyList = class_copyPropertyList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, property_getAttributes(propertyList[i]));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839596</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSTimer"</span>,W,N,V_timer</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839692</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"NSThread"</span>,&amp;,N,V_thread</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">37.839771</span>+<span class="number">0800</span> Demo[<span class="number">39749</span>:<span class="number">288880</span>] T<span class="string">@"AModel"</span>,R,N,V_a</span><br></pre></td></tr></table></figure>
<p>通过 property_getAttributes() 方法获取属性的参数。</p>
<h4 id="8-2-KVC字典转模型"><a href="#8-2-KVC字典转模型" class="headerlink" title="8.2 KVC字典转模型"></a>8.2 KVC字典转模型</h4><p>获取属性/成员列表一个重要的应用就是：一次取出模型中的属性/成员变量，根据变量名获取字典中的 key 然后取出对应的 value，使用 setValue:forKeyPath: 方法设置值。</p>
<p>为什么要这样，而不再使用方法 setValuesForKeysWithDictionary:。因为在 setValuesForKeysWithDictionary: 方法内部会执行这样一个过程：</p>
<p>①、遍历字典里面的所有 key，取出 key；<br>②、取出 key 的 value，即 dict[key]；<br>③、使用方法 [setValue:value forKeyPath:key] 给模型的属性/成员变量进行赋值。</p>
<p>因此，开发中经常遇到的字典中的 key 比模型中多时，会出现的 this class is not key-value compliant for ‘xxx’ 这个 bug，是因为模型中没有这个属性/成员变量。当模型中的属性比字典中多时，使用 setValuesForKeysWithDictionary: ，多出来的属性是对象类型时为 null，基本数据类型时会有一个系统默认值（如 int 为 0）。</p>
<p>因此使用逐一为属性赋值的方法进行 KVC：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">     Class cls = Person.class;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">     Person * person = [[Person alloc] init];</span><br><span class="line">     <span class="built_in">NSDictionary</span> * dict = @&#123;  <span class="string">@"name"</span> : <span class="string">@"Tom"</span>, <span class="string">@"age"</span> : @<span class="number">19</span>, <span class="string">@"height"</span>: @<span class="number">175</span> &#125;;</span><br><span class="line">    </span><br><span class="line">     Ivar * ivars = class_copyIvarList(cls, &amp;count);</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * clsName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:clsName];</span><br><span class="line">          <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];  <span class="comment">// 去掉'_'</span></span><br><span class="line">          [person setValue:dict[key] forKey:key];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-04</span> <span class="number">19</span>:<span class="number">42</span>:<span class="number">16.964474</span>+<span class="number">0800</span> Demo[<span class="number">6425</span>:<span class="number">1574210</span>] height:<span class="number">175.0000</span>，name:Tom，age:<span class="number">19</span>，time:(null)</span><br></pre></td></tr></table></figure>
<p>使用这种方式进行 kvc，即使字典中的 key 多的时候也不会有 bug。</p>
<p>但新的问题出现了，如果模型中的属性比字典中的 key 多便会出现 bug，而且如果多的是对象类型不会有 bug，该属性的值为 null，如果是基本数据类型就会出错 could not set nil as the value for the key ‘xxx’。</p>
<blockquote>
<p>setObject:forKey: 如果 value 传 nil 会直接报错；setValue:forKey: 则不会，会赋值 nil。具体可以看文档说明。</p>
</blockquote>
<p>解决基础类型被赋值 nil 的 bug：可以在 [setValue:value forKeyPath:key] 方法调用之前取出属性对应的类型，如果类型是基本数据类型，value 替换为默认值（如 int 对应默认值为 0）。</p>
<p>runtime 提供的 ivar_getTypeEncoding() 函数可以获取到属性的类型。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">     <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">     <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> * coding = ivar_getTypeEncoding(ivars[i]); <span class="comment">// 获取类型</span></span><br><span class="line">     <span class="built_in">NSString</span> * strCode = [<span class="built_in">NSString</span> stringWithUTF8String:coding];</span><br><span class="line">     <span class="keyword">id</span> value = dict[key];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ([strCode isEqualToString:<span class="string">@"f"</span>]) &#123;  <span class="comment">// 判断类型是否是 float</span></span><br><span class="line">          value = @(<span class="number">0.0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     [person setValue:value forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>method_getTypeEncoding() 函数可以获取到方法类型编码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     Method m = class_getInstanceMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(<span class="keyword">do</span>:at:on:));</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, method_getTypeEncoding(m));</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)<span class="keyword">do</span>:(<span class="built_in">NSString</span> *)something at:(<span class="keyword">char</span>)place on:(<span class="keyword">int</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">42</span>:<span class="number">30.891829</span>+<span class="number">0800</span> Demo[<span class="number">38588</span>:<span class="number">270099</span>] B32@<span class="number">0</span>:<span class="number">8</span>@<span class="number">16</span>c24i28</span><br></pre></td></tr></table></figure>
<p>property_getAttributes() 函数可以获取到属性的参数。<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="noopener">Declared Properties</a></p>
<h4 id="8-3-NSCoding-归档和解档"><a href="#8-3-NSCoding-归档和解档" class="headerlink" title="8.3 NSCoding 归档和解档"></a>8.3 NSCoding 归档和解档</h4><p>获取属性/成员列表另外一个重要的应用就是进行归档和解档，其原理和上面的 kvc 基本上一样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">          <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">          <span class="built_in">NSString</span> * key  = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];  <span class="comment">// 取出 key 对应的 value</span></span><br><span class="line">          [aCoder encodeObject:value forKey:key];   <span class="comment">// 编码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          Ivar * ivars = class_copyIvarList(<span class="keyword">self</span>.class, &amp;count);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">char</span> * ivarName = ivar_getName(ivars[i]);</span><br><span class="line">               <span class="built_in">NSString</span> * name = [<span class="built_in">NSString</span> stringWithUTF8String:ivarName];</span><br><span class="line">               <span class="built_in">NSString</span> * key = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];  <span class="comment">// 解码</span></span><br><span class="line">               [<span class="keyword">self</span> setValue:value forKey:key];  <span class="comment">// 设置 key 对应的 value</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-交换方法实现"><a href="#8-4-交换方法实现" class="headerlink" title="8.4 交换方法实现"></a>8.4 交换方法实现</h4><p>交换两个方法的实现一般写在类的 load 方法里面，因为 load 方法会在程序运行前加载一次，而 initialize 方法会在类或者子类第一次使用的时候调用，当有分类的时候会调用多次。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">          Method orginalMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">          Method swizzleMethod = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(my_imageNamed:));</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//方法交换</span></span><br><span class="line">          method_exchangeImplementations(orginalMethod, swizzleMethod);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">UIImage</span> *)my_imageNamed:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> my_imageNamed:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是</p>
<p>①、可以交换的两个方法的参数必须是匹配的，参数的类型一致。<br>②、如果想在 my_imageNamed: 的内部调用 imageNamed: 方法，此时调用 [self my_imageNamed:name] 实际上是在调用 imageName: 的代码实现。</p>
<p>任何一个方法都有两个重要的属性：SEL 方法的编号，IMP 方法的实现。方法的调用过程实际上是根据 SEL 去寻找 IMP。</p>
<h4 id="8-5-类-对象的关联对象"><a href="#8-5-类-对象的关联对象" class="headerlink" title="8.5 类/对象的关联对象"></a>8.5 类/对象的关联对象</h4><p>关联对象不是为类/对象添加属性或者成员变量（因为在设置关联后也无法通过 ivarList 或者 propertyList 取得) ，而是为类添加一个相关的对象，通常用于存储类信息，例如存储类的属性列表数组，为将来字典转模型的方便。 例如，将属性的名称存到数组中设置关联</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参数 1 : 关联到对象</span></span><br><span class="line"><span class="comment">   参数 2 : 关联的 key，可以是任意类型</span></span><br><span class="line"><span class="comment">   参数 3 : 被关联的对象</span></span><br><span class="line"><span class="comment">   参数 4 : 关联引用的规则</span></span><br><span class="line"><span class="comment">           enum &#123;</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_ASSIGN = 0,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY_NONATOMIC = 3,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_RETAIN = 01401,</span></span><br><span class="line"><span class="comment">                OBJC_ASSOCIATION_COPY = 01403</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, key, value, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> value = objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br></pre></td></tr></table></figure>
<h4 id="8-6-动态添加方法，拦截未实现的方法"><a href="#8-6-动态添加方法，拦截未实现的方法" class="headerlink" title="8.6 动态添加方法，拦截未实现的方法"></a>8.6 动态添加方法，拦截未实现的方法</h4><p>每个类都有继承自 NSObject 的两个类方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br></pre></td></tr></table></figure>
<p>一个适用于类方法，一个适用于对象方法。</p>
<p>在代码中调用没有实现的方法时，也就是 sel 标识的方法没有实现，都会先调用这两个方法中的一个拦截。 通常的做法是在 resolve 的内部指定 sel 对应的 IMP，从而完成方法的动态创建和调用两个过程，也可以不指定 IMP 打印错误信息后直接返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个方法的内部都默认包含两个参数，被称为隐式参数：id self 和 SEL _cmd</span></span><br><span class="line"><span class="keyword">void</span> method(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(sel) isEqualToString:<span class="string">@"doSomething"</span>]) &#123;       </span><br><span class="line">     </span><br><span class="line">          <span class="comment">/* 参数 4 : const char *types 方法的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             要注意函数至少有 self 和 _cmd 参数，第二个和第三个字符必须是 “@:”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             如果想要再增加参数，就可以从实现的第三个参数算起：</span></span><br><span class="line"><span class="comment">                 class_addMethod(self, sel, method, "v@:@"); // 多一个对象类型参数增加了 @</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                 void method(id self, SEL _cmd, NSString * name) &#123;  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             返回值：YES if the method was found and added to the receiver, otherwise NO.</span></span><br><span class="line"><span class="comment">          */</span> </span><br><span class="line">          class_addMethod(<span class="keyword">self</span>, sel, method, <span class="string">"v@:"</span>);  <span class="comment">// 为 sel 指定实现为 method</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-7-动态创建一个类"><a href="#8-7-动态创建一个类" class="headerlink" title="8.7 动态创建一个类"></a>8.7 动态创建一个类</h4><p>动态创建一个类，为这个类添加成员变量和方法，并创建这个类型的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> sayFunction(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> param) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld岁的%@在%@说%@"</span>, [object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_age"</span>)) integerValue], object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"_name"</span>)), object_getIvar(<span class="keyword">self</span>, class_getInstanceVariable([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="string">"schoolName"</span>)), param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建 Student 类。参数 1 : 父类   参数 2 : 类名   参数 3 : 通常为 0</span></span><br><span class="line">    Class StudentClass = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">"Student"</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个 NSString 的变量，第四个参数是对齐方式，第五个参数是参数类型</span></span><br><span class="line">    <span class="comment">// 必须在 objc_allocateClassPair and 和 objc_registerClassPair 之间调用</span></span><br><span class="line">    <span class="keyword">if</span> (class_addIvar(StudentClass, <span class="string">"schoolName"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="string">"@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加成员变量成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 NSString * _name 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_name"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">    <span class="comment">// 添加 int _age 成员变量</span></span><br><span class="line">    class_addIvar(StudentClass, <span class="string">"_age"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0</span>, <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为 Student 类添加方法 "v@:" 这种写法见参数类型连接</span></span><br><span class="line">    SEL sel = sel_registerName(<span class="string">"sayFunction:"</span>);</span><br><span class="line">    <span class="keyword">if</span> (class_addMethod(StudentClass, sel, (IMP)sayFunction, <span class="string">"v@:@"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"添加方法成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册这个类到 runtime 系统中就可以使用了</span></span><br><span class="line">    objc_registerClassPair(StudentClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用创建的类</span></span><br><span class="line">    <span class="keyword">id</span> student = [[StudentClass alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给刚刚添加的变量赋值</span></span><br><span class="line">    <span class="comment">// object_setInstanceVariable(student, "schoolName", (void *)&amp;str);在ARC下不允许使用</span></span><br><span class="line">    [student setValue:<span class="string">@"清华大学"</span> forKey:<span class="string">@"schoolName"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KVC 动态改变实例变量</span></span><br><span class="line">    [student setValue:<span class="string">@"Tom"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从类中获取成员变量Ivar</span></span><br><span class="line">    Ivar ageIvar = class_getInstanceVariable(StudentClass, <span class="string">"_age"</span>);</span><br><span class="line">    <span class="comment">// 为peopleInstance的成员变量赋值</span></span><br><span class="line">    object_setIvar(StudentClass, ageIvar, @<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 sayFunction 方法，也就是给 student 这个接受者发送 sayFunction: 这个消息</span></span><br><span class="line">    objc_msgSend(student, <span class="string">"sayFunction:"</span>, <span class="string">@"你好~"</span>); </span><br><span class="line">    <span class="comment">// [student performSelector:sel withObject:@"你好~"]; // 动态调用未显式在类中声明的方法</span></span><br><span class="line">    </span><br><span class="line">    student = <span class="literal">nil</span>;</span><br><span class="line">    StudentClass = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    objc_disposeClassPair(StudentClass);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接使用 objc_msgSend() 会报错 Too many arguments to function call, expected 0, have 3，此时需要在 Target -&gt; Build Settings -&gt; 搜索 msg -&gt; 修改为 NO</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d8496fe34a524c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt></p>
<h2 id="九、健壮的实例变量-Non-Fragile-ivars"><a href="#九、健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="九、健壮的实例变量(Non Fragile ivars)"></a>九、健壮的实例变量(Non Fragile ivars)</h2><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。</p>
<p>当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b75736c89991ff2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ddfa1eb170bae83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a4a0f676708f0a30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="健壮的实例变量自动偏移"></p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p>
<p>需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。</p>
<h2 id="十、文章"><a href="#十、文章" class="headerlink" title="十、文章"></a>十、文章</h2><p><a href="http://home.cnblogs.com/u/Mike-zh/" target="_blank" rel="noopener">Mike_zh</a> &amp; <a href="https://www.cnblogs.com/Mike-zh/p/4557014.html" target="_blank" rel="noopener">iOS-Runtime知识点整理</a></p>
<p><a href="https://www.ianisme.com/" target="_blank" rel="noopener">ian</a> &amp; <a href="https://www.ianisme.com/ios/2019.html" target="_blank" rel="noopener">Objective-C Runtime 1小时入门教程</a></p>
<p><a href="https://www.cnblogs.com/ioshe/p/5489086.html" target="_blank" rel="noopener">iOS开发-Runtime 详解</a></p>
<p><a href="https://www.jianshu.com/p/26c41f48267d" target="_blank" rel="noopener">iOS RunTime 之数据结构</a></p>
<p><a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">iOS 模块分解—「Runtime面试、工作」</a></p>
<p><a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Runtime 源码</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/06/Runtime/">http://yoursite.com/2019/08/06/Runtime/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/06/01-背包/" class="pre">0-1 背包</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、简介"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、作用"><span class="toc-text">二、作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Objective-C-源代码"><span class="toc-text">2.1 Objective-C 源代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-通过-Foundation-框架的-NSObject-类定义的方法"><span class="toc-text">2.2 通过 Foundation 框架的 NSObject 类定义的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-通过对-Runtime-库函数的直接调用"><span class="toc-text">2.3 通过对 Runtime 库函数的直接调用</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Runtime-相关的头文件"><span class="toc-text">三、Runtime 相关的头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-操作对象的类型的定义"><span class="toc-text">3.1 操作对象的类型的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-函数的定义"><span class="toc-text">3.2 函数的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、术语及其数据结构"><span class="toc-text">四、术语及其数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-SEL"><span class="toc-text">4.1 SEL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-id"><span class="toc-text">4.2 id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-Class"><span class="toc-text">4.3 Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-Method"><span class="toc-text">4.4 Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-IMP"><span class="toc-text">4.6 IMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-Cache"><span class="toc-text">4.7 Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-Property"><span class="toc-text">4.8 Property</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、消息"><span class="toc-text">五、消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-方法中的隐藏参数"><span class="toc-text">5.1 方法中的隐藏参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-获取方法地址"><span class="toc-text">5.2 获取方法地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、动态方法解析"><span class="toc-text">六、动态方法解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、消息转发"><span class="toc-text">七、消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-重定向"><span class="toc-text">7.1 重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-转发"><span class="toc-text">7.2 转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-转发和多继承"><span class="toc-text">7.3 转发和多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-转发与继承"><span class="toc-text">7.4 转发与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、应用场景"><span class="toc-text">八、应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-获取属性-成员变量列表"><span class="toc-text">8.1 获取属性/成员变量列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-KVC字典转模型"><span class="toc-text">8.2 KVC字典转模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-NSCoding-归档和解档"><span class="toc-text">8.3 NSCoding 归档和解档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-交换方法实现"><span class="toc-text">8.4 交换方法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-类-对象的关联对象"><span class="toc-text">8.5 类/对象的关联对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-动态添加方法，拦截未实现的方法"><span class="toc-text">8.6 动态添加方法，拦截未实现的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-动态创建一个类"><span class="toc-text">8.7 动态创建一个类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、健壮的实例变量-Non-Fragile-ivars"><span class="toc-text">九、健壮的实例变量(Non Fragile ivars)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、文章"><span class="toc-text">十、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/编程思想/">编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/dyld/">dyld</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/终端/">终端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/Xcode/">Xcode</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/重构AppDelegate/">重构 AppDelegate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法设计策略/">算法设计策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/第 k 小的数/">第 k 小的数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/简单算法/">简单算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/硬币问题/">硬币问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/爬楼梯/">爬楼梯</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>