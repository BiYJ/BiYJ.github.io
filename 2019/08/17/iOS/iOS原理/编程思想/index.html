<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>编程思想 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">编程思想</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">编程思想</h1><div class="post-meta"><a href="/2019/08/17/iOS/iOS原理/编程思想/#comments" class="comment-count"></a><p><span class="date">Aug 17, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、链式编程"><a href="#一、链式编程" class="headerlink" title="一、链式编程"></a>一、链式编程</h2><blockquote>
<p>链式编程其实就是在返回值的基础上，继续调用方法。为了达到目的，需要返回值为对象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[self one] two];</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中，没有传递参数的方法可以写成<font color="#cc0000">点语法</font>的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.one.two;</span><br></pre></td></tr></table></figure>
<p>上面的写法会产生警告：<code>Property access result unused - getters should not be used for side effects</code>。这是因为 two 方法被当成 <font color="#cc0000"><code>getter</code></font> 方法，getter 方法会有返回值，self.one.two 没有使用该返回值。</p>
<blockquote>
<p>Objective-C : 点语法 + 事务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.one.two(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void(^)(NSString *))two</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    return ^ (NSString * s) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, s);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-17 19:45:34.079059+0800 Demo[858:23949] 1</span><br><span class="line">2019-08-17 19:45:34.079188+0800 Demo[858:23949] 2</span><br><span class="line">2019-08-17 19:45:34.079271+0800 Demo[858:23949] 3</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>经典使用链式编程思想的开源代码：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a></p>
<h2 id="二、函数式编程"><a href="#二、函数式编程" class="headerlink" title="二、函数式编程"></a>二、函数式编程</h2><p>在数学中 y = f(x), y = f(f(x)) 都是函数，x 既可以是一个简单的参数，也可以是一个表达式。</p>
<p>在 OC 中，将 block 作为参数传递可实现<font color="#cc0000">灵活的</font>函数封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (ViewController *)one</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)two:(void (^)(NSString *))block</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">    </span><br><span class="line">    block(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.one two:^(NSString * s) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, s);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>函数式编程（Functional Programming）相对于要理解「函数」，我们更需要理解的其实是「状态」。</p>
<h4 id="2-1-状态"><a href="#2-1-状态" class="headerlink" title="2.1 状态"></a>2.1 状态</h4><p>说到状态，很容易会联想到变量、局部变量、全局变量、property、model，这些都可以成为状态，但变量和状态又不是一回事，要真正理解状态，得先理解下面一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>简单的一行代码，分析起来却有不少门道。</p>
<ul>
<li>「i」就是变量，一个变量可以看做是一个实体，真实存在于内存空间的实体。</li>
<li>int 是它的类型信息，是对于它的一种约束。</li>
<li>0 是它被赋予的一个值。</li>
</ul>
<p>变量是我们要分析的目标。它的类型信息、值信息虽然会约束变量的行为，但不是我们关注的重点，真正让变量变得危险的是中间的等号，= 是个赋值操作，意味着改变 i 的值，原本处于<font color="#cc0000">静态的</font> i，由于一个 = 发生了变化，它的值可以变为 1，或者 10000，或者其他任何值，我们可以说这个变量有了状态。</p>
<p>状态也是个相对的概念，变量都有其生命周期，一旦变量被回收，其所包含的状态也随之消失，所以状态所带来的影响是受限于变量的生命周期的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)<span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i 是函数 do 方法内部的临时变量，分配在内存的栈上。在 do 函数内部这个空间范畴来说，i 是有状态的，i 被赋予了值 0。一旦 return，i 的生命周期也随之结束，其所对应的状态也消失了。所以一旦出了do，i 又变得没有状态了。代码虽然执行了 return i，但返回的其实是 i 所代表的值，i 将自己的值交出来之后，就完成了自己的使命。</p>
<p>所以 do 函数的使用者是感受不到 i 的存在的，do 的调用方可以认为 do 是无状态（stateless）的，<font color="#cc0000">无状态意味着静止，静止的事物都是安全的</font>，飞驰而过的火车和静止的石块，当然是后者感觉更安全。</p>
<p>我们编写代码的时候会经常谈论状态，函数的状态、类的状态、App 的状态，归根结底，我们所讨论的是：<font color="#cc0000">在某个空间范畴内会发生变化的变量</font>。</p>
<p>函数式编程当中的函数 f(x) 强调无状态，其实是强调<font color="#cc0000">将状态锁定在函数的内部</font>。一个函数它不依赖于任何外部的状态，只依赖于它的入参的值，一旦值确定，这个函数所返回的结果就是确定的。可能有人会觉得入参也是状态，是外部传入的状态，其实不然，前面说过变量才会有状态，值是没有状态的，入参传入的只是值，而不是变量。下面两个函数，一个入参是传值，一个入参是传变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)do:(int)value  // 传值</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)do:(NSMutableArray *)arr  // 传变量</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个没状态，对调用方来说是安全的，对整个app来说也是安全的，既避免了依赖外部的状态，也不会修改外部的状态，即：不会产生 side effect，没有副作用。</p>
<p>第二个 do 函数，不但是传入了变量，还是可以变化的变量，是真正意义上的外部状态。很有可能在你遍历这个 arr 的时候，外部某个同时执行的线程正在尝试改变这个 arr 里的元素。</p>
<p>所以让我来总结函数式编程当中的函数，可以一句话归结为：<font color="#cc0000">隔绝一切外部状态，传入值，输出值</font>。</p>
<p>再看看函数式编程当中的纯函数（Pure Function）的定义:</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_programming" target="_blank" rel="noopener">computer programming</a>, a <a href="https://en.wikipedia.org/wiki/Function_(computer_science" target="_blank" rel="noopener">function</a>) may be considered a pure function if both of the following statements about the function hold:</p>
<ol>
<li><p>The function always evaluates the same result value given the same argument value(s). The function result value cannot depend on any hidden information or state that may change while program execution proceeds or bet`ween different executions of the program, nor can it depend on any external input from <a href="https://en.wikipedia.org/wiki/Input/output" target="_blank" rel="noopener">I/O</a> devices (usually—see below).</p>
</li>
<li><p>Evaluation of the result does not cause any semantically observable side effect or output, such as mutation of mutable objects or output to I/O devices (usually—see below).</p>
</li>
</ol>
</blockquote>
<p>纯函数即为函数式编程所强调的函数，上述两点可翻译为：</p>
<p>①、不依赖外部状态<br>②、不改变外部状态</p>
<p>所以对函数式编程当中函数的理解，最后还是落实到状态的理解。静止的状态是安全的，变化的状态是危险的，之所以危险可以从两个维度去理解：<font color="#cc0000">时间和空间</font>。</p>
<h4 id="2-2-时间"><a href="#2-2-时间" class="headerlink" title="2.2 时间"></a>2.2 时间</h4><p>变量一旦有了状态，它就有可能随着时间而发生变化，时间是最不可预知的因素，时间会将我们引至什么样的远方不得而知，我们每创造一个变量，真正控制它的不是我们，是时间。</p>
<p>时间的武器是赋值，赋予变量新的值，在不可预知的未来埋下隐患。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)setUserName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	//before assignment</span><br><span class="line">	_userName = name;</span><br><span class="line">	//after assignment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦有了赋值操作，时间就找到了空隙，可以对代码的执行产生影响。或许是现在，或许是明天，或许是在  appDidFinishLaunch，或许是在 didReceiveMemoryWarning。</p>
<p><font color="#cc0000">变量会随着时间变化</font>。有状态的函数也会随着时间的流动产生不同的输出，Pure Function 却是对时间免疫的，纯函数没有状态，无论怎样去执行一个纯函数，它所输出的结果永远不会变。</p>
<h4 id="2-3-空间"><a href="#2-3-空间" class="headerlink" title="2.3 空间"></a>2.3 空间</h4><p>如果把一个线程看成一个独立的空间，在程序的世界当中，空间会产生交叉重叠。一个变量如果可以被两个线程同时访问，它的值如果可以在两个空间发生变化，这个变量同样变得很危险。(线程安全问题)</p>
<p>Pure Function 同样是对空间免疫的。</p>
<p>多线程的 bug 调试起来非常困难，因为我们的大脑并不擅长多路并发的思考方式，而函数式编程可以帮我们解决这一痛点，每一个纯函数都是线程安全的。</p>
<h4 id="2-4-离不开的状态"><a href="#2-4-离不开的状态" class="headerlink" title="2.4 离不开的状态"></a>2.4 离不开的状态</h4><p>函数式编程通过 Pure Function，使得我们的代码经得起时间和空间的考验。</p>
<p>我们可以把一个 App 的代码按照函数式编程的方式，拆分成一个个合格的 pure function，再通过某种方式串联起来，要方便的串联函数，需要能像使用变量一样方便的使用函数。</p>
<p>一个 Pure Function 可以是 stateless 的，但 App 可以变成 stateless 吗？显然不能。</p>
<p>离开了变量和状态，我们很难完整的描述业务。用户购物车里的商品总是会发生变化，今天或明天，我们总是需要在一个地方接收这种变化，保存这种变化，继而反应这种变化。所以，大多数时候，我们离不开状态，但我们能做的是，<font color="#cc0000">将一定会变化的状态，锁定在尽可能小的时间和空间跨度之内</font>，通过改变代码的组织方式或架构，将必须改变的难以管教的状态，囚禁在特定的模块代码之中，让不可控变得尽量可控。</p>
<p>其实，即使不严格遵从函数式编程，我们同样可以写出带有 Functional Programming 精髓的代码，一切的一切，都是对于状态（state）的理解。</p>
<p>NSMutableArray 的 copy 也是颇具函数式编程精髓的。</p>
<h4 id="2-5-一等公民"><a href="#2-5-一等公民" class="headerlink" title="2.5 一等公民"></a>2.5 一等公民</h4><p>当我们把函数改造成 pure function 之后，会产生一些奇妙的化学连锁反应，这些反应甚至会改变我们的编程习惯。</p>
<p>一旦我们有了绝对安全的纯函数，我们当然希望能尽最大可能的去发挥它的价值，增加它出现和被使用的场景。为了加大纯函数的使用率，我们需要在语言层面做一些改造或者增强，以提高纯函数传递性。怎么增强呢？答案是将函数变为一等公民。</p>
<p>何谓公民？有身份证才叫公民，有身份证还能自由迁徙的就叫一等公民。</p>
<p>当我们的变量可以指向函数时，这个变量就有了函数的身份。当我们把这个变量当做函数的参数传入，或者函数的返回值传出的时候，这个变量就有了自由迁徙的能力。</p>
<p>一个函数 A，可以接收另一个函数 B 作为参数，然后再返回第三个函数 C 作为返回值。类似下面的一段swift代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">(funcB: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; input <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">return</span> funcB(input)</span><br><span class="line">	&#125; <span class="comment">//funcC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 funcA 的定义里，funcB 是作为参数传入，funcC（匿名的）是作为返回值返回。funcB 和 funcC 在这个语境里就称之为 first class function。而 funcA 作为 funcB 和 funcC 的管理者，有个更高端的称谓：high order function。</p>
<p>有了 first class function 和 high order function，我们还会收获另一个成果：语言的表达力更灵活，更简洁，更强大了。举个例子，我们写一段代码来实现一个功能：参加 party 前选一件衣服。用传统的方式来写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseColor</span><span class="params">(gender: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dressup</span><span class="params">(dressColor: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//imperative</span></span><br><span class="line"><span class="keyword">let</span> dressColor = chooseColor(gender: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> dress = dressup(dressColor: dressColor)</span><br><span class="line">user.dress = dress</span><br></pre></td></tr></table></figure>
<p>先定义函数，再分三步依次调用 chooseColor, dressup，然后赋值。</p>
<p>如果用 first class function 和 high order function 的方式来写就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoParty</span><span class="params">(dressup: @escaping <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>, chooseColor: @escaping (<span class="type">Int</span>) -&gt; <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; gender <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">let</span> dressColor = chooseColor(gender)</span><br><span class="line">		<span class="keyword">return</span> dressup(dressColor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// declarative</span></span><br><span class="line"><span class="keyword">let</span> prepare = gotoParty(dressup: &#123; color <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;, chooseColor: &#123; gender <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line">user.dress = prepare(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>gotoParty 函数糅合了 dressup 和 chooseColor，gotoParty 成了一个 high order function，当我们读 gotoParty 的代码的时候，这单一一个函数就将我们的目的和结果都表明了。</p>
<p>这就是 high order function 的神奇之处，原先啰啰嗦嗦的几句话变成一句话就说清楚了，它更接近我们自然语言的表达方式，比如 gotoParty 可以这样阅读：我要挑选一件颜色适合的衣服去参加 party，这样的代码是不是语意更简洁更美呢？</p>
<p>注意，<font color="#cc0000">functional programming 并不会减少我们的代码量，它改变的只是我们书写代码的方式</font>。</p>
<p>这种更为强大的表达力我们也有个行话来称呼它：declarative programming。而我们传统的代码表达方式（OOP当中所使用的方式）则叫做：imperative programming。</p>
<p>imperative programming 更强调实现的步骤，而 declarative programming 则重在表达我们想要的结果。这句话理解起来可能有些抽象，实在理解不了也没啥关系，只要记住declarative programming 能更简洁精炼的表达我们想要的结果即可。</p>
<p>以上都是我们将function变为一等公民所产生的结果，这一改变还有更多的妙用，比如lazy evaluation。</p>
<p>上述代码中的dressup和chooseColor虽然都是function，但是他们在传入gotoParty的时候并不会立马执行（evaluation），而是等gotoParty被执行的时候再一起执行。这也很大程度上增强了我们的表达能力，dressup和chooseColor都具备了lazy evaluation的属性，可以被拼装，被delay，最后在某一时刻才被执行。</p>
<p>所以，functional programming改变了我们使用函数的方式，之前使用 OOP，我们对于怎么处理变量（定义变量，修改值，传递值，等）轻车熟路，到了函数式编程的世界，我们要学会如何同函数打交道了，要能像使用变量一样灵活自如的使用函数，这在刚开始的时候确实需要一段适应期。</p>
<h2 id="三、响应式编程"><a href="#三、响应式编程" class="headerlink" title="三、响应式编程"></a>三、响应式编程</h2><p>在网上流传一个非常经典的解释｀响应式编程的概念｀</p>
<blockquote>
<p>在程序开发中： a ＝ b ＋ c<br>赋值之后 b 或者 c 的值变化后，a 的值不会跟着变化。<br>响应式编程的目标就是：如果 b 或者 c 的数值发生变化，a 的数值会同时发生变化。</p>
</blockquote>
<ol>
<li><p>什么是响应式编程？</p>
<p> 响应式编程是一种编程范例，它处理异步数据流和特定的变更传播，按照特定顺序对执行环境（上下文）进行修改。</p>
</li>
<li><p>使用响应式编程有哪些好处？</p>
<p> 提高系统性能：使用响应式编程能提高处理大量数据的反应速度。提升用户体验：使用响应式编程能提升系统的响应能力。简化修改和维护：代码更容易理解。</p>
</li>
<li><p>所有都应该是响应式的么？</p>
<p>响应式编程可以作为应用的一部分集成到应用中，没必要将已经证明有效的编程模式全部推倒。如果只是简单的网站，肯定没有必要应用响应式编程；如果需要引入推荐系统，引入响应式编程处理来大数据、高负载就是个好办法。</p>
</li>
<li><p>什么时候使用响应式编程？</p>
<p>响应式编程是高负载、多用户应用的优雅的解决方案，像社交应用、游戏、音视频应用；此外，应用有以下模块也适合应用：需要大量交互的服务端代码、代理服务器/负载均衡器、人工智能/机器学习、实时数据流处理。</p>
</li>
</ol>
<h2 id="四、文章"><a href="#四、文章" class="headerlink" title="四、文章"></a>四、文章</h2><p>suiling &amp; <a href="http://www.cocoachina.com/articles/18325" target="_blank" rel="noopener">简单点，理解iOS与函数式编程</a><br><a href="https://www.jianshu.com/u/456d7ff700c2" target="_blank" rel="noopener">阳仔dynamics</a> &amp; <a href="https://www.jianshu.com/p/ca10c143ff0d" target="_blank" rel="noopener">ReactiveCocoa学习笔记（三）：响应式和函数响应式编程</a><br><a href="http://www.sprynthesis.com/2014/06/15/why-reactivecocoa/" target="_blank" rel="noopener">Why Reactive(Cocoa)?</a><br><a href="https://www.jianshu.com/u/18eb197607ff" target="_blank" rel="noopener">吴启辉</a> &amp; <a href="https://www.jianshu.com/p/a3598fb73eda" target="_blank" rel="noopener">关于响应式编程的十个问题</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/08/17/iOS/iOS原理/编程思想/">http://yoursite.com/2019/08/17/iOS/iOS原理/编程思想/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/08/30/iOS/iOS原理/静态、动态 Pod/" class="pre">静态、动态 pod</a><a href="/2019/08/07/iOS/iOS原理/dyld/" class="next">dyld</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、链式编程"><span class="toc-text">一、链式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、函数式编程"><span class="toc-text">二、函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-状态"><span class="toc-text">2.1 状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-时间"><span class="toc-text">2.2 时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-空间"><span class="toc-text">2.3 空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-离不开的状态"><span class="toc-text">2.4 离不开的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-一等公民"><span class="toc-text">2.5 一等公民</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#三、响应式编程"><span class="toc-text">三、响应式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、文章"><span class="toc-text">四、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/iOS/iOS原理/NSPredicate/">NSPredicate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/30/iOS/iOS原理/静态、动态 Pod/">静态、动态 pod</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/iOS/iOS原理/编程思想/">编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/07/iOS/iOS原理/dyld/">dyld</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/终端/">终端</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/工具/Xcode/">Xcode</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/算法设计策略/">算法设计策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/iOS/iOS优化/重构AppDelegate/">重构 AppDelegate</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/第 k 小的数/">第 k 小的数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/算法/简单算法/">简单算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>