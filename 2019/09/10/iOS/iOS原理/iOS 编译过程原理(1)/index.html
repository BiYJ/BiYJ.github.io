<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 编译过程原理(1) | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 编译过程原理(1)</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 编译过程原理(1)</h1><div class="post-meta"><a href="/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/#comments" class="comment-count"></a><p><span class="date">Sep 10, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>一般可以将编程语言分为两种，<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">编译语言</a>和<a href="https://en.wikipedia.org/wiki/Interpreted_language" target="_blank" rel="noopener">直译式语言</a>。</p>
<p>像 C++、Objective-C 都是编译语言。编译语言在执行的时候，必须<font color="#cc0000">先通过编译器生成机器码</font>，机器码可以直接在 CPU 上执行，所以执行效率较高。</p>
<p>像 JavaScript、Python 都是直译式语言。直译式语言不需要经过编译的过程，而是<font color="#cc0000">在执行的时候通过一个中间的解释器将代码解释为 CPU 可以执行的代码</font>。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。</p>
<p>iOS 开发目前的常用语言：Objective-C 和 Swift。二者都是编译语言，换句话说都是需要编译才能执行的。它们的编译都是依赖于 Clang(swift) + LLVM。本文只关注 Objective-C，原理上大同小异。</p>
<p>充分理解了编译的过程，会对你的开发大有帮助。本文的最后，会以以下几个例子，来讲解如何合理利用 XCode 和编译</p>
<ul>
<li>__attribute__</li>
<li>Clang 警告处理</li>
<li>预处理</li>
<li>插入编译期脚本</li>
<li>提高项目编译速度</li>
</ul>
<h2 id="二、iOS-编译"><a href="#二、iOS-编译" class="headerlink" title="二、iOS 编译"></a>二、iOS 编译</h2><p>Objective-C 采用 Clang 作为前端，而 Swift 则采用 swift() 作为前端，都是 LLVM（Low level vritual machine）作为编译器后端。所以简单的编译过程如图：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-3a4fe4a482e93bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"><br></center>

<p>其中，swift 的编译命令可以在这里找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift</span><br></pre></td></tr></table></figure>
<p>可以通过 Clang，来<font color="#cc0000">查看一个文件的编译具体过程</font>，新建 Demo.m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">  </span><br><span class="line">int main()&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,@&quot;Hello Leo&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后终端输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~ $ cd /Users/dubin/Desktop/Demo/Demo</span><br><span class="line">Demo $ </span><br><span class="line">Demo $ clang -ccc-print-phases -framework Foundation Demo.m -o Demo </span><br><span class="line">0: input, &quot;Foundation&quot;, object</span><br><span class="line">1: input, &quot;Demo.m&quot;, objective-c</span><br><span class="line">2: preprocessor, &#123;1&#125;, objective-c-cpp-output  // 预处理</span><br><span class="line">3: compiler, &#123;2&#125;, ir                          // 编译生成 IR（中间代码）</span><br><span class="line">4: backend, &#123;3&#125;, assembler                    // 汇编器生成汇编代码</span><br><span class="line">5: assembler, &#123;4&#125;, object                     // 生成机器码</span><br><span class="line">6: linker, &#123;0, 5&#125;, image                      // 链接</span><br><span class="line">7: bind-arch, &quot;x86_64&quot;, &#123;6&#125;, image            // 生成 Image，也就是最后的可执行文件</span><br></pre></td></tr></table></figure>
<p>在终端运行这个程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Demo $ gcc -framework Foundation Demo.m -o Demo</span><br><span class="line">$ ./Demo</span><br><span class="line">2019-03-27 13:55:30.426 Demo[14155:5478670] Hello Leo</span><br></pre></td></tr></table></figure>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9a33d4c189414790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"><br></center>

<p>另一种终端运行 OC 程序的顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Demo $ cc -c Demo.m</span><br><span class="line">Demo $ cc Demo.o -framework Foundation</span><br><span class="line">ld: warning: text-based stub file /System/Library/Frameworks//Foundation.framework/Foundation.tbd and library file /System/Library/Frameworks//Foundation.framework/Foundation are out of sync. Falling back to library file for linking.</span><br><span class="line">ld: warning: text-based stub file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation.tbd and library file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation are out of sync. Falling back to library file for linking.</span><br><span class="line">Demo $ ./a.out</span><br><span class="line">2019-03-27 14:01:52.933 a.out[14413:5483194] Hello Leo</span><br></pre></td></tr></table></figure>
<p>cc -c tst.m    编译：生成 tst.o文件</p>
<p>cc -c man.m        编译： 生成 man.o 文件</p>
<p>cc tst.o man.o -framework Foundation  链接、合并：生成 a.out 可执行文件</p>
<p>./a.out 运行</p>
<p>当然 OC 程序还可以混编 C 程序，格式为：cc -c x.m x.c，或者直接将编译和链接合在一起：cc x.m x.c</p>
<ol>
<li><p>编译器前端</p>
<p> 编译器前端的任务是：语法分析、语义分析、生成中间代码（intermediate representation）。在这个过程中<font color="#cc0000">会进行类型检查，如果发现错误或者警告会标注出来在哪一行</font>。</p>
 <center><br> <img src="https://upload-images.jianshu.io/upload_images/5294842-eba0d4d3a3fbec8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"><br> </center>
</li>
<li><p>编译器后端</p>
<p> 编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS 的编译过程，后端的处理如下</p>
<p> ①、LVVM 优化器会进行 BitCode 的生成，链接期优化等等。</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/5294842-7fc3096f9cf495e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p>
<p> ②、LLVM 机器码生成器会针对不同的架构，比如 arm64 等生成不同的机器码。</p>
<p> <img src="https://upload-images.jianshu.io/upload_images/5294842-2037b2a6480b4d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p>
</li>
</ol>
<h2 id="三、执行一次-XCode-build-的流程"><a href="#三、执行一次-XCode-build-的流程" class="headerlink" title="三、执行一次 XCode build 的流程"></a>三、执行一次 XCode build 的流程</h2><p>当你在 XCode 中，选择 build 的时候（快捷键 command+B），会执行如下过程</p>
<ul>
<li>编译信息写入辅助文件，创建编译后的文件架构（name.app）</li>
<li>处理文件打包信息，例如在 debug 环境下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entitlements:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;application-identifier&quot; = &quot;app的bundleid&quot;;</span><br><span class="line">    &quot;aps-environment&quot; = development;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 CocoaPod 编译前脚本。例如对于使用 CocoaPod 的工程会执行 <font color="#cc0000">CheckPods Manifest.lock</font></li>
<li>编译各个 .m 文件，使用 <font color="#cc0000">CompileC</font> 和 <font color="#cc0000">clang</font> 命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</span><br><span class="line">export LANG=en_US.US-ASCII</span><br><span class="line">export PATH=&quot;...&quot;</span><br><span class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework  -iquote 所需要的Framework  ... -c ClassName.c -o ClassName.o</span><br></pre></td></tr></table></figure>
<p>通过这个编译的命令，我们可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang是实际的编译命令</span><br><span class="line">-x 		objective-c 指定了编译的语言</span><br><span class="line">-arch 	x86_64制定了编译的架构，类似还有arm7等</span><br><span class="line">-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。</span><br><span class="line">-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项</span><br><span class="line">-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span><br><span class="line">-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本</span><br><span class="line">-I 把编译信息写入指定的辅助文件</span><br><span class="line">-F 链接所需要的Framework</span><br><span class="line">-c ClassName.c 编译文件</span><br><span class="line">-o ClassName.o 编译产物</span><br></pre></td></tr></table></figure>
<ul>
<li>链接需要的 Framework，例如 Foundation.framework、AFNetworking.framework、AliPay.framework</li>
<li>编译 xib 文件</li>
<li>拷贝 xib，图片等资源文件到结果目录</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝 Swift 标准库</li>
<li>创建 .app 文件和对其签名</li>
</ul>
<h2 id="四、ipa-包的内容"><a href="#四、ipa-包的内容" class="headerlink" title="四、ipa 包的内容"></a>四、ipa 包的内容</h2><p>例如，通过 iTunes Store 下载微信，获得 ipa 安装包，然后实际看看其安装包的内容。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-475c1b17e4bc6ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"><br></center>

<ul>
<li>右键 ipa，重命名为 .zip</li>
<li>双击 zip 文件，解压缩后会得到一个文件夹。所以，<font color="#cc0000">ipa 包就是一个普通的压缩包</font>。</li>
</ul>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-a17d16dddf291011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"><br></center>

<ul>
<li>右键图中的 [WeChat[，选择显示包内容，然后就能够看到实际的 ipa 包内容了。</li>
</ul>
<h2 id="五、二进制文件的内容"><a href="#五、二进制文件的内容" class="headerlink" title="五、二进制文件的内容"></a>五、二进制文件的内容</h2><p>通过 XCode 的 Link Map File，我们可以窥探二进制文件中布局。在 XCode -&gt; Build Settings -&gt; 搜索 map -&gt; 开启Write Link Map File。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-ad796aa51811238f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"><br></center>

<p>开启后，再编译，我们可以在对应的 Debug/Release 目录下看到对应的 link map 的 text 文件。</p>
<p>默认的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Developer/Xcode/DerivedData/&lt;TARGET-NAME&gt;-对应ID/Build/Intermediates/&lt;TARGET-NAME&gt;.build/Debug-iphoneos/&lt;TARGET-NAME&gt;.build/</span><br></pre></td></tr></table></figure>
<p>例如 TargetName是 Demo 的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build</span><br></pre></td></tr></table></figure>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9879ec4e25c96df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"><br></center>

<p>这个映射文件的主要包含以下部分：</p>
<ol>
<li><p>Object files</p>
<p> 这个部分包括的内容：</p>
<ul>
<li>.o 文文件，也就是上文提到的 .m 文件编译后的结果。</li>
<li>.a 文件</li>
<li><p>需要 link 的 framework</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Arch: x86_64</span><br><span class="line"># Object files:</span><br><span class="line">[  0] linker synthesized</span><br><span class="line">[  1] dtrace</span><br><span class="line">[  2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o</span><br><span class="line">[  3] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/ViewController.o</span><br><span class="line">[  4] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/Person.o</span><br><span class="line">[  5] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyOperation.o</span><br><span class="line">[  6] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/main.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[130] /Applications/Xcode10.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//CoreGraphics.framework/CoreGraphics.tbd</span><br></pre></td></tr></table></figure>
<p>这个区域的存储内容比较简单：前面是文件的编号，后面是文件的路径。文件的编号在后续会用到。</p>
</li>
</ul>
</li>
<li><p>Sections</p>
<p> 这个区域<font color="#cc0000">提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小</font>。这个区域完整的描述了可执行文件中的全部内容。其中，段分为两种：</p>
<ul>
<li>__TEXT 代码段</li>
<li><p>__DATA 数据段</p>
<p>从 Sections 区域可以看到，代码段的 __text 节的地址是 0x100001000，大小是 0x000A5FF9，而二者相加的下一个位置正好是 __stubs 的位置 0x1000A6FFA。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Sections: </span><br><span class="line"># 位置           大小            段       节 </span><br><span class="line"># Address       Size            Segment Section</span><br><span class="line">0x100001000	0x000A5FF9	__TEXT	__text             // 代码</span><br><span class="line">0x1000A6FFA	0x000003D8	__TEXT	__stubs</span><br><span class="line">0x1000A73D4	0x00000678	__TEXT	__stub_helper</span><br><span class="line">0x1000A7A4C	0x0000794A	__TEXT	__objc_methname    // OC 方法名</span><br><span class="line">0x1000AF396	0x000079F4	__TEXT	__cstring          // 字符串</span><br><span class="line">0x1000B6D8A	0x0000092C	__TEXT	__objc_classname   // OC 类名</span><br><span class="line">0x1000B76B6	0x00002293	__TEXT	__objc_methtype    // OC 方法类型</span><br><span class="line">0x1000B9950	0x000000E8	__TEXT	__const            // 常量</span><br><span class="line">0x1000B9A38	0x000043DC	__TEXT	__gcc_except_tab</span><br><span class="line">0x1000BDE14	0x0000004A	__TEXT	__ustring</span><br><span class="line">0x1000BDE5E	0x00000166	__TEXT	__entitlements</span><br><span class="line">0x1000BDFC4	0x0000037B	__TEXT	__dof_RACSignal</span><br><span class="line">0x1000BE33F	0x000002E8	__TEXT	__dof_RACCompou</span><br><span class="line">0x1000BE628	0x000009CC	__TEXT	__unwind_info</span><br><span class="line">0x1000BF000	0x00000010	__DATA	__nl_symbol_ptr</span><br><span class="line">0x1000BF010	0x000001B8	__DATA	__got</span><br><span class="line">0x1000BF1C8	0x00000520	__DATA	__la_symbol_ptr</span><br><span class="line">0x1000BF6E8	0x00005D28	__DATA	__const</span><br><span class="line">0x1000C5410	0x00002E80	__DATA	__cfstring</span><br><span class="line">0x1000C8290	0x00000268	__DATA	__objc_classlist   // OC 方法列表</span><br><span class="line">0x1000C84F8	0x000001C0	__DATA	__objc_catlist</span><br><span class="line">0x1000C86B8	0x00000098	__DATA	__objc_protolist   // OC 协议列表</span><br><span class="line">0x1000C8750	0x00000008	__DATA	__objc_imageinfo</span><br><span class="line">0x1000C8758	0x0000F0C0	__DATA	__objc_const       // OC 常量</span><br><span class="line">0x1000D7818	0x00001B28	__DATA	__objc_selrefs</span><br><span class="line">0x1000D9340	0x00000040	__DATA	__objc_protorefs</span><br><span class="line">0x1000D9380	0x00000360	__DATA	__objc_classrefs</span><br><span class="line">0x1000D96E0	0x00000170	__DATA	__objc_superrefs   // OC 父类引用</span><br><span class="line">0x1000D9850	0x00000610	__DATA	__objc_ivar        // OC ivar</span><br><span class="line">0x1000D9E60	0x00001810	__DATA	__objc_data</span><br><span class="line">0x1000DB670	0x00000768	__DATA	__data</span><br><span class="line">0x1000DBDD8	0x0000015F	__DATA	__bss</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Symbols</p>
<p> <font color="#cc0000">Section 部分将二进制文件进行了一级划分。而 Symbols 对 Section 中的各个段进行了二级划分</font>，例如，对于 __TEXT __text 表示代码段中的代码内容。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x100001000	0x000A5FF9	__TEXT	__text             // 代码</span><br></pre></td></tr></table></figure>
<p> 而对应的 Symbols，起始地址也是 0x1000021B0。其中，文件编号和上文的编号对应</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x100001000	0x000000A0	[  2] +[MyProxy proxyWithObj:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o</span><br></pre></td></tr></table></figure>
<p> 具体内容：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># 地址           大小            文件编号 方法名</span><br><span class="line"># Address	Size    	File  Name</span><br><span class="line">0x100001000	0x000000A0	[  2] +[MyProxy proxyWithObj:]</span><br><span class="line">0x1000010A0	0x00000040	[  2] -[MyProxy methodSignatureForSelector:]</span><br><span class="line">0x1000010E0	0x000003F0	[  2] -[MyProxy forwardInvocation:]</span><br><span class="line">0x1000014D0	0x00000040	[  2] -[MyProxy .cxx_destruct]</span><br><span class="line">0x100001510	0x00000048	[  2] -[Dog barking:]</span><br><span class="line">0x100001560	0x00000060	[  3] -[ViewController dealloc]</span><br><span class="line">0x1000015C0	0x000001C0	[  3] -[ViewController drawImage:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到这里，我们知道 OC 的方法是如何存储的，再来看看 ivar 是如何存储的。</p>
<p>首先找到数据栈中 __DATA __objc_ivar</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000D9850	0x00000610	__DATA	__objc_ivar</span><br></pre></td></tr></table></figure>
<p>然后，搜索这个地址 0x1000D9850，就能找到 ivar 的存储区域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000D9850	0x00000008	[  2] _OBJC_IVAR_$_MyProxy.__innerObj</span><br></pre></td></tr></table></figure>
<p>值得一提的是，对于 String，会显式的存储到数据段中，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x1000AF3F2	0x00000004	[  3] literal string: http://www.baidu.com</span><br></pre></td></tr></table></figure>
<p>所以，若果你的加密 Key 以明文的形式写在文件里，是一件很危险的事情。</p>
<h2 id="六、dSYM-文件"><a href="#六、dSYM-文件" class="headerlink" title="六、dSYM 文件"></a>六、dSYM 文件</h2><p>在每次编译过后，都会生成一个 dsym 文件。<font color="#cc0000">dsym 文件中，存储了 16 进制的函数地址映射</font>。</p>
<p>在 App 实际执行的二进制文件中，是通过地址来调用方法的。在 App crash 的时候，第三方工具（Fabric、友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含 crash 地址的调用信息。然后通过 dSYM 文件，我们就可以由地址映射到具体的函数位置。</p>
<p>XCode 中选择 Window -&gt; Organizer 可以看到生成的 archier 文件。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-6d216b1dd05b7413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"><br></center>

<p>然后</p>
<ul>
<li>右键 -> 在 finder 中显示。</li>
<li>右键 -> 查看包内容。</li>
</ul>
<p>关于如何用 dsym 文件来分析崩溃位置，查看另一篇博客：<a href="http://blog.csdn.net/hello_hwc/article/details/50036323" target="_blank" rel="noopener">iOS 如何调试第三方统计到的崩溃报告</a></p>
<h2 id="七、应用场景"><a href="#七、应用场景" class="headerlink" title="七、应用场景"></a>七、应用场景</h2><h4 id="7-1-attribute"><a href="#7-1-attribute" class="headerlink" title="7.1 __attribute__"></a>7.1 __attribute__</h4><p>或多或少都会在第三方库或者 iOS 的头文件中，见到过 __attribute__。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((warn_unused_result)) // 如果没有使用返回值，编译的时候给出警告</span><br></pre></td></tr></table></figure>
<p><font color="#cc0000">__attribtue__ 是一个高级的的编译器指令</font>，它允许开发者指定更多的编译检查和一些高级的<font color="#cc0000">编译期优化</font>。</p>
<p>分为三种：</p>
<ul>
<li>函数属性（Function Attribute）</li>
<li>类型属性（Variable Attribute）</li>
<li>变量属性（Type Attribute）</li>
</ul>
<p>语法结构</p>
<pre><code>__attribute__ 语法格式为：__attribute__ ((attribute-list))
</code></pre><p>放在声明分号 “;” 前面。</p>
<p>比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) CLASSNAME * property __deprecated;</span><br></pre></td></tr></table></figure>
<p>好处：</p>
<p>给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的 API，但是被 __deprecated 的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新 Pod 的时候，代码无法运行了。</p>
<p>__attribtue__ 的使用场景很多，本文只列举 iOS 开发中常用的几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 弃用 API，用作 API 更新</span><br><span class="line">#define __deprecated	__attribute__((deprecated)) </span><br><span class="line"></span><br><span class="line">// 带描述信息的弃用</span><br><span class="line">#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))</span><br><span class="line"></span><br><span class="line">// 遇到 __unavailable 的变量/方法，编译器直接抛出 Error</span><br><span class="line">#define __unavailable	__attribute__((unavailable))</span><br><span class="line"></span><br><span class="line">// 告诉编译器，即使这个变量/方法没被使用，也不要抛出警告</span><br><span class="line">#define __unused	__attribute__((unused))</span><br><span class="line"></span><br><span class="line">// 和 __unused 相反</span><br><span class="line">#define __used		__attribute__((used))</span><br><span class="line"></span><br><span class="line">// 如果不使用方法的返回值，进行警告</span><br><span class="line">#define __result_use_check __attribute__((__warn_unused_result__))</span><br><span class="line"></span><br><span class="line">// OC 方法在 Swift 中不可用</span><br><span class="line">#define __swift_unavailable(_msg)	__attribute__((__availability__(swift, unavailable, message=_msg)))</span><br></pre></td></tr></table></figure>
<h4 id="7-2-Clang-警告处理"><a href="#7-2-Clang-警告处理" class="headerlink" title="7.2 Clang 警告处理"></a>7.2 Clang 警告处理</h4><p>你一定还见过如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span><br><span class="line">/// 代码</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是</p>
<ol>
<li><font color="#cc0000">对当前编译环境进行压栈</font></li>
<li>忽略 -Wundeclared-selector（未声明的）Selector 警告</li>
<li>编译代码</li>
<li>对编译环境进行出栈</li>
</ol>
<p>通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<p>在另一篇文章：<a href="http://blog.csdn.net/Hello_Hwc/article/details/46425503" target="_blank" rel="noopener">iOS 合理利用 Clang 警告来提高代码质量</a>，详细的介绍了 XCode 的警告相关内容。</p>
<h4 id="7-3-预处理"><a href="#7-3-预处理" class="headerlink" title="7.3 预处理"></a>7.3 预处理</h4><p>所谓预处理，就是在编译之前的处理。<font color="#cc0000">预处理能够让你定义编译器变量，实现条件编译</font>。</p>
<p>比如，这样的代码很常见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG</span><br><span class="line">//...</span><br><span class="line">#else</span><br><span class="line">//...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>我们同样也可以定义其他预处理变量，在 XCode -&gt; 选中 Target -&gt; build settings 中，搜索 preprocessor。可以分别为 Debug 和 Release 两种模式设置预处理宏。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-f44b0523ec2d7d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"><br></center>

<p>比如加上：TESTMODE = 1，表示在这个宏中的代码运行在测试服务器。</p>
<p>然后，配合多个 Target（右键 Target，选择 Duplicate），单独一个 Target 负责测试服务器。这样就不用每次切换测试服务器都要修改代码了。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9e591436b1f5e436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"><br></center>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef TESTMODE</span><br><span class="line">// 测试服务器相关的代码</span><br><span class="line">#else</span><br><span class="line">// 生产服务器相关代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h4 id="7-4-插入脚本"><a href="#7-4-插入脚本" class="headerlink" title="7.4 插入脚本"></a>7.4 插入脚本</h4><p>通常，如果你使用 CocoaPod 来管理三方库，那么你的 Build Phase 是这样子的：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-cbf92c80a034e8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13"><br></center>

<p>其中：[CP] 开头的就是 CocoaPod 插入的脚本。</p>
<ul>
<li>Check Pods Manifest.lock，用来检查 cocoapod 管理的三方库是否需要更新</li>
<li>Embed Pods Framework，运行脚本来链接三方库的静态/动态库</li>
<li>Copy Pods Resources，运行脚本来拷贝三方库的资源文件</li>
</ul>
<p>而这些配置信息都存储在这个文件（.xcodeproj）里。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-204e1892f65add4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14"><br></center>

<p>到这里，CocoaPod 的原理也就大致搞清楚了，<font color="#cc0000">通过修改 xcodeproject，然后配置编译期脚本</font>，来保证三方库能够正确的编译连接。</p>
<p>同样，我们也可以插入自己的脚本来做一些额外的事情。比如，每次进行 archive 的时候，我们都必须手动调整 target 的 build 版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buildNumber=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)</span><br><span class="line">buildNumber=$(($buildNumber + 1))</span><br><span class="line">/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>这段脚本其实很简单，读取当前 plist 的 build 版本号，然后对其 +1，重新写入。</p>
<p>使用起来也很简单：</p>
<ul>
<li>Xcode -&gt; 选中 Target -&gt; 选中 build phase</li>
<li>选择添加 Run Script Phase</li>
</ul>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-7390774f5a869394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"><br></center>

<ul>
<li>然后把这段脚本拷贝进去，并且勾选 Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为 Auto Increase build number</li>
</ul>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1bbe50512c4a785c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16"><br></center>

<ul>
<li>然后，拖动这个脚本的到 Link Binary With Libraries 下面。</li>
</ul>
<h4 id="7-5-脚本编译打包"><a href="#7-5-脚本编译打包" class="headerlink" title="7.5 脚本编译打包"></a>7.5 脚本编译打包</h4><p>脚本化编译打包对于 CI（持续集成）来说，十分有用。iOS 开发中，编译打包必备的两个命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 编译成.app</span><br><span class="line">xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">// 打包</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</span><br><span class="line"></span><br><span class="line">// 通过 info 命令，可以查看到详细的文档</span><br><span class="line">info xcodebuild</span><br></pre></td></tr></table></figure>
<p>在本文最后的附录中，提供一个自动打包的脚本。</p>
<h4 id="7-6-提高项目编译速度"><a href="#7-6-提高项目编译速度" class="headerlink" title="7.6 提高项目编译速度"></a>7.6 提高项目编译速度</h4><p>通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了 XCode 的编译过程后，我们可以从以下角度来优化编译速度。</p>
<ol>
<li><p>查看编译时间</p>
<p> 我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。</p>
<p> 对于 XCode 8，关闭 XCode，终端输入以下指令</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>然后，重启 XCode，再编译，你会在这里看到编译时间。

&lt;center&gt;
![17](https://upload-images.jianshu.io/upload_images/5294842-699c09578e290bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
&lt;/center&gt;
</code></pre><ol start="2">
<li><p>代码层面的优化</p>
<ul>
<li><p>forward declaration</p>
<p>所谓 forward declaration，就是 @class CLASSNAME，而不是 #import CLASSNAME.h。这样，编译器能大大<font color="#cc0000">提高 #import 的替换速度</font>。</p>
</li>
<li><p>对常用的工具类进行打包（Framework/.a）</p>
<p>打包成 Framework 或者静态库，这样编译的时候这部分代码就<font color="#cc0000">不需要重新编译</font>了。</p>
</li>
<li><p>常用头文件放到预编译文件里</p>
<p>pch 文件是预编译文件，这里的内容在执行 XCode build 之前就已经被预编译，并且引入到了每一个 .m 文件里。</p>
</li>
</ul>
</li>
<li><p>编译器选项优化</p>
<ul>
<li><p>Debug 模式下，不生成 dsym 文件</p>
<p>上文提到了，dysm 文件里存储了调试信息，在 Debug 模式下，我们可以借助 XCode 和 LLDB 进行调试。所以，不需要生成额外的 dsym 文件来降低编译速度。</p>
</li>
<li><p>Debug 开启 Build Active Architecture Only</p>
<p>在 XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为 YES。这样做，可以只编译当前的版本，比如 arm7/arm64 等等，记得只开启 Debug 模式。这个选项在高版本的 XCode 中自动开启了。</p>
</li>
<li><p>Debug 模式下，关闭编译器优化</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-69b06dd791e83926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18"><br></center>


</li>
</ul>
</li>
</ol>
<h2 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h2><p>自动编译打包脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">export LC_ALL=zh_CN.GB2312;</span><br><span class="line">export LANG=zh_CN.GB2312</span><br><span class="line">buildConfig=&quot;Release&quot; //这里是build模式</span><br><span class="line">projectName=[find . -name *.xcodeproj | awk -F &quot;[/.]&quot; &apos;&#123;print $(NF-1)&#125;&apos;[</span><br><span class="line">projectDir=[pwd[</span><br><span class="line">wwwIPADir=~/Desktop/$projectName-IPA</span><br><span class="line">isWorkSpace=true</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">if [ -d &quot;$wwwIPADir&quot; ]; then</span><br><span class="line">echo $wwwIPADir</span><br><span class="line">echo &quot;文件目录存在&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;文件目录不存在&quot;</span><br><span class="line">mkdir -pv $wwwIPADir</span><br><span class="line">echo &quot;创建$&#123;wwwIPADir&#125;目录成功&quot;</span><br><span class="line">fi</span><br><span class="line">cd $projectDir</span><br><span class="line">rm -rf ./build</span><br><span class="line">buildAppToDir=$projectDir/build</span><br><span class="line">infoPlist=&quot;$projectName/Info.plist&quot;</span><br><span class="line">bundleVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlist`</span><br><span class="line">bundleIdentifier=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlist`</span><br><span class="line">bundleBuildVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist`</span><br><span class="line"></span><br><span class="line">if $isWorkSpace ; then  #是否用CocoaPod</span><br><span class="line">echo  &quot;开始编译workspace....&quot;</span><br><span class="line">xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">else</span><br><span class="line">echo  &quot;开始编译target....&quot;</span><br><span class="line">xcodebuild  -target  $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if test $? -eq 0</span><br><span class="line">then</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ipaName=[echo $projectName | tr &quot;[:upper:]&quot; &quot;[:lower:]&quot;[ #将项目名转小写</span><br><span class="line">findFolderName=[find . -name &quot;$buildConfig-*&quot; -type d |xargs basename[ #查找目录</span><br><span class="line">appDir=$buildAppToDir/$findFolderName/  #app所在路径</span><br><span class="line">echo &quot;开始打包$projectName.app成$projectName.ipa.....&quot;</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$appDir/$ipaName.ipa&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;打包$ipaName.ipa成功.&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;打包$ipaName.ipa失败.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">path=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipa</span><br><span class="line">cp -f -p $appDir/$ipaName.ipa $path   #拷贝ipa文件</span><br><span class="line">echo &quot;复制$ipaName.ipa到$&#123;wwwIPADir&#125;成功&quot;</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~结束编译，处理成功~~~~~~~~~~~~~~~~~~~&quot;</span><br></pre></td></tr></table></figure>
<h2 id="九、文章"><a href="#九、文章" class="headerlink" title="九、文章"></a>九、文章</h2><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/53557308" target="_blank" rel="noopener">iOS编译过程的原理和应用</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/">http://yoursite.com/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/10/iOS/iOS架构/组件化方案/" class="pre">组件化方案</a><a href="/2019/09/10/C/if-else、switch、while、for/" class="next">if-else、switch、while、for</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、iOS-编译"><span class="toc-text">二、iOS 编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、执行一次-XCode-build-的流程"><span class="toc-text">三、执行一次 XCode build 的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ipa-包的内容"><span class="toc-text">四、ipa 包的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、二进制文件的内容"><span class="toc-text">五、二进制文件的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、dSYM-文件"><span class="toc-text">六、dSYM 文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、应用场景"><span class="toc-text">七、应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-attribute"><span class="toc-text">7.1 __attribute__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-Clang-警告处理"><span class="toc-text">7.2 Clang 警告处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-预处理"><span class="toc-text">7.3 预处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-插入脚本"><span class="toc-text">7.4 插入脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-脚本编译打包"><span class="toc-text">7.5 脚本编译打包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-提高项目编译速度"><span class="toc-text">7.6 提高项目编译速度</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#八、附录"><span class="toc-text">八、附录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、文章"><span class="toc-text">九、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/图片处理/">图片处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/Premultiplied Alpha/">Premultiplied Alpha</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS架构/垃圾代码/">添加垃圾代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/pthread_rwlock_t/">pthread_rwlock_t</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD实现/">GCD实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD深入/">GCD深入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS原理/NSProxy/">NSProxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS架构/组件化方案/">组件化方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/">iOS 编译过程原理(1)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS音视频/">iOS音视频</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">1</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>