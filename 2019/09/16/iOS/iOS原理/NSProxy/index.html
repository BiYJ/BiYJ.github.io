<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>NSProxy | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">NSProxy</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">NSProxy</h1><div class="post-meta"><a href="/2019/09/16/iOS/iOS原理/NSProxy/#comments" class="comment-count"></a><p><span class="date">Sep 16, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>NSProxy 是一个<font color="#cc0000">实现了 NSObject 协议</font>类似于 NSObject 的根类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NS_ROOT_CLASS</span><br><span class="line">@interface NSProxy &lt;NSObject&gt;&#123;</span><br><span class="line">    Class   isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>苹果的官方文档：</p>
<blockquote>
<p>Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.</p>
<p>NSProxy implements the basic methods required of a root class, including those defined in the NSObject protocol. However, as an abstract class it doesn’t provide an initialization method, and it raises an exception upon receiving any message it doesn’t respond to. A concrete subclass must therefore provide an initialization or creation method and override the forwardInvocation: and methodSignatureForSelector: methods to handle messages that it doesn’t implement itself. A subclass’s implementation of forwardInvocation: should do whatever is needed to process the invocation, such as forwarding the invocation over the network or loading the real object and passing it the invocation. methodSignatureForSelector: is required to provide argument type information for a given message; a subclass’s implementation should be able to determine the argument types for the messages it needs to forward and should construct an NSMethodSignature object accordingly. See the NSDistantObject, NSInvocation, and NSMethodSignature class specifications for more information.</p>
</blockquote>
<p>看了这些描述我们应该能对 NSProxy 有个初步印象，<font color="#cc0000">它仅仅是个转发消息的场所</font>，至于如何转发，取决于派生类的具体实现。比如可以在内部 hold 住（或创建）一个对象，然后把消息转发给该对象。那我们就可以在转发的过程中做些手脚了。甚至也可以不去创建这些对象，去做任何你想做的事情，但是必须要实现它的 forwardInvocation: 和 methodSignatureForSelector: 方法。</p>
<h2 id="一、用途"><a href="#一、用途" class="headerlink" title="一、用途"></a>一、用途</h2><h4 id="1-1-多继承"><a href="#1-1-多继承" class="headerlink" title="1.1 多继承"></a>1.1 多继承</h4><p>大致过程就是让它持有要实现多继承的类的对象，然后用多个接口定义不同的行为，并让 Proxy 去实现这些接口，然后在转发的时候把消息转发到实现了该接口的对象去执行，这样就好像实现了多重继承一样。注意：这个真不是多重继承，只是包含，然后把消息路由到指定的对象而已，其实完全可以用 NSObject 类来实现。</p>
<p>NSObject 寻找方法顺序：本类 -> 父类 -> 动态方法解析 -> 备用对象 -> 消息转发；<br> NSproxy 寻找方法顺序：本类-> 消息转发；</p>
<p>同样做“消息转发”，NSObject 会比 NSProxy 多做好多事，也就意味着耽误很多时间。</p>
<p>首先新建两个基类如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation classA</span><br><span class="line">-(void)infoA</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;classA 卖水&quot;);   </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation classB</span><br><span class="line">-(void)infoB</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;classB 卖饭&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>代理如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassProxy : NSProxy</span><br><span class="line"></span><br><span class="line">@property(nonatomic, strong, readonly) NSMutableArray * targetArray;</span><br><span class="line"></span><br><span class="line">-(void)target:(id)target;</span><br><span class="line">-(void)handleTargets:(NSArray *)targets;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>NSProxy 必须以子类的形式出现。</p>
<p>因为考虑到很可能还有其他的卖衣服的、卖鞋子的需要 ClassProxy 来代理，这边做了一个数组来存放需要代理的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface ClassProxy()</span><br><span class="line">@property (nonatomic, strong) NSMutableArray * targetArray; // 多个 targets 皆可代理</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * methodDic;</span><br><span class="line">@property (nonatomic, strong) id target;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后 target 和相对应的 method name 做了一个字典来存储，方便获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(void)registMethodWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int countOfMethods = 0;</span><br><span class="line">    Method *method_list = class_copyMethodList([target class], &amp;countOfMethods);</span><br><span class="line">    for (int i = 0; i&lt;countOfMethods; i++) &#123;</span><br><span class="line">        Method method = method_list[i];</span><br><span class="line">        //得到方法的符号</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        //得到方法的符号字符串</span><br><span class="line">        const char *sel_name = sel_getName(sel);</span><br><span class="line">        //得到方法的名字</span><br><span class="line">        NSString * method_name = [NSString stringWithUTF8String:sel_name];</span><br><span class="line">        self.methodDic[method_name] = target;</span><br><span class="line">    &#125;</span><br><span class="line">    free(method_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是最主要的两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    id target = self.methodDic[methodName];</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        [invocation invokeWithTarget:target];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *Method;</span><br><span class="line">    NSString *methodName = NSStringFromSelector(sel);</span><br><span class="line">    id target = self.methodDic[methodName];</span><br><span class="line">    if (target) &#123;</span><br><span class="line">        Method =  [target methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        Method = [super methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    return Method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>methodSignatureForSelector: 得到对应的方法签名，通过 forwardInvocation: 转发。</p>
<p>调用和打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self classInheritance];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多继承</span><br><span class="line"> */</span><br><span class="line">-(void)classInheritance</span><br><span class="line">&#123;</span><br><span class="line">    classA * A = [[classA alloc]init];</span><br><span class="line">    classB * B = [[classB alloc]init];</span><br><span class="line">    ClassProxy * proxy = [ClassProxy alloc];</span><br><span class="line"></span><br><span class="line">    [proxy handleTargets:@[A, B]];</span><br><span class="line">    [proxy performSelector:@selector(infoA)];</span><br><span class="line">    [proxy performSelector:@selector(infoB)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2018-12-27 18:02:34.445 NSProxyStudy[18975:4587631] classA 卖水</span><br><span class="line">2018-12-27 18:02:34.446 NSProxyStudy[18975:4587631] classB 卖饭</span><br></pre></td></tr></table></figure>
<p>以上就是利用 NSProxy 实现多继承。</p>
<h4 id="1-2-避免循环应用"><a href="#1-2-避免循环应用" class="headerlink" title="1.2 避免循环应用"></a>1.2 避免循环应用</h4><p>举一个比较常见的例子 NSTimer。</p>
<p>由于苹果在 iOS10 以上给出了 timer 的 block 方式，已经可以解决循环引用的问题。所以这里只是说明利用 NSProxy 如何解决循环引用，实际情况可直接使用系统的方法。</p>
<p>首先因为 NSTimer 创建的时候需要传入一个 target，并且持有它，而 target 本身也会持有 timer 所以会造成循环引用。所以我们将 target 用 NSProxy 的子类代替。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    self.timer = [NSTimer timerWithTimeInterval:1</span><br><span class="line">                                         target:[WeakProxy proxyWithTarget:self]</span><br><span class="line">                                       selector:@selector(invoked:)</span><br><span class="line">                                       userInfo:nil</span><br><span class="line">                                        repeats:YES];</span><br><span class="line">    [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)invoked:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 WeakProxy 中我们设定 target 为弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@interface WeakProxy ()</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WeakProxy</span><br><span class="line">+(instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    return [[self alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(instancetype)initWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    self.target = target; </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line">    if ([self.target respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:self.target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后同样利用上述两个方法进行消息转发即可。</p>
<h4 id="1-3-AOP"><a href="#1-3-AOP" class="headerlink" title="1.3 AOP"></a>1.3 AOP</h4><p>要重点介绍的功能就是 AOP（Aspect Oriented Programming），它是可以<font color="#cc0000">通过预编译方式和运行时动态代理实现在不修改源代码的情况下给程序动态添加功能的一种技术</font>。</p>
<p>iOS 中面向切片编程一般有两种方式 ，一种是直接基于 runtime 的 method-Swizzling 机制来实现方法替换从而达到 hook 的目的，另一种就是基于 NSProxy。</p>
<p>OC 的动态语言的核心部分应该就是 objc_msgSend 方法的调用了。该函数的声明大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 参数 1：接受消息的 target</span><br><span class="line"> * 参数 2：要执行的 selector</span><br><span class="line"> * 参数 3：要调用的方法</span><br><span class="line"> * 可变参数：若干个要传给 selector 的参数 </span><br><span class="line"> */</span><br><span class="line">id objc_msgSend(id self, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>
<p>只要我们能够 Hook 到对某个对象的 objc_msgSend 的调用，并且可以修改其参数甚至于修改成任意其他 selector 的 IMP，我们就实现了 AOP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface MyProxy : NSProxy &#123;</span><br><span class="line">     id _innerObject;  // 在内部持有要 hook 的对象</span><br><span class="line">&#125;</span><br><span class="line">+(instancetype)proxyWithObj:(id)object;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Dog : NSObject</span><br><span class="line">-(NSString *)barking:(NSInteger)months;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>实现部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyProxy</span><br><span class="line"></span><br><span class="line">+(instancetype)proxyWithObj:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    MyProxy * proxy = [MyProxy alloc];</span><br><span class="line">    // 持有要 hook 的对象</span><br><span class="line">    proxy-&gt;_innerObject = object;</span><br><span class="line">    // 注意返回的值是 Proxy 对象</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    // 这里可以返回任何 NSMethodSignature 对象，也可以完全自己构造一个</span><br><span class="line">    return [_innerObject methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    if([_innerObject respondsToSelector:invocation.selector])&#123;</span><br><span class="line">        NSString *selectorName = NSStringFromSelector(invocation.selector);</span><br><span class="line">        NSLog(@&quot;Before calling %@&quot;,selectorName);</span><br><span class="line">        [invocation retainArguments];</span><br><span class="line">        NSMethodSignature *sig = [invocation methodSignature];</span><br><span class="line">        // 获取参数个数，注意在本例里这里的值是 3，因为 objc_msgSend 隐含了 self、selector 参数</span><br><span class="line">        NSUInteger cnt = [sig numberOfArguments];</span><br><span class="line">        // 本例只是简单的将参数和返回值打印出来</span><br><span class="line">        for (int i = 0; i &lt; cnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            // 参数类型</span><br><span class="line">            const char * type = [sig getArgumentTypeAtIndex:i];</span><br><span class="line">            if(strcmp(type, &quot;@&quot;) == 0)&#123;</span><br><span class="line">                NSObject *obj;</span><br><span class="line">                [invocation getArgument:&amp;obj atIndex:i];</span><br><span class="line">                // 这里输出的是：&quot;parameter (0)&apos;class is MyProxy&quot;，也证明了这是 objc_msgSend 的第一个参数</span><br><span class="line">                NSLog(@&quot;parameter (%d)&apos;class is %@&quot;, i, [obj class]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(strcmp(type, &quot;:&quot;) == 0)&#123;</span><br><span class="line">                SEL sel;</span><br><span class="line">                [invocation getArgument:&amp;sel atIndex:i];</span><br><span class="line">                // 这里输出的是:&quot;parameter (1) is barking:&quot;，也就是 objc_msgSend 的第二个参数</span><br><span class="line">                NSLog(@&quot;parameter (%d) is %@&quot;, i, NSStringFromSelector(sel));</span><br><span class="line">            &#125;</span><br><span class="line">            else if(strcmp(type, &quot;q&quot;) == 0)&#123;</span><br><span class="line">                int arg = 0;</span><br><span class="line">                [invocation getArgument:&amp;arg atIndex:i];</span><br><span class="line">                // 这里输出的是:&quot;parameter (2) is int value is 4&quot;，稍后会看到我们在调用 barking 的时候传递的参数就是 4</span><br><span class="line">                NSLog(@&quot;parameter (%d) is int value is %d&quot;, i, arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 消息转发</span><br><span class="line">        [invocation invokeWithTarget:_innerObject];</span><br><span class="line">        const char *retType = [sig methodReturnType];</span><br><span class="line">        if(strcmp(retType, &quot;@&quot;) == 0)&#123;</span><br><span class="line">            NSObject *ret;</span><br><span class="line">            [invocation getReturnValue:&amp;ret];</span><br><span class="line">            //这里输出的是:&quot;return value is wang wang!&quot;</span><br><span class="line">            NSLog(@&quot;return value is %@&quot;, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;After calling %@&quot;, selectorName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Dog</span><br><span class="line">-(NSString *)barking:(NSInteger)months</span><br><span class="line">&#123;</span><br><span class="line">    return months &gt; 3 ? @&quot;wang wang!&quot; : @&quot;eng eng!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>函数的调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog * dog = [MyProxy proxyWithObj:[Dog alloc]];</span><br><span class="line">[dog barking:4];</span><br></pre></td></tr></table></figure>
<p>上面的代码中，可以任意更改参数、调用的方法，甚至转发给其他类型的对象，这确实达到了 Hook 对象的目的，也就是可以实现 AOP 的功能了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^proxyBlock)(id target,SEL selector);</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface AOPProxy : NSProxy</span><br><span class="line">+(instancetype)proxyWithTarget:(id)target;</span><br><span class="line">-(void)inspectSelector:(SEL)selector preSelTask:(proxyBlock)preTask endSelTask:(proxyBlock)endTask;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface AOPProxy ()</span><br><span class="line">@property (nonatomic, strong) id target;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * preSelTaskDic;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary * endSelTaskDic;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(void)inspect&#123;</span><br><span class="line">    NSMutableArray * targtArray = [AOPProxy proxyWithTarget:[NSMutableArray arrayWithCapacity:1]];</span><br><span class="line">    [(AOPProxy *)targtArray inspectSelector:@selector(addObject:) preSelTask:^(id target, SEL selector) &#123;</span><br><span class="line">        [target addObject:@&quot;-------&quot;];</span><br><span class="line">        NSLog(@&quot;%@ 我加进来之前&quot;, target);</span><br><span class="line">    &#125; endSelTask:^(id target, SEL selector) &#123;</span><br><span class="line">        [target addObject:@&quot;-------&quot;];</span><br><span class="line">        NSLog(@&quot;%@ 我加进来之后&quot;, target);</span><br><span class="line">    &#125;];</span><br><span class="line">    [targtArray addObject:@&quot;我是一个元素&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">( &quot;-------&quot; ) 我加进来之前</span><br><span class="line">( &quot;-------&quot;, </span><br><span class="line">  &quot;\U6211\U662f\U4e00\U4e2a\U5143\U7d20&quot;, </span><br><span class="line">  &quot;-------&quot; ) </span><br><span class="line">我加进来之后</span><br></pre></td></tr></table></figure>
<h3 id="1-4-实现延迟初始化（Lazy-Initialization）"><a href="#1-4-实现延迟初始化（Lazy-Initialization）" class="headerlink" title="1.4 实现延迟初始化（Lazy Initialization）"></a>1.4 实现延迟初始化（Lazy Initialization）</h3><p>使用场景：</p>
<ol>
<li><p>在 [SomeClass lazy] 之后调用 doSomthing，首先进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用 init 初始化对象，然后将消息转发给代理对象 _object；</p>
</li>
<li><p>在 [SomeClass lazy] 之后调用 initWithXXX:，首先进入 forwardingTargetForSelector 返回 nil，然后进入 methodSignatureForSelector: 和 forwardInvocation: 保存自定义初始化方法的调用，最后调用 doSomthing，进入 forwardingTargetForSelector，_object 为 nil 并且不是 init 开头的方法的时候会调用自定义初始化方法，然后将消息转发给代理对象 _object。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SomeClass *object = [SomeClass lazy];</span><br><span class="line"></span><br><span class="line">// other thing ...</span><br><span class="line"></span><br><span class="line">[object doSomething];  // 在这里 object 才会调用初始化方法，然后调用 doSomething</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/09/16/iOS/iOS原理/NSProxy/">http://yoursite.com/2019/09/16/iOS/iOS原理/NSProxy/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/16/iOS/iOS多线程/GCD深入/" class="pre">GCD深入</a><a href="/2019/09/10/iOS/iOS架构/组件化方案/" class="next">组件化方案</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、用途"><span class="toc-text">一、用途</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-多继承"><span class="toc-text">1.1 多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-避免循环应用"><span class="toc-text">1.2 避免循环应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-AOP"><span class="toc-text">1.3 AOP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-实现延迟初始化（Lazy-Initialization）"><span class="toc-text">1.4 实现延迟初始化（Lazy Initialization）</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/图片处理/">图片处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/Premultiplied Alpha/">Premultiplied Alpha</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS架构/垃圾代码/">添加垃圾代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/pthread_rwlock_t/">pthread_rwlock_t</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD实现/">GCD实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD深入/">GCD深入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS原理/NSProxy/">NSProxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS架构/组件化方案/">组件化方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/">iOS 编译过程原理(1)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS音视频/">iOS音视频</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">1</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>