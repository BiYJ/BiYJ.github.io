<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>GCD深入 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">GCD深入</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">GCD深入</h1><div class="post-meta"><a href="/2019/09/16/iOS/iOS多线程/GCD深入/#comments" class="comment-count"></a><p><span class="date">Sep 16, 2019</span><span><a href="/categories/iOS多线程/" class="category">iOS多线程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、知识储备"><a href="#一、知识储备" class="headerlink" title="一、知识储备"></a>一、知识储备</h2><p>阅读 <a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a>之前，需要了解一些相关知识。</p>
<h4 id="1-1-DISPATCH-DECL"><a href="#1-1-DISPATCH-DECL" class="headerlink" title="1.1 DISPATCH_DECL"></a>1.1 DISPATCH_DECL</h4><p>GCD 中对变量的定义大多遵循如下格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DISPATCH_DECL(name) typedef struct name##_s *name##_t</span><br></pre></td></tr></table></figure>
<p>如 DISPATCH_DECL(dispatch_queue); 的展开形式是：typedef struct dispatch_queue_s *dispatch_queue_t; 这行代码定义了一个 dispatch_queue_t 类型的指针，指向一个 dispatch_queue_s 类型的结构体。</p>
<h4 id="1-2-TSD"><a href="#1-2-TSD" class="headerlink" title="1.2 TSD"></a>1.2 TSD</h4><p>TSD（Thread-Specific Data）表示线程私有数据。在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。在不同线程中，虽然名字相同，但是获取到的数据随线程不同而不同。通常我们可以利用 POSIX 库提供的 API 来实现 TSD：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *))</span><br></pre></td></tr></table></figure>
<p>此函数用来创建一个 key，在线程退出时会将 key 对应的数据传入 destr_function 函数中进行清理。我们分别使用 get/set 方法来访问/修改 key 对应的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  pthread_setspecific(pthread_key_t  key,  const   void  *pointer)</span><br><span class="line">  </span><br><span class="line">void * pthread_getspecific(pthread_key_t key)</span><br></pre></td></tr></table></figure>
<p>在 GCD 中定义了六个 key，根据名字大概能猜出各自的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_key_t dispatch_queue_key;  </span><br><span class="line">pthread_key_t dispatch_sema4_key;  </span><br><span class="line">pthread_key_t dispatch_cache_key;  </span><br><span class="line">pthread_key_t dispatch_io_key;  </span><br><span class="line">pthread_key_t dispatch_apply_key;  </span><br><span class="line">pthread_key_t dispatch_bcounter_key;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-fastpath-amp-amp-slowpath"><a href="#1-3-fastpath-amp-amp-slowpath" class="headerlink" title="1.3 fastpath &amp;&amp; slowpath"></a>1.3 fastpath &amp;&amp; slowpath</h4><p>这是定义在 internal.h 中的两个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span><br><span class="line">#define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span><br></pre></td></tr></table></figure>
<p>为了理解所谓的快路径和慢路径，需要先学习一点计算机基础知识。比如这段非常简单的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (x)  </span><br><span class="line">    return 1;</span><br><span class="line">else  </span><br><span class="line">    return 39;</span><br></pre></td></tr></table></figure>
<p>由于<font color="#cc0000">计算机并非一次只读取一条指令，而是读取多条指令</font>，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的<font color="#cc0000">指令重读</font>。当然，最简单的优化就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!x)  </span><br><span class="line">    return 39;</span><br><span class="line">else  </span><br><span class="line">    return 1;</span><br></pre></td></tr></table></figure>
<p>然而对程序员来说，每次都做这样的判断非常烧脑，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long __builtin_expect (long EXP, long C)</span><br></pre></td></tr></table></figure>
<p>它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (__builtin_expect(x, 0))  </span><br><span class="line">    return 1;</span><br><span class="line">else  </span><br><span class="line">    return 39;</span><br></pre></td></tr></table></figure>
<p>虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。</p>
<h2 id="二、dispatch-queue-t"><a href="#二、dispatch-queue-t" class="headerlink" title="二、dispatch_queue_t"></a>二、dispatch_queue_t</h2><p>以 dispatch_queue_create 的源码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) &#123;</span><br><span class="line">    // 省略 label 相关的操作</span><br><span class="line"></span><br><span class="line">    dispatch_queue_t dq;</span><br><span class="line">    dq = _dispatch_alloc(DISPATCH_VTABLE(queue),</span><br><span class="line">            sizeof(struct dispatch_queue_s) - DISPATCH_QUEUE_MIN_LABEL_SIZE -</span><br><span class="line">            DISPATCH_QUEUE_CACHELINE_PAD + label_len + 1);</span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    if (fastpath(!attr)) &#123;</span><br><span class="line">        return dq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (fastpath(attr == DISPATCH_QUEUE_CONCURRENT)) &#123;</span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        dq-&gt;do_targetq = _dispatch_get_root_queue(0, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        dispatch_debug_assert(!attr, &quot;Invalid attribute&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道创建队列时， attr 属性有三个值可选，nil、DISPATCH_QUEUE_SERIAL（实际上就是 nil）或 DISPATCH_QUEUE_CONCURRENT。</p>
<p>第一个 if 判断中，苹果认为串行队列或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。</p>
<p>第二个判断中，参数几乎只可能是 DISPATCH_QUEUE_CONCURRENT，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断几乎不会为 0，依然与 fastpath 的作用一致。</p>
<p><font color="#cc0000">_dispatch_get_root_queue</font> 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载（overcommit）。这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务（比如下文介绍的定时器），3 这个序列号暂时没有使用。队列 的 <font color="#cc0000">dq_width</font> 被设置为 UINT32_MAX，表示这些队列不限制并发数。作为对比，在 _dispatch_queue_init 中，并发数限制为 1，也就是串行队列的默认设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_queue_init(dispatch_queue_t dq) &#123;  </span><br><span class="line">    dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);</span><br><span class="line">    dq-&gt;dq_running = 0;</span><br><span class="line">    dq-&gt;dq_width = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这行代码：dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);，它涉及到 GCD 队列与 block 的一个重要模型，target_queue。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。借用 <a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">objc 的文章</a> 中的图片来表示：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-bf853ec94c911d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br></center>

<h2 id="二、dispatch-async"><a href="#二、dispatch-async" class="headerlink" title="二、dispatch_async"></a>二、dispatch_async</h2><p>直接上函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block) &#123;  </span><br><span class="line">    dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="#cc0000">队列其实就是一个用来提交 block 的对象</font>，当 block 提交到队列中后，将按照 “先入先出（FIFO）” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。block 参数的类型是 dispatch_block_t，它是一个没有参数，没有返回值的 block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^dispatch_block_t)(void);</span><br></pre></td></tr></table></figure>
<p>dispatch_async 的函数很简单，它将 block 复制了一份，然后调用另一个函数 dispatch_async_f：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);</span><br></pre></td></tr></table></figure>
<p>work 参数是一个函数，在实际调用时，会把第二参数 context 作为参数传入，以 _dispatch_call_block_and_release 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_call_block_and_release(void *block) &#123;  </span><br><span class="line">    void (^b)(void) = block;</span><br><span class="line">    b();</span><br><span class="line">    Block_release(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略各种分支后的 dispatch_async_f 函数实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    if (dq-&gt;dq_width == 1) &#123;</span><br><span class="line">        return dispatch_barrier_async_f(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (void *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    if (dq-&gt;do_targetq) &#123;</span><br><span class="line">        return _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见如果是串行队列（dq_width = 1），会调用 dispatch_barrier_async_f 函数处理。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。这里的 dispatch_continuation_t 其实是对 block 的封装，然后调用 _dispatch_queue_push 这个宏将封装好的 block 放入队列中。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push  </span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br><span class="line">        └──_dispatch_queue_push_slow</span><br><span class="line">            └──_dispatch_queue_push_list_slow2</span><br><span class="line">                └──_dispatch_wakeup</span><br><span class="line">                    └──dx_probe</span><br></pre></td></tr></table></figure>
<p>队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法，调用栈如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global  </span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure>
<p>在 _dispatch_queue_wakeup_global_slow 我们见到了熟悉的老朋友 pthread 线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) &#123;</span><br><span class="line"> </span><br><span class="line">    // 如果线程池已满，则直接调用 _dispatch_worker_thread </span><br><span class="line">    // 否则创建线程池</span><br><span class="line">    pthread_t pthr;</span><br><span class="line">    while ((r = pthread_create(&amp;pthr, NULL, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">        if (r != EAGAIN) &#123;</span><br><span class="line">            (void)dispatch_assume_zero(r);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">    r = pthread_detach(pthr);</span><br><span class="line">    (void)dispatch_assume_zero(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见这里确实使用了线程池。创建线程后会执行 _dispatch_worker_thread 回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_worker_thread  </span><br><span class="line">└──_dispatch_worker_thread4</span><br><span class="line">    └──_dispatch_continuation_pop</span><br></pre></td></tr></table></figure>
<p>在 pop 函数中，我们拿到了最早加入的任务，然后执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline void _dispatch_continuation_pop(dispatch_object_t dou) &#123;  </span><br><span class="line">    // ...</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    if (dg) &#123;</span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_async 的实现比较复杂，主要是因为其中的数据结构较多，分支流程控制比较复杂。但思路其实很简单，用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。如果熟悉了相关数据结构和调用流程，接下来研究 GCD 的其他 API 就比较轻松了。</p>
<h2 id="三、dispatch-sync"><a href="#三、dispatch-sync" class="headerlink" title="三、dispatch_sync"></a>三、dispatch_sync</h2><p>同步方法的实现相对来说和异步类似，而且更简单，调用栈如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync  </span><br><span class="line">└──dispatch_sync_f</span><br><span class="line">    └──_dispatch_sync_f2</span><br><span class="line">        └──_dispatch_sync_f_slow</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_sync_f_slow(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    struct dispatch_sync_slow_s &#123;</span><br><span class="line">        DISPATCH_CONTINUATION_HEADER(sync_slow);</span><br><span class="line">    &#125; dss = &#123;</span><br><span class="line">        .do_vtable = (void*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_ctxt = (void*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push(dq, (void *)&amp;dss);</span><br><span class="line"></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。</p>
<h2 id="四、dispatch-semaphore"><a href="#四、dispatch-semaphore" class="headerlink" title="四、dispatch_semaphore"></a>四、dispatch_semaphore</h2><p>关于信号量的 API 不多，主要是三个：create、wait 和 signal。信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value，一个是当前的 value，一个是记录初始 value。信号的 wait 和 signal 是互逆的两个操作。如果 value &gt; 0，前者将 value - 1，此时如果 value &lt; 0 就一直等待。初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。</p>
<h4 id="4-1-dispatch-semaphore-wait"><a href="#4-1-dispatch-semaphore-wait" class="headerlink" title="4.1 dispatch_semaphore_wait"></a>4.1 dispatch_semaphore_wait</h4><p>首先从源码看起：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">    long value = dispatch_atomic_dec2o(dsema, dsema_value);</span><br><span class="line">    dispatch_atomic_acquire_barrier();</span><br><span class="line">    if (fastpath(value &gt;= 0)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 <font color="#cc0000">__sync_sub_and_fetch，实现减法的原子性操作</font>。因此这一行的意思是将 dsema 的值减 1，并把新的值赋给 value。如果减一后的 value ≥ 0 就立刻返回，没有任何操作，否则进入等待状态。_dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case DISPATCH_TIME_NOW:  </span><br><span class="line">    while ((orig = dsema-&gt;dsema_value) &lt; 0) &#123;</span><br><span class="line">        if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) &#123;</span><br><span class="line">            return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value + 1（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。实际上 while 判断一定会成立，因为如果 value 大于等于 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。</p>
<p>第二种情况是 DISPATCH_TIME_FOREVER 这个 case：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case DISPATCH_TIME_FOREVER:  </span><br><span class="line">    do &#123;</span><br><span class="line">        kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">    &#125; while (kr == KERN_ABORTED);</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<p>进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。整个函数的框架如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">again:  </span><br><span class="line">    while ((orig = dsema-&gt;dsema_sent_ksignals)) &#123;</span><br><span class="line">        if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,</span><br><span class="line">                orig - 1)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (timeout) &#123;</span><br><span class="line">        default:  /* semaphore_timedwait */</span><br><span class="line">        case DISPATCH_TIME_NOW: /* KERN_OPERATION_TIMED_OUT */</span><br><span class="line">        case DISPATCH_TIME_FOREVER: /* semaphore_wait */</span><br><span class="line">    &#125;</span><br><span class="line">    goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。</p>
<h4 id="4-2-dispatch-semaphore-signal"><a href="#4-2-dispatch-semaphore-signal" class="headerlink" title="4.2 dispatch_semaphore_signal"></a>4.2 dispatch_semaphore_signal</h4><p>这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_semaphore_signal(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    long value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">    if (fastpath(value &gt; 0)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会调用原子方法让 value + 1，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：“如果唤醒了线程，返回非 0，否则返回 0”。</p>
<h2 id="五、dispatch-group"><a href="#五、dispatch-group" class="headerlink" title="五、dispatch_group"></a>五、dispatch_group</h2><p>有了上面的铺垫，group 是一个非常容易理解的概念，我们先看看如何创建 group：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t dispatch_group_create(void) &#123;  </span><br><span class="line">    dispatch_group_t dg = _dispatch_alloc(DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s));</span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    return dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，group 就是一个 value 为 LONG_MAX 的信号量。</p>
<h4 id="5-1-dispatch-group-async"><a href="#5-1-dispatch-group-async" class="headerlink" title="5.1 dispatch_group_async"></a>5.1 dispatch_group_async</h4><p>它仅仅是 dispatch_group_async_f 的封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line"></span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数和 dispatch_async_f 的实现高度一致，主要的不同在于调用了 dispatch_group_enter 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_enter(dispatch_group_t dg) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    (void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也没做什么，就是调用 wait 方法让信号量的 value 减一而已。</p>
<h4 id="5-2-dispatch-group-wait"><a href="#5-2-dispatch-group-wait" class="headerlink" title="5.2 dispatch_group_wait"></a>5.2 dispatch_group_wait</h4><p>这个方法用于等待 group 中所有任务执行完成，可以理解为信号量 wait 的封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (timeout == 0) &#123;</span><br><span class="line">        return KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前 value 和原始 value 相同，表明任务已经全部完成，直接返回 0，如果 timeout 为 0 也会立刻返回，否则调用 _dispatch_group_wait_slow。这个方法的等待部分和 _dispatch_semaphore_signal_slow 几乎一致，区别在于等待结束后它不是 return，而是调用 _dispatch_group_wake 去唤醒这个 group。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) &#123;  </span><br><span class="line">again:  </span><br><span class="line">    _dispatch_group_wake(dsema);</span><br><span class="line">    switch (timeout) &#123;/* 三种情况分类 */&#125;    </span><br><span class="line">    goto again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们暂时跳过 _dispatch_group_wake，后面会有详细分析。只要知道这个函数在 group 中所有事件执行完后会被调用即可。</p>
<h4 id="5-3-dispatch-group-notify"><a href="#5-3-dispatch-group-notify" class="headerlink" title="5.3 dispatch_group_notify"></a>5.3 dispatch_group_notify</h4><p>这个函数仅仅是封装了 dispatch_group_notify_f：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, void (*func)(void *)) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    struct dispatch_sema_notify_s *dsn, *prev;</span><br><span class="line"></span><br><span class="line">    dsn-&gt;dsn_queue = dq;</span><br><span class="line">    dsn-&gt;dsn_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dsn_func = func;</span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn);</span><br><span class="line">    if (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;dsn_next = dsn;</span><br><span class="line">    &#125; else &#123;/* ... */&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种结构的代码已经遇到多次了，它其实就是在链表的尾部续上新的元素。所以 notify 方法并没有做过多的处理，只是用链表把所有回调通知保存起来，等待调用。</p>
<h4 id="5-4-dispatch-group-leave"><a href="#5-4-dispatch-group-leave" class="headerlink" title="5.4 dispatch_group_leave"></a>5.4 dispatch_group_leave</h4><p>在介绍 dispatch_async 函数时，我们看到任务在被执行时，还会调用 dispatch_group_leave 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_group_leave(dispatch_group_t dg) &#123;  </span><br><span class="line">    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;</span><br><span class="line">    long value = dispatch_atomic_inc2o(dsema, dsema_value);</span><br><span class="line">    if (slowpath(value == dsema-&gt;dsema_orig)) &#123;</span><br><span class="line">        (void)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 group 的 value 变为初始值时，表示所有任务都已执行完，开始调用 _dispatch_group_wake 处理回调。  </p>
<h4 id="5-5-dispatch-group-wake"><a href="#5-5-dispatch-group-wake" class="headerlink" title="5.5 dispatch_group_wake"></a>5.5 dispatch_group_wake</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static long _dispatch_group_wake(dispatch_semaphore_t dsema) &#123;  </span><br><span class="line">    struct dispatch_sema_notify_s *next, *head, *tail = NULL;</span><br><span class="line">    long rval;</span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL);</span><br><span class="line"></span><br><span class="line">    if (head) &#123;</span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = dispatch_atomic_xchg2o(dsema, dsema_group_waiters, 0);</span><br><span class="line">    if (rval) &#123;</span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_waiter_port);</span><br><span class="line">        do &#123;</span><br><span class="line">            kern_return_t kr = semaphore_signal(dsema-&gt;dsema_waiter_port);</span><br><span class="line">        &#125; while (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    if (head) &#123;</span><br><span class="line">        // async group notify blocks</span><br><span class="line">        do &#123;</span><br><span class="line">            dispatch_async_f(head-&gt;dsn_queue, head-&gt;dsn_ctxt, head-&gt;dsn_func);</span><br><span class="line">            next = fastpath(head-&gt;dsn_next);</span><br><span class="line">            if (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                while (!(next = fastpath(head-&gt;dsn_next))) &#123;</span><br><span class="line">                    _dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            free(head);</span><br><span class="line">        &#125; while ((head = next));</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要分为两部分，首先循环调用 semaphore_signal 告知唤醒当初等待 group 的信号量，因此 dispatch_group_wait 函数得以返回。然后获取链表，依次调用 dispatch_async_f 异步执行在 notify 函数中注册的回调。</p>
<h2 id="六、dispatch-once"><a href="#六、dispatch-once" class="headerlink" title="六、dispatch_once"></a>六、dispatch_once</h2><p>dispatch_once 仅仅是一个包装，内部直接调用了 dispatch_once_f：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    struct _dispatch_once_waiter_s * volatile *vval = (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;;</span><br><span class="line">    struct _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">    _dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">    if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line">        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        while (tail != tmp) &#123;</span><br><span class="line">            while (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                _dispatch_hardware_pause();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            tmp = *vval;</span><br><span class="line">            if (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_atomic_store_barrier();</span><br><span class="line">            if (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码比较长，我们考虑三个场景：</p>
<ol>
<li><p>第一次调用：此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。</p>
<p> 首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。</p>
</li>
<li><p>同一线程第二次调用：由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。</p>
<p> 由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。</p>
</li>
<li><p>多个线程同时调用：由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。</p>
<p> 由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。</p>
</li>
</ol>
<h2 id="七、dispatch-barrier-async"><a href="#七、dispatch-barrier-async" class="headerlink" title="七、dispatch_barrier_async"></a>七、dispatch_barrier_async</h2><p>它调用了 dispatch_barrier_async_f 函数，实现原理也和 dispatch_async_f 类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    dispatch_continuation_t dc;</span><br><span class="line">    dc = fastpath(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    dc-&gt;do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区别在于 do_vtable 被设置了两个标志位，多了一个 DISPATCH_OBJ_BARRIER_BIT 标记。这个标记在从队列中取出任务时被用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static _dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_queue_t dq) &#123;  </span><br><span class="line">    while (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">        if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp; (long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">            if (dq-&gt;dq_running &gt; 1) &#123;</span><br><span class="line">                goto out;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:  </span><br><span class="line">    /* 不完整的 drain，需要清理现场 */</span><br><span class="line">    return sema; // 返回空的信号量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里原来是一个循环，会拿出所有的任务，依次调用 _dispatch_continuation_redirect，最终并行处理。一旦遇到 DISPATCH_OBJ_BARRIER_BIT 这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_queue_invoke(dispatch_queue_t dq) &#123;  </span><br><span class="line">    _dispatch_thread_semaphore_t sema = _dispatch_queue_drain(dq);</span><br><span class="line">    if (sema) &#123;</span><br><span class="line">        _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">    &#125; else if (tq) &#123;</span><br><span class="line">        return _dispatch_queue_push(tq, dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此 barrier 方法能等待此前所有任务执行完以后执行 _dispatch_queue_push，同时保证自己执行完以后才执行后续的操作。</p>
<h2 id="八、dispatch-source"><a href="#八、dispatch-source" class="headerlink" title="八、dispatch_source"></a>八、dispatch_source</h2><p>source 是一种资源，类似于生产者/消费者模式中的生产者，而队列则是消费者。当有新的资源（source）产生时，它们被放到对应的队列上被执行（消费）。dispatch_source 最常见的用途之一就是用来实现定时器，举一个小例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);  </span><br><span class="line"></span><br><span class="line">// 每 10 秒触发 timer，误差 1 秒</span><br><span class="line">dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 10*NSEC_PER_SEC, 1*NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;  </span><br><span class="line">    // 定时器触发时执行的 block</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>使用 GCD Timer 的好处在于<font color="#cc0000">不依赖 runloop</font>，因此任何线程都可以使用。由于使用了 block，不会忘记避免循环引用。此外，定时器可以自由控制精度，随时修改间隔时间等。</p>
<h4 id="8-1-dispatch-source-create"><a href="#8-1-dispatch-source-create" class="headerlink" title="8.1 dispatch_source_create"></a>8.1 dispatch_source_create</h4><p>下面从底层源码的角度来研究这几行代码的作用。首先是 dispatch_source_create 函数，它和之前见到的 create 函数都差不多，对 dispatch_source_t 对象做了一些初始化工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t ds = NULL;  </span><br><span class="line">ds = _dispatch_alloc(DISPATCH_VTABLE(source), sizeof(struct dispatch_source_s));  </span><br><span class="line">_dispatch_queue_init((dispatch_queue_t)ds);  </span><br><span class="line">ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;  </span><br><span class="line">ds-&gt;do_targetq = &amp;_dispatch_mgr_q;  </span><br><span class="line">dispatch_set_target_queue(ds, q);  </span><br><span class="line">return ds;</span><br></pre></td></tr></table></figure>
<p>这里涉及到两个队列，其中 q 是用户指定的队列，表示事件触发的回调在哪个队列执行。而 _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写，也是上文提到的序列号为 2 的内部队列。</p>
<h4 id="8-2-dispatch-source-set-timer"><a href="#8-2-dispatch-source-set-timer" class="headerlink" title="8.2 dispatch_source_set_timer"></a>8.2 dispatch_source_set_timer</h4><p>在这个函数中，首先会有参数处理，过滤掉不符合要求的参数。随后创建了 dispatch_set_timer_params 类型的指针 params：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct dispatch_set_timer_params &#123;  </span><br><span class="line">    dispatch_source_t ds;</span><br><span class="line">    uintptr_t ident;</span><br><span class="line">    struct dispatch_timer_source_s values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个 params 负责绑定定时器对象与它的参数（存储在 values 属性中），最后调用：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async_f((dispatch_queue_t)ds, params, _dispatch_source_set_timer2);</span><br></pre></td></tr></table></figure>
<p>这里是把 source 当做队列来使用，因此实际上是调用了 _dispatch_source_set_timer2(params) 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_source_set_timer2(void *context) &#123;  </span><br><span class="line">    // Called on the source queue</span><br><span class="line">    struct dispatch_set_timer_params *params = context;</span><br><span class="line">    dispatch_suspend(params-&gt;ds);</span><br><span class="line">    dispatch_barrier_async_f(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先暂停了队列，避免了修改的过程中定时器被触发。然后在 manager 队列上执行 _dispatch_source_set_timer3(params)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_source_set_timer3(void *context) &#123;  </span><br><span class="line">    struct dispatch_set_timer_params *params = context;</span><br><span class="line">    dispatch_source_t ds = params-&gt;ds;</span><br><span class="line">    // ...</span><br><span class="line">    _dispatch_timer_list_update(ds);</span><br><span class="line">    dispatch_resume(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_dispatch_timer_list_update 函数的作用是根据下一次触发时间将 timer 排序。接下来，当初分发到 manager 队列的 block 将要被执行，走到 _dispatch_mgr_invoke 函数，其中有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeoutp = _dispatch_get_next_timer_fire(&amp;timeout);  </span><br><span class="line">r = select(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, NULL, sel_timeoutp);</span><br></pre></td></tr></table></figure>
<p>可见 GCD 的定时器是由系统的 select 方法实现的。当内层的 manager 队列被唤醒后，还会进一步唤醒外层的队列（当初用户指定的那个），并在队列上执行 timer 触发时的 block。</p>
<h2 id="九、dispatch-resume-suspend"><a href="#九、dispatch-resume-suspend" class="headerlink" title="九、dispatch_resume/suspend"></a>九、dispatch_resume/suspend</h2><p>GCD 对象的暂停和恢复由 do_suspend_cnt 决定，暂停时通过原子操作将该属性的值加 2，对应的在恢复时通过原子操作将该属性减 2。它有两个默认值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DISPATCH_OBJECT_SUSPEND_LOCK        1u</span><br><span class="line">#define DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span><br></pre></td></tr></table></figure>
<p>在唤醒队列时有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void _dispatch_queue_invoke(dispatch_queue_t dq) &#123;  </span><br><span class="line">    if (!dispatch_atomic_sub2o(dq, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK)) &#123;</span><br><span class="line">        if (dq-&gt;dq_running == 0) &#123;</span><br><span class="line">            _dispatch_wakeup(dq); // verify that the queue is idle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见能够唤醒队列的前提是 dq-&gt;do_suspend_cnt - 1 = 0，也就是要求 do_suspend_cnt 的值就是 DISPATCH_OBJECT_SUSPEND_LOCK。观察 8 个全局队列和主队列的定义就会发现，他们的 do_suspend_cnt 值确实为 DISPATCH_OBJECT_SUSPEND_LOCK，因此默认处于启动状态。而 dispatch_source 的 create 方法中，do_suspend_cnt 的初始值为 DISPATCH_OBJECT_SUSPEND_INTERVAL，因此默认处于暂停状态，需要手动开启。</p>
<h2 id="十、dispatch-after"><a href="#十、dispatch-after" class="headerlink" title="十、dispatch_after"></a>十、dispatch_after</h2><p>dispatch_after 其实依赖于定时器的实现，函数内部调用了 dispatch_after_f：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *ctxt, dispatch_function_t func) &#123;  </span><br><span class="line">    uint64_t delta;</span><br><span class="line">    struct _dispatch_after_time_s *datc = NULL;</span><br><span class="line">    dispatch_source_t ds;</span><br><span class="line"></span><br><span class="line">    // 如果延迟为 0，直接调用 dispatch_async</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    if (delta == 0) &#123;</span><br><span class="line">        return dispatch_async_f(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    dispatch_assert(ds);</span><br><span class="line"></span><br><span class="line">    datc = malloc(sizeof(*datc));</span><br><span class="line">    dispatch_assert(datc);</span><br><span class="line">    datc-&gt;datc_ctxt = ctxt;</span><br><span class="line">    datc-&gt;datc_func = func;</span><br><span class="line">    datc-&gt;ds = ds;</span><br><span class="line"></span><br><span class="line">    dispatch_set_context(ds, datc);</span><br><span class="line">    dispatch_source_set_event_handler_f(ds, _dispatch_after_timer_callback);</span><br><span class="line">    dispatch_source_set_timer(ds, when, DISPATCH_TIME_FOREVER, 0);</span><br><span class="line">    dispatch_resume(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将延迟执行的 block 封装在 _dispatch_after_time_s 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。到时以后，执行 _dispatch_after_timer_callback 回调，并取出上下文中的 block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void _dispatch_after_timer_callback(void *ctxt) &#123;  </span><br><span class="line">    struct _dispatch_after_time_s *datc = ctxt;</span><br><span class="line">    _dispatch_client_callout(datc-&gt;datc_ctxt, datc-&gt;datc_func);</span><br><span class="line">    // 清理工作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h2><p>本文主要整理了 GCD 中常见的 API 以及底层的实现原理。</p>
<ol>
<li><p>对于队列来说，需要理解它的数据结构，转发机制，以及底层的线程池模型。</p>
</li>
<li><p>dispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。在 wakeup 方法中，从线程池里取出工作线程（如果没有就新建），然后在工作线程中取出链表头部指向的 block 并执行。</p>
</li>
<li><p>dispatch_sync 的实现略简单一些，它不涉及线程池（因此一般都在当前线程执行），而是利用与线程绑定的信号量来实现串行。分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性（表示在运行的任务数量）为 1，所以以下判断成立：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) &#123;  </span><br><span class="line">    return _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>在 \_dispatch\_barrier\_sync\_f\_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。如果向其它队列同步提交 block，最终进入 \_dispatch\_barrier\_sync\_f\_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。
</code></pre><ol start="4">
<li><p>对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。在调用 signal 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。</p>
</li>
<li><p>dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。</p>
</li>
<li><p>dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。</p>
</li>
<li><p>dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。</p>
</li>
<li><p>dispatch_source 可以用来实现定时器。所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。随后找到最近触发的定时器，调用内核的 select 方法等待。等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。</p>
</li>
<li><p>GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。</p>
</li>
<li><p>dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。</p>
</li>
</ol>
<h2 id="十二、文章"><a href="#十二、文章" class="headerlink" title="十二、文章"></a>十二、文章</h2><p><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解 GCD</a><br><a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a><br><a href="http://stackoverflow.com/questions/7346929/why-do-we-use-builtin-expect-when-a-straightforward-way-is-to-use-if-else" target="_blank" rel="noopener">Why do we use _builtinexpect when a straightforward way is to use if-else</a><br><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/" target="_blank" rel="noopener">Posix线程编程指南(2) 线程私有数据</a><br><a href="http://www.jianshu.com/p/0c050af6c5ee" target="_blank" rel="noopener">选择 GCD 还是 NSTimer？</a><br><a href="https://yq.aliyun.com/articles/17709" target="_blank" rel="noopener">从NSTimer的失效性谈起（二）：关于GCD Timer和libdispatch</a><br><a href="http://blog.csdn.net/u012878842/article/list/4" target="_blank" rel="noopener">变态的libDispatch源码分析</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/09/16/iOS/iOS多线程/GCD深入/">http://yoursite.com/2019/09/16/iOS/iOS多线程/GCD深入/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/16/iOS/iOS多线程/GCD/" class="pre">GCD</a><a href="/2019/09/16/iOS/iOS原理/NSProxy/" class="next">NSProxy</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、知识储备"><span class="toc-text">一、知识储备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-DISPATCH-DECL"><span class="toc-text">1.1 DISPATCH_DECL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-TSD"><span class="toc-text">1.2 TSD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-fastpath-amp-amp-slowpath"><span class="toc-text">1.3 fastpath &amp;&amp; slowpath</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#二、dispatch-queue-t"><span class="toc-text">二、dispatch_queue_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、dispatch-async"><span class="toc-text">二、dispatch_async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、dispatch-sync"><span class="toc-text">三、dispatch_sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、dispatch-semaphore"><span class="toc-text">四、dispatch_semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-dispatch-semaphore-wait"><span class="toc-text">4.1 dispatch_semaphore_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-dispatch-semaphore-signal"><span class="toc-text">4.2 dispatch_semaphore_signal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、dispatch-group"><span class="toc-text">五、dispatch_group</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-dispatch-group-async"><span class="toc-text">5.1 dispatch_group_async</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-dispatch-group-wait"><span class="toc-text">5.2 dispatch_group_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-dispatch-group-notify"><span class="toc-text">5.3 dispatch_group_notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-dispatch-group-leave"><span class="toc-text">5.4 dispatch_group_leave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-dispatch-group-wake"><span class="toc-text">5.5 dispatch_group_wake</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、dispatch-once"><span class="toc-text">六、dispatch_once</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、dispatch-barrier-async"><span class="toc-text">七、dispatch_barrier_async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、dispatch-source"><span class="toc-text">八、dispatch_source</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-dispatch-source-create"><span class="toc-text">8.1 dispatch_source_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-dispatch-source-set-timer"><span class="toc-text">8.2 dispatch_source_set_timer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、dispatch-resume-suspend"><span class="toc-text">九、dispatch_resume/suspend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、dispatch-after"><span class="toc-text">十、dispatch_after</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、总结"><span class="toc-text">十一、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、文章"><span class="toc-text">十二、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/图片处理/">图片处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS音视频/Premultiplied Alpha/">Premultiplied Alpha</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS架构/垃圾代码/">添加垃圾代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/pthread_rwlock_t/">pthread_rwlock_t</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD实现/">GCD实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS多线程/GCD深入/">GCD深入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/iOS/iOS原理/NSProxy/">NSProxy</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS架构/组件化方案/">组件化方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/iOS/iOS原理/iOS 编译过程原理(1)/">iOS 编译过程原理(1)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS音视频/">iOS音视频</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">1</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>