<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> Bitcode（2）		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> Bitcode（2）		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> Bitcode（2）		</h1><div class="post-meta"><a href="/2019/01/11/bitcode-ef-bc-882-ef-bc-89/#comments" class="comment-count"></a><p><span class="date">Jan 11, 2019</span><span><a href="/categories/Xcode/" class="category">Xcode</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/" target="_blank" rel="noopener">http://xelz.info/blog/2018/11/24/all-you-need-to-know-about-bitcode/</a></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>苹果在 WWDC2015 大会上引入了 bitcode，随后在 Xcode7 中添加了在二进制中嵌入 bitcode(Enable Bitcode) 的功能，并且默认设置为开启状态。</p>
<h4 id="什么是-Bitcode"><a href="#什么是-Bitcode" class="headerlink" title="什么是 Bitcode"></a>什么是 Bitcode</h4><p>Bitcode 是由 LLVM 引入的一种中间代码(Intermediate Representation，简称 IR)，它是源代码被编译为二进制机器码过程中的中间表示形态，它既不是源代码，也不是机器码。从代码组织结构上看它比较接近机器码，但是在函数和指令层面使用了很多高级语言的特性。</p>
<p>LLVM 是一套优秀的编译器框架，目前 NDK/Xcode 均采用 LLVM 作为默认的编译器。LLVM 的编译过程可以简单分为 3 个部分:</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-2bf277be7a38c689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>前端(Frontend)负责把各种类型的源代码编译为中间表示，也就是 Bitcode。在 LLVM 体系内，不同的语言有不同的编译器前端，最常见的如 clang 负责 c/c++/oc 的编译，flang 负责 fortran 的编译，swiftc 负责 swift 的编译等等</li>
<li>优化(Optimizer)负责对 Bitcode 进行各种类型的优化，将 bitcode 代码进行一些逻辑等价的转换，使得代码的执行效率更高，体积更小，比如 DeadStrip/SimplifyCFG。</li>
<li>后端(Backend)也叫 CodeGenerator，负责把优化后的 bitcode 编译为指定目标架构的机器码，比如 X86Backend 负责把 bitcode 编译为 x86 指令集的机器码。</li>
</ol>
<p>在这个体系中，不同语言的源代码将会被转化为统一的 bitcode 格式，三个模块可以充分复用，防止重复造轮子。如果要开发一门新的语言 x，只需要造一个 x 语言的前端，将 x 语言的源代码编译为 bitcode，优化和后端的事情完全不用管。同理，如果新的芯片架构问世，则只需要基于 LLVM 重新写一套目标平台的后端，非常方便。</p>
<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>既然 bitcode 是代码的一种表示形式，因此它也会有自己的一套独立的语法，可以通过一个简单的例子来一探究竟，这里以 clang为例，swift 的操作和结果可能稍有不同。</p>
<p>①、先编写一段 c 语言代码(test.c)：</p>
<p>#include &lt;stdio.h&gt;<br>int main(void)<br>{<br>    printf(“hello, world.\n”);<br>    return 0;<br>}</p>
<p>②、通过以下命令可以将源代码编译为 object 文件。</p>
<p>$ clang -c test.c -o test.o<br>$ file test.o<br>test.o: Mach-O 64-bit object x86_64</p>
<p>这个命令同时完成了前端、优化、后端，可以通过 -emit-llvm -c 将前端这一步单独拆出来，这样就可以看到 bitcode 了。</p>
<p>$ clang -emit-llvm -c test.c -o test.bc   # 将源代码编译为 bitcode</p>
<p>$ clang -c test.bc -o test.bc.o  # 将 bitcode 编译为 object</p>
<p>$ clang -emit-llvm -c test.c -o test.bc<br>$ file test.bc<br>test.bc: LLVM bitcode, wrapper x86_64<br>$ clang -c test.bc -o test.bc.o<br>$ file test.bc.o<br>test.bc.o: Mach-O 64-bit object x86_64<br>$ md5 test.bc.o test.o<br>MD5 (test.bc.o) = 9b90026b9c1d3fa0211e106ff921e9bd<br>MD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bd</p>
<p>bitcode 文件使用后缀名 .bc表示。可以看到，将 bitcode 文件作为 clang 的输入，编出的 object 文件跟直接编源代码是相同的。</p>
<p>③、查看 bitcode 文件。</p>
<p>$ hexdump -C test.bc | head<br>00000000  de c0 17 0b 00 00 00 00  14 00 00 00 90 09 00 00  |…………….|<br>00000010  07 00 00 01 42 43 c0 de  35 14 00 00 07 00 00 00  |….BC..5…….|<br>00000020  62 0c 30 24 94 96 a6 a5  f7 d7 7f 4f d3 3e ed df  |b.0$…….O.&gt;..|<br>00000030  bd 6f ff b4 10 05 c8 14  00 00 00 00 21 0c 00 00  |.o……….!…|<br>00000040  58 02 00 00 0b 82 20 00  02 00 00 00 13 00 00 00  |X….. ………|<br>00000050  07 81 23 91 41 c8 04 49  06 10 32 39 92 01 84 0c  |..#.A..I..29….|<br>00000060  25 05 08 19 1e 04 8b 62  80 10 45 02 42 92 0b 42  |%……b..E.B..B|<br>00000070  84 10 32 14 38 08 18 4b  0a 32 42 88 48 90 14 20  |..2.8..K.2B.H.. |<br>00000080  43 46 88 a5 00 19 32 42  e4 48 0e 90 11 22 c4 50  |CF….2B.H…”.P|<br>00000090  41 51 81 8c e1 83 e5 8a  04 21 46 06 51 18 00 00  |AQ…….!F.Q…|</p>
<p>通过 hexdump 可以看出它并非文本文件，全是乱码，这样的文件是很难分析的。其实 LLVM 提供了 llvm-dis/llvm-as 两个工具，用于将 bitcode 在二进制格式和可读的文本格式之间进行相互的转化，但遗憾的是 Xcode 的编译器工具链中并没有附带这个命令，因此需要另寻他法。</p>
<p>④、我们知道通过编译器的 -S 参数可以将源代码编译为文本的 assembly 代码，不进行最后一步 assembly 到机器码的翻译工作，而 assembly 和机器码是等价的两种表示形式，bitcode 同样也是有文本和二进制(bitcode)两种等价表示形式，clang 也为 bitcode 保留了这一特性，可以通过 -emit-llvm -S 将源代码编译为文本格式的 bitcode， 也叫做 LLVM Assembly Language，一般后缀名使用 .ll。</p>
<p>$ clang -emit-llvm -S test.c -o test.ll   # 将源代码编译为 LLVM Assembly</p>
<p>test.ll 可用文本编辑器打开，全部内容：</p>
<p>; ModuleID = ‘test.c’<br>source_filename = “test.c”<br>target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”<br>target triple = “x86_64-apple-macosx10.13.0”</p>
<p>@.str = private unnamed_addr constant [15 x i8] c”hello, world.\0A\00”, align 1</p>
<p>; Function Attrs: noinline nounwind ssp uwtable<br>define i32 @main() #0 {<br>  %1 = alloca i32, align 4<br>  store i32 0, i32<em> %1, align 4<br>  %2 = call i32 (i8</em>, …) @printf(i8<em> getelementptr inbounds ([15 x i8], [15 x i8]</em> @.str, i32 0, i32 0))<br>  ret i32 0<br>}</p>
<p>declare i32 @printf(i8*, …) #1</p>
<p>attributes #0 = { noinline nounwind ssp uwtable “correctly-rounded-divide-sqrt-fp-math”=”false” “disable-tail-calls”=”false” “less-precise-fpmad”=”false” “no-frame-pointer-elim”=”true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=”false” “no-jump-tables”=”false” “no-nans-fp-math”=”false” “no-signed-zeros-fp-math”=”false” “no-trapping-math”=”false” “stack-protector-buffer-size”=”8” “target-cpu”=”penryn” “target-features”=”+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87” “unsafe-fp-math”=”false” “use-soft-float”=”false” }<br>attributes #1 = { “correctly-rounded-divide-sqrt-fp-math”=”false” “disable-tail-calls”=”false” “less-precise-fpmad”=”false” “no-frame-pointer-elim”=”true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=”false” “no-nans-fp-math”=”false” “no-signed-zeros-fp-math”=”false” “no-trapping-math”=”false” “stack-protector-buffer-size”=”8” “target-cpu”=”penryn” “target-features”=”+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87” “unsafe-fp-math”=”false” “use-soft-float”=”false” }</p>
<p>!llvm.module.flags = !{!0}<br>!llvm.ident = !{!1}</p>
<p>!0 = !{i32 1, !”PIC Level”, i32 2}<br>!1 = !{!”Apple LLVM version 9.0.0 (clang-900.0.39.2)”}</p>
<p>这样看上去就很清晰明了了，我们重点关注下函数定义这部分，加了一些注释方便理解。</p>
<p>; 定义全局常量 @.str, 内容初始化为 ‘hello, world.\n\0’<br>@.str = private unnamed_addr constant [15 x i8] c”hello, world.\0A\00”, align 1</p>
<p>; Function Attrs: noinline nounwind optnone ssp uwtable<br>define i32 @main() #0 { ; 定义函数 @main，返回值为i32类型<br>  %1 = alloca i32, align 4 ; 声明变量 %1 = 分配i32的内存空间<br>  store i32 0, i32<em> %1, align 4 ; 将 0 存入 %1 的内存空间<br>  %2 = call i32 (i8</em>, …) @printf(i8<em> getelementptr inbounds ([15 x i8], [15 x i8]</em> @.str, i32 0, i32 0)) ; 调用 @printf 函数，并将 @.str 的地址作为参数<br>  ret i32 0 ; 返回 0<br>}</p>
<p>declare i32 @printf(i8*, …) #1 ; 声明一个外部函数 @printf</p>
<p>这段代码不难阅读， 其含义和逻辑与我们所写的源代码基本一致，只是用了另外一种语法表示出来。因为没有经过优化，函数中的前两条语句其实是多余的，这在之后的优化阶段会被消除(dead_strip)。bitcode 的具体语法在此不做展开，虽然这个例子看起来非常简单易懂，但真实场景中，bitcode 的语法远比这个复杂，有兴趣的同学可以直接阅读 <a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM Language Reference Manual</a>。</p>
<h4 id="Enable-Bitcode"><a href="#Enable-Bitcode" class="headerlink" title="Enable Bitcode"></a>Enable Bitcode</h4><p>在对 bitcode 有了一个直观的认识之后，再来看一下 Apple 围绕 bitcode 做了什么。Xcode 中对 Enable Bitcode 这个配置的解释是 <a href="https://help.apple.com/xcode/mac/10.1/index.html?localePath=en.lproj#/itcaec37c2a6" target="_blank" rel="noopener">Xcode Help</a>：</p>
<blockquote>
<h6 id="Enable-Bitcode-ENABLE-BITCODE"><a href="#Enable-Bitcode-ENABLE-BITCODE" class="headerlink" title="Enable Bitcode (ENABLE_BITCODE)"></a>Enable Bitcode (ENABLE_BITCODE)</h6><p>Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.</p>
</blockquote>
<p>具体展开一下：</p>
<ul>
<li><p>开启此设置将会在支持的平台和架构中开启 bitcode</p>
<ul>
<li>当前支持的平台主要是 iPhoneOS(armv7/arm64)，watchOS 等；</li>
<li>注意不包括 iPhoneSimulator(i386/x86_64) 和 macos，也就是说模拟器架构下不会编出 bitcode。这个限制只是 Xcode 自身的限制，并非编译器的限制，我们使用编译器提供的命令行工具自行操作仍然可以编译出这些架构下的bitcode，本文中的示例就是基于 macos 平台/x86_64 架构。</li>
</ul>
</li>
<li><p>进行 Archive 时，bitcode 会被嵌入到链接后的二进制文件中，用于提交给 App Store</p>
<ul>
<li>Enable Bitcode 设置为 YES 时，从编译日志中可以看出，Archive 时多了一个编译参数 -fembed-bitcode</li>
</ul>
</li>
<li><p>进行其他类型的 Build(非 Archive)时，编译器只会检查是否满足开启 bitcode 的条件，但并不会真正生成 bitcode</p>
<ul>
<li>非 Archive 编译时，Enable Bitcode 将会增加编译参数 -fembed-bitcode-marker， 只是在 object 文件中做了标记，表明可以有 bitcode，但是现在暂时没有带上它。因为本地编译调试时并不需要 bitcode，只有 AppStore 需要这玩意儿，去掉这个不必要的步骤，会加快编译速度。</li>
<li>这就是为什么有的同学在开发 SDK 时，明明开启了 Enable Bitcode，交给客户后客户却说：你的 sdk 里没有bitcode，因为你没有使用 Archive 方式打包。</li>
<li>当然，你可以将 Enable Bitcode 设置为 NO， 然后在 Other Compiler Flags 和 Other Linker Flags 中手动为真机架构添加 -fembed-bitcode 参数，这样任何类型的 Build 都会带上 bitcode。</li>
</ul>
</li>
</ul>
<p>接下来看一下 Enable Bitcode 之后，编译出的文件发生了什么变化， 直接在 clang 的参数中添加 -fembed-bitcode 即可。</p>
<p>$ clang -fembed-bitcode -c test.c -o test_bitcode.o</p>
<p>编译之后可以通过 otool 工具查看 object 文件的结构，此时你需要对 Mach-O 文件有一些基本的了解。</p>
<p>otool -l test_bitcode.o<br>test_bitcode.o:<br>Mach header<br>      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags<br> 0xfeedfacf 16777223          3  0x00           1     4        672 0x00002000<br>Load command 0<br>      cmd LC_SEGMENT_64<br>  cmdsize 552<br>  segname<br>   vmaddr 0x0000000000000000<br>   vmsize 0x0000000000000a88<br>  fileoff 704<br> filesize 2696<br>  maxprot 0x00000007<br> initprot 0x00000007<br>   nsects 6<br>    flags 0x0<br>Section<br>  sectname <strong>bitcode<br>   segname </strong>LLVM<br>      addr 0x0000000000000040<br>      size 0x00000000000009a0<br>    offset 768<br>     align 2^4 (16)<br>    reloff 0<br>    nreloc 0<br>     flags 0x00000000<br> reserved1 0<br> reserved2 0<br>Section<br>  sectname <strong>cmdline<br>   segname </strong>LLVM<br>      addr 0x00000000000009e0<br>      size 0x0000000000000042<br>    offset 3232<br>     align 2^4 (16)<br>    reloff 0<br>    nreloc 0<br>     flags 0x00000000<br> reserved1 0<br> reserved2 0<br>Load command 1<br>      cmd LC_VERSION_MIN_MACOSX<br>  cmdsize 16<br>  version 10.13<br>      sdk n/a<br>Load command 2<br>     cmd LC_SYMTAB<br> cmdsize 24<br>  symoff 3424<br>   nsyms 4<br>  stroff 3488<br> strsize 56<br>Load command 3<br>            cmd LC_DYSYMTAB<br>        cmdsize 80<br>      ilocalsym 0<br>      nlocalsym 2<br>     iextdefsym 2<br>     nextdefsym 1<br>      iundefsym 3<br>      nundefsym 1<br>         tocoff 0<br>           ntoc 0<br>      modtaboff 0<br>        nmodtab 0<br>   extrefsymoff 0<br>    nextrefsyms 0<br> indirectsymoff 0<br>  nindirectsyms 0<br>      extreloff 0<br>        nextrel 0<br>      locreloff 0<br>        nlocrel 0</p>
<p>或者使用 MachOView 软件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9d803def2ae23856.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以发现生成的 object 文件中多了两个 Section，分别是 __LLVM,__bitcode 和 __LLVM,__cmdline，并且 otool 的输出中给出了这两个 section 在 object 文件中的偏移和大小，通过 dd 命令可以很方便地将这两个 Section 提取出来（待验证）</p>
<p>$ dd bs=1 skip=768 count=0x00000000000009a0 if=test_bitcode.o of=test_bitcode.o.bc</p>
<p>$ dd bs=1 skip=3608 count=0x0000000000000042 if=test_bitcode.o of=test_bitcode.o.cmdline</p>
<p>还有一种更便捷的方式，Xcode 提供的 segedit 命令可以直接将指定的 Section 导出，只需要给定 Section 的名字，和上面的命令效果是一样的，并且更为方便。</p>
<p>$ segedit -extract __LLVM __bitcode test_bitcode.o.bc -extract __LLVM __cmdline test_bitcode.o.cmdline test_bitcode.o</p>
<p>$ segedit -extract __LLVM __bitcode test_bitcode.o.bc \<br>>           -extract __LLVM __cmdline test_bitcode.o.cmdline \<br>>           test_bitcode.o</p>
<p>观察导出的文件：</p>
<p>$ file test_bitcode.o.bc<br>test_bitcode.o.bc: LLVM bitcode, wrapper x86_64<br>$ cat test_bitcode.o.cmdline | tr ‘\0’ ‘ ‘<br>-triple x86_64-apple-macosx10.13.0 -emit-obj -disable-llvm-passes<br>$ md5 test.bc test_bitcode.o.bc<br>MD5 (test.bc) = 718d88a109ba9e1a75119b04eac566f8<br>MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828</p>
<p>不难得出结论：</p>
<ul>
<li>object 文件中嵌入的 __LLVM,__bitcode 正是完整的，未经任何加密或者压缩的 bitcode 文件，通过 -fembed-bitcode 参数，clang 把对应的 bitcode 文件整个嵌入到了 object 文件中。</li>
<li>__LLVM,__cmdline 是编译这个文件所用到的参数，如果要通过导出的 bitcode 重新编译这个 object 文件，必须带上这些参数<ul>
<li>导出的参数是 cc1 也就是 clang 中真正”前端”部分的参数(clang 命令其实是整合了各个环节，所以 clang 一个命令可以从源代码编出可执行文件)，所以编译时要带上 -cc1</li>
</ul>
</li>
<li>导出的 bitcode 文件似乎和直接编译的 bitcode 不一样，先留个疑问，后面再研究。</li>
</ul>
<p>首先， 来测试一下导出的 bitcode 文件结合 cmdline 能否编译出正常的 object：</p>
<p>$ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes test_bitcode.o.bc -o test_rebuild.o<br>warning: overriding the module target triple with x86_64-apple-macosx10.14.0<br>1 warning generated.<br>$ file test_rebuild.o<br>test_rebuild.o: Mach-O 64-bit object x86_64<br>$ md5 test.o test_rebuild.o<br>MD5 (test.o) = 9b90026b9c1d3fa0211e106ff921e9bd<br>MD5 (test_rebuild.o) = d647be2f0a5cd4ff96b815aef8af5943</p>
<p>没有任何问题，并且通过内嵌的 bitcode 编译出的 object 文件与直接从源代码编译出来的 object 完全一样！</p>
<p>回到遗留的问题：为什么导出的 bitcode 文件和直接编译的 bitcode 会不一样？明明编出的 object 都是一模一样的！</p>
<p>这是因为二进制的 bitcode 文件中还保存了一些与实际代码无关的 meta 信息。如果能将 bitcode 转换为文本格式，将能更直观地进行对比。前面已经提到，xcode 中并没有附带转换工具，但是我们依然可以通过 clang 来完成这一操作，还记得前面用过的 -emit-llvm -S 吗？</p>
<p>$ clang -emit-llvm -S test_bitcode.o.bc -o test_bitcode.o.ll</p>
<p>神奇吧？输入虽然已经是 bitcode 了，并非源代码，但是 clang 也能”编译”出 LLVM Assembly。其实 clang 内部是先将输入的文件转换成 Module 对象，然后再执行对应的处理：</p>
<ul>
<li>如果输入是源代码，会先进行前端编译，得到一个 Module；</li>
<li>如果输入是 bitcode 或者 LLVM Assembly，那么直接进行 parse 操作，即可得到 Module 对象；</li>
<li>如果输出类型是 LLVM Assembly，将 Module 对象序列化为文本格式；</li>
<li>如果输出类型是 bitcode，则将 Module 对象序列化为二进制格式</li>
</ul>
<p>所以完全可以通过 clang 进行 bitcode 和 LLVM Assembly 的相互转换。</p>
<p>现在，可以对比一下前后两次生成的.ll文件：（待验证）</p>
<p>$ diff test_bitcode.o.ll test.ll</p>
<p>$ diff /Users/cykj/Desktop/Chart/Chart/test_bitcode.o.ll /Users/cykj/Desktop/Chart/Chart/test.ll<br>1c1<br>&lt; ; ModuleID = ‘test_bitcode.o.bc’<br>---<br>> ; ModuleID = ‘test.c’</p>
<p>除了 ModuleID，也就是来源的文件名以外，其余部分完全相同，这也就解决了前面的疑虑。</p>
<p>再来回顾一下，前文提到非 Archive 类型的 build，比如直接 ⌘ + B，即使开启了 bitcode，也不会编出 bitcode，那么会产生什么样的文件呢？通过观察编译日志可以看出 xcode 在此时使用了 -fembed-bitcode-marker 这样一个参数，试一下：</p>
<p>$ clang -fembed-bitcode-marker -c test.c -o test_bitcode_marker.o<br>$ otool -l test_bitcode_marker.o<br>Section<br>  sectname <strong>bitcode<br>   segname </strong>LLVM<br>      addr 0x0000000000000039<br>      size 0x0000000000000001<br>    offset 761<br>     align 2^0 (1)<br>    reloff 0<br>    nreloc 0<br>     flags 0x00000000<br> reserved1 0<br> reserved2 0<br>Section<br>  sectname <strong>cmdline<br>   segname </strong>LLVM<br>      addr 0x000000000000003a<br>      size 0x0000000000000001<br>    offset 762<br>     align 2^0 (1)<br>    reloff 0<br>    nreloc 0<br>     flags 0x00000000<br> reserved1 0<br> reserved2 0<br>$ objdump -s -section=__bitcode test_bitcode_marker.o</p>
<p>test_bitcode_marker.o:    file format Mach-O 64-bit x86-64</p>
<p>Contents of section __bitcode:<br> 0039 00</p>
<p>这样的方式编译出的文件结构与 -fembed-bitcode 的结果是一样的，唯一的区别就是 __LLVM,__bitcode 和 __LLVM,__cmdline 的内容并没有将实际的 bitcode 文件和编译参数嵌入进来，取而代之的一个字节的占位符 0x00</p>
<h4 id="Bitcode-Bundle"><a href="#Bitcode-Bundle" class="headerlink" title="Bitcode Bundle"></a>Bitcode Bundle</h4><p>已经搞清楚了 bitcode 是如何嵌入在 object 文件里的，但是 object 只是编译过程的中间产物，真正运行的代码是多个 object文件经过链接之后的可执行文件，接下来要分析下 object 中嵌入的 bitcode 是如何被链接的：</p>
<p>$ clang test.o -o test  # 链接原始 object</p>
<p>$ clang -fembed-bitcode test_bitcode.o -o test_bitcode # 链接带 bitcode 的object</p>
<p>$ clang test.o -o test<br>$ ./test<br>hello, world.<br>$ clang -fembed-bitcode test_bitcode.o -o test_bitcode<br>$ ./test_bitcode<br>hello, world.<br>$ otool -l test_bitcode<br>Section<br>  sectname <strong>bundle<br>   segname </strong>LLVM<br>      addr 0x0000000100002000<br>      size 0x0000000000001264<br>    offset 8192<br>     align 2^0 (1)<br>    reloff 0<br>    nreloc 0<br>     flags 0x00000000<br> reserved1 0<br> reserved2 0</p>
<p>object 中的 __LLVM,__bitcode 和 __LLVM,__cmdline不见了，取而代之的是一个 __LLVM,__bundle 的 Section， 通过名字可以基本推断出 object 中的 bitcode 被打包在了一起，把它从可执行文件中 dump 出来一探究竟：</p>
<p>$ segedit -extract __LLVM __bundle bundle test_bitcode<br>$ file bundle<br>bundle: xar archive version 1, SHA-1 checksum</p>
<p>这个 bundle 文件是一个 xar 格式的压缩包，xar 格式包含了一个 xml 格式的文件头(TOC)，里面用于存放各种文件的基本属性以及一些附加附加信息，可以通过 xar 命令查看并解压：</p>
<p>$ xar -d toc.xml -f bundle # 导出文件头</p>
<p>$ xar -x -C bundle.extract -f bundle # 解压文件</p>
<p>$ xar -d toc.xml -f bundle<br>$ mkdir bundle.extract<br>$ xar -x -C bundle.extract -f bundle<br>$ ls bundle.extract<br>1<br>$ file bundle.extract/1<br>bundle.extract/1: LLVM bitcode, wrapper x86_64<br>$ md5 bundle.extract/1 test_bitcode.o.bc<br>MD5 (bundle.extract/1) = 1b3bd72eb7f380cfd6c6528674d90828<br>MD5 (test_bitcode.o.bc) = 1b3bd72eb7f380cfd6c6528674d90828</p>
<p>查看导出的 toc.xml</p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<xar><br> <subdoc subdoc_name="Ld"><br>  <version>1.0</version><br>  <architecture>x86_64</architecture><br>  <platform>MacOSX</platform><br>  <sdkversion>10.13.0</sdkversion><br>  <dylibs><br>   <lib>{SDKPATH}/usr/lib/libSystem.B.dylib</lib><br>  </dylibs><br>  <link-options><br>   <option>-execute</option><br>   <option>-macosx_version_min</option><br>   <option>10.13.0</option><br>   <option>-e</option><br>   <option>_main</option><br>   <option>-executable_path</option><br>   <option>test_bitcode</option><br>  </link-options><br> </subdoc><br> <toc><br>  <checksum style="sha1"><br>   <size>20</size><br>   <offset>0</offset><br>  </checksum><br>  <creation-time>2019-01-11T10:21:54</creation-time><br>  <file id="1"><br>   <name>1</name><br>   <type>file</type><br>   <data><br>    <archived-checksum style="sha1">d64be6fc7a9551555ccb4e8a78a87864cbef40b7</archived-checksum><br>    <extracted-checksum style="sha1">d64be6fc7a9551555ccb4e8a78a87864cbef40b7</extracted-checksum><br>    <size>2464</size><br>    <offset>20</offset><br>    <encoding style="application/octet-stream"><br>    <length>2464</length><br>   </encoding></data><br>   <file-type>Bitcode</file-type><br>   <clang><br>    <cmd>-triple</cmd><br>    <cmd>x86_64-apple-macosx10.13.0</cmd><br>    <cmd>-emit-obj</cmd><br>    <cmd>-disable-llvm-passes</cmd><br>   </clang><br>  </file><br> </toc><br></xar>

<p>header 的结构非常清晰，内容基本包含这些：</p>
<ul>
<li>ld 的基本参数，我们链接时使用的是 clang，实际上 clang 内部调用了 ld，这里记录的是 ld的参数<ul>
<li>version: bitcode bundle 的版本号</li>
<li>architecture: 目标架构</li>
<li>platform: 目标平台</li>
<li>sdkversion: sdk版本</li>
<li>dylibs: 链接的动态库</li>
<li>link-options: 其他链接参数</li>
</ul>
</li>
<li>文件目录<ul>
<li>checksum类型</li>
<li>创建时间</li>
<li>每个文件的信息<ul>
<li>文件名，这里并非原始文件名，而是按照链接时输入的顺序被重命名为数字序号</li>
<li>基本属性，包括 checksum、偏移、大小等</li>
<li>文件类型，一般是 Bitcode，还有两种特殊类型，Object 以及 Bundle</li>
<li>编译器类型(clang/swift)及编译参数，这部分就是 object 文件中 __LLVM,__cmdline 的内容</li>
</ul>
</li>
<li>下一个文件的信息(如有)</li>
<li>重复</li>
</ul>
</li>
</ul>
<p>从 bundle 中解压出来的文件，就是 object 中嵌入的 bitcode，通过 MD5 对比可以看出链接时对 bitcode 文件自身没有做任何处理。可以注意到，用于编译各个 bitcode 文件的参数(cmdline)被放进了 TOC 中文件描述的区域，而 TOC 中多出了一个部分用于存放链接时所需要的信息和必要的参数，有了这些信息， 我们不难通过 bitcode 重新编译，并链接出一个新的可执行文件：</p>
<p># 首先根据文件目录，将解压出的每一个bitcode文件编译为object<br>$ clang -cc1 -triple x86_64-apple-macosx10.14.0 -emit-obj -disable-llvm-passes bundle.extract/1 -o bundle.extract/1.o -x ir<br># 由于解压出的文件没有后缀名，clang无法判断输入文件的格式，因此使用 -x ir 强制指定输入文件为ir格式<br># 也可以将其重命名为1.bc，这样就不用指定-x ir</p>
<p># 根据toc.xml中提供的链接参数，将所有object文件链接为可执行文件，本例中只有一个文件<br>$ ld \<br>    -arch x86_64 <code># architecture</code> \<br>    -syslibroot `xcrun –show-sdk-path –sdk macosx` <code># platform</code> \<br>    -sdk_version 10.14.0 <code># sdkversion</code> \<br>    -lSystem <code># dylibs</code> \<br>    -execute <code># link-options</code> \<br>    -macosx_version_min 10.14.0 <code># link-options</code> \<br>    -e _main <code># link-options</code> \<br>    -executable_path test <code># link-options</code> \<br>    -o test_rebuild <code># 输出文件</code> \<br>    bundle.extract/1.o <code># 输入文件</code><br>$ ./test_rebuild<br>hello, world.<br>$ md5 test_rebuild test<br>MD5 (test_rebuild) = f4786288582decf2b8a1accb1aaa4a3c<br>MD5 (test) = f4786288582decf2b8a1accb1aaa4a3c</p>
<p>看！我们成功利用 bitcode 重新编了一份一模一样的可执行文件出来。</p>
<p>现在可以理解，为什么苹果要强推 bitcode 了吧？开发者把 bitcode 提交到 iTunes Connect 之后，如果苹果发布了使用新芯片的 iPhone，支持更高效的指令，开发者不需要做任何操作，iTunes Connect 自己就可以编译出针对新产品优化过的 app 并通过 App Store 分发给用户，不需要开发者自己重新打包上架，这样一来苹果的商店生态就不需要依赖开发者的积极性了。</p>
<h4 id="使用-Bitcode-导出-ipa"><a href="#使用-Bitcode-导出-ipa" class="headerlink" title="使用 Bitcode 导出 ipa"></a>使用 Bitcode 导出 ipa</h4><p>前面已经提到，如果要以 bitcode 方式上传 app，必须在开启 bitcode 的状态下，进行 Archive 打包，才会得到带有 bitcode 的 app。大部分 app 都会依赖一堆第三方 sdk，如果此时项目里依赖的某一个或者几个 sdk 没有开启 bitcode，那么很遗憾，Xcode 会拒绝编译并给出类似这样的提示：</p>
<blockquote>
<p>ld: ‘name_of_the_library_or_framework’ does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target.</p>
<p>ld: bitcode bundle could not be generated because ‘name_of_the_library_or_framework’ was built without full bitcode.</p>
</blockquote>
<p>第一种提示表示这个第三方库完全没有开启 bitcode，而第二种提示表示它只有 bitcode-marker，也就是说它的开发者虽然在工程配置中设置了 Enable Bitcode 为 YES，但并没有以 Archive 方式编译，可能只是 ⌘ + B，然后顺手把 Products 拷贝出来交付了。</p>
<p>遇到这种问题，也需要分两种情况来看：</p>
<ul>
<li>如果这个库是在本地编译的， 比如自己项目里或者子项目里的 target，或者通过 Pods 引入了源代码，那么这个 target 一定没有开启 bitcode，在工程中找到这个 target 的 Build Settings 把 Enable Bitcode 置为 YES 即可；</li>
<li>但如果是第三方提供的二进制库文件，则需要联系 sdk 的提供方确认是否能提供带 bitcode 的版本，否则只能关闭自己项目中的 bitcode。这也是 bitcode 时至今日都没有得到大面积应用的最大障阻碍。</li>
</ul>
<p>当使用 Archive 方式打包出带有 bitcode 的包时，你会发现这个包里的二进制文件比没有开启 bitcode 时大出了许多，多出来的其实就是 bitcode 的体积，并且 bitcode 的体积，一般要比二进制文件本身还要大出许多。</p>
<p>$ ls -al test.o test_bitcode.o test.bc<br>-rw-r–r–  1 xelz  staff  2848 12 19 18:42 test.bc<br>-rw-r--r--@ 1 xelz  staff   784 12 19 18:24 test.o<br>-rw-r--r--@ 1 xelz  staff  3920 12 19 18:59 test_bitcode.o<br>$ ls -al test test_bitcode<br>-rwxr-xr-x@ 1 xelz  staff   8432 12 19 21:38 test<br>-rwxr-xr-x@ 1 xelz  staff  16624 12 19 20:50 test_bitcode</p>
<p>当然，这部分内容并不会导致用户下载到的 APP 变大，因为用户下载到的代码中只会有机器码，不会包含 bitcode。有的项目开启 bitcode 之后会发现二进制的体积增大到超出了苹果对<a href="https://help.apple.com/app-store-connect/#/dev611e0a21f" target="_blank" rel="noopener">二进制体积的限制</a>，但是完全不用担心，苹果的限制只是针对<strong>TEXT 段，而嵌入的 bitcode 是存储在单独的 </strong>LLVM 段，不在苹果的限制范围内。</p>
<p>打包出带有 bitcode 的 xcarchive 之后，可以导出 Development IPA 进行上线前的最终测试，或者上传到 App Store Connect进行提审上架。进行此类操作时会发现 Xcode Organizer 中多出了 bitcode 相关的选项：</p>
<ul>
<li><p>导出 Development 版本时，可以勾选 Rebuild from Bitcode，这时导出会变的很慢，因为 Xcode 在后台通过 bitcode 重新编译代码，这样导出的 ipa 最接近最终用户从 AppStore 下载的版本，为什么说是接近呢，因为苹果使用的编译器版本很可能和本地 Xcode 不一样，并且苹果可能在编译时增加额外的优化步骤，这些都会导致苹果编译后的二进制文件跟本地编译的版本产生差异。而如果不勾选此选项，则会直接使用 Archive 时编译出的二进制代码，并把 bitcode 从二进制中去除以减小体积。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-dd76d4b61f40c4bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
<li><p>导出 Store 版本或者直接进行上传时，默认会勾选 Include bitcode for iOS content，如果不勾选，则跟前面类似，将会去除内嵌的 bitcode，直接使用本地编译的二进制代码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9769b90727879ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>勾选后生成的 ipa 中将会只包含 bitcode，这个 ipa 是无法重签后安装到设备上进行测试的，因为里面没有任何可执行代码：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f5315841df4156cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><strong>TEXT 和 </strong>DATA 等跟已编译好的二进制相关的内容会被全部去除，但是会保留 __LINKEDIT 中的部分信息，其中最重要的就是 LC_UUID，用于在重编之后能跟原始的符号文件对应起来，如果用户下载经过 AppStore 重编之后的 app 发生了Crash，得到的 backtrace 地址是跟本地编译的版本对应不起来的，需要结合 UUID 和从 App Store Connect 下载的dSYM 文件才能得到符号化的 crash 信息。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7a7a5d2df3e7e1ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
</li>
</ul>
<p>Thread 0 name:  Dispatch queue: com.apple.main-thread<br>Thread 0 Crashed:<br>0   libsystem_kernel.dylib            0x23269c84 __pthread_kill + 8<br>1   libsystem_pthread.dylib           0x2330bb46 pthread_kill + 62<br>2   libsystem_c.dylib                 0x232000c4 abort + 108<br>3   libc++abi.dylib                   0x22d7a7dc __cxa_bad_cast + 0<br>4   libc++abi.dylib                   0x22d936a0 default_unexpected_handler() + 0<br>5   libobjc.A.dylib                   0x22d9f098 _objc_terminate() + 192<br>6   libc++abi.dylib                   0x22d90e16 std::<strong>terminate(void (<em>)()) + 78<br>7   libc++abi.dylib                   0x22d905f4 __cxxabiv1::exception_cleanup_func(_Unwind_Reason_Code, _Unwind_Exception</em>) + 0<br>8   libobjc.A.dylib                   0x22d9eed2 objc_exception_throw + 250<br>9   CoreFoundation                    0x234e831e -[</strong>NSArrayI objectAtIndex:] + 186<br>10  test                              0x000791f2 __hidden#5_ (__hidden#43_:35)<br>11  libdispatch.dylib                 0x2316fdd6 _dispatch_call_block_and_release + 10<br>12  libdispatch.dylib                 0x231794e6 _dispatch_after_timer_callback + 66<br>13  libdispatch.dylib                 0x2316fdc2 _dispatch_client_callout + 22<br>14  libdispatch.dylib                 0x231826d2 _dispatch_source_latch_and_call + 2042<br>15  libdispatch.dylib                 0x23171d16 _dispatch_source_invoke + 738<br>16  libdispatch.dylib                 0x231741fe _dispatch_main_queue_callback_4CF + 394<br>17  CoreFoundation                    0x23594fc4 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + 8<br>18  CoreFoundation                    0x235934be __CFRunLoopRun + 1590<br>19  CoreFoundation                    0x234e5bb8 CFRunLoopRunSpecific + 516<br>20  CoreFoundation                    0x234e59ac CFRunLoopRunInMode + 108<br>21  GraphicsServices                  0x2475faf8 GSEventRunModal + 160<br>22  UIKit                             0x277d1fb4 UIApplicationMain + 144<br>23  test                              0x000797de main (__hidden#317_:14)<br>24  libdyld.dylib                     0x23198872 start + 2</p>
<p>----------------------------------------------------------------------<br> File: /Users/Breeze/Desktop/crash/test.app.dSYM/Contents/Resources/DWARF/test (armv7)<br>----------------------------------------------------------------------<br>.debug_info contents:</p>
<p>0x00000000: Compile Unit: length = 0x00000073  version = 0x0002  abbr_offset = 0x00000000  addr_size = 0x04  (next CU at 0x00000077)</p>
<p>0x0000000b: TAG_compile_unit [1] *<br>             AT_producer( “__hidden#30_” )<br>             AT_language( DW_LANG_ObjC )<br>             AT_name( “__hidden#43_” )<br>             AT_stmt_list( 0x00000000 )<br>             AT_comp_dir( “__hidden#41_“ )<br>             AT_APPLE_optimized( 0x01 )<br>             AT_APPLE_major_runtime_vers( 0x02 )<br>             AT_low_pc( 0x0000a0b0 )<br>             AT_high_pc( 0x0000a206 )</p>
<p>0x00000028:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a0b0 )<br>                 AT_high_pc( 0x0000a154 )<br>                 AT_name( “__hidden#45_” )</p>
<p>0x00000035:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a154 )<br>                 AT_high_pc( 0x0000a166 )<br>                 AT_name( “__hidden#1_” )</p>
<p>0x00000042:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a168 )<br>                 AT_high_pc( 0x0000a16e )<br>                 AT_name( “__hidden#2_” )</p>
<p>0x0000004f:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a170 )<br>                 AT_high_pc( 0x0000a176 )<br>                 AT_name( “__hidden#3_” )</p>
<p>0x0000005c:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a178 )<br>                 AT_high_pc( 0x0000a1a4 )<br>                 AT_name( “__hidden#44_” )</p>
<p>0x00000069:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a1a4 )<br>                 AT_high_pc( 0x0000a206 )<br>                 AT_name( “__hidden#42_” )</p>
<p>0x00000076:     NULL</p>
<p>0x00000077: Compile Unit: length = 0x000000db  version = 0x0002  abbr_offset = 0x00000000  addr_size = 0x04  (next CU at 0x00000156)</p>
<p>0x00000082: TAG_compile_unit [1] *<br>             AT_producer( “__hidden#30_” )<br>             AT_language( DW_LANG_ObjC )<br>             AT_name( “__hidden#301_” )<br>             AT_stmt_list( 0x000000bf )<br>             AT_comp_dir( “__hidden#41_“ )<br>             AT_APPLE_optimized( 0x01 )<br>             AT_APPLE_major_runtime_vers( 0x02 )<br>             AT_low_pc( 0x0000a208 )<br>             AT_high_pc( 0x0000a796 )</p>
<p>0x0000009f:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a208 )<br>                 AT_high_pc( 0x0000a20c )<br>                 AT_name( “__hidden#315_” )</p>
<p>0x000000ac:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a20c )<br>                 AT_high_pc( 0x0000a20e )<br>                 AT_name( “__hidden#314_” )</p>
<p>0x000000b9:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a210 )<br>                 AT_high_pc( 0x0000a212 )<br>                 AT_name( “__hidden#313_” )</p>
<p>0x000000c6:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a214 )<br>                 AT_high_pc( 0x0000a216 )<br>                 AT_name( “__hidden#312_” )</p>
<p>0x000000d3:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a218 )<br>                 AT_high_pc( 0x0000a21a )<br>                 AT_name( “__hidden#311_” )</p>
<p>0x000000e0:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a21c )<br>                 AT_high_pc( 0x0000a22c )<br>                 AT_name( “__hidden#310_” )</p>
<p>0x000000ed:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a22c )<br>                 AT_high_pc( 0x0000a2a2 )<br>                 AT_name( “__hidden#309_” )</p>
<p>0x000000fa:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a2a4 )<br>                 AT_high_pc( 0x0000a372 )<br>                 AT_name( “__hidden#308_” )</p>
<p>0x00000107:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a374 )<br>                 AT_high_pc( 0x0000a5b6 )<br>                 AT_name( “__hidden#307_” )</p>
<p>0x00000114:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a5b8 )<br>                 AT_high_pc( 0x0000a65c )<br>                 AT_name( “__hidden#306_” )</p>
<p>0x00000121:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a65c )<br>                 AT_high_pc( 0x0000a702 )<br>                 AT_name( “__hidden#305_” )</p>
<p>0x0000012e:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a704 )<br>                 AT_high_pc( 0x0000a714 )<br>                 AT_name( “__hidden#304_” )</p>
<p>0x0000013b:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a714 )<br>                 AT_high_pc( 0x0000a73a )<br>                 AT_name( “__hidden#302_” )</p>
<p>0x00000148:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a73c )<br>                 AT_high_pc( 0x0000a796 )<br>                 AT_name( “__hidden#300_” )</p>
<p>0x00000155:     NULL</p>
<p>0x00000156: Compile Unit: length = 0x00000032  version = 0x0002  abbr_offset = 0x00000000  addr_size = 0x04  (next CU at 0x0000018c)</p>
<p>0x00000161: TAG_compile_unit [1] *<br>             AT_producer( “__hidden#30_” )<br>             AT_language( DW_LANG_ObjC )<br>             AT_name( “__hidden#317_” )<br>             AT_stmt_list( 0x00000320 )<br>             AT_comp_dir( “__hidden#41_“ )<br>             AT_APPLE_optimized( 0x01 )<br>             AT_APPLE_major_runtime_vers( 0x02 )<br>             AT_low_pc( 0x0000a798 )<br>             AT_high_pc( 0x0000a7f4 )</p>
<p>0x0000017e:     TAG_subprogram [2]<br>                 AT_low_pc( 0x0000a798 )<br>                 AT_high_pc( 0x0000a7f4 )<br>                 AT_name( “__hidden#316_” )</p>
<p>0x0000018b:     NULL</p>
<h4 id="bitcode-不是-bytecode"><a href="#bitcode-不是-bytecode" class="headerlink" title="bitcode 不是 bytecode"></a>bitcode 不是 bytecode</h4><p>bitcode 不能翻译为字节码(bytecode)，显然从字面上看这两个词代表的含义并不等同：字节码是按照字节存取的，一般其控制代码的最小宽度是一个字节(也即 8 个bits)，而 bitcode 是按位(bit)存取，最大化利用空间。比如用 bitcode 中使用 6-bit characters来编码只包含字母/数字的字符串。</p>
<p>‘a’ .. ‘z’ —  0 .. 25 —&gt; 00 0000 .. 01 1001<br>‘A’ .. ‘Z’ — 26 .. 51 —&gt; 01 1010 .. 11 0011<br>‘0’ .. ‘9’ — 52 .. 61 —&gt; 11 0100 .. 11 1101<br>       ‘.’ --- 62       —&gt; 11 1110<br>       ‘_’ — 63       —&gt; 11 1111</p>
<p>在这种编码模式下，4 字节的字符串 abcd只用 3 个字节就可以表示</p>
<p>  char:     a   |    b   |    c   |    d<br>binary: 00 00 00|00|00 01|00 00|10|00 00 11<br>   hex:     00     |     10    |    83</p>
<p>完整的编码格式可以参考官方文档<a href="http://llvm.org/docs/BitCodeFormat.html" target="_blank" rel="noopener">LLVM Bitcode File Format</a></p>
<h4 id="bitcode-的兼容性"><a href="#bitcode-的兼容性" class="headerlink" title="bitcode 的兼容性"></a>bitcode 的兼容性</h4><p>bitcode 的格式目前是一直在变化的，且无法向前兼容，举例来说 Xcode8 的编译器无法读取并解析 xcode9 产生的 bitcode。</p>
<p>另外苹果的 bitcode 格式与社区版 LLVM 的 bitcode 有一定差异，但苹果并不会及时开源 Xcode 最新版编译器的代码，所以如果你使用第三方基于社区版 LLVM 制作的编译器进行开发，不要尝试开启并提交 bitcode 到 App Store Connect，否则会因为App Store Connect 解析不了你的 bitcode 而被拒。</p>
<h4 id="bitcode-不是架构无关代码"><a href="#bitcode-不是架构无关代码" class="headerlink" title="bitcode 不是架构无关代码"></a>bitcode 不是架构无关代码</h4><p>如果一个 app 同时要支持 armv7 和 arm64 两种架构，那么同一个源代码文件将会被编译出两份 bitcode，也就是说，在一开始介绍 LLVM 的那张图中，并不是代表同一份 bitcode 代码可以直接被编译为不同目标机器的机器码。</p>
<p>LLVM 只是统一了中间语言的结构和语法格式，但不能像 Java 那样，Compile Once &amp; Run Everywhere。</p>
<h4 id="如何判断是否开启-bitcode"><a href="#如何判断是否开启-bitcode" class="headerlink" title="如何判断是否开启 bitcode"></a>如何判断是否开启 bitcode</h4><p>可以通过 otool 检查二进制文件，网上有很多类似这样的方法：</p>
<p>otool -arch armv7 -l xxxx.a | grep __LLVM | wc -l</p>
<p>通过判断是否包含 <strong>LLVM 或者关键字来判断是否支持 bitcode，其实这种方式是完全错误的，通过前面的测试可以知道，这种方式区分不了 bitcode 和 bitcode-marker，确定是否包含 bitcode，还需要检查 otool 输出中 </strong>LLVM Segment 的长度，如果长度只有 1 个字节，则并不能代表真正开启了 bitcode：</p>
<p>$ otool -l test_bitcode.o | grep -A 2  __LLVM | grep size<br>      size 0x0000000000000b10<br>      size 0x0000000000000042<br>$ otool -l test_bitcode_marker.o | grep -A 2  __LLVM | grep size<br>      size 0x0000000000000001<br>      size 0x0000000000000001</p>
<h4 id="bitcode-是否能反编译出源代码"><a href="#bitcode-是否能反编译出源代码" class="headerlink" title="bitcode 是否能反编译出源代码"></a>bitcode 是否能反编译出源代码</h4><p>从科学严谨的角度来说，无法给出确定的答案，但是这个问题跟”二进制文件是否能反编译出源代码”是一样的道理。编译是一个将源代码一层一层不断低级化的过程，每一层都可能会丢失一些特性，产生不可逆的转换，把源代码编译为 bitcode 或是二进制机器码是五十步之于百步的关系。在通常情况下，反编译 bitcode 跟反编译二进制文件比要相对容易一些，但通过 bitcode 反编译出和源代码语义完全相同的代码，也是几乎不可能的。</p>
<p>另外，从安全的角度考虑，Xcode 引入了  Symbol Hiding 和 Debug info Striping 机制，在链接时，bitcode 中所有非导出符号均被隐藏，取而代之的是 __hidden#0_ 或者 __ir_hidden#1_ 这样的形式，debug 信息也只保留了 line-table，所有跟文件路径、标识符、导出符号等相关的信息全部都从 bitcode 中移除，相当于做了一层混淆，防止源代码级别的信息泄露，可谓是煞费苦心。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/01/11/bitcode-ef-bc-882-ef-bc-89/">http://yoursite.com/2019/01/11/bitcode-ef-bc-882-ef-bc-89/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/01/15/e7-ba-bf-e7-a8-8bcall-stack-e7-9a-84-e6-8d-95-e8-8e-b7-e5-92-8c-e8-a7-a3-e6-9e-90/" class="pre"> 线程 Call Stack 的捕获和解析		</a><a href="/2019/01/11/bitcode/" class="next"> Bitcode（1）		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是-Bitcode"><span class="toc-text">什么是 Bitcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初探"><span class="toc-text">初探</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enable-Bitcode"><span class="toc-text">Enable Bitcode</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Enable-Bitcode-ENABLE-BITCODE"><span class="toc-text">Enable Bitcode (ENABLE_BITCODE)</span></a></li></ol></li></ol><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitcode-Bundle"><span class="toc-text">Bitcode Bundle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-Bitcode-导出-ipa"><span class="toc-text">使用 Bitcode 导出 ipa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitcode-不是-bytecode"><span class="toc-text">bitcode 不是 bytecode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitcode-的兼容性"><span class="toc-text">bitcode 的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitcode-不是架构无关代码"><span class="toc-text">bitcode 不是架构无关代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何判断是否开启-bitcode"><span class="toc-text">如何判断是否开启 bitcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitcode-是否能反编译出源代码"><span class="toc-text">bitcode 是否能反编译出源代码</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>