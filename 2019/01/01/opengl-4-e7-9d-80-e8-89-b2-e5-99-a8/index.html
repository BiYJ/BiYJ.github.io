<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> OpenGL - 4 着色器		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> OpenGL - 4 着色器		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> OpenGL - 4 着色器		</h1><div class="post-meta"><a href="/2019/01/01/opengl-4-e7-9d-80-e8-89-b2-e5-99-a8/#comments" class="comment-count"></a><p><span class="date">Jan 01, 2019</span><span><a href="/categories/OPENGL/" class="category">OPENGL</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>在 <a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">Hello Triangle </a>教程中提到，着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p>
<p>前面的教程里我们简要地触及了一点着色器的皮毛，并了解了如何恰当地使用它们。现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。</p>
<h4 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h4><p>着色器是使用一种叫 GLSL 的类 C 语言写成的。GLSL 是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>
<p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform 和 main 函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是 uniform 也不用担心，我们后面会进行讲解。</p>
<p>一个典型的着色器有下面的结构：</p>
<p>#version version_number<br>in type in_variable_name;<br>in type in_variable_name;</p>
<p>out type out_variable_name;</p>
<p>uniform type uniform_name;</p>
<p>int main()<br>{<br>  // 处理输入并进行一些图形操作<br>  …<br>  // 输出处理过的结果到输出变量<br>  out_variable_name = weird_stuff_we_processed;<br>}</p>
<p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL 确保至少有 16 个包含 4 分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS 来获取具体的上限：</p>
<p>int nrAttributes;<br>glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);<br>std::cout &lt;&lt; “Maximum nr of vertex attributes supported: “ &lt;&lt; nrAttributes &lt;&lt; std::endl;</p>
<p>通常情况下它至少会返回 16 个，大部分情况下是够用了。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>和其他编程语言一样，GLSL 有数据类型可以来指定变量的种类。GLSL 中包含 C 等其它语言大部分的默认基础数据类型：int、float、double、uint 和 bool。GLSL 也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)，其中矩阵我们会在之后的教程里再讨论。</p>
<h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>GLSL 中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n 代表分量的数量）：</p>
<p>类型</p>
<p>含义</p>
<p>vecn</p>
<p>包含 n 个 float 分量的默认向量</p>
<p>bvecn</p>
<p>包含 n 个 bool 分量的向量</p>
<p>ivecn</p>
<p>包含 n 个 int 分量的向量</p>
<p>uvecn</p>
<p>包含 n 个 unsigned int 分量的向量</p>
<p>dvecn</p>
<p>包含 n 个 double 分量的向量</p>
<p>大多数时候我们使用 vecn，因为 float 足够满足大多数要求了。</p>
<p>一个向量的分量可以通过 vec.x 这种方式获取，这里 x 是指这个向量的第一个分量。你可以分别使用 .x、.y、.z 和 .w 来获取它们的第1、2、3、4个分量。GLSL 也允许你对颜色使用 rgba，或是对纹理坐标使用 stpq 访问相同的分量。</p>
<p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p>
<p>vec2 someVec;<br>vec4 differentVec = someVec.xyxx;<br>vec3 anotherVec = differentVec.zyw;<br>vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</p>
<p>你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个 vec2 向量中去获取 .z 元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量：</p>
<p>vec2 vect = vec2(0.5, 0.7);<br>vec4 result = vec4(vect, 0.0, 0.0);<br>vec4 otherResult = vec4(result.xyz, 1.0);</p>
<p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。学完教程你会看到很多新颖的管理向量的例子。</p>
<h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><p>虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL 定义了 in 和 out 关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p>
<p>顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用 location 这一元数据指定输入变量，这样我们才可以在 CPU 上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的 layout 标识，这样我们才能把它链接到顶点数据。</p>
<p>你也可以忽略 layout (location = 0) 标识符，通过在 OpenGL 代码中使用glGetAttribLocation 查询属性位置值(Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你和 OpenGL 的工作量。</p>
<p>另一个例外是片段着色器，它需要一个 vec4 颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL 会把你的物体渲染为黑色（或白色）。</p>
<p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL 就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</p>
<p><strong>顶点着色器</strong></p>
<p>#version 330 core<br>layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0</p>
<p>out vec4 vertexColor; // 为片段着色器指定一个颜色输出<br>void main()<br>{<br>    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数<br>    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色<br>}</p>
<p><strong>片段着色器</strong></p>
<p>#version 330 core<br>out vec4 FragColor;</p>
<p>in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）<br>void main()<br>{<br>    FragColor = vertexColor;<br>}</p>
<p>你可以看到我们在顶点着色器中声明了一个 vertexColor 变量作为 vec4 输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的 vertexColor 就和顶点着色器中的 vertexColor 链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。下面的图片展示了输出结果：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/05/shaders.png" alt></p>
<p>完成了！我们成功地从顶点着色器向片段着色器发送数据。让我们更上一层楼，看看能否从应用程序中直接给片段着色器发送一个颜色！</p>
<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>Uniform 是一种从 CPU 中的应用向 GPU 中的着色器发送数据的方式，但 uniform 和顶点属性有些不同。首先，uniform 是全局的(Global)。全局意味着 uniform 变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p>我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色：</p>
<p>#version 330 core<br>out vec4 FragColor;</p>
<p>uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量<br>void main()<br>{<br>    FragColor = ourColor;<br>}</p>
<p>我们在片段着色器中声明了一个 uniform vec4 的 ourColor，并把片段着色器的输出颜色设置为 uniform 值的内容。因为 uniform 是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个 uniform，所以我们不用在那里定义它。</p>
<p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p>
<p>这个 uniform 现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中 uniform 属性的索引/位置值。当我们得到 uniform 的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p>
<p>float timeValue = glfwGetTime();<br>float greenValue = (sin(timeValue) / 2.0f) + 0.5f;<br>int vertexColorLocation = glGetUniformLocation(shaderProgram, “ourColor”);<br>glUseProgram(shaderProgram);<br>glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);</p>
<p>首先我们通过 glfwGetTime() 获取运行的秒数。然后我们使用sin函数让颜色在 0.0 到 1.0 之间改变，最后将结果储存到 greenValue里。</p>
<p>接着，我们用 glGetUniformLocation 查询 uniform ourColor 的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果 glGetUniformLocation 返回 -1 就代表没有找到这个位置值。最后，我们可以通过 glUniform4f函数设置 uniform 值。注意，查询 uniform 地址不要求你之前使用过着色器程序，但是更新一个 uniform 之前你必须先使用程序（调用 glUseProgram)，因为它是在当前激活的着色器程序中设置 uniform 的。</p>
<p>因为 OpenGL 在其核心是一个 C 库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform 是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p>
<p>后缀</p>
<p>含义</p>
<p>f</p>
<p>函数需要一个float作为它的值</p>
<p>i</p>
<p>函数需要一个int作为它的值</p>
<p>ui</p>
<p>函数需要一个unsigned int作为它的值</p>
<p>3f</p>
<p>函数需要3个float作为它的值</p>
<p>fv</p>
<p>函数需要一个float向量/数组作为它的值</p>
<p>每当你打算配置一个 OpenGL 的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定 uniform 的 4 个 float 值，所以我们通过 glUniform4f 传递我们的数据（注意，我们也可以使用 fv 版本）。</p>
<p>现在你知道如何设置uniform变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的每一次迭代中（所以他会逐帧改变）更新这个 uniform，否则三角形就不会改变颜色。下面我们就计算greenValue然后每个渲染迭代都更新这个 uniform：</p>
<p>while(!glfwWindowShouldClose(window))<br>{<br>    // 输入<br>    processInput(window);</p>
<pre><code>// 渲染
// 清除颜色缓冲
glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
glClear(GL\_COLOR\_BUFFER_BIT);

// 记得激活着色器
glUseProgram(shaderProgram);

// 更新uniform颜色
float timeValue = glfwGetTime();
float greenValue = sin(timeValue) / 2.0f + 0.5f;
int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);
glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);

// 绘制三角形
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);

// 交换缓冲并查询IO事件
glfwSwapBuffers(window);
glfwPollEvents();
</code></pre><p>}</p>
<p>这里的代码对之前代码是一次非常直接的修改。这次，我们在每次迭代绘制三角形前先更新 uniform 值。如果你正确更新了uniform，你会看到你的三角形逐渐由绿变黑再变回绿色。</p>
<p>如果你在哪儿卡住了，可以到<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.1.shaders_uniform/shaders_uniform.cpp" target="_blank" rel="noopener">这里</a>查看源码。</p>
<p>可以看到，uniform 对于设置一个在渲染迭代中会改变的属性是一个非常有用的工具，它也是一个在程序和着色器间数据交互的很好工具，但假如我们打算为每个顶点设置一个颜色的时候该怎么办？这种情况下，我们就不得不声明和顶点数目一样多的 uniform了。在这一问题上更好的解决方案是在顶点属性中包含更多的数据，这是我们接下来要做的事情。</p>
<h4 id="更多属性！"><a href="#更多属性！" class="headerlink" title="更多属性！"></a>更多属性！</h4><p>在前面的教程中，我们了解了如何填充 VBO、配置顶点属性指针以及如何把它们都储存到一个 VAO 里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为 3 个 float 值至vertices 数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p>
<p>float vertices[] = {<br>    // 位置              // 颜色<br>     0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下<br>    -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下<br>     0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部<br>};</p>
<p>由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用 layout 标识符来把 aColor 属性的位置值设置为 1：</p>
<p>#version 330 core<br>layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0<br>layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1</p>
<p>out vec3 ourColor; // 向片段着色器输出一个颜色<br>void main()<br>{<br>    gl_Position = vec4(aPos, 1.0);<br>    ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色<br>}</p>
<p>由于我们不再使用 uniform 来传递片段的颜色了，现在使用 ourColor 输出变量，我们必须再修改一下片段着色器：</p>
<p>#version 330 core<br>out vec4 FragColor;<br>in vec3 ourColor;</p>
<p>void main()<br>{<br>    FragColor = vec4(ourColor, 1.0);<br>}</p>
<p>因为我们添加了另一个顶点属性，并且更新了 VBO 的内存，我们就必须重新配置顶点属性指针。更新后的 VBO 内存中的数据现在看起来像这样：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt></p>
<p>知道了现在使用的布局，我们就可以使用 glVertexAttribPointer 函数更新顶点格式，</p>
<p>// 位置属性<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);<br>// 颜色属性<br>glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 <em> sizeof(float), (void</em>)(3* sizeof(float)));<br>glEnableVertexAttribArray(1);</p>
<p>glVertexAttribPointer 函数的前几个参数比较明了。这次我们配置属性位置值为 1 的顶点属性。颜色值有 3 个 float 那么大，我们不去标准化这些值。</p>
<p>由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个 x 分量）我们必须向右移动 6 个 float，其中 3 个是位置值，另外 3 个是颜色值。这使我们的步长值为 6 乘以 float 的字节数（= 24字节）。<br>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是 0。颜色属性紧随位置数据之后，所以偏移量就是 3 * sizeof(float)，用字节来计算就是 12 字节。</p>
<p>运行程序你应该会看到如下结果：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/05/shaders3.png" alt></p>
<p>如果你在哪卡住了，可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.2.shaders_interpolation/shaders_interpolation.cpp" target="_blank" rel="noopener">这里</a>查看源码。</p>
<p>这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。</p>
<p>基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。</p>
<p>这正是在这个三角形中发生了什么。我们有 3 个顶点，和相应的 3 个颜色，从这个三角形的像素来看它可能包含 50000 左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p>
<h4 id="我们自己的着色器类"><a href="#我们自己的着色器类" class="headerlink" title="我们自己的着色器类"></a>我们自己的着色器类</h4><p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p>
<p>我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：</p>
<p>#ifndef SHADER_H</p>
<p>#define SHADER_H</p>
<p>#include &lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</p>
<p>#include <string></string></p>
<p>#include <fstream></fstream></p>
<p>#include <sstream></sstream></p>
<p>#include <iostream><br>class Shader<br>{<br>public:<br>    // 程序ID<br>    unsigned int ID;</iostream></p>
<pre><code>// 构造器读取并构建着色器
Shader(const GLchar* vertexPath, const GLchar* fragmentPath);
// 使用/激活程序
void use();
// uniform工具函数
void setBool(const std::string &amp;name, bool value) const;  
void setInt(const std::string &amp;name, int value) const;   
void setFloat(const std::string &amp;name, float value) const;
</code></pre><p>};</p>
<p>#endif</p>
<p>在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor Directives)。这些预处理指令会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。</p>
<p>着色器类储存了着色器程序的 ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：use 用来激活着色器程序，所有的 set… 函数能够查询一个 unform 的位置值并设置它的值。</p>
<h4 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h4><p>我们使用 C++ 文件流读取着色器内容，储存到几个 string 对象里：</p>
<p>Shader(const char<em> vertexPath, const char</em> fragmentPath)<br>{<br>    // 1. 从文件路径中获取顶点/片段着色器<br>    std::string vertexCode;<br>    std::string fragmentCode;<br>    std::ifstream vShaderFile;<br>    std::ifstream fShaderFile;<br>    // 保证ifstream对象可以抛出异常：<br>    vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);<br>    fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit);<br>    try<br>    {<br>        // 打开文件<br>        vShaderFile.open(vertexPath);<br>        fShaderFile.open(fragmentPath);<br>        std::stringstream vShaderStream, fShaderStream;<br>        // 读取文件的缓冲内容到数据流中<br>        vShaderStream &lt;&lt; vShaderFile.rdbuf();<br>        fShaderStream &lt;&lt; fShaderFile.rdbuf();<br>        // 关闭文件处理器<br>        vShaderFile.close();<br>        fShaderFile.close();<br>        // 转换数据流到string<br>        vertexCode   = vShaderStream.str();<br>        fragmentCode = fShaderStream.str();<br>    }<br>    catch(std::ifstream::failure e)<br>    {<br>        std::cout &lt;&lt; “ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ” &lt;&lt; std::endl;<br>    }<br>    const char<em> vShaderCode = vertexCode.c_str();<br>    const char</em> fShaderCode = fragmentCode.c_str();<br>    […]<br>}</p>
<p>下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p>
<p>// 2. 编译着色器<br>unsigned int vertex, fragment;<br>int success;<br>char infoLog[512];</p>
<p>// 顶点着色器<br>vertex = glCreateShader(GL_VERTEX_SHADER);<br>glShaderSource(vertex, 1, &amp;vShaderCode, NULL);<br>glCompileShader(vertex);<br>// 打印编译错误（如果有的话）<br>glGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;success);<br>if(!success)<br>{<br>    glGetShaderInfoLog(vertex, 512, NULL, infoLog);<br>    std::cout &lt;&lt; “ERROR::SHADER::VERTEX::COMPILATION_FAILED\n” &lt;&lt; infoLog &lt;&lt; std::endl;<br>};</p>
<p>// 片段着色器也类似<br>[…]</p>
<p>// 着色器程序<br>ID = glCreateProgram();<br>glAttachShader(ID, vertex);<br>glAttachShader(ID, fragment);<br>glLinkProgram(ID);<br>// 打印连接错误（如果有的话）<br>glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);<br>if(!success)<br>{<br>    glGetProgramInfoLog(ID, 512, NULL, infoLog);<br>    std::cout &lt;&lt; “ERROR::SHADER::PROGRAM::LINKING_FAILED\n” &lt;&lt; infoLog &lt;&lt; std::endl;<br>}</p>
<p>// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了<br>glDeleteShader(vertex);<br>glDeleteShader(fragment);</p>
<p>use 函数非常简单：</p>
<p>void use()<br>{<br>    glUseProgram(ID);<br>}</p>
<p>uniform 的 setter 函数也很类似：</p>
<p>void setBool(const std::string &amp;name, bool value) const<br>{<br>    glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);<br>}<br>void setInt(const std::string &amp;name, int value) const<br>{<br>    glUniform1i(glGetUniformLocation(ID, name.c_str()), value);<br>}<br>void setFloat(const std::string &amp;name, float value) const<br>{<br>    glUniform1f(glGetUniformLocation(ID, name.c_str()), value);<br>}</p>
<p>现在我们就写完了一个完整的<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" target="_blank" rel="noopener">着色器类</a>。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p>
<p>Shader ourShader(“path/to/shaders/shader.vs”, “path/to/shaders/shader.fs”);<br>…<br>while(…)<br>{<br>    ourShader.use();<br>    ourShader.setFloat(“someUniform”, 1.0f);<br>    DrawStuff();<br>}</p>
<p>我们把顶点和片段着色器储存为两个叫做 shader.vs 和 shader.fs 的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用 .vs 和 .fs 作为扩展名很直观。</p>
<p>你可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/3.3.shaders_class/shaders_class.cpp" target="_blank" rel="noopener">这里</a>找到使用<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h" target="_blank" rel="noopener">新着色器类</a>的源代码。注意你可以点击源码中的着色器文件路径来查看每一个着色器的源代码。</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol>
<li>修改顶点着色器让三角形上下颠倒：<a href="https://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise1" target="_blank" rel="noopener">参考解答</a></li>
<li>使用 uniform 定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧：<a href="https://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise2" target="_blank" rel="noopener">参考解答</a></li>
<li>使用 out 关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?：<a href="https://learnopengl.com/code_viewer.php?code=getting-started/shaders-exercise3" target="_blank" rel="noopener">参考解答</a></li>
</ol>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/01/01/opengl-4-e7-9d-80-e8-89-b2-e5-99-a8/">http://yoursite.com/2019/01/01/opengl-4-e7-9d-80-e8-89-b2-e5-99-a8/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/01/02/e5-a4-9a-e4-b8-aa-e5-bc-82-e6-ad-a5-e7-bd-91-e7-bb-9c-e8-af-b7-e6-b1-82-e5-85-a8-e9-83-a8-e8-bf-94-e5-9b-9e/" class="pre"> 多个异步网络请求全部返回		</a><a href="/2018/12/26/opengl-3/" class="next"> OpenGL - 3 绘制三角形		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#GLSL"><span class="toc-text">GLSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向量"><span class="toc-text">向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入与输出"><span class="toc-text">输入与输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uniform"><span class="toc-text">Uniform</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更多属性！"><span class="toc-text">更多属性！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们自己的着色器类"><span class="toc-text">我们自己的着色器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从文件读取"><span class="toc-text">从文件读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#练习"><span class="toc-text">练习</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>