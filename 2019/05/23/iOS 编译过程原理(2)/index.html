<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 编译过程原理(2) | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 编译过程原理(2)</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 编译过程原理(2)</h1><div class="post-meta"><a href="/2019/05/23/iOS 编译过程原理(2)/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://me.csdn.net/Hello_Hwc" target="_blank" rel="noopener">黄文臣</a>/<a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147" target="_blank" rel="noopener">深入浅出iOS编译</a></p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚：</p>
<ul>
<li>Clang 和 LLVM 究竟是什么</li>
<li>源文件到机器码的细节</li>
<li>Linker 做了哪些工作</li>
<li>编译顺序如何确定</li>
<li>头文件是什么？XCode 是如何找到头文件的？</li>
<li>Clang Module</li>
<li>签名是什么？为什么要签名</li>
</ul>
<p>为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。</p>
<h2 id="二、编译器"><a href="#二、编译器" class="headerlink" title="二、编译器"></a>二、编译器</h2><blockquote>
<p>把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做<a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">编译器</a>。</p>
</blockquote>
<p>大多数编译器由两部分组成：前端和后端。</p>
<ul>
<li>前端负责词法分析、语法分析、生成中间代码；</li>
<li>后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。</li>
</ul>
<p><font color="#cc0000">前后端依赖统一格式的中间代码（IR）</font>，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。</p>
<p>Objective-C/C/C++ 使用的编译器前端是<a href="https://clang.llvm.org/docs/index.html" target="_blank" rel="noopener">clang</a>，swift 是 <a href="https://swift.org/compiler-stdlib/#compiler-architecture" target="_blank" rel="noopener">swift</a>，后端都是 <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-dd65ea5de43d8fc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19"></p>
<h2 id="三、LLVM"><a href="#三、LLVM" class="headerlink" title="三、LLVM"></a>三、LLVM</h2><p>LLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。</p>
<p><font color="#cc0000">LLVM 的核心库提供了现代化的 source-target-independent <a href="https://llvm.org/docs/Passes.html" target="_blank" rel="noopener">优化器</a>和支持诸多流行 CPU 架构的代码生成器</font>，这些核心代码是围绕着 LLVM IR（中间代码）建立的。</p>
<p>基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。</p>
<h2 id="四、clang"><a href="#四、clang" class="headerlink" title="四、clang"></a>四、clang</h2><p>clang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-867e93a43ad184f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20"></p>
<p>接下来，从代码层面看一下具体的转化过程，新建一个 main.c：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello debug\\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、预处理（preprocessor）"><a href="#五、预处理（preprocessor）" class="headerlink" title="五、预处理（preprocessor）"></a>五、预处理（preprocessor）</h2><p>预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。</p>
<p>#include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，<font color="#cc0000">这个过程是递归的</font>：因为 stdio.h 也有可能包含其他头文件。</p>
<p>用 clang 查看预处理的结果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xcrun clang -E main.c</span><br></pre></td></tr></table></figure>
<p>预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -E main.c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __vsnprintf_chk (<span class="keyword">char</span> * <span class="keyword">restrict</span>, <span class="keyword">size_t</span>, <span class="keyword">int</span>, <span class="keyword">size_t</span>,</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line"># <span class="number">412</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">10</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello debug\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在预处理的时候，注释被删除，条件编译被处理。</p>
<h2 id="六、词法分析（lexical-anaysis）"><a href="#六、词法分析（lexical-anaysis）" class="headerlink" title="六、词法分析（lexical anaysis）"></a>六、词法分析（lexical anaysis）</h2><p>词法分析器读入源文件的字符流，将它们组织成有意义的词素（lexeme）序列，对于每个词素，词法分析器产生词法单元（token）作为输出。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -<span class="type">Xclang</span> -<span class="built_in">dump</span>-tokens main.<span class="built_in">c</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c</span><br><span class="line">annot_module_include '#include &lt;stdio.h&gt;</span><br><span class="line">// 一点注释</span><br><span class="line">#define DEBUG 1</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    printf("hello debug\n");</span><br><span class="line">#else</span><br><span class="line">    printf'		Loc=&lt;main.c:<span class="number">9</span>:<span class="number">1</span>&gt;</span><br><span class="line">int <span class="string">'int'</span>	 [StartOfLine]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">1</span>&gt;</span><br><span class="line">identifier <span class="string">'main'</span>	 [LeadingSpace]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;main.c:<span class="number">14</span>:<span class="number">9</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;main.c:<span class="number">14</span>:<span class="number">10</span>&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span>	 [LeadingSpace]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">12</span>&gt;</span><br><span class="line">identifier <span class="string">'printf'</span>	 [StartOfLine] [LeadingSpace]	Loc=&lt;main.c:<span class="number">16</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">11</span>&gt;</span><br><span class="line">string_literal <span class="string">'"hello debug\n"'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">12</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">27</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">28</span>&gt;</span><br><span class="line">return <span class="string">'return'</span>	 [StartOfLine] [LeadingSpace]	Loc=&lt;main.c:<span class="number">20</span>:<span class="number">5</span>&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span>	 [LeadingSpace]	Loc=&lt;main.c:<span class="number">20</span>:<span class="number">12</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.c:<span class="number">20</span>:<span class="number">13</span>&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span>	 [StartOfLine]	Loc=&lt;main.c:<span class="number">21</span>:<span class="number">1</span>&gt;</span><br><span class="line">eof <span class="string">''</span>		Loc=&lt;main.c:<span class="number">21</span>:<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Loc=\<a href="main.c:9:1\" target="_blank" rel="noopener">main.c:9:1\</a> 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。</p>
<h2 id="七、语法分析（semantic-analysis）"><a href="#七、语法分析（semantic-analysis）" class="headerlink" title="七、语法分析（semantic analysis）"></a>七、语法分析（semantic analysis）</h2><p>词法分析的 Token 流会被解析成<font color="#cc0000">一颗抽象语法树（abstract syntax tree - AST）</font>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fsyntax-only -<span class="type">Xclang</span> -ast-<span class="built_in">dump</span> main.<span class="built_in">c</span> | <span class="keyword">open</span> -f</span><br></pre></td></tr></table></figure>
<p>main 函数 AST 的结构：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTranslationUnitDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18166e8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816c60</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __int128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816980</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816cd0</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __uint128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18169a0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816fa8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __NSConstantString[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mRecordType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816db0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mRecord[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816d28</span>[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m '__NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817040</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_ms_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mPointerType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817000</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816780</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817308</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit referenced[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __va_list_tag [<span class="number">1</span>]'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mConstantArrayType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18172b0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了抽象语法树，<font color="#cc0000">clang 就可以对这个树进行分析，找出代码中的错误</font>。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。</p>
<p>AST 是开发者编写 clang 插件主要交互的数据结构，clang 也提供很多 API 去读取 AST。更多细节：<a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a>。</p>
<h2 id="八、CodeGen"><a href="#八、CodeGen" class="headerlink" title="八、CodeGen"></a>八、CodeGen</h2><p>CodeGen 遍历语法树，生成 LLVM IR 代码。LLVM IR 是前端的输出，后端的输入。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xcrun</span> <span class="selector-tag">clang</span> <span class="selector-tag">-S</span> <span class="selector-tag">-emit-llvm</span> <span class="selector-tag">main</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.ll</span></span><br></pre></td></tr></table></figure>
<p>main.ll 文件内容：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ModuleID = 'main.c'</span></span><br><span class="line"><span class="comment">source_filename = "main.c"</span></span><br><span class="line"><span class="comment">target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line"><span class="comment">target triple = "x86_64-apple-macosx10.13.0"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant [13 x i8] c"hello debug\0A\00", align 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone ssp uwtable</span></span><br><span class="line"><span class="comment">define i32 @main() #0 &#123;</span></span><br><span class="line"><span class="comment">  %1 = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  store i32 0, i32* %1, align 4</span></span><br><span class="line"><span class="comment">  %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str, i32 0, i32 0))</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">...</span></span><br></pre></td></tr></table></figure>
<p>Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。</p>
<p>LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 <a href="http://llvm.org/doxygen/classllvm_1_1Pass.html" target="_blank" rel="noopener">Pass</a> 类的子类，每个节点负责做特定的优化，更多细节：<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a>。</p>
<h2 id="九、生成汇编代码"><a href="#九、生成汇编代码" class="headerlink" title="九、生成汇编代码"></a>九、生成汇编代码</h2><p>LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。</p>
<p>生成 arm 64 汇编：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -S main<span class="selector-class">.c</span> -o main.s</span><br></pre></td></tr></table></figure>
<p>查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：<a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Basic/iOS%20assembly%20toturial%20part%201.md" target="_blank" rel="noopener">iOS汇编快速入门</a>。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.macosx_version_min <span class="number">10</span>, <span class="number">13</span></span><br><span class="line">	.globl	_main                   <span class="comment">## -- Begin function main</span></span><br><span class="line">	.p2align	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line">_main:                                  <span class="comment">## @main</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	L<span class="number">_</span>.str(%rip), %rdi</span><br><span class="line">	movl	$0, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          <span class="comment">## 4-byte Spill</span></span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals</span><br><span class="line">L<span class="number">_</span>.str:                                 <span class="comment">## @.str</span></span><br><span class="line">	.asciz	<span class="string">"hello debug\n"</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>
<h2 id="十、汇编器"><a href="#十、汇编器" class="headerlink" title="十、汇编器"></a>十、汇编器</h2><p>汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -<span class="keyword">c</span> main.<span class="keyword">c</span> -o main.o</span><br></pre></td></tr></table></figure>
<p>还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> main.o</span><br><span class="line">                 (undefined) external _printf</span><br><span class="line"><span class="number">0000000000000000</span> (\<span class="symbol">_</span>\_TEXT,\<span class="symbol">_</span>\_text) external _main</span><br></pre></td></tr></table></figure>
<p>_printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。</p>
<h3 id="10-1-什么是符号（Symbols）"><a href="#10-1-什么是符号（Symbols）" class="headerlink" title="10.1 什么是符号（Symbols）?"></a>10.1 什么是符号（Symbols）?</h3><p>符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。</p>
<h2 id="十一、链接"><a href="#十一、链接" class="headerlink" title="十一、链接"></a>十一、链接</h2><p>连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang main<span class="selector-class">.o</span> -o main</span><br></pre></td></tr></table></figure>
<p>就得到了一个 mach o 格式的可执行文件</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: Mach-O 64-bit executable x86_64</span><br><span class="line">$ ./main</span><br><span class="line">hello debug</span><br><span class="line"></span><br><span class="line">再用 nm 命令，查看可执行文件的符号表：</span><br><span class="line"></span><br><span class="line">$ nm -nm main</span><br><span class="line">                 (undefined) external _printf (from libSystem)</span><br><span class="line">                 (undefined) external dyld<span class="symbol">\_</span>stub<span class="symbol">\_</span>binder (from libSystem)</span><br><span class="line">0000000100000000 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) <span class="symbol">\[</span>referenced dynamically<span class="symbol">\]</span> external <span class="symbol">\_</span><span class="symbol">\_</span>mh<span class="symbol">\_</span>execute_header</span><br><span class="line">0000000100000f60 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) external _main</span><br></pre></td></tr></table></figure>
<p>_printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。</p>
<h2 id="十二、XCode-编译"><a href="#十二、XCode-编译" class="headerlink" title="十二、XCode 编译"></a>十二、XCode 编译</h2><p>通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？</p>
<p>新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-850e886824831a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21"></p>
<p>详细的步骤：</p>
<ul>
<li>创建 Product.app 的文件夹</li>
<li>把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。</li>
<li>创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。</li>
<li>执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。</li>
<li>编译 .m 文件，生成 .o 文件。</li>
<li>链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。</li>
<li>编译 assets，编译 storyboard，链接 storyboard</li>
<li>拷贝动态库 Logger.framework，并且对其签名</li>
<li>执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework</li>
<li>对 Demo.App 签名，并验证（validate）</li>
<li>生成 Product.app</li>
<li>生成 dYSM 文件</li>
</ul>
<blockquote>
<p>Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。</p>
</blockquote>
<h2 id="十三、编译顺序"><a href="#十三、编译顺序" class="headerlink" title="十三、编译顺序"></a>十三、编译顺序</h2><p>编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？</p>
<blockquote>
<p>答案是：依赖关系。</p>
</blockquote>
<p>还是以刚刚的 Demo 项目为例，整个依赖关系如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b0c7342fdc5b545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22"></p>
<p>可以从 XCode 的 Report Navigator 看到 Target 的编译顺序：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-1c02d00b99428ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23"></p>
<p>XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。</p>
<p>那么，XCode 又从哪里得到了这些依赖关系呢？</p>
<ul>
<li>Target Dependencies - 显式声明的依赖关系</li>
<li>Linked Frameworks and Libraries - 隐式声明的依赖关系</li>
<li>Build Phase - 定义了编译一个 Target 的每一步</li>
</ul>
<h2 id="十四、增量编译"><a href="#十四、增量编译" class="headerlink" title="十四、增量编译"></a>十四、增量编译</h2><p>日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？</p>
<p>因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。</p>
<p>比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0eaaea9ee243f79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="24"></p>
<h2 id="十五、头文件"><a href="#十五、头文件" class="headerlink" title="十五、头文件"></a>十五、头文件</h2><p>C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。</p>
<p>头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-b5be48b5d1a1c97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25"></p>
<p>当只有声明，没有实现的时候，链接器就会报错。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture arm64:</span><br><span class="line">“_umimplementMethod”, referenced <span class="keyword">from</span>:</span><br><span class="line">-\[ClassA <span class="function"><span class="keyword">method</span>\] <span class="title">in</span> <span class="title">ClassA</span>.<span class="title">o</span></span></span><br><span class="line"><span class="function"><span class="title">ld</span>:</span> symbol(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture arm64</span><br><span class="line">clang: error: linker command failed <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">1</span> (use -v <span class="keyword">to</span> see invocation)</span><br></pre></td></tr></table></figure>
<p>Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。</p>
<p>日常开发中，两种常见的头文件引入方式：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"CustomClass.h"</span> // 自定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span> // 系统或者内部 framework</span></span><br></pre></td></tr></table></figure>
<p>引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？</p>
<p>回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d620556105843b4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="27"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d1cd2dd2e5bb8a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="26"></p>
<p>把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "..." search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory)</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">clang</span>/10.0.0/<span class="title">include</span></span></span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/System/Library/Frameworks (framework directory)</span><br><span class="line"> </span><br><span class="line">End <span class="keyword">of</span> search list.</span><br></pre></td></tr></table></figure>
<p>这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。</p>
<p>可以通过一个辅助的小工具 <a href="https://github.com/milend/hmap" target="_blank" rel="noopener">hmap</a> 查看 hmap 中的内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./hmap print Demo-project-headers<span class="selector-class">.hmap</span> </span><br><span class="line">AppDelegate<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.h</span><br><span class="line">Demo-Bridging-Header<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.h</span><br><span class="line">Dummy<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.h</span><br><span class="line">Framework<span class="selector-class">.h</span> -&gt; Framework/Framework.h</span><br><span class="line">TestView<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.h</span><br><span class="line">ViewController<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。</p>
</blockquote>
<p>clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>AFNetworking<span class="regexp">/AFNetworking.framework/</span>Headers/TestView.h</span><br><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>SDWebImage<span class="regexp">/SDWebImage.framework/</span>Headers/TestView.h</span><br></pre></td></tr></table></figure>
<p>系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。</p>
<p>以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时：</p>
<p>首先查找 framework 是否存在</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework</span><br></pre></td></tr></table></figure>
<p>如果 framework 存在，再在 headers 目录里查找头文件是否存在</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/headers/</span>Foundation.h</span><br></pre></td></tr></table></figure>
<h2 id="十六、Clang-Module"><a href="#十六、Clang-Module" class="headerlink" title="十六、Clang Module"></a>十六、Clang Module</h2><p>传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的：</p>
<ol>
<li>大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。</li>
<li>文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。</li>
<li>边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。</li>
</ol>
<p><a href="https://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">clang module</a> 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。</p>
<p>XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。</p>
<p>#import &lt;Foundation/NSString.h&gt; 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f9261463ed11b9e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="28"></p>
<p>那么，如何定义一个 module 呢？答案是：<font color="#cc0000">modulemap 文件，这个文件描述了一组头文件如何转换为一个 module</font>，举个例子：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">framework</span> module Foundation  \[extern_c\] \[system\] &#123;</span><br><span class="line">	umbrella header <span class="string">"Foundation.h"</span> // 所有要暴露的头文件</span><br><span class="line"> 	<span class="meta">export</span> *</span><br><span class="line">	module * &#123;</span><br><span class="line"> 		<span class="meta">export</span> *</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	explicit module NSDebug &#123; //<span class="keyword">submodule</span></span><br><span class="line"><span class="keyword"> </span>		header <span class="string">"NSDebug.h"</span></span><br><span class="line"> 		<span class="meta">export</span> *</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="keyword">swift </span>是可以直接 <span class="meta">import</span> 一个 clang module 的，比如你有一些 C 库，需要在 <span class="keyword">Swift </span>中使用，就可以用 modulemap 的方式。</span><br><span class="line"></span><br><span class="line">## 十七、<span class="keyword">Swift </span>编译</span><br><span class="line"></span><br><span class="line">现代化的语言几乎都抛弃了头文件，<span class="keyword">swift </span>也不例外。问题来了，<span class="keyword">swift </span>没有头文件又是怎么找到声明的呢？</span><br><span class="line"></span><br><span class="line">&gt; 编译器干了这些脏活累活。编译一个 <span class="keyword">Swift </span>头文件，需要解析 module 中所有的 <span class="keyword">Swift </span>文件，找到对应的声明。</span><br><span class="line"></span><br><span class="line">![<span class="number">29</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-<span class="keyword">bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">当开发中难免要有 </span>Objective-C 和 <span class="keyword">Swift </span>相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？</span><br><span class="line"></span><br><span class="line">### <span class="number">17</span>.<span class="number">1</span> <span class="keyword">Swift </span>引用 Objective-C</span><br><span class="line"></span><br><span class="line"><span class="keyword">Swift </span>的编译器内部使用了 clang，所以 <span class="keyword">swift </span>可以直接使用 clang module，从而支持直接 <span class="meta">import</span> Objective-C 编写的framework。</span><br><span class="line"></span><br><span class="line">![<span class="number">30</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/<span class="keyword">strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span> </span><br><span class="line"><span class="keyword">swift </span>编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：</span><br><span class="line"></span><br><span class="line">*   <span class="keyword">Bridging-Header.h </span>中暴露给 swfit 的头文件</span><br><span class="line">*   framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。</span><br><span class="line"></span><br><span class="line"><span class="symbol">XCode</span> 提供了宏定义 NS\_SWIFT\_NAME 来让开发者定义 Objective-C =&gt; <span class="keyword">Swift的符号映射，可以通过 </span>Related <span class="keyword">Items </span>-&gt; Generate Interface 来查看转换后的结果：</span><br><span class="line"></span><br><span class="line">![<span class="number">31</span>](https://upload-images.jianshu.io/upload_images/<span class="number">5294842</span>-<span class="keyword">bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">### </span><span class="number">17</span>.<span class="number">2</span> Objective-C 引用 <span class="keyword">swift</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">xcode </span>会以 module 为单位，为 <span class="keyword">swift </span>自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-<span class="keyword">Swift.h。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">swift </span>提供了关键词 <span class="comment">@objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。</span></span><br></pre></td></tr></table></figure>
<p>@objc public class MyClass<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">## 十八、深入理解 Linker</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; &lt;font color=#cc0000&gt;链接器会把编译器编译生成的多个文件，链接成一个可执行文件&lt;/font&gt;。链接并不会产生新的代码，只是在现有代码的基础上做&lt;font color=#cc0000&gt;移动和补丁&lt;/font&gt;。</span></span><br><span class="line"></span><br><span class="line">链接器的输入可能是以下几种文件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*   </span>object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。</span><br><span class="line"><span class="bullet">*   </span>动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载</span><br><span class="line"><span class="bullet">*   </span>静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。</span><br><span class="line"><span class="bullet">*   </span>tbd，只包含符号的库文件</span><br><span class="line"></span><br><span class="line">这里提到了一个概念：符号（Symbols），那么符号是什么呢？</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。</span></span><br><span class="line"></span><br><span class="line">以一段代码为例，看看链接时究竟发生了什么？</span><br><span class="line"></span><br><span class="line">源代码：</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(void)log<br>{<br>  printf(“hello world\n”);<br>}<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.o</span> 文件：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>#代码<br>adrp    x0, l<em>.str@PAGE<br>add     x0, x0, l</em>.str@PAGEOFF<br>bl      _printf</p>
<p>#字符串符号<br>l_.str:                                 ; @.str<br>        .asciz  “hello world\n”<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 .o 文件中，字符串 "hello world\\n" 作为一个符号（l\<span class="emphasis">_.str）被引用，汇编代码读取的时候按照 l\_</span>.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>l_.str 在可执行文件的哪个位置？</span><br><span class="line"><span class="bullet">2.  </span>printf 函数来自哪里？</span><br><span class="line"></span><br><span class="line">再来看看链接之后的 mach o 文件：</span><br><span class="line"></span><br><span class="line">![<span class="string">32</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">链接器如何解决这两个问题呢？</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。</span><br><span class="line"><span class="bullet">2.  </span>链接后，不再是调用符号 \<span class="emphasis">_printf，而是在 DATA 段上创建了一个函数指针 \_</span>printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 <span class="emphasis">_printf 地址。更多细节，可以参考这篇文章：[深入理解iOS App的启动过程](https://blog.csdn.net/Hello_</span>Hwc/article/details/78317863)。</span><br><span class="line"></span><br><span class="line">Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。</span><br><span class="line"></span><br><span class="line"><span class="section">## 十九、理解签名</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 19.1 基础回顾</span></span><br><span class="line"></span><br><span class="line">非对称加密</span><br><span class="line"></span><br><span class="line">在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。</span><br><span class="line"></span><br><span class="line">数字签名</span><br><span class="line"></span><br><span class="line">数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。</span><br><span class="line"></span><br><span class="line">数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。</span><br><span class="line"></span><br><span class="line">![<span class="string">33</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。</span><br><span class="line"></span><br><span class="line">![<span class="string">34</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。</span></span><br><span class="line"></span><br><span class="line">有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。</span><br><span class="line"></span><br><span class="line"><span class="section">## 二十、iOS App 签名</span></span><br><span class="line"></span><br><span class="line">为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。</span><br><span class="line"></span><br><span class="line">除此之外，Apple 要严格控制 App 的分发：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>App 来自 Apple 信任的开发者</span><br><span class="line"><span class="bullet">2.  </span>安装的设备是 Apple 允许的设备</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.1 证书</span></span><br><span class="line"></span><br><span class="line">通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。</span><br><span class="line"></span><br><span class="line">![<span class="string">35</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.2 Provisioning Profile</span></span><br><span class="line"></span><br><span class="line">iOS App 安装到设备的途径（非越狱）有以下几种：</span><br><span class="line"></span><br><span class="line"><span class="bullet">*   </span>开发包（插线，或者 archive 导出 develop 包）</span><br><span class="line"><span class="bullet">*   </span>Ad Hoc</span><br><span class="line"><span class="bullet">*   </span>App Store</span><br><span class="line"><span class="bullet">*   </span>企业证书</span><br><span class="line"></span><br><span class="line">开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。</span><br><span class="line"></span><br><span class="line">![<span class="string">36</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line">可以通过以下命令来查看 Provisioning Profile 中的内容：</span><br></pre></td></tr></table></figure></p>
<p>security cms -D -i embedded.mobileprovision &gt; result.plist<br>open result.plist<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本质上就是一个编码过后的 plist。</span><br><span class="line"></span><br><span class="line">![<span class="string">37</span>](<span class="link">https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### 20.3 iOS 签名</span></span><br><span class="line"></span><br><span class="line">生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。</span><br><span class="line"></span><br><span class="line">创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名</span><br></pre></td></tr></table></figure></p>
<p><key>Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nib</key><br><data><br>T2g5jlq7EVFHNzL/ip3fSoXKoOI=<br></data></p>
<p><key>Info.plist</key><br><data><br>5aVg/3m4y30m+GSB8LkZNNU3mug=<br></data></p>
<p><key>PkgInfo</key><br><data><br>n57qDP4tZfLD1rCS43W0B4LQjzE=<br></data></p>
<p><key>embedded.mobileprovision</key><br><data><br>tm/I1g+0u2Cx9qrPJeC0zgyuVUE=<br></data><br>…<br><code>`</code></p>
<p>代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-8c96d1f4a8fcb7b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="38"></p>
<h3 id="20-4-验证"><a href="#20-4-验证" class="headerlink" title="20.4 验证"></a>20.4 验证</h3><h4 id="20-4-1-安装-App-的时候"><a href="#20-4-1-安装-App-的时候" class="headerlink" title="20.4.1 安装 App 的时候"></a>20.4.1 安装 App 的时候</h4><ul>
<li>从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者</li>
<li>证书验证通过后，从证书中取出 Leo 的公钥</li>
<li>读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确</li>
<li>文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证）</li>
<li>验证通过后，安装 App</li>
</ul>
<h4 id="20-4-2-启动-App-的时候"><a href="#20-4-2-启动-App-的时候" class="headerlink" title="20.4.2 启动 App 的时候"></a>20.4.2 启动 App 的时候</h4><ul>
<li>验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致</li>
<li>判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证</li>
<li>如果是企业证书，验证用户是否信任企业证书</li>
<li>App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。</li>
<li>以上都验证通过，App 才能正常启动</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/iOS 编译过程原理(2)/">http://yoursite.com/2019/05/23/iOS 编译过程原理(2)/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/iOS 内存管理：MRC、ARC/" class="next">iOS 内存管理：从 MRC 到 ARC 实践</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、编译器"><span class="toc-text">二、编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、LLVM"><span class="toc-text">三、LLVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、clang"><span class="toc-text">四、clang</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、预处理（preprocessor）"><span class="toc-text">五、预处理（preprocessor）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、词法分析（lexical-anaysis）"><span class="toc-text">六、词法分析（lexical anaysis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、语法分析（semantic-analysis）"><span class="toc-text">七、语法分析（semantic analysis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、CodeGen"><span class="toc-text">八、CodeGen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、生成汇编代码"><span class="toc-text">九、生成汇编代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、汇编器"><span class="toc-text">十、汇编器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-什么是符号（Symbols）"><span class="toc-text">10.1 什么是符号（Symbols）?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、链接"><span class="toc-text">十一、链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、XCode-编译"><span class="toc-text">十二、XCode 编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、编译顺序"><span class="toc-text">十三、编译顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四、增量编译"><span class="toc-text">十四、增量编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五、头文件"><span class="toc-text">十五、头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六、Clang-Module"><span class="toc-text">十六、Clang Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-验证"><span class="toc-text">20.4 验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-4-1-安装-App-的时候"><span class="toc-text">20.4.1 安装 App 的时候</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-4-2-启动-App-的时候"><span class="toc-text">20.4.2 启动 App 的时候</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存监控/">iOS 内存监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/property/">property</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/ARC/">ARC</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/引用计数/">引用计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/weak/">weak</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/String/">String</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/malloc/">malloc</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>