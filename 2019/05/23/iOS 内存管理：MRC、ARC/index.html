<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 内存管理：从 MRC 到 ARC 实践 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 内存管理：从 MRC 到 ARC 实践</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/algorithm/"><i class="fa algorithm"> 算法</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 内存管理：从 MRC 到 ARC 实践</h1><div class="post-meta"><a href="/2019/05/23/iOS 内存管理：MRC、ARC/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>对于 iOS 程序员来说，内存管理是入门的必修课。引用计数、自动释放等概念，都是与 C 语言完全不同的。</p>
<p>iOS 内存管理的核心是<font color="#cc0000">引用计数</font>。</p>
<p>接触 MRC 时遇到最头疼的问题就是：为什么那么多 release？什么地方需要 release？</p>
<p>同样初始化一个字符串的两个方法为什么不同，上边一个不需要调用 release，后边一个就需要调用 release？</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">"qqstock"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * str2 = [[<span class="built_in">NSString</span> alloc] initWithData:recvData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br></pre></td></tr></table></figure>
<p>属性赋值与成员变量赋值，一个导致计数器 +1，一个就不会。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.name</span> = @<span class="string">"qqstock"</span>;    </span><br><span class="line"><span class="attr">_name</span> = @<span class="string">"qqstock"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一、MRC-的初衷和实现方式"><a href="#一、MRC-的初衷和实现方式" class="headerlink" title="一、MRC 的初衷和实现方式"></a>一、MRC 的初衷和实现方式</h2><p>苹果为什么要做这个？</p>
<p>首先，C/C++ 传统的内存管理方式是：所有的内存都需要业务代码自己处理，程序员一定要知道一个内存对象什么时候不再使用了，一定要知道这个内存对象的终点在哪里。</p>
<p>当代码越来越复杂，参与开发的程序员越来越多，甚至随着岁月的流逝更换了新的程序员，这个时候，很难有人说的清了。于是，要么那个内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；要么，一个胆大的程序员将它释放掉，某处发生了crash。</p>
<p>尽管大家总结出许多类似“谁创建谁释放”、“谁持有谁释放” 的原则，但都导致存储空间的浪费：<font color="#cc0000">为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，而其中大部分已经不再使用了</font>。要么，自己写许许多多的代码，频繁对容器进行主动操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ce94c096d686dec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>于是，苹果要解决这个问题。初衷就是：<font color="#cc0000">任何一个内存对象由系统自己处理释放的问题，无论创建者也好，持有者也好，不需要去考虑别人是否还在使用同一个内存对象，做好自己该做的就是了，别人的事情别人负责</font>。</p>
<p>苹果实现此目的的手段就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，就好了，即便别人还在使用，你只要调用 release 将自己的引用次数清零就好了，不用管别人。</p>
<p>与 C/C++ 传统的内存管理方式相比，MRC 是不是显得非常智能？是不是更加方便？而且，这样做的代价也非常低廉，每一个内存对象增加一个计数器就好了，每一次 release，只需要检查一遍计数器是否为零，如果为零就释放，如果不为零就不执行真正的释放逻辑。</p>
<p>另外，为了解决函数返回值的问题，需要搞一个 autorelease 的东西，否则就会打破这个良好的初衷：“只负责自己范围内的事情就好了，不要管别人。”</p>
<p>那么为什么不将所有内存对象都统一成 retain 呢？对于一种编译器，它能够用一个技术解决所有问题，就坚决不会用两种并列的技术导致问题更复杂。</p>
<p>OC 有一个 delegate 的东西，这个东西的出现也是有其现实需求的，在此先跳过。如果所有地方都使用 retain，delegate 的问题一定会导致循环引用，除了 delegate，苹果不敢保证所有用户代码的逻辑都是树形结构的，最简单的比如说循环链表、双向链表，除此之外，业务层肯定也有某些地方必须做成“循环引用”，如果都是 retain，那么，最终处于循环中的内存对象谁也不会被最终释放掉。为了解决这个问题，苹果依然保留了 C/C++ 的那种弱引用方式。</p>
<h2 id="二、MRC-的优点和无奈"><a href="#二、MRC-的优点和无奈" class="headerlink" title="二、MRC 的优点和无奈"></a>二、MRC 的优点和无奈</h2><p>总结：</p>
<ol>
<li>MRC 的计数器机制改善了内存管理的方式，减少了各个模块的逻辑耦合，释放了程序员对“何时该释放”的心理压力，解决了大部分的问题</li>
<li>为了应对各种复杂的场景，很无奈的留了一个口子；</li>
<li>两种模式的并存，对 C++ 程序员转移到 OC 树立了一个无形的心理门槛，使得起步阶段问题更加复杂，比如：retain、assign、release、autorelease 等。</li>
</ol>
<p>难道就没有更好的方式么？当然有更好的方式，而且一定有许多公司的 C++ 程序员或者 C 程序员写了类似引用计数的程序，甚至比引用计数还要高级，只不过大多数公司没有实力推广一个编程语言而已。</p>
<p>略微深入思考，一定许多人想到：如果让系统对所有内存对象在运行时统一管理，问题就能彻底解决了。是的，的确如此，一定有人设计出来了。但是，代价比较高。</p>
<p>系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，在硬件设备尚且处于低级阶段的时候，当程序员们依然在努力降低内存降低 CPU 消耗的时候，推出这样的机制，是不合时宜的！</p>
<p>引用计数器的方式，编译器并没有增加太多的逻辑，只是在创建的时候增加一个计数器，在释放的时候编译器自动帮程序员增加一个逻辑判断。这个逻辑并没有增加太多的内存和 CPU 开销。</p>
<p>再来看 autorelease，这个逻辑增加的成本可就大了去了，系统要一直持有该类型的内存对象，直到本次 runloop 结束。所以，无论苹果，还是有经验的程序员，都建议：能不用就尽量不用，能缩短范围就尽量缩短范围。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-8a9490ca9920ca7b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="三、编程语言和编译器的发展方向"><a href="#三、编程语言和编译器的发展方向" class="headerlink" title="三、编程语言和编译器的发展方向"></a>三、编程语言和编译器的发展方向</h2><p>由于留了无奈的口子，野指针依然会出现，该 crash 的时候依然 crash。许多人说：这是程序员的问题，如果代码写的足够好，一定不会出现野指针，一定不会出现 crash。是的，如果大家足够尽力，这个世界上不会有任何冲突。</p>
<p>然而，<font color="#cc0000">编程语言和编译器的发展，一定向着便利、易用、稳健、智能，甚至傻瓜</font>。如果一个编译器能够让一个对计算机毫无了解的人一天之内搞出自己想要的业务应用，谁又会拒绝呢？</p>
<p>许多程序员都是技术控，自己能做的事情尽量不让别人做，自己能实现的逻辑尽量不用别人的。比如：C++ 的各种封装、引用，我用 C 也能实现，有什么大不了的！系统提供的各种类库，我自己用底层的代码也能实现，而且性能更优，代码更少。但是，如果你连一个砖头都要自己烧制，连一堵墙都要自己去砌，其它更重要的事情谁去做？</p>
<p>更何况，人，总有打盹的时候。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-8c741ac3aebd0dd7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="四、ARC-的适时推出"><a href="#四、ARC-的适时推出" class="headerlink" title="四、ARC 的适时推出"></a>四、ARC 的适时推出</h2><p>随着硬件的升级，条件已经成熟了，ARC 到来了！</p>
<p>ARC 的初衷是为了让程序员写代码的时候更加便利，最好不用再关注任何内存释放的问题（也不用关注用什么方式初始化的问题）。当然了，解决野指针的问题也是很重要的！总之，让编码更加简单，程序更加健壮。</p>
<p>之前对 C++ 程序员头疼的问题变得异常简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">"qqstock"</span>];</span><br><span class="line"><span class="built_in">NSString</span> * str2 = [[<span class="built_in">NSString</span> alloc] initWithData:recvData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="keyword">self</span>.name = <span class="string">@"qqstock"</span>;</span><br><span class="line">_name = <span class="string">@"qqstock"</span>;</span><br></pre></td></tr></table></figure>
<p>到底何时释放？总之，你不用管了，用就好。到底有何区别？没啥区别，只管用就好。</p>
<p>许多刨根究底的程序员从汇编代码也印证了这个“猜想”。ARC 的目的就是将程序员从 MRC 的各种“不同点”上解脱出来，对于尚未接触过 MRC 的 C 程序员是非常容易理解的，而对于已经习惯了 MRC 的程序员，反倒有点“不敢相信”。</p>
<p>逻辑其实很简单。</p>
<p>首先，强引用依然保留 MRC 的方式，因为这样实现的方式代价很低；</p>
<p>其次，一旦出现弱引用，则<font color="#cc0000">将内存对象在系统中建立映射表</font>；一旦内存对象因为所有强引用归零而释放，则将所有弱引用指针归零（指向 nil）。其实，将弱引用强制指向 nil 也是一种无奈的方式，按理说，这依然是个隐患，是代码逻辑的缺陷，只是人家帮你将错误的代价降到最低而已。</p>
<p>总之，强引用的逻辑是：如果都不用了，我就释放掉；弱引用的逻辑是：如果释放了，我就置 nil。最终，程序员不需要关注内存的持有和释放问题，更不需要关注别的模块是否依然在使用同一个内存。做好自己分内的事情，别的事情交给系统和编译器！</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-257b99640d8ddfea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="è¾è®¯Bugly"></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>如果所有地方都用强引用，或者所有地方都交予系统管理，势必会导致内存的快速膨胀。某些其它语言的例子就非常明显，无论程序员如何努力，内存也很难降低下来。</p>
<p>许多问题，如果我们能够站在设计者的立场上考虑，就能够更加清楚自己该如何 coding，设计者的初衷决定了我们 coding 的方式，设计者的 coding 决定了我们的思维方式。</p>
<p>①、使用 retain 类型初始化方法给 weak 和 assign 类型变量赋值时，编译器会报警。</p>
<p>②、weak 变量当其指向的变量的所有强引用置零后，自己会被置 nil，而 assign 却不会。</p>
<p>③、weak 变量被置 nil，不是当其指向变量析构的时候，而是在强引用归零的时候就已经发生了。</p>
<p>④、各种类方法初始化的 autorelease 对象，依然是在 runloop 结束的时候析构的，而 retain 类型的对象，却是在代码模块终止的时候析构的。所以，出于内存管理的考虑，依然建议少用 autorelease。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/iOS 内存管理：MRC、ARC/">http://yoursite.com/2019/05/23/iOS 内存管理：MRC、ARC/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/AFNetworking/" class="pre">AFNetworking</a><a href="/2019/05/23/iOS 内存监控/" class="next">iOS 内存监控</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、MRC-的初衷和实现方式"><span class="toc-text">一、MRC 的初衷和实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、MRC-的优点和无奈"><span class="toc-text">二、MRC 的优点和无奈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、编程语言和编译器的发展方向"><span class="toc-text">三、编程语言和编译器的发展方向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ARC-的适时推出"><span class="toc-text">四、ARC 的适时推出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、总结"><span class="toc-text">五、总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存监控/">iOS 内存监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/property/">property</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/ARC/">ARC</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/引用计数/">引用计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/weak/">weak</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/String/">String</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>