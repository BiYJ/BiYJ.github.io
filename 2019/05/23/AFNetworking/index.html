<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>AFNetworking | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AFNetworking</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">AFNetworking</h1><div class="post-meta"><a href="/2019/05/23/AFNetworking/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-6f0c4c0e6a6b5465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d8ff8c272fa71948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-527878595c6d8c94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>AFNetworking 实际上是对 NSURLSession 高度地封装，提供一些简单易用的 api，方便开发者在 iOS 开发中发出网络请求并在其上更快地构建网络层组件以及提供合理的接口。</p>
<p>AFNetworking 默认接收 json 格式的响应。</p>
<h2 id="二、AFURLSessionManager"><a href="#二、AFURLSessionManager" class="headerlink" title="二、AFURLSessionManager"></a>二、AFURLSessionManager</h2><p>AFURLSessionManager 遵守 \&lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate, NSSecureCoding, NSCopying> 协议，根据指定的 NSURLSessionConfiguration 对象创建和管理 NSURLSession 对象。</p>
<ol>
<li>负责创建和管理 NSURLSession</li>
<li>管理 NSURLSessionTask</li>
<li>实现 NSURLSessionDelegate 等协议中的代理方法</li>
<li>使用 AFURLSessionManagerTaskDelegate 管理进度</li>
<li>使用 _AFURLSessionTaskSwizzling 调剂方法</li>
<li>引入 AFSecurityPolicy 保证请求的安全</li>
<li>引入 AFNetworkReachabilityManager 监控网络状态</li>
</ol>
<h2 id="三、AFURLResponseSerialization-文件"><a href="#三、AFURLResponseSerialization-文件" class="headerlink" title="三、AFURLResponseSerialization 文件"></a>三、AFURLResponseSerialization 文件</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-a4c8de00e051ca4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="3-1-AFURLResponseSerialization-协议"><a href="#3-1-AFURLResponseSerialization-协议" class="headerlink" title="3.1 AFURLResponseSerialization 协议"></a>3.1 AFURLResponseSerialization 协议</h3><p>遵守协议的对象根据详细的服务器响应，将数据转换成更有用的对象表达。响应序列化程序可以对输入的响应和数据进行验证，例如：一个 JSON 响应序列化程序可以检查一个可接受的状态代码(‘2xx’范围)和内容类型(‘application/json’)，然后决定将一个有效的 JSON 响应解码成一个对象。</p>
<h3 id="3-2-AFHTTPResponseSerializer"><a href="#3-2-AFHTTPResponseSerializer" class="headerlink" title="3.2 AFHTTPResponseSerializer"></a>3.2 AFHTTPResponseSerializer</h3><p>遵守 AFURLRequestSerialization、AFURLResponseSerialization 协议，提供一个查询字符串或 URL 类型编码的参数序列化和默认请求头具体的实现，以及响应状态码和内容类型的验证。鼓励使用 AFHTTPResponseSerializer 的子类来解析请求或相应序列化。</p>
<h3 id="3-3-AFJSONResponseSerializer"><a href="#3-3-AFJSONResponseSerializer" class="headerlink" title="3.3 AFJSONResponseSerializer"></a>3.3 AFJSONResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型：</p>
<p>- ‘application/json’<br>- ‘text/json’<br>- ‘text/javascript’</p>
<h3 id="3-4-AFXMLParserResponseSerializer"><a href="#3-4-AFXMLParserResponseSerializer" class="headerlink" title="3.4 AFXMLParserResponseSerializer"></a>3.4 AFXMLParserResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，可以解析的 MIME 类型：</p>
<p>- ‘application/xml’<br>- ‘text/xml’</p>
<h3 id="3-5-AFPropertyListResponseSerializer"><a href="#3-5-AFPropertyListResponseSerializer" class="headerlink" title="3.5 AFPropertyListResponseSerializer"></a>3.5 AFPropertyListResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，验证和解析 XML 响应，如同 NSXMLDocument 对象。可解析的 MIME 类型：</p>
<p>- ‘application/x-plist’</p>
<h3 id="3-6-AFImageResponseSerializer"><a href="#3-6-AFImageResponseSerializer" class="headerlink" title="3.6 AFImageResponseSerializer"></a>3.6 AFImageResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，验证和解析 image 响应，解析成 UIImage 或 NSImage，可解析的 MIME 类型：</p>
<p>- ‘image/tiff’<br>- ‘image/jpeg’<br>- ‘image/gif’<br>- ‘image/png’<br>- ‘image/ico’<br>- ‘image/x-icon’<br>- ‘image/bmp’<br>- ‘image/x-bmp’<br>- ‘image/x-xbitmap’<br>- ‘image/x-win-bitmap’</p>
<h3 id="3-7-AFCompoundResponseSerializer"><a href="#3-7-AFCompoundResponseSerializer" class="headerlink" title="3.7 AFCompoundResponseSerializer"></a>3.7 AFCompoundResponseSerializer</h3><p>继承自 AFHTTPResponseSerializer，将用 AFURLResponseSerialization 的方法解析完成的对象，转成 AFHTTPResponseSerializer 行为的对象。这对于用单个序列化处理多种可能的响应类型来说很有用。This is useful for supporting multiple potential types and structures of server responses with a single serializer.</p>
<h3 id="3-8-全局方法"><a href="#3-8-全局方法" class="headerlink" title="3.8 全局方法"></a>3.8 全局方法</h3><p>AFErrorWithUnderlyingError()                  处理 NSError 对象</p>
<p>AFJSONObjectByRemovingKeysWithNullValues()    递归处理空值，返回可变或不可变对象</p>
<h3 id="3-9-AFHTTPResponseSerializer-方法"><a href="#3-9-AFHTTPResponseSerializer-方法" class="headerlink" title="3.9 AFHTTPResponseSerializer 方法"></a>3.9 AFHTTPResponseSerializer 方法</h3><p>- validateResponse:data:error:           通过 MIME 类型和状态码验证响应是否有效，并记录错误信息</p>
<p>- responseObjectForResponse:data:error:  AFURLResponseSerializer 协议方法</p>
<p>…                                      其他协议方法</p>
<h3 id="3-10-AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer-方法"><a href="#3-10-AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer-方法" class="headerlink" title="3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法"></a>3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法</h3><p>- init                                   设置可解析的类型</p>
<p>- responseObjectForResponse:data:error:  AFURLResponseSerializer 协议方法，执行步骤：</p>
<p>①、验证 MIME 类型和状态码</p>
<p>②、检查内容（JSON 序列化类检查内容是否为一个空格）</p>
<p>③、调用系统的序列化方法</p>
<p>④、存储错误信息</p>
<p>⑤、移除空值</p>
<h3 id="3-11-AFImageResponseSerialize-方法"><a href="#3-11-AFImageResponseSerialize-方法" class="headerlink" title="3.11 AFImageResponseSerialize 方法"></a>3.11 AFImageResponseSerialize 方法</h3><p>+ af_safeImageWithData:                   使用锁来保证数据安全</p>
<p>AFImageWithDataAtScale()                  将图片按比例缩放</p>
<p>AFInflatedImageFromResponseWithDataAtScale()     获取图片数据，执行步骤：</p>
<p>①、判断数据是否存在，没有返回 nil</p>
<p>②、使用 CGDataProvider 对象，获取不同响应类型图片文件的内容，其中 JPEG 类型颜色空间为 kCGColorSpaceModelCMYK 的数据不采用此种方式，原因：CGImageCreateWithJPEGDataProvider does not properly handle CMKY</p>
<p>③、如果 CGDataProvider 没有获取到内容，则使用  AFImageWithDataAtScale 方法进行缩放后直接返回</p>
<p>④、使用位图对象 CGBitmapContextCreate 重新绘图后缩放，并返回</p>
<p>AFCompoundResponseSerializer 分派给以上类进行解析。</p>
<h2 id="四、AFURLRequestSerialization-文件"><a href="#四、AFURLRequestSerialization-文件" class="headerlink" title="四、AFURLRequestSerialization 文件"></a>四、AFURLRequestSerialization 文件</h2><p><img src="http://upload-images.jianshu.io/upload_images/5294842-846dfe7bfc48e7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><strong>请求序列化器</strong>从 URL 字符串创建请求，将参数编码为查询字符串或 HTTP 正文。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString <span class="symbol">*</span> URLString = <span class="meta">@"http://example.com";</span></span><br><span class="line">NSDictionary <span class="symbol">*</span> parameters = <span class="meta">@&#123;</span> <span class="meta">@"foo":</span> <span class="meta">@"bar",</span> <span class="meta">@"baz":</span> <span class="meta">@[</span><span class="meta">@1,</span> <span class="meta">@2,</span> <span class="meta">@3</span> ]&#125;;</span><br></pre></td></tr></table></figure>
<p>Query String Parameter Encoding - 查询字符串参数编码</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFHTTPRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">GET</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">GET http://example.com?foo=bar&amp;baz<span class="string">[]</span>=<span class="number">1</span>&amp;baz<span class="string">[]</span>=<span class="number">2</span>&amp;baz<span class="string">[]</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>URL Form Parameter Encoding - URL 表单参数编码</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFHTTPRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">POST</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">POST http://example.com/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo=bar&amp;baz<span class="string">[]</span>=<span class="number">1</span>&amp;baz<span class="string">[]</span>=<span class="number">2</span>&amp;baz<span class="string">[]</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>JSON Parameter Encoding - JSON 参数编码</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[AFJSONRequestSerializer serializer]</span> requestWithMethod:@<span class="string">"<span class="keyword">POST</span>"</span> URLString:URLString parameters:parameters error:nil];</span><br><span class="line"></span><br><span class="line">POST http://example.com/</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>, <span class="string">"baz"</span>: <span class="string">[1,2,3]</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-AFURLRequestSerialization-协议"><a href="#4-1-AFURLRequestSerialization-协议" class="headerlink" title="4.1 AFURLRequestSerialization 协议"></a>4.1 AFURLRequestSerialization 协议</h3><p>遵守协议的对象为指定的 HTTP 请求的参数进行编码，参数包含查询字符串、HTTP bodies、必要设置的合适的 HTTP 头字段。例如：一个 JSON 请求序列化可以将请求的 HTTP 主体设置为JSON 表示，并将 HTTP 头字段 ‘Content-Type’ 设置为 ‘application/json’。</p>
<h3 id="4-2-AFMultipartFormData-协议"><a href="#4-2-AFMultipartFormData-协议" class="headerlink" title="4.2 AFMultipartFormData 协议"></a>4.2 AFMultipartFormData 协议</h3><p>该协议定义了一些方法。在 AFHTTPRequestSerializer 的 multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock: 方法中，block 参数返回遵守该协议的对象。</p>
<h3 id="4-3-AFHTTPRequestSerializer"><a href="#4-3-AFHTTPRequestSerializer" class="headerlink" title="4.3 AFHTTPRequestSerializer"></a>4.3 AFHTTPRequestSerializer</h3><p>遵守 AFURLRequestSerialization 协议。主要作用：</p>
<p>①、处理查询的 URL 参数</p>
<p>②、设置 HTTP 头部字段</p>
<p>③、设置请求的属性</p>
<p>④、分块上传</p>
<p>- init                 初始化属性，设置可解析的语言，用户信息，对属性添加观察</p>
<p>- dealloc              移除观察</p>
<p>SET、GET               属性的 setter、getter 方法。注意观察者模式的问题</p>
<p>- multipartFormRequestWithMethod:URLString:parameters:constructingBodyWithBlock:  创建 NSMutableURLRequest 对象，设置相关参数(请求方法，缓存策略等)，设置请求头字段，拼接查询字符串到 URL 或者放入 body 中</p>
<h3 id="4-4-AFStreamingMultipartFormData"><a href="#4-4-AFStreamingMultipartFormData" class="headerlink" title="4.4 AFStreamingMultipartFormData"></a>4.4 AFStreamingMultipartFormData</h3><p>遵守 AFMultipartFormData 协议</p>
<h3 id="4-5-AFHTTPBodyPart"><a href="#4-5-AFHTTPBodyPart" class="headerlink" title="4.5 AFHTTPBodyPart"></a>4.5 AFHTTPBodyPart</h3><ul>
<li><p>inputStream              根据不同 body 内容设置不同的输入流</p>
</li>
<li><p>stringForHeaders         将 headers 字典的内容进行拼接</p>
</li>
<li><p>contentLength            求出请求内容的长度，包括：初始边界、</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--<span class="variable">$&#123;bound&#125;</span>   <span class="comment">// 该 bound 表示pdf 的文件名  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"Filename"</span>  </span><br><span class="line">  </span><br><span class="line">HTTP.pdf  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>   <span class="comment">// 该 bound 表示pdf 的文件内容  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"file000"</span>; filename=<span class="string">"HTTP协议详解.pdf"</span>  </span><br><span class="line">Content-<span class="keyword">Type</span>: application/octet-stream  </span><br><span class="line">  </span><br><span class="line">%PDF-1.5  </span><br><span class="line"><span class="keyword">file</span> content  </span><br><span class="line">%%EOF  </span><br><span class="line">  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>    <span class="comment">// 该 bound 表示字符串  </span></span><br><span class="line">Content-Disposition: <span class="keyword">form</span>-data; name=<span class="string">"Upload"</span>  </span><br><span class="line">  </span><br><span class="line">Submit <span class="keyword">Query</span>  </span><br><span class="line">--<span class="variable">$&#123;bound&#125;</span>—   <span class="comment">// 表示 body 结束了</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-AFQueryStringPair"><a href="#4-6-AFQueryStringPair" class="headerlink" title="4.6 AFQueryStringPair"></a>4.6 AFQueryStringPair</h3><p>输出字段 - 值对的信息。</p>
<h2 id="五、Network-Reachability-Manager"><a href="#五、Network-Reachability-Manager" class="headerlink" title="五、Network Reachability Manager"></a>五、Network Reachability Manager</h2><p>AFNetworkReachabilityManager 监控域的可达性，以及 WWAN 和 WiFi 网络接口的地址。</p>
<ul>
<li><p>不要使用 Reachability 来确定是否应发送原始请求。</p>
<p>你应该尝试发送它。</p>
</li>
<li><p>可以使用 Reachability 来确定何时应该自动重试请求。</p>
<p>虽然它可能仍然失败，但是连接可用的可达性通知是重试某件事的好时机。</p>
</li>
<li><p>网络可达性是确定请求失败原因的有用工具。</p>
<p>在网络请求失败后，告诉用户他们处于离线状态比向他们提供更加技术性但准确的错误（如“请求超时”）要好。</p>
</li>
</ul>
<p>可以参考 <a href="https://developer.apple.com/videos/wwdc2012" target="_blank" rel="noopener">WWDC 2012 session 706, “Networking Best Practices.</a></p>
<p>Shared Network Reachability</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">AFNetworkReachabilityManager</span> sharedManager] setReachabilityStatusChangeBlock:^(<span class="name">AFNetworkReachabilityStatus</span> status) &#123;</span><br><span class="line">    NSLog(<span class="name">@</span><span class="string">"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(<span class="name">status</span>))<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">[[<span class="name">AFNetworkReachabilityManager</span> sharedManager] startMonitoring]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="六、Security-Policy"><a href="#六、Security-Policy" class="headerlink" title="六、Security Policy"></a>六、Security Policy</h2><p>AFSecurityPolicy 通过安全连接评估针对固定的 X.509 证书和公钥的服务器信任。</p>
<p>将固定的 SSL 证书添加到您的应用程序有助于防止中间人攻击和其他漏洞。 强烈建议处理敏感客户数据或财务信息的应用程序通过 HTTPS 连接路由所有通信，并配置启用 SSL pinning。</p>
<p>Allowing Invalid SSL Certificates - 允许无效的 SSL 证书</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.securityPolicy.allowInvalidCertificates = YES;  <span class="regexp">//</span> <span class="keyword">not</span> recommended <span class="keyword">for</span> production</span><br></pre></td></tr></table></figure>
<p>在二进制的文件中获取公钥的过程是这样</p>
<p>①、NSData *certificate -&gt; CFDataRef -&gt; (SecCertificateCreateWithData) -&gt; SecCertificateRefallowedCertificate</p>
<p>②、判断 SecCertificateRef allowedCertificate 是不是空，如果为空，直接跳转到后边的代码；</p>
<p>③、根据函数 SecPolicyCreateBasicX509() -&gt; SecPolicyRef policy</p>
<p>④、SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust) -&gt; 生成 SecTrustRef allowedTrust；</p>
<p>⑤、SecTrustEvaluate(allowedTrust, &amp;result) 校验证书；</p>
<p>⑥、(__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust) -&gt; 得到公钥 id, allowedPublicKey</p>
<p>这里边值得学习的地方是：__Require_Quiet 和 __Require_noErr_Quiet 这两个宏定义。</p>
<p>我们看看他们内部是怎么定义的</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __Require_Quiet</span></span><br><span class="line">	<span class="comment">#define __Require_Quiet(assertion, exceptionLabel)                            \</span></span><br><span class="line">	  <span class="keyword">do</span>                                                                          <span class="string">\</span></span><br><span class="line">	  &#123;                                                                           <span class="string">\</span></span><br><span class="line">	      <span class="keyword">if</span> ( __builtin_expect(!(assertion), <span class="number">0</span>) )                                <span class="string">\</span></span><br><span class="line">	      &#123;                                                                       <span class="string">\</span></span><br><span class="line">		  goto exceptionLabel;                                                <span class="string">\</span></span><br><span class="line">	      &#125;                                                                       <span class="string">\</span></span><br><span class="line">	  &#125; <span class="keyword">while</span> ( <span class="number">0</span> )</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>可以看出这个宏的用途是：当条件返回 false 时，执行标记以后的代码</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ifndef __Require_noErr_Quiet</span></span><br><span class="line">	<span class="comment">#define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">	  <span class="keyword">do</span>                                                                          <span class="string">\</span></span><br><span class="line">	  &#123;                                                                           <span class="string">\</span></span><br><span class="line">	      <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            <span class="string">\</span></span><br><span class="line">	      &#123;                                                                       <span class="string">\</span></span><br><span class="line">           	  goto exceptionLabel;                                                <span class="string">\</span></span><br><span class="line">	      &#125;                                                                       <span class="string">\</span></span><br><span class="line">	  &#125; <span class="keyword">while</span> ( <span class="number">0</span> )</span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>
<p>可以看出这个宏的用途是：当条件抛出异常时，执行标记以后的代码。</p>
<p>这样就有很多使用场景了。当必须要对条件进行判断的时候，我们有下边几种方案了</p>
<p>①、#ifdef  这个是编译特性</p>
<p>②、if-else  代码层次的判断</p>
<p>③、__Require_XXX 宏</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="variable">__Require_Quiet</span>(<span class="number">0</span>, <span class="variable">_out</span>);</span><br><span class="line">  </span><br><span class="line">     ...</span><br><span class="line"><span class="variable">_out</span>:</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_out 就是一个标记，这段代码 __Require_Quiet 到 _out 之间的代码不会执行。</p>
<h2 id="七、单元测试"><a href="#七、单元测试" class="headerlink" title="七、单元测试"></a>七、单元测试</h2><p>AFNetworking 在 Tests 子目录中包含一套单元测试。 这些测试可以运行，只需在您想测试的平台框架上执行测试操作即可。</p>
<h2 id="八、学习文章"><a href="#八、学习文章" class="headerlink" title="八、学习文章"></a>八、学习文章</h2><p><a href="https://draveness.me/afnetworking1" target="_blank" rel="noopener">AFNetworking 概述（一）</a><br><a href="https://www.jianshu.com/p/02488365cff6" target="_blank" rel="noopener">AFNetworking源码探究（一）– 基本介绍</a><br><a href="https://www.cnblogs.com/machao/p/5681645.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（一）之 AFNetworkReachabilityManager</a><br><a href="http://www.cnblogs.com/machao/p/5654661.html" target="_blank" rel="noopener">socket通信</a><br><a href="https://www.cnblogs.com/machao/p/5704201.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（二）之 AFSecurityPolicy</a><br><a href="http://www.cocoachina.com/ios/20151012/13722.html" target="_blank" rel="noopener">iOS 9之适配ATS</a><br><a href="https://www.cnblogs.com/machao/p/5725874.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（三）之 AFURLRequestSerialization</a><br><a href="http://www.cnblogs.com/machao/p/5718945.html" target="_blank" rel="noopener">url 编码（percentcode 百分号编码）</a><br><a href="http://www.cnblogs.com/machao/p/5755947.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（四）之 AFURLResponseSerialization</a><br><a href="http://www.cnblogs.com/machao/p/5768253.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（五）之 AFURLSessionManager</a><br><a href="http://www.cnblogs.com/machao/p/5790708.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（六）之 AFHTTPSessionManager</a><br><a href="http://www.cnblogs.com/machao/p/5796234.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（七）之 AFAutoPurgingImageCache</a><br><a href="http://www.cnblogs.com/machao/p/5803850.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（八）之 AFImageDownloader</a><br><a href="http://www.cnblogs.com/machao/p/5813054.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（九）之 AFNetworkActivityIndicatorManager</a><br><a href="http://www.cnblogs.com/machao/p/5817701.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（十）之 UIActivityIndicatorView/UIRefreshControl/UIImageView + AFNetworking</a><br><a href="https://www.cnblogs.com/machao/p/5821462.html" target="_blank" rel="noopener">AFNetworking 3.0 源码解读（十一）之 UIButton/UIProgressView/UIWebView + AFNetworking</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/AFNetworking/">http://yoursite.com/2019/05/23/AFNetworking/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/iOS 编译过程原理(2)/" class="pre">iOS 编译过程原理(2)</a><a href="/2019/05/23/iOS 内存管理：MRC、ARC/" class="next">iOS 内存管理：从 MRC 到 ARC 实践</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、架构"><span class="toc-text">一、架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、AFURLSessionManager"><span class="toc-text">二、AFURLSessionManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、AFURLResponseSerialization-文件"><span class="toc-text">三、AFURLResponseSerialization 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-AFURLResponseSerialization-协议"><span class="toc-text">3.1 AFURLResponseSerialization 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-AFHTTPResponseSerializer"><span class="toc-text">3.2 AFHTTPResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-AFJSONResponseSerializer"><span class="toc-text">3.3 AFJSONResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-AFXMLParserResponseSerializer"><span class="toc-text">3.4 AFXMLParserResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-AFPropertyListResponseSerializer"><span class="toc-text">3.5 AFPropertyListResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-AFImageResponseSerializer"><span class="toc-text">3.6 AFImageResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-AFCompoundResponseSerializer"><span class="toc-text">3.7 AFCompoundResponseSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-全局方法"><span class="toc-text">3.8 全局方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-AFHTTPResponseSerializer-方法"><span class="toc-text">3.9 AFHTTPResponseSerializer 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer-方法"><span class="toc-text">3.10 AFJSONResponseSerializer、AFXMLParserResponseSerializer、AFPropertyListResponseSerializer 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-AFImageResponseSerialize-方法"><span class="toc-text">3.11 AFImageResponseSerialize 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、AFURLRequestSerialization-文件"><span class="toc-text">四、AFURLRequestSerialization 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-AFURLRequestSerialization-协议"><span class="toc-text">4.1 AFURLRequestSerialization 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-AFMultipartFormData-协议"><span class="toc-text">4.2 AFMultipartFormData 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-AFHTTPRequestSerializer"><span class="toc-text">4.3 AFHTTPRequestSerializer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-AFStreamingMultipartFormData"><span class="toc-text">4.4 AFStreamingMultipartFormData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-AFHTTPBodyPart"><span class="toc-text">4.5 AFHTTPBodyPart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-AFQueryStringPair"><span class="toc-text">4.6 AFQueryStringPair</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Network-Reachability-Manager"><span class="toc-text">五、Network Reachability Manager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Security-Policy"><span class="toc-text">六、Security Policy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、单元测试"><span class="toc-text">七、单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、学习文章"><span class="toc-text">八、学习文章</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存监控/">iOS 内存监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/property/">property</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/ARC/">ARC</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/引用计数/">引用计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/weak/">weak</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/String/">String</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>