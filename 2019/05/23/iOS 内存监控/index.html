<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 内存监控 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 内存监控</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 内存监控</h1><div class="post-meta"><a href="/2019/05/23/iOS 内存监控/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、导读"><a href="#一、导读" class="headerlink" title="一、导读"></a>一、导读</h2><p>目前 iOS 主流的内存监控工具是 Instruments 的 Allocations，但只能用于开发阶段。本文介绍如何实现离线化的内存监控工具，<font color="#cc0000">用于 App 上线后发现内存问题</font>。</p>
<p>FOOM(Foreground Out Of Memory) 是指 App 在前台因消耗内存过多引起系统强杀。对用户而言，表现跟 crash 一样。Facebook 早在 2015 年 8 月提出 FOOM 检测办法。</p>
<p>微信自 15 年年底上线 FOOM 上报，从最初数据来看，每天 FOOM 次数与登录用户数比例接近 3%，同期 crash 率 1% 不到。而后发现 kv 上报频繁打 log 引起 FOOM。接着分析大量日志还是不能找到 FOOM 原因。微信急需一个有效的内存监控工具来发现问题。</p>
<h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>微信内存监控最初版本是使用 Facebook 的 <a href="https://github.com/facebook/FBAllocationTracker" target="_blank" rel="noopener">FBAllocationTracker</a> 工具监控 OC 对象分配，用 <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> 工具 <font color="#cc0000">hook malloc/free</font> 等接口监控堆内存分配，每隔 1 秒，把当前所有 OC 对象个数、TOP200 最大堆内存及其分配堆栈，用文本 log 输出到本地。该方案实现简单，一天内完成，通过给用户下发 TestFlight，最终发现联系人模块因迁移 DB 加载大量联系人导致FOOM。</p>
<p>不过这方案有不少缺点：</p>
<p>①、监控粒度不够细，像大量分配小内存引起的质变无法监控，另外 fishhook 只能 hook 自身 app 的 C 接口调用，对系统库不起作用；</p>
<p>②、输出 log 间隔不好控制，间隔过长可能丢失中间峰值情况，间隔过短会引起耗电、io 频繁等性能问题；</p>
<p>③、上报的原始 log 靠人工分析，缺少好的页面工具展现和归类问题。</p>
<p>所以二期版本以 Instruments 的 Allocations 为参考，着重四个方面优化：数据收集、存储、上报及展现。</p>
<h3 id="2-1-数据收集"><a href="#2-1-数据收集" class="headerlink" title="2.1 数据收集"></a>2.1 数据收集</h3><p>16 年 9 月底为了解决 ios10 nano crash，研究了 <a href="https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c.auto.html" target="_blank" rel="noopener">libmalloc 源码</a>，无意中发现这几个接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(<span class="keyword">malloc_logger_t</span>)</span><span class="params">(<span class="keyword">uint32_t</span> type, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg1, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg2, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> arg3, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uintptr_t</span> result, </span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> num_hot_frames_to_skip)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">malloc_logger_t</span> *__syscall_logger;   <span class="comment">// use this to set up syscall logging (e.g., vm_allocate, vm_deallocate, mmap, munmap)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">malloc_logger_t</span> *malloc_logger = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>当 malloc_logger 和 __syscall_logger 函数指针不为空时，malloc/free、vm_allocate/vm_deallocate 等内存分配/释放通过这两个指针通知上层，这也是内存调试工具 malloc stack 的实现原理。</p>
<p>有了这两个函数指针，我们很容易记录当前存活对象的内存分配信息（包括分配大小和分配堆栈）。分配堆栈可以用 backtrace 函数捕获，但捕获到的地址是虚拟内存地址，不能从符号表 dsym 解析符号。所以还要记录每个 image 加载时的偏移 slide，这样符号表地址 = 堆栈地址 - slide。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ae86221f47c0df54.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>另外为了更好的归类数据，每个内存对象应该有它所属的分类 Category。如上图所示。对于堆内存对象，它的 Category 名是 “Malloc” +分配大小，如 “Malloc 48.00KiB”。</p>
<p>对于虚拟内存对象，调用 vm_allocate 创建时，最后的参数 flags 代表它是哪类虚拟内存，而这个 flags 正对应于上述函数指针 __syscall_logger 的第一个参数 type，每个 flag 具体含义可以在头文件 \&lt;mach/vm_statistics.h> 找到；</p>
<p>对于 OC 对象，它的 Category 名是 OC 类名，我们可以通过 hook OC方法 +[NSObject alloc] 来获取：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Logger</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        SEL originSEL = <span class="keyword">@selector</span>(alloc);</span><br><span class="line">        SEL swizzeSEL = <span class="keyword">@selector</span>(event_logging_alloc);</span><br><span class="line">        Method originMethod = class_getClassMethod(<span class="keyword">self</span>.class, originSEL);</span><br><span class="line">        Method swizzeMethod = class_getClassMethod(<span class="keyword">self</span>.class, swizzeSEL);</span><br><span class="line">        </span><br><span class="line">        method_exchangeImplementations(originMethod, swizzeMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)event_logging_alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> object = [<span class="keyword">self</span> event_logging_alloc];  <span class="comment">// 对于 NSAutoreleasePool 对象会崩掉</span></span><br><span class="line">    </span><br><span class="line">    nsobject_set_last_allocation_event_name(object, class_getName(<span class="keyword">self</span>.class));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> nsobject_set_last_allocation_event_name(<span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> * clsName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, clsName);  <span class="comment">// 输出类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但后来发现，NSData 创建对象的类静态方法没有调用 +[NSObject alloc]，里面实现是调用 C 方法 NSAllocateObject 来创建对象，也就是说类方式创建的 OC 对象无法通过 hook 来获取 OC 类名。最后在苹果开源代码 CF-1153.18 找到了答案，当__CFOASafe=true 并且 __CFObjectAllocSetLastAllocEventNameFunction != NULL 时，CoreFoundation 创建对象后通过这个函数指针告诉上层当前对象是什么类型：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRuntime.c</span></span><br><span class="line"></span><br><span class="line">bool __CFOASafe = <span class="keyword">false</span>;</span><br><span class="line">void <span class="comment">(*__CFObjectAllocSetLastAllocEventNameFunction)(void *, const char *)</span> = NULL;</span><br></pre></td></tr></table></figure>
<p>通过上面方式，我们的监控数据来源基本跟 Allocations 一样了，当然是借助了私有 API，这是可能会被苹果打回的。只能退而求其次，修改 malloc_default_zone 函数返回的 malloc_zone_t 结构体里的 malloc、free 等函数指针，也是可以监控堆内存分配，效果等同于 malloc_logger；而虚拟内存分配只能通过 fishhook 方式。</p>
<h3 id="2-2-数据存储"><a href="#2-2-数据存储" class="headerlink" title="2.2 数据存储"></a>2.2 数据存储</h3><p>①、存活对象管理</p>
<p>APP 在运行期间会大量申请/释放内存。以上图为例，微信启动 10 秒内，已经创建了 80 万对象，释放了 50 万，性能问题是个挑战。另外在存储过程中，也尽量减少内存申请/释放。所以放弃了 sqlite，改用了更轻量级的平衡二叉树来存储。</p>
<p>伸展树 Splay Tree，也叫分裂树，是一种二叉排序树，不保证树是平衡，但各种操作平均时间复杂度是 O(logN)，可近似看作平衡二叉树。相比其他平衡二叉树（如红黑树），其内存占用较小，不需要存储额外信息。伸展树主要出发点是考虑到局部性原理（某个刚被访问的结点下次又被访问，或者访问次数多的结点下次可能被访问），为了使整个查找时间更少，被频繁查询的结点通过 “伸展” 操作搬移到离树根更近的地方。</p>
<p>大部分情况下，内存申请很快又被释放，如 autoreleased 对象、临时变量等；而 OC 对象申请内存后紧接着会更新它所属 Category。所以用伸展树管理最适合不过了。</p>
<p>传统二叉树是用链表方式实现，每次添加/删除结点，都会申请/释放内存。为了减少内存操作，可以用数组实现二叉树。具体做法是父结点的左右孩子由以往的指针类型改成整数类型，代表孩子在数组的下标；删除结点时，被删除的结点存放上一个被释放的结点所在数组下标。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ef31fa94463803da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p>
<p>②、堆栈存储</p>
<p>据统计，微信运行期间，backtrace 的堆栈有成百万上千万种，在捕获最大栈长 64 情况下，平均栈长 35。如果 36bits 存储一个地址（armv8 最大虚拟内存地址 48bits，实际上 36bits 够用了），一个堆栈平均存储长度 157.5bytes，1M 个堆栈需要157.5M 存储空间。但通过断点观察，实际上大部分堆栈是有共同后缀，例如下面的两个堆栈后 7 个地址是一样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-babc876580258a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>为此，可以用 Hash Table 来存储这些堆栈。思路是整个堆栈以链表的方式插入到 table 里，链表结点存放当前地址和上一个地址所在 table 的索引。每插入一个地址，先计算它的 hash 值，作为在 table 的索引，如果索引对应的 slot 没有存储数据，就记录这个链表结点；如果有存储数据，并且数据跟链表结点一致，hash 命中，继续处理下一个地址；数据不一致，意味着 hash 冲突，需要重新计算 hash 值，直到满足存储条件。举个例子（简化了 hash 计算）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-2f441cfc778e63f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>Stack1 的 G、F、E、D、C、A 依次插入到哈希表，索引 1～6 结点数据依次是(G, 0)、(F, 1)、(E, 2)、(D, 3)、(C, 4)、(A, 5)。Stack1 索引入口是 6</li>
<li>轮到插入 Stack2，由于 G、F、E、D、C 结点数据跟 Stack1 前 5 个结点一致，hash 命中；B 插入新的 7 号位置 (B, 5)。Stack2 索引入口是 7</li>
<li>最后插入 Stack3，G、F、E、D 结点 hash 命中；但由于 Stack3 的 A 的上一个地址 D 索引是 4，而不是已有的 (A, 5)，hash 不命中，查找下一个空白位置 8，插入结点 (A, 4)；B 上一个地址 A 索引是 8，而不是已有的 (B, 5)，hash 不命中，查找下一个空白位置 9，插入结点 (B, 9)。Stack3 索引入口是 9</li>
</ol>
<p>经过这样的后缀压缩存储，平均栈长由原来的 35 缩短到 5 不到。而每个结点存储长度为 64bits（36bits 存储地址，28bits 储存 parent 索引），hashTable 空间利用率 60%+，一个堆栈平均存储长度只需要 66.7bytes，压缩率高达 42%。</p>
<p>③、性能数据</p>
<p>经过上述优化，内存监控工具在 iPhone6Plus 运行占用 CPU 占用率 13% 不到，当然这是跟数据量有关，重度用户（如群过多、消息频繁等）可能占用率稍微偏高。而存储数据内存占用量 20M 左右，都用 mmap 方式把文件映射到内存。有关 mmap 好处可自行google。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e698f9596c1ad5b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="三、数据上报"><a href="#三、数据上报" class="headerlink" title="三、数据上报"></a>三、数据上报</h2><p>由于内存监控是存储了当前所有存活对象的内存分配信息，数据量极大，所以当出现 FOOM 时，不可能全量上报，而是按某些规则有选择性的上报。</p>
<p>首先把所有对象按 Category 进行归类，统计每个 Category 的对象数和分配内存大小。这列表数据很少，可以做全量上报。接着对 Category 下所有相同堆栈做合并，计算每种堆栈的对象数和内存大小。对于某些 Category，如分配大小 TOP N，或者UI相关的（如 UIViewController、UIView 之类的），它里面分配大小 TOP M 的堆栈才做上报。上报格式类似这样：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"items"</span> : [&#123;</span><br><span class="line">        <span class="string">"name"</span> : <span class="string">"NSObject"</span>,         # 分类名字</span><br><span class="line">        <span class="string">"size"</span> : <span class="number">123456</span>,             # 该分类下分配内存总大小</span><br><span class="line">        <span class="string">"count"</span> : <span class="number">123</span>,</span><br><span class="line">        <span class="string">"stacks"</span> : [&#123;</span><br><span class="line">            <span class="string">"size"</span> : <span class="number">21313</span>,          # 总大小</span><br><span class="line">            <span class="string">"count"</span> : <span class="number">123</span>,           # 对象个数</span><br><span class="line">            <span class="string">"frames"</span> : [&#123;</span><br><span class="line">                <span class="string">"uuid"</span> : uuid1,      # 地址所在 image 的 uuid</span><br><span class="line">                <span class="string">"offset"</span> : offset1   # 地址所在 image 的偏移</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、页面展现"><a href="#四、页面展现" class="headerlink" title="四、页面展现"></a>四、页面展现</h2><p>页面展现参考了 Allocations，可看出有哪些 Category，每个 Category 分配大小和对象数，某些 Category 还能看分配堆栈。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-6f0873784b782d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>为了突出问题，提高解决问题效率，后台先根据规则找出可能引起 FOOM 的 Category（如上面的 Suspect Categories），规则有： </p>
<ol>
<li>UIViewController 数量是否异常</li>
<li>UIView 数量是否异常</li>
<li>UIImage 数量是否异常</li>
<li>其它 Category 分配大小是否异常，对象个数是否异常</li>
</ol>
<p>接着对可疑的 Category 计算特征值，也就是 OOM 原因。特征值是由 “Caller1”、”Caller2” 和 “Category, Reason” 组成。Caller1 是指申请内存点，Caller2 是指具体场景或业务，它们都是从 Category 下分配大小第一的堆栈提取。Caller1 提取尽量是有意义的，并不是分配函数的上一地址。例如：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e03ff1c09c9eec15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>所有 report 计算出特征值后，可以对它们进行归类了。一级分类可以是 Caller1，也可以是 Category，二级分类是与Caller1/Category 有关的特征聚合。效果如下：</p>
<h3 id="4-1-一级分类"><a href="#4-1-一级分类" class="headerlink" title="4.1 一级分类"></a>4.1 一级分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/5294842-fab3ef4fe960cff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h3 id="4-2-二级分类"><a href="#4-2-二级分类" class="headerlink" title="4.2 二级分类"></a>4.2 二级分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/5294842-ddf305f28b7511d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="五、运营策略"><a href="#五、运营策略" class="headerlink" title="五、运营策略"></a>五、运营策略</h2><p>上面提到，内存监控会带来一定的性能损耗，同时上报的数据量每次大概 300K 左右，全量上报对后台有一定压力，所以对现网用户做抽样开启，灰度包用户/公司内部用户/白名单用户做 100% 开启。本地最多只保留最近三次数据。</p>
<h2 id="六、降低误判"><a href="#六、降低误判" class="headerlink" title="六、降低误判"></a>六、降低误判</h2><p>先回顾 Facebook 如何判定上一次启动是否出现 FOOM：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f1aca616a4878bf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ol>
<li>App 没有升级</li>
<li>App 没有调用 exit() 或 abort() 退出</li>
<li>App 没有出现 crash</li>
<li>用户没有强退 App</li>
<li>系统没有升级/重启</li>
<li>App 当时没有后台运行</li>
<li>App 出现 FOOM</li>
</ol>
<p>1、2、4、5 比较容易判断，3 依赖于自身 CrashReport 组件的 crash 回调，6、7 依赖于 ApplicationState 和前后台切换通知。<strong>微信自上线 FOOM 数据上报以来，出现不少误判，主要情况有：</strong></p>
<h3 id="6-1-ApplicationState-不准"><a href="#6-1-ApplicationState-不准" class="headerlink" title="6.1 ApplicationState 不准"></a>6.1 ApplicationState 不准</h3><p>部分系统会在后台短暂唤起 app，ApplicationState 是 Active，但又不是 BackgroundFetch；执行完 didFinishLaunchingWithOptions 就退出了，也有收到 BecomeActive 通知，但很快也退出；整个启动过程持续 5～8 秒不等。解决方法是收到 BecomeActive 通知一秒后，才认为这次启动是正常的前台启动。这方法只能减少误判概率，并不能彻底解决。</p>
<h3 id="6-2-群控类外挂"><a href="#6-2-群控类外挂" class="headerlink" title="6.2 群控类外挂"></a>6.2 群控类外挂</h3><p>这类外挂是可以远程控制 iPhone 的软件，通常一台电脑可以控制多台手机，电脑画面和手机屏幕实时同步操作，如开启微信，自动加好友，发朋友圈，强制退出微信，这一过程容易产生误判。解决方法只能通过安全后台打击才能减少这类误判。</p>
<h3 id="6-3-CrashReport-组件出现-crash-没有回调上层"><a href="#6-3-CrashReport-组件出现-crash-没有回调上层" class="headerlink" title="6.3 CrashReport 组件出现 crash 没有回调上层"></a>6.3 CrashReport 组件出现 crash 没有回调上层</h3><p>微信曾经在 17 年 5 月底爆发大量 GIF crash，该 crash 由内存越界引起，但收到 crash 信号写 crashlog 时，由于内存池损坏，组件无法正常写 crashlog，甚至引起二次 crash；上层也无法收到 crash 通知，因此误判为 FOOM。目前改成不依赖 crash回调，只要本地存在上一次 crashlog（不管是否完整），就认为是 crash 引起的 APP 重启。</p>
<h3 id="6-4-前台卡死引起系统-watchdog-强杀"><a href="#6-4-前台卡死引起系统-watchdog-强杀" class="headerlink" title="6.4 前台卡死引起系统 watchdog 强杀"></a>6.4 前台卡死引起系统 watchdog 强杀</h3><p>也就是常见的 0x8badf00d，通常原因是前台线程过多，死锁，或 CPU 使用率持续过高等，这类强杀无法被 App 捕获。为此我们结合了已有卡顿系统，当前台运行最后一刻有捕获到卡顿，我们认为这次启动是被 watchdog 强杀。同时我们从 FOOM 划分出新的重启原因叫“App 前台卡死导致重启”，列入重点关注。</p>
<h2 id="七、成果"><a href="#七、成果" class="headerlink" title="七、成果"></a>七、成果</h2><p>微信自 2017 年三月上线内存监控以来，解决了 30 多处大大小小内存问题，涉及到聊天、搜索、朋友圈等多个业务，FOOM 率由 17 年年初 3%，降到目前 0.67%，而前台卡死率由 0.6% 下降到 0.3%，效果特别明显。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0d49c3bc2a47404f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ed1e1b21c8bbd785.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h2 id="八、常见问题"><a href="#八、常见问题" class="headerlink" title="八、常见问题"></a>八、常见问题</h2><p>1、UIGraphicsEndImageContext</p>
<p>UIGraphicsBeginImageContext 和 UIGraphicsEndImageContext 必须成双出现，不然会造成 context 泄漏。另外 XCode的 Analyze 也能扫出这类问题。</p>
<p>2、UIWebView</p>
<p>无论是打开网页，还是执行一段简单的 js 代码，UIWebView 都会占用 APP 大量内存。而 WKWebView 不仅有出色的渲染性能，而且它有自己独立进程，一些网页相关的内存消耗移到自身进程里，最适合取替 UIWebView。</p>
<p>3、autoreleasepool</p>
<p>通常 autoreleased 对象是在 runloop 结束时才释放。如果在循环里产生大量 autoreleased 对象，内存峰值会猛涨，甚至出现 OOM。适当的添加 autoreleasepool 能及时释放内存，降低峰值。</p>
<p>4、互相引用</p>
<p>比较容易出现互相引用的地方是 block 里使用了 self，而 self 又持有这个 block，只能通过代码规范来避免。另外 NSTimer的target、CAAnimation 的 delegate，是对 Obj 强引用。目前微信通过自己实现的 MMNoRetainTimer 和MMDelegateCenter 来规避这类问题。</p>
<p>5、大图片处理</p>
<p>举个例子，以往图片缩放接口是这样写的：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)scaleImage:<span class="type"></span>(UIImage *)originIamge <span class="keyword">new</span><span class="type">Size</span>:(CGSize)<span class="keyword">new</span><span class="type">Size</span></span><br><span class="line"><span class="type"></span>&#123;</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(originIamge.size, NO, <span class="number">0</span>);</span><br><span class="line">    [originIamge drawInRect:<span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span><span class="type">Size</span>.width, <span class="keyword">new</span><span class="type">Size</span>.height)];</span><br><span class="line">    UIImage * <span class="keyword">new</span><span class="type">Image</span> = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Image</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但处理大分辨率图片时，往往容易出现 OOM，原因是 -[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的 bitmap，这是很耗内存的。解决方法是使用更低层的 ImageIO 接口，避免中间 bitmap 产生：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)scaleImageWithData:(<span class="built_in">NSData</span> *)data withSize:(<span class="built_in">CGSize</span>)size scale:(<span class="built_in">CGFloat</span>)scale orientation:(<span class="built_in">UIImageOrientation</span>)orientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> maxPixelSize = MAX(size.width, size.height);</span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> sourceRef = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)data, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">NSDictionary</span> * options = @&#123; (__bridge <span class="keyword">id</span>)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge <span class="keyword">id</span>)kCFBooleanTrue, (__bridge <span class="keyword">id</span>)kCGImageSourceThumbnailMaxPixelSize : @(maxPixelSize)&#125;;</span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(sourceRef, <span class="number">0</span>, (__bridge <span class="built_in">CFDictionaryRef</span>)options);</span><br><span class="line">    <span class="built_in">UIImage</span> * resultImage = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef scale:scale orientation:orientation];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    <span class="built_in">CFRelease</span>(sourceRef);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultImage;</span><br></pre></td></tr></table></figure>
<p>6、大视图</p>
<p>大视图是指 View 的 size 过大，自身包含要渲染的内容。超长文本是微信里常见的炸群消息，通常几千甚至几万行。如果把它绘制到同一个 View 里，那将会消耗大量内存，同时造成严重卡顿。最好做法是把文本划分成多个 View 绘制，利用 TableView 的复用机制，减少不必要的渲染和内存占用。</p>
<h2 id="九、学习文章"><a href="#九、学习文章" class="headerlink" title="九、学习文章"></a>九、学习文章</h2><p><a href="https://cloud.tencent.com/developer/article/1359436" target="_blank" rel="noopener">iOS微信内存监控</a><br><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160-SW1" target="_blank" rel="noopener">Memory Usage Performance Guidelines</a><br><a href="http://www.newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="noopener">No pressure, Mon!</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/iOS 内存监控/">http://yoursite.com/2019/05/23/iOS 内存监控/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/iOS 内存管理：MRC、ARC/" class="pre">iOS 内存管理：从 MRC 到 ARC 实践</a><a href="/2019/05/23/property/" class="next">property</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、导读"><span class="toc-text">一、导读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、实现原理"><span class="toc-text">二、实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-数据收集"><span class="toc-text">2.1 数据收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-数据存储"><span class="toc-text">2.2 数据存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、数据上报"><span class="toc-text">三、数据上报</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、页面展现"><span class="toc-text">四、页面展现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-一级分类"><span class="toc-text">4.1 一级分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-二级分类"><span class="toc-text">4.2 二级分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、运营策略"><span class="toc-text">五、运营策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、降低误判"><span class="toc-text">六、降低误判</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-ApplicationState-不准"><span class="toc-text">6.1 ApplicationState 不准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-群控类外挂"><span class="toc-text">6.2 群控类外挂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-CrashReport-组件出现-crash-没有回调上层"><span class="toc-text">6.3 CrashReport 组件出现 crash 没有回调上层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-前台卡死引起系统-watchdog-强杀"><span class="toc-text">6.4 前台卡死引起系统 watchdog 强杀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、成果"><span class="toc-text">七、成果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、常见问题"><span class="toc-text">八、常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、学习文章"><span class="toc-text">九、学习文章</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存监控/">iOS 内存监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/property/">property</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/ARC/">ARC</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/引用计数/">引用计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/weak/">weak</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/String/">String</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>