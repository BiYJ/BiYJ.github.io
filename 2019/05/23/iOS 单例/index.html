<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 单例 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 单例</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 单例</h1><div class="post-meta"><a href="/2019/05/23/iOS 单例/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、单例介绍"><a href="#一、单例介绍" class="headerlink" title="一、单例介绍"></a>一、单例介绍</h2><p>单例：该类在程序运行期间有且仅有一个实例。</p>
<h4 id="1-1-单例的主要优点"><a href="#1-1-单例的主要优点" class="headerlink" title="1.1 单例的主要优点"></a>1.1 单例的主要优点</h4><p>①、单例可以保证系统中该类有且仅有一个实例，确保所有对象都访问这个唯一实例；</p>
<p>②、因为类控制了实例化过程，所以类可以灵活更改实例化过程；</p>
<p>③、基于第 1 条，对于项目中的个别场景的传值、存储状态等业务更加方便。</p>
<h4 id="1-2-单例的主要缺点"><a href="#1-2-单例的主要缺点" class="headerlink" title="1.2 单例的主要缺点"></a>1.2 单例的主要缺点</h4><p>①、单例实例一旦创建，对象指针是保存在静态区，那么在堆区分配的空间只有在应用程序终止后才会被释放；</p>
<p>②、单例不能继承。</p>
<h2 id="二、单例的实现"><a href="#二、单例的实现" class="headerlink" title="二、单例的实现"></a>二、单例的实现</h2><p>单例的实现重点就是防止在外部调用的时候出现多个不同的实例，也就是说要从创建的方式入手禁止出现多个不同的实例。</p>
<p>主要是做到以下几点：</p>
<p>防止调用 [[A alloc] init] 引起的错误<br>防止调用 new 引起的错误<br>防止调用 copy 引起的错误<br>防止调用 mutableCopy 引起的错误</p>
<h4 id="2-1-实现方式一"><a href="#2-1-实现方式一" class="headerlink" title="2.1 实现方式一"></a>2.1 实现方式一</h4><blockquote>
<p>把所有可能出现的初始化方法做了相应的处理来其保证安全性</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 不能再使用 alloc 方法</span></span><br><span class="line">        <span class="comment">// 因为已经重写了 allocWithZone 方法，所以这里要调用父类的分配空间的方法</span></span><br><span class="line">        _sharedSingleton = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ②、防止 [[A alloc] init] 和 new 引起的错误。因为 [[A alloc] init] 和 new 实际是一样的工作原理，都是执行了下面方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③、NSCopying 防止 copy 引起的错误。当你的单例类不遵循 NSCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ④、防止 mutableCopy 引起的错误，当你的单例类不遵循 NSMutableCopying 协议，外部调用本身就会出错.</span></span><br><span class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [Singleton sharedSingleton];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-实现方式二"><a href="#2-2-实现方式二" class="headerlink" title="2.2 实现方式二"></a>2.2 实现方式二</h4><blockquote>
<p>不做处理的情况下禁止外部调用</p>
</blockquote>
<p>一些成熟的第三方代码的单例中也有使用该方法的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.h 文件</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)<span class="keyword">copy</span> <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line">- (<span class="keyword">id</span>)mutableCopy <span class="built_in">NS_UNAVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">.m 文件</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedSingleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *_sharedSingleton = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          _sharedSingleton = [[<span class="keyword">self</span> alloc] init];  <span class="comment">// 要使用 self 来调用</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _sharedSingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行 [[A alloc] init] 或 [A new] 时，会直接报错 ‘init’ is unavailable 或 ‘new’ is unavailable。</p>
<h2 id="三、单例的滥用"><a href="#三、单例的滥用" class="headerlink" title="三、单例的滥用"></a>三、单例的滥用</h2><h4 id="3-1-全局状态"><a href="#3-1-全局状态" class="headerlink" title="3.1 全局状态"></a>3.1 全局状态</h4><p>大多数的开发者都认同使用<font color="#cc0000">全局可变的状态</font>是不好的行为。有状态使得程序难以理解和难以调试。面向对象的程序员在最小化代码的有状态性方面，有很多还需要向函数式编程学习的地方。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SPMath</span></span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">NSInteger</span> _a;</span><br><span class="line">     <span class="built_in">NSInteger</span> _b;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)add</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> _a + _b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个简单的数学库的实现中，程序员需要在调用 add 前正确的设置实例变量 _a 和 _b。这样有以下问题：</p>
<ol>
<li><p>add 没有显式的通过使用参数的形式声明它依赖于 _a 和 _b 的状态。与仅仅通过查看函数声明就可以知道这个函数的输出依赖于哪些变量不同的是，另一个开发者必须查看这个函数的具体实现才能明白这个函数依赖那些变量。隐藏依赖是不好的。</p>
</li>
<li><p>当修改 _a 和 _b 的数值为调用 add 做准备时，程序员需要保证修改不会影响任何其他依赖于这两个变量的代码的正确性。而这在多线程的环境中是尤其困难的。</p>
</li>
</ol>
<p>把下面的代码和上面的例子做对比:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSUInteger</span>)addOf:(<span class="built_in">NSUInteger</span>)a plus:(<span class="built_in">NSUInteger</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，对变量 a 和 b 的依赖被显式的声明了，并且不需要为了调用这个方法而去改变实例变量的状态，也不需要担心调用这个函数会留下持久的副作用。甚至可以声明为<font color="#cc0000">类方法</font>，这样就显式的告诉了代码的阅读者：这个方法<font color="#cc0000">不会修改任何实例的状态</font>。</p>
<p>那么，这个例子和单例相比又有什么关系呢？用 Miško Hevery 的话来说，“<a href="http://misko.hevery.com/2008/08/25/root-cause-of-singletons/" target="_blank" rel="noopener">单例就是披着羊皮的全局状态</a>” 。</p>
<p>一个单例可以在不需要显式声明对其依赖的情况下，被使用在任何地方。就像变量 _a 和 _b 在 add 内部被使用了，却没有被显式声明一样，程序的任意模块都可以调用 [A sharedInstance] 并且访问这个单例。这意味着任何和这个单例交互产生的副作用都会影响程序其他地方的任意代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Singleton</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)a </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ([[Singleton sharedInstance] name]) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)b</span><br><span class="line">&#123;</span><br><span class="line">     [[Singleton sharedInstance] setName:<span class="string">""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，A 和 B 是两个完全独立的模块。但是 B 可以通过使用单例提供的<font color="#cc0000">共享状态</font>来影响 A 的行为。这种情况应该只能发生在 B 显式引用了 A，显式建立了它们两者之间的关系时。由于这里使用了单例，单例的全局性和有状态性，导致<font color="#cc0000">隐式的在两个看起来完全不相关的模块之间建立了耦合</font>。</p>
<p>来看一个更具体的例子，并且暴露一个使用全局可变状态的额外问题。</p>
<p>想要在我们的应用中构建一个网页查看器(web viewer)。我们构建了一个简单的 URL cache 来支持这个网页查看器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">URLCache</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSCache</span> *)sharedURLCache;</span><br><span class="line">- (<span class="keyword">void</span>)storeCachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这个开发者开始写了一些单元测试来保证代码在不同的情况下都能达到预期。首先，他写了一个测试用例来保证网页查看器在没有设备链接时能够展示出错误信息。然后他写了一个测试用例来保证网页查看器能够正确的处理服务器错误。最后，他为成功情况时写了一个测试用例，来保证返回的网络内容能够被正确的显示出来。这个开发者运行了所有的测试用例，并且它们都如预期一样正确。</p>
<p>几个月以后，这些测试用例开始出现失败，尽管网页查看器的代码从它写完后就从来没有再改动过！到底发生了什么？</p>
<p>原来，有人改变了测试的顺序。处理成功的那个测试用例首先被运行，然后再运行其他两个。处理错误的那两个测试用例现在竟然成功了，和预期不一样，因为 URL cache 这个单例把不同测试用例之间的 response 缓存起来了。</p>
<p><font color="#cc0000">持久化状态是单元测试的敌人</font>，因为单元测试在各个测试用例相互独立的情况下才有效。如果状态从一个测试用例传递到了另外一个，这样就和测试用例的执行顺序就有关系了。有 bug 的测试用例是非常糟糕的事情，特别是那些有时候能通过测试，有时候又不能通过测试的。</p>
<h4 id="3-2-对象的生命周期"><a href="#3-2-对象的生命周期" class="headerlink" title="3.2 对象的生命周期"></a>3.2 对象的生命周期</h4><p>另外一个关键问题就是单例的生命周期。当你在程序中添加一个单例时，很容易会认为 “它们永远只能有一个实例”。但是在很多我看到过的 iOS 代码中，这种假定都可能被打破。</p>
<p>假设我们正在构建一个应用，在这个应用里用户可以看到他们的好友列表。他们的每个朋友都有一张个人信息的图片，并且我们想使我们的应用能够下载并且在设备上缓存这些图片。 使用 dispatch_once 代码片段，写一个 ThumbnailCache 单例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ThumbnailCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache;</span><br><span class="line">- (<span class="keyword">void</span>)cacheProfileImage:(<span class="built_in">NSData</span> *)imageData forUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line">- (<span class="built_in">NSData</span> *)cachedProfileImageForUserId:(<span class="built_in">NSString</span> *)userId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>继续构建我们的应用，一切看起来都很正常，直到有一天，决定实现“注销”功能时，这样用户可以在应用中进行账号切换。突然发现我们将要面临一个讨厌的问题：用户相关的状态存储在全局单例中。</p>
<p>当用户注销后，我们希望能够清理掉所有的硬盘上的持久化状态。否则，我们将会把这些被遗弃的数据残留在用户的设备上，浪费宝贵的硬盘空间。对于用户登出又登录了一个新的账号这种情况，我们也想能够对这个新用户使用一个全新的 ThumbnailCache 实例。</p>
<p>问题在于按照定义单例被认为是“创建一次，永久有效”的实例。你可以想到一些对于上述问题的解决方案。或许我们可以在用户登出时移除这个单例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThumbnailCache * sharedThumbnailCache;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedThumbnailCache</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!sharedThumbnailCache) &#123;</span><br><span class="line">           sharedThumbnailCache = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sharedThumbnailCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)cleanUp</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// The SPThumbnailCache will clean up persistent states when deallocated</span></span><br><span class="line">     sharedThumbnailCache = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个明显的对单例模式的滥用，但是它可以工作，对吧。</p>
<p>当然可以使用这种方式去解决，但代价实在是太大了。我们不能使用简单的、能够保证线程安全和所有的调用 [ThumbnailCache sharedThumbnailCache] 的地方都会访问同一个实例的 dispatch_once 解决方案了。现在我们需要对使用 thumbnail cache 时的代码的执行顺序非常小心。假设当用户正在执行登出操作时，有一些后台任务正在执行把图片保存到缓存中的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [[ThumbnailCache sharedThumbnailCache] cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要保证在所有的后台任务完成前， cleanUp 一定不能被执行。这保证了 newImage 可以被正确的清理掉。或者，我们需要保证在 thumbnail cache 被移除时，后台缓存任务一定要被取消掉。否则，一个新的 thumbnail cache 的实例将会被延迟创建，并且之前用户的数据（newImage 对象）会被存储在它里面。</p>
<p>由于对于单例实例来说它没有明确的所有者，(比如，单例自己管理自己的生命周期)，永远“关闭”一个单例变得非常的困难。</p>
<p>分析到这里，希望能够意识到，这个 thumbnail cache 从来就不应该作为一个单例。问题在于一个对象的生命周期可能在项目的最初阶段没有被很好得考虑清楚。</p>
<p>举一个具体的例子，Dropbox 的 iOS 客户端曾经只支持一个账号登录。它以这样的状态存在了数年，直到有一天我们希望能够同时支持<a href="https://www.dropbox.com/business/two-dropboxes" target="_blank" rel="noopener">多个用户账号</a>登录（既包括个人账号也包括企业账号）。突然之间，我们以前的的假设“只能够同时有一个用户处于登录状态”就不成立了。 假定一个对象的生命周期和应用的生命周期一致，会限制你的代码的灵活扩展，早晚有一天当产品的需求产生变化时，你会为当初的这个假定付出代价的。</p>
<p>这里我们得到的教训是：<font color="#cc0000">单例应该只用来保存全局的状态，并且不能和任何作用域绑定</font>。如果这些状态的作用域比一个完整的应用程序的生命周期要短，那么这个状态就不应该使用单例来管理。用一个单例来管理用户绑定的状态，是代码的坏味道，你应该认真的重新评估你的对象图的设计。</p>
<h2 id="四、避免使用单例"><a href="#四、避免使用单例" class="headerlink" title="四、避免使用单例"></a>四、避免使用单例</h2><p>既然单例对局部作用域的状态有这么多的坏处，那么应该怎样避免使用它们呢？</p>
<p>重温上面的例子。既然我们的 thumbnail cache 的缓存状态是和具体的用户绑定的，那么定义一个 user 对象吧。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">User</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) ThumbnailCache * thumbnailCache;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">User</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">          _thumbnailCache = [[ThumbnailCache alloc] init];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>现在用一个对象来作为一个经过认证的用户会话的模型类，并且可以把所有和用户相关的状态存储在这个对象中。</p>
<p>现在假设我们有一个 VC 来展现好友列表：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FriendListVC</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUser:(User *)user; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们可以显式的把经过认证的 user 对象作为参数传递给这个 vc。这种把依赖性传递给依赖对象的技术正式的叫法是<a href="http://en.wikipedia.org/wiki/Dependency_injection" target="_blank" rel="noopener">依赖注入</a>，并且它有很多优点：</p>
<p>①、对于阅读这个 FriendListVC 头文件的人来说，可以很清楚的知道它只有在有登录用户的情况下才会被展示。</p>
<p>②、这个 FriendListVC 只要还在使用中，就可以强引用 user 对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     [_user.thumbnailCache cacheProfileImage:newImage forUserId:userId];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种后台任务仍然意义重大，当第一个实例失效时，应用其他地方的代码可以创建和使用一个全新的 User 对象，而不会阻塞用户交互。</p>
<p>为了更详细的说明一下第二点，让我们画一下在使用依赖注入之前和之后的对象图。</p>
<ol>
<li>假设 FriendListVC 是当前 window 的 root view controller。使用单例时，对象图看起来如下所示：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-5a3d085872ee313f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>vc 以及自定义的 imageView，都会和 sharedThumbnailCache 产生交互。</p>
<p>当用户登出后，清理 rootViewController 并且退出到登录页面：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d7ce97acfc9e7890.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这里的问题在于这个 FriendListVC 可能仍然在执行代码（由于后台操作的原因），并且可能因此仍然有一些调用被挂起到 sharedThumbnailCache 上。</p>
<ol start="2">
<li>使用依赖注入的对象图：</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-42f2c8e7764a543b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>简单起见，假设 UIApplicationDelegate 管理 User 的实例（在实际中，为了<a href="http://www.objc.io/issue-1/lighter-view-controllers.html" target="_blank" rel="noopener">简化</a> applicationDelegate 可能会把这些用户状态的管理工作交给另外一个对象来做）。当展现 FriendListVC 时，会传递进去一个 user 的引用。这个引用也会向下传递给 profileImageView。现在，当用户登出时，我们的对象图如下所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a00b35bf8a96f6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>这个对象图看起来和使用单例时很像。这有什么区别？</p>
<p>关键问题是作用域。在单例情况下，sharedThumbnailCache 仍然可以被程序的任意模块访问。假如用户快速的登录了一个新的账号。该用户也想看看他的好友列表，这也就意味着需要再一次的和 thumbnailCache 产生交互：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-b011ee68eba70df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当用户登录一个新账号，我们应该能够构建并且与全新的 ThumbnailCache 交互，而不需要再在销毁老的 thumbnailCache 上花费精力。基于对象管理的典型规则，旧的 vc 和老的 thumbnailCache 应该能够自己在后台延迟被清理掉。简而言之，我们应该隔离用户 A 相关联的状态和用户 B 相关联的状态：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f0268e3703574ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h2 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h2><p>在 iOS 开发的世界中，单例的使用是如此的普遍以至于我们有时候忘记了多年来在其他面向对象编程中学到的教训。</p>
<p>这一切的关键点在于，在面向对象编程中我们想要最小化可变状态的作用域。但是单例却站在了对立面，因为它们使可变的状态可以被程序中的任何地方访问。下一次使用单例时，希望能够好好考虑一下使用依赖注入作为替代方案。</p>
<h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://blog.csdn.net/zhengang007/article/details/70336612" target="_blank" rel="noopener">避免滥用单例</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/iOS 单例/">http://yoursite.com/2019/05/23/iOS 单例/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/iOS 内置图片瘦身/" class="pre">iOS 内置图片瘦身</a><a href="/2019/05/23/依赖注入/" class="next">依赖注入</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、单例介绍"><span class="toc-text">一、单例介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-单例的主要优点"><span class="toc-text">1.1 单例的主要优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-单例的主要缺点"><span class="toc-text">1.2 单例的主要缺点</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#二、单例的实现"><span class="toc-text">二、单例的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-实现方式一"><span class="toc-text">2.1 实现方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-实现方式二"><span class="toc-text">2.2 实现方式二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、单例的滥用"><span class="toc-text">三、单例的滥用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-全局状态"><span class="toc-text">3.1 全局状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-对象的生命周期"><span class="toc-text">3.2 对象的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、避免使用单例"><span class="toc-text">四、避免使用单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、结论"><span class="toc-text">五、结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、文章"><span class="toc-text">六、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/排序算法/">排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/01/算法设计策略/">算法设计策略</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/31/简单算法/">简单算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/31/iOS 项目/">iOS 项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 响应链/">iOS 响应链</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 页面流畅技巧/">iOS 页面流畅技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/isa 和 Class/">isa 和 Class</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Runtime/">Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/消息转发/">消息转发</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/图片加载和处理/">图片加载和处理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">9</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>