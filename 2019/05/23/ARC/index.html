<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ARC | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ARC</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">ARC</h1><div class="post-meta"><a href="/2019/05/23/ARC/#comments" class="comment-count"></a><p><span class="date">May 23, 2019</span><span><a href="/categories/iOS/" class="category">iOS</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、ARC"><a href="#一、ARC" class="headerlink" title="一、ARC"></a>一、ARC</h2><p>ARC 的想法来源于苹果在早期设计 Xcode 的 Analyzer 的时候，发现编译器在编译时可以帮助大家发现很多内存管理中的问题。后来苹果修改了一些内存管理代码的书写方式，干脆编译器在编译时把内存管理的代码都自动补上。</p>
<p><font color="#cc0000">ARC 是编译器特性，而不是运行时特性，更不是垃圾回收器（GC）</font>。</p>
<blockquote>
<p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p>
</blockquote>
<p>程序在编译的时候，编译器会分析源码中每个对象的生命周期，然后基于这些对象的生命周期，编译器帮我们在合适的地方插入retain、release 等代码以管理对象的引用计数，从而达到自动管理对象生命周期的目的。</p>
<p>所以 ARC 是工作在编译期的一种技术方案，这样的好处：</p>
<ol>
<li><p>编译之后，ARC 与 MRC 代码是没有什么差别的，所以二者可以<font color="#cc0000">在源码中共存</font>。</p>
</li>
<li><p>相对于垃圾回收这类内存管理方案，<font color="#cc0000">ARC 不会带来运行时的额外开销</font>，所以对于应用的运行效率不会有影响。相反的，由于ARC 能够深度分析每一个对象的生命周期，它能够做到比人工管理引用计数更加高效。例如在一个函数中，对一个对象刚开始有一个引用计数 +1 的操作，之后又紧接着有一个 -1 的操作，那么编译器就可以把这两个操作都优化掉。</p>
</li>
</ol>
<p>只有编译器是无法单独完成这一工作的，还需要 OC 运行时库的配合协助，因此 ARC 的实现工具主要包括：</p>
<ol>
<li>LLVM 编译器（clang 3.0 以上）</li>
<li>OC 运行时库 493.9 以上</li>
</ol>
<p>weak 变量能够在引用计数为 0 时被自动设置成 nil，显然是有运行时逻辑在工作的。</p>
<p>ARC 能够解决 iOS 开发中 90% 的内存管理问题，但是另外 10% 的内存管理问题是需要开发者处理的，这主要是与底层 Core Foundation 对象交互的部分，底层 Core Foundation 对象由于不在 ARC 的管理下，所以需要自己维护这些对象的引用计数。</p>
<h2 id="二、ARC-的开启和关闭"><a href="#二、ARC-的开启和关闭" class="headerlink" title="二、ARC 的开启和关闭"></a>二、ARC 的开启和关闭</h2><p>在 Targets -》Build Settings 中搜索 Automatic Reference Counting，可以修改它的布尔值，yes - 开启　no - 关闭。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-186571a065bdb139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p>
<p>如果需要对特定文件开启或关闭 ARC，可以在 Targets -》Build Phases -》Compile Sources，在里面找到对应文件，添加flag：</p>
<p>开启：-fobjc-arc  关闭：-fno-objc-arc</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-de31d9803c80902b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p>
<h2 id="三、ARC-的修饰符"><a href="#三、ARC-的修饰符" class="headerlink" title="三、ARC 的修饰符"></a>三、ARC 的修饰符</h2><p>主要提供了 4 种修饰符，他们分别是：__strong、__weak、__autoreleasing、__unsafe_unretained。</p>
<h3 id="3-1-strong"><a href="#3-1-strong" class="headerlink" title="3.1 __strong"></a>3.1 __strong</h3><p>强引用。相当于 @property 的 “strong”。所有对象只有当没有任何一个强引用指向（引用计数为 0）时，才会被释放。</p>
<blockquote>
<p>注意：如果在声明引用时不加修饰符，那么将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置 nil。</p>
</blockquote>
<p>使用 __strong 修饰变量的程序运行过程。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的模拟源代码为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">id <span class="keyword">object</span> = objc_msgSend(NSObjct, <span class="meta">@selector(alloc)</span>);</span><br><span class="line">objc_msgSend(<span class="keyword">object</span>, <span class="meta">@selector(init)</span>);</span><br><span class="line">objc_release(<span class="keyword">object</span>);</span><br></pre></td></tr></table></figure>
<p>对象变量生成时，分别调用 alloc 和 init 方法，对象变量作用域结束时调用 objc_release 方法释放对象变量，虽然 ARC 情况下不能使用 release 方法，但是由此可见编译器编译时在合适的地方插入了 release。</p>
<p>在使用 alloc、new、copy、mutableCopy 以外的方法生成对象变量方法时会有什么不同</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> object = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 array 的类方法转换后：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /*编译器的模拟代码*/</span><br><span class="line">    id object = objc_msgSend(<span class="name">NSMutableArray</span>, @selector(<span class="name">array</span>))<span class="comment">;</span></span><br><span class="line">    objc_retainAutoreleasedReturnValue(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_retainAutoreleasedReturnValue(object) 函数的作用：最优化程序运行。</p>
<p>自己持有（retain）对象的函数，但它持有的应为返回注册在 autoreleasepool 中对象的方法或函数的返回值。</p>
<p>objc_retainAutoreleasedReturnValue 函数与 objc_autoreleasedReturnValue 是成对出现的，现在看看 NSMutableArray 类的 array 类方法的编译器实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    <span class="keyword">return</span> [[NSMutableArray alloc] <span class="keyword">init</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的源代码。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, <span class="meta">@selector(alloc)</span>);</span><br><span class="line">    objc_msgSend(obj, <span class="meta">@selector(init)</span>);</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 objc_autoreleaseReturnValue 函数将对象注册在自动释放池 autoreleasepool 中并返回，但是与 objc_autorelease 函数不同的是，objc_autoreleaseReturnValue 函数一般不仅限于注册对象到 autoreleasepool 中去。</p>
<p>objc_autoreleaseReturnValue 与 objc_retainAutoreleasedReturnValue 的配合使用，可以不将对象注册到autoreleasepool 中而直接传递，达到最优化。</p>
<p>objc_autoreleaseReturnValue 函数会检查使用该函数的方法或者函数的调用方的执行命令列表，如果调用方在调用该函数或方法之后，紧接着调用了 objc_retainAutoreleasedReturnValue 函数，那么不再将对象注册到 autoreleasepool 中去，而直接将对象传递给调用方。</p>
<p>相比于 objc_retain 函数来说 objc_retainAutoreleasedReturnValue 函数在返回一个即使没有注册到autoreleasepool 中的对象，也能正确的获取对象。</p>
<h3 id="3-2-weak"><a href="#3-2-weak" class="headerlink" title="3.2 __weak"></a>3.2 __weak</h3><p>弱引用。相当于 @property 的 “weak”。弱引用不会影响对象的引用计数，即只要对象没有任何强引用指向，即使有 n 个弱引用对象指向也没用，该对象依然会被释放。</p>
<p>对象在被释放的同时，指向它的弱引用（weak）会自动被置 nil，这个技术叫 zeroing weak pointer。这样有效的防止无效指针、野指针的产生。__weak 一般用在 delegate 关系中防止循环引用或者用来修饰指向由 Interface Builder 编辑与生成的 UI 控件。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id _weak object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的模拟源代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id object;</span><br><span class="line">    id tmp = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">tmp</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    objc_initWeak(<span class="name">&amp;object</span>, tmp)<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">    objc_destoryWeak(<span class="name">&amp;object</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己生成并且持有的对象通过 objc_initWeak 函数赋值给 __weak 修饰符的变量，但是编译器判断并没有对其进行持有，因此该对象通过 objc_release 函数被释放和废弃。</p>
<p>随后通过 objc_destoryWeak 将引用废弃对象的附有 __weak 修饰符的变量置为 nil。</p>
<p>如果不是直接赋值，而是通过使用 __weak 修饰符来引用变量时。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak <span class="class"><span class="keyword">object</span> </span>= obj;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, <span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的模拟源代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器的模拟代码*/</span></span><br><span class="line">&#123;</span><br><span class="line">    id <span class="class"><span class="keyword">object</span></span>;</span><br><span class="line">    objc_initWeak(&amp;<span class="class"><span class="keyword">object</span>, <span class="title">obj</span>)</span>;</span><br><span class="line">    id temp = objc_loadWeakRetained(&amp;<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">    objc_autorelease(temp);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, temp);</span><br><span class="line">    objc_destoryWeak(&amp;<span class="class"><span class="keyword">object</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明显增加了 objc_loadWeakRetained 与 objc_autorelease 函数调用，他们的主要作用是：</p>
<ol>
<li>objc_loadWeakRetained 函数取出 __weak 修饰符变量引用的对象并且 retain</li>
<li>objc_autorelease 函数将引用的对象注册到 autoreleasepool 中。</li>
</ol>
<p>因此，使用 __weak 修饰符引用的对象都被注册到 autoreleasepool 中，在 @autoreleasepool 块结束之前都可以放心使用，大量使用 __weak 修饰符的变量，导致注册到 autoreleasepool 中的对象也大量地增加。所以在使用 __weak 修饰符引用的变量时，最好先暂时用 __strong 修饰符的变量进行引用后再使用。</p>
<p>2 种不能使用 __weak 修饰符的情况：</p>
<ul>
<li>重写了 retain/release 的类，例如 NSMachPort 类；</li>
<li>当 allowsWeakReference/retainWeakReference 实例方法返回 NO 时。</li>
</ul>
<h3 id="3-3-autoreleasing"><a href="#3-3-autoreleasing" class="headerlink" title="3.3 __autoreleasing"></a>3.3 __autoreleasing</h3><p>对象被加入到 autorelease pool，是会自动释放的引用，与 MRC 中 autorelease 的用法相同。定义 @property 时不能使用这个修饰符。</p>
<p>对于 alloc、new、copy、mutableCopy 的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@autoreleasepool</span>&#123;</span><br><span class="line">    id __autoreleasing <span class="keyword">object</span> = [[NSObject alloc] <span class="keyword">init</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的模拟源代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id pool = objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line">    id object = objc_msgSend(<span class="name">NSObjct</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">object</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    // 调用autorelease方法</span><br><span class="line">    objc_autorelease(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    id pool = objc_autoreleasePoolPop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSMutableArray 类中的 array 方法如何实现 autorelease 功能。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing object = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化后的模拟源代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /* 编译器的模拟代码 */</span><br><span class="line">    id pool = objc_autoreleasePoolPush()<span class="comment">;</span></span><br><span class="line">    id object = objc_msgSend(<span class="name">NSMutableArray</span>, @selector(<span class="name">array</span>))<span class="comment">;</span></span><br><span class="line">    objc_retainAutoreleasedReturnValue(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    // 调用 autorelease 方法</span><br><span class="line">    objc_autorelease(<span class="name">object</span>)<span class="comment">;</span></span><br><span class="line">    id pool = objc_autoreleasePoolPop()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了持有对象的方法从 alloc 变成了 objc_retainAutoreleasedReturnValue 函数，但是注册到 autoreleasepool 的方法没有变化，都是调用了 objc_autorelease 函数。</p>
<p>一个常见的误解是，在 ARC 中没有 autorelease，因为这样一个“自动释放”看起来好像有点多余。</p>
<p>这个误解可能源自于将 ARC 的“自动” 和 autorelease “自动” 的混淆。其实你只要看一下每个 iOS App 的 main.m 文件就能知道，autorelease 不仅好好的存在着，并且不需要再手工被创建，也不需要再显式得调用 [pool drain] 方法释放内存池。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下两行代码的意义是相同的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * str = [[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"China"</span>] autorelease];   <span class="comment">// MRC</span></span><br><span class="line"><span class="built_in">NSString</span> * __autoreleasing str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"China"</span>]; <span class="comment">// ARC</span></span><br></pre></td></tr></table></figure>
<p>__autoreleasing 在 ARC 中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。</p>
<blockquote>
<p>__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</p>
</blockquote>
<p>比如常见的 NSError 的使用：</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError * __autoreleasing <span class="keyword">error</span>;</span><br><span class="line"> </span><br><span class="line">// writeToFile方法中 <span class="keyword">error</span> 参数的类型为 (NSError *__autoreleasing *)）</span><br><span class="line">￼<span class="keyword">if</span> (![data writeToFile:<span class="keyword">filename</span> options:NSDataWritingAtomic <span class="keyword">error</span>:&amp;<span class="keyword">error</span>])  &#123; </span><br><span class="line">　　NSLog(@<span class="string">"Error: %@"</span>, <span class="keyword">error</span>.localizedDescription); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果 error 的修饰符为 strong，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个 __autoreleasing 类型的引用。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSError</span> * <span class="keyword">error</span>; </span><br><span class="line"><span class="type">NSError</span> * __autoreleasing tempError = <span class="keyword">error</span>;  <span class="comment">// 编译器添加</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (![data writeToFile:filename options:<span class="type">NSDataWritingAtomic</span> <span class="keyword">error</span>:&amp;tempError]) </span><br><span class="line">￼&#123; </span><br><span class="line">　　<span class="keyword">error</span> = tempError; <span class="comment">// 编译器添加 </span></span><br><span class="line">　　<span class="type">NSLog</span>(@<span class="string">"Error: %@"</span>, <span class="keyword">error</span>.localizedDescription); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免这种情况，提高效率，一般在定义 error 的时候将其声明为__autoreleasing 类型的：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSError</span> *__autoreleasing <span class="literal">error</span>;</span><br></pre></td></tr></table></figure>
<p>加上 __autoreleasing 之后，相当于在 MRC 中对返回值 error 做了如下事情：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*error = <span class="comment">[<span class="comment">[<span class="comment">[NSError alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure>
<p>*error 指向的对象在创建出来后，被放入到了 autoreleasing pool 中，等待使用结束后的自动释放，函数外 error 的使用者并不需要关心 *error 指向对象的释放。</p>
<p>另外，在 ARC 中，所有这种指针的指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为 __autoreleasing 类型。</p>
<p>比如下面的两段代码是等同的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">doSomething</span><span class="selector-pseudo">:(NSNumber</span> **)<span class="selector-tag">value</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// do something  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">doSomething</span><span class="selector-pseudo">:(NSNumber</span> * <span class="selector-tag">__autoreleasing</span> *)<span class="selector-tag">value</span></span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// do something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非显式得给 value 声明了 __strong，否则 value 默认就是 __autoreleasing 的。</p>
<p>最后一点，某些类的方法会隐式地使用自己的 autorelease pool，在这种时候使用 __autoreleasing 类型要特别小心。</p>
<p>比如 NSDictionary 的 - enumerateKeysAndObjectsUsingBlock: 方法会隐式地创建一个 autorelease pool.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">          <span class="comment">// do stuff  </span></span><br><span class="line">          <span class="keyword">if</span> (...)  &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">￼&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码实际类似于：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop)&#123;</span><br><span class="line">          <span class="keyword">@autoreleasepool</span>  <span class="comment">// 被隐式创建</span></span><br><span class="line">　　　　　　&#123;</span><br><span class="line">              <span class="keyword">if</span> (...) &#123;</span><br><span class="line">                    *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">              &#125;</span><br><span class="line">￼          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// *error 在这里已经被dict的做枚举遍历时创建的 autorelease pool 释放掉了 </span></span><br><span class="line">￼&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够正常的使用 *error，我们需要一个 strong 型的临时引用，在 dict 的枚举 block 中使用这个临时引用，保证引用指向的对象不会在出了 dict 的枚举 block 后被释放，正确的方式如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loopThroughDictionary:(<span class="built_in">NSDictionary</span> *)dict error:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">　　__block <span class="built_in">NSError</span> * tempError;  <span class="comment">// 加 __block 保证可以在 Block 内被修改  </span></span><br><span class="line">　　</span><br><span class="line">   [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123; </span><br><span class="line">　　　　</span><br><span class="line">      <span class="keyword">if</span> (...)  &#123; </span><br><span class="line">　　　　　　*tempError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Not Found"</span> ￼code:<span class="number">404</span> userInfo:<span class="literal">nil</span>]; </span><br><span class="line">　　　　&#125; ￼ </span><br><span class="line">　　&#125;] </span><br><span class="line">　　<span class="keyword">if</span> (error != <span class="literal">nil</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　*error = tempError; </span><br><span class="line">　　&#125; ￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-unsafe-unretained"><a href="#3-4-unsafe-unretained" class="headerlink" title="3.4 __unsafe_unretained"></a>3.4 __unsafe_unretained</h3><p>ARC 是在 iOS 5 引入的，而这个修饰符主要是为了在 ARC 刚发布时兼容 iOS 4 以及版本更低的设备，因为这些低版本的设备没有 weak pointer system，这个系统简单的理解就是上面讲 weak 时提到的，能够在 weak 引用指向对象被释放后，把引用值自动设为 nil。</p>
<p>相当于 @property 的 “unsafe_unretained”，实际可以将它理解为 MRC 时代的 assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然指向原来被释放的对象（所在的内存区域）。所以非常不安全。</p>
<p>现在可以完全忽略掉这个修饰符了，因为 iOS 4 早已退出历史舞台很多年。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __unsafe_unretained object = [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的模拟源代码。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     /*编译器的模拟代码*/</span><br><span class="line">    id object = objc_msgSend(<span class="name">NSObject</span>, @selector(<span class="name">alloc</span>))<span class="comment">;</span></span><br><span class="line">    objc_msgSend(<span class="name">object</span>, @selector(<span class="name">init</span>))<span class="comment">;</span></span><br><span class="line">    objc_release(<span class="name">tmp</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见通过 __unsafe_unretained 修饰的变量引用了对象但是并不持有对象，对象在释放和废弃后，并没有调用被 __unsafe_unretained 修饰的变量的 objc_destoryWeak 函数，因此该对象的悬垂指针被赋值给变量 object，导致引用变量 object 时发生崩溃。</p>
<h3 id="3-5-正确使用修饰符"><a href="#3-5-正确使用修饰符" class="headerlink" title="3.5 正确使用修饰符"></a>3.5 正确使用修饰符</h3><p>苹果的文档中明确地写道：</p>
<blockquote>
<p>You should decorate variables correctly. When using qualifiers in an object variable declaration,<br>the correct format is:<br>  ClassName * qualifier variableName;</p>
</blockquote>
<p>按照这个说明，要定义一个 weak 修饰的 NSString 引用，它的写法应该是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * __<span class="keyword">weak</span> str = <span class="string">@"Hello"</span>;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>而不应该是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *str = <span class="string">@"Hello"</span>;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：</p>
<blockquote>
<p>Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, see <a href="http://cdecl.org/" target="_blank" rel="noopener">http://cdecl.org/</a>.</p>
</blockquote>
<p>看来是苹果考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误。虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符。</p>
<h3 id="3-6-栈中指针默认值为-nil"><a href="#3-6-栈中指针默认值为-nil" class="headerlink" title="3.6 栈中指针默认值为 nil"></a>3.6 栈中指针默认值为 nil</h3><p>无论是被 strong、weak 还是 autoreleasing 修饰，声明在栈中的指针默认值都会是 nil。所有这类型的指针不用再初始化的时候置 nil 了。这个特性更加降低了“野指针”出现的可能性。</p>
<p>在 ARC 中，以下代码会输出 null 而不是 crash。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMethod </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * name;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、ARC-与-Block"><a href="#四、ARC-与-Block" class="headerlink" title="四、ARC 与 Block"></a>四、ARC 与 Block</h2><p>在手动管理内存时代，block 会隐式地对进入其作用域内的对象（或者说被 block 捕获的指针指向的对象）执行 retain 操作，来确保 block 使用到该对象时，能够正确的访问。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * myController = [[MyViewController alloc] init…]; </span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    <span class="comment">// 隐式地调用 [myController retain]; 造成循环引用</span></span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:myController animated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">    <span class="comment">// 调用[myController release];是在 MRC 中的一个常规写法，并不能解决上面循环引用的问题</span></span><br><span class="line">    [myController release]; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondVC</span> : <span class="title">UIViewController</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^ block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">&#123;</span><br><span class="line">    SecondVC * vc = [[SecondVC alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)vc.retainCount);</span><br><span class="line">    </span><br><span class="line">    vc.block = ^ &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)vc.retainCount);</span><br><span class="line">    &#125;;</span><br><span class="line">    vc.block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">26</span>:<span class="number">05.872092</span>+<span class="number">0800</span> Demo[<span class="number">49289</span>:<span class="number">1083433</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-11</span><span class="number">-16</span> <span class="number">10</span>:<span class="number">26</span>:<span class="number">05.872214</span>+<span class="number">0800</span> Demo[<span class="number">49289</span>:<span class="number">1083433</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>dismissBlock 调用了 [myController dismiss..] 方法，这时 dismissBlock 会对 myController 执行 retain 操作。</p>
<p>而作为 myController 的属性，myController 对 dismissBlock 也至少有一个 retain（一般准确讲是 copy），这时就出现了在内存管理中最糟糕的情况：循环引用。也就是说：相互持有对方。循环引用导致了 myController 和 dismissBlock 最终都不能被释放。</p>
<p>对 delegate 指针用 weak 就是为了避免这种问题。</p>
<p>不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-56f8ed9fe539a49f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p>
<p>我们一般用如下方法解决：给进入 block 的指针加一个 __block 修饰符。</p>
<p>这个 __block 在 MRC 时代有两个作用：</p>
<ul>
<li>说明变量可改</li>
<li>说明指针指向的对象不做隐式的 retain 操作</li>
</ul>
<p>除了静态变量和全局变量不需要加 __block 就可以在 block 中修改外，其他变量不加则不能在 block 中修改。</p>
<p>对代码做出修改，解决了循环引用的问题：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __block myController = [[MyViewController alloc] init…]; </span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    [myController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 之后正常的 release 或者 retain</span></span><br></pre></td></tr></table></figure>
<p>在 ARC 环境下，没有了 retain 和 release 等操作，情况也发生了改变：</p>
<blockquote>
<p>在任何情况下，__block 修饰符的作用只有上面的第一条：说明变量可改。即使加上了 __block 修饰符，一个被 block 捕获的强引用也依然是一个强引用。</p>
</blockquote>
<p>所以在 ARC 下，如果还按照 MRC 下的写法，添加 __block 是没有解决循环引用的问题。</p>
<p>代码修改如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block MyViewController * myController = [[MyViewController alloc] init…]<span class="comment">; </span></span><br><span class="line">myController.<span class="keyword">dismissBlock </span>=  ^(NSString * result) &#123;</span><br><span class="line">    [myController <span class="keyword">dismissViewControllerAnimated:YES </span>completion:nil]<span class="comment">;</span></span><br><span class="line">    myController = nil<span class="comment">;  // 注意这里，保证了 block 结束对 myController 强引用的解除</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在 block 中将捕获的指针置为 nil，保证了 dismissBlock 对 myController 强引用的解除，不过也同时解除了myController 指针对 myController 对象的强引用。</p>
<p>更好的方法就是使用 weak。（或者为了考虑 iOS4 的兼容性用 unsafe_unretained，具体用法和 weak 相同）</p>
<p>为了保证 dismissBlock 对 myController 没有强引用，我们可以定义一个临时的弱引用 weakMyViewController 来指向原myController 的对象，并把这个弱引用传入到 dismissBlock 内，这样就保证了 dismissBlock 对 myController 持有的是一个弱引用，而不是一个强引用。如此，继续修改代码如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __weak weakMyViewController = myController<span class="comment">;</span></span><br><span class="line">myController.<span class="keyword">dismissBlock </span>=  ^(NSString * result) &#123;</span><br><span class="line">    [weakMyViewController <span class="keyword">dismissViewControllerAnimated:YES </span>completion:nil]<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这样循环引用的问题就解决了，但是却引入了一个新的问题：由于传入 dismissBlock 的是一个弱引用，那么当 myController指向的对象在 dismissBlock 被调用前释放，那么 dismissBlock 就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。</p>
<p>为了保证在 dismissBlock 内能够访问到正确的 myController，我们在 dismissBlock 内新定义一个强引用strongMyController 来指向 weakMyController 指向的对象，这样多了一个强引用，就能保证这个 myController 对象不会在 dismissBlock 被调用前释放掉了。于是，对代码再次做出修改：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyViewController * __<span class="keyword">weak</span> weakMyController = myController;</span><br><span class="line"><span class="comment">// __weak typeof(myController) weakMyController = myController;</span></span><br><span class="line">myController.dismissBlock =  ^(<span class="built_in">NSString</span> * result) &#123;</span><br><span class="line">    MyViewController * strongMyController = weakMyController;</span><br><span class="line">    <span class="comment">// __strong typeof(weakMyController) strongMyController = weakMyController;</span></span><br><span class="line">    <span class="keyword">if</span> (strongMyController) &#123;</span><br><span class="line">         [strongMyController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>很多读者会有疑问，不是不希望 block 对原 myController 对象增加强引用么，这里为什么堂而皇之地在 block 内新定义了一个强引用，这个强引用不会造成循环引用么？</p>
<p>理解这个问题的关键在于被 block 捕获的引用和在 block 内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block 的实现原理，详细的内容可以参考其他的文章：<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" title="谈Objective-C block的实现" target="_blank" rel="noopener">谈Objective-C block的实现</a>、<a href="http://blog.csdn.net/hherima/article/details/38586101" target="_blank" rel="noopener">block 实现</a>、<a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">正确使用Block避免Cycle Retain和Crash</a>。</p>
<p>为了更清楚地说明问题，这里用一个简单的程序举例。如下程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *a = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> (^ block)() = ^() &#123;</span><br><span class="line">         <span class="keyword">int</span> *c = a;</span><br><span class="line">    &#125;;</span><br><span class="line">    block(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中，同为 int 型的指针，a 变量被 block 捕获，而 c 变量是在 block 内定义的。用 clang -rewrite-objc 命令处理后，可以看到如下代码。</p>
<p>原 main 函数：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int b = <span class="number">10</span>;</span><br><span class="line">    int *a = &amp;b;</span><br><span class="line">   </span><br><span class="line">    <span class="literal">void</span> (*block)() = (<span class="literal">void</span> (*)())&amp;__main_block_impl_0((<span class="literal">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a);</span><br><span class="line">    <span class="function"><span class="params">((<span class="literal">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block)</span>;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">return</span> 1;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>block 的结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc; </span><br><span class="line">    </span><br><span class="line">    int *a;  <span class="comment">// 被捕获的引用 a 出现在了 block 的结构体里面</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际执行的函数：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">__main_block_func_0</span><span class="params">(struct __main_block_impl_0 *__cself)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> *a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">     <span class="keyword">int</span> *c = a; <span class="comment">// 在 block 中声明的引用 c 在函数中声明，存在于函数栈上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清楚的看到，a 和 c 存在的位置完全不同，如果 block 存在于堆上（在 ARC 下 block 默认在堆上），那么 a 作为 block 结构体的一个成员，也自然会存在于堆上，而 c 无论如何，永远位于 block 内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c 在 block 的函数运行完毕，即会被释放，而 a 只有在 block 被从堆上释放的时候才会释放。</p>
<p>回到之前的示例，如果直接让 dismissBlock 捕获 myController 引用，那么这个引用会被复制后作为 dismissBlock 的成员变量存在于其所在的堆空间中，也就是为 dismissBlock 增加了一个指向 myController 对象的强引用，这就是造成循环引用的本质原因。</p>
<p>对于 MyViewController 的例子，dismissBlock 的结构体大概是这个样子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    MyViewController * __strong myController;  <span class="comment">// 被捕获的强引用 myController</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">         <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">         <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">         <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">         Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而给 dismissBlock 传入一个弱引用 weakMyController，这时 dismissBlock 的结构：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    MyViewController * __weak weakMyController;  <span class="comment">// 被捕获的弱引用 weakMyController</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_a, int flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 dismissBlock 内声明的强引用 strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，一直持有 myController 对象，但当函数执行完毕，strongMyController 即被销毁，于是它对 myController 对象的强引用被解除，这时 dismissBlock 对 myController 对象就不存在强引用关系了！</p>
<p>加入了 strongMyController 的函数大体会是这个样子：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">     MyViewController * <span class="variable">__strong</span> strongMyController = <span class="variable">__cself</span>-&gt;weakMyController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ARC 中，block 捕获的引用和 block 内声明的引用，存储空间与生命周期都是不同的。</p>
<p>实际上，在自动引用计数环境下，对 block 捕获对象的内存管理已经简化了很多，由于没有了 retain 和 release 等操作，实际只需要考虑循环引用的问题就行了。</p>
<h2 id="五、ARC-与-Toll-Free-Bridging"><a href="#五、ARC-与-Toll-Free-Bridging" class="headerlink" title="五、ARC 与 Toll-Free Bridging"></a>五、ARC 与 Toll-Free Bridging</h2><blockquote>
<p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called <em>toll-free bridging</em>, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message.</p>
</blockquote>
<p>Toll-Free Briding 保证了在程序中，可以方便和谐的使用 Core Foundation 类型的对象和 Objective-C 类型的对象。详细的内容可参考<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="noopener">官方文档</a>。以下是官方文档中给出的示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocale</span> * gbNSLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_GB"</span>];</span><br><span class="line"><span class="built_in">CFLocaleRef</span> gbCFLocale = (<span class="built_in">CFLocaleRef</span>) gbNSLocale;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfIdentifier = <span class="built_in">CFLocaleGetIdentifier</span> (gbCFLocale);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"cfIdentifier: %@"</span>, (<span class="built_in">NSString</span> *)cfIdentifier); <span class="comment">// logs: "cfIdentifier: en_GB"</span></span><br><span class="line"><span class="built_in">CFRelease</span>((<span class="built_in">CFLocaleRef</span>) gbNSLocale);</span><br><span class="line"><span class="built_in">CFLocaleRef</span> myCFLocale = <span class="built_in">CFLocaleCopyCurrent</span>();</span><br><span class="line"><span class="built_in">NSLocale</span> * myNSLocale = (<span class="built_in">NSLocale</span> *) myCFLocale;</span><br><span class="line">[myNSLocale autorelease];</span><br><span class="line"><span class="built_in">NSString</span> * nsIdentifier = [myNSLocale localeIdentifier];</span><br><span class="line"><span class="built_in">CFShow</span>((<span class="built_in">CFStringRef</span>) [<span class="string">@"nsIdentifier: "</span> stringByAppendingString:nsIdentifier]); <span class="comment">// logs identifier for current locale</span></span><br></pre></td></tr></table></figure>
<p>在 MRC 时代，由于 Objective-C 类型的对象和 Core Foundation 类型的对象都是相同的 retain 和 release 操作规则，所以Toll-Free Bridging 的使用比较简单，但是自从 ARC 加入后，Objective-C 类型的对象内存管理规则改变了，而 Core Foundation 依然是之前的机制，换句话说，Core Foundation 不支持 ARC。</p>
<p>这个时候就必须要考虑一个问题，在做 Core Foundation 与 Objective-C 类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用 Objective-C（也就是ARC）的规则，哪些对象用 Core Foundation 的规则（也就是 MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership 的改变。</p>
<blockquote>
<p>If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined in NSObject.h)</p>
</blockquote>
<p>于是苹果在引入 ARC 之后对 Toll-Free Bridging 的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。</p>
<h3 id="5-1-bridge"><a href="#5-1-bridge" class="headerlink" title="5.1 __bridge"></a>5.1 __bridge</h3><blockquote>
<p>只是声明类型转变，但是不做内存管理规则的转变。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> s = (__bridge <span class="built_in">CFStringRef</span>)[[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"Hi, %@!"</span>, name];</span><br></pre></td></tr></table></figure>
<p>只是 NSString 到 CFStringRef 的类型转化，但管理规则未变，依然要用 Objective-C 类型的 ARC 来管理 s，不能用CFRelease() 去释放 s。</p>
<h3 id="5-2-bridge-retained、CFBridgingRetain"><a href="#5-2-bridge-retained、CFBridgingRetain" class="headerlink" title="5.2 __bridge_retained、CFBridgingRetain()"></a>5.2 __bridge_retained、CFBridgingRetain()</h3><blockquote>
<p>将指针类型转变的同时，将内存管理的责任由原来的 Objective-C 交给 Core Foundation 来处理，也就是，将 ARC 转变为 MRC。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = [[NSString alloc] initWithFormat:@<span class="string">"Hi, %@!"</span>, name]<span class="comment">;</span></span><br><span class="line">￼CFStringRef <span class="built_in">s2</span> = (__bridge_retained CFStringRef)<span class="built_in">s1</span><span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">￼CFRelease(<span class="built_in">s2</span>)<span class="comment">;  // 注意在使用结束后释放</span></span><br></pre></td></tr></table></figure>
<p>在第二行做了转化，这时内存管理规则由 ARC 变成了 MRC，需要手动的来管理 s2 的内存，而对于 s1，即使将其置为 nil，也不能释放内存。</p>
<p>也可以写成：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString * <span class="built_in">s1</span> = [[NSString alloc] initWithFormat:@<span class="string">"Hi, %@!"</span>, name]<span class="comment">;</span></span><br><span class="line">￼CFStringRef <span class="built_in">s2</span> = (CFStringRef)CFBridgingRetain(<span class="built_in">s1</span>)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">￼CFRelease(<span class="built_in">s2</span>)<span class="comment">;  // 注意在使用结束后释放</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-bridge-transfer、CFBridgingRelease"><a href="#5-3-bridge-transfer、CFBridgingRelease" class="headerlink" title="5.3 __bridge_transfer、CFBridgingRelease()"></a>5.3 __bridge_transfer、CFBridgingRelease()</h3><blockquote>
<p>功能与 __bridge_retained 相反，表示将管理的责任由 Core Foundation 转交给 Objective-C，即将管理方式由MRC 转变为 ARC。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFStringRef</span> result = <span class="built_in">CFURLCreateStringByAddingPercentEscapes</span>(. . .);</span><br><span class="line">￼<span class="built_in">NSString</span> * s = (__bridge_transfer <span class="built_in">NSString</span> *)result; </span><br><span class="line"><span class="comment">// 或 NSString * s = (NSString *)CFBridgingRelease(result);</span></span><br><span class="line">￼<span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<p>这里将 result 的管理责任交给了 ARC 来处理，就不需要再显式地调用 CFRelease() 了。</p>
<p>这里和 ARC 中 4 个主要的修饰符 __strong、__weak、__autoreleasing… 不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但最好与官方的相同。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-77a3391ea512ac3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="arc"> </p>
<h2 id="六、ARC下获取引用计数"><a href="#六、ARC下获取引用计数" class="headerlink" title="六、ARC下获取引用计数"></a>六、ARC下获取引用计数</h2><h3 id="6-1-使用-KVC"><a href="#6-1-使用-KVC" class="headerlink" title="6.1 使用 KVC"></a>6.1 使用 KVC</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">obj</span> valueForKey:@<span class="string">"retainCount"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-使用私有-API"><a href="#6-2-使用私有-API" class="headerlink" title="6.2 使用私有 API"></a>6.2 使用私有 API</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXTERN int _objc_rootRetainCount(<span class="name">id</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">_objc_rootRetainCount(<span class="name">obj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这个不一定完全可信。Xcode 10.1 用的示例一直返回 1。</p>
<h3 id="6-3-使用-CFGetRetainCount"><a href="#6-3-使用-CFGetRetainCount" class="headerlink" title="6.3 使用 CFGetRetainCount"></a>6.3 使用 CFGetRetainCount</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFGetRetainCount((<span class="name">__bridge</span> CFTypeRef)(<span class="name">obj</span>))</span><br></pre></td></tr></table></figure>
<p>使用 Toll-Free-Bridging 将 OC 对象的内容管理转为 Core Foundation 对象。</p>
<h2 id="七、学习文章"><a href="#七、学习文章" class="headerlink" title="七、学习文章"></a>七、学习文章</h2><p><a href="https://www.cnblogs.com/flyFreeZn/p/4264220.html" target="_blank" rel="noopener">iOS 开发ARC内存管理技术要点</a><br><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" title="谈Objective-C block的实现" target="_blank" rel="noopener">谈 Objective-C block的实现</a><br><a href="http://blog.csdn.net/hherima/article/details/38586101" target="_blank" rel="noopener">block 的实现</a><br><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">正确使用 Block 避免Cycle Retain和Crash</a><br><a href="https://blog.csdn.net/geeklee609/article/details/82142337" target="_blank" rel="noopener">ARC 的实现原理</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/05/23/ARC/">http://yoursite.com/2019/05/23/ARC/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/05/23/property/" class="pre">property</a><a href="/2019/05/23/引用计数/" class="next">引用计数</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、ARC"><span class="toc-text">一、ARC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、ARC-的开启和关闭"><span class="toc-text">二、ARC 的开启和关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、ARC-的修饰符"><span class="toc-text">三、ARC 的修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-strong"><span class="toc-text">3.1 __strong</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-weak"><span class="toc-text">3.2 __weak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-autoreleasing"><span class="toc-text">3.3 __autoreleasing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-unsafe-unretained"><span class="toc-text">3.4 __unsafe_unretained</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-正确使用修饰符"><span class="toc-text">3.5 正确使用修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-栈中指针默认值为-nil"><span class="toc-text">3.6 栈中指针默认值为 nil</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、ARC-与-Block"><span class="toc-text">四、ARC 与 Block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、ARC-与-Toll-Free-Bridging"><span class="toc-text">五、ARC 与 Toll-Free Bridging</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-bridge"><span class="toc-text">5.1 __bridge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-bridge-retained、CFBridgingRetain"><span class="toc-text">5.2 __bridge_retained、CFBridgingRetain()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-bridge-transfer、CFBridgingRelease"><span class="toc-text">5.3 __bridge_transfer、CFBridgingRelease()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、ARC下获取引用计数"><span class="toc-text">六、ARC下获取引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-使用-KVC"><span class="toc-text">6.1 使用 KVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-使用私有-API"><span class="toc-text">6.2 使用私有 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-使用-CFGetRetainCount"><span class="toc-text">6.3 使用 CFGetRetainCount</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、学习文章"><span class="toc-text">七、学习文章</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>