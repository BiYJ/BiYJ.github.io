<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>mmap | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">mmap</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">mmap</h1><div class="post-meta"><a href="/2019/10/10/iOS/iOS原理/iOS mmap/#comments" class="comment-count"></a><p><span class="date">Oct 10, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、常规文件操作"><a href="#一、常规文件操作" class="headerlink" title="一、常规文件操作"></a>一、常规文件操作</h2><p>常规文件操作（read/write）有那几个重要步骤：</p>
<ol>
<li>进程发起读文件请求</li>
<li>内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode</li>
<li>inode 在 address_space 上查找要请求的文件页是否已经缓存在内核页高速缓冲中。如果存在，则直接返回这片文件页的内容</li>
<li>如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到内核页高速缓冲。之后再次发起读页面过程，进而将内核页高速缓冲中的数据发给用户进程</li>
</ol>
<p>需要注意的几点：</p>
<ol>
<li>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。由于页缓存处在内核空间，不能被用户进程直接寻址，所以需要将页缓存中数据页再次拷贝到内存对应的用户空间中</li>
<li>read/write 是系统调用很耗时，如下图，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，实际上完成了两次数据拷贝</li>
<li>如果两个进程都对磁盘中的一个文件内容进行访问，那么这个内容在物理内存中有三份：进程 A 的地址空间 + 进程 B 的地址空间 + 内核页高速缓冲空间</li>
<li>写操作也是一样，待写入的 buffer 在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝</li>
</ol>
<p><a href="https://www.jianshu.com/p/4f79680b54a4" target="_blank" rel="noopener">Linux 内核剖析</a></p>
<center><br><img src="http://dzliving.com/mmap_1.jpeg" alt><br></center>

<h2 id="二、mmap内存映射"><a href="#二、mmap内存映射" class="headerlink" title="二、mmap内存映射"></a>二、mmap内存映射</h2><h4 id="2-1-mmap-介绍"><a href="#2-1-mmap-介绍" class="headerlink" title="2.1 mmap 介绍"></a>2.1 mmap 介绍</h4><p>在日常开发中偶尔会遇到 mmap，它最常用到的场景是 <a href="https://github.com/Tencent/MMKV" target="_blank" rel="noopener">MMKV</a>，其次用到的是日志打印。虽然都已经被封装好，但也需要了解下 mmap 的基本原理和过程。</p>
<p>进程是 App 运行的基本单位，进程之间相对独立。iOS 系统中 <font color="#cc0000">App 运行的内存空间地址是虚拟空间地址，存储数据是在各自的沙盒</font>。</p>
<p>当我们在 App 中去读写沙盒中的文件时，我们会使用 NSFileManager 去查找文件，然后可以使用 NSData 去加载二进制数据。文件操作的更底层实现过程，是使用 linux 的 <code>read()</code>、<code>write()</code> 函数直接操作文件句柄（也叫文件描述符、fd）。</p>
<p>在操作系统层面，当 App 读取一个文件时，实际是有两步：</p>
<ol>
<li>将文件从磁盘读取到物理内存；</li>
<li>从系统空间拷贝到用户空间（可以认为是复制到系统给 App 统一分配的内存）。</li>
</ol>
<p>iOS 系统使用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fgdj0001%2Farticle%2Fdetails%2F80136364" target="_blank" rel="noopener">页缓存机制</a>，通过 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FMMU%2F4542218" target="_blank" rel="noopener">MMU</a>（Memory Management Unit）<font color="#cc0000">将虚拟内存地址和物理地址进行映射</font>，并且由于进程的地址空间和系统的地址空间不一样，所以还需要多一次拷贝。</p>
<p>而 mmap 将磁盘上文件的地址信息与进程用的虚拟逻辑地址进行映射，建立映射的过程与普通的内存读取不同：正常的是将文件拷贝到内存，<font color="#cc0000">mmap 只是建立映射而不会将文件加载到内存中</font>。</p>
<center><br><img src="http://dzliving.com/mmap_2.jpeg" alt><br></center>

<p>在内存映射的过程中，并没有实际的数据拷贝，文件没有被载入内存，只是逻辑上被放入了内存，具体到代码，就是建立并初始化了相关的数据结构（struct address_space），这个过程由系统调用 mmap() 实现，所以建立内存映射的效率很高。</p>
<p>既然建立内存映射没有进行实际的数据拷贝，那么进程又怎么能最终直接通过内存操作访问到硬盘上的文件呢？那就要看内存映射之后的几个相关的过程了。</p>
<p>mmap() 会返回一个指针 ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用 read 或 write 对文件进行读写，而只需要通过 ptr 就能够操作文件。但是 ptr 所指向的是一个逻辑地址，要操作其中的数据，必须通过 MMU 将逻辑地址转换成物理地址，如上图中过程 2 所示。这个过程与内存映射无关。</p>
<p>前面讲过，建立内存映射并没有实际拷贝数据，这时，MMU 在地址映射表中是无法找到与 ptr 相对应的物理地址的，也就是 MMU 失败，将产生一个缺页中断，缺页中断的中断响应函数会在 swap 中寻找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则会通过 mmap() 建立的映射关系，从硬盘上将文件读取到物理内存中，如上图中过程 3 所示。这个过程与内存映射无关。</p>
<p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘上，如图1中过程4所示。这个过程也与内存映射无关。</p>
<p>mmap 内存映射的实现过程，总的来说可以分为三个阶段：</p>
<ol>
<li>进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域</li>
<li>调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系</li>
<li>进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝</li>
</ol>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析mmap：是什么 为什么 怎么用</a></p>
<h4 id="2-2-适合的场景"><a href="#2-2-适合的场景" class="headerlink" title="2.2 适合的场景"></a>2.2 适合的场景</h4><ul>
<li>有一个很大的文件，因为映射有额外的性能消耗，所以适用于频繁读操作的场景；（单次使用的场景不建议使用）</li>
<li>有一个小文件，它的内容您想要立即读入内存并经常访问。这种技术最适合那些大小不超过几个虚拟内存页的文件。（页是地址空间的最小单位，虚拟页和物理页的大小是一样的，通常为 <font color="#cc0000">4KB</font>。）</li>
<li>需要在内存中缓存文件的特定部分。文件映射消除了缓存数据的需要，这使得系统磁盘缓存中的其他数据空间更大</li>
</ul>
<p>当随机访问一个非常大的文件时，通常最好只映射文件的一小部分。映射大文件的问题是文件会消耗活动内存。如果文件足够大，系统可能会被迫将其他部分的内存分页以加载文件。将多个文件映射到内存中会使这个问题更加复杂。</p>
<h4 id="2-3-不适合的场景"><a href="#2-3-不适合的场景" class="headerlink" title="2.3 不适合的场景"></a>2.3 不适合的场景</h4><ul>
<li>希望从开始到结束的顺序从头到尾读取一个文件</li>
<li>文件有几百兆字节或者更大。将大文件映射到内存中会快速地填充内存，并可能导致分页，这将抵消首先映射文件的好处。对于大型顺序读取操作，禁用磁盘缓存并将文件读入一个小内存缓冲区</li>
<li>该文件大于可用的连续虚拟内存地址空间。对于 64 位应用程序来说，这不是什么问题，但是对于 32 位应用程序来说，这是一个问题。32 位虚拟内存最大是 4GB，可以只映射部分。</li>
<li>因为每次操作内存会同步到磁盘，所以不适用于移动磁盘或者网络磁盘上的文件；</li>
<li>变长文件不适用；</li>
</ul>
<h2 id="三、iOS-中的-mmap"><a href="#三、iOS-中的-mmap" class="headerlink" title="三、iOS 中的 mmap"></a>三、iOS 中的 mmap</h2><p>以<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FPerformance%2FConceptual%2FFileSystem%2FArticles%2FMappingFiles.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2F20001990-CJBJFIDD" target="_blank" rel="noopener">官网的 demo</a> 为例，其他的代码很简明直接，核心就在于mmap函数。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  start  映射开始地址，设置 NULL 则让系统决定映射开始地址</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  length  映射区域的长度，单位是 Byte</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  prot  映射内存的保护标志，主要是读写相关，是位运算标志；（记得与下面fd对应句柄打开的设置一致）</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  flags  映射类型，通常是文件和共享类型</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  fd  文件句柄</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param</span>  off_toffset  被映射对象的起点偏移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span>* mmap(<span class="keyword">void</span>* start,size_t length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,off_t offset);</span><br><span class="line"></span><br><span class="line">*outDataPtr = mmap(NULL,</span><br><span class="line">                   size,</span><br><span class="line">                   PROT_READ|PROT_WRITE,</span><br><span class="line">                   MAP_FILE|MAP_SHARED,</span><br><span class="line">                   fileDescriptor,</span><br><span class="line">                   <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>用官网的代码做参考，写了一个读写的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MapFile(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName, <span class="keyword">void</span> ** outDataPtr, size_t * outDataLength, size_t appendSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> outError;</span><br><span class="line">    <span class="keyword">int</span> fileDescriptor;</span><br><span class="line">    <span class="keyword">struct</span> stat statInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return safe values on error.</span></span><br><span class="line">    outError = <span class="number">0</span>;</span><br><span class="line">    *outDataPtr = <span class="literal">NULL</span>;</span><br><span class="line">    *outDataLength = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Open the file.</span></span><br><span class="line">    fileDescriptor = open( inPathName, O_RDWR, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span>( fileDescriptor &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        outError = errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// We now know the file exists. Retrieve the file size.</span></span><br><span class="line">        <span class="keyword">if</span>( fstat( fileDescriptor, &amp;statInfo ) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            outError = errno;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ftruncate(fileDescriptor, statInfo.st_size + appendSize);</span><br><span class="line">            fsync(fileDescriptor);</span><br><span class="line">            *outDataPtr = mmap(<span class="literal">NULL</span>,</span><br><span class="line">                               statInfo.st_size + appendSize,</span><br><span class="line">                               PROT_READ|PROT_WRITE,</span><br><span class="line">                               MAP_FILE|MAP_SHARED,</span><br><span class="line">                               fileDescriptor,</span><br><span class="line">                               <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>( *outDataPtr == MAP_FAILED )</span><br><span class="line">            &#123;</span><br><span class="line">                outError = errno;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// On success, return the size of the mapped file.</span></span><br><span class="line">                *outDataLength = statInfo.st_size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Now close the file. The kernel doesn’t use our file descriptor.</span></span><br><span class="line">        close( fileDescriptor );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> outError;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProcessFile(<span class="keyword">const</span> <span class="keyword">char</span> * inPathName)</span><br><span class="line">&#123;</span><br><span class="line">    size_t dataLength;</span><br><span class="line">    <span class="keyword">void</span> * dataPtr;</span><br><span class="line">    <span class="keyword">char</span> *appendStr = <span class="string">" append_key"</span>;</span><br><span class="line">    <span class="keyword">int</span> appendSize = (<span class="keyword">int</span>)strlen(appendStr);</span><br><span class="line">    <span class="keyword">if</span>( MapFile(inPathName, &amp;dataPtr, &amp;dataLength, appendSize) == <span class="number">0</span>) &#123;</span><br><span class="line">        dataPtr = dataPtr + dataLength;</span><br><span class="line">        memcpy(dataPtr, appendStr, appendSize);</span><br><span class="line">        <span class="comment">// Unmap files</span></span><br><span class="line">        munmap(dataPtr, appendSize + dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> * path = [<span class="built_in">NSHomeDirectory</span>() stringByAppendingPathComponent:<span class="string">@"test.data"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"path: %@"</span>, path);</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"test str"</span>;</span><br><span class="line">    [str writeToFile:path atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    ProcessFile(path.UTF8String);</span><br><span class="line">    <span class="built_in">NSString</span> *result = [<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"result:%@"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS 的应用实例：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1066229" target="_blank" rel="noopener">MMKV–基于 mmap 的 iOS 高性能通用 key-value 组件</a></li>
<li><a href="http://blog.cnbang.net/tech/2578/" target="_blank" rel="noopener">iOS图片加载速度极限优化—FastImageCache解析</a></li>
<li><a href="https://github.com/path/FastImageCache" target="_blank" rel="noopener">FastImageCache</a></li>
</ul>
<h2 id="四、MMKV-和-mmap"><a href="#四、MMKV-和-mmap" class="headerlink" title="四、MMKV 和 mmap"></a>四、MMKV 和 mmap</h2><p>NSUserDefault 是常见的缓存工具，但是数据有时会同步不及时，比如说在 crash 前保存的值很容易出现保存失败的情况，在 App 重新启动之后读取不到保存的值。</p>
<p>MMKV 很好的解决了 NSUserDefault 的局限，具体的好处可以见<a href="https://links.jianshu.com/go?to=http%3A%2F%2F" target="_blank" rel="noopener">官网</a>。</p>
<p>但是同样由于其独特设计，在数据量较大、操作频繁的场景下，会产生性能问题。</p>
<p>这里的使用给出两个建议：</p>
<ol>
<li>不要全部用 defaultMMKV，根据业务大的类型做聚合，避免某一个 MMKV 数据过大，特别是对于某些只会出现一次的新手引导、红点之类的逻辑，尽可能按业务聚合，使用多个 MMKV 的对象；</li>
<li>对于需要频繁读写的数据，可以在内存持有一份数据缓存，<font color="#cc0000">必要时再更新</font>到 MMKV；</li>
</ol>
<h2 id="五、NSData-与-mmap"><a href="#五、NSData-与-mmap" class="headerlink" title="五、NSData 与 mmap"></a>五、NSData 与 mmap</h2><p>NSData 有一个静态方法和 mmap 有关系。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)dataWithContentsOfFile:(<span class="built_in">NSString</span> *)path options:(<span class="built_in">NSDataReadingOptions</span>)readOptionsMask error:(<span class="built_in">NSError</span> **)errorPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSDataReadingOptions</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint to map the file in if possible and safe. 在保证安全的前提下使用 mmap</span></span><br><span class="line">	<span class="built_in">NSDataReadingMappedIfSafe</span> =   <span class="number">1</span>UL &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	<span class="comment">// Hint to get the file not to be cached in the kernel. 不要缓存。如果该文件只会读取一次，这个设置可以提高性能</span></span><br><span class="line">    <span class="built_in">NSDataReadingUncached</span> = <span class="number">1</span>UL &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// Hint to map the file in if possible. This takes precedence over NSDataReadingMappedIfSafe if both are given.  总使用 mmap</span></span><br><span class="line">    <span class="built_in">NSDataReadingMappedAlways</span> API_AVAILABLE(macos(<span class="number">10.7</span>), ios(<span class="number">5.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>)) = <span class="number">1</span>UL &lt;&lt; <span class="number">3</span>,</span><br><span class="line">   	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>Mapped 的意思是使用 mmap，那么 ifSafe 是什么意思呢？</li>
<li>NSDataReadingMappedIfSafe 和 NSDataReadingMappedAlways 有什么区别？</li>
</ol>
<p>如果使用 mmap，则在 NSData 的生命周期内，都不能删除对应的文件。</p>
<p>如果文件是在固定磁盘，非可移动磁盘、网络磁盘，则满足 NSDataReadingMappedIfSafe。对 iOS 而言，这个 NSDataReadingMappedIfSafe = NSDataReadingMappedAlways。</p>
<blockquote>
<p>那什么情况下应该用对应的参数？</p>
</blockquote>
<p>如果文件很大，直接使用 <code>dataWithContentsOfFile</code> 方法，会导致 load 整个文件，出现内存占用过多的情况；此时用 NSDataReadingMappedIfSafe，则会使用 mmap 建立文件映射，减少内存的占用。</p>
<p>使用场景：视频加载。视频文件通常比较大，但是使用的过程中不会同时读取整个视频文件的内容，可以使用 mmap 优化。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><blockquote>
<p>mmap 就是文件的内存映射。</p>
</blockquote>
<p>通常读取文件是将文件读取到内存，会占用真正的物理内存；而 mmap 是用进程的内存虚拟地址空间去映射实际的文件中，这个过程由操作系统处理。mmap 不会为文件分配物理内存，而是相当于将内存地址指向文件的磁盘地址，后续对这些内存进行的读写操作，会由操作系统同步到磁盘上的文件。</p>
<p>iOS 中使用 mmap 可以用 c 方法的 mmap()，也可以使用 NSData 的接口带上NSDataReadingMappedIfSafe 参数。前者自由度更大，后者用于读取数据。</p>
<h2 id="七、文章"><a href="#七、文章" class="headerlink" title="七、文章"></a>七、文章</h2><p><a href="https://www.jianshu.com/u/815d10a4bdce" target="_blank" rel="noopener">落影loyinglin</a> &amp; <a href="https://www.jianshu.com/p/516e7ff6f251" target="_blank" rel="noopener">iOS的文件内存映射——mmap</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FPerformance%2FConceptual%2FFileSystem%2FArticles%2FMappingFiles.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2F20001990-CJBJFIDD" target="_blank" rel="noopener">mmap 苹果官方文档</a><br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.openradar.me%2F12254262" target="_blank" rel="noopener">NSDataReadingMappedIfSafe</a><br><a href="https://www.jianshu.com/u/20fbcc23dce5" target="_blank" rel="noopener">小凉介</a> &amp; <a href="https://www.jianshu.com/p/13f254cf58a7" target="_blank" rel="noopener">iOS内存映射mmap详解</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fgdj0001%2Farticle%2Fdetails%2F80136364" target="_blank" rel="noopener">linux中的页缓存和文件IO</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fhuxiao-tee%2Fp%2F4657851.html" target="_blank" rel="noopener">从内核文件系统看文件读写过程</a><br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fjoejames%2Farticle%2Fdetails%2F37958017" target="_blank" rel="noopener">linux内存映射mmap原理分析</a><br><a href="http://ju.outofmemory.cn/entry/224106" target="_blank" rel="noopener">mmap实例及原理分析</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/10/10/iOS/iOS原理/iOS mmap/">http://yoursite.com/2019/10/10/iOS/iOS原理/iOS mmap/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/10/10/IT/linux 中的页缓存和文件 IO/" class="pre">linux 中的页缓存和文件 IO</a><a href="/2019/09/16/iOS/iOS媒体/图片处理/" class="next">图片处理</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、常规文件操作"><span class="toc-text">一、常规文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、mmap内存映射"><span class="toc-text">二、mmap内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-mmap-介绍"><span class="toc-text">2.1 mmap 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-适合的场景"><span class="toc-text">2.2 适合的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-不适合的场景"><span class="toc-text">2.3 不适合的场景</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#三、iOS-中的-mmap"><span class="toc-text">三、iOS 中的 mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、MMKV-和-mmap"><span class="toc-text">四、MMKV 和 mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、NSData-与-mmap"><span class="toc-text">五、NSData 与 mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、总结"><span class="toc-text">六、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、文章"><span class="toc-text">七、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/">iOS UmbrellaFramework</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/">iOS umbrella header</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS媒体/iOS 图片/">iOS 图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS优化/iOS 优化实例/">iOS 优化实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS原理/iOS 操作系统架构/">iOS 操作系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS架构/iOS 网络层设计/">iOS网络层设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS 类簇/">iOS 类簇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS OCR/">iOS OCR</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS IM/">iOS IM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/iOS/iOS原理/iOS 推送/">iOS 推送</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT/">IT</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL/">OpenGL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS动画/">iOS动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS媒体/">iOS媒体</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS安全/">iOS安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">5</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>