<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Crash | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Crash</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Crash</h1><div class="post-meta"><a href="/2019/10/24/iOS/iOS优化/Crash/#comments" class="comment-count"></a><p><span class="date">Oct 24, 2019</span><span><a href="/categories/iOS优化/" class="category">iOS优化</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、Crash类型"><a href="#一、Crash类型" class="headerlink" title="一、Crash类型"></a>一、Crash类型</h2><p>crash 一般产生自 iOS 的微内核 Mach，然后在 BSD 层转换成 UNIX SIGABRT 信号，以标准 POSIX 信号的形式提供给用户。NSException 是使用者在处理 App 逻辑时，用编程的方法抛出。</p>
<p>iOS 端的 crash 分为三类：</p>
<ul>
<li>Mach 异常：EXC_CRASH</li>
<li>UNIX 信号：SIGABRT</li>
<li>系统崩溃而引起的程序 NSException 异常退出</li>
</ul>
<p><a href="https://cnbin.github.io/blog/2016/03/15/ioszhong-de-beng-kui-lei-xing/" target="_blank" rel="noopener">常见的 iOS 崩溃类型</a>有：</p>
<ol>
<li><p>EXC_BAD_ACCESS</p>
<blockquote>
<p>在访问一个已经释放的对象或向它发送消息时，就会出现 EXC_BAD_ACCESS。</p>
</blockquote>
<p> 造成 EXC_BAD_ACCESS 最常见的原因，是在初始化变量时用错了所有权修饰符，这会导致对象过早地被释放。例如，一个 NSArray 属性的所有权修饰符设成了 assign 而不是 strong。</p>
<p> 这个崩溃发生时，查看崩溃日志，往往得不到有用的栈信息。可以通过 NSZombieEnabled 来解决。</p>
<p> NSZombieEnabled 是一个环境变量，用来调试与内存相关的问题，跟踪对象的释放过程。启用之后，它会在对象调用 dealloc 时，也就是在引用计数降到 0，用一个僵尸实现将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。</p>
<p> 所以，当在应用中启用 NSZombie 而不是让应用直接崩溃时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接收到的消息，然后跳入调试器，这样就可以查看到底哪里出了问题。 启用如图所示：</p>
 <center><br> <img src="http://dzliving.com/ZombieEnabled.png" alt><br> </center>
</li>
<li><p>SIGSEGV</p>
<blockquote>
<p>段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。</p>
</blockquote>
<p> 当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。</p>
<p> 当要读取保存在 RAM 中的数据，而该位置的 RAM 硬件有问题时，会收到 SIGSEGV，这种情况并不常见。下面两种情况更多出现：</p>
<ul>
<li>当应用中的某个指针指向代码页并试图修改指向位置的值；</li>
<li><p>当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值</p>
<p>SIGSEGV 错误调试起来更困难，而导致 SIGSEGV 的最常见原因是<font color="#cc0000">不正确的类型转换</font>。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到 SIGSEGV。</p>
</li>
</ul>
</li>
<li><p>SIGBUS</p>
<blockquote>
<p>总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。</p>
</blockquote>
<p> 也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV 和 SIGBUS 都 EXC_BAD_ACCESS 的子类型。</p>
</li>
<li><p>SIGTRAP</p>
<blockquote>
<p>SIGTRAP 代表陷阱信号。</p>
</blockquote>
<p> 它并不是一个真正的崩溃信号。它会在处理器执行 trap 指令发送。LLDB 调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的 SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。</p>
</li>
<li><p>EXC_ARITHETIC</p>
<blockquote>
<p>当要作除零运算时，应用会收到 EXC_ARITHMETIC 信号。</p>
</blockquote>
<p> 这个错误应该很容易解决。</p>
</li>
<li><p>SIGILL</p>
<blockquote>
<p>SIGILL 代表 signal illegal instruction(非法指令信号)。</p>
</blockquote>
<p> 当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是 EXC_BAD_INSTRUCTION 而不是SIGILL，虽然它们是一回事，不过 EXC_* 等同于此信号不依赖体系结构。</p>
</li>
<li><p>SIGABRT</p>
<blockquote>
<p>SIGABRT 代表 SIGNAL ABORT（中止信号）。</p>
</blockquote>
<p> 当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d 或 UIKit 等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用 C 函数 abort（由它来发送此信号）。</p>
<p> 当 SIGABRT 出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在 LLDB 控制台上键入 <code>bt</code> 命令打印出回溯信息。</p>
</li>
<li><p>看门狗超时</p>
<p> 这种崩溃通常比较容易分辨，因为错误码是固定的 0x8badf00d。（程序员幽默的把它读作 Ate Bad Food。）在 iOS 上，它经常出现在执行一个同步网络调用而阻塞主线程的情况。因此，永远不要进行同步网络调用。</p>
</li>
</ol>
<h2 id="二、Crash捕获"><a href="#二、Crash捕获" class="headerlink" title="二、Crash捕获"></a>二、Crash捕获</h2><p>日常开发中，可以使用的 crash 收集方式有：</p>
<ul>
<li>第三方平台：Fabric、友盟、腾讯 Bugly、<a href="https://www.flurry.com/" target="_blank" rel="noopener">Flurry</a>、<a href="https://www.jianshu.com/p/ee5ccb0d39af" target="_blank" rel="noopener">Crashlytics</a> 等，数据会上传到这些平台</li>
<li>第三方工具：KSCrash、plcrashreporter 等，可自行处理收集的 crash</li>
<li>自定义捕获 + 堆栈符号化</li>
</ul>
<p>本文主要讨论自定义捕获。</p>
<h4 id="1-1-Mach-异常捕获"><a href="#1-1-Mach-异常捕获" class="headerlink" title="1.1 Mach 异常捕获"></a>1.1 Mach 异常捕获</h4><p>如果想要做 mach 异常捕获，需要注册一个异常端口，这个异常端口会对当前任务的所有线程有效，如果想要针对单个线程，可以通过 thread_set_exception_ports 注册自己的异常端口，发生异常时，首先会将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，当我们捕获异常时，就可以做一些自己的工作，比如，当前堆栈收集等。</p>
<h4 id="1-2-NSException-异常捕获"><a href="#1-2-NSException-异常捕获" class="headerlink" title="1.2 NSException 异常捕获"></a>1.2 NSException 异常捕获</h4><blockquote>
<p>NSException 异常是 OC 代码导致的 crash。</p>
</blockquote>
<p>NSException 异常和 Signal 信号异常，这两类都可以通过<font color="#cc0000">注册相关函数</font>来捕获。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存注册的 exception 捕获方法</span></span><br><span class="line"><span class="built_in">NSUncaughtExceptionHandler</span> * oldExceptionHandler;</span><br><span class="line"><span class="comment">// 自定义的 exception 异常处理</span></span><br><span class="line"><span class="keyword">void</span> ExceptionHandler(<span class="built_in">NSException</span> * exception);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RegisterExceptionHandler() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">NSGetUncaughtExceptionHandler</span>() != ExceptionHandler) &#123;</span><br><span class="line">        oldExceptionHandler = <span class="built_in">NSGetUncaughtExceptionHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSSetUncaughtExceptionHandler</span>(ExceptionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSSetUncaughtExceptionHandler 用来做异常处理，功能非常有限。引起崩溃的大多数原因如：内存访问错误、重复释放等错误，它就无能为力了，因为这种错误它抛出的是 Signal。</p>
<p>同时值得注意</p>
<blockquote>
<p>如果一个应用中注册了多个 crash 收集组件，必然会存在冲突问题。</p>
</blockquote>
<p>这个时候，我们需要在注册之前判断是否已经注册过 handler，如果有注册过，需要把之前注册的 handler函数指针保存，待处理完 crash 后，再把对应的 handler 抛出去。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  exception 崩溃处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> ExceptionHandler(<span class="built_in">NSException</span> * exception)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使 UncaughtExceptionCount 递增</span></span><br><span class="line">    int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超出允许捕获错误的次数</span></span><br><span class="line">    <span class="keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取调用堆栈</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> * userInfo = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:[exception userInfo]];</span><br><span class="line">    userInfo[kUncaughtCallStackKey] = [exception callStackSymbols];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSException</span> * exp = [<span class="built_in">NSException</span> exceptionWithName:exception.name</span><br><span class="line">                                                reason:exception.reason</span><br><span class="line">                                              userInfo:userInfo];</span><br><span class="line">    <span class="comment">// 在主线程中执行方法</span></span><br><span class="line">    [[[UncaughtExceptionHandler alloc] init] performSelectorOnMainThread:<span class="keyword">@selector</span>(dealException:)</span><br><span class="line">                                                              withObject:exp</span><br><span class="line">                                                           waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用保存的 handler</span></span><br><span class="line">    <span class="keyword">if</span> (oldExceptionHandler) &#123;</span><br><span class="line">        oldExceptionHandler(exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-Signal-信号捕获"><a href="#1-3-Signal-信号捕获" class="headerlink" title="1.3 Signal 信号捕获"></a>1.3 Signal 信号捕获</h4><blockquote>
<p>Signal 信号是由 iOS 底层 mach 信号异常转换后以 signal 信号抛出的异常。</p>
</blockquote>
<p>既然是<font color="#cc0000">兼容 posix 标准</font>的异常，我们同样可以通过 sigaction 函数注册对应的信号。</p>
<p>因为 signal 信号有很多，有些信号在 iOS 应用中也不会产生，我们只需要注册常见的几类信号：</p>
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">值</th>
<th style="text-align:center">介绍</th>
<th style="text-align:center">场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SIGILL</td>
<td style="text-align:center">4</td>
<td style="text-align:center">非法指令</td>
<td style="text-align:center">1. 执行了非法指令. <br>2. 通常是因为可执行文件本身出现错误或者试图执行数据段. <br>3. 堆栈溢出时也有可能产生这个信号.</td>
</tr>
<tr>
<td style="text-align:center">SIGABRT</td>
<td style="text-align:center">6</td>
<td style="text-align:center">调用abort</td>
<td style="text-align:center">程序自己发现错误并调用 abort 时产生，一些 C 库函数（如：strlen）</td>
</tr>
<tr>
<td style="text-align:center">SIGSFPE</td>
<td style="text-align:center">8</td>
<td style="text-align:center">浮点运算错误</td>
<td style="text-align:center">如：除 0 操作</td>
</tr>
<tr>
<td style="text-align:center">SIGSEGV</td>
<td style="text-align:center">11</td>
<td style="text-align:center">段非法错误</td>
<td style="text-align:center">1. 试图访问未分配给自己的内存<br>2. 或试图往没有写权限的内存地址写数据<br>3. 空指针<br>4. 数组越界<br>5. 栈溢出等</td>
</tr>
</tbody>
</table>
<p>下面注册一个 SIGABRT 信号，在注册 handler 之前，需要保存之前注册的 hander:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* SignalHandlerClass)</span><span class="params">(<span class="keyword">int</span>, struct __siginfo *, <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已注册的 singal 捕获方法</span></span><br><span class="line">SignalHandlerClass oldSignalHandler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MySignalHandler</span><span class="params">(<span class="keyword">int</span> signal, <span class="keyword">siginfo_t</span>* info, <span class="keyword">void</span>* context)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something。。。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (signal == SIGABRT) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (oldSignalHandler) &#123;</span><br><span class="line">	        oldSignalHandler(signal, info, context);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerSignalHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取已注册的 handler</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">old_action</span>;</span></span><br><span class="line">    sigaction(SIGABRT, <span class="literal">NULL</span>, &amp;old_action);</span><br><span class="line">    <span class="keyword">if</span> (old_action.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">        SignalHandlerClass handler = old_action.sa_sigaction;</span><br><span class="line">        <span class="keyword">if</span> (handler != MySignalHandler) &#123;</span><br><span class="line">            oldSignalHandler = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>;</span></span><br><span class="line">    action.sa_sigaction = MySignalHandler;</span><br><span class="line">    action.sa_flags = SA_NODEFER | SA_SIGINFO;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask);</span><br><span class="line">    sigaction(signal, &amp;action, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、收集调用堆栈"><a href="#三、收集调用堆栈" class="headerlink" title="三、收集调用堆栈"></a>三、收集调用堆栈</h2><p>调用堆栈的收集我们可以利用系统 api，也可以参考 PLCrashRepoter 等第三方实现获取所有线程堆栈。使用系统 api 关键代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)backtrace</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  指针列表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ①、backtrace 用来获取当前线程的调用堆栈，获取的信息存放在这里的 callstack 中</span></span><br><span class="line"><span class="comment">        ②、128 用来指定当前的 buffer 中可以保存多少个 void* 元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> * callstack[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回值是实际获取的指针个数</span></span><br><span class="line">    <span class="keyword">int</span> frames = backtrace(callstack, <span class="number">128</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// backtrace_symbols 将从 backtrace 函数获取的信息转化为一个字符串数组，每个字符串包含了一个相对于 callstack 中对应元素的可打印信息，包括函数名、偏移地址、实际返回地址。</span></span><br><span class="line">    <span class="comment">// 返回一个指向字符串数组的指针</span></span><br><span class="line">    <span class="keyword">char</span> **strs = backtrace_symbols(callstack, frames);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> * backtrace = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frames];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; frames; i++) &#123;</span><br><span class="line">        [backtrace addObject:[<span class="built_in">NSString</span> stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> backtrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、堆栈符号化"><a href="#四、堆栈符号化" class="headerlink" title="四、堆栈符号化"></a>四、堆栈符号化</h2><p>通过系统 api 获取的堆栈信息可能只是一串内存地址，很难从中获取有用的信息协助排查问题，因此，需要对堆栈信息符号化。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未符号化前</span></span><br><span class="line">Thread <span class="number">0</span> <span class="string">name:</span>  Dispatch <span class="string">queue:</span> com.apple.main-thread</span><br><span class="line">Thread <span class="number">0</span> <span class="string">Crashed:</span></span><br><span class="line"><span class="number">0</span>   libobjc.A.dylib                 <span class="number">0x000000018b816f30</span> <span class="number">0x18b7fc000</span> + <span class="number">110384</span> (objc_msgSend + <span class="number">16</span>)</span><br><span class="line"><span class="number">1</span>   UIKit                           <span class="number">0x0000000192e0a79c</span> <span class="number">0x192c05000</span> + <span class="number">2119580</span> (&lt;redacted&gt; + <span class="number">72</span>)</span><br><span class="line"><span class="number">2</span>   UIKit                           <span class="number">0x0000000192c4db48</span> <span class="number">0x192c05000</span> + <span class="number">297800</span> (&lt;redacted&gt; + <span class="number">312</span>)</span><br><span class="line"><span class="number">3</span>   UIKit                           <span class="number">0x0000000192c4d988</span> <span class="number">0x192c05000</span> + <span class="number">297352</span> (&lt;redacted&gt; + <span class="number">160</span>)</span><br><span class="line"><span class="number">4</span>   QuartzCore                      <span class="number">0x00000001900d6404</span> <span class="number">0x18ffc5000</span> + <span class="number">1119236</span> (&lt;redacted&gt; + <span class="number">260</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号化后</span></span><br><span class="line">Thread <span class="number">0</span> <span class="string">name:</span>  Dispatch <span class="string">queue:</span> com.apple.main-thread</span><br><span class="line">Thread <span class="number">0</span> <span class="string">Crashed:</span></span><br><span class="line"><span class="number">0</span>   libobjc.A.dylib                 <span class="number">0x000000018b816f30</span> objc_msgSend + <span class="number">16</span></span><br><span class="line"><span class="number">1</span>   UIKit                           <span class="number">0x0000000192e0a79c</span> -[UISearchDisplayController _sendDelegateDidBeginDidEndSearch] + <span class="number">72</span></span><br><span class="line"><span class="number">2</span>   UIKit                           <span class="number">0x0000000192c4db48</span> -[UIViewAnimationState <span class="string">sendDelegateAnimationDidStop:</span><span class="string">finished:</span>] + <span class="number">312</span></span><br><span class="line"><span class="number">3</span>   UIKit                           <span class="number">0x0000000192c4d988</span> -[UIViewAnimationState <span class="string">animationDidStop:</span><span class="string">finished:</span>] + <span class="number">160</span></span><br><span class="line"><span class="number">4</span>   QuartzCore                      <span class="number">0x00000001900d6404</span> <span class="string">CA:</span>:<span class="string">Layer:</span>:run_animation_callbacks(<span class="keyword">void</span>*) + <span class="number">260</span></span><br></pre></td></tr></table></figure>
<p>符号化的思路是找到当前应用对于的 <font color="#cc0000">dsym 符号表文件</font>，利用 symbolicatecrash（Xcode 的 Organizer 内置了）、dwarfdump，atos 等工具还原 crash 堆栈内存地址对应的符号名。需要注意，如果应用中使用了自己或第三方的动态库，应用崩溃在动态库 Image 而不是主程序 Image 中，我们需要有对应动态库的 dsym 符号表才能符号化。</p>
<p>思路明确之后，接下来面临的是两个问题。一个问题是如何把当前 crash 的应用和 dsym 符号表对应上。另一个问题是如何通过内存地址符号化。在解决这两个问题之前，我们需要先了解可执行文件的二进制格式和加载过程。</p>
<h4 id="4-1-Mach-O文件格式"><a href="#4-1-Mach-O文件格式" class="headerlink" title="4.1 Mach-O文件格式"></a>4.1 Mach-O文件格式</h4><p>不同操作系统都会定义不同的可执行文件格式。如 Linux平台的 ELF 格式，Windows 平台的 PE 格式，iOS 的可执行文件格式被称作 Mach-O。可执行文件、动态库、dsym 文件都是这种文件格式。</p>
<p>下图是官方的 Mach-O 格式结构：</p>
<center><br><img src="http://dzliving.com/MachO_1.png" alt="Mach-O文件格式"><br></center>

<p>可以看到，Mach-O 文件分为三部分。</p>
<ol>
<li><p><strong>header</strong></p>
<p> hander 定义了文件的基本信息，包括文件大小、文件类型、使用的平台等信息。我们可以从 loader.h 头文件中找到相关定义：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit mach header appears at the very beginning of object files for</span></span><br><span class="line"><span class="comment"> * 64-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;      <span class="comment">/* mach magic number identifier */</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>  cputype;    <span class="comment">/* cpu specifier */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>   cpusubtype; <span class="comment">/* machine specifier */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filetype;   <span class="comment">/* type of file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    ncmds;      <span class="comment">/* number of load commands */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    sizeofcmds; <span class="comment">/* the size of all the load commands */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;      <span class="comment">/* flags */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved;   <span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>load commands</strong></p>
<p> 这一部分定义了详细的加载指令，指明如何加载到内存。</p>
<p> 从头文件定义可以看到，基础的 load_command 结构体只包含了 cmd 以及 cmdsize。通过 cmd 类型，可以转义成不同类型的 load command 结构体：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;       <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;   <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据部分</strong></p>
<p> 包括了代码段、数据段、符号表等具体的二进制数据。</p>
<p> 我们可以用 otool 查看二进制文件的具体内容，更直观的，可以用 Mach-O View 来浏览可执行文件的具体内容。</p>
<p> 下图是一个可执行文件与其所对应的符号表文件。可执行文件的 load command 比较多，里面包含了有代码段、数据段、函数入口、加载动态库等指令。其中的 LC_UUID 字段和符号表中的 LC_UUID 是完全对应的，也就是说，可以<font color="#cc0000">通过 UUID 字段匹配可执行文件和 dsym 符号表</font>。</p>
</li>
</ol>
<center><br><img src="http://dzliving.com/MachO_2.png" alt="可执行文件"><br><img src="http://dzliving.com/MachO_3.png" alt="符号表文件"><br></center>

<h4 id="4-2-可执行文件加载过程"><a href="#4-2-可执行文件加载过程" class="headerlink" title="4.2 可执行文件加载过程"></a>4.2 可执行文件加载过程</h4><p>一个 iOS 应用的加载过程是这样的：</p>
<ol>
<li>首先，由内核加载可执行文件（Mach-O），并从中获得 dyld 的路径。</li>
<li>然后加载 dyld，由 dyld 接管动态库加载，符号绑定等工作，runtime 的初始化工作也在这一阶段进行。</li>
<li>最后 dyld 调用 main 函数，这样便来到了 main 函数入口。</li>
</ol>
<p>在这个过程中，操作系统为了安全考虑，使用了 <font color="#cc0000">ASLR</font> 技术。地址空间布局随机化(Address space layout randomization)，就是每次应用加载时，使用随机的一个地址空间，这样能有效防止被攻击。</p>
<p>VM Address 是编译后 Image 的起始位置，Load Address 是在运行时加载到虚拟内存的起始位置，Slide 是加载到内存的偏移，这个偏移值是一个随机值，每次运行都不相同，有下面公式：</p>
<blockquote>
<p>Load Address = VM Address + Slide</p>
</blockquote>
<p>由于 dsym 符号表是编译时生成的地址，crash 堆栈的地址是运行时地址，这个时候需要经过转换才能正确的符号化。crash 日志里的符号地址被称为 Stack Address，而编译后的符号地址被称为 Symbol Address，他们之间的关系如下：</p>
<blockquote>
<p>Stack Address = Symbol Address + Slide</p>
</blockquote>
<p><font color="#cc0000">符号化就是通过 Symbol Address 到 dsym 文件中寻找对应符号信息的过程</font>。</p>
<h4 id="4-3-获取-Binary-Images-信息"><a href="#4-3-获取-Binary-Images-信息" class="headerlink" title="4.3 获取 Binary Images 信息"></a>4.3 获取 Binary Images 信息</h4><p>当前采集到的 crash 日志，报错地址 Stack Address 位于 0x1046eea14，相对 Load Address 0x1046e8000 偏移了 27156。这里的 27156 并不是 ASLR 的随机偏移Slide，而是符号相对位置offset（Symbol Address - VM Address）：</p>
<center><br><img src="http://dzliving.com/Crash_1.png" alt="报错堆栈"><br></center>

<p>再观察 crash 日志最后有一栏 Binary Images，记录了所有加载 image 的 UUID 和加载的 Load Address：</p>
<center><br><img src="http://dzliving.com/Crash_2.png" alt="Binary Images"><br></center>

<p>根据前文提到的 UUID 对应关系以及 Load Address 和 Symbol Address 的转换关系，只要能获取 Binary Images 信息，就可以实现符号化。</p>
<p>UUID 存放在 Mach-O 的 load command 中，对应 uuid_command 结构体的 uuid 字段，可以通过遍历所有 load command 获取。</p>
<p>Slide 偏移可以通过 image_dyld_get_image_vmaddr_slide 方法遍历所有 Image 获取。</p>
<p>VM Address 也存放在 load command 中，对应 segment_command 结构体的 vmaddr 字段，需要注意 segment_command 存在多种类型以及需要区分32位和64位应用的细微差别。</p>
<p>解析代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; _dyld_image_count(); i++) &#123;</span><br><span class="line">        uint64_t vmbase = <span class="number">0</span>;</span><br><span class="line">        uint64_t vmslide = <span class="number">0</span>;</span><br><span class="line">        uint64_t vmsize = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        uint64_t loadAddress = <span class="number">0</span>;</span><br><span class="line">        uint64_t loadEndAddress = <span class="number">0</span>;</span><br><span class="line">        NSString *imageName = @<span class="string">""</span>;</span><br><span class="line">        NSString *uuid;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span> *header = _dyld_get_image_header(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *name = _dyld_get_image_name(i);</span><br><span class="line">        vmslide = (i);</span><br><span class="line">        imageName = [NSString stringWithCString:name encoding:NSUTF8StringEncoding];</span><br><span class="line">        BOOL is64bit = header-&gt;magic == MH_MAGIC_64 || header-&gt;magic == MH_CIGAM_64;</span><br><span class="line">        uintptr_t cursor = (uintptr_t)header + (is64bit ? <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span></span>) : <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span>));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span></span> *loadCommand = NULL;</span><br><span class="line">        <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cursor += loadCommand-&gt;cmdsize) &#123;</span><br><span class="line">            loadCommand = (<span class="class"><span class="keyword">struct</span> <span class="title">load_command</span></span> *)cursor;</span><br><span class="line">            <span class="keyword">if</span>(loadCommand-&gt;cmd == LC_SEGMENT) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span></span>* segmentCommand = (<span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span></span>*)loadCommand;</span><br><span class="line">                <span class="keyword">if</span> (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == <span class="number">0</span>) &#123;</span><br><span class="line">                    vmsize = segmentCommand-&gt;vmsize;</span><br><span class="line">                    vmbase = segmentCommand-&gt;vmaddr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(loadCommand-&gt;cmd == LC_SEGMENT_64) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span></span>* segmentCommand = (<span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span></span>*)loadCommand;</span><br><span class="line">                 <span class="keyword">if</span> (strcmp(segmentCommand-&gt;segname, SEG_TEXT) == <span class="number">0</span>) &#123;</span><br><span class="line">                    vmsize = segmentCommand-&gt;vmsize;</span><br><span class="line">                    vmbase = (uintptr_t)(segmentCommand-&gt;vmaddr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (loadCommand-&gt;cmd == LC_UUID) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span></span> *uuidCommand = (<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span></span> *)loadCommand;</span><br><span class="line">                NSString *uuidString = [[[NSUUID alloc] initWithUUIDBytes:uuidCommand-&gt;uuid] UUIDString];</span><br><span class="line">                uuid = [[uuidString stringByReplacingOccurrencesOfString:@<span class="string">"-"</span> withString:@<span class="string">""</span>] lowercaseString];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        loadAddress = vmbase + vmslide;</span><br><span class="line">        loadEndAddress = loadAddress + vmsize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line">#### <span class="number">4.4</span> 符号化</span><br><span class="line"></span><br><span class="line">通过上述代码，我们可以采集到和系统一样的 crash 日志。接下来，可以使用 dwarfdump 和 atos 进行符号化。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. dwarfdump</span><br><span class="line"></span><br><span class="line">	拿到 crash 日志后，我们要先确定 dsym 文件是否匹配。可以使用 dwarfdump --uuid 命令查看 dsym 文件所有架构的 UUID：</span><br></pre></td></tr></table></figure>
<pre><code>$ dwarfdump --uuid mytest.app.dSYM 
UUID: B4217D5B-0349-3D9F-9D70-BC7DD60DA121 (armv7) mytest.app.dSYM/Contents/Resources/DWARF/mytest
UUID: A52E3452-C2EF-3291-AE37-9392EDCCE572 (arm64) mytest.app.dSYM/Contents/Resources/DWARF/mytest
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到 dsym 文件的 arm64 架构中包含的 A52E3452-C2EF-3291-AE37-9392EDCCE572 和 Binary Images 中的 UUID 是相匹配的。</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span></span><br><span class="line">![<span class="string">UUID</span>](<span class="link">http://dzliving.com/Crash_3.png</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">下面就可以用 dwarfdump --lookup 命令对报错堆栈符号化，格式如下：</span><br></pre></td></tr></table></figure>

dwarfdump --arch [arch type] --lookup [Symbol Address] [dsym file path]
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于报错堆栈的 Stack<span class="built_in"> Address </span>0x1046eea14，需要进行一个转换。已知 VM<span class="built_in"> Address </span>为0x100000000，Load<span class="built_in"> Address </span>为 0x1046e8000，可以得到 Slide 为 0x46e8000。通过公式Symbol<span class="built_in"> Address </span>= Stack<span class="built_in"> Address </span>- Slider 求得 Symbol<span class="built_in"> Address </span>为 0x100006a14，输入命令：</span><br></pre></td></tr></table></figure>

$ dwarfdump --arch arm64 --lookup 0x100006a14 mytest.app.dSYM 
----------------------------------------------------------------------
 File: mytest.app.dSYM/Contents/Resources/DWARF/mytest (arm64)
----------------------------------------------------------------------
Looking up address: 0x0000000100006a14 in .debug_info... found!

0x0003ebb7: Compile Unit: length = 0x000000d4  version = 0x0004  abbr_offset = 0x00000000  addr_size = 0x08  (next CU at 0x0003ec8f)

0x0003ebc2: TAG_compile_unit [120] *
             AT_producer( &quot;Apple LLVM version 9.1.0 (clang-902.0.39.2)&quot; )
             AT_language( DW_LANG_ObjC )
             AT_name( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; )
             AT_stmt_list( 0x00009151 )
             AT_comp_dir( &quot;/Users/worthyzhang/Desktop/mytest&quot; )
             AT_APPLE_optimized( true )
             AT_APPLE_major_runtime_vers( 0x02 )
             AT_low_pc( 0x00000001000069bc )
             AT_high_pc( 0x000000a4 )

0x0003ebf9:     TAG_subprogram [122] *
                 AT_low_pc( 0x00000001000069bc )
                 AT_high_pc( 0x00000070 )
                 AT_frame_base( reg29 )
                 AT_object_pointer( {0x0003ec12} )
                 AT_name( &quot;-[ViewController viewDidLoad]&quot; )
                 AT_decl_file( &quot;/Users/worthyzhang/Desktop/mytest/mytest/ViewController.m&quot; )
                 AT_decl_line( 17 )
                 AT_prototyped( true )
                 AT_APPLE_optimized( true )
Line table dir : &apos;/Users/worthyzhang/Desktop/mytest/mytest&apos;
Line table file: &apos;ViewController.m&apos; line 25, column 1 with start address 0x0000000100006a14

Looking up address: 0x0000000100006a14 in .debug_frame... not found.
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	可以定位到报错所在的函数名 <span class="string">[ViewController viewDidLoad]</span> 以及文件名、行号等信息。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. atos</span><br><span class="line"></span><br><span class="line">	如果只是简单的获取符号名，可以用 atos 来符号化，命令格式如下：</span><br></pre></td></tr></table></figure>

atos -o [dsym file path] -l [Load Address] -arch [arch type] [Stack Address]
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">需要注意这里的 dsym file path 是 dsym 文件而不是 <span class="selector-class">.dSYM</span> 结尾的文件夹，输入命令：</span><br></pre></td></tr></table></figure>

$ atos -o mytest.app.dSYM/Contents/Resources/DWARF/mytest -l 0x1046e8000 --arch arm64 0x1046eea14
-[ViewController viewDidLoad] (in mytest) (ViewController.m:25)
```

得到结果和dwarfdump是一致的。
</code></pre><h4 id="4-5-常见错误标识"><a href="#4-5-常见错误标识" class="headerlink" title="4.5 常见错误标识"></a>4.5 常见错误标识</h4><ol>
<li><p>Exception codes</p>
<ul>
<li>0x8badf00d 错误码：Watchdog 超时，意为“ate bad food”。</li>
<li>0xdeadfa11 错误码：用户强制退出，意为“dead fall”。</li>
<li>0xbaaaaaad 错误码：用户按住 Home 键和音量键，获取当前内存状态，不代表崩溃。</li>
<li>0xbad22222 错误码：VoIP应用（因为太频繁？）被iOS干掉。</li>
<li>0xc00010ff 错误码：因为太烫了被干掉，意为“cool off”。</li>
<li>0xdead10cc 错误码：因为在后台时仍然占据系统资源（比如通讯录）被干掉，意为“dead lock”。</li>
</ul>
</li>
<li><p>Exception types</p>
<ul>
<li>SIGSEGV（Segmentation Violation，段违例）：表明内存操作不当，比如访问一个没有权限的内存地址。当我们收到 SIGSEGV 信号时，可以往以下几个方面考虑：<ul>
<li>访问无效内存地址，比如访问Zombie对象；</li>
<li>尝试往只读区域写数据；</li>
<li>解引用空指针；</li>
<li>使用未初始化的指针；</li>
<li>栈溢出；</li>
</ul>
</li>
<li>SIGABRT：收到 Abort 信号，可能自身调用 abort() 或者收到外部发送过来的信号；</li>
<li>SIGBUS：总线错误。与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址（比如虚存映射不到物理内存），而 SIGBUS 访问的是有效地址，但总线访问异常（比如地址对齐问题）；</li>
<li>SIGILL：尝试执行非法的指令，可能不被识别或者没有权限；</li>
<li>SIGFPE：Floating Point Error，数学计算相关问题（可能不限于浮点计算），比如除零操作；</li>
<li>SIGPIPE：管道另一端没有进程接手数据；</li>
</ul>
</li>
</ol>
<h2 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h2><ol>
<li><p>Debug 环境正常，Release 环境崩溃</p>
<p> 属性内存语义错误，如 NSArray 使用 assign 修饰，导致访问了释放掉的内存地址。</p>
</li>
<li><p>闪退</p>
<ul>
<li>数据库损坏：在日常使用异常退出、断电或者错误的操作</li>
<li>文件损坏：处理文件时如果没有 @try…catch，损坏文件会抛出 NSException 导致 crash</li>
<li>网络返回数据异常：数据类型不对，或返回破损的 Tar 包，在解压失败导致 crash。</li>
<li><p>代码 bug：当必 crash 的代码出现在启动关键路径中，就会导致连续闪退。</p>
<p>解决：</p>
</li>
<li><p>通过工具修复数据库，或者删除 DB。</p>
</li>
<li>删除文件来进行修复</li>
<li>具体地分析 crash 案例，通过 JSPatch 来进行修复。</li>
</ul>
</li>
<li><p>数组越界，nil 值初始化导致的崩溃。</p>
</li>
<li>对字典插入 nil 值，或者读取 NSNULL 导致的崩溃。</li>
<li>字符串的截取越界导致的崩溃。</li>
<li>doesNotRecognizeSelector 导致的崩溃。</li>
<li>子线程初始化 UIView 导致的崩溃。</li>
<li>KVO的重复添加、删除，或者忘了删除导致的崩溃。</li>
</ol>
<h2 id="六、文章"><a href="#六、文章" class="headerlink" title="六、文章"></a>六、文章</h2><p><a href="https://www.jianshu.com/u/796e9139e445" target="_blank" rel="noopener">悟行Worthy</a> &amp; <a href="https://www.jianshu.com/p/ea8926762121" target="_blank" rel="noopener">iOS实现Crash捕获与堆栈符号化</a><br><a href="https://www.objc.io/issues/6-build-tools/mach-o-executables/" target="_blank" rel="noopener">Mach-O Executables</a><br><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001827-SW1" target="_blank" rel="noopener">Mach-O Programming Topics</a><br><a href="https://www.jianshu.com/p/953f0961157a" target="_blank" rel="noopener">iOS崩溃堆栈信息的符号化解析</a><br><a href="https://www.jianshu.com/u/2b54d468523d" target="_blank" rel="noopener">oncezou</a> &amp; <a href="https://www.jianshu.com/p/5fcf7bb7955f" target="_blank" rel="noopener">iOS Crash的捕获知识</a><br><a href="https://www.jianshu.com/p/ca95fdee78d8" target="_blank" rel="noopener">iOS 崩溃处理（拦截和捕获）</a><br><a href="https://blog.csdn.net/weixin_38633659/article/details/82496635" target="_blank" rel="noopener">iOS开发：Crash异常总结与捕获</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/10/24/iOS/iOS优化/Crash/">http://yoursite.com/2019/10/24/iOS/iOS优化/Crash/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/10/24/iOS/iOS原理/App Thinning/" class="pre">App Thinning</a><a href="/2019/10/24/IT/OpenSSL演示RSA加密解密/" class="next">OpenSSL演示RSA加密解密</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Crash类型"><span class="toc-text">一、Crash类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Crash捕获"><span class="toc-text">二、Crash捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Mach-异常捕获"><span class="toc-text">1.1 Mach 异常捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-NSException-异常捕获"><span class="toc-text">1.2 NSException 异常捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Signal-信号捕获"><span class="toc-text">1.3 Signal 信号捕获</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#三、收集调用堆栈"><span class="toc-text">三、收集调用堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、堆栈符号化"><span class="toc-text">四、堆栈符号化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Mach-O文件格式"><span class="toc-text">4.1 Mach-O文件格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-可执行文件加载过程"><span class="toc-text">4.2 可执行文件加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-获取-Binary-Images-信息"><span class="toc-text">4.3 获取 Binary Images 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-常见错误标识"><span class="toc-text">4.5 常见错误标识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、问题"><span class="toc-text">五、问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、文章"><span class="toc-text">六、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/">iOS UmbrellaFramework</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/">iOS umbrella header</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS媒体/iOS 图片/">iOS 图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS优化/iOS 优化实例/">iOS 优化实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS原理/iOS 操作系统架构/">iOS 操作系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS架构/iOS 网络层设计/">iOS网络层设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS 类簇/">iOS 类簇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS OCR/">iOS OCR</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS IM/">iOS IM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/iOS/iOS原理/iOS 推送/">iOS 推送</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT/">IT</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL/">OpenGL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS动画/">iOS动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS媒体/">iOS媒体</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS安全/">iOS安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">5</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>