<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 编译过程原理(2) | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 编译过程原理(2)</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">iOS 编译过程原理(2)</h1><div class="post-meta"><a href="/2019/10/24/iOS/iOS原理/iOS 编译过程原理(2)/#comments" class="comment-count"></a><p><span class="date">Oct 24, 2019</span><span><a href="/categories/iOS原理/" class="category">iOS原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>《iOS编译过程的原理和应用》文章介绍了 iOS 编译相关基础知识和简单应用，但也很有多问题都没有解释清楚：</p>
<ul>
<li>Clang 和 LLVM 究竟是什么</li>
<li>源文件到机器码的细节</li>
<li>Linker 做了哪些工作</li>
<li>编译顺序如何确定</li>
<li>头文件是什么？XCode 是如何找到头文件的？</li>
<li>Clang Module</li>
<li>签名是什么？为什么要签名</li>
</ul>
<p>为了搞清楚这些问题，我们来挖掘下 XCode 编译 iOS 应用的细节。</p>
<h2 id="二、编译器"><a href="#二、编译器" class="headerlink" title="二、编译器"></a>二、编译器</h2><blockquote>
<p>把一种编程语言（原始语言）转换为另一种编程语言（目标语言）的程序叫做<a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">编译器</a>。</p>
</blockquote>
<p>大多数编译器由两部分组成：<font color="#cc0000">前端和后端</font>。</p>
<ul>
<li>前端负责词法分析、语法分析、生成中间代码；</li>
<li>后端以中间代码作为输入，进行与架构无关的代码优化，接着针对不同架构生成不同的机器码。</li>
</ul>
<p>前后端依赖统一格式的<font color="#cc0000">中间代码（IR）</font>，使得前后端可以独立的变化。新增一门语言只需要修改前端，而新增一个 CPU 架构只需要修改后端即可。</p>
<p>Objective-C/C/C++ 使用的编译器前端是<a href="https://clang.llvm.org/docs/index.html" target="_blank" rel="noopener">clang</a>，swift 是 <a href="https://swift.org/compiler-stdlib/#compiler-architecture" target="_blank" rel="noopener">swift</a>，后端都是 <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a>。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-dd65ea5de43d8fc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19"><br></center>

<h2 id="三、LLVM"><a href="#三、LLVM" class="headerlink" title="三、LLVM"></a>三、LLVM</h2><p>LLVM（Low Level Virtual Machine）是一个强大的编译器开发工具套件，听起来像是虚拟机，但实际上 LLVM 和传统意义的虚拟机关系不大，只不过项目最初的名字是 LLVM 罢了。</p>
<p>LLVM 的核心库提供了现代化的 source-target-independent <a href="https://llvm.org/docs/Passes.html" target="_blank" rel="noopener">优化器</a>和支持诸多流行 CPU 架构的代码生成器，这些核心代码是围绕着 LLVM IR（中间代码）建立的。</p>
<p>基于 LLVM 又衍生出了一些强大的子项目，其中 iOS 开发者耳熟能详的是：Clang 和 LLDB。</p>
<h2 id="四、clang"><a href="#四、clang" class="headerlink" title="四、clang"></a>四、clang</h2><p>clang 是 C 语言家族的编译器前端，诞生之初是为了替代 GCC，提供更快的编译速度。一张图了解 clang 编译的大致流程：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-867e93a43ad184f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20"><br></center>

<p>接下来，从代码层面看一下具体的转化过程，新建一个 main.c：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 注释</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello debug\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、预处理（preprocessor）"><a href="#五、预处理（preprocessor）" class="headerlink" title="五、预处理（preprocessor）"></a>五、预处理（preprocessor）</h2><p>预处理会进行头文件引入、宏替换、注释处理、条件编译（#ifdef）等操作。</p>
<p>#include “stdio.h” 就是告诉预处理器将这一行替换成头文件 stdio.h 中的内容，这个过程是递归的：因为 stdio.h 也有可能包含其他头文件。</p>
<p>用 clang 查看预处理的结果：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>xcrun clang -E main.c</span><br></pre></td></tr></table></figure>
<p>预处理后的文件有很多行，在文件的末尾，可以找到 main 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -E main.c</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> \_\_vsnprintf\_chk (<span class="keyword">char</span> * <span class="keyword">restrict</span>, size\<span class="keyword">_t</span>, <span class="keyword">int</span>, size\<span class="keyword">_t</span>,</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span>, va_list);</span><br><span class="line">\# <span class="number">412</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">\# <span class="number">10</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello debug\\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在预处理的时候，注释被删除，条件编译被处理。</p>
<h2 id="六、词法分析（lexical-anaysis）"><a href="#六、词法分析（lexical-anaysis）" class="headerlink" title="六、词法分析（lexical anaysis）"></a>六、词法分析（lexical anaysis）</h2><p>词法分析器读入源文件的<font color="#cc0000">字符流</font>，将它们组织成<font color="#cc0000">有意义的词素（lexeme）序列</font>，对于每个词素，词法分析器产生词法单元（token）作为输出。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -<span class="type">Xclang</span> -<span class="built_in">dump</span>-tokens main.<span class="built_in">c</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight profile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -fsyntax-only -Xclang -dump-tokens main.c</span><br><span class="line">annot\_module\_include '#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 一点注释</span><br><span class="line"></span><br><span class="line">#define DEBUG 1</span><br><span class="line">int main() &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    printf("hello debug\\n");</span><br><span class="line">#else</span><br><span class="line">    printf'		Loc=&lt;main.c:<span class="number">9</span>:<span class="number">1</span>&gt;</span><br><span class="line">int <span class="string">'int'</span>	 \[StartOfLine\]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">1</span>&gt;</span><br><span class="line">identifier <span class="string">'main'</span>	 \[LeadingSpace\]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;main.c:<span class="number">14</span>:<span class="number">9</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;main.c:<span class="number">14</span>:<span class="number">10</span>&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span>	 \[LeadingSpace\]	Loc=&lt;main.c:<span class="number">14</span>:<span class="number">12</span>&gt;</span><br><span class="line">identifier <span class="string">'printf'</span>	 \[StartOfLine\] \[LeadingSpace\]	Loc=&lt;main.c:<span class="number">16</span>:<span class="number">5</span>&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">11</span>&gt;</span><br><span class="line">string_literal <span class="string">'"hello debug\\n"'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">12</span>&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">27</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.c:<span class="number">16</span>:<span class="number">28</span>&gt;</span><br><span class="line">return <span class="string">'return'</span>	 \[StartOfLine\] \[LeadingSpace\]	Loc=&lt;main.c:<span class="number">20</span>:<span class="number">5</span>&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span>	 \[LeadingSpace\]	Loc=&lt;main.c:<span class="number">20</span>:<span class="number">12</span>&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;main.c:<span class="number">20</span>:<span class="number">13</span>&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span>	 \[StartOfLine\]	Loc=&lt;main.c:<span class="number">21</span>:<span class="number">1</span>&gt;</span><br><span class="line">eof <span class="string">''</span>		Loc=&lt;main.c:<span class="number">21</span>:<span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Loc=\<a href="main.c:9:1\" target="_blank" rel="noopener">main.c:9:1\</a> 标示这个 token 位于源文件 main.c 的第 9 行，从第 1 个字符开始。保存 token 在源文件中的位置是方便后续 clang 分析的时候能够找到出错的原始位置。</p>
<h2 id="七、语法分析（semantic-analysis）"><a href="#七、语法分析（semantic-analysis）" class="headerlink" title="七、语法分析（semantic analysis）"></a>七、语法分析（semantic analysis）</h2><p>词法分析的 Token 流会被解析成一颗<font color="#cc0000">抽象语法树（abstract syntax tree - AST）</font>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fsyntax-only -<span class="type">Xclang</span> -ast-<span class="built_in">dump</span> main.<span class="built_in">c</span> | <span class="keyword">open</span> -f</span><br></pre></td></tr></table></figure>
<p>main 函数 AST 的结构：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTranslationUnitDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18166e8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816c60</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __int128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816980</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'__int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816cd0</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __uint128_t[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18169a0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'unsigned __int128'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816fa8</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __NSConstantString[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mRecordType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816db0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mRecord[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816d28</span>[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m '__NSConstantString_tag'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817040</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_ms_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mPointerType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817000</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char *'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|   `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mBuiltinType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1816780</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'char'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m|-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">1</span>;<span class="number">32</span>mTypedefDecl[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a1817308</span>[<span class="number">0</span>m &lt;[<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m&gt; [<span class="number">0</span>;<span class="number">33</span>m&lt;invalid sloc&gt;[<span class="number">0</span>m implicit referenced[<span class="number">0</span>;<span class="number">1</span>;<span class="number">36</span>m __builtin_va_list[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct __va_list_tag [<span class="number">1</span>]'[<span class="number">0</span>m</span><br><span class="line">[<span class="number">0</span>;<span class="number">34</span>m| `-[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">32</span>mConstantArrayType[<span class="number">0</span>m[<span class="number">0</span>;<span class="number">33</span>m <span class="number">0x7fd9a18172b0</span>[<span class="number">0</span>m [<span class="number">0</span>;<span class="number">32</span>m'struct </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了抽象语法树，clang 就可以对这个树进行分析，找出代码中的错误。比如类型不匹配，亦或 Objective-C 中向 target 发送了一个未实现的消息。</p>
<p><font color="#cc0000">AST 是开发者编写 clang 插件主要交互的数据结构</font>，clang 也提供很多 API 去读取 AST。更多细节：<a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Introduction to the Clang AST</a>。</p>
<h2 id="八、CodeGen"><a href="#八、CodeGen" class="headerlink" title="八、CodeGen"></a>八、CodeGen</h2><p>CodeGen 遍历语法树，<font color="#cc0000">生成 LLVM IR 代码</font>。LLVM IR 是前端的输出，后端的输入。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xcrun</span> <span class="selector-tag">clang</span> <span class="selector-tag">-S</span> <span class="selector-tag">-emit-llvm</span> <span class="selector-tag">main</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">main</span><span class="selector-class">.ll</span></span><br></pre></td></tr></table></figure>
<p>main.ll 文件内容：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ModuleID = 'main.c'</span></span><br><span class="line"><span class="comment">source_filename = "main.c"</span></span><br><span class="line"><span class="comment">target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line"><span class="comment">target triple = "x86_64-apple-macosx10.13.0"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@.str = private unnamed_addr constant \[13 x i8\] c"hello debug\\0A\\00", align 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone ssp uwtable</span></span><br><span class="line"><span class="comment">define i32 @main() #0 &#123;</span></span><br><span class="line"><span class="comment">  %1 = alloca i32, align 4</span></span><br><span class="line"><span class="comment">  store i32 0, i32* %1, align 4</span></span><br><span class="line"><span class="comment">  %2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds (\[13 x i8\], \[13 x i8\]* @.str, i32 0, i32 0))</span></span><br><span class="line"><span class="comment">  ret i32 0</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">...</span></span><br></pre></td></tr></table></figure>
<p>Objective-C 代码在这一步会进行 runtime 的桥接：property 合成、ARC 处理等。</p>
<p>LLVM 会对生成的 IR 进行优化，优化会调用相应的 Pass 进行处理。Pass 由多个节点组成，都是 <a href="http://llvm.org/doxygen/classllvm_1_1Pass.html" target="_blank" rel="noopener">Pass</a> 类的子类，每个节点负责做特定的优化，更多细节：<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass</a>。</p>
<h2 id="九、生成汇编代码"><a href="#九、生成汇编代码" class="headerlink" title="九、生成汇编代码"></a>九、生成汇编代码</h2><p>LLVM 对 IR 进行优化后，会针对不同架构生成不同的目标代码，最后以汇编代码的格式输出。</p>
<p>生成 arm 64 汇编：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -S main<span class="selector-class">.c</span> -o main.s</span><br></pre></td></tr></table></figure>
<p>查看生成的 main.s 文件。对汇编感兴趣的同学可以看看这篇文章：<a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/Basic/iOS%20assembly%20toturial%20part%201.md" target="_blank" rel="noopener">iOS汇编快速入门</a>。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">	.section	__TEXT,__text,regular,pure_instructions</span><br><span class="line">	.macosx_version_min <span class="number">10</span>, <span class="number">13</span></span><br><span class="line">	.globl	_main                   <span class="comment">## -- Begin function main</span></span><br><span class="line">	.p2align	<span class="number">4</span>, <span class="number">0x90</span></span><br><span class="line">_main:                                  <span class="comment">## @main</span></span><br><span class="line">	.cfi_startproc</span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset %rbp, -<span class="number">16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	$16, %rsp</span><br><span class="line">	leaq	L<span class="number">_</span>.str(%rip), %rdi</span><br><span class="line">	movl	$0, -<span class="number">4</span>(%rbp)</span><br><span class="line">	movb	$0, %al</span><br><span class="line">	callq	_printf</span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -<span class="number">8</span>(%rbp)          <span class="comment">## 4-byte Spill</span></span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	$16, %rsp</span><br><span class="line">	popq	%rbp</span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc</span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals</span><br><span class="line">L<span class="number">_</span>.str:                                 <span class="comment">## @.str</span></span><br><span class="line">	.asciz	<span class="string">"hello debugn"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure>
<h2 id="十、汇编器"><a href="#十、汇编器" class="headerlink" title="十、汇编器"></a>十、汇编器</h2><p>汇编器以汇编代码作为输入，将汇编代码转换为机器代码，最后输出目标文件（object file）。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang -fmodules -<span class="keyword">c</span> main.<span class="keyword">c</span> -o main.o</span><br></pre></td></tr></table></figure>
<p>还记得代码中调用了一个函数 printf 么？通过 nm 命令，查看下 main.o 中的符号</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun <span class="built_in">nm</span> -<span class="built_in">nm</span> main.o</span><br><span class="line">                 (undefined) external _printf</span><br><span class="line"><span class="number">0000000000000000</span> (\<span class="symbol">_</span>\_TEXT,\<span class="symbol">_</span>\_text) external _main</span><br></pre></td></tr></table></figure>
<p>_printf 是一个 undefined external 的。undefined 表示在当前文件暂时找不到符号 _printf，而 external 表示这个符号是外部可以访问的，对应表示文件私有的符号是 non-external。</p>
<blockquote>
<p>什么是符号（Symbols）?</p>
</blockquote>
<p>符号就是指向一段代码或者数据的名称。还有一种叫做 WeakSymols，也就是并不一定会存在的符号，需要在运行时决定。比如 iOS12 特有的 API，在 iOS11 上就没有。</p>
<h2 id="十一、链接"><a href="#十一、链接" class="headerlink" title="十一、链接"></a>十一、链接</h2><p>连接器把编译产生的 .o 文件和（dylib、a、tbd）文件，生成一个 mach-o 文件。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun clang main<span class="selector-class">.o</span> -o main</span><br></pre></td></tr></table></figure>
<p>就得到了一个 mach o 格式的可执行文件</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> <span class="keyword">file</span> main</span><br><span class="line">main: Mach-O <span class="number">64</span>-bit executable x86_64</span><br><span class="line"><span class="symbol">$</span> ./main</span><br><span class="line">hello debug</span><br></pre></td></tr></table></figure>
<p>再用 nm 命令，查看可执行文件的符号表：</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nm -nm main</span><br><span class="line">                 (undefined) external _printf (from libSystem)</span><br><span class="line">                 (undefined) external dyld<span class="symbol">\_</span>stub<span class="symbol">\_</span>binder (from libSystem)</span><br><span class="line">0000000100000000 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) <span class="symbol">\[</span>referenced dynamically<span class="symbol">\]</span> external <span class="symbol">\_</span><span class="symbol">\_</span>mh<span class="symbol">\_</span>execute_header</span><br><span class="line">0000000100000f60 (<span class="symbol">\_</span><span class="symbol">\_</span>TEXT,<span class="symbol">\_</span><span class="symbol">\_</span>text) external _main</span><br></pre></td></tr></table></figure>
<p>_printf 仍然是 undefined，但是后面多了一些信息：from libSystem，表示这个符号来自于 libSystem，会在运行时动态绑定。</p>
<h2 id="十二、XCode-编译"><a href="#十二、XCode-编译" class="headerlink" title="十二、XCode 编译"></a>十二、XCode 编译</h2><p>通过上文我们大概了解了 Clang 编译一个 C 语言文件的过程，但是 XCode 开发的项目不仅仅包含了代码文件，还包括了图片、plist 等。XCode 中编译一次都要经过哪些过程呢？</p>
<p>新建一个单页面的 Demo 工程：CocoaPods 依赖 AFNetworking 和 SDWebImage，同时依赖于一个内部 Framework。按下Command + B，在 XCode 的 Report Navigator 模块中，可以找到编译的详细日志：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-850e886824831a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21"><br></center>

<p>详细的步骤：</p>
<ul>
<li>创建 Product.app 的文件夹</li>
<li>把 Entitlements.plist 写入到 DerivedData 里，处理打包的时候需要的信息（比如 application-identifier）。</li>
<li>创建一些辅助文件，比如各种 .hmap，这是 headermap 文件，具体作用下文会讲解。</li>
<li>执行 CocoaPods 的编译前脚本：检查 Manifest.lock 文件。</li>
<li>编译 .m 文件，生成 .o 文件。</li>
<li>链接动态库。.o 文件，生成一个 mach o 格式的可执行文件。</li>
<li>编译 assets，编译 storyboard，链接 storyboard</li>
<li>拷贝动态库 Logger.framework，并且对其签名</li>
<li>执行 CocoaPods 编译后脚本：拷贝 CocoaPods Target 生成的 Framework</li>
<li>对 Demo.App 签名，并验证（validate）</li>
<li>生成 Product.app</li>
<li>生成 dYSM 文件</li>
</ul>
<blockquote>
<p>Entitlements.plist 保存了 App 需要使用的特殊权限，比如 iCloud、远程通知、Siri 等。</p>
</blockquote>
<h2 id="十三、编译顺序"><a href="#十三、编译顺序" class="headerlink" title="十三、编译顺序"></a>十三、编译顺序</h2><p>编译的时候有很多的 Task（任务）要去执行，XCode 如何决定 Task 的执行顺序呢？</p>
<p>答案是：<font color="#cc0000">依赖关系</font>。</p>
<p>还是以刚刚的 Demo 项目为例，整个依赖关系如下：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-9b0c7342fdc5b545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22"><br></center>

<p>可以从 XCode 的 Report Navigator 看到 Target 的编译顺序：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-1c02d00b99428ab4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23"><br></center>

<p>XCode 编译的时候会尽可能的利用多核性能，多 Target 并发编译。</p>
<p>那么，XCode 又从哪里得到了这些依赖关系呢？</p>
<ul>
<li>Target Dependencies - 显式声明的依赖关系</li>
<li>Linked Frameworks and Libraries - 隐式声明的依赖关系</li>
<li>Build Phase - 定义了编译一个 Target 的每一步</li>
</ul>
<h2 id="十四、增量编译"><a href="#十四、增量编译" class="headerlink" title="十四、增量编译"></a>十四、增量编译</h2><p>日常开发中，一次完整的编译可能要几分钟，甚至几十分钟，而增量编译只需要不到 1 分钟，为什么增量编译会这么快呢？</p>
<p>因为 XCode 会对每一个 Task 生成一个哈希值，只有哈希值改变的时候才会重新编译。</p>
<p>比如，修改了 ViewControler.m，只有图中灰色的三个 Task 会重新执行（这里不考虑 build phase 脚本）。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-0eaaea9ee243f79c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="24"><br></center>

<h2 id="十五、头文件"><a href="#十五、头文件" class="headerlink" title="十五、头文件"></a>十五、头文件</h2><p>C 语言家族中，头文件（.h）文件用来引入函数/类/宏定义等声明，让开发者更灵活的组织代码，而不必把所有的代码写到一个文件里。</p>
<p>头文件对于编译器来说就是一个 promise。头文件里的声明，编译会认为有对应实现，在链接的时候再解决具体实现的位置。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-b5be48b5d1a1c97d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25"><br></center>

<p>当只有声明，没有实现的时候，链接器就会报错。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture arm64:</span><br><span class="line">“_umimplementMethod”, referenced <span class="keyword">from</span>:</span><br><span class="line">-\[ClassA <span class="function"><span class="keyword">method</span>\] <span class="title">in</span> <span class="title">ClassA</span>.<span class="title">o</span></span></span><br><span class="line"><span class="function"><span class="title">ld</span>:</span> symbol(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture arm64</span><br><span class="line">clang: error: linker command failed <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">1</span> (use -v <span class="keyword">to</span> see invocation)</span><br></pre></td></tr></table></figure>
<p>Objective-C 的方法要到运行时才会报错，因为 Objective-C 是一门动态语言，编译器无法确定对应的方法名（SEL）在运行时到底有没有实现（IMP）。</p>
<p>日常开发中，两种常见的头文件引入方式：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"CustomClass.h"</span> // 自定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span> // 系统或者内部 framework</span></span><br></pre></td></tr></table></figure>
<p>引入的时候并没有指明文件的具体路径，编译器是如何找到这些头文件的呢？</p>
<p>回到 XCode 的 Report Navigator，找到上一个编译记录，可以看到编译 ViewController.m 的具体日志：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-d620556105843b4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="27"><br><br><img src="https://upload-images.jianshu.io/upload_images/5294842-d1cd2dd2e5bb8a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="26"><br></center>

<p>把这个日志整体拷贝到命令行中，然后最后加上 -v，表示我们希望得到更多的日志信息，执行这段代码，在日志最后可以看到clang 是如何找到头文件的：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "..." search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-generated-files.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-project-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking/AFNetworking.framework/Headers</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage/SDWebImage.framework/Headers</span><br><span class="line"> </span><br><span class="line"><span class="comment">#include &lt;...&gt; search starts here:</span></span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-own-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/Demo-all-non-framework-target-headers.hmap (headermap)</span><br><span class="line"> /Users/.../Build/Intermediates.noindex/Demo.build/Debug-iphoneos/Demo.build/DerivedSources</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/AFNetworking (framework directory)</span><br><span class="line"> /Users/.../Build/Products/Debug-iphoneos/SDWebImage (framework directory)</span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">clang</span>/10.0.0/<span class="title">include</span></span></span><br><span class="line"> /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/usr/<span class="keyword">include</span></span><br><span class="line"> $SDKROOT/System/Library/Frameworks (framework directory)</span><br><span class="line"> </span><br><span class="line">End <span class="keyword">of</span> search list.</span><br></pre></td></tr></table></figure>
<p>这里有个文件类型叫做 heademap，headermap 是帮助编译器找到头文件的辅助文件：存储着头文件到其物理路径的映射关系。</p>
<p>可以通过一个辅助的小工具 <a href="https://github.com/milend/hmap" target="_blank" rel="noopener">hmap</a> 查看 hmap 中的内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./hmap print Demo-project-headers<span class="selector-class">.hmap</span> </span><br><span class="line">AppDelegate<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/AppDelegate.h</span><br><span class="line">Demo-Bridging-Header<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/Demo-Bridging-Header.h</span><br><span class="line">Dummy<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Framework/Dummy.h</span><br><span class="line">Framework<span class="selector-class">.h</span> -&gt; Framework/Framework.h</span><br><span class="line">TestView<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/View/TestView.h</span><br><span class="line">ViewController<span class="selector-class">.h</span> -&gt; /Users/huangwenchen/Desktop/Demo/Demo/ViewController.h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是为什么备份/恢复 Mac 后，需要 clean build folder，因为两台 mac 对应文件的物理位置可能不一样。</p>
</blockquote>
<p>clang 发现 #import “TestView.h” 的时候，先在 headermap(Demo-generated-files.hmap,Demo-project-headers.hmap) 里查找，如果 headermap 文件找不到，接着在 own target 的 framework 里找：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>AFNetworking<span class="regexp">/AFNetworking.framework/</span>Headers/TestView.h</span><br><span class="line"><span class="regexp">/Users/</span>...<span class="regexp">/Build/</span>Products<span class="regexp">/Debug-iphoneos/</span>SDWebImage<span class="regexp">/SDWebImage.framework/</span>Headers/TestView.h</span><br></pre></td></tr></table></figure>
<p>系统的头文件查找的时候也是优先 headermap，headermap 查找不到会查找 own target framework，最后查找 SDK 目录。</p>
<p>以 #import &lt;Foundation/Foundation.h&gt; 为例，在 SDK 目录查找时：</p>
<ol>
<li><p>首先查找 framework 是否存在</p>
 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 framework 存在，再在 headers 目录里查找头文件是否存在</p>
 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$SDKROOT</span><span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/headers/</span>Foundation.h</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="十六、Clang-Module"><a href="#十六、Clang-Module" class="headerlink" title="十六、Clang Module"></a>十六、Clang Module</h2><p>传统的 #include/#import 都是文本语义：预处理器在处理的时候会把这一行替换成对应头文件的文本，这种简单粗暴替换是有很多问题的：</p>
<ol>
<li>大量的预处理消耗。假如有 N 个头文件，每个头文件又 #include 了 M 个头文件，那么整个预处理的消耗是 N*M。</li>
<li>文件导入后，宏定义容易出现问题。因为是文本导入，并且按照 include 依次替换，当一个头文件定义了 #define std hello_world，而另一个头文件刚好又是 C++ 标准库，那么 include 顺序不同，可能会导致所有的 std 都会被替换。</li>
<li>边界不明显。拿到一组 .a 和 .h 文件，很难确定 .h 是属于哪个 .a 的，需要以什么样的顺序导入才能正确编译。</li>
</ol>
<p><a href="https://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">clang module</a> 不再使用文本模型，而是采用更高效的语义模型。clang module 提供了一种新的导入方式：@import，module 会被作为一个独立的模块编译，并且产生独立的缓存，从而大幅度提高预处理效率，这样时间消耗从 M*N 变成了 M+N。</p>
<p>XCode 创建的 Target 是 Framework 的时候，默认 define module 会设置为 YES，从而支持 module，当然像 Foundation 等系统的 framwork 同样支持 module。</p>
<p>#import \&lt;Foundation/NSString.h> 的时候，编译器会检查 NSString.h 是否在一个 module 里，如果是的话，这一行会被替换成 @import Foundation。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-f9261463ed11b9e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="28"><br></center>

<p>那么，如何定义一个 module 呢？答案是：modulemap 文件，这个文件描述了一组头文件如何转换为一个 module，举个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">framework <span class="keyword">module</span> Foundation  [extern_c] [system] &#123;</span><br><span class="line">	umbrella header <span class="string">"Foundation.h"</span> <span class="comment">// 所有要暴露的头文件</span></span><br><span class="line"> 	<span class="keyword">export</span> *</span><br><span class="line">	<span class="keyword">module</span> * &#123;</span><br><span class="line"> 		<span class="keyword">export</span> *</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	explicit <span class="keyword">module</span> NSDebug &#123; <span class="comment">//submodule</span></span><br><span class="line"> 		header <span class="string">"NSDebug.h"</span></span><br><span class="line"> 		<span class="keyword">export</span> *</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>swift 是可以直接 import 一个 clang module 的，比如你有一些 C 库，需要在 Swift 中使用，就可以用 modulemap 的方式。</p>
<h2 id="十七、Swift-编译"><a href="#十七、Swift-编译" class="headerlink" title="十七、Swift 编译"></a>十七、Swift 编译</h2><p>现代化的语言几乎都抛弃了头文件，swift 也不例外。问题来了，swift 没有头文件又是怎么找到声明的呢？</p>
<blockquote>
<p>编译器干了这些脏活累活。编译一个 Swift 头文件，需要解析 module 中所有的 Swift 文件，找到对应的声明。</p>
</blockquote>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-bd4a0844c9c85adb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="29"><br></center>

<p>当开发中难免要有 Objective-C 和 Swift 相互调用的场景，两种语言在编译的时候查找符号的方式不同，如何一起工作的呢？</p>
<ol>
<li><p>Swift 引用 Objective-C</p>
<p> Swift 的编译器内部使用了 clang，所以 swift 可以直接使用 clang module，从而支持直接 import Objective-C 编写的framework。</p>
 <center><br> <img src="https://upload-images.jianshu.io/upload_images/5294842-cd4f5c7f8eafc71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="30"><br> </center>

<p> swift 编译器会从 Objective-C 头文件里查找符号，头文件的来源分为两大类：</p>
<ul>
<li>Bridging-Header.h 中暴露给 swfit 的头文件</li>
<li><p>framework 中公开的头文件，根据编写的语言不同，可能从 modulemap 或者 umbrella header 查找。</p>
<p>XCode 提供了宏定义 NS_SWIFT_NAME 来让开发者定义 Objective-C =&gt; Swift的符号映射，可以通过 Related Items -&gt; Generate Interface 来查看转换后的结果：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-bd928c0ee2b8d45a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="31"><br></center>
</li>
</ul>
</li>
<li><p>Objective-C 引用 swift</p>
<p> xcode 会以 module 为单位，为 swift 自动生成头文件，供 Objective-C 引用，通常这个文件命名为 ProductName-Swift.h。</p>
<p> swift 提供了关键词 @objc 来把类型暴露给 Objective-C 和 Objective-C Runtime。</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="十八、深入理解-Linker"><a href="#十八、深入理解-Linker" class="headerlink" title="十八、深入理解 Linker"></a>十八、深入理解 Linker</h2><blockquote>
<p>链接器会把编译器编译生成的多个文件，链接成一个可执行文件。链接并不会产生新的代码，只是在现有代码的基础上做移动和补丁。</p>
</blockquote>
<p>链接器的输入可能是以下几种文件：</p>
<ul>
<li>object file(.o)，单个源文件的编辑结果，包含了由符号表示的代码和数据。</li>
<li>动态库（.dylib），mach o 类型的可执行文件，链接的时候只会绑定符号，动态库会被拷贝到 app 里，运行时加载</li>
<li>静态库（.a），由 ar 命令打包的一组 .o 文件，链接的时候会把具体的代码拷贝到最后的 mach-o。</li>
<li>tbd，只包含符号的库文件</li>
</ul>
<p>这里提到了一个概念：符号（Symbols），那么符号是什么呢？</p>
<blockquote>
<p>符号是一段代码或者数据的名称，一个符号内部也有可能引用另一个符号。</p>
</blockquote>
<p>以一段代码为例，看看链接时究竟发生了什么？</p>
<p>源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="built_in">log</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>.o 文件：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#代码</span><br><span class="line"><span class="selector-tag">adrp</span>    <span class="selector-tag">x0</span>, <span class="selector-tag">l_</span><span class="selector-class">.str</span>@<span class="keyword">PAGE</span></span><br><span class="line"><span class="selector-tag">add</span>     <span class="selector-tag">x0</span>, <span class="selector-tag">x0</span>, <span class="selector-tag">l_</span><span class="selector-class">.str</span>@<span class="keyword">PAGE</span><span class="selector-tag">OFF</span></span><br><span class="line"><span class="selector-tag">bl</span>      _<span class="selector-tag">printf</span></span><br><span class="line"></span><br><span class="line">#字符串符号</span><br><span class="line"><span class="selector-tag">l_</span><span class="selector-class">.str</span>:                                 ; @.<span class="keyword">str</span></span><br><span class="line">        .asciz  <span class="string">"hello world\\n"</span></span><br></pre></td></tr></table></figure>
<p>在 .o 文件中，字符串 “hello world\n” 作为一个符号（l_.str）被引用，汇编代码读取的时候按照 l_.str 所在的页加上偏移量的方式读取，然后调用 printf 符号。到这一步，CPU 还不知道怎么执行，因为还有两个问题没解决：</p>
<ol>
<li>l_.str 在可执行文件的哪个位置？</li>
<li>printf 函数来自哪里？</li>
</ol>
<p>再来看看链接之后的 mach o 文件：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-ac9f852d87c4ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="32"><br></center>

<p>链接器如何解决这两个问题呢？</p>
<ol>
<li>链接后，不再是以页+偏移量的方式读取字符串，而是直接读虚拟内存中的地址，解决了 l_.str 的位置问题。</li>
<li>链接后，不再是调用符号 _printf，而是在 DATA 段上创建了一个函数指针 _printf$ptr，初始值为 0x0(null)，代码直接调用这个函数指针。启动的时候，dyld 会把 DATA 段上的指针进行动态绑定，绑定到具体虚拟内存中的 _printf 地址。更多细节，可以参考这篇文章：<a href="https://blog.csdn.net/Hello_Hwc/article/details/78317863" target="_blank" rel="noopener">深入理解iOS App的启动过程</a>。</li>
</ol>
<p>Mach-O 有一个区域叫做 LINKEDIT，这个区域用来存储启动时 dyld 需要动态修复的一些数据：比如刚刚提到的 printf 在内存中的地址。</p>
<h2 id="十九、理解签名"><a href="#十九、理解签名" class="headerlink" title="十九、理解签名"></a>十九、理解签名</h2><ol>
<li><p>非对称加密</p>
<p> 在密码学中，非对称加密需要两个密钥：公钥和私钥。私钥加密的只能用公钥解密，公钥加密的只能用私钥解密。</p>
</li>
<li><p>数字签名</p>
<p> 数字签名表示我对数据做了个标记，表示这是我的数据，没有经过篡改。</p>
<p> 数据发送方 Leo 产生一对公私钥，私钥自己保存，公钥发给接收方 Lina。Leo 用摘要算法，对发送的数据生成一段摘要，摘要算法保证了只要数据修改，那么摘要一定改变。然后用私钥对这个摘要进行加密，和数据一起发送给 Lina。</p>
 <center><br> <img src="https://upload-images.jianshu.io/upload_images/5294842-b929196750ad26b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33"><br> </center>

<p> Lina 收到数据后，用公钥解密签名，得到 Leo 发过来的摘要；然后自己按照同样的摘要算法计算摘要，如果计算的结果和 Leo 的一样，说明数据没有被篡改过。</p>
 <center><br> <img src="https://upload-images.jianshu.io/upload_images/5294842-cacead84adbed4a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="34"><br> </center>

<p> 但是，现在还有个问题：Lina 有一个公钥，假如攻击者把 Lina 的公钥替换成自己的公钥，那么攻击者就可以伪装成 Leo 进行通信，所以 Lina 需要确保这个公钥来自于 Leo，可以通过数字证书来解决这个问题。</p>
<blockquote>
<p>数字证书由 CA（Certificate Authority）颁发，以 Leo 的证书为例，里面包含了以下数据：签发者、Leo 的公钥、Leo 使用的 Hash 算法、证书的数字签名、到期时间等。</p>
</blockquote>
<p> 有了数字证书后，Leo 再发送数据的时候，把自己从 CA 申请的证书一起发送给 Lina。Lina 收到数据后，先用 CA 的公钥验证证书的数字签名是否正确，如果正确说明证书没有被篡改过，然后以信任链的方式判断是否信任这个证书，如果信任证书，取出证书中的数据，可以判断出证书是属于 Leo 的，最后从证书中取出公钥来做数据签名验证。</p>
</li>
</ol>
<h2 id="二十、iOS-App-签名"><a href="#二十、iOS-App-签名" class="headerlink" title="二十、iOS App 签名"></a>二十、iOS App 签名</h2><p>为什么要对 App 进行签名呢？签名能够让 iOS 识别出是谁签名了 App，并且签名后 App 没有被篡改过。</p>
<p>除此之外，Apple 要严格控制 App 的分发：</p>
<ol>
<li>App 来自 Apple 信任的开发者</li>
<li>安装的设备是 Apple 允许的设备</li>
</ol>
<h4 id="20-1-证书"><a href="#20-1-证书" class="headerlink" title="20.1 证书"></a>20.1 证书</h4><p>通过上文的讲解，我们知道数字证书里包含着申请证书设备的公钥，所以在 Apple 开发者后台创建证书的时候，需要上传 CSR 文件（Certificate Signing Request），用 keychain 生成这个文件的时候，就生成了一对公/私钥：公钥在 CSR 里，私钥在本地的 Mac 上。Apple 本身也有一对公钥和私钥：私钥保存在 Apple 后台，公钥在每一台 iOS 设备上。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-ec7d73889dc3f8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="35"><br></center>

<h4 id="20-2-Provisioning-Profile"><a href="#20-2-Provisioning-Profile" class="headerlink" title="20.2 Provisioning Profile"></a>20.2 Provisioning Profile</h4><p>iOS App 安装到设备的途径（非越狱）有以下几种：</p>
<ul>
<li>开发包（插线，或者 archive 导出 develop 包）</li>
<li>Ad Hoc</li>
<li>App Store</li>
<li>企业证书</li>
</ul>
<p>开发包和 Ad Hoc 都会严格限制安装设备，为了把设备 uuid 等信息一起打包进 App，开发者需要配置 Provisioning Profile。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-696d4d9bbf81ec36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="36"><br></center>

<p>可以通过以下命令来查看 Provisioning Profile 中的内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security cms -D -<span class="selector-tag">i</span> embedded<span class="selector-class">.mobileprovision</span> &gt; result.plist</span><br><span class="line">open result.plist</span><br></pre></td></tr></table></figure>
<p>本质上就是一个编码过后的 plist。</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-46a1386a0e86d8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="37"><br></center>

<h4 id="20-3-iOS-签名"><a href="#20-3-iOS-签名" class="headerlink" title="20.3 iOS 签名"></a>20.3 iOS 签名</h4><p>生成安装包的最后一步，XCode 会调用 codesign 对 Product.app 进行签名。</p>
<p>创建一个额外的目录 _CodeSignature 以 plist 的方式存放安装包内每一个文件签名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>Base.lproj/LaunchScreen.storyboardc/01J-lp-oVM-view-Ze5-6b-2t3.nib<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">T2g5jlq7EVFHNzL/ip3fSoXKoOI=</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>Info.plist<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">5aVg/3m4y30m+GSB8LkZNNU3mug=</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>PkgInfo<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">n57qDP4tZfLD1rCS43W0B4LQjzE=</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>embedded.mobileprovision<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">tm/I1g+0u2Cx9qrPJeC0zgyuVUE=</span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>代码签名会直接写入到 mach-o 的可执行文件里，值得注意的是签名是以页（Page）为单位的，而不是整个文件签名：</p>
<center><br><img src="https://upload-images.jianshu.io/upload_images/5294842-8c96d1f4a8fcb7b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="38"><br></center>

<h4 id="20-4-验证"><a href="#20-4-验证" class="headerlink" title="20.4 验证"></a>20.4 验证</h4><p>安装 App 的时候</p>
<ul>
<li>从 embedded.mobileprovision 取出证书，验证证书是否来自 Apple 信任的开发者</li>
<li>证书验证通过后，从证书中取出 Leo 的公钥</li>
<li>读取 _CodeSignature 中的签名结果，用 Leo 的公钥验证每个文件的签名是否正确</li>
<li>文件 embedded.mobileprovision 验证通过后，读取里面的设备 id 列表，判断当前设备是否可安装（App Store 和企业证书不做这步验证）</li>
<li>验证通过后，安装 App</li>
</ul>
<p>启动 App 的时候</p>
<ul>
<li>验证 bundle id、entitlements 和 embedded.mobileprovision中的 AppId，entitlements 是否一致</li>
<li>判断 device id 包含在 embedded.mobileprovision 里。App Store 和企业证书不做验证</li>
<li>如果是企业证书，验证用户是否信任企业证书</li>
<li>App 启动后，当缺页中断（page fault）发生的时候，系统会把对应的 mach-o 页读入物理内存，然后验证这个 page 的签名是否正确。</li>
<li>以上都验证通过，App 才能正常启动</li>
</ul>
<h2 id="二十一、文章"><a href="#二十一、文章" class="headerlink" title="二十一、文章"></a>二十一、文章</h2><p><a href="https://me.csdn.net/Hello_Hwc" target="_blank" rel="noopener">黄文臣</a> &amp; <a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147" target="_blank" rel="noopener">深入浅出iOS编译</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/10/24/iOS/iOS原理/iOS 编译过程原理(2)/">http://yoursite.com/2019/10/24/iOS/iOS原理/iOS 编译过程原理(2)/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/10/24/算法/排序算法/" class="pre">排序算法</a><a href="/2019/10/24/iOS/iOS原理/block/" class="next">Block</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、编译器"><span class="toc-text">二、编译器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、LLVM"><span class="toc-text">三、LLVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、clang"><span class="toc-text">四、clang</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、预处理（preprocessor）"><span class="toc-text">五、预处理（preprocessor）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、词法分析（lexical-anaysis）"><span class="toc-text">六、词法分析（lexical anaysis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、语法分析（semantic-analysis）"><span class="toc-text">七、语法分析（semantic analysis）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、CodeGen"><span class="toc-text">八、CodeGen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、生成汇编代码"><span class="toc-text">九、生成汇编代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、汇编器"><span class="toc-text">十、汇编器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、链接"><span class="toc-text">十一、链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、XCode-编译"><span class="toc-text">十二、XCode 编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、编译顺序"><span class="toc-text">十三、编译顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四、增量编译"><span class="toc-text">十四、增量编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五、头文件"><span class="toc-text">十五、头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六、Clang-Module"><span class="toc-text">十六、Clang Module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七、Swift-编译"><span class="toc-text">十七、Swift 编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十八、深入理解-Linker"><span class="toc-text">十八、深入理解 Linker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十九、理解签名"><span class="toc-text">十九、理解签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十、iOS-App-签名"><span class="toc-text">二十、iOS App 签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#20-1-证书"><span class="toc-text">20.1 证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-Provisioning-Profile"><span class="toc-text">20.2 Provisioning Profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-3-iOS-签名"><span class="toc-text">20.3 iOS 签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-4-验证"><span class="toc-text">20.4 验证</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#二十一、文章"><span class="toc-text">二十一、文章</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaFramework/">iOS UmbrellaFramework</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS原理/iOS UmbrellaHeader/">iOS umbrella header</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/iOS/iOS媒体/iOS 图片/">iOS 图片</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS优化/iOS 优化实例/">iOS 优化实例</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/iOS/iOS原理/iOS 操作系统架构/">iOS 操作系统架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS架构/iOS 网络层设计/">iOS网络层设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS 类簇/">iOS 类簇</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS OCR/">iOS OCR</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/04/iOS/iOS原理/iOS IM/">iOS IM</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/iOS/iOS原理/iOS 推送/">iOS 推送</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IT/">IT</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenGL/">OpenGL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS优化/">iOS优化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS动画/">iOS动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS原理/">iOS原理</a><span class="category-list-count">42</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS多线程/">iOS多线程</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS媒体/">iOS媒体</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS安全/">iOS安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS架构/">iOS架构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">5</span></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p> 
京ICP备 - <a target="_blank" href="http://www.beian.miit.gov.cn">19039713号</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>