<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> GCD 深入		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> GCD 深入		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> GCD 深入		</h1><div class="post-meta"><a href="/2019/03/19/deep-gcd/#comments" class="comment-count"></a><p><span class="date">Mar 19, 2019</span><span><a href="/categories/多线程/" class="category">多线程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解 GCD</a>、<a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a></p>
<h5 id="一、知识储备"><a href="#一、知识储备" class="headerlink" title="一、知识储备"></a>一、知识储备</h5><p>阅读 <a href="https://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a>之前，需要了解一些相关知识。</p>
<p>1、DISPATCH_DECL</p>
<p>GCD 中对变量的定义大多遵循如下格式:</p>
<p>#define DISPATCH_DECL(name) typedef struct name##_s *name##_t </p>
<p>如 DISPATCH_DECL(dispatch_queue); 的展开形式是：typedef struct dispatch_queue_s *dispatch_queue_t; 这行代码定义了一个 dispatch_queue_t 类型的指针，指向一个 dispatch_queue_s 类型的结构体。</p>
<p>2、TSD</p>
<p>TSD（Thread-Specific Data）表示线程私有数据。在 C++ 中，全局变量可以被所有线程访问，局部变量只有函数内部可以访问。而 TSD 的作用就是能够在同一个线程的不同函数中被访问。在不同线程中，虽然名字相同，但是获取到的数据随线程不同而不同。通常我们可以利用 POSIX 库提供的 API 来实现 TSD：</p>
<p>int pthread_key_create(pthread_key_t *key, void (*destr_function) (void *))  </p>
<p>此函数用来创建一个 key，在线程退出时会将 key 对应的数据传入 destr_function 函数中进行清理。我们分别使用 get/set 方法来访问/修改 key 对应的数据：</p>
<p>int  pthread_setspecific(pthread_key_t  key,  const   void  *pointer)</p>
<p>void * pthread_getspecific(pthread_key_t key)  </p>
<p>在 GCD 中定义了六个 key，根据名字大概能猜出各自的含义：</p>
<p>pthread_key_t dispatch_queue_key;<br>pthread_key_t dispatch_sema4_key;<br>pthread_key_t dispatch_cache_key;<br>pthread_key_t dispatch_io_key;<br>pthread_key_t dispatch_apply_key;<br>pthread_key_t dispatch_bcounter_key;  </p>
<p>3、fastpath &amp;&amp; slowpath</p>
<p>这是定义在 internal.h 中的两个宏：</p>
<p>#define fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</p>
<p>#define slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</p>
<p>为了理解所谓的快路径和慢路径，需要先学习一点计算机基础知识。比如这段非常简单的代码：</p>
<p>if (x)<br>    return 1;<br>else<br>    return 39;</p>
<p>由于计算机并非一次只读取一条指令，而是读取多条指令，所以在读到 if 语句时也会把 return 1 读取进来。如果 x 为 0，那么会重新读取 return 39，重读指令相对来说比较耗时。如果 x 有非常大的概率是 0，那么 return 1 这条指令每次不可避免的会被读取，并且实际上几乎没有机会执行， 造成了不必要的指令重读。当然，最简单的优化就是：</p>
<p>if (!x)<br>    return 39;<br>else<br>    return 1;</p>
<p>然而对程序员来说，每次都做这样的判断非常烧脑，而且容易出错。于是 GCC 提供了一个内置函数 __builtin_expect：</p>
<p>long __builtin_expect (long EXP, long C)  </p>
<p>它的返回值就是整个函数的返回值，参数 C 代表预计的值，表示程序员知道 EXP 的值很可能就是 C。比如上文中的例子可以这样写：</p>
<p>if (__builtin_expect(x, 0))<br>    return 1;<br>else<br>    return 39;</p>
<p>虽然写法逻辑不变，但是编译器会把汇编代码优化成 if(!x) 的形式。因此，在苹果定义的两个宏中，fastpath(x) 依然返回 x，只是告诉编译器 x 的值一般不为 0，从而编译器可以进行优化。同理，slowpath(x) 表示 x 的值很可能为 0，希望编译器进行优化。</p>
<h5 id="二、dispatch-queue-t"><a href="#二、dispatch-queue-t" class="headerlink" title="二、dispatch_queue_t"></a>二、dispatch_queue_t</h5><p>以 dispatch_queue_create 的源码为例：</p>
<p>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr) {<br>    // 省略 label 相关的操作</p>
<pre><code>dispatch\_queue\_t dq;
dq = \_dispatch\_alloc(DISPATCH_VTABLE(queue),
        sizeof(struct dispatch\_queue\_s) - DISPATCH\_QUEUE\_MIN\_LABEL\_SIZE -
        DISPATCH\_QUEUE\_CACHELINE\_PAD + label\_len + 1);
\_dispatch\_queue_init(dq);
if (fastpath(!attr)) {
    return dq;
}

if (fastpath(attr == DISPATCH\_QUEUE\_CONCURRENT)) {
    dq-&gt;dq\_width = UINT32\_MAX;
    dq-&gt;do\_targetq = \_dispatch\_get\_root_queue(0, false);
}
else {
    dispatch\_debug\_assert(!attr, &quot;Invalid attribute&quot;);
}
return dq;
</code></pre><p>}</p>
<p>我们知道创建队列时， attr 属性有三个值可选，nil、DISPATCH_QUEUE_SERIAL（实际上就是 nil）或 DISPATCH_QUEUE_CONCURRENT。</p>
<p>第一个 if 判断中，苹果认为串行队列或者 NULL 参数更常见，因此 !attr 的值很有可能不为 0，这与上文的结论一致。</p>
<p>第二个判断中，参数几乎只可能是 DISPATCH_QUEUE_CONCURRENT，因此 attr == DISPATCH_QUEUE_CONCURRENT 这个判断几乎不会为 0，依然与 fastpath 的作用一致。</p>
<p>_dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载（overcommit）。这 8 个全局队列的序列号是 4-11，序列号为 1 的队列是主队列，2 是 manager 队列，用来管理 GCD 内部的任务（比如下文介绍的定时器），3 这个序列号暂时没有使用。队列 的 dq_width 被设置为 UINT32_MAX，表示这些队列不限制并发数。作为对比，在 _dispatch_queue_init 中，并发数限制为 1，也就是串行队列的默认设置：</p>
<p>static inline void _dispatch_queue_init(dispatch_queue_t dq) {<br>    dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;<br>    dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);<br>    dq-&gt;dq_running = 0;<br>    dq-&gt;dq_width = 1;<br>}</p>
<p>注意这行代码：dq-&gt;do_targetq = _dispatch_get_root_queue(0, true);，它涉及到 GCD 队列与 block 的一个重要模型，target_queue。向任何队列中提交的 block，都会被放到它的目标队列中执行，而普通串行队列的目标队列就是一个支持 overcommit 的全局队列，全局队列的底层则是一个线程池。借用 <a href="https://www.objc.io/issues/2-concurrency/concurrency-apis-and-pitfalls/" target="_blank" rel="noopener">objc 的文章</a> 中的图片来表示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-bf853ec94c911d23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="çº¿ç¨æ± ä¸ç®æ éå"></p>
<h5 id="二、dispatch-async"><a href="#二、dispatch-async" class="headerlink" title="二、dispatch_async"></a>二、dispatch_async</h5><p>直接上函数实现：</p>
<p>dispatch_async(dispatch_queue_t queue, dispatch_block_t block) {<br>    dispatch_async_f(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);<br>}</p>
<p>队列其实就是一个用来提交 block 的对象，当 block 提交到队列中后，将按照 “先入先出（FIFO）” 的顺序进行处理。系统在 GCD 的底层会维护一个线程池，用来执行这些 block。block 参数的类型是 dispatch_block_t，它是一个没有参数，没有返回值的 block：</p>
<p>typedef void (^dispatch_block_t)(void);</p>
<p>dispatch_async 的函数很简单，它将 block 复制了一份，然后调用另一个函数 dispatch_async_f：</p>
<p>dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);</p>
<p>work 参数是一个函数，在实际调用时，会把第二参数 context 作为参数传入，以 _dispatch_call_block_and_release 为例：</p>
<p>void _dispatch_call_block_and_release(void *block) {<br>    void (^b)(void) = block;<br>    b();<br>    Block_release(b);<br>}</p>
<p>省略各种分支后的 dispatch_async_f 函数实现如下：</p>
<p>void dispatch_async_f(dispatch_queue_t dq, void <em>ctxt, dispatch_function_t func) {<br>    dispatch_continuation_t dc;<br>    if (dq-&gt;dq_width == 1) {<br>        return dispatch_barrier_async_f(dq, ctxt, func);<br>    }<br>    dc-&gt;do_vtable = (void </em>)DISPATCH_OBJ_ASYNC_BIT;<br>    dc-&gt;dc_func = func;<br>    dc-&gt;dc_ctxt = ctxt;<br>    if (dq-&gt;do_targetq) {<br>        return _dispatch_async_f2(dq, dc);<br>    }<br>    _dispatch_queue_push(dq, dc);<br>}</p>
<p>可见如果是串行队列（dq_width = 1），会调用 dispatch_barrier_async_f 函数处理。如果有 do_targetq 则进行转发，否则调用 _dispatch_queue_push 入队。这里的 dispatch_continuation_t 其实是对 block 的封装，然后调用 _dispatch_queue_push 这个宏将封装好的 block 放入队列中。把这个宏展开，然后依次分析调用栈，选择一条主干调用线，结果如下:</p>
<p>_dispatch_queue_push<br>└──_dispatch_trace_queue_push<br>    └──_dispatch_queue_push<br>        └──_dispatch_queue_push_slow<br>            └──_dispatch_queue_push_list_slow2<br>                └──_dispatch_wakeup<br>                    └──dx_probe </p>
<p>队列中保存了一个链表，我们首先将新的 block 添加到链表尾部，然后调用 dx_probe 宏，它依赖于 vtable 数据结构，GCD 中的大部分对象，比如队列等，都具有这个数据结构。它定义了对象在不同操作下该执行的方法，比如在这里的 probe 操作下，实际上会执行 _dispatch_queue_wakeup_global 方法，调用栈如下</p>
<p>_dispatch_queue_wakeup_global<br>└──_dispatch_queue_wakeup_global2<br>    └──_dispatch_queue_wakeup_global_slow </p>
<p>在 _dispatch_queue_wakeup_global_slow 我们见到了熟悉的老朋友 pthread 线程：</p>
<p>static void _dispatch_queue_wakeup_global_slow(dispatch_queue_t dq, unsigned int n) {</p>
<pre><code>// 如果线程池已满，则直接调用 \_dispatch\_worker_thread 
// 否则创建线程池
pthread_t pthr;
while ((r = pthread\_create(&amp;pthr, NULL, \_dispatch\_worker\_thread, dq))) {
    if (r != EAGAIN) {
        (void)dispatch\_assume\_zero(r);
    }
    sleep(1);
}
r = pthread_detach(pthr);
(void)dispatch\_assume\_zero(r);
</code></pre><p>}</p>
<p>由此可见这里确实使用了线程池。创建线程后会执行 _dispatch_worker_thread 回调:</p>
<p>_dispatch_worker_thread<br>└──_dispatch_worker_thread4<br>    └──_dispatch_continuation_pop </p>
<p>在 pop 函数中，我们拿到了最早加入的任务，然后执行：</p>
<p>static inline void _dispatch_continuation_pop(dispatch_object_t dou) {<br>    // …<br>    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);<br>    if (dg) {<br>        dispatch_group_leave(dg);<br>        _dispatch_release(dg);<br>    }<br>}</p>
<p>dispatch_async 的实现比较复杂，主要是因为其中的数据结构较多，分支流程控制比较复杂。但思路其实很简单，用链表保存所有提交的 block，然后在底层线程池中，依次取出 block 并执行。如果熟悉了相关数据结构和调用流程，接下来研究 GCD 的其他 API 就比较轻松了。</p>
<h5 id="三、dispatch-sync"><a href="#三、dispatch-sync" class="headerlink" title="三、dispatch_sync"></a>三、dispatch_sync</h5><p>同步方法的实现相对来说和异步类似，而且更简单，调用栈如下:</p>
<p>dispatch_sync<br>└──dispatch_sync_f<br>    └──_dispatch_sync_f2<br>        └──_dispatch_sync_f_slow </p>
<p>static void _dispatch_sync_f_slow(dispatch_queue_t dq, void <em>ctxt, dispatch_function_t func) {<br>    _dispatch_thread_semaphore_t sema = _dispatch_get_thread_semaphore();<br>    struct dispatch_sync_slow_s {<br>        DISPATCH_CONTINUATION_HEADER(sync_slow);<br>    } dss = {<br>        .do_vtable = (void</em>)DISPATCH_OBJ_SYNC_SLOW_BIT,<br>        .dc_ctxt = (void<em>)sema,<br>    };<br>    _dispatch_queue_push(dq, (void </em>)&amp;dss);</p>
<pre><code>\_dispatch\_thread\_semaphore\_wait(sema);
\_dispatch\_put\_thread\_semaphore(sema);
// ...
</code></pre><p>}</p>
<p>这里利用了线程专属信号量，保证了每次只有一个 block 被执行。这条调用栈有多个分支，如果向当前串行队列提交任务就会走到上述分支，导致死锁。如果是向其它串行队列提交 block，则会利用原子性操作来实现，因此不会有死锁问题。</p>
<h5 id="四、dispatch-semaphore"><a href="#四、dispatch-semaphore" class="headerlink" title="四、dispatch_semaphore"></a>四、dispatch_semaphore</h5><p>关于信号量的 API 不多，主要是三个：create、wait 和 signal。信号量在初始化时要指定 value，随后内部将这个 value 存储起来。实际操作时会存两个 value，一个是当前的 value，一个是记录初始 value。信号的 wait 和 signal 是互逆的两个操作。如果 value &gt; 0，前者将 value - 1，此时如果 value &lt; 0 就一直等待。初始 value 必须 ≥ 0，如果为 0 并随后调用 wait 方法，线程将被阻塞直到别的线程调用了 signal 方法。</p>
<p>1、dispatch_semaphore_wait</p>
<p>首先从源码看起：</p>
<p>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout) {<br>    long value = dispatch_atomic_dec2o(dsema, dsema_value);<br>    dispatch_atomic_acquire_barrier();<br>    if (fastpath(value &gt;= 0)) {<br>        return 0;<br>    }<br>    return _dispatch_semaphore_wait_slow(dsema, timeout);<br>}</p>
<p>第一行的 dispatch_atomic_dec2o 是一个宏，会调用 GCC 内置的函数 __sync_sub_and_fetch，实现减法的原子性操作。因此这一行的意思是将 dsema 的值 -1，并把新的值赋给 value。如果减一后的 value ≥ 0 就立刻返回，没有任何操作，否则进入等待状态。_dispatch_semaphore_wait_slow 函数针对不同的 timeout 参数，分了三种情况考虑：</p>
<p>case DISPATCH_TIME_NOW:<br>    while ((orig = dsema-&gt;dsema_value) &lt; 0) {<br>        if (dispatch_atomic_cmpxchg2o(dsema, dsema_value, orig, orig + 1)) {<br>            return KERN_OPERATION_TIMED_OUT;<br>        }<br>    }</p>
<p>这种情况下会立刻判断 dsema-&gt;dsema_value 与 orig 是否相等。如果 while 判断成立，内部的 if 判断一定也成立，此时会将 value + 1（也就是变为 0）并返回。加一的原因是为了抵消 wait 函数一开始的减一操作。此时函数调用方会得到返回值 KERN_OPERATION_TIMED_OUT，表示由于等待时间超时而返回。实际上 while 判断一定会成立，因为如果 value 大于等于 0，在上一个函数 dispatch_semaphore_wait 中就已经返回了。</p>
<p>第二种情况是 DISPATCH_TIME_FOREVER 这个 case：</p>
<p>case DISPATCH_TIME_FOREVER:<br>    do {<br>        kr = semaphore_wait(dsema-&gt;dsema_port);<br>    } while (kr == KERN_ABORTED);<br>    break;</p>
<p>进入 do-while 循环后会调用系统的 semaphore_wait 方法，KERN_ABORTED 表示调用者被一个与信号量系统无关的原因唤醒。因此一旦发生这种情况，还是要继续等待，直到收到 signal 调用。在其他情况下（default 分支），我们指定一个超时时间，这和 DISPATCH_TIME_FOREVER 的处理比较类似，不同的是我们调用了内核提供的 semaphore_timedwait 方法可以指定超时时间。整个函数的框架如下：</p>
<p>static long _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) {<br>again:<br>    while ((orig = dsema-&gt;dsema_sent_ksignals)) {<br>        if (dispatch_atomic_cmpxchg2o(dsema, dsema_sent_ksignals, orig,<br>                orig - 1)) {<br>            return 0;<br>        }<br>    }<br>    switch (timeout) {<br>        default:  /<em> semaphore_timedwait </em>/<br>        case DISPATCH_TIME_NOW: /<em> KERN_OPERATION_TIMED_OUT </em>/<br>        case DISPATCH_TIME_FOREVER: /<em> semaphore_wait </em>/<br>    }<br>    goto again;<br>}</p>
<p>可见信号量被唤醒后，会回到最开始的地方，进入 while 循环。这个判断条件一般都会成立，极端情况下由于内核存在 bug，导致 orig 和 dsema_sent_ksignals 不相等，也就是收到虚假 signal 信号时会忽略。进入 while 循环后，if 判断一定成立，因此返回 0，正如文档所说，返回 0 表示成功，否则表示超时。</p>
<p>2、dispatch_semaphore_signal</p>
<p>这个函数的实现相对来说比较简单，因为它不需要阻塞，只用唤醒。简化版源码如下：</p>
<p>long dispatch_semaphore_signal(dispatch_semaphore_t dsema) {<br>    long value = dispatch_atomic_inc2o(dsema, dsema_value);<br>    if (fastpath(value &gt; 0)) {<br>        return 0;<br>    }<br>    return _dispatch_semaphore_signal_slow(dsema);<br>}</p>
<p>首先会调用原子方法让 value + 1，如果大于零就立刻返回 0，否则返回 _dispatch_semaphore_signal_slow：</p>
<p>long _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema) {<br>    (void)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals);<br>    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);<br>    kern_return_t kr = semaphore_signal(dsema-&gt;dsema_port);<br>    return 1;<br>}</p>
<p>它的作用仅仅是调用内核的 semaphore_signal 函数唤醒信号量，然后返回 1。这也符合文档中的描述：“如果唤醒了线程，返回非 0，否则返回 0”。</p>
<h5 id="五、dispatch-group"><a href="#五、dispatch-group" class="headerlink" title="五、dispatch_group"></a>五、dispatch_group</h5><p>有了上面的铺垫，group 是一个非常容易理解的概念，我们先看看如何创建 group：</p>
<p>dispatch_group_t dispatch_group_create(void) {<br>    dispatch_group_t dg = _dispatch_alloc(DISPATCH_VTABLE(group), sizeof(struct dispatch_semaphore_s));<br>    _dispatch_semaphore_init(LONG_MAX, dg);<br>    return dg;<br>}</p>
<p>没错，group 就是一个 value 为 LONG_MAX 的信号量。</p>
<p>1、dispatch_group_async</p>
<p>它仅仅是 dispatch_group_async_f 的封装：</p>
<p>void dispatch_group_async_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, dispatch_function_t func) {<br>    dispatch_continuation_t dc;<br>    dispatch_group_enter(dg);</p>
<pre><code>dc = \_dispatch\_continuation_alloc();
dc-&gt;do\_vtable = (void *)(DISPATCH\_OBJ\_ASYNC\_BIT | DISPATCH\_OBJ\_GROUP_BIT);
dc-&gt;dc_func = func;
dc-&gt;dc_ctxt = ctxt;
dc-&gt;dc_data = dg;
\_dispatch\_queue_push(dq, dc);
</code></pre><p>}</p>
<p>这个函数和 dispatch_async_f 的实现高度一致，主要的不同在于调用了 dispatch_group_enter 方法：</p>
<p>void dispatch_group_enter(dispatch_group_t dg) {<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    (void)dispatch_semaphore_wait(dsema, DISPATCH_TIME_FOREVER);<br>}</p>
<p>这个方法也没做什么，就是调用 wait 方法让信号量的 value 减一而已。</p>
<p>2、dispatch_group_wait</p>
<p>这个方法用于等待 group 中所有任务执行完成，可以理解为信号量 wait 的封装：</p>
<p>long dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout) {<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    if (dsema-&gt;dsema_value == dsema-&gt;dsema_orig) {<br>        return 0;<br>    }<br>    if (timeout == 0) {<br>        return KERN_OPERATION_TIMED_OUT;<br>    }<br>    return _dispatch_group_wait_slow(dsema, timeout);<br>}</p>
<p>如果当前 value 和原始 value 相同，表明任务已经全部完成，直接返回 0，如果 timeout 为 0 也会立刻返回，否则调用 _dispatch_group_wait_slow。这个方法的等待部分和 _dispatch_semaphore_signal_slow 几乎一致，区别在于等待结束后它不是 return，而是调用 _dispatch_group_wake 去唤醒这个 group。</p>
<p>static long _dispatch_group_wait_slow(dispatch_semaphore_t dsema, dispatch_time_t timeout) {<br>again:<br>    _dispatch_group_wake(dsema);<br>    switch (timeout) {/<em> 三种情况分类 </em>/}<br>    goto again;<br>}</p>
<p>这里我们暂时跳过 _dispatch_group_wake，后面会有详细分析。只要知道这个函数在 group 中所有事件执行完后会被调用即可。</p>
<p>3、dispatch_group_notify</p>
<p>这个函数仅仅是封装了 dispatch_group_notify_f：</p>
<p>void dispatch_group_notify_f(dispatch_group_t dg, dispatch_queue_t dq, void *ctxt, void (*func)(void <em>)) {<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    struct dispatch_sema_notify_s \</em>dsn, *prev;</p>
<pre><code>dsn-&gt;dsn_queue = dq;
dsn-&gt;dsn_ctxt = ctxt;
dsn-&gt;dsn_func = func;
prev = dispatch\_atomic\_xchg2o(dsema, dsema\_notify\_tail, dsn);
if (fastpath(prev)) {
    prev-&gt;dsn_next = dsn;
} else {/* ... */}
</code></pre><p>}</p>
<p>这种结构的代码已经遇到多次了，它其实就是在链表的尾部续上新的元素。所以 notify 方法并没有做过多的处理，只是用链表把所有回调通知保存起来，等待调用。</p>
<p>4、dispatch_group_leave</p>
<p>在介绍 dispatch_async 函数时，我们看到任务在被执行时，还会调用 dispatch_group_leave 函数：</p>
<p>void dispatch_group_leave(dispatch_group_t dg) {<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    long value = dispatch_atomic_inc2o(dsema, dsema_value);<br>    if (slowpath(value == dsema-&gt;dsema_orig)) {<br>        (void)_dispatch_group_wake(dsema);<br>    }<br>}</p>
<p>当 group 的 value 变为初始值时，表示所有任务都已执行完，开始调用 _dispatch_group_wake 处理回调。  </p>
<p>5、dispatch_group_wake</p>
<p>static long _dispatch_group_wake(dispatch_semaphore_t dsema) {<br>    struct dispatch_sema_notify_s *next, *head, *tail = NULL;<br>    long rval;<br>    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, NULL);</p>
<pre><code>if (head) {
    tail = dispatch\_atomic\_xchg2o(dsema, dsema\_notify\_tail, NULL);
}
rval = dispatch\_atomic\_xchg2o(dsema, dsema\_group\_waiters, 0);
if (rval) {
    \_dispatch\_semaphore\_create\_port(&amp;dsema-&gt;dsema\_waiter\_port);
    do {
        kern\_return\_t kr = semaphore\_signal(dsema-&gt;dsema\_waiter_port);
    } while (--rval);
}
if (head) {
    // async group notify blocks
    do {
        dispatch\_async\_f(head-&gt;dsn\_queue, head-&gt;dsn\_ctxt, head-&gt;dsn_func);
        next = fastpath(head-&gt;dsn_next);
        if (!next &amp;&amp; head != tail) {
            while (!(next = fastpath(head-&gt;dsn_next))) {
                \_dispatch\_hardware_pause();
            }
        }
        free(head);
    } while ((head = next));
}
return 0;
</code></pre><p>}</p>
<p>这个函数主要分为两部分，首先循环调用 semaphore_signal 告知唤醒当初等待 group 的信号量，因此 dispatch_group_wait 函数得以返回。然后获取链表，依次调用 dispatch_async_f 异步执行在 notify 函数中注册的回调。</p>
<h5 id="六、dispatch-once"><a href="#六、dispatch-once" class="headerlink" title="六、dispatch_once"></a>六、dispatch_once</h5><p>dispatch_once 仅仅是一个包装，内部直接调用了 dispatch_once_f：</p>
<p>void dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func) {<br>    struct _dispatch_once_waiter_s <em> volatile \</em>vval = (struct _dispatch_once_waiter_s**)val;<br>    struct _dispatch_once_waiter_s dow = { NULL, 0 };<br>    struct _dispatch_once_waiter_s *tail, *tmp;<br>    _dispatch_thread_semaphore_t sema;</p>
<pre><code>if (dispatch\_atomic\_cmpxchg(vval, NULL, &amp;dow)) {
    \_dispatch\_client_callout(ctxt, func);
    tmp = dispatch\_atomic\_xchg(vval, DISPATCH\_ONCE\_DONE);
    tail = &amp;dow;
    while (tail != tmp) {
        while (!tmp-&gt;dow_next) {
            \_dispatch\_hardware_pause();
        }
        sema = tmp-&gt;dow_sema;
        tmp = (struct \_dispatch\_once\_waiter\_s*)tmp-&gt;dow_next;
        \_dispatch\_thread\_semaphore\_signal(sema);
    }
} else {
    dow.dow\_sema = \_dispatch\_get\_thread_semaphore();
    for (;;) {
        tmp = *vval;
        if (tmp == DISPATCH\_ONCE\_DONE) {
            break;
        }
        dispatch\_atomic\_store_barrier();
        if (dispatch\_atomic\_cmpxchg(vval, tmp, &amp;dow)) {
            dow.dow_next = tmp;
            \_dispatch\_thread\_semaphore\_wait(dow.dow_sema);
        }
    }
    \_dispatch\_put\_thread\_semaphore(dow.dow_sema);
}
</code></pre><p>}</p>
<p>这段代码比较长，我们考虑三个场景：</p>
<p>①、第一次调用：此时外部传进来的 onceToken 还是空指针，所以 vval 为 NULL，if 判断成立。</p>
<p>首先执行 block，然后让将 vval 的值设为 DISPATCH_ONCE_DONE 表示任务已经完成，同时用 tmp 保存先前的 vval。此时，dow 也为空，因此 while 判断不成立，代码执行结束。</p>
<p>②、同一线程第二次调用：由于 vval 已经变成了 DISPATCH_ONCE_DONE，因此 if 判断不成立，进入 else 分支的 for 循环。</p>
<p>由于 tmp 就是 DISPATCH_ONCE_DONE，所以循环退出，没有做任何事。</p>
<p>③、多个线程同时调用：由于 if 判断中是一个原子性操作，所以必然只有一个线程能进入 if 分支，其他的进入 else 分支。</p>
<p>由于其他线程在调用函数时，vval 还不是 DISPATCH_ONCE_DONE，所以进入到 for 循环的后半部分。这里构造了一个链表，链表的每个节点上都调用了信号量的 wait 方法并阻塞，而在 if 分支中，则会依次遍历所有的节点并调用 signal 方法，唤醒所有等待中的信号量。</p>
<h5 id="七、dispatch-barrier-async"><a href="#七、dispatch-barrier-async" class="headerlink" title="七、dispatch_barrier_async"></a>七、dispatch_barrier_async</h5><p>它调用了 dispatch_barrier_async_f 函数，实现原理也和 dispatch_async_f 类似：</p>
<p>void dispatch_barrier_async_f(dispatch_queue_t dq, void <em>ctxt, dispatch_function_t func) {<br>    dispatch_continuation_t dc;<br>    dc = fastpath(_dispatch_continuation_alloc_cacheonly());<br>    dc-&gt;do_vtable = (void </em>)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);<br>    dc-&gt;dc_func = func;<br>    dc-&gt;dc_ctxt = ctxt;<br>    _dispatch_queue_push(dq, dc);<br>}</p>
<p>区别在于 do_vtable 被设置了两个标志位，多了一个 DISPATCH_OBJ_BARRIER_BIT 标记。这个标记在从队列中取出任务时被用到：</p>
<p>static _dispatch_thread_semaphore_t _dispatch_queue_drain(dispatch_queue_t dq) {<br>    while (dq-&gt;dq_items_tail) {<br>        /* … <em>/<br>        if (!DISPATCH_OBJ_IS_VTABLE(dc) &amp;&amp; (long)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) {<br>            if (dq-&gt;dq_running &gt; 1) {<br>                goto out;<br>            }<br>        } else {<br>            _dispatch_continuation_redirect(dq, dc);<br>            continue;<br>        }<br>    }<br>out:<br>    /\</em> 不完整的 drain，需要清理现场 */<br>    return sema; // 返回空的信号量<br>}</p>
<p>这里原来是一个循环，会拿出所有的任务，依次调用 _dispatch_continuation_redirect，最终并行处理。一旦遇到 DISPATCH_OBJ_BARRIER_BIT 这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行：</p>
<p>void _dispatch_queue_invoke(dispatch_queue_t dq) {<br>    _dispatch_thread_semaphore_t sema = _dispatch_queue_drain(dq);<br>    if (sema) {<br>        _dispatch_thread_semaphore_signal(sema);<br>    } else if (tq) {<br>        return _dispatch_queue_push(tq, dq);<br>    }<br>}</p>
<p>因此 barrier 方法能等待此前所有任务执行完以后执行 _dispatch_queue_push，同时保证自己执行完以后才执行后续的操作。</p>
<h5 id="八、dispatch-source"><a href="#八、dispatch-source" class="headerlink" title="八、dispatch_source"></a>八、dispatch_source</h5><p>source 是一种资源，类似于生产者/消费者模式中的生产者，而队列则是消费者。当有新的资源（source）产生时，它们被放到对应的队列上被执行（消费）。dispatch_source 最常见的用途之一就是用来实现定时器，举一个小例子：  </p>
<p>dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);  </p>
<p>// 每 10 秒触发 timer，误差 1 秒<br>dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), 10*NSEC_PER_SEC, 1*NSEC_PER_SEC);</p>
<p>dispatch_source_set_event_handler(timer, ^{<br>    // 定时器触发时执行的 block<br>});<br>dispatch_resume(timer);  </p>
<p>使用 GCD Timer 的好处在于不依赖 runloop，因此任何线程都可以使用。由于使用了 block，不会忘记避免循环引用。此外，定时器可以自由控制精度，随时修改间隔时间等。</p>
<p>1、dispatch_source_create</p>
<p>下面从底层源码的角度来研究这几行代码的作用。首先是 dispatch_source_create 函数，它和之前见到的 create 函数都差不多，对 dispatch_source_t 对象做了一些初始化工作：</p>
<p>dispatch_source_t ds = NULL;<br>ds = _dispatch_alloc(DISPATCH_VTABLE(source), sizeof(struct dispatch_source_s));<br>_dispatch_queue_init((dispatch_queue_t)ds);<br>ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;<br>ds-&gt;do_targetq = &amp;_dispatch_mgr_q;<br>dispatch_set_target_queue(ds, q);<br>return ds;  </p>
<p>这里涉及到两个队列，其中 q 是用户指定的队列，表示事件触发的回调在哪个队列执行。而 _dispatch_mgr_q 则表示由哪个队列来管理这个 source，mgr 是 manager 的缩写，也是上文提到的序列号为 2 的内部队列。</p>
<p>2、dispatch_source_set_timer</p>
<p>在这个函数中，首先会有参数处理，过滤掉不符合要求的参数。随后创建了 dispatch_set_timer_params 类型的指针 params：</p>
<p>struct dispatch_set_timer_params {<br>    dispatch_source_t ds;<br>    uintptr_t ident;<br>    struct dispatch_timer_source_s values;<br>};</p>
<p>这个 params 负责绑定定时器对象与它的参数（存储在 values 属性中），最后调用：  </p>
<p>dispatch_barrier_async_f((dispatch_queue_t)ds, params, _dispatch_source_set_timer2);</p>
<p>这里是把 source 当做队列来使用，因此实际上是调用了 _dispatch_source_set_timer2(params) 方法：</p>
<p>static void _dispatch_source_set_timer2(void <em>context) {<br>    // Called on the source queue<br>    struct dispatch_set_timer_params </em>params = context;<br>    dispatch_suspend(params-&gt;ds);<br>    dispatch_barrier_async_f(&amp;_dispatch_mgr_q, params,<br>            _dispatch_source_set_timer3);<br>}</p>
<p>这里首先暂停了队列，避免了修改的过程中定时器被触发。然后在 manager 队列上执行 _dispatch_source_set_timer3(params)：</p>
<p>static void _dispatch_source_set_timer3(void <em>context) {<br>    struct dispatch_set_timer_params </em>params = context;<br>    dispatch_source_t ds = params-&gt;ds;<br>    // …<br>    _dispatch_timer_list_update(ds);<br>    dispatch_resume(ds);<br>}</p>
<p>_dispatch_timer_list_update 函数的作用是根据下一次触发时间将 timer 排序。接下来，当初分发到 manager 队列的 block 将要被执行，走到 _dispatch_mgr_invoke 函数，其中有如下代码：</p>
<p>timeoutp = _dispatch_get_next_timer_fire(&amp;timeout);<br>r = select(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, NULL, sel_timeoutp);</p>
<p>可见 GCD 的定时器是由系统的 select 方法实现的。当内层的 manager 队列被唤醒后，还会进一步唤醒外层的队列（当初用户指定的那个），并在队列上执行 timer 触发时的 block。</p>
<h5 id="九、dispatch-resume-suspend"><a href="#九、dispatch-resume-suspend" class="headerlink" title="九、dispatch_resume/suspend"></a>九、dispatch_resume/suspend</h5><p>GCD 对象的暂停和恢复由 do_suspend_cnt 决定，暂停时通过原子操作将该属性的值加 2，对应的在恢复时通过原子操作将该属性减 2。它有两个默认值：</p>
<p>#define DISPATCH_OBJECT_SUSPEND_LOCK        1u</p>
<p>#define DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</p>
<p>在唤醒队列时有如下代码：</p>
<p>void _dispatch_queue_invoke(dispatch_queue_t dq) {<br>    if (!dispatch_atomic_sub2o(dq, do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_LOCK)) {<br>        if (dq-&gt;dq_running == 0) {<br>            _dispatch_wakeup(dq); // verify that the queue is idle<br>        }<br>    }<br>}</p>
<p>可见能够唤醒队列的前提是 dq-&gt;do_suspend_cnt - 1 = 0，也就是要求 do_suspend_cnt 的值就是 DISPATCH_OBJECT_SUSPEND_LOCK。观察 8 个全局队列和主队列的定义就会发现，他们的 do_suspend_cnt 值确实为 DISPATCH_OBJECT_SUSPEND_LOCK，因此默认处于启动状态。而 dispatch_source 的 create 方法中，do_suspend_cnt 的初始值为 DISPATCH_OBJECT_SUSPEND_INTERVAL，因此默认处于暂停状态，需要手动开启。</p>
<h5 id="十、dispatch-after"><a href="#十、dispatch-after" class="headerlink" title="十、dispatch_after"></a>十、dispatch_after</h5><p>dispatch_after 其实依赖于定时器的实现，函数内部调用了 dispatch_after_f：</p>
<p>void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void <em>ctxt, dispatch_function_t func) {<br>    uint64_t delta;<br>    struct _dispatch_after_time_s </em>datc = NULL;<br>    dispatch_source_t ds;</p>
<pre><code>// 如果延迟为 0，直接调用 dispatch_async
delta = \_dispatch\_timeout(when);
if (delta == 0) {
    return dispatch\_async\_f(queue, ctxt, func);
}

ds = dispatch\_source\_create(DISPATCH\_SOURCE\_TYPE_TIMER, 0, 0, queue);
dispatch_assert(ds);

datc = malloc(sizeof(*datc));
dispatch_assert(datc);
datc-&gt;datc_ctxt = ctxt;
datc-&gt;datc_func = func;
datc-&gt;ds = ds;

dispatch\_set\_context(ds, datc);
dispatch\_source\_set\_event\_handler\_f(ds, \_dispatch\_after\_timer_callback);
dispatch\_source\_set\_timer(ds, when, DISPATCH\_TIME_FOREVER, 0);
dispatch_resume(ds);
</code></pre><p>}</p>
<p>首先将延迟执行的 block 封装在 _dispatch_after_time_s 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。到时以后，执行 _dispatch_after_timer_callback 回调，并取出上下文中的 block：</p>
<p>static void _dispatch_after_timer_callback(void <em>ctxt) {<br>    struct _dispatch_after_time_s </em>datc = ctxt;<br>    _dispatch_client_callout(datc-&gt;datc_ctxt, datc-&gt;datc_func);<br>    // 清理工作<br>}</p>
<h5 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h5><p>本文主要整理了 GCD 中常见的 API 以及底层的实现原理。</p>
<p>①、对于队列来说，需要理解它的数据结构，转发机制，以及底层的线程池模型。</p>
<p>②、dispatch_async 会把任务添加到队列的一个链表中，添加完后会唤醒队列，根据 vtable 中的函数指针，调用 wakeup 方法。在 wakeup 方法中，从线程池里取出工作线程（如果没有就新建），然后在工作线程中取出链表头部指向的 block 并执行。</p>
<p>③、dispatch_sync 的实现略简单一些，它不涉及线程池（因此一般都在当前线程执行），而是利用与线程绑定的信号量来实现串行。分发到不同队列时，代码进入的分支也不一样，比如 dispatch_async 到主队列的任务由 runloop 处理，而分发到其他队列的任务由线程池处理。在当前串行队列中执行 dispatch_sync 时，由于 dq_running 属性（表示在运行的任务数量）为 1，所以以下判断成立：</p>
<p>if (slowpath(!dispatch_atomic_cmpxchg2o(dq, dq_running, 0, 1))) {<br>    return _dispatch_barrier_sync_f_slow(dq, ctxt, func);<br>}</p>
<p>在 _dispatch_barrier_sync_f_slow 函数中使用了线程对应的信号量并且调用 wait 方法，从而导致线程死锁。如果向其它队列同步提交 block，最终进入 _dispatch_barrier_sync_f_invoke，它只是保证了 block 执行的原子性，但没有使用线程对应的信号量。</p>
<p>④、对于信号量来说，它主要使用 signal 和 wait 这两个接口，底层分别调用了内核提供的方法。在调用 signal 方法后，先将 value 减一，如果大于零立刻返回，否则陷入等待。signal 方法将信号量加一，如果 value 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。</p>
<p>⑤、dispatch_group 的本质就是一个 value 非常大的信号量，等待 group 完成实际上就是等待 value 恢复初始值。而 notify 的作用是将所有注册的回调组装成一个链表，在 dispatch_async 完成时判断 value 是不是恢复初始值，如果是则调用 dispatch_async 异步执行所有注册的回调。</p>
<p>⑥、dispatch_once 通过一个静态变量来标记 block 是否已被执行，同时使用信号量确保只有一个线程能执行，执行完 block 后会唤醒其他所有等待的线程。</p>
<p>⑦、dispatch_barrier_async 改变了 block 的 vtable 标记位，当它将要被取出执行时，会等待前面的 block 都执行完，然后在下一次循环中被执行。</p>
<p>⑧、dispatch_source 可以用来实现定时器。所有的 source 会被提交到用户指定的队列，然后提交到 manager 队列中，按照触发时间排好序。随后找到最近触发的定时器，调用内核的 select 方法等待。等待结束后，依次唤醒 manager 队列和用户指定队列，最终触发一开始设置的回调 block。</p>
<p>⑨、GCD 中的对象用 do_suspend_cnt 来表示是否暂停。队列默认处于启动状态，而 dispatch_source 需要手动启动。</p>
<p>⑩、dispatch_after 函数依赖于 dispatch_source 定时器，它只是注册了一个定时器，然后在回调函数中执行 block。</p>
<h5 id="十二、参考资料"><a href="#十二、参考资料" class="headerlink" title="十二、参考资料"></a>十二、参考资料</h5><p><a href="http://stackoverflow.com/questions/7346929/why-do-we-use-builtin-expect-when-a-straightforward-way-is-to-use-if-else" target="_blank" rel="noopener">Why do we use _builtinexpect when a straightforward way is to use if-else</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/" target="_blank" rel="noopener">Posix线程编程指南(2) 线程私有数据</a></p>
<p><a href="http://www.jianshu.com/p/0c050af6c5ee" target="_blank" rel="noopener">选择 GCD 还是 NSTimer？</a></p>
<p><a href="https://yq.aliyun.com/articles/17709" target="_blank" rel="noopener">从NSTimer的失效性谈起（二）：关于GCD Timer和libdispatch</a></p>
<p><a href="http://blog.csdn.net/u012878842/article/list/4" target="_blank" rel="noopener">变态的libDispatch源码分析</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/19/deep-gcd/">http://yoursite.com/2019/03/19/deep-gcd/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/19/nsoperation-e3-80-81nsoperationqueue/" class="pre"> NSOperation、NSOperationQueue		</a><a href="/2019/03/19/gcd/" class="next"> GCD		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、知识储备"><span class="toc-text">一、知识储备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、dispatch-queue-t"><span class="toc-text">二、dispatch_queue_t</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、dispatch-async"><span class="toc-text">二、dispatch_async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、dispatch-sync"><span class="toc-text">三、dispatch_sync</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、dispatch-semaphore"><span class="toc-text">四、dispatch_semaphore</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、dispatch-group"><span class="toc-text">五、dispatch_group</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、dispatch-once"><span class="toc-text">六、dispatch_once</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、dispatch-barrier-async"><span class="toc-text">七、dispatch_barrier_async</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八、dispatch-source"><span class="toc-text">八、dispatch_source</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#九、dispatch-resume-suspend"><span class="toc-text">九、dispatch_resume/suspend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十、dispatch-after"><span class="toc-text">十、dispatch_after</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十一、总结"><span class="toc-text">十一、总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十二、参考资料"><span class="toc-text">十二、参考资料</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>