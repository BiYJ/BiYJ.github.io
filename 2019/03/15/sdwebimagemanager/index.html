<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> SDWebImageManager		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> SDWebImageManager		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> SDWebImageManager		</h1><div class="post-meta"><a href="/2019/03/15/sdwebimagemanager/#comments" class="comment-count"></a><p><span class="date">Mar 15, 2019</span><span><a href="/categories/SDWebImage/" class="category">SDWebImage</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://www.cnblogs.com/machao/p/6323337.html" target="_blank" rel="noopener">SDWebImage源码解读之SDWebImageManager</a></p>
<p>SDWebImageManager 是 SDWebImage 中最核心的类，但是源代码确是非常简单的。这一切都归功于功能的良好分类。</p>
<p>有了 SDWebImageManager 这个基石，就能做很多其他的有意思的事情。比如给各种 view 绑定一个 URL，就能显示图片的功能，有了 Options，就能满足多种应用场景的图片下载任务。</p>
<p>读源码既能让我们更好地使用该框架，又能学到很多知识，还能让我们懂得如何去扩充现有的功能。</p>
<h5 id="一、-h-文件"><a href="#一、-h-文件" class="headerlink" title="一、.h 文件"></a>一、.h 文件</h5><p>typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) {<br>    /**<br>     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won’t keep trying.<br>     * This flag disable this blacklisting.<br>     *<br>     * 每一个下载都会提供一个 URL，如果这个 URL 是错误，SD 就会把它放入到黑名单之中，黑名单中的 URL 是不会再次进行下载的<br>     * 但是，当设置了该选项时，SD 会将其在黑名单中移除，重新下载该 URL<br>     */<br>    SDWebImageRetryFailed = 1 &lt;&lt; 0,</p>
<pre><code>/\*\*
 \* By default, image downloads are started during UI interactions, this flags disable this feature,
 \* leading to delayed download on UIScrollView deceleration for instance.
 \*
 \* 一般来说，下载都是按照一定的先后顺序开始的，但是该选项能够延迟下载，也就说他的权限比较低，权限比他高的在他前边下载 
 */
SDWebImageLowPriority = 1 &lt;&lt; 1,

/\*\*
 \* This flag disables on-disk caching after the download finished, only cache in memory
 \*
 \* 该选项要求 SD 只把图片缓存到内存中，不缓存到 disk 中 
 */
SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,

/\*\*
 \* This flag enables progressive download, the image is displayed progressively during download as a browser would do.
 \* By default, the image is only displayed once completely downloaded.
 \*
 \* 给下载添加进度。默认情况下，图像只显示一次完全下载。
 */
SDWebImageProgressiveDownload = 1 &lt;&lt; 3,

/\*\*
 \* Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.
 \* The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.
 \* This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.
 \* If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.
 \*
 \* Use this flag only if you can&apos;t make your URLs static with embedded cache busting parameter.
 \*
 \* 有这么一种使用场景，如果一个图片的资源发生了改变。但是 url 并没有变，我们就可以使用该选项来刷新数据了
 */
SDWebImageRefreshCached = 1 &lt;&lt; 4,

/\*\*
 \* In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for
 \* extra time in background to let the request finish. If the background task expires the operation will be cancelled.
 \* 支持切换到后台也能下载
 */
SDWebImageContinueInBackground = 1 &lt;&lt; 5,

/\*\*
 \* Handles cookies stored in NSHTTPCookieStore by setting NSMutableURLRequest.HTTPShouldHandleCookies = YES;
 \*
 \* 使用Cookies
 */
SDWebImageHandleCookies = 1 &lt;&lt; 6,

/\*\*
 \* Enable to allow untrusted SSL certificates. Useful for testing purposes. Use with caution in production.
 \*
 \* 允许验证证书
 */
SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,

/\*\*
 \* By default, images are loaded in the order in which they were queued. This flag moves them to the front of the queue.
 \* 高权限
 */
SDWebImageHighPriority = 1 &lt;&lt; 8,

/\*\*
 \* By default, placeholder images are loaded while the image is loading. This flag will delay the loading
 \* of the placeholder image until after the image has finished loading.
 \*
 \* 一般情况下，placeholder image 都会在图片下载完成前显示，该选项将设置 placeholder image 在下载完成之后才能显示
 */
SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,

/\*\*
 \* We usually don&apos;t call transformDownloadedImage delegate method on animated images,
 \* as most transformation code would mangle it.
 \* Use this flag to transform them anyway.
 \*
 \* 使用该属性来自由改变图片，但需要使用 transformDownloadedImage delegate
 */
SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,

/\*\*
 \* By default, image is added to the imageView after download. But in some cases, we want to
 \* have the hand before setting the image (apply a filter or add it with cross-fade animation for instance)
 \* Use this flag if you want to manually set the image in the completion when success
 \*
 \* 该选项允许我们在图片下载完成后不会立刻给 view 设置图片，比较常用的使用场景是给赋值的图片添加动画
 */
SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,

/\*\*
 \* By default, images are decoded respecting their original size. On iOS, this flag will scale down the
 \* images to a size compatible with the constrained memory of devices.
 \* If \`SDWebImageProgressiveDownload\` flag is set the scale down is deactivated.
 \*
 \* 压缩大图片
 */
SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,

/\*\*
 \* By default, we do not query disk data when the image is cached in memory. This mask can force to query disk data at the same time.
 \* This flag is recommend to be used with \`SDWebImageQueryDiskSync\` to ensure the image is loaded in the same runloop. 
 \*
 \* 默认情况下，当图像缓存在内存中时，不查询 disk 数据。此枚举值可以强制同时查询 disk 数据。 
 \* 建议将此标志与 &apos;sdwebimagequerydisksync&apos; 一起使用，以确保在同一个 runloop 中加载图像。
 */
SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,

/\*\*
 \* By default, we query the memory cache synchronously, disk cache asynchronously. This mask can force to query disk cache synchronously to ensure that image is loaded in the same runloop.
 \* This flag can avoid flashing during cell reuse if you disable memory cache or in some other cases.
 \*
 \* 默认情况下，在内存查找时是同步，在硬盘查找时是异步。这个枚举值强制同步查找 disk，以确保在同一个 runloop 中加载图像。
 */
SDWebImageQueryDiskSync = 1 &lt;&lt; 14,

/\*\*
 \* By default, when the cache missed, the image is download from the network. This flag can prevent network to load from cache only.
 \* 只从缓存中取，不使用网络
 */
SDWebImageFromCacheOnly = 1 &lt;&lt; 15,
/\*\*
 \* By default, when you use \`SDWebImageTransition\` to do some view transition after the image load finished, this transition is only applied for image download from the network. This mask can force to apply view transition for memory and disk cache as well.
 \* &apos;SDWebImageTransition&apos; 只应用于网络加载图片，此枚举值使得同样应用于 memory 和 disk 缓存
 */
SDWebImageForceTransition = 1 &lt;&lt; 16
</code></pre><p>};</p>
<p>SDWebImageOptions 作为下载的选项提供了非常多的子项。</p>
<p>typedef void(^SDExternalCompletionBlock)(UIImage <em> _Nullable image, NSError </em> _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</p>
<p>typedef void(^SDInternalCompletionBlock)(UIImage <em> _Nullable image, NSData </em> _Nullable data, NSError <em> _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL </em> _Nullable imageURL);</p>
<p>typedef NSString <em> _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL </em> _Nullable url);</p>
<p>typedef NSData <em> _Nullable(^SDWebImageCacheSerializerBlock)(UIImage </em> _Nonnull image, NSData <em> _Nullable data, NSURL </em> _Nullable imageURL);</p>
<p>在平时的开发中，使用 Block 可以参考上边的使用方法，XXXxxxCompletionBlock 这种命名应该是 Apple 的风格。</p>
<p>@protocol SDWebImageManagerDelegate <nsobject></nsobject></p>
<p>@optional</p>
<p>/**<br> * Controls which image should be downloaded when the image is not found in the cache.<br> *<br> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.<br> *<br> * 在缓存中没发现图片，控制是否通过网络下载该图片。如果没有实现这个方法，默认为 YES<br> */<br>- (BOOL)imageManager:(nonnull SDWebImageManager <em>)imageManager shouldDownloadImageForURL:(nullable NSURL </em>)imageURL;</p>
<p>/**<br> * Controls the complicated logic to mark as failed URLs when download error occur.<br> * If the delegate implement this method, we will not use the built-in way to mark URL as failed based on error code;<br> *<br> * @return Whether to block this url or not. Return YES to mark this URL as failed.<br> *<br> * 控制在发生错误的时候标记为失败 url 的复杂逻辑<br> */<br>- (BOOL)imageManager:(nonnull SDWebImageManager <em>)imageManager shouldBlockFailedURL:(nonnull NSURL </em>)imageURL withError:(nonnull NSError *)error;</p>
<p>/**<br> * Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.<br> * NOTE: This method is called from a global queue in order to not to block the main thread.<br> *<br> * @return The transformed image object.<br> *<br> * 网络下载之后，缓存之前，自由转换图片<br> */<br>- (nullable UIImage <em>)imageManager:(nonnull SDWebImageManager </em>)imageManager transformDownloadedImage:(nullable UIImage <em>)image withURL:(nullable NSURL </em>)imageURL;</p>
<p>@end</p>
<p>使用协议增加了我们编程的灵活性，SDWebImageManagerDelegate 提供了三个方法。</p>
<p>/**<br> * The SDWebImageManager is the class behind the UIImageView+WebCache category and likes.<br> * It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache).<br> * You can use this class directly to benefit from web image downloading with caching in another context than<br> * a UIView.<br> *<br> * Here is a simple example of how to use SDWebImageManager:<br> *<br> * @code</p>
<p>SDWebImageManager <em>manager = [SDWebImageManager sharedManager];<br>[manager loadImageWithURL:imageURL<br>                  options:0<br>                 progress:nil<br>                completed:^(UIImage \</em>image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {<br>                    if (image) {<br>                        // do something with image<br>                    }<br>                }];</p>
<p> * @endcode<br> */<br>@interface SDWebImageManager : NSObject</p>
<p>1、属性</p>
<p>@property (strong, nonatomic, readonly, nullable) SDImageCache <em>imageCache;  // 缓存对象<br>@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader </em>imageDownloader; // 下载对象</p>
<p>/**<br> * The cache filter is a block used each time SDWebImageManager need to convert an URL into a cache key. This can<br> * be used to remove dynamic part of an image URL.<br> *<br> * 每次 SDWebImageManager 需要将 URL 转换为缓存 key 时使用的 block。这可用于删除图像 URL 的动态部分。<br> *<br> * The following example sets a filter in the application delegate that will remove any query-string from the<br> * URL before to use it as a cache key:<br> *<br> * @code</p>
<pre><code>SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL * _Nullable url) {
     url = \[\[NSURL alloc\] initWithScheme:url.scheme host:url.host path:url.path\];
     return \[url absoluteString\];
};
</code></pre><p> * @endcode<br> */<br>@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</p>
<p>/**<br> * The cache serializer is a block used to convert the decoded image, the source downloaded data, to the actual data used for storing to the disk cache. If you return nil, means to generate the data from the image instance, see `SDImageCache`.<br> * For example, if you are using WebP images and facing the slow decoding time issue when later retriving from disk cache again. You can try to encode the decoded image to JPEG/PNG format to disk cache instead of source downloaded data.<br> * @note The `image` arg is nonnull, but when you also provide a image transformer and the image is transformed, the `data` arg may be nil, take attention to this case.<br> * @note This method is called from a global queue in order to not to block the main thread.<br> * @code</p>
<p>   SDWebImageManager.sharedManager.cacheSerializer = ^NSData <em> _Nullable( UIImage </em> _Nonnull image,<br>                                                                          NSData <em> _Nullable data,<br>                                                                          NSURL </em> _Nullable imageURL) {<br>    SDImageFormat format = [NSData sd_imageFormatForImageData:data];<br>    switch (format) {<br>        case SDImageFormatWebP:<br>            return image.images ? data : nil;<br>        default:<br>            return data;<br>    }<br> };<br> * @endcode<br> * The default value is nil. Means we just store the source downloaded data to disk cache.<br> */<br>@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</p>
<h5 id="二、-m-文件"><a href="#二、-m-文件" class="headerlink" title="二、.m 文件"></a>二、.m 文件</h5><p>1、SDWebImageCombinedOperation</p>
<p>@interface SDWebImageCombinedOperation : NSObject <sdwebimageoperation></sdwebimageoperation></p>
<p>@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;<br>@property (strong, nonatomic, nullable) SDWebImageDownloadToken <em>downloadToken;<br>@property (strong, nonatomic, nullable) NSOperation </em>cacheOperation;<br>@property (weak, nonatomic, nullable) SDWebImageManager *manager;</p>
<p>@end</p>
<p>SDWebImageCombinedOperation 是对每一个下载任务的封装，重要的是它提供了一个取消功能。</p>
<p>2、属性</p>
<p>@interface SDWebImageManager ()</p>
<p>@property (strong, nonatomic, readwrite, nonnull) SDImageCache <em>imageCache;<br>@property (strong, nonatomic, readwrite, nonnull) SDWebImageDownloader </em>imageDownloader;<br>@property (strong, nonatomic, nonnull) NSMutableSet<nsurl *> <em>failedURLs;<br>@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe<br>@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation </em>&gt; *runningOperations;<br>@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</nsurl></p>
<p>@end</p>
<p>3、初始化</p>
<p>+ (nonnull instancetype)sharedManager {<br>    static dispatch_once_t once;<br>    static id instance;<br>    dispatch_once(&amp;once, ^{<br>        instance = [self new];<br>    });<br>    return instance;<br>}</p>
<p>- (nonnull instancetype)init {<br>    SDImageCache <em>cache = [SDImageCache sharedImageCache];<br>    SDWebImageDownloader </em>downloader = [SDWebImageDownloader sharedDownloader];<br>    return [self initWithCache:cache downloader:downloader];<br>}</p>
<p>- (nonnull instancetype)initWithCache:(nonnull SDImageCache <em>)cache downloader:(nonnull SDWebImageDownloader </em>)downloader {<br>    if ((self = [super init])) {<br>        _imageCache = cache;<br>        _imageDownloader = downloader;<br>        _failedURLs = [NSMutableSet new];<br>        _failedURLsLock = dispatch_semaphore_create(1);<br>        _runningOperations = [NSMutableSet new];<br>        _runningOperationsLock = dispatch_semaphore_create(1);<br>    }<br>    return self;<br>}</p>
<p>4、URL -&gt; key</p>
<p>/**<br> *  缓存 key<br> */<br>- (nullable NSString <em>)cacheKeyForURL:(nullable NSURL </em>)url {<br>    if (!url) {<br>        return @””;<br>    }</p>
<pre><code>if (self.cacheKeyFilter) {
    return self.cacheKeyFilter(url);
} else {
    return url.absoluteString;
}
</code></pre><p>}</p>
<p>5、缩放图片</p>
<p>- (nullable UIImage <em>)scaledImageForKey:(nullable NSString </em>)key image:(nullable UIImage *)image<br>{<br>    // 调用 SDWebImageCompat 方法<br>    return SDScaledImageForKey(key, image);<br>}</p>
<p>6、查看图片是否已经缓存</p>
<p>/**<br> * 先内存后硬盘<br> */<br>- (void)cachedImageExistsForURL:(nullable NSURL <em>)url<br>                     completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock<br>{<br>    NSString </em>key = [self cacheKeyForURL:url];</p>
<pre><code>BOOL isInMemoryCache = (\[self.imageCache imageFromMemoryCacheForKey:key\] != nil);

// 内存中有缓存
if (isInMemoryCache) {
    // making sure we call the completion block on the main queue
    dispatch\_async(dispatch\_get\_main\_queue(), ^{
        if (completionBlock) {
            completionBlock(YES);
        }
    });
    return;
}

// 硬盘中有缓存
\[self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) {
    // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch
    if (completionBlock) {
        completionBlock(isInDiskCache);
    }
}\];
</code></pre><p>}</p>
<p>7、查看是否已经缓存到了硬盘</p>
<p>- (void)diskImageExistsForURL:(nullable NSURL <em>)url<br>                   completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock<br>{<br>    NSString </em>key = [self cacheKeyForURL:url];</p>
<pre><code>// 缓存对象的方法
\[self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) {
    // the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch
    if (completionBlock) {
        completionBlock(isInDiskCache);
    }
}\];
</code></pre><p>}</p>
<pre><code>        SDWebImageDownloadToken \*subOperationToken = \[self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage \*downloadedImage, NSData \*downloadedData, NSError \*error, BOOL finished) {
            \_\_strong \_\_typeof(weakOperation) strongOperation = weakOperation;
            if (!strongOperation || strongOperation.isCancelled) {
                // Do nothing if the operation was cancelled
                // See #699 for more details
                // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data
            } else if (error) {
                \[self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url\];

                if (   error.code != NSURLErrorNotConnectedToInternet
                    &amp;&amp; error.code != NSURLErrorCancelled
                    &amp;&amp; error.code != NSURLErrorTimedOut
                    &amp;&amp; error.code != NSURLErrorInternationalRoamingOff
                    &amp;&amp; error.code != NSURLErrorDataNotAllowed
                    &amp;&amp; error.code != NSURLErrorCannotFindHost
                    &amp;&amp; error.code != NSURLErrorCannotConnectToHost) {
                    @synchronized (self.failedURLs) {
                        \[self.failedURLs addObject:url\];
                    }
                }
            }
            else {

                if ((options &amp; SDWebImageRetryFailed)) {
                    @synchronized (self.failedURLs) {
                        \[self.failedURLs removeObject:url\];
                    }
                }

                BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

                if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) {
                    // Image refresh hit the NSURLCache cache, do not call the completion block
                } else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; \[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)\]) { 
                    dispatch\_async(dispatch\_get\_global\_queue(DISPATCH\_QUEUE\_PRIORITY_HIGH, 0), ^{
                        UIImage *transformedImage = \[self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url\];

                        if (transformedImage &amp;&amp; finished) {
                            BOOL imageWasTransformed = !\[transformedImage isEqual:downloadedImage\];
                            // pass nil if the image was transformed, so we can recalculate the data from the image
                            \[self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil\];
                        }

                        \[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\];
                    });
                } else {
                    if (downloadedImage &amp;&amp; finished) {
                        \[self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil\];
                    }
                    \[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url\];
                }
            }

            if (finished) {
                \[self safelyRemoveOperationFromRunning:strongOperation\];
            }
        }\];

        operation.cancelBlock = ^{
            \[self.imageDownloader cancel:subOperationToken\];
            \_\_strong \_\_typeof(weakOperation) strongOperation = weakOperation;
            \[self safelyRemoveOperationFromRunning:strongOperation\];
        };
    } else if (cachedImage) {
        \_\_strong \_\_typeof(weakOperation) strongOperation = weakOperation;
        \[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url\];
        \[self safelyRemoveOperationFromRunning:operation\];
    } else {
        // Image not in cache and download disallowed by delegate
        /// (8.4).既没有缓存也下载了代理不允许的图片
        \_\_strong \_\_typeof(weakOperation) strongOperation = weakOperation;
        \[self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url\];
        \[self safelyRemoveOperationFromRunning:operation\];
    }
}\];

return operation;
</code></pre><p>}</p>
<p>8、核心下载方法</p>
<p>- (id <sdwebimageoperation>)loadImageWithURL:(nullable NSURL <em>)url<br>                                     options:(SDWebImageOptions)options<br>                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock<br>                                   completed:(nullable SDInternalCompletionBlock)completedBlock<br>{<br>    // Invoking this method without a completedBlock is pointless<br>    /\</em> ①、如果想预先下载图片，使用 [SDWebImagePrefetcher prefetchURLs] 取代本方法 </sdwebimageoperation></p>
<pre><code>   预下载图片是有很多种使用场景的，当我们使用 SDWebImagePrefetcher 下载图片后，之后使用该图片时就不用再用网络下载了
 */
NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -\[SDWebImagePrefetcher prefetchURLs\] instead&quot;);

// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&apos;t
// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.
/\* ②、XCode 有时候经常会犯一些错误，当用户给 url 赋值了字符串的时候，XCode 也没有报错，因此这里提供一种错误修正的处理  */
if (\[url isKindOfClass:NSString.class\]) {
    url = \[NSURL URLWithString:(NSString *)url\];
}

// Prevents app crashing on argument type error like sending NSNull instead of NSURL
/\* ③、防止参数的其他错误  */
if (!\[url isKindOfClass:NSURL.class\]) {
    url = nil;
}

/\* ④、operation 的类型是 SDWebImageCombinedOperation，是一个封装的对象，并不是一个 NSOperation  */
SDWebImageCombinedOperation *operation = \[SDWebImageCombinedOperation new\];
operation.manager = self;

/\* ⑤、在图片的下载中，会有一些下载失败的情况，这时候我们把这些下载失败的 url 放到一个集合中去，也就是加入了黑名单中

   默认是不会再继续下载黑名单中的 url 了，但是也有例外，当 options被设置为 SDWebImageRetryFailed 的时候，会尝试进行重新下载。
 */
BOOL isFailedUrl = NO;
if (url) {
    LOCK(self.failedURLsLock);
    isFailedUrl = \[self.failedURLs containsObject:url\];
    UNLOCK(self.failedURLsLock);
}

/\* ⑥、会有两种情况让我们停止下载这个 rul 指定的图片：

             \- url 的长度为 0
             \- options 并没有选择 SDWebImageRetryFailed 且这个 url 在黑名单之中

   调用完成 Block，直接返回 operation
 */
if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {
    \[self callCompletionBlockForOperation:operation completion:completedBlock error:\[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil\] url:url\];
    return operation;
}

/\* ⑦、排除了所有的错误可能后，我们就先把这个 operation 添加到正在运行操作的数组中

      这里没有判断 self.runningOperations 是否包含了 operation，说明肯定会在下边的代码中做判断，如果存在就删除 operation
 */
LOCK(self.runningOperationsLock);
\[self.runningOperations addObject:operation\];
UNLOCK(self.runningOperationsLock);
NSString *key = \[self cacheKeyForURL:url\];

SDImageCacheOptions cacheOptions = 0;

/\* 将 Manager 枚举值转成 Cache 枚举值，实际上就是 0 |= xxx  */
if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;
if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;
if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;

__weak SDWebImageCombinedOperation *weakOperation = operation;

/\* ⑧、self.imageCache 的 queryCacheOperationForKey 方法是异步的获取指定 key 的图片  但是这个方法的 operation 是同步返回的，也就是说下边的代码会直接执行到 return 那里。       这个 Block 会在查询完指定的 key 的图片后回调，由

        dispatch_async(self.ioQueue, ^{` 
            // 这个可以看出，是在异步线程采用串行的方式在调用，任务在 self.imageCache 的 ioQueue 中一个一个执行，是线程安全的
        }; 
 */
operation.cacheOperation = \[self.imageCache queryCacheOperationForKey:key 
                                                              options:cacheOptions 
                                 done:^(UIImage \*cachedImage, NSData \*cachedData, SDImageCacheType cacheType) {
    \_\_strong \_\_typeof(weakOperation) strongOperation = weakOperation;

    /\* (⑧.1)、如果每次调用 loadImage 方法都会生成一个 operation，如果我们想取消某个下载任务，在设计上来说，只要把响应的operation.isCancelled 设置为 NO，那么下载就会被取消。
     */
    if (!strongOperation || strongOperation.isCancelled) {
        \[self safelyRemoveOperationFromRunning:strongOperation\];
        return;
    }

    // Check whether we should download image from network
    /\* (⑧.2)、代码来到这里，我们就要根据是否有缓存的图片来做出响应的处理。

        可以从网络下载 &amp;&amp; （如果没有获取到缓存图片 || 需要刷新缓存图片） &amp;&amp;  根据 delegate 的 imageManager:shouldDownloadImageForURL: 获取是否下载的权限 -&gt; 返回 YES，就继续下载。
    */
    BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))
        &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)
        &amp;&amp; (!\[self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)\] || \[self.delegate imageManager:self shouldDownloadImageForURL:url\]);

    // 需要重新下载
    if (shouldDownload) {

        /\* (⑧.2.1)、这里需要注意了，当图片已经下载 &amp;&amp; Options == SDWebImageRefreshCached

              就会触发一次 completionBlock 回调，这说明这个下载的回调不是只触发一次的。

              如果使用了 dispatch\_group\_enter 和 dispatch\_group\_leave 就一定要注意了。
         */
        if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) {
            // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.
            \[self callCompletionBlockForOperation:strongOperation
                                       completion:completedBlock
                                            image:cachedImage
                                             data:cachedData
                                            error:nil
                                        cacheType:cacheType
                                         finished:YES
                                              url:url\];
        }

        // download if no image or requested to refresh anyway, and download allowed by delegate

        /\* (⑧.2.2)、这里是 SDWebImageOptions 到 SDWebImageDownloaderOptions 的转换

                   其实就是 0 |= xxx 
         */
        SDWebImageDownloaderOptions downloaderOptions = 0;
        if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;
        if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;
        if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;
        if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;
        if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;
        if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;
        if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;
        if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;

        /*
           (⑧.2.3)、已经缓存且 SDWebImageRefreshCached 的比较特殊
         */
        if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) {
            // force progressive off if image already cached but forced refreshing

            /\* SDWebImageDownloaderProgressiveDownload = 1&lt;&lt;1，由于当 options == SDWebImageRefreshCached 时，

               downloaderOptions |= SDWebImageDownloaderUseNSURLCache (1 &lt;&lt; 2) 00000000 | 00000100 =&gt; 00000100 
               ~SDWebImageDownloaderProgressiveDownload : ~ 00000010 =&gt; 111111101 
               00000100 &amp; 11111101 =&gt; 00000100 
            */
            downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;
            // ignore image read from NSURLCache if image if cached but force refreshing
            /\*  
                00000100 | 00001000 =&gt; 00001100 通过这种位的运算，就能够给同一个值赋值两种转态
            */
            downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;
        }

        // \`SDWebImageCombinedOperation\` -&gt; \`SDWebImageDownloadToken\` -&gt; \`downloadOperationCancelToken\`, which is a \`SDCallbacksDictionary\` and retain the completed block below, so we need weak-strong again to avoid retain cycle
        __weak typeof(strongOperation) weakSubOperation = strongOperation;

        /*
          (⑧.2.4)、下载图片
         */
        strongOperation.downloadToken = \[self.imageDownloader downloadImageWithURL:url 
                                                                           options:downloaderOptions
                                                                          progress:progressBlock 
                 completed:^(UIImage \*downloadedImage, NSData \*downloadedData, NSError *error, BOOL finished) {
            __strong typeof(weakSubOperation) strongSubOperation = weakSubOperation;
            if (!strongSubOperation || strongSubOperation.isCancelled) {
                // Do nothing if the operation was cancelled
                // See #699 for more details
                // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data
            }
            else if (error) {
                /\* 
                   (⑧.2.4.1)、发生错误就返回
                 */ 
                \[self callCompletionBlockForOperation:strongSubOperation 
                                           completion:completedBlock 
                                                error:error 
                                                  url:url\];
                BOOL shouldBlockFailedURL;
                // Check whether we should block failed url
               if (\[self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)\]) {
                    shouldBlockFailedURL = \[self.delegate imageManager:self 
                                                  shouldBlockFailedURL:url 
                                                             withError:error\];
                } 
                else {
                    /*
                      (⑧.2.4.2)、除了下边这几种情况之外的情况则把 url 加入黑名单
                     */ 
                    shouldBlockFailedURL = (   error.code != NSURLErrorNotConnectedToInternet
                                            &amp;&amp; error.code != NSURLErrorCancelled
                                            &amp;&amp; error.code != NSURLErrorTimedOut
                                            &amp;&amp; error.code != NSURLErrorInternationalRoamingOff
                                            &amp;&amp; error.code != NSURLErrorDataNotAllowed
                                            &amp;&amp; error.code != NSURLErrorCannotFindHost
                                            &amp;&amp; error.code != NSURLErrorCannotConnectToHost
                                            &amp;&amp; error.code != NSURLErrorNetworkConnectionLost);
                }

                // 添加到黑名单
                if (shouldBlockFailedURL) {
                    LOCK(self.failedURLsLock);
                    \[self.failedURLs addObject:url\];
                    UNLOCK(self.failedURLsLock);
                }
            }
            else {
                /\* 
                   (⑧.2.4.3)、如果是 SDWebImageRetryFailed 就在黑名单中移除，不管有没有
                 */ 
                if ((options &amp; SDWebImageRetryFailed)) {
                    LOCK(self.failedURLsLock);
                    \[self.failedURLs removeObject:url\];
                    UNLOCK(self.failedURLsLock);
                }

                BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);

                // We&apos;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.
                if (self != \[SDWebImageManager sharedManager\] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) {
                    downloadedImage = \[self scaledImageForKey:key image:downloadedImage\];
                }

                if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) {
                    // Image refresh hit the NSURLCache cache, do not call the completion block
                }
                /*
                   要不要修改图片，这个修改图片完全由代理来操作
                 */
                else if (downloadedImage &amp;&amp; (!downloadedImage.images 
                         || (options &amp; SDWebImageTransformAnimatedImage)) 
              &amp;&amp; \[self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)\]) {
                    dispatch\_async(dispatch\_get\_global\_queue(DISPATCH\_QUEUE\_PRIORITY_HIGH, 0), ^{
                        @autoreleasepool {
                            UIImage *transformedImage = \[self.delegate imageManager:self 
                                                           transformDownloadedImage:downloadedImage 
                                                                            withURL:url\];

                            if (transformedImage &amp;&amp; finished) {
                                BOOL imageWasTransformed = !\[transformedImage isEqual:downloadedImage\];
                                NSData *cacheData;
                                // pass nil if the image was transformed, so we can recalculate the data from the image
                                if (self.cacheSerializer) {
                                    cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);
                                } 
                                else {
                                    cacheData = (imageWasTransformed ? nil : downloadedData);
                                }
                                \[self.imageCache storeImage:transformedImage 
                                                  imageData:cacheData
                                                     forKey:key
                                                     toDisk:cacheOnDisk
                                                 completion:nil\];
                            }

                            \[self callCompletionBlockForOperation:strongSubOperation 
                                                       completion:completedBlock 
                                                            image:transformedImage 
                                                             data:downloadedData 
                                                            error:nil
                                                        cacheType:SDImageCacheTypeNone 
                                                         finished:finished
                                                              url:url\];
                        }
                    });
                } 
                else {
                    if (downloadedImage &amp;&amp; finished) {
                        if (self.cacheSerializer) {
                            dispatch\_async(dispatch\_get\_global\_queue(DISPATCH\_QUEUE\_PRIORITY_HIGH, 0), ^{
                                @autoreleasepool {
                                    NSData *cacheData = self.cacheSerializer(downloadedImage, downloadedData, url);
                                    \[self.imageCache storeImage:downloadedImage 
                                                      imageData:cacheData
                                                         forKey:key
                                                         toDisk:cacheOnDisk
                                                     completion:nil\];
                                }
                            });
                        }
                        else {
                            \[self.imageCache storeImage:downloadedImage 
                                              imageData:downloadedData
                                                 forKey:key
                                                 toDisk:cacheOnDisk
                                             completion:nil\];
                        }
                    }
                    \[self callCompletionBlockForOperation:strongSubOperation 
                                               completion:completedBlock
                                                    image:downloadedImage
                                                     data:downloadedData
                                                    error:nil
                                                cacheType:SDImageCacheTypeNone
                                                 finished:finished
                                                      url:url\];
                }
            }

            /\* (⑧.2.4.4)、完成了就把该任务从正运行着的数组中删除  */
            if (finished) {
                \[self safelyRemoveOperationFromRunning:strongSubOperation\];
            }
        }\];
    }
    else if (cachedImage) {
        \[self callCompletionBlockForOperation:strongOperation 
                                   completion:completedBlock
                                        image:cachedImage  
                                         data:cachedData
                                        error:nil
                                    cacheType:cacheType
                                     finished:YES
                                          url:url\];
        \[self safelyRemoveOperationFromRunning:strongOperation\];
    }
    else {
        // Image not in cache and download disallowed by delegate
        \[self callCompletionBlockForOperation:strongOperation
                                   completion:completedBlock
                                        image:nil
                                         data:nil
                                        error:nil
                                    cacheType:SDImageCacheTypeNone
                                     finished:YES
                                          url:url\];
        \[self safelyRemoveOperationFromRunning:strongOperation\];
    }
}\];

return operation;
</code></pre><p>}</p>
<p>对于一个比较复杂的函数，往往只需要做下边三件事就可以了：</p>
<ul>
<li><p>处理参数相关的异常</p>
</li>
<li><p>处理复杂的逻辑</p>
</li>
<li><p>返回数据。</p>
</li>
</ul>
<p>这三条适合所有的函数。</p>
<p>9、保存图片到缓存区</p>
<p>- (void)saveImageToCache:(nullable UIImage <em>)image forURL:(nullable NSURL </em>)url<br>{<br>    if (image &amp;&amp; url) {<br>        NSString *key = [self cacheKeyForURL:url];<br>        [self.imageCache storeImage:image forKey:key toDisk:YES completion:nil];<br>    }<br>}</p>
<p>10、取消所有的下载</p>
<p>- (void)cancelAll<br>{<br>    LOCK(self.runningOperationsLock);<br>    NSSet<sdwebimagecombinedoperation *> *copiedOperations = [self.runningOperations copy];<br>    UNLOCK(self.runningOperationsLock);</sdwebimagecombinedoperation></p>
<pre><code>// This will call \`safelyRemoveOperationFromRunning:\` and remove from the array
\[copiedOperations makeObjectsPerformSelector:@selector(cancel)\];
</code></pre><p>}</p>
<p>11、查看是否下载完毕</p>
<p>- (BOOL)isRunning<br>{<br>    BOOL isRunning = NO;<br>    LOCK(self.runningOperationsLock);<br>    isRunning = (self.runningOperations.count &gt; 0);<br>    UNLOCK(self.runningOperationsLock);<br>    return isRunning;<br>}</p>
<p>12、安全移除任务</p>
<p>- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation<br>{<br>    if (!operation) {<br>        return;<br>    }<br>    LOCK(self.runningOperationsLock);<br>    [self.runningOperations removeObject:operation];<br>    UNLOCK(self.runningOperationsLock);<br>}</p>
<p>13、回调</p>
<p>- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation<em>)operation<br>                             completion:(nullable SDInternalCompletionBlock)completionBlock<br>                                  error:(nullable NSError </em>)error<br>                                    url:(nullable NSURL *)url<br>{<br>    [self callCompletionBlockForOperation:operation<br>                               completion:completionBlock<br>                                    image:nil<br>                                     data:nil<br>                                    error:error<br>                                cacheType:SDImageCacheTypeNone<br>                                 finished:YES<br>                                      url:url];<br>}</p>
<p>- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation<em>)operation<br>                             completion:(nullable SDInternalCompletionBlock)completionBlock<br>                                  image:(nullable UIImage </em>)image<br>                                   data:(nullable NSData <em>)data<br>                                  error:(nullable NSError </em>)error<br>                              cacheType:(SDImageCacheType)cacheType<br>                               finished:(BOOL)finished<br>                                    url:(nullable NSURL *)url {<br>    dispatch_main_async_safe(^{<br>        if (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) {<br>            completionBlock(image, data, error, cacheType, finished, url);<br>        }<br>    });<br>}</p>
<p>14、SDWebImageCombinedOperation 实现方法</p>
<p>- (void)cancel<br>{<br>    @synchronized(self) {<br>        self.cancelled = YES;<br>        if (self.cacheOperation) {<br>            [self.cacheOperation cancel];<br>            self.cacheOperation = nil;<br>        }<br>        if (self.downloadToken) {<br>            [self.manager.imageDownloader cancel:self.downloadToken];<br>        }<br>        [self.manager safelyRemoveOperationFromRunning:self];<br>    }<br>}</p>
<h5 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h5><p>SD 在特定使用场景会崩溃的情况。（新版 v4.4.2 没有该问题）</p>
<p>- (void)test<br>{<br>    NSURL *url = [NSURL URLWithString:@”//upload-images.jianshu.io/upload_images/1432482-dcc38746f56a89ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240”];</p>
<pre><code>SDWebImageManager *manager = \[SDWebImageManager sharedManager\];

dispatch\_group\_t group = dispatch\_group\_create();

dispatch\_group\_enter(group);
\[manager loadImageWithURL:url 
                  options:SDWebImageRefreshCached
                 progress:nil
                completed:^(UIImage * \_Nullable image, NSData * \_Nullable data, NSError * \_Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * \_Nullable imageURL) {
    dispatch\_group\_leave(group);
}\];

dispatch\_group\_notify(group, dispatch\_get\_main_queue(), ^{
    NSLog(@&quot;下载完成了&quot;);
});
</code></pre><p>}</p>
<p>使用 dispatch_group_t、dispatch_group_enter、dispatch_group_leave 的目的是等待所有的异步任务完成。</p>
<p>enter 和 leave 方法必须成对出现，如果调用 leave 的次数多于 enter 就会崩溃。当我们使用 SD 时，如果 Options 设置为SDWebImageRefreshCached，那么这个 completionBlock 至少会调用两次，首先返回缓存中的图片，其次在下载完成后再次调用 Block，这也就是崩溃的原因。</p>
<p>要想重现上边方法的崩溃，等图片下载完之后，再重新新调用该方法就行。</p>
<p>SD 默认下载的图片会缓存进内存和 disk 中。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/15/sdwebimagemanager/">http://yoursite.com/2019/03/15/sdwebimagemanager/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/15/sdwebimageprefetcher/" class="pre"> SDWebImagePrefetcher		</a><a href="/2019/03/15/sdwebimagedownloader/" class="next"> SDWebImageDownloader		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、-h-文件"><span class="toc-text">一、.h 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、-m-文件"><span class="toc-text">二、.m 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、问题"><span class="toc-text">三、问题</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>