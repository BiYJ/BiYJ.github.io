<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> SDWebImageDownloader		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> SDWebImageDownloader		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> SDWebImageDownloader		</h1><div class="post-meta"><a href="/2019/03/15/sdwebimagedownloader/#comments" class="comment-count"></a><p><span class="date">Mar 15, 2019</span><span><a href="/categories/SDWebImage/" class="category">SDWebImage</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://www.cnblogs.com/machao/p/6265621.html" target="_blank" rel="noopener">SDWebImage源码解读之SDWebImageDownloader</a></p>
<p>SDWebImageDownloader 这个类非常简单，作者的设计思路也很清晰。  </p>
<h5 id="一、编程"><a href="#一、编程" class="headerlink" title="一、编程"></a>一、编程</h5><p>怎么看待编程这件事？其实不管是函数还是属性，它们都是数据，编写的所有程序都是在处理数据。函数本身也是一种特殊的数据。</p>
<p>真正难的是生产数据的这一过程。</p>
<p>举个例子，给你一堆菜籽，要求生产出油来。怎么办？首先为这个任务设计一个函数：</p>
<p>- (油)用菜籽生产油(菜籽);</p>
<p>这就是最外层的函数，也应该是最开始想到的函数。然后经过不断的研究发现，这个生产过程很复杂，必须分工合作才能实现。于是把这个任务分割为好几个小任务：</p>
<p>①、- (干净的菜籽)取出杂质(菜籽);</p>
<p>②、- (炒熟的菜籽)把菜籽炒一下(干净的菜籽);</p>
<p>③、- (蒸了的菜籽)把菜籽蒸一下(炒熟的菜籽);</p>
<p>④、- (捆好的菜籽)把菜籽包捆成一块(蒸了的菜籽);</p>
<p>⑤、- (油)撞击菜籽包(捆好的菜籽);</p>
<p>有没有发现，整个榨油的过程就是对数据的处理。这一点其实很重要。如果没有把 -(油)用菜籽生产油(菜籽); 任务进行拆分，我们就会写出复杂无比的函数。那么就有人要问了，只要实现这个功能就行了呗。其实这往往是写不出好代码的原因。</p>
<p>整个任务的设计应该是事先就设计好的。任务被分割成更小更简单的部分，然后再去实现这些最小的任务，不应该是边写边分割任务，往往临时分割的任务没有最正确的界限。</p>
<p>有了上边合理的分工之后，就可以进行任务安排了。回到现实开发中来。上边 5 个子任务的难度是不同的。有的人可能基础比较差，那么让他去干筛菜籽这种体力活，应该没问题。那些炒或者蒸的子任务是要掌握火候的，也就是说有点技术含量。那么就交给能胜任这项工作的人去做。所有的这一切，我们只要事先定义好各自的生产结果就行了，完全不影响每个程序的执行。</p>
<p>有的人用原始的撞击菜籽包榨油，有的人却用最先进的仪器榨油，这就是编程技术和知识深度的区别啊。</p>
<h5 id="二、-h-文件"><a href="#二、-h-文件" class="headerlink" title="二、.h 文件"></a>二、.h 文件</h5><p>typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) {<br>    /**<br>     * Put the download in the low queue priority and task priority.  低优先级<br>     */<br>    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</p>
<pre><code>/\*\*
 \* This flag enables progressive download, the image is displayed progressively during download as a browser would do.  带有进度
 */
SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,

/\*\*
 \* By default, request prevent the use of NSURLCache. With this flag, NSURLCache is used with default policies.
 \* 使用 NSCache
 */
SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,

/\*\*
 \* Call completion block with nil image/imageData if the image was read from NSURLCache
 \* (to be combined with \`SDWebImageDownloaderUseNSURLCache\`).  不缓存响应
 */
SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,

/\*\*
 \* In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for extra time in background to let the request finish. If the background task expires the operation will be cancelled. 支持后台下载
 */
SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,

/\*\*
 \* Handles cookies stored in NSHTTPCookieStore by setting NSMutableURLRequest.HTTPShouldHandleCookies = YES;
 \* 使用 Cookies
 */
SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,

/\*\*
 \* Enable to allow untrusted SSL certificates.
 \* Useful for testing purposes. Use with caution in production.  允许验证 SSL
 */
SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,

/\*\*
 \* Put the download in the high queue priority and task priority.  高权限
 */
SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,

/\*\*
 \* Scale down the image  裁剪大图片
 */
SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,
</code></pre><p>};</p>
<p>当需要给某个功能添加 Options 的时候，一般使用枚举来实现。</p>
<p>这些选项提供了几种不同的选项，可以根据自己的需求选个合适的选项。这里作者使用了掩码。比如 1 &lt;&lt; 1 表示把 1 左移一位，将 1 写成二进制格式为：00000001，那么左移一位后就是：00000010，转成十进制后就是 2，也就是说左移一位表示在原来的值上乘以 2。</p>
<p>当判断 self.option 是否是 SDWebImageDownloaderIgnoreCachedResponse 选项时，应该这么判断：</p>
<p>if (self.option &amp; SDWebImageDownloaderIgnoreCachedResponse) { }</p>
<p>&amp; 运算是当左右两边的相同即为 YES，其他为 NO。</p>
<p>typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) {<br>    /**<br>     * Default value. All download operations will execute in queue style (first-in-first-out).  先进先出<br>     */<br>    SDWebImageDownloaderFIFOExecutionOrder,</p>
<pre><code>/\*\*
 \* All download operations will execute in stack style (last-in-first-out).   后进先出
 */
SDWebImageDownloaderLIFOExecutionOrder
</code></pre><p>};</p>
<p>定义了数据被调用的顺序。按照一般的想法。下载应该按照数据放入队列的顺序依次进行，但也支持后进先出这种方式。</p>
<p>一个下载管理器肯定有一个下载列表，我们可以假定这个列表保存在一个数组中，正常情况下应该每次取出数组中第 1 个元素来下载，这就是 FIFO（先进先出）。那么要改为 LIFO（后进先出），应该是针对某一个下载的，不应该是把取出数据的顺序改为从数组的最后一个元素取出。</p>
<p>有一个疑问，如果只是想暂停某一个下载，该怎么办呢？如果直接取消，那么点击继续的时候，要重新开启下载，肯定影响体验。这一点跟使用数组管理任务有点不同。</p>
<p>FOUNDATION_EXPORT NSString <em> _Nonnull const SDWebImageDownloadStartNotification;<br>FOUNDATION_EXPORT NSString </em> _Nonnull const SDWebImageDownloadStopNotification;</p>
<p>通过 extern 就能够使用其他文件的代码。</p>
<p>/**<br> * 进度 block<br> <em>/<br>typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize, NSURL </em> _Nullable targetURL);</p>
<p>/**<br> * 完成 block<br> <em>/<br>typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage </em> _Nullable image, NSData <em> _Nullable data, NSError </em> _Nullable error, BOOL finished);</p>
<p>命名 Block。</p>
<p>typedef NSDictionary<nsstring *, nsstring *> SDHTTPHeadersDictionary;<br>typedef NSMutableDictionary<nsstring *, nsstring *> SDHTTPHeadersMutableDictionary;</nsstring></nsstring></p>
<p>命名字典。</p>
<p>typedef SDHTTPHeadersDictionary <em> _Nullable (^SDWebImageDownloaderHeadersFilterBlock)(NSURL </em> _Nullable url, SDHTTPHeadersDictionary * _Nullable headers);</p>
<p>这个 block 允许我们自定义请求头，通过 Block 传值。有一定的优点，可以拿到一些参数，然后在加工成我们需要的数据，最后返回。</p>
<p>/**<br> *  A token associated with each download. Can be used to cancel a download<br> */<br>@interface SDWebImageDownloadToken : NSObject <sdwebimageoperation></sdwebimageoperation></p>
<p>SDWebImageDownloadToken 作为每一个下载的唯一身份标识，SDWebImageDownloader 和我们平时开发中的下载还是有不一样的，它弱化了下载过程，比较强调的是下载结果。不支持断点下载。</p>
<p>如果我们需要设计一个自己的下载管理者，就应该设计一个类似 SDWebImageDownloadToken 这样的下载对象封装类，能在这个对象中获取需要的所有信息，大家如果有兴趣，可以看看 <a href="https://github.com/agelessman/MCDownloadManager" target="_blank" rel="noopener">MCDownloadManager</a>.</p>
<p>/**<br> * The download’s URL. This should be readonly and you should not modify<br> <em>/<br>@property (nonatomic, strong, nullable) NSURL </em>url;<br>/**<br> * The cancel token taken from `addHandlersForProgress:completed`. This should be readonly and you should not modify<br> * @note use <code>-\[SDWebImageDownloadToken cancel\]</code> to cancel the token<br> */<br>@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</p>
<p>可以通过 token 进行取消下载。</p>
<p>/**<br> * Asynchronous downloader dedicated and optimized for image loading.<br> */<br>@interface SDWebImageDownloader : NSObject</p>
<p>专门为图像加载而优化的异步下载器。</p>
<p>/**<br> * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory.<br> * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption.<br> * 是否需要解压图片，默认为 YES。<br> */<br>@property (assign, nonatomic) BOOL shouldDecompressImages;</p>
<p>/**<br> * The maximum number of concurrent downloads.<br> *<br> * 最大并发下载数<br> */<br>@property (assign, nonatomic) NSInteger maxConcurrentDownloads;</p>
<p>/**<br> * Shows the current amount of downloads that still need to be downloaded.<br> *<br> * 当前下载数量<br> */<br>@property (readonly, nonatomic) NSUInteger currentDownloadCount;</p>
<p>/**<br> *  The timeout value (in seconds) for the download operation. Default: 15.0.<br> *<br> *  下载超时时间，默认是 15.0s<br> */<br>@property (assign, nonatomic) NSTimeInterval downloadTimeout;</p>
<p>/**<br> * The configuration in use by the internal NSURLSession.<br> * Mutating this object directly has no effect. （只读）直接改变这个对象没有效果<br> *<br> * @see createNewSessionWithConfiguration:<br> <em>/<br>@property (readonly, nonatomic, nonnull) NSURLSessionConfiguration </em>sessionConfiguration;</p>
<p>/**<br> * Changes download operations execution order. Default value is `SDWebImageDownloaderFIFOExecutionOrder`.<br> *<br> * 数据调用顺序。默认为 FIFO<br> */<br>@property (assign, nonatomic) SDWebImageDownloaderExecutionOrder executionOrder;</p>
<p>/**<br> *  Singleton method, returns the shared instance<br> *<br> *  @return global shared instance of downloader class<br> */<br>+ (nonnull instancetype)sharedDownloader;</p>
<p>/**<br> *  Set the default URL credential to be set for request operations. 请求验证<br> <em>/<br>@property (strong, nonatomic, nullable) NSURLCredential </em>urlCredential;</p>
<p>/**<br> * Set username  用户名<br> <em>/<br>@property (strong, nonatomic, nullable) NSString </em>username;</p>
<p>/**<br> * Set password  密码<br> <em>/<br>@property (strong, nonatomic, nullable) NSString </em>password;</p>
<p>/**<br> * Set filter to pick headers for downloading image HTTP request.<br> *<br> * This block will be invoked for each downloading image request, returned NSDictionary will be used as headers in corresponding HTTP request.<br> *<br> * 设置请求头部回调<br> */<br>@property (nonatomic, copy, nullable) SDWebImageDownloaderHeadersFilterBlock headersFilter;</p>
<p>初始化方法：</p>
<p>/**<br> * Creates an instance of a downloader with specified session configuration.<br> * @note `timeoutIntervalForRequest` is going to be overwritten.<br> * @return new instance of downloader class<br> */<br>- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration NS_DESIGNATED_INITIALIZER;</p>
<p>一个 NSURLSession 会话，使用 NSURLSessionConfiguration 进行配置，利用这一点，我们在设计自己的网络框架的时候，可以参考 NSURLSessionConfiguration。暴露少量的属性来配置网络请求，后期维护起来也比较容易。</p>
<p>使用 NS_DESIGNATED_INITIALIZER 强调该方法是建议的初始化方法。</p>
<p>其他的方法：</p>
<p>/**<br> * Set a value for a HTTP header to be appended to each download HTTP request.<br> *<br> * @param value The value for the header field. Use `nil` value to remove the header.<br> * @param field The name of the header field to set.<br> *<br> * 设置请求头字段。如果 value = nil，移除该头字段<br> */<br>- (void)setValue:(nullable NSString <em>)value forHTTPHeaderField:(nullable NSString </em>)field;</p>
<p>/**<br> * Returns the value of the specified HTTP header field.<br> *<br> * @return The value associated with the header field field, or `nil` if there is no corresponding header field.<br> * 返回头字段 value，可能返回 nil<br> */<br>- (nullable NSString <em>)valueForHTTPHeaderField:(nullable NSString </em>)field;</p>
<p>/**<br> * Sets a subclass of `NSOperation` and conforms to `SDWebImageDownloaderOperationInterface`.<br> * Default is `SDWebImageDownloaderOperation`.<br> * Can be used each time SDWebImage constructs a request<br> * operation to download an image.<br> *<br> * @param operationClass The subclass of `NSOperation` and conforms to `SDWebImageDownloaderOperationInterface`.<br> * Default is `SDWebImageDownloaderOperation`, Passing `nil` will revert to `SDWebImageDownloaderOperation`.<br> *<br> * 遵守 SDWebImageDownloaderOperationInterface 协议的 NSOperation 子类，默认为 SDWebImageDownloaderOperation<br> */<br>- (void)setOperationClass:(nullable Class)operationClass;</p>
<p>/**<br> * Creates a SDWebImageDownloader async downloader instance with a given URL<br> *<br> * The delegate will be informed when the image is finish downloaded or an error has happen.<br> *<br> * @see SDWebImageDownloaderDelegate<br> *<br> * @param url            The URL to the image to download<br> * @param options        The options to be used for this download<br> * @param progressBlock  A block called repeatedly while the image is downloading<br> *                       @note the progress block is executed on a background queue<br> * @param completedBlock A block called once the download is completed.<br> *                       If the download succeeded, the image parameter is set, in case of error,<br> *                       error parameter is set with the error. The last parameter is always YES<br> *                       if SDWebImageDownloaderProgressiveDownload isn’t use. With the<br> *                       SDWebImageDownloaderProgressiveDownload option, this block is called<br> *                       repeatedly with the partial image object and the finished argument set to NO<br> *                       before to be called a last time with the full image and finished argument<br> *                       set to YES. In case of error, the finished argument is always YES.<br> *<br> * @return A token (SDWebImageDownloadToken) that can be passed to -cancel: to cancel this operation<br> *<br> * 下载图片<br> */<br>- (nullable SDWebImageDownloadToken <em>)downloadImageWithURL:(nullable NSURL </em>)url<br>                                                   options:(SDWebImageDownloaderOptions)options<br>                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock<br>                                             completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</p>
<p>/**<br> * Cancels a download that was previously queued using -downloadImageWithURL:options:progress:completed:<br> *<br> * @param token The token received from -downloadImageWithURL:options:progress:completed: that should be canceled.<br> *<br> * 取消图片下载<br> */<br>- (void)cancel:(nullable SDWebImageDownloadToken *)token;</p>
<p>/**<br> * Sets the download queue suspension state. 暂停<br> */<br>- (void)setSuspended:(BOOL)suspended;</p>
<p>/**<br> * Cancels all download operations in the queue.<br> *<br> * 取消所有的下载任务<br> */<br>- (void)cancelAllDownloads;</p>
<p>/**<br> * Forces SDWebImageDownloader to create and use a new NSURLSession that is<br> * initialized with the given configuration.<br> * @note All existing download operations in the queue will be cancelled.<br> * @note `timeoutIntervalForRequest` is going to be overwritten.<br> *<br> * @param sessionConfiguration The configuration to use for the new NSURLSession<br> */<br>- (void)createNewSessionWithConfiguration:(nonnull NSURLSessionConfiguration *)sessionConfiguration;</p>
<p>/**<br> * Invalidates the managed session, optionally canceling pending operations.<br> * @note If you use custom downloader instead of the shared downloader, you need call this method when you do not use it to avoid memory leak<br> * @param cancelPendingOperations Whether or not to cancel pending operations.<br> * @note Calling this method on the shared downloader has no effect.<br> */<br>- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations;</p>
<h5 id="三、-m-文件"><a href="#三、-m-文件" class="headerlink" title="三、.m 文件"></a>三、.m 文件</h5><p>@interface SDWebImageDownloadToken ()</p>
<p>@property (nonatomic, weak, nullable) NSOperation<sdwebimagedownloaderoperationinterface> *downloadOperation;</sdwebimagedownloaderoperationinterface></p>
<p>@end</p>
<p>@implementation SDWebImageDownloadToken</p>
<p>- (void)cancel {<br>    if (self.downloadOperation) {<br>        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;<br>        if (cancelToken) {<br>            [self.downloadOperation cancel:cancelToken];<br>        }<br>    }<br>}</p>
<p>@end</p>
<p>SDWebImageDownloadToken 增加一个遵守 SDWebImageDownloaderOperationInterface 协议的下载任务对象，用于取消任务。</p>
<p>@interface SDWebImageDownloader () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</p>
<p>// 下载队列<br>@property (strong, nonatomic, nonnull) NSOperationQueue <em>downloadQueue;<br>// 用于记录最后添加的操作<br>@property (weak, nonatomic, nullable) NSOperation </em>lastAddedOperation;<br>// 支持我们自定义的操作类<br>@property (assign, nonatomic, nullable) Class operationClass;<br>// 存放着所有的 operation<br>@property (strong, nonatomic, nonnull) NSMutableDictionary&lt;NSURL <em>, NSOperation<sdwebimagedownloaderoperationinterface> </sdwebimagedownloaderoperationinterface></em>&gt; *URLOperations;</p>
<p>// HTTP 请求头<br>@property (strong, nonatomic, nullable) SDHTTPHeadersMutableDictionary *HTTPHeaders;</p>
<p>// 用户线程安全的信号量<br>// a lock to keep the access to `URLOperations` thread-safe<br>@property (strong, nonatomic, nonnull) dispatch_semaphore_t operationsLock;<br>// a lock to keep the access to `HTTPHeaders` thread-safe<br>@property (strong, nonatomic, nonnull) dispatch_semaphore_t headersLock;</p>
<p>// The session in which data tasks will run<br>@property (strong, nonatomic) NSURLSession *session;</p>
<p>@end</p>
<p>这些属性可以说都是为了完成管理下载任务而存在的。</p>
<p>1、initialize</p>
<p>initialize 和 load 这两个方法比较特殊，通过下边这个表格来看看它们的区别</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-82c8313b67fec0cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>+ (void)initialize {<br>    // Bind SDNetworkActivityIndicator if available (download it here: <a href="http://github.com/rs/SDNetworkActivityIndicator" target="_blank" rel="noopener">http://github.com/rs/SDNetworkActivityIndicator</a> )<br>    // To use it, just add #import “SDNetworkActivityIndicator.h” in addition to the SDWebImage import<br>    if (NSClassFromString(@”SDNetworkActivityIndicator”)) {</p>
<p>#pragma clang diagnostic push</p>
<p>#pragma clang diagnostic ignored “-Warc-performSelector-leaks”<br>        id activityIndicator = [NSClassFromString(@”SDNetworkActivityIndicator”) performSelector:NSSelectorFromString(@”sharedActivityIndicator”)];</p>
<p>#pragma clang diagnostic pop</p>
<pre><code>    // Remove observer in case it was previously added.
    \[\[NSNotificationCenter defaultCenter\] removeObserver:activityIndicator 
                                                    name:SDWebImageDownloadStartNotification 
                                                  object:nil\];
    \[\[NSNotificationCenter defaultCenter\] removeObserver:activityIndicator 
                                                    name:SDWebImageDownloadStopNotification
                                                  object:nil\];

    \[\[NSNotificationCenter defaultCenter\] addObserver:activityIndicator
                                             selector:NSSelectorFromString(@&quot;startActivity&quot;)
                                                 name:SDWebImageDownloadStartNotification object:nil\];
    \[\[NSNotificationCenter defaultCenter\] addObserver:activityIndicator
                                             selector:NSSelectorFromString(@&quot;stopActivity&quot;)
                                                 name:SDWebImageDownloadStopNotification object:nil\];
}
</code></pre><p>}</p>
<p>上边的方法是为了给图片下载绑定一个 SDNetworkActivityIndicator，只有当这个 SDNetworkActivityIndicator 文件存在的情况下才会执行，目的就是在下载图片时，状态栏会转小菊花。</p>
<p>/**<br> * 初始化方法<br> */<br>- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration <em>)sessionConfiguration<br>{<br>    if ((self = [super init])) {<br>        _operationClass = [SDWebImageDownloaderOperation class];<br>        _shouldDecompressImages = YES;<br>        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;<br>        _downloadQueue = [NSOperationQueue new];<br>        _downloadQueue.maxConcurrentOperationCount = 6;<br>        _downloadQueue.name = @”com.hackemist.SDWebImageDownloader”;<br>        _URLOperations = [NSMutableDictionary new];<br>        SDHTTPHeadersMutableDictionary </em>headerDictionary = [SDHTTPHeadersMutableDictionary dictionary];<br>        NSString *userAgent = nil;</p>
<p>#if SD_UIKIT<br>        // User-Agent Header; see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</a><br>        userAgent = [NSString stringWithFormat:@”%@/%@ (%@; iOS %@; Scale/%0.2f)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString <em>)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString </em>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[UIDevice currentDevice] model], [[UIDevice currentDevice] systemVersion], [[UIScreen mainScreen] scale]];</p>
<p>#elif SD_WATCH<br>        // User-Agent Header; see <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43" target="_blank" rel="noopener">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43</a><br>        userAgent = [NSString stringWithFormat:@”%@/%@ (%@; watchOS %@; Scale/%0.2f)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString <em>)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString </em>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[WKInterfaceDevice currentDevice] model], [[WKInterfaceDevice currentDevice] systemVersion], [[WKInterfaceDevice currentDevice] screenScale]];</p>
<p>#elif SD_MAC<br>        userAgent = [NSString stringWithFormat:@”%@/%@ (Mac OS X %@)”, [[NSBundle mainBundle] infoDictionary][(__bridge NSString <em>)kCFBundleExecutableKey] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString </em>)kCFBundleIdentifierKey], [[NSBundle mainBundle] infoDictionary][@”CFBundleShortVersionString”] ?: [[NSBundle mainBundle] infoDictionary][(__bridge NSString *)kCFBundleVersionKey], [[NSProcessInfo processInfo] operatingSystemVersionString]];</p>
<p>#endif<br>        if (userAgent) {<br>            if (![userAgent canBeConvertedToEncoding:NSASCIIStringEncoding]) {<br>                NSMutableString *mutableUserAgent = [userAgent mutableCopy];<br>                if (CFStringTransform((__bridge CFMutableStringRef)(mutableUserAgent), NULL, (__bridge CFStringRef)@”Any-Latin; Latin-ASCII; [:^ASCII:] Remove”, false)) {<br>                    userAgent = mutableUserAgent;<br>                }<br>            }<br>            headerDictionary[@”User-Agent”] = userAgent;<br>        }</p>
<p>#ifdef SD_WEBP<br>        headerDictionary[@”Accept”] = @”image/webp,image/*;q=0.8”;</p>
<p>#else<br>        headerDictionary[@”Accept”] = @”image/*;q=0.8”;</p>
<p>#endif<br>        _HTTPHeaders = headerDictionary;<br>        _operationsLock = dispatch_semaphore_create(1);<br>        _headersLock = dispatch_semaphore_create(1);<br>        _downloadTimeout = 15.0;</p>
<pre><code>    \[self createNewSessionWithConfiguration:sessionConfiguration\];
}
return self;
</code></pre><p>}</p>
<p>这里边做了必要的初始化，默认最大支持的并发数为 6 个，也就是说可以同时下载 6 张图片。</p>
<p>看看 image/webp,image/<em>;q=0.8 是什么意思。image/webp 是 web 格式的图片，q=0.8 指的是权重系数为 0.8，q 的取值范围是 0 - 1， 默认值为 1，q 作用于它前边分号;前边的内容。在这里，image/webp,image/</em>;q=0.8 表示优先接受 image/webp，其次接受 image/* 的图片。</p>
<p>- (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration {    // 取消所有的下载任务<br>    [self cancelAllDownloads];<br>    // 取消当前的会话<br>    if (self.session) {<br>        [self.session invalidateAndCancel];<br>    }</p>
<pre><code>sessionConfiguration.timeoutIntervalForRequest = self.downloadTimeout;

/\*\*
 \*  Create the session for this task
 \*  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate
 \*  method calls and completion handler calls.
 */    // 创建新的会话
self.session = \[NSURLSession sessionWithConfiguration:sessionConfiguration
                                             delegate:self
                                        delegateQueue:nil\];
</code></pre><p>}</p>
<p>- (void)invalidateSessionAndCancel:(BOOL)cancelPendingOperations<br>{<br>    if (self == [SDWebImageDownloader sharedDownloader]) {<br>        return;<br>    }<br>    if (cancelPendingOperations) {<br>        // 直接取消<br>        [self.session invalidateAndCancel];<br>    }<br>    else {<br>        // 完成任务后取消<br>        [self.session finishTasksAndInvalidate];<br>    }<br>}</p>
<p>新建、挂起/取消会话。</p>
<p>- (void)setValue:(nullable NSString <em>)value forHTTPHeaderField:(nullable NSString </em>)field {<br>    LOCK(self.headersLock);<br>    if (value) {<br>        self.HTTPHeaders[field] = value;<br>    } else {<br>        [self.HTTPHeaders removeObjectForKey:field];<br>    }<br>    UNLOCK(self.headersLock);<br>}</p>
<p>- (nullable NSString <em>)valueForHTTPHeaderField:(nullable NSString </em>)field {<br>    if (!field) {<br>        return nil;<br>    }<br>    return [[self allHTTPHeaderFields] objectForKey:field];<br>}</p>
<p>- (nonnull SDHTTPHeadersDictionary <em>)allHTTPHeaderFields {<br>    LOCK(self.headersLock);<br>    SDHTTPHeadersDictionary </em>allHTTPHeaderFields = [self.HTTPHeaders copy];<br>    UNLOCK(self.headersLock);<br>    return allHTTPHeaderFields;<br>}</p>
<p>- (void)setMaxConcurrentDownloads:(NSInteger)maxConcurrentDownloads {<br>    _downloadQueue.maxConcurrentOperationCount = maxConcurrentDownloads;<br>}</p>
<p>- (NSUInteger)currentDownloadCount {<br>    return _downloadQueue.operationCount;<br>}</p>
<p>- (NSInteger)maxConcurrentDownloads {<br>    return _downloadQueue.maxConcurrentOperationCount;<br>}</p>
<p>- (NSURLSessionConfiguration *)sessionConfiguration {<br>    return self.session.configuration;<br>}</p>
<p>- (void)setOperationClass:(nullable Class)operationClass<br>{<br>    if (operationClass &amp;&amp; [operationClass isSubclassOfClass:[NSOperation class]]<br>        &amp;&amp; [operationClass conformsToProtocol:@protocol(SDWebImageDownloaderOperationInterface)]) {<br>        _operationClass = operationClass;<br>    }<br>    else {<br>        _operationClass = [SDWebImageDownloaderOperation class];<br>    }<br>}</p>
<p>set 或者 get 方法，操作数据时加锁保证多线程安全。</p>
<p>- (NSOperation<sdwebimagedownloaderoperationinterface> <em>)createDownloaderOperationWithUrl:(nullable NSURL </em>)url<br>                                                                   options:(SDWebImageDownloaderOptions)options<br>{<br>    // 1、设置超时时间，默认为 15.0<br>    NSTimeInterval timeoutInterval = self.downloadTimeout;<br>    if (timeoutInterval == 0.0) {<br>        timeoutInterval = 15.0;<br>    }</sdwebimagedownloaderoperationinterface></p>
<pre><code>// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise
// 缓存策略
NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;

// 2、创建请求对象
NSMutableURLRequest *request = \[\[NSMutableURLRequest alloc\] initWithURL:url
                                                            cachePolicy:cachePolicy
                                                        timeoutInterval:timeoutInterval\];
request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);
request.HTTPShouldUsePipelining = YES;

// 3、设置请求头部
if (self.headersFilter) {
    request.allHTTPHeaderFields = self.headersFilter(url, \[self allHTTPHeaderFields\]);
}
else {
    request.allHTTPHeaderFields = \[self allHTTPHeaderFields\];
}

// 4、创建下载任务
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *operation = \[\[self.operationClass alloc\] initWithRequest:request inSession:self.session options:options\];
operation.shouldDecompressImages = self.shouldDecompressImages;

// 5、给任务设置 url 凭证
if (self.urlCredential) {
    operation.credential = self.urlCredential;
}
else if (self.username &amp;&amp; self.password) {
    operation.credential = \[NSURLCredential credentialWithUser:self.username
                                                      password:self.password 
                                                   persistence:NSURLCredentialPersistenceForSession\];
}

// 6、设置优先级
if (options &amp; SDWebImageDownloaderHighPriority) {
    operation.queuePriority = NSOperationQueuePriorityHigh;
}
else if (options &amp; SDWebImageDownloaderLowPriority) {
    operation.queuePriority = NSOperationQueuePriorityLow;
}

// 7、处理下载顺序
if (self.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {
    // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency
    \[self.lastAddedOperation addDependency:operation\];
    self.lastAddedOperation = operation;
}

return operation;
</code></pre><p>}</p>
<p>创建 SDWebImageDownloaderOperation。</p>
<p>- (nullable SDWebImageDownloadToken <em>)downloadImageWithURL:(nullable NSURL </em>)url<br>                                                   options:(SDWebImageDownloaderOptions)options<br>                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock<br>                                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock<br>{<br>    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.<br>    if (url == nil) {<br>        if (completedBlock != nil) {<br>            completedBlock(nil, nil, nil, NO);<br>        }<br>        return nil;<br>    }</p>
<pre><code>LOCK(self.operationsLock);
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *operation = \[self.URLOperations objectForKey:url\];
// There is a case that the operation may be marked as finished or cancelled, but not been removed from \`self.URLOperations\`.

// 创建新的操作对象
if (!operation || operation.isFinished || operation.isCancelled) {
    operation = \[self createDownloaderOperationWithUrl:url options:options\];
    __weak typeof(self) wself = self;
    operation.completionBlock = ^{
        __strong typeof(wself) sself = wself;
        if (!sself) {
            return;
        }
        LOCK(sself.operationsLock);
        \[sself.URLOperations removeObjectForKey:url\];
        UNLOCK(sself.operationsLock);
    };
    \[self.URLOperations setObject:operation forKey:url\];
    // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.
    // \`addOperation:\` does not synchronously execute the \`operation.completionBlock\` so this will not cause deadlock.
    // 任务加入到队列
    \[self.downloadQueue addOperation:operation\];
}
// 操作任务没有在运行中
else if (!operation.isExecuting) {
    if (options &amp; SDWebImageDownloaderHighPriority) {
        operation.queuePriority = NSOperationQueuePriorityHigh;
    }
    else if (options &amp; SDWebImageDownloaderLowPriority) {
        operation.queuePriority = NSOperationQueuePriorityLow;
    }
    else {
        operation.queuePriority = NSOperationQueuePriorityNormal;
    }
}
UNLOCK(self.operationsLock);

id downloadOperationCancelToken = \[operation addHandlersForProgress:progressBlock completed:completedBlock\];

SDWebImageDownloadToken *token = \[SDWebImageDownloadToken new\];
token.downloadOperation = operation;
token.url = url;
token.downloadOperationCancelToken = downloadOperationCancelToken;

return token;
</code></pre><p>}</p>
<p>为每个 URL 绑定事件。</p>
<p>- (void)cancel:(nullable SDWebImageDownloadToken <em>)token<br>{<br>    NSURL </em>url = token.url;<br>    if (!url) {<br>        return;<br>    }<br>    LOCK(self.operationsLock);<br>    NSOperation<sdwebimagedownloaderoperationinterface> *operation = [self.URLOperations objectForKey:url];<br>    if (operation) {<br>        BOOL canceled = [operation cancel:token.downloadOperationCancelToken];<br>        if (canceled) {<br>            [self.URLOperations removeObjectForKey:url];<br>        }<br>    }<br>    UNLOCK(self.operationsLock);<br>}</sdwebimagedownloaderoperationinterface></p>
<p>取消某个操作。</p>
<p>- (void)setSuspended:(BOOL)suspended<br>{<br>    self.downloadQueue.suspended = suspended;<br>}</p>
<p>- (void)cancelAllDownloads<br>{<br>    [self.downloadQueue cancelAllOperations];<br>}</p>
<p>全部暂停或取消。</p>
<p>我们在初始化方法中创建了会话：</p>
<p>self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration</p>
<pre><code>     delegate:self

delegateQueue:nil\];
</code></pre><p>delegate 设置为自己，也就是当使用这个会话请求数据，收到响应时，会调用 SDWebImageDownloader.m 中的代理方法，然后再调用 SDWebImageDownloaderOperation 中的代理方法处理事情。</p>
<p>那么作者为什么这么设计呢？目的就是为了共用一个 URLSession。</p>
<p>#pragma mark NSURLSessionDataDelegate</p>
<p>- (void)URLSession:(NSURLSession <em>)session<br>          dataTask:(NSURLSessionDataTask </em>)dataTask<br>didReceiveResponse:(NSURLResponse *)response<br> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:dataTask\];
if (\[dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)\]) {
    \[dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler\];
} else {
    if (completionHandler) {
        completionHandler(NSURLSessionResponseAllow);
    }
}
</code></pre><p>}</p>
<p>- (void)URLSession:(NSURLSession <em>)session dataTask:(NSURLSessionDataTask </em>)dataTask didReceiveData:(NSData *)data {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:dataTask\];
if (\[dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveData:)\]) {
    \[dataOperation URLSession:session dataTask:dataTask didReceiveData:data\];
}
</code></pre><p>}</p>
<p>- (void)URLSession:(NSURLSession <em>)session<br>          dataTask:(NSURLSessionDataTask </em>)dataTask<br> willCacheResponse:(NSCachedURLResponse <em>)proposedResponse<br> completionHandler:(void (^)(NSCachedURLResponse </em>cachedResponse))completionHandler {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:dataTask\];
if (\[dataOperation respondsToSelector:@selector(URLSession:dataTask:willCacheResponse:completionHandler:)\]) {
    \[dataOperation URLSession:session dataTask:dataTask willCacheResponse:proposedResponse completionHandler:completionHandler\];
} else {
    if (completionHandler) {
        completionHandler(proposedResponse);
    }
}
</code></pre><p>}</p>
<p>#pragma mark NSURLSessionTaskDelegate</p>
<p>- (void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task didCompleteWithError:(NSError *)error {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:task\];
if (\[dataOperation respondsToSelector:@selector(URLSession:task:didCompleteWithError:)\]) {
    \[dataOperation URLSession:session task:task didCompleteWithError:error\];
}
</code></pre><p>}</p>
<p>- (void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task willPerformHTTPRedirection:(NSHTTPURLResponse <em>)response newRequest:(NSURLRequest </em>)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:task\];
if (\[dataOperation respondsToSelector:@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)\]) {
    \[dataOperation URLSession:session task:task willPerformHTTPRedirection:response newRequest:request completionHandler:completionHandler\];
} else {
    if (completionHandler) {
        completionHandler(request);
    }
}
</code></pre><p>}</p>
<p>- (void)URLSession:(NSURLSession <em>)session task:(NSURLSessionTask </em>)task didReceiveChallenge:(NSURLAuthenticationChallenge <em>)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential </em>credential))completionHandler {</p>
<pre><code>// Identify the operation that runs this task and pass it the delegate method
NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *dataOperation = \[self operationWithTask:task\];
if (\[dataOperation respondsToSelector:@selector(URLSession:task:didReceiveChallenge:completionHandler:)\]) {
    \[dataOperation URLSession:session task:task didReceiveChallenge:challenge completionHandler:completionHandler\];
} else {
    if (completionHandler) {
        completionHandler(NSURLSessionAuthChallengePerformDefaultHandling, nil);
    }
}
</code></pre><p>}</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/15/sdwebimagedownloader/">http://yoursite.com/2019/03/15/sdwebimagedownloader/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/15/sdwebimagemanager/" class="pre"> SDWebImageManager		</a><a href="/2019/03/14/sdwebimagedownloaderoperation/" class="next"> SDWebImageDownloaderOperation		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、编程"><span class="toc-text">一、编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、-h-文件"><span class="toc-text">二、.h 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、-m-文件"><span class="toc-text">三、.m 文件</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>