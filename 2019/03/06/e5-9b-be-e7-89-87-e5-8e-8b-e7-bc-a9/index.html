<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> 图片压缩		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> 图片压缩		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> 图片压缩		</h1><div class="post-meta"><a href="/2019/03/06/e5-9b-be-e7-89-87-e5-8e-8b-e7-bc-a9/#comments" class="comment-count"></a><p><span class="date">Mar 06, 2019</span><span><a href="/categories/图像视频/" class="category">图像视频</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://blog.csdn.net/BUG_delete/article/details/84636899" target="_blank" rel="noopener">iOS优秀的图片压缩处理方案（系统 UIImageJPEG 和 UIKit 以及 ImageI/O 处理）</a></p>
<p>Demo 地址：<a href="https://github.com/KirstenDunst/CSXImageCompress" target="_blank" rel="noopener">https://github.com/KirstenDunst/CSXImageCompress</a></p>
<p>大图资源：<a href="https://pan.baidu.com/s/13eexiBPy_lyJxBLXIddnZw" target="_blank" rel="noopener">https://pan.baidu.com/s/13eexiBPy_lyJxBLXIddnZw</a></p>
<h5 id="一、UIImageJPEGRepresentation"><a href="#一、UIImageJPEGRepresentation" class="headerlink" title="一、UIImageJPEGRepresentation"></a>一、UIImageJPEGRepresentation</h5><p>1、为什么用 UIImageJPEGRepresentation() 不用 UIImagePNGRepresentation()？</p>
<p>因为是 png 格式读取的内容会有多图层的的问题导致读取的会显示比较大，而且比较耗时间。</p>
<p>{<br>    double begin = CACurrentMediaTime();<br>    NSData * data1 = UIImagePNGRepresentation(image);<br>    double end = CACurrentMediaTime();</p>
<pre><code>NSLog(@&quot;%8.2f  %lu&quot;, (end - begin) * 1000, (unsigned long)\[data1 length\]);

begin = CACurrentMediaTime();
NSData * data2 = UIImageJPEGRepresentation(image, 1.0);
end = CACurrentMediaTime();

NSLog(@&quot;%8.2f  %lu&quot;, (end - begin) * 1000, (unsigned long)\[data2 length\]);
</code></pre><p>}</p>
<p>Demo[10775:139506]     2.44  6831<br>Demo[10775:139506]     0.71  15256</p>
<p>一张 29KB 的图片，UIImagePNGRepresentation() 返回的数据大小为 6.831KB，而 UIImageJPEGRepresentation( , 1.0) 返回的数据大小为 15.256KB，UIImageJPEGRepresentation( , 0.5) 的数据大小为 3.166KB。如果对图片的清晰度要求不高，还可以通过设置 UIImageJPEGRepresentation() 函数的第二个参数，大幅度降低图片数据量。</p>
<p>2、第二个参数 scale，一个 0～1 的浮点型比率，0 不是压缩到 0B 大小，1.0 不是原图大小。</p>
<p>图片的大小 = 图片的宽 * 图片的高 * 每一个色彩的深度。你的图片只会按照你的手机像素的分辨率 [UIScreen mainScreen].scale 来读取值。其次，第二个参数苹果官方并没有明确说明这个参数的具体意义。对于大图片来说，即使你的scale 设置很小，比如：0.0000000001，但是得到的结果还是很大，这里做了一个实验：一个 10M 左右的图片，处理后大小为2M 多，有点不能继续的感觉。当然如果是小图片的话那就是没问题，能满足你的希望的压缩到的大小。</p>
<h5 id="二、压缩"><a href="#二、压缩" class="headerlink" title="二、压缩"></a>二、压缩</h5><p>循环压缩算法，考虑到递归、二分法处理。更快一点压缩图片到指定的大小。先看一段代码：</p>
<p>{<br>    // 二分最多 10 次，区间范围精度最大可达 0.00097657；最大 6 次，精度可达 0.015625<br>    for (int i = 0; i &lt; 10; ++i) {</p>
<pre><code>    compression = (max + min) / 2;

    imageData = UIImageJPEGRepresentation(image, compression);

    // 容错区间范围 0.9～1.0
    if (imageData.length &lt; fImageBytes * 0.9) {
        min = compression;
    }
    else if (imageData.length &gt; fImageBytes) {
        max = compression;
    }
    else {
        break;
    }
}
</code></pre><p>}</p>
<p>上面就是使用二分法进行处理，比 for 循环依次递减“高效”很多，而且也合理很多。</p>
<p>无法继续压缩怎么办？</p>
<p>这样压缩到极致（一般我们不用进行太多的 for 循环，个人觉得参数到 0.05 已经可以了），如果还是比你想要的大很多那就不要用 UIImageJPEGRepresentation 了。</p>
<p>然后可以换一个方式，进行尺寸压缩。提到尺寸压缩，会不会很失望，原来也是使用 UIGraphicsBeginImageContextWithOptions 然后 drawInRect 绘制一个图片。代码类似如下：</p>
<p>/**<br> *  @brief 根据 size 返回一个新的 image<br> */<br>- (UIImage <em>)drawWithWithImage:(UIImage </em>)imageCope Size:(CGSize)size<br>{<br>    // 这里设置为 0，意为自动设置清晰度，图片可以是别的传过来的图片信息<br>    UIGraphicsBeginImageContextWithOptions(size, NO, 0);<br>    [imageCope drawInRect:CGRectMake(0, 0, size.width, size.height)];<br>    imageCope = UIGraphicsGetImageFromCurrentImageContext();<br>    UIGraphicsEndImageContext();</p>
<pre><code>return imageCope;
</code></pre><p>}</p>
<p>首先需要说一下这个绘制很耗内存性能的，[UIImage drawInRect:] 在绘制时，先解码图片，再生成原始分辨率大小的bitmap，这是很耗内存的，并且还有位数对齐等耗时操作。</p>
<p>如果在一个方法中循环压缩比例进行代码的比例压缩，那么这种使用 UIKit 类进行图片绘制的话是需要先把图片读入内存然后再进行绘制，那么势必会给内存中占用大量的临时内存 bitmap，而这个如果再加上循环，那么内存占有将是不可估量的，你可能会加一个自动释放池 @autoreleasepool，错：首先这个自动释放池 @autoreleasepool 不要放在循环的外面，包着这个循环，原因就不过多说明，可以自行百度。然后放在 for 循环内部包着这个绘制的方法，你的内存并不是画完就得到了释放，内存占有的情况可以得到缓解，但是还是不能解决内存突然暴增的问题。尤其是大图片的压缩尤其明显。</p>
<p>然后你会想换一个方式，使用 Image I/O 相关的处理方式，使用相关的生成缩略图的形式压缩图片文件。直接上代码如下：</p>
<p>static size_t getAssetBytesCallback(void *info, void *buffer, off_t position, size_t count)<br>{<br>    ALAssetRepresentation <em> rep = (__bridge id)info;<br>    NSError </em> error = nil;<br>    size_t countRead = [rep getBytes:(uint8_t *)buffer fromOffset:position length:count error:&amp;error];</p>
<pre><code>if (countRead == 0 &amp;&amp; error) {
    // We have no way of passing this info back to the caller, so we log it, at least.
    NSLog(@&quot;thumbnailForAsset:maxPixelSize: got an error reading an asset: %@&quot;, error);
}
return countRead;
</code></pre><p>}</p>
<p>static void releaseAssetCallback(void * info)<br>{<br>    // The info here is an ALAssetRepresentation which we CFRetain in thumbnailForAsset:maxPixelSize:.<br>    // This release balances that retain.<br>    CFRelease(info);<br>}</p>
<p>- (UIImage <em>)thumbnailForAsset:(ALAsset </em>)asset maxPixelSize:(NSUInteger)size<br>{<br>    NSParameterAssert(asset != nil);<br>    NSParameterAssert(size &gt; 0);</p>
<pre><code>ALAssetRepresentation * rep = \[asset defaultRepresentation\];

CGDataProviderDirectCallbacks callbacks = { .version = 0, .getBytePointer = NULL, .releaseBytePointer = NULL, .getBytesAtPosition = getAssetBytesCallback, .releaseInfo = releaseAssetCallback, };

CGDataProviderRef provider = CGDataProviderCreateDirect((void *)CFBridgingRetain(rep), \[rep size\], &amp;callbacks);

CGImageSourceRef source = CGImageSourceCreateWithDataProvider(provider, NULL);
CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(source, 0, (__bridge CFDictionaryRef) @{ (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @YES,(NSString *)kCGImageSourceThumbnailMaxPixelSize : @(size), (NSString *)kCGImageSourceCreateThumbnailWithTransform : @YES, });

CFRelease(source);
CFRelease(provider);

if (!imageRef) {
    return nil;
}

UIImage * toReturn = \[UIImage imageWithCGImage:imageRef\];

CFRelease(imageRef);

return toReturn;
</code></pre><p>}</p>
<p>可以结合从数据库获取的 info 返回使用。这里代码如下：</p>
<p>#pragma mark - UIImagePickerControllerDelegate</p>
<p>- (void)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary </em>)info<br>{<br>    NSLog(@”info:\n%@”, info);</p>
<pre><code>UIImage * image = info\[UIImagePickerControllerOriginalImage\];
__block NSData * imgData = UIImageJPEGRepresentation(image, 1.0);

NSLog(@&quot;length1: %lu&quot;, (unsigned long)imgData.length);

NSURL * imageURL = info\[UIImagePickerControllerReferenceURL\];
ALAssetsLibrary * assetsLibrary = \[\[ALAssetsLibrary alloc\] init\];
\[assetsLibrary assetForURL:imageURL resultBlock:^(ALAsset *asset) {

    image = \[self thumbnailForAsset:asset maxPixelSize:600\];
    imgData = UIImageJPEGRepresentation(image, 1.0);

    NSLog(@&quot;length2: %lu&quot;, (unsigned long)imgData.length);

    NSArray * paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);

    NSString *filePath = \[\[paths objectAtIndex:0\] stringByAppendingPathComponent:@&quot;new/ceshi.jpg&quot;\];

    // 保存文件的名称
    BOOL result = \[imgData writeToFile: filePath atomically:YES\];
    // 保存成功会返回YES
    NSLog(@&quot;文件保存成功？%d&quot;,result);

} failureBlock:nil\];

\[picker dismissViewControllerAnimated:YES completion:^{}\];
</code></pre><p>}</p>
<p>使用 ImageIO 接口，避免在改变图片大小的过程中产生临时的 bitmap，就能够在很大程度上减少内存的占有从而避免由此导致的 app 闪退问题。</p>
<p>在这之前我也直接有过另外一种方式压缩图片（直接靠图片尺寸压缩绘制图片）：</p>
<p>+ (void)compressedImageFiles:(UIImage <em>)image imageKB:(CGFloat)fImageKBytes imageBlock:(ReturnCompressImage)block<br>{<br>    __block UIImage </em>imageCope = image;<br>    CGFloat fImageBytes = fImageKBytes <em> 1024; // 需要压缩的字节Byte<br>    __block NSData </em>uploadImageData = nil;</p>
<p>//        uploadImageData = UIImagePNGRepresentation(imageCope);<br>    uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0);<br>//    NSLog(@”图片压前缩成 %fKB”,uploadImageData.length/1024.0);<br>//    CGFloat value1 = uploadImageData.length/1024.0;</p>
<pre><code>CGSize size = imageCope.size;
CGFloat imageWidth = size.width;
CGFloat imageHeight = size.height;

if (uploadImageData.length &gt; fImageBytes &amp;&amp; fImageBytes &gt;0) {

    dispatch\_async(dispatch\_queue\_create(&quot;CompressedImage&quot;, DISPATCH\_QUEUE_SERIAL), ^{

        /\* 宽高的比例 **/
        CGFloat ratioOfWH = imageWidth/imageHeight;
        /\* 压缩率 **/
        CGFloat compressionRatio = fImageBytes/uploadImageData.length;
        /\* 宽度或者高度的压缩率 **/
        CGFloat widthOrHeightCompressionRatio = sqrt(compressionRatio);

        CGFloat dWidth   = imageWidth *widthOrHeightCompressionRatio;
        CGFloat dHeight  = imageHeight*widthOrHeightCompressionRatio;
        if (ratioOfWH &gt;0) { /* 宽 &gt; 高,说明宽度的压缩相对来说更大些 **/
            dHeight = dWidth/ratioOfWH;
        }
        else {
            dWidth  = dHeight*ratioOfWH;
        }

        imageCope = \[self drawWithWithImage:imageCope width:dWidth height:dHeight\];
        //            uploadImageData = UIImagePNGRepresentation(imageCope);
        uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0);
</code></pre><p>//            NSLog(@”当前的图片已经压缩成 %fKB”,uploadImageData.length/1024.0);<br>            //微调<br>            NSInteger compressCount = 0;<br>            /* 控制在 1M 以内<strong>/<br>            while (fabs(uploadImageData.length - fImageBytes) &gt; 1024) {<br>                /* 再次压缩的比例</strong>/<br>                CGFloat nextCompressionRatio = 0.9;</p>
<pre><code>    if (uploadImageData.length &gt; fImageBytes) {
        dWidth = dWidth*nextCompressionRatio;
        dHeight= dHeight*nextCompressionRatio;
    }else {
        dWidth = dWidth/nextCompressionRatio;
        dHeight= dHeight/nextCompressionRatio;
    }

    imageCope = \[self drawWithWithImage:imageCope width:dWidth height:dHeight\];
    //                uploadImageData = UIImagePNGRepresentation(imageCope);
    uploadImageData = UIImageJPEGRepresentation(imageCope, 1.0);

    /*防止进入死循环**/
    compressCount ++;
    if (compressCount == 10) {
        break;
    }
}
</code></pre><p>//            NSLog(@”图片已经压缩成 %fKB”,uploadImageData.length/1024.0);<br>//            CGFloat value2 = uploadImageData.length/1024.0;</p>
<pre><code>        imageCope = \[\[UIImage alloc\] initWithData:uploadImageData\];

        dispatch\_sync(dispatch\_get\_main\_queue(), ^{
            if (block) {
                block(imageCope);
            }
        });
    });
} 
else {
    if (block) {
        block(imageCope);
    }
}
</code></pre><p>}</p>
<p>/* 根据 dWidth dHeight 返回一个新的 image <em>/<br>+ (UIImage </em>)drawWithWithImage:(UIImage *)imageCope width:(CGFloat)dWidth height:(CGFloat)dHeight<br>{<br>    UIGraphicsBeginImageContext(CGSizeMake(dWidth, dHeight));<br>    [imageCope drawInRect:CGRectMake(0, 0, dWidth, dHeight)];<br>    imageCope = UIGraphicsGetImageFromCurrentImageContext();<br>    UIGraphicsEndImageContext();</p>
<pre><code>return imageCope;   
</code></pre><p>}</p>
<p>这种方式极耗手机的 cpu，而且绘制也是使用 UIKit 进行绘制，内存占用也是比较严重的。</p>
<p>综合上面的所有情况现在我的最终处理方案如下：</p>
<p>①、首先使用 UIImageJPEGRepresentation 进行尽可能的压缩，这里使用二分法（考虑到手机性能问题，这里二分法设置 10 次以内即可，能精确到 0.00097657）处理压缩的比率参数，尽可能压缩一下原图片信息，比对一下最小的二分法能处理的最大限度得到的最小图片信息能否满足条件（在你设定的目标大小以内）。以减少不必要的循环，保护 cpu 处理</p>
<p>②、然后对处理后的图片信息，保留最大压缩比（即上面的最小二分法的 scale 结果），然后再进行和最终目标的大小比值，求根，然后对图像的宽和高等比压缩处理。然后再次根据最小二分法的 scale 以 UIImageJPEGRepresentation 读取结果再和你的目标大小比对，然后以此循环。直到小于目标大小。</p>
<p>这样得到的图片几乎就能够在你设定的大小以内的附近，而且图片的信息肉眼几乎看不出来多大的区别，而且压缩出来的图片清晰度很高。</p>
<p>代码如下：</p>
<p>- (void)compressedImageFiles:(UIImage <em>)image imageKB:(CGFloat)fImageKBytes imageBlock:(void(^)(NSData </em>imageData))block<br>{<br>    //二分法压缩图片<br>    CGFloat compression = 1;<br>    NSData <em>imageData = UIImageJPEGRepresentation(image, compression);<br>    NSUInteger fImageBytes = fImageKBytes </em> 1000; //需要压缩的字节Byte，iOS系统内部的进制1000<br>    if (imageData.length &lt;= fImageBytes){<br>        block(imageData);<br>        return;<br>    }<br>    CGFloat max = 1;<br>    CGFloat min = 0;<br>    //指数二分处理，s首先计算最小值<br>    compression = pow(2, -6);<br>    imageData = UIImageJPEGRepresentation(image, compression);</p>
<pre><code>if (imageData.length &lt; fImageBytes) {
    //二分最大10次，区间范围精度最大可达0.00097657；最大6次，精度可达0.015625
    for (int i = 0; i &lt; 6; ++i) {
        compression = (max + min) / 2;
        imageData = UIImageJPEGRepresentation(image, compression);
        //容错区间范围0.9～1.0
        if (imageData.length &lt; fImageBytes * 0.9) {
            min = compression;
        } 
        else if (imageData.length &gt; fImageBytes) {
            max = compression;
        }  
        else {
            break;
        }
    }

    block(imageData);
    return;
}

// 对于图片太大上面的压缩比即使很小压缩出来的图片也是很大，不满足使用。
// 然后再一步绘制压缩处理
UIImage * resultImage = \[UIImage imageWithData:imageData\];
while (imageData.length &gt; fImageBytes) {
    @autoreleasepool {
        CGFloat ratio = (CGFloat)fImageBytes / imageData.length;
        // 使用 NSUInteger 不然由于精度问题，某些图片会有白边
        NSLog(@&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&gt;&gt;&gt;&gt;&gt;&gt;&gt;%f&quot;,resultImage.size.width, sqrtf(ratio), resultImage.size.height);
        CGSize size = CGSizeMake((NSUInteger)(resultImage.size.width * sqrtf(ratio)),
                                 (NSUInteger)(resultImage.size.height * sqrtf(ratio)));
</code></pre><p>//            resultImage = [self drawWithWithImage:resultImage Size:size];<br>//            resultImage = [self scaledImageWithData:imageData withSize:size scale:resultImage.scale orientation:UIImageOrientationUp];<br>            resultImage = [self thumbnailForData:imageData maxPixelSize:MAX(size.width, size.height)];<br>            imageData = UIImageJPEGRepresentation(resultImage, compression);<br>        }<br>    }</p>
<pre><code>// 整理后的图片尽量不要用 UIImageJPEGRepresentation 方法转换，后面参数 1.0 并不表示的是原质量转换。
block(imageData);
</code></pre><p>}<br>- (UIImage <em>)thumbnailForData:(NSData </em>)data maxPixelSize:(NSUInteger)size<br>{<br>    CGDataProviderRef provider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);<br>    CGImageSourceRef source = CGImageSourceCreateWithDataProvider(provider, NULL);</p>
<pre><code>CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(source, 0, (__bridge CFDictionaryRef) @{
                                           (NSString *)kCGImageSourceCreateThumbnailFromImageAlways : @YES,
                                                    (NSString *)kCGImageSourceThumbnailMaxPixelSize : @(size),
                                             (NSString *)kCGImageSourceCreateThumbnailWithTransform : @YES,
                                                                                                  });
CFRelease(source);
CFRelease(provider);

if (!imageRef) {
    return nil;
}

UIImage * toReturn = \[UIImage imageWithCGImage:imageRef\];

CFRelease(imageRef);

return toReturn;
</code></pre><p>}</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/06/e5-9b-be-e7-89-87-e5-8e-8b-e7-bc-a9/">http://yoursite.com/2019/03/06/e5-9b-be-e7-89-87-e5-8e-8b-e7-bc-a9/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/06/tcp/" class="pre"> TCP		</a><a href="/2019/03/06/cgimagesource/" class="next"> CGImageSource		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、UIImageJPEGRepresentation"><span class="toc-text">一、UIImageJPEGRepresentation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、压缩"><span class="toc-text">二、压缩</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>