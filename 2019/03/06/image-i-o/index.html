<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> Image I/O 解码探究		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> Image I/O 解码探究		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> Image I/O 解码探究		</h1><div class="post-meta"><a href="/2019/03/06/image-i-o/#comments" class="comment-count"></a><p><span class="date">Mar 06, 2019</span><span><a href="/categories/图像视频/" class="category">图像视频</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://www.jianshu.com/p/19e1faddd37f" target="_blank" rel="noopener">图片 ImageI/O 解码探究</a></p>
<h5 id="一、Image-I-O"><a href="#一、Image-I-O" class="headerlink" title="一、Image I/O"></a>一、Image I/O</h5><p>在使用 CGImageSourceCreateImageAtIndex() 和 CGImageSourceCreateThumbnailAtIndex() 方法创建 UIImage 对象时，引发了关于 ImageI/O 的使用以及解码过程的思考。</p>
<p>当用 UIImage 或 CGImageSource 的几个相关方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</p>
<p>通过下面的方法模拟图片被解码并渲染的过程：</p>
<p>- (void)drawImage:(UIImage *)image<br>{<br>    size_t width = CGImageGetWidth(image.CGImage);<br>    size_t height = CGImageGetHeight(image.CGImage);</p>
<pre><code>CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceRGB();

CGContextRef context = CGBitmapContextCreate(NULL,
                                             width,
                                             height,
                                             8,
                                             width * 4,
                                             colorSpaceRef,
                                             kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
if(!context) return;

// 绘制图片。解码阶段
CGContextDrawImage(context, CGRectMake(0, 0, width, height), image.CGImage);
// 获取图片
CGImageRef newImageRef = CGBitmapContextCreateImage(context);

// 释放内存
CGColorSpaceRelease(colorSpaceRef);
CFRelease(context);
CGImageRelease(newImageRef);
</code></pre><p>}</p>
<p>用 TimeProfiler 一步一步来看过程中内部调用的函数可以帮助我们解决问题，由于 TimeProfiler 统计函数栈为间隔一段时间统计一次，导致没有记录下所有函数的调用而且每次函数栈还可能不一致，所以没法精确判断函数栈是如何调用的，但是可以大概推测出每步做了什么。</p>
<p>看下正常情况下图片解码时系统都是如何做的。首先是 PNG 格式的图片：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-12d2222525d3dc71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>CGContextDrawImageWithOptions 方法中，调用了 PNGPlugin 库中的一系列方法，没有明显看到带有 decode 关键字的方法，猜测 png_read_IDAT_dataApple 就是执行的解码过程。</p>
<p>接着是 JPEG 格式的图片：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-5d02ea1fc1770177.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>CGContextDrawImageWithOptions 方法中调用了 AppleJPEGPlugin 库中的一系列方法，可以看到带有 decode 关键字的方法 FigPhotoJPEGDecodeJPEGIntoRGBSurface，这个应该就是执行解码的过程。</p>
<p>以上的实验大致推断出 PNG 和 JPEG 格式的图片执行解码的关键方法，接下来正式进入本文章的探究主题。</p>
<p>下面使用 ImageI/O 通过获取缩略图的方法，将图片进行裁剪操作，生成所需要的 UIImage 对象。</p>
<p>- (UIImage <em>)resizeWithData:(NSData </em>)data scaleSize:(CGSize)size<br>{<br>    if(!data) {<br>        return nil;<br>    }</p>
<pre><code>// 获取 source 对象
CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);

if(!imageSourceRef) {
    return nil;
}

CGFloat maxPixelSize = MAX(size.width, size.height);

CFDictionaryRef options = (__bridge CFDictionaryRef) @{ 
                  (\_\_bridge id)kCGImageSourceShouldCacheImmediately : (\_\_bridge id)kCFBooleanFalse, 
                             (\_\_bridge id)kCGImageSourceShouldCache : (\_\_bridge id)kCFBooleanFalse, 
          (\_\_bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (\_\_bridge id)kCFBooleanTrue, 
                   (__bridge id)kCGImageSourceThumbnailMaxPixelSize : \[NSNumber numberWithFloat:maxPixelSize\] };
// 获取缩略图
CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSourceRef, 0, options);

UIImage * thumbnailImage = \[UIImage imageWithCGImage:imageRef\];

// 释放内存
CFRelease(imageSourceRef);
CGImageRelease(imageRef);

return thumbnailImage;
</code></pre><p>}</p>
<p>options 的几个参数需要解释一下，依次如下：</p>
<p>1、kCGImageSourceShouldCacheImmediately。文档解释：</p>
<p>/* Specifies whether image decoding and caching should happen at image creation time.<br> * The value of this key must be a CFBooleanRef. The default value is kCFBooleanFalse (image decoding will<br> * happen at rendering time).<br> */</p>
<p>是否应该在图像创建过程时进行图像解码和缓存。</p>
<p>值必须是 CFBooleanRef。 默认值为 kCFBooleanFalse（图像解码将在渲染时发生）。</p>
<p>2、kCGImageSourceShouldCache。文档解释：  </p>
<p>/** Keys for the options dictionary of “CGImageSourceCopyPropertiesAtIndex”<br> ** and “CGImageSourceCreateImageAtIndex”. *<em>/<br>/\</em> Specifies whether the image should be cached in a decoded form. The<br> * value of this key must be a CFBooleanRef.<br> * kCFBooleanFalse indicates no caching, kCFBooleanTrue indicates caching.<br> * For 64-bit architectures, the default is kCFBooleanTrue, for 32-bit the default is kCFBooleanFalse.<br> */</p>
<p>在方法 CGImageSourceCopyPropertiesAtIndex 和 CGImageSourceCreateImageAtIndex 中使用指定是否应以解码形式缓存图像。</p>
<p>此键的值必须是 CFBooleanRef。 kCFBooleanFalse 表示没有缓存，kCFBooleanTrue 表示缓存。 对于 64 位体系结构，默认值为 kCFBooleanTrue，对于 32 位，默认值为 kCFBooleanFalse。</p>
<p>注意：此 key 指定的是解码后的数据是否需要缓存。此处我们设置为 kCFBooleanFalse，不进行缓存。</p>
<p>3、kCGImageSourceCreateThumbnailFromImageAlways。文档解释：</p>
<p>/* Specifies whether a thumbnail should be created from the full image even<br> * if a thumbnail is present in the image source file. The thumbnail will<br> * be created from the full image, subject to the limit specified by<br> * kCGImageSourceThumbnailMaxPixelSize—if a maximum pixel size isn’t<br> * specified, then the thumbnail will be the size of the full image, which<br> * probably isn’t what you want. The value of this key must be a<br> * CFBooleanRef; the default value of this key is kCFBooleanFalse.<br> */</p>
<p>指定是否应从完整图像创建缩略图，即使图像源文件中存在缩略图。</p>
<p>缩略图将根据完整图像创建，受 kCGImageSourceThumbnailMaxPixelSize 指定的限制，如果未指定最大像素大小，则缩略图将是完整图像的大小。</p>
<p>该键的值必须是 CFBooleanRef，默认值为 kCFBooleanFalse。</p>
<p>4、kCGImageSourceThumbnailMaxPixelSize。文档解释：</p>
<p>/* Specifies the maximum width and height in pixels of a thumbnail.  If<br> * this this key is not specified, the width and height of a thumbnail is<br> * not limited and thumbnails may be as big as the image itself.  If<br> * present, this value of this key must be a CFNumberRef.<br> */</p>
<p>指定缩略图的最大宽度和高度（以像素为单位）。</p>
<p>如果未指定此键，则缩略图的宽度和高度不受限制，缩略图可能与图像本身一样大；否则值必须为 CFNumberRef。</p>
<p>接下来看看 CGImageSourceCreateThumbnailAtIndex() 系统具体做了什么。</p>
<h5 id="二、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanTrue"><a href="#二、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanTrue" class="headerlink" title="二、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanTrue"></a>二、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanTrue</h5><p>为了测试图片的解码过程，令 kCGImageSourceShouldCacheImmediately 的值设置为 kCFBooleanTrue，也就是创建图片过程中进行解码。</p>
<p>1、PNG 格式的图片</p>
<p>根据 Time Profiler 查看下系统在这个函数里面做了什么，调用结果如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ed8d10ce37ab6f7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p>
<p>看到 - (UIImage)resizeWithData:(NSData)data scaleSize:(CGSize)size 方法执行了 48.00ms，其中CGImageSourceCreateThumbnailAtIndex() 执行了大约 45.00ms，大部分耗时都在这里。</p>
<p>继续看下里面究竟做了什么。过程中系统调用了 CGContextDrawImageWithOptions。因为我们前面设置了kCGImageSourceShouldCacheImmediately 对应的值修改为 kCFBooleanTrue，也就是需要解码，所以这里系统调用了CGContextDrawImageWithOptions 方法，会将图片渲染到画布，这个过程是会解码的。再接着往下看，具体解码的步骤在哪里。可以看到接下来最耗时的操作分别在 img_interpolate_extent 和 img_interpolate_read 两个函数。然后分别看看这两个函数做了什么。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7ae286bb96d94021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p>
<p>系统调用了 CGImageProviderCopyImageBlockSet，里面调用了 PNGPlugin 库的 _cg_png_read_row 和 _cg_png_read_info 方法，_cg_png_read_row 方法调用了 png_read_IDAT_dataApple，这个方法上面已经提到了，是进行的解码操作。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-dc491748584fcf4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"></p>
<p>img_interpolate_read 里面调用了 img_decide_read，猜测应该是读取解码完成的数据。PNG 格式的图片如何解码大致推理出来了。</p>
<p>2、JPEG 格式的图片</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-b2d1c989d45367ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"></p>
<p>JPEG 图片的 -(UIImage)resizeWithData:(NSData)data scaleSize:(CGSize)size 方法执行了 55.00ms，其中CGImageSourceCreateThumbnailAtIndex() 执行了大约 53.00ms，这里系统同样调用了 CGContextDrawImageWithOptions方法，与 PNG 不同的是，JPEG 里面调用了 img_decode_stage 和 img_interpolate_read 方法。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0a731de173c33d53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>可以看到 img_decode_stage 方法里面同样调用了 CGImageProviderCopyImageBlockSet 方法，然后调用了AppleJPEGPlugin 库的 FigPhotoJPEGDecodeJPEGIntoRGBSurface 方法，这里进行了解码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ee0b011b4f1226a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"></p>
<p>img_interpolate_read 里面调用了 img_decode_read，与 PNG 图片的一模一样，应该也是对解码完成的数据进行读取。</p>
<p>以上就是解码过程的剖析，那么作为对比试验，我们接下来看下不经过解码时的调用过程。</p>
<h5 id="三、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanFalse"><a href="#三、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanFalse" class="headerlink" title="三、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanFalse"></a>三、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanFalse</h5><p>将 kCGImageSourceShouldCacheImmediately 对应的值修改为 kCFBooleanFalse，也就是创建图片过程中不进行解码。</p>
<p>1、PNG 格式的图片</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0c4c793c0b3d102b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"></p>
<p>居然跟之前强制解码的一模一样，也是 img_interpolate_extent、img_interpolate_read。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1417630-197836b5ce4c9753" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-20c7a8b3383fbb59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"></p>
<p>真的是也会解码！这究竟是为什么呢？难道是 options 的问题？</p>
<p>CFDictionaryRef options = (<strong>bridge CFDictionaryRef) @{<br>             (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse,<br>                        (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse,<br>     (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,<br>              (</strong>bridge id)kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize] };</p>
<p>尝试使用不同的 options，有了下面的结果：</p>
<p>①、不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse。</p>
<p>CFDictionaryRef options = (<strong>bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse,<br>                (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue<br>                     // (</strong>bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize]<br>                                                           };</p>
<p>依次为 PNG、JPEG 的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e6496f64c7d6d37c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-06c04d20fbdaf578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13"></p>
<p>结论：如果不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse，那么不管是 PNG 还是 JPEG 格式的图片，都没有进行解码操作。</p>
<p>②、不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue。</p>
<p>CFDictionaryRef options = (<strong>bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse,<br>                (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue<br>                     // (</strong>bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize]<br>                                                           };</p>
<p>依次为 PNG、JPEG 的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9a2b1f43eee1b5d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-95b5fb74031871ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"></p>
<p>结论：如果不设置 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue，那么不管是 PNG 还是 JPEG 格式的图片，都进行了解码操作。</p>
<p>③、设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为kCFBooleanFalse。</p>
<p>CFDictionaryRef options = (<strong>bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse,<br>                (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,<br>                        (</strong>bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize]<br>                                                           };</p>
<p>依次 PNG、JPEG 结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ed03d6b4917d35c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7b199d8d338409d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17"></p>
<p>结论：如果设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanFalse，PNG 和 JPEG 格式的图片，都进行了解码操作。</p>
<p>④、设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为kCFBooleanTure。</p>
<p>CFDictionaryRef options = (<strong>bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse,<br>                (__bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (__bridge id)kCFBooleanTrue,<br>                        (</strong>bridge id) kCGImageSourceThumbnailMaxPixelSize : [NSNumber numberWithFloat:maxPixelSize]<br>                                                           };</p>
<p>依次 PNG、JPEG 结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-8d2fe05dd60d5fa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-19705e320e00f1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="19"></p>
<p>结论：如果设置了 kCGImageSourceThumbnailMaxPixelSize，同时 kCGImageSourceShouldCacheImmediately 设置为 kCFBooleanTrue，那么不管是 PNG 还是 JPEG 格式的图片，也都进行了解码操作。</p>
<p>⑤、总结</p>
<p>在使用 CGImageSourceCreateThumbnailAtIndex 方法时</p>
<p>a. 设置了 kCGImageSourceThumbnailMaxPixelSize，那么肯定会进行解码操作，生成对应的新图 CGImageRef。</p>
<p>b. 不设置 kCGImageSourceThumbnailMaxPixelSize，那么是否进行解码操作，取决于kCGImageSourceShouldCacheImmediately 对应的值是 kCFBooleanTure 还是 kCFBooleanFalse。</p>
<h5 id="四、CGImageSourceCreateImageAtIndex"><a href="#四、CGImageSourceCreateImageAtIndex" class="headerlink" title="四、CGImageSourceCreateImageAtIndex()"></a>四、CGImageSourceCreateImageAtIndex()</h5><p>ImageI/O 中使用 CGImageSourceCreateThumbnailAtIndex 创建缩略图方法的结论就是如上所述。那么这里又有另一个思考，如果是 CGImageSourceCreateImageAtIndex 方法，那么上述的 kCGImageSourceShouldCacheImmediately 键值对会造成什么影响呢？</p>
<p>- (UIImage <em>)resizeWithData:(NSData </em>)data scaleSize:(CGSize)size<br>{<br>    if(!data) {<br>        return nil;<br>    }</p>
<pre><code>// 获取 source 对象
CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);

if(!imageSourceRef) {
    return nil;
}

CGFloat maxPixelSize = MAX(size.width, size.height);

CFDictionaryRef options = (__bridge CFDictionaryRef) @{                       
                   (\_\_bridge id)kCGImageSourceShouldCacheImmediately : (\_\_bridge id)kCFBooleanFalse,                                    
                              (\_\_bridge id)kCGImageSourceShouldCache : (\_\_bridge id)kCFBooleanFalse};

CGImageRef imageRef = CGImageSourceCreateImageAtIndex(imageSourceRef, 0, options);

UIImage * thumbnailImage = \[UIImage imageWithCGImage:imageRef\];

// 释放内存
CFRelease(imageSourceRef);
CGImageRelease(imageRef);

return thumbnailImage;
</code></pre><p>}</p>
<p>①、设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanFalse。</p>
<p>CFDictionaryRef options = (__bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanFalse,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse };</p>
<p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7ff9c0596d1e4cb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20"></p>
<p>CGImageSourceCreateImageAtIndex() 不解码 _PNG。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f3b42c6f1743d014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21"></p>
<p>CGImageSourceCreateImageAtIndex() 不解码 _JPEG。</p>
<p>结论：设置 kCGImageSourceShouldCacheImmediately为 kCFBooleanFalse 时，PNG 和 JPEG 都没有进行解码。</p>
<p>②、设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanTrue。</p>
<p>CFDictionaryRef options = (__bridge CFDictionaryRef) @{<br>                        (__bridge id)kCGImageSourceShouldCacheImmediately : (__bridge id)kCFBooleanTrue,<br>                                   (__bridge id)kCGImageSourceShouldCache : (__bridge id)kCFBooleanFalse };</p>
<p>结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-62d3c1982109d187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22"></p>
<p>CGImageSourceCreateImageAtIndex() 解码 _PNG。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-468a9cd860a693da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="23"></p>
<p>CGImageSourceCreateImageAtIndex() 解码 _JPEG。</p>
<p>结论：设置 kCGImageSourceShouldCacheImmediately 为 kCFBooleanTrue 时，PNG 和 JPEG 都进行了解码。</p>
<p>③总结</p>
<p>在使用 CGImageSourceCreateImageAtIndex 方法创建 CGImageRef 时，kCGImageSourceShouldCacheImmediately 值会影响是否开启解码操作。ImageI/O 默认的 kCGImageSourceShouldCacheImmediately 为 kCFBooleanFalse，也就是说创建图片时候不解码，会等到图片被渲染的时候才进行解码。</p>
<p>以上部分就明确了 CGImageSourceCreateImageAtIndex() 和 CGImageSourceCreateThumbnailAtIndex() 时系统底层具体的实现。</p>
<p>当然，在使用这个 -(UIImage <em>)resizeWithData:(NSData </em>)data scaleSize:(CGSize)size 方法时也采坑了。因为大部分情况下（参考图片缩放使用 UIKIt、Core Graphics、Core Foundation 等情况下的方法)，是为 UIImage 添加一个分类，使用分类方法进行缩放。那么既然如此，为什么不同样使用分类呢？嗯，不错的想法，笔者刚开始是这样做的：</p>
<p>- (UIImage <em>)resizeWithImage:(UIImage </em>)image scaleSize:(CGSize)size<br>{<br>    CFDataRef bitmapData = CGDataProviderCopyData(CGImageGetDataProvider(image.CGImage));</p>
<pre><code>// Create the image source
CGImageSourceRef imageSourceRef = CGImageSourceCreateWithData(bitmapData, NULL);

if(!imageSourceRef) {
    return nil;
}

CGFloat maxPixelSize = MAX(size.width, size.height);

// 缩略图选项
CFDictionaryRef options = (__bridge CFDictionaryRef) @{
                             (\_\_bridge id)kCGImageSourceShouldCache : (\_\_bridge id)kCFBooleanFalse,
          (\_\_bridge id)kCGImageSourceCreateThumbnailFromImageAlways : (\_\_bridge id)kCFBooleanTrue,
                    (__bridge id)kCGImageSourceThumbnailMaxPixelSize: \[NSNumber numberWithFloat:maxPixelSize\] };

// 生成缩略图
CGImageRef imageRef = CGImageSourceCreateThumbnailAtIndex(imageSourceRef, 0, options);

UIImage * thumbnailImage = \[UIImage imageWithCGImage:imageRef\];

// 释放内存
CFRelease(imageSourceRef);
CGImageRelease(imageRef);

return thumbnailImage;
</code></pre><p>}</p>
<p>直接跑起来，结果返回的图片为 nil。</p>
<p>经过详细了解 CGDataProvider 的一系列 API，CGImage 的 dataProvider 指的是 CGImageCreate 时，传入的承载了Bitmap Buffer 数组的一个提供者，可以是一个内存中的 buffer，也可以是一个 callback 来实现惰性解码。也就是说，这个传入的 Bitmap Buffer 数组，必须是未经过解压缩的数据。如果是经过了解压缩的图片数据，那么传给 ImageI/O 是没有意义的。</p>
<p>问题真的出在这里吗？</p>
<p>这两个方法参数不同之处是，一个是使用 UIImage <em> image = [UIImage imageWithContentsOfFile:path]，传入 UIImage 对象，而另一个是通过 NSData </em> data = [NSData dataWithContentsOfFile:path]，传入的 NSData 对象。</p>
<p>这两个方法本质的区别到底是什么呢？为什么造成不同的结局？系统在这两个方法里面具体都干了什么呢？</p>
<p>首先，拿 JPEG 格式的做实验，看看 [UIImage imageWithContentsOfFile:] 都做了什么。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-cdefbbec6eedd2a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="24"></p>
<p>可以看到，在该方法中系统调用了 CGImageSourceCreateImageAtIndex 方法，接着使用了 AppleJPEGPlugin 库的一些方法，但是并没有发现 decode 相关的函数，所以这里应该没有进行解码，而只是将图片进行了解压缩（decompress）。这也就解释了为什么使用 CGImageGetDataProvider 获取的 CGDataProvider 对象是无效的了。</p>
<p>那么同时可以看下 PNG 格式的图片，在使用 [UIImage imageWithContentsOfFile:] 时系统都做了什么。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-85ae7282d8907c29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="25"></p>
<p>PNG 格式的图片，同样是调用 CGImageSourceCreateImageAtIndex 等方法，同时可以看到使用的是 PNGPlugin 库相关的方法，PNGReadPlugin 读取文件数据进行解压缩。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/06/image-i-o/">http://yoursite.com/2019/03/06/image-i-o/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/06/cgimagesource/" class="pre"> CGImageSource		</a><a href="/2019/03/06/e5-9b-be-e7-89-87-e5-8a-a0-e8-bd-bd-e5-92-8c-e5-a4-84-e7-90-86/" class="next"> 图片加载和处理		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、Image-I-O"><span class="toc-text">一、Image I/O</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanTrue"><span class="toc-text">二、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanTrue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、CGImageSourceCreateThumbnailAtIndex-amp-kCGImageSourceShouldCacheImmediately-kCFBooleanFalse"><span class="toc-text">三、CGImageSourceCreateThumbnailAtIndex() &amp; kCGImageSourceShouldCacheImmediately = kCFBooleanFalse</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、CGImageSourceCreateImageAtIndex"><span class="toc-text">四、CGImageSourceCreateImageAtIndex()</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>