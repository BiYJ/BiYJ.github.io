<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> SDWebImageCache、SDImageCacheConfig		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> SDWebImageCache、SDImageCacheConfig		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> SDWebImageCache、SDImageCacheConfig		</h1><div class="post-meta"><a href="/2019/03/14/sdwebimagecache-e3-80-81sdimagecacheconfig/#comments" class="comment-count"></a><p><span class="date">Mar 14, 2019</span><span><a href="/categories/SDWebImage/" class="category">SDWebImage</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://www.cnblogs.com/machao/p/6179638.html" target="_blank" rel="noopener">SDWebImage源码解读之SDWebImageCache(上)</a>、<a href="https://www.cnblogs.com/machao/p/6198140.html" target="_blank" rel="noopener">SDWebImage源码解读之SDWebImageCache(下)</a>、<a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable: 不只是一个能放weak指针的 NSDictionary</a></p>
<p>本篇主要讲解图片缓存类的知识，虽然只涉及了图片方面的缓存的设计，但思想同样适用于别的方面的设计。在架构上来说，缓存算是存储设计的一部分。我们把各种不同的存储内容按照功能进行切割后，图片缓存便是其中的一个。</p>
<p>在封装自己的图片缓存管理对象的时候，SDWebImageCache 能够提供大约 90% 的代码给我们直接使用，基于这些代码，我们需要分析出作者的设计思想是什么。当需要缓存某个列表时，基于 SDWebImageCache 的设计思想，我们就能够设计出比较合理的缓存管理对象了。</p>
<h5 id="一、-h-文件"><a href="#一、-h-文件" class="headerlink" title="一、.h 文件"></a>一、.h 文件</h5><p>只看作者暴露出来的内容，来分析该类有哪些属性和方法，必须明白如何使用这个缓存管理者。</p>
<p>1、缓存位置</p>
<p>typedef NS_ENUM(NSInteger, SDImageCacheType) {<br>    /**<br>     * The image wasn’t available the SDWebImage caches, but was downloaded from the web.<br>     <em>/<br>    SDImageCacheTypeNone,<br>    /\</em>*<br>     * The image was obtained from the disk cache.<br>     *<br>     * 硬盘<br>     <em>/<br>    SDImageCacheTypeDisk,<br>    /\</em>*<br>     * The image was obtained from the memory cache.<br>     *<br>     * 内存<br>     */<br>    SDImageCacheTypeMemory<br>};</p>
<p>2、配置</p>
<p>通过 SDImageCacheConfig 这个类来管理缓存的配置信息，打开 SDImageCacheConfig 后，发现可以配置的东西有：</p>
<p>/**<br> * 基于什么清除磁盘缓存<br> <em>/<br>typedef NS_ENUM(NSUInteger, SDImageCacheConfigExpireType) {<br>    /\</em>*<br>     * When the image is accessed it will update this value 基于图片创建时间<br>     <em>/<br>    SDImageCacheConfigExpireTypeAccessDate,<br>    /\</em>*<br>     * The image was obtained from the disk cache (Default) 基于图片修改时间<br>     */<br>    SDImageCacheConfigExpireTypeModificationDate<br>};</p>
<p>@interface SDImageCacheConfig : NSObject</p>
<p>/**<br> * Decompressing images that are downloaded and cached can improve performance but can consume lot of memory.<br> * Defaults to YES. Set this to NO if you are experiencing a crash due to excessive memory consumption.<br> *<br> * 是否解压缩图片<br> */<br>@property (assign, nonatomic) BOOL shouldDecompressImages;</p>
<p>/**<br> * Whether or not to disable iCloud backup. Defaults to YES.<br> *<br> * 是否禁止 iCloud 备份<br> */<br>@property (assign, nonatomic) BOOL shouldDisableiCloud;</p>
<p>/**<br> * Whether or not to use memory cache. Defaults to YES.<br> * @note When the memory cache is disabled, the weak memory cache will also be disabled.<br> *<br> * 是否缓存一份到内存中<br> */<br>@property (assign, nonatomic) BOOL shouldCacheImagesInMemory;</p>
<p>/**<br> * The option to control weak memory cache for images. When enable, `SDImageCache`‘s memory cache will use a weak maptable to store the image at the same time when it stored to memory, and get removed at the same time.<br> * However when memory warning is triggered, since the weak maptable does not hold a strong reference to image instacnce, even when the memory cache itself is purged, some images which are held strongly by UIImageViews or other live instances can be recovered again, to avoid later re-query from disk cache or network. This may be helpful for the case, for example, when app enter background and memory is purged, cause cell flashing after re-enter foreground.<br> * Defautls to YES. You can change this option dynamically.<br> *<br> * 是否额外存一份弱引用的缓存<br> */<br>@property (assign, nonatomic) BOOL shouldUseWeakMemoryCache;</p>
<p>/**<br> * The reading options while reading cache from disk.<br> * Defaults to 0. You can set this to `NSDataReadingMappedIfSafe` to improve performance.<br> *<br> * 从磁盘读取图片的配置项。默认是 NSDataReadingMappedIfSafe，也就是使用文件映射内存的方式，是不消耗内存的<br> */<br>@property (assign, nonatomic) NSDataReadingOptions diskCacheReadingOptions;</p>
<p>/**<br> * The writing options while writing cache to disk.<br> * Defaults to `NSDataWritingAtomic`. You can set this to `NSDataWritingWithoutOverwriting` to prevent overwriting an existing file.<br> *<br> * 写文件的配置项。默认是 NSDataWritingAtomic，也就是会覆盖原有的文件<br> */<br>@property (assign, nonatomic) NSDataWritingOptions diskCacheWritingOptions;</p>
<p>/**<br> * The maximum length of time to keep an image in the cache, in seconds.<br> *<br> * 图片在磁盘的最大缓存不过期时间，单位为秒，默认是一周<br> */<br>@property (assign, nonatomic) NSInteger maxCacheAge;</p>
<p>/**<br> * The maximum size of the cache, in bytes.<br> *<br> * 最大的缓存尺寸，单位为字节，默认为 0，即没有限制<br> */<br>@property (assign, nonatomic) NSUInteger maxCacheSize;</p>
<p>/**<br> * The attribute which the clear cache will be checked against when clearing the disk cache. Default is Modified Date<br> *<br> * 清除磁盘缓存是基于什么清除，默认是 SDImageCacheConfigExpireTypeModificationDate，即基于图片修改时间<br> */<br>@property (assign, nonatomic) SDImageCacheConfigExpireType diskCacheExpireType;</p>
<p>@end</p>
<p>static const NSInteger kDefaultCacheMaxCacheAge = 60 <em> 60 </em> 24 * 7;  // 1 week</p>
<p>@implementation SDImageCacheConfig</p>
<p>- (instancetype)init {<br>    if (self = [super init]) {<br>        _shouldDecompressImages = YES;<br>        _shouldDisableiCloud = YES;<br>        _shouldCacheImagesInMemory = YES;<br>        _shouldUseWeakMemoryCache = YES;<br>        _diskCacheReadingOptions = 0;<br>        _diskCacheWritingOptions = NSDataWritingAtomic;<br>        _maxCacheAge = kDefaultCacheMaxCacheAge;<br>        _maxCacheSize = 0;<br>        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;<br>    }<br>    return self;<br>}</p>
<p>3、内存最大缓存</p>
<p>/**<br> * The maximum “total cost” of the in-memory image cache. The cost function is the number of pixels held in memory.<br> */<br>@property (assign, nonatomic) NSUInteger maxMemoryCost;</p>
<p>通过 maxMemoryCost 来设置内存的最大缓存是多少，这个是以像素为单位的。</p>
<p>4、最大内存缓存数量</p>
<p>/**<br> * The maximum number of objects the cache should hold.<br> */<br>@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</p>
<p>通过 maxMemoryCountLimit 来设置内存的最大缓存数量是多少。</p>
<p>5、初始化</p>
<p>一般来说，管理类都有一个全局的单例对象，然后根据业务需求设计不同的初始化方法。不管是什么样的类，在设计它的时候，应该通过合理的初始化方法告诉别的开发者，该类应该如何创建。</p>
<p>/**<br> * Returns global shared cache instance<br> */<br>+ (nonnull instancetype)sharedImageCache;</p>
<p>/**<br> * Init a new cache store with a specific namespace<br> *<br> * 通过指定的 namespace 来初始化<br> */<br>- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns;</p>
<p>/**<br> * Init a new cache store with a specific namespace and directory<br> *<br> * 通过指定的 namespace 和图片缓存位置来初始化<br> */<br>- (nonnull instancetype)initWithNamespace:(nonnull NSString <em>)ns<br>                       diskCacheDirectory:(nonnull NSString </em>)directory NS_DESIGNATED_INITIALIZER;</p>
<p>注意：如果想设置某个方法为指定的初始化方法，通过 NS_DESIGNATED_INITIALIZER 来实现。</p>
<p>6、Cache paths</p>
<p>既然把数据缓存到了 disk 中，那么就要提供一个方法获取这个缓存路径。这里通过下边这个方法，根据 namespace 获取缓存路径：</p>
<p>- (nullable NSString <em>)makeDiskCachePath:(nonnull NSString</em>)fullNamespace;</p>
<p>注意：在开发中，我们会遇到这样的情况，假如之前把图片缓存到了地址 1，现在打算重构代码。写了这么一个缓存管理者，我需要和之前缓存的图片建立联系，但是以后都打算使用新写的这个管理者，那怎么办呢？</p>
<p>只需要把之前的路径添加到管理类的路径集合中就行了。主要目的是在搜索图片的时候，也有权限去搜索新添加的路径。</p>
<p>一个好的架构或框架，应该使用这用思想。</p>
<p>这也是下边这个方法的意义：</p>
<p>/**<br> * Add a read-only cache path to search for images pre-cached by SDImageCache Useful if you want to bundle pre-loaded images with your app<br> *<br> * @param path The path to use for this read-only cache path<br> */<br>- (void)addReadOnlyCachePath:(nonnull NSString *)path;</p>
<p>7、存储图片</p>
<p>图片会被存储到内存或者硬盘中，在这一存储过程的设计中有下边这几个需要考虑的因素：</p>
<ul>
<li><p>数据源：可以保存 UIImage 也可以保存 NSData</p>
</li>
<li><p>唯一标识：找到该数据的唯一标识，一般使用图片的 URL</p>
</li>
<li><p>是否需要保存到硬盘：根据配置文件中的设置，如果设置了应该缓存到内存，那么图片肯定会被缓存到内存中。</p>
</li>
<li><p>数据保存这一过程必须是异步的，在完成之后，在主线程回调。</p>
</li>
</ul>
<p>代码如下：</p>
<p>/**<br> * Asynchronously store an image into memory and disk cache at the given key.<br> */<br>- (void)storeImage:(nullable UIImage <em>)image<br>            forKey:(nullable NSString </em>)key<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</p>
<p>/**<br> * Asynchronously store an image into memory and disk cache at the given key.<br> */<br>- (void)storeImage:(nullable UIImage <em>)image<br>            forKey:(nullable NSString </em>)key<br>            toDisk:(BOOL)toDisk<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</p>
<p>/**<br> * Asynchronously store an image into memory and disk cache at the given key.<br> *<br> * @param image           The image to store<br> * @param imageData       The image data as returned by the server, this representation will be used for disk storage<br> *                        instead of converting the given image object into a storable/compressed image format in order<br> *                        to save quality and CPU<br> * @param key             The unique image cache key, usually it’s image absolute URL<br> * @param toDisk          Store the image to disk cache if YES<br> * @param completionBlock A block executed after the operation is finished<br> *<br> * 参数最全的方法。<br> */<br>- (void)storeImage:(nullable UIImage <em>)image<br>         imageData:(nullable NSData </em>)imageData<br>            forKey:(nullable NSString *)key<br>            toDisk:(BOOL)toDisk<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock;</p>
<p>/**<br> * Synchronously store image NSData into disk cache at the given key.<br> */<br>- (void)storeImageDataToDisk:(nullable NSData <em>)imageData forKey:(nullable NSString </em>)key;</p>
<p>8、获取图片</p>
<p>对于如何获取图片。作者给出了比较多的方式，首先考虑内存和硬盘，其次考虑异步获取还是同步获取。如果获取数据异步的，就要使用 block。总结下来有这么几种情况：</p>
<ul>
<li>异步判断图片是否被缓存到 disk</li>
</ul>
<p>/**<br> *  Async check if image exists in disk cache already (does not load the image)<br> *<br> *  @note the completion block will be always executed on the main queue<br> */<br>- (void)diskImageExistsWithKey:(nullable NSString *)key<br>                    completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</p>
<ul>
<li>同步判断 disk 中是否有缓存和返回缓存</li>
</ul>
<p>/**<br> *  Sync check if image data exists in disk cache already (does not load the image)<br> */<br>- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key;</p>
<p>/**<br> *  Query the image data for the given key synchronously. nil if not found.<br> */<br>- (nullable NSData <em>)diskImageDataForKey:(nullable NSString </em>)key;</p>
<ul>
<li>异步查询图片是否存在。这里返回了一个 NSOperation，原因是在内存中获取耗时非常短，在 disk 中时间相对较长。</li>
</ul>
<p>/**<br> * Operation that queries the cache asynchronously and call the completion when done.<br> *<br> * @param doneBlock The completion block. Will not get called if the operation is cancelled<br> *<br> * @return a NSOperation instance containing the cache op.<br> */<br>- (nullable NSOperation <em>)queryCacheOperationForKey:(nullable NSString </em>)key<br>                                               done:(nullable SDCacheQueryCompletedBlock)doneBlock;</p>
<ul>
<li>同步在 memory 查询图片</li>
</ul>
<p>/**<br> * Query the memory cache synchronously. nil if not found.<br> */<br>- (nullable UIImage <em>)imageFromMemoryCacheForKey:(nullable NSString </em>)key;</p>
<ul>
<li>同步在 disk 查询图片</li>
</ul>
<p>/**<br> * Query the disk cache synchronously. nil if not found.<br> */<br>- (nullable UIImage <em>)imageFromDiskCacheForKey:(nullable NSString </em>)key;</p>
<ul>
<li>同步查找图片，先 memory 后 disk</li>
</ul>
<p>/**<br> * Query the cache (memory and or disk) synchronously after checking the memory cache. nil if not found.<br> */<br>- (nullable UIImage <em>)imageFromCacheForKey:(nullable NSString </em>)key;</p>
<p>9、移除某条数据</p>
<p>数据可能存在于内存，也可能是 disk，也可能两者都有，那么要想移除数据，就要考虑这些情况了。</p>
<ul>
<li>全部移除 memory 和 disk（异步）</li>
</ul>
<p>/**<br> * Remove the image from memory and disk cache asynchronously<br> */<br>- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion;</p>
<ul>
<li>移除 memory 数据，可选移除 disk 数据（异步）</li>
</ul>
<p>/**<br> * Remove the image from memory and optionally disk cache asynchronously<br> */<br>- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion;</p>
<p>10、移除数据</p>
<p>这个移除不同于上边的移除，它会清空所有的符合条件的数据。</p>
<ul>
<li>清空 memory</li>
</ul>
<p>/**<br> * Clear all memory cached images<br> */<br>- (void)clearMemory;</p>
<ul>
<li>清空 disk（异步）</li>
</ul>
<p>/**<br> * Async clear all disk cached images. Non-blocking method - returns immediately.<br> */<br>- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion;</p>
<ul>
<li>清空过期数据（异步）</li>
</ul>
<p>/**<br> * Async remove all expired cached image from disk. Non-blocking method - returns immediately.<br> */<br>- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</p>
<p>11、获取缓存相关信息</p>
<ul>
<li>获取 disk 使用 size</li>
</ul>
<p>/**<br> * Get the size used by the disk cache<br> */<br>- (NSUInteger)getSize;</p>
<ul>
<li>获取 disk 缓存的图片数目</li>
</ul>
<p>/**<br> * Get the number of images in the disk cache<br> */<br>- (NSUInteger)getDiskCount;</p>
<ul>
<li>获取 disk 使用 size（异步）</li>
</ul>
<p>/**<br> * Asynchronously calculate the disk cache’s size.<br> */<br>- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock;</p>
<ul>
<li>获取某个路径下的指定的图片。比如 key 为 <a href="http://www.123.com/image.png，path" target="_blank" rel="noopener">http://www.123.com/image.png，path</a> 为 <a href="http://www.456.com，那么方法返回" target="_blank" rel="noopener">http://www.456.com，那么方法返回</a> <a href="http://www.456.com/image.png" target="_blank" rel="noopener">http://www.456.com/image.png</a></li>
</ul>
<p>/**<br> *  Get the cache path for a certain key (needs the cache path root folder)<br> *<br> *  @param key  the key (can be obtained from url using cacheKeyForURL)<br> *  @param path the cache path root folder<br> *<br> *  @return the cache path<br> */<br>- (nullable NSString <em>)cachePathForKey:(nullable NSString </em>)key inPath:(nonnull NSString *)path;</p>
<ul>
<li>获取默认的缓存路径</li>
</ul>
<p>/**<br> *  Get the default cache path for a certain key<br> */<br>- (nullable NSString <em>)defaultCachePathForKey:(nullable NSString </em>)key;</p>
<h5 id="二、NSCache"><a href="#二、NSCache" class="headerlink" title="二、NSCache"></a>二、NSCache</h5><p>对于很多开发者来说，NSCache 是一个陌生人，因为大家往往对 NSMutableDictionary 情有独钟，可怜的 NSCache 一直处于 NSMutableDictionary 的阴影之下。就好像没有人知道它提供了垃圾处理的功能，而开发者们却费劲力气地去自己实现它。</p>
<p>NSCache 基本上就是一个会自动移除对象来释放内存的 NSMutableDictionary。无需响应内存警告或者使用计时器来清除缓存。唯一不同的是键对象不会像 NSMutableDictionary 中那样被复制（键不需要实现 NSCopying 协议），这实际上是它的一个优点。</p>
<p>当有缓存数据到内存的业务的时候，就应该考虑 NSCache 了，有缓存就有清除缓存。</p>
<p>NSCache 每个方法和属性的具体作用，请参考这篇文章<a href="http://www.jianshu.com/p/5e69e211b161" target="_blank" rel="noopener">NSCache</a></p>
<h5 id="三、-m-文件"><a href="#三、-m-文件" class="headerlink" title="三、.m 文件"></a>三、.m 文件</h5><p>不管是图片的缓存还是其他各种不同形式的缓存，在原理上都极其相似，通过 SDWebImageCache 来看看如何实现缓存功能。</p>
<p>#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</p>
<p>#define UNLOCK(lock) dispatch_semaphore_signal(lock);</p>
<p>用信号量来实现锁的功能。</p>
<p>1、SDMemoryCache</p>
<p>/**<br> * A memory cache which auto purge the cache on memory warning and support weak cache.<br> *<br> * 内存缓存，在内存出现警告时自动清除缓存并支持弱缓存。<br> */<br>@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt;</p>
<p>@end</p>
<p>@interface SDMemoryCache &lt;KeyType, ObjectType&gt; ()</p>
<p>// 缓存配置<br>@property (nonatomic, strong, nonnull) SDImageCacheConfig *config;</p>
<p>// strong-weak cache 弱引用缓存<br>@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache;</p>
<p>// a lock to keep the access to `weakCache` thread-safe 用于线程安全的锁，实际为信号量<br>@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; </p>
<p>- (instancetype)init NS_UNAVAILABLE;<br>- (instancetype)initWithConfig:(nonnull SDImageCacheConfig *)config;</p>
<p>@end</p>
<p>NSCache 在收到内存警告的时候会释放自身的一部分资源，设计 SDMemoryCache 的目的是在收到警告时，释放缓存的所有资源。</p>
<p>#if SD_UIKIT</p>
<p>- (void)dealloc {<br>    [[NSNotificationCenter defaultCenter] removeObserver:self<br>                                                    name:UIApplicationDidReceiveMemoryWarningNotification<br>                                                  object:nil];<br>}</p>
<p>- (instancetype)initWithConfig:(SDImageCacheConfig *)config<br>{<br>    self = [super init];<br>    if (self) {<br>        // Use a strong-weak maptable storing the secondary cache. Follow the doc that NSCache does not copy keys<br>        // This is useful when the memory warning, the cache was purged. However, the image instance can be retained by other instance such as imageViews and alive.<br>        // At this case, we can sync weak cache back and do not need to load from disk cache</p>
<pre><code>    // 使用强弱映射表存储次要的缓存。按照文档说明，NSCache 不会复制 Key
    // 当内存警告清除缓存时，这很有用。但是，image 对象还能被其他实例（如 UIImageView 对象）持有
    self.weakCache = \[\[NSMapTable alloc\] initWithKeyOptions:NSPointerFunctionsStrongMemory 
                                               valueOptions:NSPointerFunctionsWeakMemory
                                                   capacity:0\];
    self.weakCacheLock = dispatch\_semaphore\_create(1);
    self.config = config;
    \[\[NSNotificationCenter defaultCenter\] addObserver:self
                                             selector:@selector(didReceiveMemoryWarning:)
                                                 name:UIApplicationDidReceiveMemoryWarningNotification
                                               object:nil\];
}
return self;
</code></pre><p>}</p>
<p>析构函数和初始化方法，监听内存警告通知，重点学习 weakCache 的创建。在 iOS 和 osTV 平台使用。</p>
<p>// `setObject:forKey:` just call this with 0 cost. Override this is enough<br>- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)g {<br>    [super setObject:obj forKey:key cost:g];</p>
<pre><code>// 不需要弱引用缓存
if (!self.config.shouldUseWeakMemoryCache) {
    return;
}

// key - value 同时存在
if (key &amp;&amp; obj) {
    // Store weak cache
    LOCK(self.weakCacheLock);
    // Do the real copy of the key and only let NSMapTable manage the key&apos;s lifetime
    // Fixes issue #2507 https://github.com/SDWebImage/SDWebImage/issues/2507
    \[self.weakCache setObject:obj forKey:\[\[key mutableCopy\] copy\]\];
    UNLOCK(self.weakCacheLock);
}
</code></pre><p>}</p>
<p>- (id)objectForKey:(id)key {<br>    id obj = [super objectForKey:key];</p>
<pre><code>// 不需要弱引用缓存
if (!self.config.shouldUseWeakMemoryCache) {
    return obj;
}

// 如果 key 存在 &amp; obj 不存在
if (key &amp;&amp; !obj) {
    // Check weak cache
    LOCK(self.weakCacheLock);
    obj = \[self.weakCache objectForKey:key\];
    UNLOCK(self.weakCacheLock);
    if (obj) {
        // Sync cache
        NSUInteger cost = 0;
        if (\[obj isKindOfClass:\[UIImage class\]\]) {
            cost = \[(UIImage *)obj sd_memoryCost\];
        }
        // 重新将 obj 存入 NSCache
        \[super setObject:obj forKey:key cost:cost\];
    }
}
return obj;
</code></pre><p>}</p>
<p>- (void)removeObjectForKey:(id)key {<br>    [super removeObjectForKey:key];</p>
<pre><code>// 不需要弱引用缓存
if (!self.config.shouldUseWeakMemoryCache) {
    return;
}
if (key) {
    // Remove weak cache
    LOCK(self.weakCacheLock);
    \[self.weakCache removeObjectForKey:key\];
    UNLOCK(self.weakCacheLock);
}
</code></pre><p>}</p>
<p>- (void)removeAllObjects {<br>    [super removeAllObjects];<br>    if (!self.config.shouldUseWeakMemoryCache) {<br>        return;<br>    }<br>    // Manually remove should also remove weak cache<br>    LOCK(self.weakCacheLock);<br>    [self.weakCache removeAllObjects];<br>    UNLOCK(self.weakCacheLock);<br>}</p>
<p>重写 NSCache 的方法，每个方法都先调用 super 方法删除 self 的内容，然后再根据逻辑判断选择是否需要对 weakCache 进行操作。</p>
<p>注意：[[key mutableCopy] copy] 是为了确切的深复制数据。</p>
<p>@interface SDImageCache ()</p>
<p>@property (strong, nonatomic, nonnull) SDMemoryCache <em>memCache;  // 内存容器<br>@property (strong, nonatomic, nonnull) NSString </em>diskCachePath;  // 硬盘缓存路径</p>
<p>// 自定义的读取路径。是一个数组，可以通过 addReadOnlyCachePath: 这个方法往里边添加路径。当读取图片的时候，这个数组的路径也会作为数据源<br>@property (strong, nonatomic, nullable) NSMutableArray<nsstring *> *customPaths;</nsstring></p>
<p>// 输入输出队列。队列往往可以当做一种”锁“来使用，把某些任务按照顺序一步一步的执行，必须考虑线程是否安全<br>@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;<br>@property (strong, nonatomic, nonnull) NSFileManager *fileManager; // 文件管理者</p>
<p>@end</p>
<p>私有属性。</p>
<p>2、Singleton、init、dealloc</p>
<p>重点讲解最后一个初始化方法：</p>
<p>- (nonnull instancetype)initWithNamespace:(nonnull NSString <em>)ns<br>                       diskCacheDirectory:(nonnull NSString </em>)directory<br>{<br>    if ((self = [super init])) {<br>        NSString *fullNamespace = [@”com.hackemist.SDWebImageCache.” stringByAppendingString:ns];</p>
<pre><code>// Create IO serial queue 串行队列
\_ioQueue = dispatch\_queue\_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH\_QUEUE_SERIAL);

_config = \[\[SDImageCacheConfig alloc\] init\];

// Init the memory cache
\_memCache = \[\[SDMemoryCache alloc\] initWithConfig:\_config\];
_memCache.name = fullNamespace;

// Init the disk cache
if (directory != nil) {
    _diskCachePath = \[directory stringByAppendingPathComponent:fullNamespace\];
} 
else {
    // 获取 directories 文件夹，拼接路径
    NSString *path = \[self makeDiskCachePath:ns\];
    _diskCachePath = path;
}

dispatch\_sync(\_ioQueue, ^{
    self.fileManager = \[NSFileManager new\];
});
</code></pre><p>#if SD_UIKIT<br>        // Subscribe to app events<br>        [[NSNotificationCenter defaultCenter] addObserver:self<br>                                                 selector:@selector(deleteOldFiles)<br>                                                     name:UIApplicationWillTerminateNotification<br>                                                   object:nil];</p>
<pre><code>\[\[NSNotificationCenter defaultCenter\] addObserver:self
                                         selector:@selector(backgroundDeleteOldFiles)
                                             name:UIApplicationDidEnterBackgroundNotification
                                           object:nil\];
</code></pre><p>#endif<br>    }</p>
<pre><code>return self;
</code></pre><p>}</p>
<p>这个方法做了两件事：①、初始化自身的属性；②、添加通知监听。</p>
<p>3、Cache paths</p>
<ul>
<li>添加自定义路径</li>
</ul>
<p>- (void)addReadOnlyCachePath:(nonnull NSString *)path {<br>    if (!self.customPaths) {<br>        self.customPaths = [NSMutableArray new];<br>    }</p>
<pre><code>if (!\[self.customPaths containsObject:path\]) {
    \[self.customPaths addObject:path\];
}
</code></pre><p>}</p>
<ul>
<li>文件名（MD5）</li>
</ul>
<p>/**<br> * 对 key 值做 MD5 算法处理<br> */<br>- (nullable NSString <em>)cachedFileNameForKey:(nullable NSString </em>)key {<br>    const char <em>str = key.UTF8String;<br>    if (str == NULL) {<br>        str = “”;<br>    }<br>    unsigned char r[CC_MD5_DIGEST_LENGTH];<br>    CC_MD5(str, (CC_LONG)strlen(str), r);<br>    NSURL </em>keyURL = [NSURL URLWithString:key];<br>    NSString <em>ext = keyURL ? keyURL.pathExtension : key.pathExtension;<br>    // File system has file name length limit, we need to check if ext is too long, we don’t add it to the filename<br>    if (ext.length &gt; SD_MAX_FILE_EXTENSION_LENGTH) {<br>        ext = nil;<br>    }<br>    NSString </em>filename = [NSString stringWithFormat:@”%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@”,<br>                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],<br>                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @”” : [NSString stringWithFormat:@”.%@”, ext]];<br>    return filename;<br>}</p>
<ul>
<li>默认的某个图片的路径</li>
</ul>
<p>- (nullable NSString <em>)defaultCachePathForKey:(nullable NSString </em>)key {<br>    return [self cachePathForKey:key inPath:self.diskCachePath];<br>}</p>
<ul>
<li>根据名称和路径拼接路径</li>
</ul>
<p>- (nullable NSString <em>)cachePathForKey:(nullable NSString </em>)key inPath:(nonnull NSString <em>)path {<br>    NSString </em>filename = [self cachedFileNameForKey:key];<br>    return [path stringByAppendingPathComponent:filename];<br>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7de2bd595a9eff62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p>
<p>4、Store Image</p>
<ul>
<li>参数最多的保存图片的方法</li>
</ul>
<p>- (void)storeImage:(nullable UIImage <em>)image<br>            forKey:(nullable NSString </em>)key<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock {<br>    [self storeImage:image imageData:nil forKey:key toDisk:YES completion:completionBlock];<br>}</p>
<p>- (void)storeImage:(nullable UIImage <em>)image<br>            forKey:(nullable NSString </em>)key<br>            toDisk:(BOOL)toDisk<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock {<br>    [self storeImage:image imageData:nil forKey:key toDisk:toDisk completion:completionBlock];<br>}</p>
<p>- (void)storeImage:(nullable UIImage <em>)image<br>         imageData:(nullable NSData </em>)imageData<br>            forKey:(nullable NSString *)key<br>            toDisk:(BOOL)toDisk<br>        completion:(nullable SDWebImageNoParamsBlock)completionBlock {</p>
<pre><code>// 检查 image 和 key 是否为 nil
if (!image || !key) {
    if (completionBlock) {
        completionBlock();
    }
    return;
}
// if memory cache is enabled
// 根据配置文件中是否设置了缓存到内存，保存 image 到缓存中。这个过程是非常快的，因此不用考虑线程
if (self.config.shouldCacheImagesInMemory) {
    NSUInteger cost = image.sd_memoryCost;
    \[self.memCache setObject:image forKey:key cost:cost\];
}

// 保存到 disk
if (toDisk) {
    // 异步串行
    dispatch_async(self.ioQueue, ^{
        @autoreleasepool {
            NSData *data = imageData;
            if (!data &amp;&amp; image) {
                // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format 如果我们没有检测图像格式的数据，请检查它是否包含使用PNG或JPEG格式的alpha通道。
                SDImageFormat format;

                // 检查图片是否有透明通道
                if (SDCGImageRefContainsAlpha(image.CGImage)) {
                    format = SDImageFormatPNG;
                } 
                else {
                    format = SDImageFormatJPEG;
                }
                // 通过 SDWebImageCodersManager 解析成二进制数据
                data = \[\[SDWebImageCodersManager sharedInstance\] encodedDataWithImage:image format:format\];
            }
            // 存储到 disk 方法
            \[self _storeImageDataToDisk:data forKey:key\];
        }

        if (completionBlock) {
            dispatch\_async(dispatch\_get\_main\_queue(), ^{
                completionBlock();
            });
        }
    });
} 
else {
    if (completionBlock) {
        completionBlock();
    }
}
</code></pre><p>}</p>
<ul>
<li>保存数据到 disk</li>
</ul>
<p>- (void)storeImageDataToDisk:(nullable NSData <em>)imageData forKey:(nullable NSString </em>)key {</p>
<pre><code>if (!imageData || !key) {
    return;
}
dispatch_sync(self.ioQueue, ^{
    \[self _storeImageDataToDisk:imageData forKey:key\];
});
</code></pre><p>}</p>
<p>// Make sure to call form io queue by caller<br>- (void)_storeImageDataToDisk:(nullable NSData <em>)imageData forKey:(nullable NSString </em>)key {</p>
<pre><code>// 检查 imageData 或者 key 是否为 nil
if (!imageData || !key) {
    return;
}

// 创建 disk 缓存文件夹
if (!\[self.fileManager fileExistsAtPath:_diskCachePath\]) {
    \[self.fileManager createDirectoryAtPath:_diskCachePath 
                withIntermediateDirectories:YES 
                                 attributes:nil
                                      error:NULL\];
}

// get cache Path for image key
// 根据 key 获取默认的缓存路径
NSString *cachePathForKey = \[self defaultCachePathForKey:key\];
// transform to NSUrl 转成 NSURL
NSURL *fileURL = \[NSURL fileURLWithPath:cachePathForKey\];

// 写入数据
\[imageData writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil\];

// disable iCloud backup
// 根据配置文件设置是否禁用 iCloud 的备份功能
if (self.config.shouldDisableiCloud) {
    \[fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil\];
}
</code></pre><p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-1782ab68d397b77e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p>
<p>5、Query and Retrieve</p>
<ul>
<li>根据 key 判断 disk 中的数据是否存在</li>
</ul>
<p>- (void)diskImageExistsWithKey:(nullable NSString *)key<br>                    completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock<br>{<br>    // 异步串行<br>    dispatch_async(self.ioQueue, ^{<br>        BOOL exists = [self _diskImageDataExistsWithKey:key];<br>        if (completionBlock) {<br>            dispatch_async(dispatch_get_main_queue(), ^{<br>                completionBlock(exists);<br>            });<br>        }<br>    });<br>}</p>
<p>- (BOOL)diskImageDataExistsWithKey:(nullable NSString *)key<br>{<br>    if (!key) {<br>        return NO;<br>    }<br>    __block BOOL exists = NO;</p>
<pre><code>// 异步串行
dispatch_sync(self.ioQueue, ^{
    exists = \[self _diskImageDataExistsWithKey:key\];
});

return exists;
</code></pre><p>}</p>
<p>/**<br> * Make sure to call form io queue by caller. 确保在 io 队列中执行<br> */<br>- (BOOL)_diskImageDataExistsWithKey:(nullable NSString *)key<br>{<br>    if (!key) {<br>        return NO;<br>    }<br>    BOOL exists = [self.fileManager fileExistsAtPath:[self defaultCachePathForKey:key]];</p>
<pre><code>// fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name
// checking the key with and without the extension

if (!exists) {
   // 去除扩展名再次检查
   exists = \[self.fileManager fileExistsAtPath:\[self defaultCachePathForKey:key\].stringByDeletingPathExtension\];
}

return exists;
</code></pre><p>}</p>
<ul>
<li>获取 memory 中的数据</li>
</ul>
<p>- (nullable UIImage <em>)imageFromMemoryCacheForKey:(nullable NSString </em>)key {<br>    return [self.memCache objectForKey:key];<br>}</p>
<ul>
<li>获取 disk 中的数据</li>
</ul>
<p>在 disk 中获取数据跟在内存中获取不一样，内存中直接保存的是 UIImage，而 disk 中保存的是 NSData，因此肯定需要一个NSData -&gt; UIImage 的转换过程。接下来我们看看这个转换过程：</p>
<p>①、根据 key 获取 disk 中的 NSData 数据。总体思路就是先从默认的路径获取，如果没有获取到，再从自定义的路径获取，值得注意的是，要考虑没有 pathExtention 的情况。</p>
<p>- (nullable NSData <em>)diskImageDataBySearchingAllPathsForKey:(nullable NSString </em>)key<br>{<br>    // 先从默认的路径获取<br>    NSString <em>defaultPath = [self defaultCachePathForKey:key];<br>    NSData </em>data = [NSData dataWithContentsOfFile:defaultPath<br>                                          options:self.config.diskCacheReadingOptions<br>                                            error:nil];<br>    if (data) {<br>        return data;<br>    }</p>
<pre><code>// fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name
// checking the key with and without the extension

// 去掉扩展名的影响
data = \[NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension 
                              options:self.config.diskCacheReadingOptions
                                error:nil\];
if (data) {
    return data;
}

NSArray&lt;NSString *&gt; *customPaths = \[self.customPaths copy\];

// 从自定义的路径获取
for (NSString *path in customPaths) {
    NSString *filePath = \[self cachePathForKey:key inPath:path\];
    NSData *imageData = \[NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil\];
    if (imageData) {
        return imageData;
    }

    // fallback because of https://github.com/SDWebImage/SDWebImage/pull/976 that added the extension to the disk file name
    // checking the key with and without the extension

    // 去掉扩展名的影响
    imageData = \[NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension 
                                       options:self.config.diskCacheReadingOptions
                                         error:nil\];
    if (imageData) {
        return imageData;
    }
}

return nil;
</code></pre><p>}</p>
<p>②、根据 NSData 获取 UIImage，需要 scaled 图片，根据配置文件的设置，是否解压图片。</p>
<p>- (nullable UIImage <em>)diskImageForKey:(nullable NSString </em>)key<br>{<br>    NSData *data = [self diskImageDataForKey:key];<br>    return [self diskImageForKey:key data:data];<br>}</p>
<p>/**<br> * 1、对 key 做判断<br> * 2、加入 io 队列执行<br> */<br>- (nullable NSData <em>)diskImageDataForKey:(nullable NSString </em>)key {<br>    if (!key) {<br>        return nil;<br>    }<br>    __block NSData *imageData = nil;<br>    dispatch_sync(self.ioQueue, ^{<br>        imageData = [self diskImageDataBySearchingAllPathsForKey:key];<br>    });</p>
<pre><code>return imageData;
</code></pre><p>}</p>
<p>- (nullable UIImage <em>)diskImageForKey:(nullable NSString </em>)key data:(nullable NSData *)data {<br>    return [self diskImageForKey:key data:data options:0];<br>}</p>
<p>/**<br> * 关键方法：NSData -&gt; UIImage<br> */<br>- (nullable UIImage <em>)diskImageForKey:(nullable NSString </em>)key data:(nullable NSData <em>)data options:(SDImageCacheOptions)options<br>{<br>    if (data) {<br>        // 获取 UIImage<br>        UIImage </em>image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];<br>        image = [self scaledImageForKey:key image:image];</p>
<pre><code>    // 解压
    if (self.config.shouldDecompressImages) {
        BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;
        image = \[\[SDWebImageCodersManager sharedInstance\] decompressedImageWithImage:image 
                                                                                data:&amp;data 
                                        options:@{SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)}\];
    }
    return image;
} else {
    return nil;
}
</code></pre><p>}</p>
<p>/**<br> * 调用 SDWebImageCompat 类的缩放方法<br> */<br>- (nullable UIImage <em>)scaledImageForKey:(nullable NSString </em>)key image:(nullable UIImage *)image {<br>    return SDScaledImageForKey(key, image);<br>}</p>
<p>③、将 UIImage 放入内存，返回图片</p>
<p>- (nullable UIImage <em>)imageFromDiskCacheForKey:(nullable NSString </em>)key<br>{<br>    UIImage *diskImage = [self diskImageForKey:key];<br>    if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) {<br>        NSUInteger cost = diskImage.sd_memoryCost;<br>        [self.memCache setObject:diskImage forKey:key cost:cost];<br>    }</p>
<pre><code>return diskImage;
</code></pre><p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-df695b4c5074a3da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"></p>
<p>4、先获取内存的数据，如果没有，再获取 disk 的数据</p>
<p>- (nullable UIImage <em>)imageFromCacheForKey:(nullable NSString </em>)key<br>{<br>    // First check the in-memory cache…<br>    UIImage *image = [self imageFromMemoryCacheForKey:key];<br>    if (image) {<br>        return image;<br>    }</p>
<pre><code>// Second check the disk cache...
image = \[self imageFromDiskCacheForKey:key\];
return image;
</code></pre><p>}</p>
<p>5、异步获取数据</p>
<p>上边 1、2、3、4 中获取数据的方法都不是异步获取的，在 SDWebImageCache 中涉及到异步获取的，都会通过 Block 来回调。</p>
<p>这个异步获取值得说的有两点：</p>
<ul>
<li><p>如果在内存中获取到的图片是 GIF，那么要去 disk 中获取</p>
</li>
<li><p>返回一个 NSOperation 对象，我们可以通过这个 NSOperation 对象取消获取任务。</p>
</li>
</ul>
<p>代码：</p>
<p>- (NSOperation <em>)queryCacheOperationForKey:(NSString </em>)key done:(SDCacheQueryCompletedBlock)doneBlock {<br>    return [self queryCacheOperationForKey:key options:0 done:doneBlock];<br>}</p>
<p>- (nullable NSOperation <em>)queryCacheOperationForKey:(nullable NSString </em>)key options:(SDImageCacheOptions)options done:(nullable SDCacheQueryCompletedBlock)doneBlock<br>{<br>    // key 为空，直接回调和返回<br>    if (!key) {<br>        if (doneBlock) {<br>            doneBlock(nil, nil, SDImageCacheTypeNone);<br>        }<br>        return nil;<br>    }</p>
<pre><code>// First check the in-memory cache...
UIImage *image = \[self imageFromMemoryCacheForKey:key\];
BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));

// 只在内存中查找缓存
if (shouldQueryMemoryOnly) {
    if (doneBlock) {
        doneBlock(image, nil, SDImageCacheTypeMemory);
    }
    return nil;
}

NSOperation *operation = \[NSOperation new\];
void(^queryDiskBlock)(void) =  ^{
    if (operation.isCancelled) {
        // do not call the completion if cancelled
        return;
    }

    @autoreleasepool {
        NSData *diskData = \[self diskImageDataBySearchingAllPathsForKey:key\];
        UIImage *diskImage;
        SDImageCacheType cacheType = SDImageCacheTypeNone;
        if (image) {
            // the image is from in-memory cache
            // 缓存中存在
            diskImage = image;
            cacheType = SDImageCacheTypeMemory;
        } 
        else if (diskData) {
            cacheType = SDImageCacheTypeDisk;
            // decode image data only if in-memory cache missed
            // 从 disk 获得数据时，都要写入内存
            diskImage = \[self diskImageForKey:key data:diskData options:options\];
            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) {
                NSUInteger cost = diskImage.sd_memoryCost;
                \[self.memCache setObject:diskImage forKey:key cost:cost\];
            }
        }

        if (doneBlock) {
            if (options &amp; SDImageCacheQueryDiskSync) {
                doneBlock(diskImage, diskData, cacheType);
            } else {
                dispatch\_async(dispatch\_get\_main\_queue(), ^{
                    doneBlock(diskImage, diskData, cacheType);
                });
            }
        }
    }
};

if (options &amp; SDImageCacheQueryDiskSync) {
    queryDiskBlock();
} 
else {
    dispatch_async(self.ioQueue, queryDiskBlock);
}

return operation;
</code></pre><p>}</p>
<p>6、Remove</p>
<p>- (void)removeImageForKey:(nullable NSString *)key withCompletion:(nullable SDWebImageNoParamsBlock)completion<br>{<br>    [self removeImageForKey:key fromDisk:YES withCompletion:completion];<br>}</p>
<p>- (void)removeImageForKey:(nullable NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(nullable SDWebImageNoParamsBlock)completion<br>{<br>    if (key == nil) {<br>        return;<br>    }</p>
<pre><code>// 从内存中删除
if (self.config.shouldCacheImagesInMemory) {
    \[self.memCache removeObjectForKey:key\];
}
// 从硬盘中删除
if (fromDisk) {
    dispatch_async(self.ioQueue, ^{
        \[self.fileManager removeItemAtPath:\[self defaultCachePathForKey:key\] error:nil\];

        if (completion) {
            dispatch\_async(dispatch\_get\_main\_queue(), ^{
                completion();
            });
        }
    });
}
// 不删除，直接回调
else if (completion){
    completion();
}
</code></pre><p>}</p>
<p>7、Mem Cache settings</p>
<p>- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost {<br>    self.memCache.totalCostLimit = maxMemoryCost;<br>}</p>
<p>- (NSUInteger)maxMemoryCost {<br>    return self.memCache.totalCostLimit;<br>}</p>
<p>- (NSUInteger)maxMemoryCountLimit {<br>    return self.memCache.countLimit;<br>}</p>
<p>- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit {<br>    self.memCache.countLimit = maxCountLimit;<br>}</p>
<p>设置/获取缓存对象的属性。</p>
<p>8、Cache clean</p>
<p>清空数据有值得我们注意的地方，一个一个方法的看：</p>
<ul>
<li>清空内存缓存数据</li>
</ul>
<p>- (void)clearMemory {<br>    [self.memCache removeAllObjects];<br>}</p>
<ul>
<li>清空 disk 数据</li>
</ul>
<p>- (void)clearDiskOnCompletion:(nullable SDWebImageNoParamsBlock)completion<br>{<br>    // 异步串行<br>    dispatch_async(self.ioQueue, ^{<br>        [self.fileManager removeItemAtPath:self.diskCachePath error:nil];<br>        [self.fileManager createDirectoryAtPath:self.diskCachePath<br>                    withIntermediateDirectories:YES<br>                                     attributes:nil<br>                                          error:NULL];</p>
<pre><code>    if (completion) {
        dispatch\_async(dispatch\_get\_main\_queue(), ^{
            completion();
        });
    }
});
</code></pre><p>}</p>
<ul>
<li>清空旧数据</li>
</ul>
<p>对于清空旧数据而言，我们需要考虑两个方面：</p>
<p>①、首先要清空掉所有的过期的数据；</p>
<p>②、过期的数据清空后，缓存的数据比我们设置的最大缓存量还大，我们要继续清空数据，直到满足我们的需求为止。</p>
<p>这里边大概用到的思路就是上边说的两点，关键是如何实现上边所说的内容。有一些我们平时可能不太接触的知识点，在这里做一些简要的讲解。</p>
<p>首先我们需要遍历 Disk 缓存路径下的所有文件，那么怎么遍历呢？NSFileManager 有一个很好地方法：</p>
<p>/* enumeratorAtURL:includingPropertiesForKeys:options:errorHandler: returns an NSDirectoryEnumerator rooted at the provided directory URL. The NSDirectoryEnumerator returns NSURLs from the -nextObject method. The optional ‘includingPropertiesForKeys’ parameter indicates which resource properties should be pre-fetched and cached with each enumerated URL. The optional ‘errorHandler’ block argument is invoked when an error occurs. Parameters to the block are the URL on which an error occurred and the error. When the error handler returns YES, enumeration continues if possible. Enumeration stops immediately when the error handler returns NO.</p>
<pre><code>If you wish to only receive the URLs and no other attributes, then pass &apos;0&apos; for &apos;options&apos; and an empty NSArray (&apos;\[NSArray array\]&apos;) for &apos;keys&apos;. If you wish to have the property caches of the vended URLs pre-populated with a default set of attributes, then pass &apos;0&apos; for &apos;options&apos; and &apos;nil&apos; for &apos;keys&apos;.
</code></pre><p> */</p>
<p>/**<br> * @param  url  需要遍历的路径<br> * @param  keys 传入一个数组，表示想获取的 NSURLResourceKeys。<br> *<br> *                 NSURLIsDirectoryKey              是否是文件夹<br> *                 NSURLContentModificationDateKey  最后修改时间<br> *                 NSURLTotalFileAllocatedSizeKey   分配的尺寸<br> *<br> * @param  mask 传入过滤参数，NSDirectoryEnumerationSkipsHiddenFiles 忽略隐藏文件<br> *<br> * @return 返回一个 NSDirectoryEnumerator<nsurl *> <em> 这个对象中存放的是 NSURLs<br> \</em>/<br>- (nullable NSDirectoryEnumerator<nsurl *> <em>)enumeratorAtURL:(NSURL </em>)url includingPropertiesForKeys:(nullable NSArray<nsurlresourcekey> <em>)keys options:(NSDirectoryEnumerationOptions)mask errorHandler:(nullable BOOL (^)(NSURL \</em>url, NSError *error))handler API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0));</nsurlresourcekey></nsurl></nsurl></p>
<p>有了这些参数，再判断最后修改日期是否过期，删除掉过期的数据就行了。还有一个值得注意的是如何对一个字典进行排序：</p>
<p>NSArray<nsurl *> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent<br>                                                         usingComparator:^NSComparisonResult(id obj1, id obj2) {</nsurl></p>
<pre><code>     return \[obj1\[cacheContentDateKey\] compare:obj2\[cacheContentDateKey\]\];
}\];
</code></pre><p>这个会返回排好序的字典的所有的 key。NSSortConcurrent 是并发排序，效率高，但可能不稳定，NSSortStable 稳定，但可能效率不如 NSSortConcurrent 高。排序的规则通过 Block 指定。</p>
<p>基本要注意的就这些。这个函数的实现也是基于这种思路。</p>
<p>- (void)deleteOldFiles {<br>    [self deleteOldFilesWithCompletionBlock:nil];<br>}</p>
<p>- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock {<br>    dispatch_async(self.ioQueue, ^{<br>        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</p>
<pre><code>    // Compute content date key to be used for tests
    NSURLResourceKey cacheContentDateKey = NSURLContentModificationDateKey;
    switch (self.config.diskCacheExpireType) {
        case SDImageCacheConfigExpireTypeAccessDate:
            cacheContentDateKey = NSURLContentAccessDateKey;
            break;

        case SDImageCacheConfigExpireTypeModificationDate:
            cacheContentDateKey = NSURLContentModificationDateKey;
            break;

        default:
            break;
    }

    NSArray&lt;NSString *&gt; *resourceKeys = @\[NSURLIsDirectoryKey, cacheContentDateKey, NSURLTotalFileAllocatedSizeKey\];

    // This enumerator prefetches useful properties for our cache files.
    NSDirectoryEnumerator *fileEnumerator = \[self.fileManager enumeratorAtURL:diskCacheURL
                                               includingPropertiesForKeys:resourceKeys
                                                                  options:NSDirectoryEnumerationSkipsHiddenFiles
                                                             errorHandler:NULL\];

    NSDate *expirationDate = \[NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge\];
    NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = \[NSMutableDictionary dictionary\];
    NSUInteger currentCacheSize = 0;

    // Enumerate all of the files in the cache directory.  This loop has two purposes:
    //
    //  1\. Removing files that are older than the expiration date.
    //  2\. Storing file attributes for the size-based cleanup pass.
    NSMutableArray&lt;NSURL *&gt; *urlsToDelete = \[\[NSMutableArray alloc\] init\];
    for (NSURL *fileURL in fileEnumerator) {
        NSError *error;
        NSDictionary&lt;NSString *, id&gt; *resourceValues = \[fileURL resourceValuesForKeys:resourceKeys error:&amp;error\];

        // Skip directories and errors.
        if (error || !resourceValues || \[resourceValues\[NSURLIsDirectoryKey\] boolValue\]) {
            continue;
        }

        // Remove files that are older than the expiration date;
        NSDate *modifiedDate = resourceValues\[cacheContentDateKey\];
        if (\[\[modifiedDate laterDate:expirationDate\] isEqualToDate:expirationDate\]) {
            \[urlsToDelete addObject:fileURL\];
            continue;
        }

        // Store a reference to this file and account for its total size.
        NSNumber *totalAllocatedSize = resourceValues\[NSURLTotalFileAllocatedSizeKey\];
        currentCacheSize += totalAllocatedSize.unsignedIntegerValue;
        cacheFiles\[fileURL\] = resourceValues;
    }

    for (NSURL *fileURL in urlsToDelete) {
        \[self.fileManager removeItemAtURL:fileURL error:nil\];
    }

    // If our remaining disk cache exceeds a configured maximum size, perform a second
    // size-based cleanup pass.  We delete the oldest files first.
    if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) {
        // Target half of our maximum cache size for this cleanup pass.
        const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;

        // Sort the remaining cache files by their last modification time or last access time (oldest first).
        NSArray&lt;NSURL *&gt; *sortedFiles = \[cacheFiles keysSortedByValueWithOptions:NSSortConcurrent
                                                                 usingComparator:^NSComparisonResult(id obj1, id obj2) {
                                                                     return \[obj1\[cacheContentDateKey\] compare:obj2\[cacheContentDateKey\]\];
                                                                 }\];

        // Delete files until we fall below our desired cache size.
        for (NSURL *fileURL in sortedFiles) {
            if (\[self.fileManager removeItemAtURL:fileURL error:nil\]) {
                NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles\[fileURL\];
                NSNumber *totalAllocatedSize = resourceValues\[NSURLTotalFileAllocatedSizeKey\];
                currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;

                if (currentCacheSize &lt; desiredCacheSize) {
                    break;
                }
            }
        }
    }
    if (completionBlock) {
        dispatch\_async(dispatch\_get\_main\_queue(), ^{
            completionBlock();
        });
    }
});
</code></pre><p>}</p>
<ul>
<li>申请一段时间在后台删除旧数据</li>
</ul>
<p>#if SD_UIKIT<br>- (void)backgroundDeleteOldFiles<br>{<br>    Class UIApplicationClass = NSClassFromString(@”UIApplication”);<br>    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) {<br>        return;<br>    }<br>    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</p>
<pre><code>// 删除回调，停止后台任务
__block UIBackgroundTaskIdentifier bgTask = \[application beginBackgroundTaskWithExpirationHandler:^{
    // Clean up any unfinished task business by marking where you
    // stopped or ending the task outright.
    \[application endBackgroundTask:bgTask\];
    bgTask = UIBackgroundTaskInvalid;
}\];

// Start the long-running task and return immediately.
// 开始删除数据
\[self deleteOldFilesWithCompletionBlock:^{
    \[application endBackgroundTask:bgTask\];
    bgTask = UIBackgroundTaskInvalid;
}\];
</code></pre><p>}</p>
<p>#endif</p>
<p>9、Cache Info</p>
<p>/**<br> * 获取 diskCachePath 路径下的硬盘缓存大小<br> */<br>- (NSUInteger)getSize<br>{<br>    __block NSUInteger size = 0;<br>    dispatch_sync(self.ioQueue, ^{<br>        NSDirectoryEnumerator <em>fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];<br>        for (NSString </em>fileName in fileEnumerator) {<br>            NSString <em>filePath = [self.diskCachePath stringByAppendingPathComponent:fileName];<br>            NSDictionary&lt;NSString </em>, id&gt; *attrs = [self.fileManager attributesOfItemAtPath:filePath error:nil];<br>            // 累加文件大小<br>            size += [attrs fileSize];<br>        }<br>    });<br>    return size;<br>}</p>
<p>/**<br> * 硬盘缓存数量<br> */<br>- (NSUInteger)getDiskCount<br>{<br>    __block NSUInteger count = 0;<br>    dispatch_sync(self.ioQueue, ^{<br>        NSDirectoryEnumerator *fileEnumerator = [self.fileManager enumeratorAtPath:self.diskCachePath];<br>        count = fileEnumerator.allObjects.count;<br>    });<br>    return count;<br>}</p>
<p>/**<br> * 获取 diskCacheURL 路径下的硬盘缓存大小<br> */<br>- (void)calculateSizeWithCompletionBlock:(nullable SDWebImageCalculateSizeBlock)completionBlock<br>{<br>    NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</p>
<pre><code>dispatch_async(self.ioQueue, ^{
    NSUInteger fileCount = 0;
    NSUInteger totalSize = 0;

    NSDirectoryEnumerator *fileEnumerator = \[self.fileManager enumeratorAtURL:diskCacheURL
                                               includingPropertiesForKeys:@\[NSFileSize\]
                                                                  options:NSDirectoryEnumerationSkipsHiddenFiles
                                                             errorHandler:NULL\];

    for (NSURL *fileURL in fileEnumerator) {
        NSNumber *fileSize;
        \[fileURL getResourceValue:&amp;fileSize forKey:NSURLFileSizeKey error:NULL\];
        totalSize += fileSize.unsignedIntegerValue;
        fileCount += 1;
    }

    if (completionBlock) {
        dispatch\_async(dispatch\_get\_main\_queue(), ^{
            completionBlock(fileCount, totalSize);
        });
    }
});
</code></pre><p>}</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/14/sdwebimagecache-e3-80-81sdimagecacheconfig/">http://yoursite.com/2019/03/14/sdwebimagecache-e3-80-81sdimagecacheconfig/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/14/sdwebimagedownloaderoperation/" class="pre"> SDWebImageDownloaderOperation		</a><a href="/2019/03/14/uiimageforcedecode/" class="next"> UIImage+ForceDecode、SDWebImageCodersManager		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、-h-文件"><span class="toc-text">一、.h 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、NSCache"><span class="toc-text">二、NSCache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、-m-文件"><span class="toc-text">三、.m 文件</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>