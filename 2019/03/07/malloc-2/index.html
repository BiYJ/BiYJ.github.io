<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> malloc		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> malloc		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> malloc		</h1><div class="post-meta"><a href="/2019/03/07/malloc-2/#comments" class="comment-count"></a><p><span class="date">Mar 07, 2019</span><span><a href="/categories/C/" class="category">C</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="http://www.cnblogs.com/Commence/p/5785912.html" target="_blank" rel="noopener">malloc 函数详解</a></p>
<p>使用 malloc 要加头文件，malloc 是分配一块连续的内存，和 free 函数是一起用的。但是一部分人还是将 malloc 当作系统所提供的或者是 C 的关键字，事实上 malloc 只是 C 标准库中提供的一个普通函数。</p>
<p>而且很多人都对 malloc 的具体实现机制不是很了解。</p>
<h5 id="一、关于-malloc-以及相关的几个函数"><a href="#一、关于-malloc-以及相关的几个函数" class="headerlink" title="一、关于 malloc 以及相关的几个函数"></a>一、关于 malloc 以及相关的几个函数</h5><p>// Linux</p>
<p>#include &lt;stdlib.h&gt;       </p>
<p>void <em>malloc(size_t size);<br>void free(void </em>ptr);<br>void <em>calloc(size_t nmemb, size_t size);<br>void \</em>realloc(void *ptr, size_t size);</p>
<p>也可以这样认为（window 下）原型：extern void *malloc(unsigned int num_bytes);</p>
<p>导入头文件 #include &lt;malloc.h&gt; 或者 #include &lt;alloc.h&gt; 两者的内容是完全一样的。</p>
<p>如果分配成功，则返回指向被分配内存空间的指针；不然，返回空指针 NULL。同时，当内存不再使用的时候，应使用 free() 函数将内存块释放掉。</p>
<p>关于：void <em> 表示未确定类型的指针。C、C++ 规定，void </em> 类型可以强转为任何其他类型的的指针。</p>
<blockquote>
<p>malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small.</p>
</blockquote>
<p>关于 void * 的其他说法：</p>
<p>void <em> p1;<br>int </em>p2;</p>
<p>p1 = p2;  // 其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。</p>
<p>malloc：</p>
<p>①、malloc 分配的内存大小至少为 size 参数所指定的字节数；</p>
<p>②、malloc 的返回值是一个指针，指向一段可用内存的起始地址；</p>
<p>③、多次调用 malloc 所分配的地址不能有重叠部分，除非某次 malloc 所分配的地址被释放掉</p>
<p>④、malloc 应该尽快完成内存分配并返回（不能使用 NP-hard 的内存分配算法）</p>
<p>⑤、实现 malloc 时应同时实现内存大小调整和内存释放函数（realloc 和 free）</p>
<p>malloc 和 free 函数是配对的，如果申请后不释放就是内存泄露；如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以释放多少次都是可以的。</p>
<h5 id="二、malloc-和-new"><a href="#二、malloc-和-new" class="headerlink" title="二、malloc 和 new"></a>二、malloc 和 new</h5><p>new 返回指定类型的指针，并且可以自动计算所需要的大小。</p>
<p>int <em>p;<br>p = new int;      // 返回类型为 int </em> 类型，分配的大小为 sizeof(int)<br>p = new int[100]; // 返回类型为 int <em> 类型，分配的大小为 sizeof(int) </em> 100</p>
<p>而 malloc 则必须由我们计算字节数，并且在返回的时候强转成实际指定类型的指针。</p>
<p>int *p = (int *)malloc(sizeof(int));</p>
<p>①、malloc 的返回是 void <em>，如果写成了 p = malloc(sizeof(int)); 间接的说明了将 void </em> 转成 int *，这不合理</p>
<p>②、malloc 的实参是 sizeof(int)，用于指明一个整形数据需要的大小，如果我们写成：</p>
<p>int <em> p = (int </em>)malloc(1);</p>
<p>可以看出，只是申请了一个字节的空间，如果向里面存放了一个整数的话，将会占用额外的 3 个字节，可能会改变原有内存空间中的数据。</p>
<p>③、malloc 只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般习惯性的将其初始化为NULL。当然，也可以用 memset 函数的。</p>
<p>简单的说：</p>
<p>malloc 函数其实就是在内存中找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看 malloc 函数中参数 size 的具体内容。我们这里 malloc 分配的内存空间在逻辑上是连续的，而在物理上可以不连续。程序员关注的是逻辑上的连续，其它的，操作系统会帮着我们处理的。</p>
<p>下面看看 malloc 的具体实现机制。</p>
<h5 id="三、Linux-内存管理"><a href="#三、Linux-内存管理" class="headerlink" title="三、Linux 内存管理"></a>三、Linux 内存管理</h5><p>1、虚拟内存地址与物理内存地址</p>
<p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时， 都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片 2N 字节的内存，其中 N 是机器位数。例如在 64 位 CPU 和 64 位操作系统下，每个进程的虚拟地址空间为 264Byte。</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫 <a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="noopener">MMU</a>（Memory Management Unit）的硬件完成。</p>
<p>2、页与地址构成</p>
<p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到 Linux 中，典型的内存页大小为 4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以 64 位机器，4G 物理内存，4K 页大小为例，虚拟内存地址和物理内存地址的组成如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-d0ebc2240cf4fd5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="åå­å°åææ"></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是 4K，所以页内偏移都是用低 12 位表示，而剩下的高地址表示页号。</p>
<p>MMU 映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如 <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener">TLB</a> 等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-14e83fb742b79f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="åå­å°åç¿»è¯"></p>
<p>3、内存页与磁盘页</p>
<p>一般将内存看做磁盘的的缓存，有时 MMU 在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对 malloc 实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p>
<p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">图片来源页</a>）。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ecfd464e35f49828.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="è¾ä¸ºå®æ´çå°åç¿»è¯æµç¨"></p>
<h5 id="四、Linux-进程级内存管理"><a href="#四、Linux-进程级内存管理" class="headerlink" title="四、Linux 进程级内存管理"></a>四、Linux 进程级内存管理</h5><p>1、内存排布</p>
<p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以 Linux 64 位系统为例。理论上，64bit 内存地址可用空间为 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux 实际上只用了其中一小部分（256T）。</p>
<p>根据 <a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">Linux 内核相关文档</a>描述，Linux 64 位操作系统仅使用低 47 位，高 17 位做扩展（只能是全 0 或全 1）。所以，实际用到的地址为空间为 0x0000000000000000 ~ 0x00007FFFFFFFFFFF 和 0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-4ea74e7031362a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linuxè¿ç¨å°åæå¸"></p>
<p>对用户来说，主要关注的空间是 User Space。将 User Space 放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）；</li>
<li>Data：这里存放的是初始化过的全局变量；</li>
<li>BSS：这里存放的是未初始化的全局变量；</li>
<li>Heap：堆。堆自低地址向高地址增长，后面要讲到的 brk 相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与 mmap 系统调用相关的区域。大多数实际的 malloc 实现会考虑通过 mmap 分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：栈。自高地址向低地址增长。</li>
</ul>
<p>下面我们主要关注 Heap 区域的操作。</p>
<p>2、Heap 内存模型</p>
<p>一般来说，malloc 所申请的内存主要从 Heap 区域分配（本文不考虑通过 mmap 申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址后，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux 对堆的管理示意如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-6fcdf6a785c8d135.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linuxè¿ç¨å ç®¡ç"></p>
<p>Linux 维护一个 break 指针，这个指针指向堆空间的某个地址。从堆起始地址到 break 之间的地址空间为映射好的，可以供进程访问；而从 break 往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<p>3、brk 与 sbrk</p>
<p>由上文知道，要增加一个进程实际的可用堆大小，就需要将 break 指针向高地址移动。Linux 通过 brk 和 sbrk 系统调用操作 break 指针。两个系统调用的原型如下：</p>
<p>int brk(void <em>addr);<br>void </em>sbrk(intptr_t increment);</p>
<p>brk 将 break 指针直接设置为某个地址，而 sbrk 将 break 从当前位置移动 increment 所指定的增量。brk 在执行成功时返回0，否则返回 -1 并设置 errno 为 ENOMEM；sbrk 成功时返回 break 移动之前所指向的地址，否则返回 (void *)-1。</p>
<p>小技巧：如果将 increment 设置为 0，则可以获得当前 break 的地址。</p>
<p>另外需要注意的是，由于 Linux 是按页进行内存映射的，所以如果 break 被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比 break 指向的地方要大一些。但是使用 break 之后的地址是很危险的（尽管也许 break 之后确实有 一小块可用内存地址）。</p>
<p>4、资源限制与 rlimit</p>
<p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个 rlimit 表示当前进程可用的资源上限。这个限制可以通过 getrlimit 系统调用得到，下面代码获取当前进程虚拟内存空间的 rlimit：</p>
<p>int main() {<br>      struct rlimit <em> limit = (struct rlimit </em>)malloc(sizeof(struct rlimit));<br>      getrlimit(RLIMIT_AS, limit);</p>
<pre><code>printf(&quot;soft limit: %ld, hard limit: %ld\\n&quot;, limit-&gt;rlim\_cur, limit-&gt;rlim\_max);
</code></pre><p>}</p>
<p>其中 rlimit 是一个结构体：</p>
<p>struct rlimit {<br>     rlim_t rlim_cur; /<em> Soft limit </em>/<br>     rlim_t rlim_max; /<em> Hard limit (ceiling for rlim_cur) </em>/<br>};</p>
<p>每种资源有软限制和硬限制，并且可以通过 setrlimit 对 rlimit 进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h5 id="五、实现-malloc"><a href="#五、实现-malloc" class="headerlink" title="五、实现 malloc"></a>五、实现 malloc</h5><p>1、玩具实现</p>
<p>在正式开始讨论 malloc 的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具 malloc，权当对上面知识的复习：</p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;</p>
<p>void <em>malloc(size_t size)<br>{<br>     void </em>p = sbrk(0);</p>
<pre><code>if (sbrk(size) == (void *)-1)
     return NULL;
return p;
</code></pre><p>}</p>
<p>这个 malloc 每次都在当前 break 的基础上增加 size 所指定的字节数，并将之前 break 的地址返回。这个 malloc 由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<p>2、正式实现</p>
<p>下面讨论 malloc 的实现方案。</p>
<p>2.1 数据结构</p>
<p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由 meta 区和数据区组成，meta 区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为 malloc 返回的地址。</p>
<p>可以用如下结构体定义一个 block：</p>
<p>typedef struct s_block *t_block;</p>
<p>struct s_block {<br>     size_t size;    /<em> 数据区大小 </em>/<br>     t_block next;   /<em> 指向下个块的指针 </em>/<br>     int free;       /<em> 是否是空闲块 </em>/<br>     int padding;    /<em> 填充4字节，保证meta块长度为8的倍数 </em>/<br>     char data[1];   /<em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入 meta </em>/<br>};</p>
<p>由于只考虑 64 位机器，为了方便，在结构体最后填充一个 int，使得结构体本身的长度为 8 的倍数，以便内存对齐。示意图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-70d03529d489d3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Blockç»æ"></p>
<p>关于长度为 1 的数组注意：<a href="http://bbs.csdn.net/topics/300077699" target="_blank" rel="noopener">http://bbs.csdn.net/topics/300077699</a></p>
<p>2.2 寻找合适的 block</p>
<p>现在考虑如何在 block 链中查找合适的 block。一般来说有两种查找算法：</p>
<ul>
<li>First fit：从头开始，使用第一个数据区大小大于要求 size 的块所谓此次分配的块；</li>
<li>Best fit：从头开始，遍历所有块，使用数据区大小大于 size 且差值最小的块作为此次分配的块。</li>
</ul>
<p>两种方法各有千秋，best fit 具有较高的内存使用率（payload 较高），而 first fit 具有更好的运行效率。这里我们采用 first fit 算法。</p>
<p>/* First fit <em>/<br>t_block find_block(t_block </em>last, size_t size) {</p>
<pre><code>t\_block b = first\_block;

while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {
      *last = b;
      b = b-&gt;next;
}
return b;
</code></pre><p>}</p>
<p>find_block 从 frist_block 开始，查找第一个符合要求的 block 并返回 block 起始地址，如果找不到这返回 NULL。这里在遍历时会更新一个叫 last 的指针，这个指针始终指向当前遍历的 block。这是为了如果找不到合适的 block 而开辟新  block 使用的，具体会在接下来的一节用到。</p>
<p>2.3 开辟新的 block</p>
<p>如果现有 block 都不能满足 size 的要求，则需要在链表最后开辟一个新的 block。这里关键是如何只使用 sbrk 创建一个 struct：</p>
<p>#define BLOCK_SIZE 24 /<em> 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 </em>/</p>
<p>t_block extend_heap(t_block last, size_t s) {</p>
<pre><code>t_block b;
b = sbrk(0);

if(sbrk(BLOCK_SIZE + s) == (void *)-1)
      return NULL;

b-&gt;size = s;
b-&gt;next = NULL;

if(last)
      last-&gt;next = b;

b-&gt;free = 0;

return b;
</code></pre><p>}</p>
<p>2.4 分裂 block</p>
<p>First fit 有一个比较致命的缺点，就是可能会让很小的 size 占据很大的一块 block，此时，为了提高 payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的 block，示意如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-10569c31d0c967bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="åè£block"></p>
<p>实现代码：</p>
<p>void split_block(t_block b, size_t s) {</p>
<pre><code>t_block new;
new = b-&gt;data + s;
new-&gt;size = b-&gt;size - s - BLOCK_SIZE ;
new-&gt;next = b-&gt;next;
new-&gt;free = 1;

b-&gt;size = s;
b-&gt;next = new;
</code></pre><p>}</p>
<p>2.5 malloc 的实现</p>
<p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的 malloc。注意首先要定义个 block 链表的头 first_block，初始化为 NULL；另外，我们需要剩余空间至少有 BLOCK_SIZE + 8 才执行分裂操作。</p>
<p>由于我们希望 malloc 分配的数据区是按 8 字节对齐，所以在 size 不为 8 的倍数时，需要将 size 调整为大于 size 的最小的 8 的倍数：</p>
<p>size_t align8(size_t s) {</p>
<pre><code>if(s &amp; 0x7 == 0)
      return s;

return ((s &gt;&gt; 3) + 1) &lt;&lt; 3;
</code></pre><p>}</p>
<p>#define BLOCK_SIZE 24</p>
<p>void *first_block = NULL;</p>
<p>/* other functions… */</p>
<p>void *malloc(size_t size) {</p>
<pre><code> t_block b, last;
 size_t s;

 /\* 对齐地址 */
 s = align8(size);

 if(first_block) {
      /\* 查找合适的block */
      last = first_block;
      b = find_block(&amp;last, s);

      if(b) {
            /\* 如果可以，则分裂 */
            if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8))
                  split_block(b, s);

            b-&gt;free = 0;
      }
      else {
            /\* 没有合适的block，开辟一个新的 */
            b = extend_heap(last, s);

            if(!b)
                  return NULL;
      }
}
else {
      b = extend_heap(NULL, s);

      if(!b)
            return NULL;

      first_block = b;
}

return b-&gt;data;
</code></pre><p>}</p>
<p>2.6 calloc 的实现</p>
<p>有了 malloc，实现 calloc 只要两步：</p>
<p>①、malloc 一段内存</p>
<p>②、将数据区内容置为 0</p>
<p>由于我们的数据区是按 8 字节对齐的，所以为了提高效率，我们可以每 8 字节一组置 0，而不是一个一个字节设置。我们可以通过新建一个 size_t 指针，将内存区域强制看做 size_t 类型来实现。</p>
<p>void *calloc(size_t number, size_t size) {</p>
<pre><code>size_t *new;
size_t s8, i;

new = malloc(number * size);

if(new) {
       s8 = align8(number * size) &gt;&gt; 3;

       for(i = 0; i &lt; s8; i++)
             new\[i\] = 0;
}

return new;
</code></pre><p>}</p>
<p>2.7 free 的实现</p>
<p>free 的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<p> ①、如何验证所传入的地址是有效地址，即确实是通过 malloc 方式分配的数据区首地址</p>
<p> ②、如何解决碎片问题</p>
<p>首先我们要保证传入 free 的地址是有效的，这个有效包括两方面：</p>
<p>①、地址应该在之前 malloc 所分配的区域内，即在 first_block 和当前 break 指针范围内</p>
<p>②、这个地址确实是之前通过我们自己的 malloc 分配的</p>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个 magic number 字段，free 之前通过相对偏移检查特定位置的值是否为我们设置的 magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时 free 时传入的地址），我们在 free 前检查 magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加 magic pointer（同时要修改 BLOCK_SIZE）：</p>
<p>typedef struct s_block *t_block;</p>
<p>struct s_block {<br>      size_t size;     /<em> 数据区大小 </em>/<br>      t_block next;    /<em> 指向下个块的指针 </em>/<br>      int free;        /<em> 是否是空闲块 </em>/<br>      int padding;     /<em> 填充 4 字节，保证 meta 块长度为 8 的倍数 </em>/<br>      void *ptr;       /* Magic pointer，指向 data <em>/<br>      char data[1]     /</em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */<br>};</p>
<p>然后我们定义检查地址合法性的函数：</p>
<p>t_block get_block(void *p) {</p>
<pre><code>char *tmp;
tmp = p;

return (p = tmp -= BLOCK_SIZE);
</code></pre><p>}</p>
<p>int valid_addr(void *p) {</p>
<pre><code>if(first_block) {
      if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) {
            return p == (get_block(p))-&gt;ptr;
      }
}

return 0;
</code></pre><p>}</p>
<p>当多次 malloc 和 free 后，整个内存池可能会产生很多碎片 block，这些 block 很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此 malloc 要求，但是由于分割成了多个小 block 而无法 fit，这就是碎片问题。</p>
<p>一个简单的解决方式时当 free 某个 block 时，如果发现它相邻的 block 也是 free 的，则将 block 和相邻 block 合并。为了满足这个实现，需要将 s_block 改为双向链表。修改后的 block 结构如下：</p>
<p>typedef struct s_block *t_block;</p>
<p>struct s_block {<br>      size_t size;    /<em> 数据区大小 </em>/<br>      t_block prev;   /<em> 指向上个块的指针 </em>/<br>      t_block next;   /<em> 指向下个块的指针 </em>/<br>      int free;       /<em> 是否是空闲块 </em>/<br>      int padding;    /<em> 填充4字节，保证meta块长度为8的倍数 </em>/<br>      void *ptr;      /* Magic pointer，指向data <em>/<br>      char data[1]    /</em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */<br>};</p>
<p>合并方法如下：</p>
<p>t_block fusion(t_block b) {</p>
<pre><code>if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) {
      b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;
      b-&gt;next = b-&gt;next-&gt;next;

      if(b-&gt;next)
            b-&gt;next-&gt;prev = b;
}

return b;
</code></pre><p>}</p>
<p>有了上述方法，free 的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此 block 的 free 标为 1，并且在可以的情况下与后面的 block 进行合并。如果当前是最后一个 block，则回退 break 指针释放进程内存，如果当前 block 是最后一个 block，则回退 break 指针并设置 first_block 为 NULL。实现如下：</p>
<p>void free(void *p) {</p>
<pre><code>t_block b;

if(valid_addr(p)) {
     b = get_block(p);
     b-&gt;free = 1;

     if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)
          b = fusion(b-&gt;prev);

     if(b-&gt;next) {
          fusion(b);
     } 
     else {
          if(b-&gt;prev)
                b-&gt;prev-&gt;prev = NULL;
          else
                first_block = NULL;

          brk(b);
     }
}
</code></pre><p>}</p>
<p>2.8 realloc 的实现</p>
<p>为了实现 realloc，首先要实现一个内存复制方法。如同 calloc 一样，为了效率，我们以 8 字节为单位进行复制：</p>
<p>void copy_block(t_block src, t_block dst) {</p>
<pre><code>size_t \*sdata, \*ddata;
size_t i;
sdata = src-&gt;ptr;
ddata = dst-&gt;ptr;

for(i = 0; (i * 8) &lt; src-&gt;size &amp;&amp; (i * 8) &lt; dst-&gt;size; i++)
     ddata\[i\] = sdata\[i\];
</code></pre><p>}</p>
<p>然后我们开始实现 realloc。一个简单（但是低效）的方法是 malloc 一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前 block 的数据区大于等于 realloc 所要求的 size，则不做任何操作</li>
<li>如果新的 size 变小了，考虑 split</li>
<li>如果当前 block 的数据区不能满足 size，但是其后继 block 是 free 的，并且合并后可以满足，则考虑做合并。</li>
</ul>
<p>下面是 realloc 的实现：</p>
<p>void *realloc(void *p, size_t size) {</p>
<pre><code>size_t s;
t_block b, new;
void *newp;

if (!p)
     /\* 根据标准库文档，当p传入NULL时，相当于调用malloc */
     return malloc(size);

if(valid_addr(p)) {
     s = align8(size);
     b = get_block(p);

     if(b-&gt;size &gt;= s) {
          if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))
               split_block(b,s);
     }
     else {
          /\* 看是否可进行合并 */
          if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) {
               fusion(b);

               if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))
                    split_block(b, s);
          }
          else {
               /\* 新malloc */
               newp = malloc (s);

               if (!newp)
                    return NULL;

               new = get_block(newp);
               copy_block(b, new);
               free(p);
               return(newp);
          }
     }
     return (p);
}
return NULL;
</code></pre><p>}</p>
<h5 id="六、遗留问题和优化"><a href="#六、遗留问题和优化" class="headerlink" title="六、遗留问题和优化"></a>六、遗留问题和优化</h5><p>以上是一个较为简陋，但是初步可用的 malloc 实现。还有很多遗留的可能优化点，例如：</p>
<ul>
<li>同时兼容 32 位和 64 位系统</li>
<li>在分配较大快内存时，考虑使用 mmap 而非 sbrk，这通常更高效</li>
<li>可以考虑维护多个链表而非单个，每个链表中的 block 大小均为一个范围内，例如 8 字节链表、16 字节链表、24-32 字节链表等等。此时可以根据 size 到对应链表中做分配，可以有效减少碎片，并提高查询 block 的速度。</li>
<li>可以考虑链表中只存放 free 的 block，而不存放已分配的 block，可以减少查找 block 的次数，提高效率。</li>
</ul>
<h5 id="七、其它参考"><a href="#七、其它参考" class="headerlink" title="七、其它参考"></a>七、其它参考</h5><p><a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf" target="_blank" rel="noopener">A malloc Tutorial</a></p>
<p><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective, 2/E</a></p>
<p><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a></p>
<p><a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/" target="_blank" rel="noopener">How the Kernel Manages Your Memory</a></p>
<p><a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c" target="_blank" rel="noopener">glibc 的实现</a></p>
<p><a href="http://www.wikipedia.org/" target="_blank" rel="noopener">维基百科</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/07/malloc-2/">http://yoursite.com/2019/03/07/malloc-2/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/08/https/" class="pre"> HTTPS		</a><a href="/2019/03/06/tcp/" class="next"> TCP		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、关于-malloc-以及相关的几个函数"><span class="toc-text">一、关于 malloc 以及相关的几个函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、malloc-和-new"><span class="toc-text">二、malloc 和 new</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、Linux-内存管理"><span class="toc-text">三、Linux 内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、Linux-进程级内存管理"><span class="toc-text">四、Linux 进程级内存管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、实现-malloc"><span class="toc-text">五、实现 malloc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、遗留问题和优化"><span class="toc-text">六、遗留问题和优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、其它参考"><span class="toc-text">七、其它参考</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>