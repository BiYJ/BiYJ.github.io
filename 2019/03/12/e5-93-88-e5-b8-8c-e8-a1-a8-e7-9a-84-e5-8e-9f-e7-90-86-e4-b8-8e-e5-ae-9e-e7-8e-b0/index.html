<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> 哈希表的原理与实现		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> 哈希表的原理与实现		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> 哈希表的原理与实现		</h1><div class="post-meta"><a href="/2019/03/12/e5-93-88-e5-b8-8c-e8-a1-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/#comments" class="comment-count"></a><p><span class="date">Mar 12, 2019</span><span><a href="/categories/数据结构/" class="category">数据结构</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://www.cnblogs.com/zhzhang/p/3740489.html" target="_blank" rel="noopener">哈希表的原理与实现</a>、<a href="https://www.cnblogs.com/lpfuture/p/5796398.html" target="_blank" rel="noopener">一致性哈希算法原理</a>、<a href="https://www.cnblogs.com/goody9807/p/4279324.html" target="_blank" rel="noopener">五分钟理解一致性哈希算法(consistent hashing)</a></p>
<h5 id="一、哈希表的原理与实现"><a href="#一、哈希表的原理与实现" class="headerlink" title="一、哈希表的原理与实现"></a>一、哈希表的原理与实现</h5><p>哈希表（Hash Table）的应用近两年才在 NOI 中出现，作为一种高效的数据结构，它正在竞赛中发挥着越来越重要的作用。 </p>
<p>哈希表又叫做散列表，分为“开散列” 和“闭散列”。考虑到竞赛时多数人通常避免使用动态存储结构，本文中的“哈希表”仅指“闭散列”，关于其他方面读者可参阅其他书籍。</p>
<p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 </p>
<p>一列键值对数据，存储在一个 table 中，如何通过数据的关键字快速查找相应值呢？ </p>
<p>在所有的线性数据结构中，数组的定位速度最快，因为它可以通过下标直接定位到相应的数组空间，不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。 </p>
<p>哈希表的做法其实很简单，就是把 Key 通过一个固定的算法函数，即哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将 value 存储在以该数字为下标的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将 key 转换为对应的数组下标，并定位到该空间获取 value。如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>
<p>存储步骤：</p>
<p>①、把字符串 key 通过哈希函数生成一个整形数字；</p>
<p>②、将该数字对数组长度进行取余，取余结果作为数组下标；</p>
<p>③、将 value 存储在数组对应下标的空间里。</p>
<p>查询步骤：</p>
<p>①、使用哈希函数将 key 转换成对应的数组下标；</p>
<p>②、利用下标定位数组对应的空间，获取 value。</p>
<p>哈希表的原理其实就是通过空间换取时间的做法。</p>
<p>哈希函数对 key 进行转换，取余的值是唯一的吗？</p>
<p>这个当然不能保证，主要是由于 hashcode 会对数组长度进行取余，因此其结果由于数组长度的限制必然会出现重复，所以就会有“冲突”这一问题，至于解决冲突的办法其实有很多种，比如重复散列的方式，大概就是定位的空间已经存在 value 且 key 不同的话就重新进行哈希加一并求模数组元素个数，即 (h(k)+i) mod S, i = 1,2,3…，直到找到空间为止。 </p>
<p>Hash 表这种数据结构在 java 中是原生的一个集合对象，在实际中用途极广，主要有这么几个特点：</p>
<ol>
<li><p>访问速度快</p>
</li>
<li><p>大小不受限制</p>
</li>
<li><p>按键进行索引，没有重复对象</p>
</li>
<li><p>用字符串（id:string）检索对象（object）</p>
</li>
</ol>
<p>下面是一个 hash 表的实现。先看看头文件，也就是数据结构的定义，相当于 java 中的接口的概念：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#define   HASHSIZE 256</p>
<p>// 定义 hash 表中的节点的类型<br>struct nlist {<br>    struct nlist <em>next;<br>    char </em> name;<br>    char * defn;<br>};</p>
<p>// 定义接口中的函数，也就是对外来说，这个程序可以做什么</p>
<p>unsigned hash(char <em>s);  // 计算一个串的 hash 值<br>struct nlist \</em>lookup(char *s);  // 根据 key 查找一个 value<br>struct nlist *install(char *name, char *defn);  // 插入一个 key = value 的对象</p>
<p>然后是具体实现：</p>
<p>#include &lt;string.h&gt;</p>
<p>static struct nlist *hashtab[HASHSIZE];</p>
<p>unsigned hash(char *s)   // 取得 hash 值<br>{<br>    unsigned hashval;</p>
<pre><code>for(hashval = 0; *s != &apos;\\0&apos;; s++)
    hashval = \*s + 31 \* hashval;
    return hashval % HASHSIZE;
</code></pre><p>}</p>
<p>struct nlist *lookup(char *s)<br>{<br>    struct nlist *np;</p>
<pre><code>for(np = hashtab\[hash(s)\]; np != NULL; np = np-&gt;next)
    if(strcmp(s,np-&gt;name) == 0)
        return np;
return NULL;
</code></pre><p>}</p>
<p>struct nlist *install(char *name,char <em>defn)<br>{<br>    struct nlist </em>np;<br>    unsigned hashval;</p>
<pre><code>if((np = lookup(name)) == NULL){
    np = (struct nlist *)malloc(sizeof(struct nlist));

    if(np == NULL || (np-&gt;name = strdup(name)) == NULL)
        return NULL;
    hashval = hash(name);
    np-&gt;next= hashtab\[hashval\];
    hashtab\[hashval\] = np;
}
else
    free((void *)np-&gt;defn);

if((np-&gt;defn = strdup(defn)) == NULL)
    return NULL;

return np;
</code></pre><p>}</p>
<p>很简单，只有两个外部接口，</p>
<ol>
<li><p>install(key, value) 用来插入一个新的节点</p>
</li>
<li><p>lookup(key) 根据一个键来进行搜索，并返回节点</p>
</li>
</ol>
<p>代码很简单，主要用到的 hash 算法跟 java 中的 String 的 hashcode() 方法中用到的算法一样，使用：</p>
<p>unsigned hash(char *s)<br>{<br>    unsigned hashval;</p>
<pre><code>for(hashval = 0; *s != &apos;\\0&apos;;s++)
    hashval = \*s + 31 \* hashval;

return hashval % HASHSIZE;
</code></pre><p>}</p>
<p>这里的 31 并非随意，乃是一个经验值，选取它的目的在于减少冲突，当然，hash 冲突这个问题是不能根本避免的。这里只是一个人们在测试中发现的可以相对减少 hash 冲突的一个数字，可能以后会发现更好的数值来。</p>
<h5 id="二、一致性-hash-算法"><a href="#二、一致性-hash-算法" class="headerlink" title="二、一致性 hash 算法"></a>二、一致性 hash 算法</h5><p>一致性 hash 算法早在 1997 年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，在论文 <a href="http://portal.acm.org/citation.cfm?id=258660" target="_blank" rel="noopener">Consistent hashing and random trees</a> 中被提出，设计目标是为了解决因特网中的热点（Hot spot）问题，初衷和 CARP 十分类似。一致性哈希修正了 CARP 使用的简单哈希算法带来的问题，使得分布式哈希（DHT）可以在 P2P 环境中真正得到应用。目前在 cache 系统中应用越来越广泛。</p>
<p>1、基本场景</p>
<p>假设有 N 个 cache 服务器（后简称 cache），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache：</p>
<p>hash(object) % N</p>
<p>一切都运行正常，再考虑如下的两种情况：</p>
<p>①、cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1)；</p>
<p>②、由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1)；</p>
<p>这两种情况意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；</p>
<p>再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。有什么方法可以改变这个状况呢，这就是 consistent hashing 一致性 hash 算法。</p>
<p>2、判定哈希算法好坏的四个定义</p>
<p>①、平衡性（Balance）：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p>
<p>②、单调性（Monotonicity）：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p>
<p>③、分散性（Spread）：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p>
<p>④、负载（Load）：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p>
<p>容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。</p>
<p>3、consistent hashing 算法的原理</p>
<p>consistent hashing 是一种 hash 算法，简单的说，在移除/添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p>
<p>下面就按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p>
<p>①、环形 hash 空间</p>
<p>考虑通常的 hash 算法都是将 value 映射到一个 32 位的 key 值，也即是 0~232-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 232-1 ）相接的圆环，如下图所示的那样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f3463c9d24d5357d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>②、把对象映射到 hash 空间</p>
<p>接下来考虑 4 个对象 object1~object4，通过特定的 hash 函数计算出对应的 key 值，然后散列到 hash 环上，分布如下图。</p>
<p>hash(object1) = key1;<br>   …<br>hash(object4) = key4;</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a697c4d4353a7d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p>③、把 cache 映射到 hash 空间</p>
<p>在采用一致性哈希算法的分布式集群中将新的机器加入，其原理是通过使用与对象存储一样的 Hash 算法将机器也映射到环中（一般情况下对机器的 hash 计算是采用机器的 IP 或者机器名作为输入值）。</p>
<p>假设当前有 A、B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。</p>
<p>hash(cache A) = key A;<br>   …<br>hash(cache C) = key C;</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-50a5eaf90ab622f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p>
<p>④、把对象映射到 cache</p>
<p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间了，接下来要考虑的是如何将对象映射到 cache 上面了。</p>
<p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这就找到了对象和 cache 的映射方法。</p>
<p>依然继续上面的例子（上图），那么根据上面的方法：</p>
<ul>
<li><p>对象 object1 将被存储到 cache A 上；</p>
</li>
<li><p>object2 和 object3 对应到 cache C；</p>
</li>
<li><p>object4 对应到 cache B。</p>
</li>
</ul>
<p>⑤、考察 cache 的变动</p>
<p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时，cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p>
<p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache A）之间的对象，也即是本来映射到 cache B 上的那些对象。</p>
<p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可：</p>
<p><img src="http://static.oschina.net/uploads/img/201305/21223635_l44C.jpg" alt></p>
<p>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache（cache B）之间的对象（它们是本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p>
<p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-623e26e85c51e3d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p>
<p>4、虚拟节点</p>
<p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p>
<blockquote>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
</blockquote>
<p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中，cache A 仅存储了 object1，而 cache C 则存储了 object2 、object3 和 object4；分布是很不均衡的。</p>
<p>为了解决这种情况，consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p>
<blockquote>
<p>“虚拟节点”（virtual node）是实际节点在 hash 空间的复制品（replica），一个实际节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p>
</blockquote>
<p>仍以仅部署 cache A 和 cache C 的情况为例，在前面我们已经看到，cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”。cache A1、cache A2 代表了 cache A；cache C1、cache C2 代表了 cache C；假设一种比较理想的情况，参见下图 。</p>
<p><img src="http://static.oschina.net/uploads/img/201305/21223636_3TXC.jpg" alt></p>
<p>此时，对象到“虚拟节点”的映射关系为：</p>
<p>objec1-&gt;cache A2<br>objec2-&gt;cache A1<br>objec3-&gt;cache C1<br>objec4-&gt;cache C2</p>
<p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-5c35149383a8120c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p>
<p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241</p>
<p>引入“虚拟节点”前，计算 cache A 的 hash 值：Hash(“202.168.14.241”);</p>
<p>引入“虚拟节点”后，计算“虚拟节点” cache A1 和 cache A2 的 hash 值：</p>
<p>Hash(“202.168.14.241#1”);  // cache A1<br>Hash(“202.168.14.241#2”);  // cache A2</p>
<h5 id="三、分布式哈希算法"><a href="#三、分布式哈希算法" class="headerlink" title="三、分布式哈希算法"></a>三、分布式哈希算法</h5><p>由浅入深一步一步介绍什么是分布式哈希表。</p>
<p>1、哈希函数</p>
<p>哈希函数是一种计算方法，它可以把一个值 A 映射到一个特定的范围 [begin, end] 之内。对于一个值的集合{k1, k2, … , kN}，哈希函数把他们均匀的映射到某个范围之中。这样，通过这些值就可以很快的找到与之对应的映射地址 {index1, index2, … , indexN}。对于同一个值，哈希函数要能保证对这个值的运算结果总是相同的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-24c7c05499f13cf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"></p>
<p>哈希函数需要经过精心设计才能够达到比较好的效果，但是总是无法达到理想的效果。多个值也许会映射到同样的地址上。这样就会产生冲突，如图中的红线所示。在设计哈希函数时要尽量减少冲突的产生。</p>
<p>最简单的哈希函数就是一个求余运算：hash(A) = A % N。这样就把 A 这个值映射到了 [0, N-1] 这样一个范围之中。</p>
<p>2、哈希表</p>
<p>哈希表的核心就是哈希函数 hash()。</p>
<p>哈希表是一种数据结构，它把 KEY 和 VALUE 用某种方式对应起来。使用 hash() 函数把一个 KEY 值映射到一个 index 上，即hash(KEY) = index。这样就可以把一个 KEY 值同某个 index 对应起来。然后把与这个 KEY 值对应的 VALUE 存储到 index 所标记的存储空间中。这样，每次想要查找 KEY 所对应的 VALUE 值时，只需要做一次 hash() 运算就可以找到了。</p>
<p>举个例子：图书馆中的书会被某人借走，这样“书名”和“人名”之间就形成了 KEY 与 VALUE 的关系。假设现在有三个记录：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-79a9417342a7b023.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"></p>
<p>这就是“书名”和“人名”的对应关系，它表示某人借了某本书。现在把这种对应关系用哈希表存储起来，它们的 hash() 值分别为：</p>
<p>hash(简明现代魔法) = 2;</p>
<p>hash(最后一天) = 0;</p>
<p>hash(变形记) = 1;</p>
<p>然后我们就可以在一个表中存储“人名”了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-4e0ea5c475d3a1d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>当有大量的 KEY VALUE 对应关系的数据需要存储时，这种方法就非常有效。这三个人名分别存储在 0、1 和 2 号存储空间中。当我们想要查找《简明现代魔法》这本书是被谁借走的时候，只要 hash()一下这个书名，就可以找到它所对应的 index = 2。然后在这个表中就可以找到对应的人名了。在这里，KEY 为“书名”， VALUE 为“人名”。</p>
<p>3、分布式哈希表</p>
<p>哈希表把所有的东西都存储在一台机器上，当这台机器坏掉了之后，所存储的东西就全部消失了。分布式哈希表可以把一整张哈希表分成若干个不同的部分，分别存储在不同的机器上，这样就降低了数据全部被损坏的风险。</p>
<p>分布式哈希表通常采用一致性哈希函数来对机器和数据进行统一运算。这里先不用深究一致性哈希究竟是什么，只需要知道它是对机器（通常是其 IP 地址）和数据（通常是其 KEY 值）进行统一的运算，把它们全都映射到一个地址空间中。假设有一个一致性哈希函数可以把一个值映射到 32bit 的地址空间中，从 0 一直到 232–1。用一个圆环来表示这个地址空间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f3463c9d24d5357d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p>
<p>假设有 N 台机器，那么 hash() 就会把这 N 台机器映射到这个环的 N 个地方。然后我们把整个地址空间进行一下划分，使每台机器控制一个范围的地址空间。这样，当我们向这个系统中添加数据的时候，首先使用 hash() 函数计算一下这个数据的 index，然后找出它所对应的地址在环中属于哪个地址范围，我们就可以把这个数据放到相应的机器上。这样，就把一个哈希表分布到了不同的机器上。如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-50a5eaf90ab622f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p>
<p>这里蓝色的圆点表示机器，红色的圆点表示某个数据经过 hash() 计算后所得出的地址。</p>
<p>在这个图中，按照逆时针方向，每个机器占据的地址范围为从本机器开始一直到下一个机器为止。用顺时针方向来看，每个机器所占据的地址范围为这台机器之前的这一段地址空间。图中的虚线表示数据会存储在哪台机器上。</p>
<h5 id="四、基础操作"><a href="#四、基础操作" class="headerlink" title="四、基础操作"></a>四、基础操作</h5><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素。也可以简单的理解为，按照关键字为每一 个元素“分类”，然后将这个元素存储在相应“类”所对应的地方。</p>
<p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。后面我们将看到一种解决“冲突”的简便做法。 </p>
<p>总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。 </p>
<p>1、函数构造</p>
<p>构造函数的常用方法（下面为了叙述简洁，设 h(k) 表示关键字为 k 的元素所对应的函数值）： </p>
<ul>
<li><p>除余法：选择一个适当的正整数 p ，令 h(k ) = k mod p，这里 p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。 </p>
</li>
<li><p>数字选择法：如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。 </p>
</li>
</ul>
<p>2、冲突处理</p>
<p>线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S, i = 1,2,3…，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。 </p>
<p>3、支持运算</p>
<p>哈希表支持的运算主要有：初始化(makenull)、哈希函数值的运算(h(x))、插入元素(insert)、查找元素(member)。 设插入的元素的关键字为 x ，A 为存储的数组。初始化比较容易，例如 ：</p>
<p>const empty = maxlongint; // 用非常大的整数代表这个位置没有存储元素<br>    p=9997; // 表的大小<br>    procedure makenull;<br>        var i:integer;<br>            begin<br>    for i:=0 to p-1 do<br>        A[i]:=empty;<br>            End; </p>
<p>哈希函数值的运算根据函数的不同而变化，例如除余法的一个例子：</p>
<p>function h(x:longint):Integer;<br>        begin<br>    h:= x mod p;<br>        end;</p>
<p>我们注意到，插入和查找首先都需要对这个元素定位，即如果这个元素若存在，它应该存储在什么位置，因此加入一个定位的函数  locate。</p>
<p>function locate(x:longint):integer;<br>    var orig,i:integer;<br>           begin<br>    orig:=h(x);<br>    i:=0;</p>
<pre><code>while (i &lt; S)and(A\[(orig+i)mod S\]&lt;&gt;x)and(A\[(orig+i)mod S\]&lt;&gt;empty) do
    inc(i);//当这个循环停下来时，要么找到一个空的存储单元，要么找到这个元素存储的单元，要么表已经满了

locate:=(orig+i) mod S;
       end;
</code></pre><p>插入元素：</p>
<p>procedure insert(x:longint);<br>    var posi:integer;<br>        begin<br>    posi:=locate(x); //定位函数的返回值</p>
<pre><code>if A\[posi\]=empty then A\[posi\]:=x
else error;  // error 即为发生了错误，当然这是可以避免的
    end;
</code></pre><p>查找元素是否已经在表中：</p>
<p>procedure member(x:longint):boolean;<br>    var posi:integer;<br>        begin<br>    posi:=locate(x);</p>
<pre><code>if A\[posi\]=x then member:=true
else member:=false;
    end;
</code></pre><p>这些就是建立在哈希表上的常用基本运算。</p>
<p>当数据规模接近哈希表上界或者下界的时候，哈希表完全不能够体现高效的特点，甚至还不如一般算法。但是如果规模在中央，它高效的特点可以充分体现。试验表明当元素充满哈希表的 90% 的时候，效率就已经开始明显下降。这就给了我们提示：如果确定使用哈希表，应该尽量使数组开大，但对最太大的数组进行操作也比较费时间，需要找到一个平衡点。通常使它的容量至少是题目最大需求的 120%，效果比较好（这个仅仅是经验，没有严格证明）。</p>
<h5 id="五、应用举例"><a href="#五、应用举例" class="headerlink" title="五、应用举例"></a>五、应用举例</h5><p>什么时候适合应用哈希表呢？如果发现解决这个问题时经常要询问：“某个元素是否在已知集合中？”，也就是需要高效的数据存储和查找，则使用哈希表是最好不过的了。那么，在应用哈希表的过程中，值得注意的是什么呢？ </p>
<p>哈希函数的设计很重要。一个不好的哈希函数，就是指造成很多冲突的情况，从前面的例子已经可以看出来，解决冲突会浪费掉大量时间，因此我们的目标就是尽力避免冲突。前面提到，在使用“除余法”的时候，h(k)=k mod p，p 最好是一个大素数。这就是为了尽力避免冲突。为什么呢？假设 p = 1000，则哈希函数分类的标准实际上就变成了按照末三位数分类，这样最多 1000 类，冲突会很多。一般地说，如果 p 的约数越多，那么冲突的几率就越大。 </p>
<p>简单的证明：假设 p 是一个有较多约数的数，同时在数据中存在 q 满足 gcd(p,q) = d &gt;1，即有 p = a<em>d，q = b</em>d，则有</p>
<p>q mod p = q – p<em> [q div p] = q – p</em>[b div a]. ①</p>
<p>其中 [b div a] 的取值范围是不会超过 [0, b] 的正整数。也就是说，[b div a] 的值只有 b + 1 种可能，而 p 是一个预先确定的数。因此 ① 式的值就只有 b + 1 种可能了。这样，虽然 mod 运算之后的余数仍然在 [0，p-1] 内，但是它的取值仅限于 ① 可能取到的那些值。也就是说余数的分布变得不均匀了。容易看出，p 的约数越多，发生这种余数分布不均匀的情况就越频繁，冲突的几率越高。而素数的约数是最少的，因此我们选用大素数。记住“素数是我们的得力助手”。 </p>
<p>另一方面，一味的追求低冲突率也不好。理论上是可以设计出一个几乎完美，几乎没有冲突的函数的。然而，这样做显然不值得，因为这样的函数设计很浪费时间而且编码一定很复杂，与其花费这么大的精力去设计函数，还不如用一个虽然冲突多一些但是编码简单的函数。因此，函数还需要易于编码，即易于实现。 </p>
<p>综上所述，设计一个好的哈希函数是很关键的。而“好”的标准，就是较低的冲突率和易于实现。 </p>
<p>另外，使用哈希表并不是记住了前面的基本操作就能以不变应万变的。有的时候，需要按照题目的要求对哈希表的结构作一些改进。往往一些简单的改进就可以带来巨大的方便。 </p>
<p>这些只是一般原则，真正遇到试题的时候实际情况千变万化，需要具体问题具体分析才行。</p>
<h5 id="六、图例过程"><a href="#六、图例过程" class="headerlink" title="六、图例过程"></a>六、图例过程</h5><p><img src="https://upload-images.jianshu.io/upload_images/5294842-05f6cd1077b95602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-10ddb2dc44c822e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-aca62d2d85762399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13"><img src="https://upload-images.jianshu.io/upload_images/5294842-853d753d96ce86dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"></p>
<p>删除节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-6c72a818388c8445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14"></p>
<p>增加节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f1581239c8cf5fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"></p>
<p>虚拟节点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-47ba8fb796fc3a18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-3e401371990c09fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16"></p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/12/e5-93-88-e5-b8-8c-e8-a1-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/">http://yoursite.com/2019/03/12/e5-93-88-e5-b8-8c-e8-a1-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/12/e9-9d-a2-e5-90-91-e5-af-b9-e8-b1-a1-e7-9a-84-e5-87-a0-e5-a4-a7-e8-ae-be-e8-ae-a1-e5-8e-9f-e5-88-99/" class="pre"> 面向对象的几大设计原则		</a><a href="/2019/03/10/whiletrue/" class="next"> while(true)		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、哈希表的原理与实现"><span class="toc-text">一、哈希表的原理与实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、一致性-hash-算法"><span class="toc-text">二、一致性 hash 算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、分布式哈希算法"><span class="toc-text">三、分布式哈希算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、基础操作"><span class="toc-text">四、基础操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、应用举例"><span class="toc-text">五、应用举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、图例过程"><span class="toc-text">六、图例过程</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>