<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> 加密算法		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> 加密算法		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> 加密算法		</h1><div class="post-meta"><a href="/2019/03/08/e5-8a-a0-e5-af-86-e7-ae-97-e6-b3-95/#comments" class="comment-count"></a><p><span class="date">Mar 08, 2019</span><span><a href="/categories/计算机网络/" class="category">计算机网络</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。</p>
<p>对称加密<br>有流式、分组两种，加密和解密都是使用的同一个密钥。<br>例如：DES、AES-GCM、ChaCha20-Poly1305等</p>
<p>非对称加密<br>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>
<p>例如：RSA、DSA、ECDSA、 DH、ECDHE</p>
<p>哈希算法<br>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p>
<p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p>
<p>数字签名<br>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。<br>---------------------<br>作者：猪哥66<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/u014044812/article/details/79571927" target="_blank" rel="noopener">https://blog.csdn.net/u014044812/article/details/79571927</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<p>一般来说,常见的数字加密方式都可以分为两类,即对称加密和非对称加密. 对于对称加密来说,<br>加密和解密用的是同一个密钥, 加密方法有AES,DES,RC4,BlowFish等; 对应的, 非对称加密在<br>加密和解密时, 用的是不同的密钥, 分别称为公钥或私钥. 非对称加密的加密方法有RSA, DSA,<br>Diffie-Hellman等.</p>
<p>OpenSSL是一个开源项目,为传输层安全(TLS)和安全套接字(SSL)协议提供了比较完整的实现,<br>同时也致力于将自身打造为一个通用的密码学工具集. 其中包括:</p>
<ul>
<li>libssl : 提供了SSL(包括SSLv3)和TLS的服务器端以及客户端的实现.</li>
<li>libcrypto : 通用的密码学库以及对X.509的支持</li>
<li>openssl : 一个多功能的命令行工具</li>
</ul>
<p>本文主要使用openssl的命令行工具来示例非对称加密的流程, 如果有兴趣的话,也可以用其SDK<br>来实现更具体的操作.</p>
<h1 id="2-加解密过程"><a href="#2-加解密过程" class="headerlink" title="2.加解密过程"></a>2.加解密过程</h1><h3 id="2-1创建公私钥对"><a href="#2-1创建公私钥对" class="headerlink" title="2.1创建公私钥对"></a>2.1创建公私钥对</h3><p>首先用openssl生成私钥:</p>
<p><code>openssl genrsa -out private.pem 1024</code></p>
<p>当然为了更加安全,可以在生成私钥的时候同时指定密码, 这样即使不小心泻露了私钥,也能增加别人的盗用难度:</p>
<ol>
<li><p>openssl genrsa -aes256 -passout stdin -out private.pem 1024</p>
</li>
<li><p>openssl genrsa -aes256 -passout file:passwd.txt -out private.pem 1024</p>
</li>
<li><p>openssl genrsa -aes256 -passout pass:my_password -out private.pem 1024</p>
</li>
</ol>
<p>其中<code>-passout</code> 指定密码的输入方式,可以分别是stdin,从文件中读取或者紧接着pass:后面输入.<br>有了私钥,便可以从其中提取出公钥:</p>
<p><code>openssl rsa -in private.pem -pubout -out public.pem</code></p>
<h3 id="2-2用公私钥进行加解密"><a href="#2-2用公私钥进行加解密" class="headerlink" title="2.2用公私钥进行加解密"></a>2.2用公私钥进行加解密</h3><p>在一次秘密的信息传输中, 我们首先通过可信的方式(比如面对面)将公钥告知对方, 对方发送机密信息的时候<br>就可以用我们的公钥加密:</p>
<p><code>openssl rsautl -encrypt -pubin -inkey public.pem -in file.txt -out file.txt.enc</code></p>
<p>在发送的过程中即便泄露了文件,也无法查看文件的明文信息. 而我们收到密文后, 用私钥解密即可:</p>
<p><code>openssl rsautl -decrypt -inkey private.pem -in file.txt.enc -out file.txt.dec</code></p>
<h3 id="2-2和对称加密协作"><a href="#2-2和对称加密协作" class="headerlink" title="2.2和对称加密协作"></a>2.2和对称加密协作</h3><p>虽然公私钥加密很好用, 但事实上非对称加密的缺点是加解密速度要远远慢于对称加密, 在某些极端情况下,<br>甚至能比非对称加密慢上千倍. 另外由于RSA算法的工作机理, 如果密钥是n比特的,那么其加密的信息容量就<br>不能大于(n-11)比特. 因此对于大文件的加密传输, 通常还是使用对称加密的方式, 例如</p>
<ol>
<li><p>openssl rand -base64 128 -out aeskey.txt</p>
</li>
<li><p>openssl enc -aes-256-cbc -salt -in file.txt -out file.txt.aesenc -pass file:aeskey.txt</p>
</li>
<li><p>openssl enc -d -aes-256-cbc -in file.txt.aesenc -out file.txt.aesdec -pass file:aeskey.txt</p>
</li>
</ol>
<p>其中aeskey.txt是我们随机生成密码文件, 并且用其可以对大文件进行对称的加解密, 在实际中,<br>通常还会将密码文件用公私钥加密的方式来发送给对方. 值得一提的是,这也正是PGP的工作方式,</p>
<p><img src="https://images2015.cnblogs.com/blog/676200/201610/676200-20161029180526484-1703108167.png" alt="加密解密" title="加密解密"></p>
<h1 id="3-证书"><a href="#3-证书" class="headerlink" title="3.证书"></a>3.证书</h1><p>对任一个体来说, 它都有公钥,私钥和证书. 其中私钥用来加密发出去的信息,公钥用来解密收到的信息,<br>而证书则用来证明自己的身份. 一般来说,证书中包含自己的公钥以及额外的信息,如签发机构(CA, Certificate Authority),<br>证书用途(比如适用的域名)和有效时间等. CA通常是个第三方的可信机构, 比如VeriSign, GeoTrust,<br>DigiCert和沃通等, 当然也可以是未知的主体, 比如说自己.</p>
<p>获得一张证书的流程通常是:</p>
<ul>
<li>1)用私钥生成证书签名请求(csr),</li>
<li>2)将csr文件发送给CA,待其验证信息无误后,CA会用自己的私钥对其进行签名表示确认.</li>
</ul>
<h3 id="3-1-生成证书签名请求"><a href="#3-1-生成证书签名请求" class="headerlink" title="3.1 生成证书签名请求"></a>3.1 生成证书签名请求</h3><p>证书签名请求(Certificate Signing Request)通常以.csr为后缀, 包含了请求方的公钥和主体的详细信息,<br>如域名,公司名,国家,城市等信息, 其完整内容可以参考这里. 使用openssl也能很方便地生成csr:</p>
<p><code>openssl req -new -key private.pem -out pppan.csr</code></p>
<p>默认会在stdin中根据提示交互地输入主体信息,也可以通过<code>-config</code>选项来从文件中读取.<br>生成完之后可以通过:</p>
<p><code>openssl req -in pppan.csr -noout -text</code></p>
<p>来查看csr文件中的详细信息.</p>
<h3 id="3-2-CA对csr文件进行签名"><a href="#3-2-CA对csr文件进行签名" class="headerlink" title="3.2 CA对csr文件进行签名"></a>3.2 CA对csr文件进行签名</h3><p>当CA收到csr文件并且对请求方的域名,公司等内容校验无误后,便可以对csr请求进行确认(签名),</p>
<ol>
<li><p>openssl req -x509 -newkey rsa:4096 -nodes -keyout cakey.pem -out cacert.pem -outform PEM</p>
</li>
<li><p>openssl ca -config openssl-ca.cnf -policy SP -extensions SR -infiles pppan.csr -out pppan.crt</p>
</li>
</ol>
<p>虽然这不是重点, 但也稍微解释下这两个命令的意思吧. 第一个命令是CA一开始创建私钥和CA的证书,<br>第二个命令表示对csr文件进行签名确认, 用-config指定自定义的配置文件, 如果不指定则默认为/usr/lib/ssl/openssl.cnf,<br>SP和SR都是自定义于配置文件中的信息, 此外配置文件中还包括CA证书路径和私钥路径,以及对req的默认校验策略等,<br>有兴趣的可以查看详细解释.</p>
<p>另外值得一提的是, 我们用自己的私钥也可以生成证书, 并且也能用这个证书来对自己的csr进行签名,<br>这通常称为自签名(self-signed), 上面CA生成的证书cacert.pem就是自签名的. 一般来说,<br>如果是自己随便生成自签名证书, 通常会被认为是不可信的, 除非手动添加到对方的信任CA证书列表中.</p>
<h3 id="3-3查看和验证证书"><a href="#3-3查看和验证证书" class="headerlink" title="3.3查看和验证证书"></a>3.3查看和验证证书</h3><p>CA对csr进行签名后, 我们就能得到对应的证书, 这里是pppan.crt, 可以用openssl查看证书的详细信息:</p>
<p><code>openssl x509 -noout -text -in pppan.crt</code></p>
<p>可以看到具体的签发机构,签发时间和证书的有效时间等信息.<br>可以用命令验证证书是否有效:</p>
<p><code>openssl verify -CAfile Trusts.pem pppan.crt</code></p>
<p>其中Trusts.pem是一系列所信任的证书集合,其中也包括了上述CA的证书cacert.pem</p>
<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><p>上面所有用到的证书及其组件,如公钥,私钥,csr等,其格式都是PEM的,这也是最常见的一种格式,<br>可以用文本便及其打开,通常是以—–BEGIN XXX——开头, 以—–END XXX—–结束,<br>中间的部分则是实际密钥的base64编码, 其二进制表示也称为DER格式, 两者可以用base64转化,<br>因此都属于x509实现的证书格式.</p>
<p>还有比较常见的证书格式,为PKCS7和PKCS12. 其中PKCS7是由JAVA使用的开放标准,并且也被<br>Windows所支持, 其内是不包含私钥信息的; 而PKCS12则是一种非公开的标准,用来提供比PEM的<br>纯文本格式更高的安全性, 这是Windows建议使用的格式, 其中可以包含私钥信息.</p>
<p>不同格式的转换如下所示.</p>
<ol>
<li>PEM <-> DER:</-></li>
</ol>
<ol start="3">
<li><p>openssl x509 -in bar.pem -outform der -out bar.der</p>
</li>
<li><p>openssl x509 -inform der -in foo.der -out foo.pem</p>
</li>
<li><p>PEM <-> PKCS7:</-></p>
</li>
</ol>
<ol start="7">
<li><p>openssl crl2pkcs7 -nocrl -certfile foocert.pem -out foocert.p7b</p>
</li>
<li><p>openssl pkcs7 -in foocert.p7b -print_certs -out barcert.pem</p>
</li>
<li><p>PEM <-> PKCS12:</-></p>
</li>
</ol>
<ol start="11">
<li><p>openssl pkcs12 -inkey private.key -in foocert.pem -export -out foocert.pfx</p>
</li>
<li><p>openssl pkcs12 -in foocert.pfx -nodes -out barcert.pem</p>
</li>
</ol>
<h3 id="5-后记"><a href="#5-后记" class="headerlink" title="5. 后记"></a>5. 后记</h3><p>当今我们使用最多的https本质上就是在http协议的基础上对传输内容进行了非对称的加密,<br>当然实现过程多了很多复杂的交互, 感兴趣的可以去查看SSL和TLS协议. 我想说的是,<br>这一切信任机制的基石是对于CA的信任, 如果说CA的私钥泻露,或者我们错误地信任了一个坏CA,<br>那么https的隐私性也就不复存在了, 因为其可能对无效的csr进行签名, 从而使得https中间人攻击<br>成为现实. 据说早在两年前伟大的防火墙就已经可以对https进行监听,敏感词识别和连接重置,<br>后来因为某种原因才从大范围应用转为只对特殊对象使用,不过那是后话了.</p>
<p>博客地址:</p>
<p><a href="http://pppan.net/" target="_blank" rel="noopener">http://pppan.net</a><br>有价值炮灰-博客园<br>欢迎交流,文章转载请注明出处.</p>
<p>常用Java加密算法总结</p>
<p>简单的java加密算法有：</p>
<ol>
<li>BASE64 严格地说，属于编码格式，而非加密算法</li>
<li>MD5(Message Digest algorithm 5，信息摘要算法)</li>
<li>SHA(Secure Hash Algorithm，安全散列算法)</li>
<li>HMAC(Hash Message Authentication Code，散列消息鉴别码)</li>
</ol>
<h2 id="1-BASE64"><a href="#1-BASE64" class="headerlink" title="1. BASE64"></a>1. BASE64</h2><p>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。（来源百度百科）</p>
<p>java实现代码：</p>
<p>package com.cn.单向加密;<br>import sun.misc.BASE64Decoder;<br>import sun.misc.BASE64Encoder;<br>/<em><br>BASE64的加密解密是双向的，可以求反解.<br>BASE64Encoder和BASE64Decoder是非官方JDK实现类。虽然可以在JDK里能找到并使用，但是在API里查不到。<br>JRE 中 sun 和 com.sun 开头包的类都是未被文档化的，他们属于 java, javax 类库的基础，其中的实现大多数与底层平台有关，<br>一般来说是不推荐使用的。<br>BASE64 严格地说，属于编码格式，而非加密算法<br>主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。<br>另，BASE加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。<br>BASE64<br>按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。<br>（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.）<br>常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。
</em>/<br>public class BASE64 {<br>    /**<br>     * BASE64解密<br>     *<br>     * @param key<br>     * @return<br>     * @throws Exception<br>     */<br>    public static byte[] decryptBASE64(String key) throws Exception {<br>        return (new BASE64Decoder()).decodeBuffer(key);<br>    }   </p>
<pre><code>/\*\*  
 \* BASE64加密  
 \*   
 \* @param key  
 \* @return  
 \* @throws Exception  
 */  
public static String encryptBASE64(byte\[\] key) throws Exception {   
    return (new BASE64Encoder()).encodeBuffer(key);   
}  

public static void main(String\[\] args) {

 String str=&quot;12345678&quot;;

    try {
    String result1= BASE64.encryptBASE64(str.getBytes());
     System.out.println(&quot;result1=====加密数据==========&quot;+result1);

     byte result2\[\]= BASE64.decryptBASE64(result1);
     String str2=new String(result2);
     System.out.println(&quot;str2========解密数据========&quot;+str2);
} catch (Exception e) { e.printStackTrace();
}

}
</code></pre><p>}</p>
<h2 id="2-MD5"><a href="#2-MD5" class="headerlink" title="2. MD5"></a>2. MD5</h2><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、M<a href="http://www.codeceo.com/article/javascript-d3-js.html" title="D3" target="_blank" rel="noopener">D3</a>和MD4。广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值。好比现在的ISO校验，都是MD5校验。怎么用？当然是把ISO经过MD5后产生MD5的值。一般下载linux-ISO的朋友都见过下载链接旁边放着MD5的串。就是用来验证文件是否一致的。</p>
<p>java实现代码：</p>
<p>package com.cn.单向加密;<br>import java.math.BigInteger;<br>import java.security.MessageDigest;<br>/<em><br>MD5(Message Digest algorithm 5，信息摘要算法)<br>通常我们不直接使用上述MD5加密。通常将MD5产生的字节数组交给BASE64再加密一把，得到相应的字符串<br>Digest:汇编
</em>/<br>public class MD5 {<br>    public static final String KEY_MD5 = “MD5”;   </p>
<pre><code>public static  String getResult(String inputStr)
{
    System.out.println(&quot;=======加密前的数据:&quot;+inputStr);
    BigInteger bigInteger=null;

    try {
     MessageDigest md = MessageDigest.getInstance(KEY_MD5);   
     byte\[\] inputData = inputStr.getBytes(); md.update(inputData); bigInteger = new BigInteger(md.digest());   
    } catch (Exception e) {e.printStackTrace();}
    System.out.println(&quot;MD5加密后:&quot; + bigInteger.toString(16));   
    return bigInteger.toString(16);
}

public static void main(String args\[\])
{
    try {
         String inputStr = &quot;简单加密8888888888888888888&quot;; getResult(inputStr);
    } catch (Exception e) { e.printStackTrace();
    }

}
</code></pre><p>}</p>
<p>MD5算法具有以下特点：</p>
<p>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。<br>5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。<br>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。除了MD5以外，其中比较有名的还有sha-1、RIPEMD以及Haval等。</p>
<h2 id="3-SHA"><a href="#3-SHA" class="headerlink" title="3.SHA"></a>3.SHA</h2><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。该算法经过加密专家多年来的发展和改进已日益完善，并被广泛使用。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。散列函数值可以说是对明文的一种”指纹”或是”摘要”所以对散列值的数字签名就可以视为对此明文的数字签名。</p>
<p>java实现代码：</p>
<p>package com.cn.单向加密;<br>import java.math.BigInteger;<br>import java.security.MessageDigest;<br>/<em><br>SHA(Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，<br>被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了，<br>但是SHA仍然是公认的安全加密算法，较之MD5更为安全</em>/<br>public class SHA {<br>     public static final String KEY_SHA = “SHA”;   </p>
<pre><code>public static  String getResult(String inputStr)
{
    BigInteger sha =null;
    System.out.println(&quot;=======加密前的数据:&quot;+inputStr);
    byte\[\] inputData = inputStr.getBytes();   
    try {
         MessageDigest messageDigest = MessageDigest.getInstance(KEY_SHA); messageDigest.update(inputData); sha = new BigInteger(messageDigest.digest());   
         System.out.println(&quot;SHA加密后:&quot; + sha.toString(32));   
    } catch (Exception e) {e.printStackTrace();}
    return sha.toString(32);
}

public static void main(String args\[\])
{
    try {
         String inputStr = &quot;简单加密&quot;; getResult(inputStr);
    } catch (Exception e) { e.printStackTrace();
    }

}
</code></pre><p>}</p>
<h2 id="SHA-1与MD5的比较"><a href="#SHA-1与MD5的比较" class="headerlink" title="SHA-1与MD5的比较"></a>SHA-1与MD5的比较</h2><p>因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：<br>l 对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是2^128数量级的操作，而对SHA-1则是2^160数量级的操作。这样，SHA-1对强行攻击有更大的强度。<br>l 对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。<br>l 速度：在相同的硬件上，SHA-1的运行速度比MD5慢。</p>
<h2 id="4-HMAC"><a href="#4-HMAC" class="headerlink" title="4.HMAC"></a>4.HMAC</h2><p>HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</p>
<p>java实现代码：</p>
<p>package com.cn.单向加密;<br>/<em><br>HMAC<br>HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。<br>消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。<br>使用一个密钥生成一个固定大小的小数据块，<br>即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</em>/<br>import javax.crypto.KeyGenerator;<br>import javax.crypto.Mac;<br>import javax.crypto.SecretKey;<br>import javax.crypto.spec.SecretKeySpec;<br>import com.cn.comm.Tools;<br>/**<br> * 基础加密组件<br> */<br>public abstract class HMAC {<br>    public static final String KEY_MAC = “HmacMD5”;   </p>
<pre><code>/\*\*  
 \* 初始化HMAC密钥  
 \*   
 \* @return  
 \* @throws Exception  
 */  
public static String initMacKey() throws Exception {   
    KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);   
    SecretKey secretKey = keyGenerator.generateKey();   
    return BASE64.encryptBASE64(secretKey.getEncoded());   
}   

/\*\*  
 \* HMAC加密  ：主要方法
 \*   
 \* @param data  
 \* @param key  
 \* @return  
 \* @throws Exception  
 */  
public static String encryptHMAC(byte\[\] data, String key) throws Exception {   

    SecretKey secretKey = new SecretKeySpec(BASE64.decryptBASE64(key), KEY_MAC);   
    Mac mac = Mac.getInstance(secretKey.getAlgorithm()); mac.init(secretKey);   
    return new String(mac.doFinal(data));   

}   

public static  String getResult1(String inputStr)
{
    String path=Tools.getClassPath();
    String fileSource=path+&quot;/file/HMAC_key.txt&quot;;
    System.out.println(&quot;=======加密前的数据:&quot;+inputStr);
    String result=null;
    try {
        byte\[\] inputData = inputStr.getBytes(); 
        String key = HMAC.initMacKey(); /*产生密钥*/  
        System.out.println(&quot;Mac密钥:===&quot; + key);  
        /*将密钥写文件*/
        Tools.WriteMyFile(fileSource,key); result= HMAC.encryptHMAC(inputData, key);
        System.out.println(&quot;HMAC加密后:===&quot; + result); 
    } catch (Exception e) {e.printStackTrace();}  
   return result.toString();
}

public static  String getResult2(String inputStr)
{
    System.out.println(&quot;=======加密前的数据:&quot;+inputStr);
     String path=Tools.getClassPath();
     String fileSource=path+&quot;/file/HMAC_key.txt&quot;;
     String key=null;;
    try {
         /*将密钥从文件中读取*/ key=Tools.ReadMyFile(fileSource);
         System.out.println(&quot;getResult2密钥:===&quot; + key);  
    } catch (Exception e1) { e1.printStackTrace();}
    String result=null;
    try {
        byte\[\] inputData = inputStr.getBytes();  
        /*对数据进行加密*/ result= HMAC.encryptHMAC(inputData, key);
        System.out.println(&quot;HMAC加密后:===&quot; + result); 
    } catch (Exception e) {e.printStackTrace();}  
   return result.toString();
}

public static void main(String args\[\])
{
    try {
         String inputStr = &quot;简单加密&quot;; 
         /*使用同一密钥：对数据进行加密：查看两次加密的结果是否一样*/ getResult1(inputStr); getResult2(inputStr);

    } catch (Exception e) { e.printStackTrace();
    }

}
</code></pre><p>}</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/08/e5-8a-a0-e5-af-86-e7-ae-97-e6-b3-95/">http://yoursite.com/2019/03/08/e5-8a-a0-e5-af-86-e7-ae-97-e6-b3-95/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/10/whiletrue/" class="pre"> while(true)		</a><a href="/2019/03/08/https/" class="next"> HTTPS		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2-加解密过程"><span class="toc-text">2.加解密过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1创建公私钥对"><span class="toc-text">2.1创建公私钥对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2用公私钥进行加解密"><span class="toc-text">2.2用公私钥进行加解密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2和对称加密协作"><span class="toc-text">2.2和对称加密协作</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#3-证书"><span class="toc-text">3.证书</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-生成证书签名请求"><span class="toc-text">3.1 生成证书签名请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-CA对csr文件进行签名"><span class="toc-text">3.2 CA对csr文件进行签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3查看和验证证书"><span class="toc-text">3.3查看和验证证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-其他"><span class="toc-text">4. 其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-后记"><span class="toc-text">5. 后记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BASE64"><span class="toc-text">1. BASE64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MD5"><span class="toc-text">2. MD5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SHA"><span class="toc-text">3.SHA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHA-1与MD5的比较"><span class="toc-text">SHA-1与MD5的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-HMAC"><span class="toc-text">4.HMAC</span></a></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>