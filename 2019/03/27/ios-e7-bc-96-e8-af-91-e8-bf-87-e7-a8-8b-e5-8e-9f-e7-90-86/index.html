<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> iOS 编译过程原理(1)		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> iOS 编译过程原理(1)		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> iOS 编译过程原理(1)		</h1><div class="post-meta"><a href="/2019/03/27/ios-e7-bc-96-e8-af-91-e8-bf-87-e7-a8-8b-e5-8e-9f-e7-90-86/#comments" class="comment-count"></a><p><span class="date">Mar 27, 2019</span><span><a href="/categories/Xcode/" class="category">Xcode</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://blog.csdn.net/Hello_Hwc/article/details/53557308" target="_blank" rel="noopener">iOS编译过程的原理和应用</a></p>
<h5 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h5><p>一般可以将编程语言分为两种，<a href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80" target="_blank" rel="noopener">编译语言</a>和<a href="https://en.wikipedia.org/wiki/Interpreted_language" target="_blank" rel="noopener">直译式语言</a>。</p>
<p>像 C++、Objective-C 都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率较高。</p>
<p>像 JavaScript、Python 都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为 CPU 可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活。</p>
<p>iOS 开发目前的常用语言：Objective 和 Swift。二者都是编译语言，换句话说都是需要编译才能执行的。它们的编译都是依赖于 Clang(swift) + LLVM。本文只关注 Objective-C，原理上大同小异。</p>
<p>充分理解了编译的过程，会对你的开发大有帮助。本文的最后，会以以下几个例子，来讲解如何合理利用 XCode 和编译</p>
<ul>
<li>__attribute__</li>
<li>Clang 警告处理</li>
<li>预处理</li>
<li>插入编译期脚本</li>
<li>提高项目编译速度</li>
</ul>
<p>对于不想看我啰里八嗦讲一大堆原理的同学，可以直接跳到本文的最后一个章节。</p>
<h5 id="二、iOS-编译"><a href="#二、iOS-编译" class="headerlink" title="二、iOS 编译"></a>二、iOS 编译</h5><p>Objective-C 采用 Clang 作为前端，而 Swift 则采用 swift() 作为前端，都是 LLVM（Low level vritual machine）作为编译器后端。所以简单的编译过程如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-3a4fe4a482e93bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p>
<p>其中，swift 的编译命令可以在这里找到</p>
<p>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift</p>
<p>可以通过 Clang，来查看一个文件的编译具体过程，新建 Demo.m</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>int main(){<br>    @autoreleasepool {<br>        NSLog(@”%@”,@”Hello Leo”);<br>    }<br>    return 0;<br>}</p>
<p>然后终端输入：</p>
<p>~ $ cd /Users/dubin/Desktop/Demo/Demo<br>Demo $<br>Demo $ clang -ccc-print-phases -framework Foundation Demo.m -o Demo<br>0: input, “Foundation”, object<br>1: input, “Demo.m”, objective-c<br>2: preprocessor, {1}, objective-c-cpp-output  // 预处理<br>3: compiler, {2}, ir                          // 编译生成 IR（中间代码）<br>4: backend, {3}, assembler                    // 汇编器生成汇编代码<br>5: assembler, {4}, object                     // 生成机器码<br>6: linker, {0, 5}, image                      // 链接<br>7: bind-arch, “x86_64”, {6}, image            // 生成 Image，也就是最后的可执行文件</p>
<p>在终端运行这个程序：</p>
<p>Demo $ gcc -framework Foundation Demo.m -o Demo<br>$ ./Demo<br>2019-03-27 13:55:30.426 Demo[14155:5478670] Hello Leo</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9a33d4c189414790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>
<p>另一种终端运行 OC 程序的顺序：</p>
<p>Demo $ cc -c Demo.m<br>Demo $ cc Demo.o -framework Foundation<br>ld: warning: text-based stub file /System/Library/Frameworks//Foundation.framework/Foundation.tbd and library file /System/Library/Frameworks//Foundation.framework/Foundation are out of sync. Falling back to library file for linking.<br>ld: warning: text-based stub file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation.tbd and library file /System/Library/Frameworks//CoreFoundation.framework/Versions/A/CoreFoundation are out of sync. Falling back to library file for linking.<br>Demo $ ./a.out<br>2019-03-27 14:01:52.933 a.out[14413:5483194] Hello Leo</p>
<p>cc -c tst.m    编译：生成 tst.o文件</p>
<p>cc -c man.m        编译： 生成 man.o 文件</p>
<p>cc tst.o man.o -framework Foundation  链接、合并：生成 a.out 可执行文件</p>
<p>./a.out 运行</p>
<p>当然 OC 程序还可以混编 C 程序，格式为：cc -c x.m x.c，或者直接将编译和链接合在一起：cc x.m x.c</p>
<p>1、编译器前端</p>
<p>编译器前端的任务是：语法分析、语义分析、生成中间代码（intermediate representation）。在这个过程中会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-eba0d4d3a3fbec8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3"></p>
<p>2、编译器后端</p>
<p>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS 的编译过程，后端的处理如下</p>
<p>①、LVVM 优化器会进行 BitCode 的生成，链接期优化等等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7fc3096f9cf495e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4"></p>
<p>②、LLVM 机器码生成器会针对不同的架构，比如 arm64 等生成不同的机器码。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-2037b2a6480b4d2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p>
<h5 id="三、执行一次-XCode-build-的流程"><a href="#三、执行一次-XCode-build-的流程" class="headerlink" title="三、执行一次 XCode build 的流程"></a>三、执行一次 XCode build 的流程</h5><p>当你在 XCode 中，选择 build 的时候（快捷键 command+B），会执行如下过程</p>
<ul>
<li>编译信息写入辅助文件，创建编译后的文件架构（name.app）</li>
<li>处理文件打包信息，例如在 debug 环境下</li>
</ul>
<p>Entitlements:<br>{<br>    “application-identifier” = “app的bundleid”;<br>    “aps-environment” = development;<br>}</p>
<ul>
<li>执行 CocoaPod 编译前脚本。例如对于使用 CocoaPod 的工程会执行 CheckPods Manifest.lock</li>
<li>编译各个 .m 文件，使用 CompileC 和 clang 命令。</li>
</ul>
<p>CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler<br>export LANG=en_US.US-ASCII<br>export PATH=”…”<br>clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I 上文提到的文件 -F 所需要的Framework  -iquote 所需要的Framework  … -c ClassName.c -o ClassName.o</p>
<p>通过这个编译的命令，我们可以看到</p>
<p>clang是实际的编译命令<br>-x         objective-c 指定了编译的语言<br>-arch     x86_64制定了编译的架构，类似还有arm7等<br>-fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。<br>-Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项<br>-DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译<br>-iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本<br>-I 把编译信息写入指定的辅助文件<br>-F 链接所需要的Framework<br>-c ClassName.c 编译文件<br>-o ClassName.o 编译产物</p>
<ul>
<li>链接需要的 Framework，例如 Foundation.framework、AFNetworking.framework、AliPay.framework</li>
<li>编译 xib 文件</li>
<li>拷贝 xib，图片等资源文件到结果目录</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝 Swift 标准库</li>
<li>创建 .app 文件和对其签名</li>
</ul>
<h5 id="四、ipa-包的内容"><a href="#四、ipa-包的内容" class="headerlink" title="四、ipa 包的内容"></a>四、ipa 包的内容</h5><p>例如，通过 iTunes Store 下载微信，获得 ipa 安装包，然后实际看看其安装包的内容。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-475c1b17e4bc6ae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6"></p>
<ul>
<li>右键 ipa，重命名为 .zip</li>
<li>双击 zip 文件，解压缩后会得到一个文件夹。所以，ipa 包就是一个普通的压缩包。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a17d16dddf291011.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"></p>
<ul>
<li>右键图中的 `WeChat`，选择显示包内容，然后就能够看到实际的 ipa 包内容了。</li>
</ul>
<h5 id="五、二进制文件的内容"><a href="#五、二进制文件的内容" class="headerlink" title="五、二进制文件的内容"></a>五、二进制文件的内容</h5><p>通过 XCode 的 Link Map File，我们可以窥探二进制文件中布局。在 XCode -&gt; Build Settings -&gt; 搜索 map -&gt; 开启Write Link Map File。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ad796aa51811238f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>开启后，在编译，我们可以在对应的 Debug/Release 目录下看到对应的 link map 的 text 文件。</p>
<p>默认的目录：</p>
<p>~/Library/Developer/Xcode/DerivedData/<target-name>-对应ID/Build/Intermediates/<target-name>.build/Debug-iphoneos/<target-name>.build/</target-name></target-name></target-name></p>
<p>例如 TargetName是 Demo 的目录：</p>
<p>/Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9879ec4e25c96df9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9"></p>
<p>这个映射文件的主要包含以下部分：</p>
<p>1、Object files</p>
<p>这个部分包括的内容：</p>
<ul>
<li>.o 文文件，也就是上文提到的 .m 文件编译后的结果。</li>
<li>.a 文件</li>
<li>需要 link 的 framework</li>
</ul>
<p># Arch: x86_64<br># Object files:<br>[  0] linker synthesized<br>[  1] dtrace<br>[  2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o<br>[  3] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/ViewController.o<br>[  4] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/Person.o<br>[  5] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyOperation.o<br>[  6] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/main.o</p>
<p>[130] /Applications/Xcode10.1.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.1.sdk/System/Library/Frameworks//CoreGraphics.framework/CoreGraphics.tbd</p>
<p>这个区域的存储内容比较简单：前面是文件的编号，后面是文件的路径。文件的编号在后续会用到。</p>
<p>2、Sections</p>
<p>这个区域提供了各个段（Segment）和节（Section）在可执行文件中的位置和大小。这个区域完整的描述了可执行文件中的全部内容。其中，段分为两种：</p>
<ul>
<li>__TEXT 代码段</li>
<li>__DATA 数据段</li>
</ul>
<p>从 Sections 区域可以看到，代码段的 <strong>text 节的地址是 0x100001000，大小是 0x000A5FF9，而二者相加的下一个位置正好是 </strong>stubs 的位置 0x1000A6FFA。</p>
<p># Sections:<br># 位置           大小            段       节<br># Address       Size            Segment Section<br>0x100001000    0x000A5FF9    __TEXT    __text             // 代码<br>0x1000A6FFA    0x000003D8    __TEXT    __stubs<br>0x1000A73D4    0x00000678    __TEXT    __stub_helper<br>0x1000A7A4C    0x0000794A    __TEXT    __objc_methname    // OC 方法名<br>0x1000AF396    0x000079F4    __TEXT    __cstring          // 字符串<br>0x1000B6D8A    0x0000092C    __TEXT    __objc_classname   // OC 类名<br>0x1000B76B6    0x00002293    __TEXT    __objc_methtype    // OC 方法类型<br>0x1000B9950    0x000000E8    __TEXT    __const            // 常量<br>0x1000B9A38    0x000043DC    __TEXT    __gcc_except_tab<br>0x1000BDE14    0x0000004A    __TEXT    __ustring<br>0x1000BDE5E    0x00000166    __TEXT    __entitlements<br>0x1000BDFC4    0x0000037B    __TEXT    __dof_RACSignal<br>0x1000BE33F    0x000002E8    __TEXT    __dof_RACCompou<br>0x1000BE628    0x000009CC    __TEXT    __unwind_info<br>0x1000BF000    0x00000010    __DATA    __nl_symbol_ptr<br>0x1000BF010    0x000001B8    __DATA    __got<br>0x1000BF1C8    0x00000520    __DATA    __la_symbol_ptr<br>0x1000BF6E8    0x00005D28    __DATA    __const<br>0x1000C5410    0x00002E80    __DATA    __cfstring<br>0x1000C8290    0x00000268    __DATA    __objc_classlist   // OC 方法列表<br>0x1000C84F8    0x000001C0    __DATA    __objc_catlist<br>0x1000C86B8    0x00000098    __DATA    __objc_protolist   // OC 协议列表<br>0x1000C8750    0x00000008    __DATA    __objc_imageinfo<br>0x1000C8758    0x0000F0C0    __DATA    __objc_const       // OC 常量<br>0x1000D7818    0x00001B28    __DATA    __objc_selrefs<br>0x1000D9340    0x00000040    __DATA    __objc_protorefs<br>0x1000D9380    0x00000360    __DATA    __objc_classrefs<br>0x1000D96E0    0x00000170    __DATA    __objc_superrefs   // OC 父类引用<br>0x1000D9850    0x00000610    __DATA    __objc_ivar        // OC ivar<br>0x1000D9E60    0x00001810    __DATA    __objc_data<br>0x1000DB670    0x00000768    __DATA    __data<br>0x1000DBDD8    0x0000015F    __DATA    __bss</p>
<p>3、Symbols</p>
<p>Section 部分将二进制文件进行了一级划分。而 Symbols 对 Section 中的各个段进行了二级划分，例如，对于 __TEXT __text 表示代码段中的代码内容。</p>
<p>0x100001000    0x000A5FF9    __TEXT    __text             // 代码</p>
<p>而对应的 Symbols，起始地址也是 0x1000021B0。其中，文件编号和上文的编号对应</p>
<p>0x100001000    0x000000A0    [  2] +[MyProxy proxyWithObj:]</p>
<p>[ 2] /Users/cykj/Library/Developer/Xcode/DerivedData/Demo-bifdsullasutjrbgiiywunmnlmjf/Build/Intermediates.noindex/Demo.build/Debug-iphonesimulator/Demo.build/Objects-normal/x86_64/MyProxy.o </p>
<p>具体内容：</p>
<p># Symbols:<br># 地址           大小            文件编号 方法名<br># Address    Size        File  Name<br>0x100001000    0x000000A0    [  2] +[MyProxy proxyWithObj:]<br>0x1000010A0    0x00000040    [  2] -[MyProxy methodSignatureForSelector:]<br>0x1000010E0    0x000003F0    [  2] -[MyProxy forwardInvocation:]<br>0x1000014D0    0x00000040    [  2] -[MyProxy .cxx_destruct]<br>0x100001510    0x00000048    [  2] -[Dog barking:]<br>0x100001560    0x00000060    [  3] -[ViewController dealloc]<br>0x1000015C0    0x000001C0    [  3] -[ViewController drawImage:<br>…</p>
<p>到这里，我们知道 OC 的方法是如何存储的，再来看看 ivar 是如何存储的。</p>
<p>首先找到数据栈中 __DATA __objc_ivar</p>
<p>0x1000D9850    0x00000610    __DATA    __objc_ivar</p>
<p>然后，搜索这个地址 0x1000D9850，就能找到 ivar 的存储区域。</p>
<p>0x1000D9850    0x00000008    [  2] _OBJC_IVAR_$_MyProxy.__innerObj</p>
<p>值得一提的是，对于 String，会显式的存储到数据段中，例如：</p>
<p>0x1000AF3F2    0x00000004    [  3] literal string: <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p>
<p>所以，若果你的加密 Key 以明文的形式写在文件里，是一件很危险的事情。</p>
<h5 id="六、dSYM-文件"><a href="#六、dSYM-文件" class="headerlink" title="六、dSYM 文件"></a>六、dSYM 文件</h5><p>在每次编译过后，都会生成一个 dsym 文件。dsym 文件中，存储了 16 进制的函数地址映射。</p>
<p>在 App 实际执行的二进制文件中，是通过地址来调用方法的。在 App crash 的时候，第三方工具（Fabric、友盟等）会帮我们抓到崩溃的调用栈，调用栈里会包含 crash 地址的调用信息。然后通过 dSYM 文件，我们就可以由地址映射到具体的函数位置。</p>
<p>XCode 中选择 Window -&gt; Organizer 可以看到生成的 archier 文件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-6d216b1dd05b7413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10"></p>
<p>然后</p>
<ul>
<li>右键 -> 在 finder 中显示。</li>
<li>右键 -> 查看包内容。</li>
</ul>
<p>关于如何用 dsym 文件来分析崩溃位置，查看另一篇博客：<a href="http://blog.csdn.net/hello_hwc/article/details/50036323" target="_blank" rel="noopener">iOS 如何调试第三方统计到的崩溃报告</a></p>
<h5 id="七、应用场景"><a href="#七、应用场景" class="headerlink" title="七、应用场景"></a>七、应用场景</h5><p>1、__attribute__</p>
<p>或多或少都会在第三方库或者 iOS 的头文件中，见到过 __attribute__。比如</p>
<p>__attribute__ ((warn_unused_result)) // 如果没有使用返回值，编译的时候给出警告</p>
<p>__attribtue__ 是一个高级的的编译器指令，它允许开发者指定更多的编译检查和一些高级的编译期优化。</p>
<p>分为三种：</p>
<ul>
<li>函数属性（Function Attribute）</li>
<li>类型属性（Variable Attribute）</li>
<li>变量属性（Type Attribute）</li>
</ul>
<p>语法结构</p>
<p>__attribute__ 语法格式为：__attribute__ ((attribute-list))</p>
<p>放在声明分号 “;” 前面。</p>
<p>比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了。</p>
<p>@property (nonatomic, strong) CLASSNAME * property __deprecated;</p>
<p>好处：</p>
<p>给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的 API，但是被 __deprecated 的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新 Pod 的时候，代码无法运行了。</p>
<p>__attribtue__ 的使用场景很多，本文只列举 iOS 开发中常用的几个：</p>
<p>// 弃用 API，用作 API 更新</p>
<p>#define __deprecated    __attribute__((deprecated)) </p>
<p>// 带描述信息的弃用</p>
<p>#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))</p>
<p>// 遇到 __unavailable 的变量/方法，编译器直接抛出 Error</p>
<p>#define __unavailable    __attribute__((unavailable))</p>
<p>// 告诉编译器，即使这个变量/方法没被使用，也不要抛出警告</p>
<p>#define __unused    __attribute__((unused))</p>
<p>// 和 __unused 相反</p>
<p>#define __used        __attribute__((used))</p>
<p>// 如果不使用方法的返回值，进行警告</p>
<p>#define __result_use_check __attribute__((__warn_unused_result__))</p>
<p>// OC 方法在 Swift 中不可用</p>
<p>#define __swift_unavailable(_msg)    __attribute__((__availability__(swift, unavailable, message=_msg)))</p>
<p>2、Clang 警告处理</p>
<p>你一定还见过如下代码：</p>
<p>#pragma clang diagnostic push</p>
<p>#pragma clang diagnostic ignored “-Wundeclared-selector”<br>/// 代码</p>
<p>#pragma clang diagnostic pop</p>
<p>这段代码的作用是</p>
<ol>
<li>对当前编译环境进行压栈</li>
<li>忽略 -Wundeclared-selector（未声明的）Selector 警告</li>
<li>编译代码</li>
<li>对编译环境进行出栈</li>
</ol>
<p>通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<p>在另一篇文章：<a href="http://blog.csdn.net/Hello_Hwc/article/details/46425503" target="_blank" rel="noopener">iOS 合理利用 Clang 警告来提高代码质量</a>，详细的介绍了 XCode 的警告相关内容。</p>
<p>3、预处理</p>
<p>所谓预处理，就是在编译之前的处理。预处理能够让你定义编译器变量，实现条件编译。</p>
<p>比如，这样的代码很常见</p>
<p>#ifdef DEBUG<br>//…</p>
<p>#else<br>//…</p>
<p>#endif</p>
<p>我们同样也可以定义其他预处理变量，在 XCode -&gt; 选中 Target -&gt; build settings 中，搜索 preprocessor。可以分别为 Debug 和 Release 两种模式设置预处理宏。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f44b0523ec2d7d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"></p>
<p>比如加上：TESTMODE = 1，表示在这个宏中的代码运行在测试服务器。</p>
<p>然后，配合多个 Target（右键 Target，选择 Duplicate），单独一个 Target 负责测试服务器。这样就不用每次切换测试服务器都要修改代码了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9e591436b1f5e436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"></p>
<p>#ifdef TESTMODE<br>// 测试服务器相关的代码</p>
<p>#else<br>// 生产服务器相关代码</p>
<p>#endif</p>
<p>4、插入脚本</p>
<p>通常，如果你使用 CocoaPod 来管理三方库，那么你的 Build Phase 是这样子的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-cbf92c80a034e8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13"></p>
<p>其中：[CP] 开头的就是 CocoaPod 插入的脚本。</p>
<ul>
<li>Check Pods Manifest.lock，用来检查 cocoapod 管理的三方库是否需要更新</li>
<li>Embed Pods Framework，运行脚本来链接三方库的静态/动态库</li>
<li>Copy Pods Resources，运行脚本来拷贝三方库的资源文件</li>
</ul>
<p>而这些配置信息都存储在这个文件（.xcodeproj）里。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-204e1892f65add4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14"></p>
<p>到这里，CocoaPod 的原理也就大致搞清楚了，通过修改 xcodeproject，然后配置编译期脚本，来保证三方库能够正确的编译连接。</p>
<p>同样，我们也可以插入自己的脚本来做一些额外的事情。比如，每次进行 archive 的时候，我们都必须手动调整 target 的 build 版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。</p>
<p>buildNumber=$(/usr/libexec/PlistBuddy -c “Print CFBundleVersion” “${PROJECT_DIR}/${INFOPLIST_FILE}”)<br>buildNumber=$(($buildNumber + 1))<br>/usr/libexec/PlistBuddy -c “Set :CFBundleVersion $buildNumber” “${PROJECT_DIR}/${INFOPLIST_FILE}”</p>
<p>这段脚本其实很简单，读取当前 plist 的 build 版本号，然后对其 +1，重新写入。</p>
<p>使用起来也很简单：</p>
<ul>
<li>Xcode -&gt; 选中 Target -&gt; 选中 build phase</li>
<li>选择添加 Run Script Phase</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-7390774f5a869394.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"></p>
<ul>
<li>然后把这段脚本拷贝进去，并且勾选 Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为 Auto Increase build number</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-1bbe50512c4a785c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16"></p>
<ul>
<li>然后，拖动这个脚本的到 Link Binary With Libraries 下面。</li>
</ul>
<p>5、脚本编译打包</p>
<p>脚本化编译打包对于 CI（持续集成）来说，十分有用。iOS 开发中，编译打包必备的两个命令是：</p>
<p>// 编译成.app<br>xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir<br>// 打包<br>xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</p>
<p>// 通过 info 命令，可以查看到详细的文档<br>info xcodebuild</p>
<p>在本文最后的附录中，提供一个自动打包的脚本。</p>
<p>6、提高项目编译速度</p>
<p>通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了 XCode 的编译过程后，我们可以从以下角度来优化编译速度。</p>
<p>①、查看编译时间</p>
<p>我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。</p>
<p>对于 XCode 8，关闭 XCode，终端输入以下指令</p>
<p>$ defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</p>
<p>然后，重启 XCode，再编译，你会在这里看到编译时间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-699c09578e290bc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="17"></p>
<p>②、代码层面的优化</p>
<ul>
<li>forward declaration</li>
</ul>
<p>所谓 forward declaration，就是 @class CLASSNAME，而不是 #import CLASSNAME.h。这样，编译器能大大提高 #import 的替换速度。</p>
<ul>
<li>对常用的工具类进行打包（Framework/.a）</li>
</ul>
<p>打包成 Framework 或者静态库，这样编译的时候这部分代码就不需要重新编译了。</p>
<ul>
<li>常用头文件放到预编译文件里</li>
</ul>
<p>pch 文件是预编译文件，这里的内容在执行 XCode build 之前就已经被预编译，并且引入到了每一个 .m 文件里。</p>
<p>③、编译器选项优化</p>
<ul>
<li>Debug 模式下，不生成 dsym 文件</li>
</ul>
<p>上文提到了，dysm 文件里存储了调试信息，在 Debug 模式下，我们可以借助 XCode 和 LLDB 进行调试。所以，不需要生成额外的 dsym 文件来降低编译速度。</p>
<ul>
<li>Debug 开启 Build Active Architecture Only</li>
</ul>
<p>在 XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为 YES。这样做，可以只编译当前的版本，比如 arm7/arm64 等等，记得只开启 Debug 模式。这个选项在高版本的 XCode 中自动开启了。</p>
<ul>
<li>Debug 模式下，关闭编译器优化</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-69b06dd791e83926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="18"></p>
<h5 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h5><p>自动编译打包脚本</p>
<p>export LC_ALL=zh_CN.GB2312;<br>export LANG=zh_CN.GB2312<br>buildConfig=”Release” //这里是build模式<br>projectName=`find . -name *.xcodeproj | awk -F “[/.]“ ‘{print $(NF-1)}’`<br>projectDir=`pwd`<br>wwwIPADir=~/Desktop/$projectName-IPA<br>isWorkSpace=true<br>echo “<del>~</del><del>~</del><del>~</del><del>~~开始编译</del><del>~</del><del>~</del><del>~</del>~~”<br>if [ -d “$wwwIPADir” ]; then<br>echo $wwwIPADir<br>echo “文件目录存在”<br>else<br>echo “文件目录不存在”<br>mkdir -pv $wwwIPADir<br>echo “创建${wwwIPADir}目录成功”<br>fi<br>cd $projectDir<br>rm -rf ./build<br>buildAppToDir=$projectDir/build<br>infoPlist=”$projectName/Info.plist”<br>bundleVersion=<code>/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlist</code><br>bundleIdentifier=<code>/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlist</code><br>bundleBuildVersion=<code>/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist</code></p>
<p>if $isWorkSpace ; then  #是否用CocoaPod<br>echo  “开始编译workspace….”<br>xcodebuild  -workspace $projectName.xcworkspace -scheme $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir<br>else<br>echo  “开始编译target….”<br>xcodebuild  -target  $projectName  -configuration $buildConfig clean build SYMROOT=$buildAppToDir<br>fi</p>
<p>if test $? -eq 0<br>then<br>echo “<del>~</del><del>~</del><del>~</del><del>~~编译成功</del><del>~</del><del>~</del><del>~</del><del>“<br>else<br>echo “</del><del>~</del><del>~</del><del>~</del><del>编译失败</del><del>~</del><del>~</del><del>~</del>~~”<br>exit 1<br>fi</p>
<p>ipaName=`echo $projectName | tr “[:upper:]“ “[:lower:]“` #将项目名转小写<br>findFolderName=`find . -name “$buildConfig-*” -type d |xargs basename` #查找目录<br>appDir=$buildAppToDir/$findFolderName/  #app所在路径<br>echo “开始打包$projectName.app成$projectName.ipa…..”<br>xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa</p>
<p>if [ -f “$appDir/$ipaName.ipa” ]<br>then<br>echo “打包$ipaName.ipa成功.”<br>else<br>echo “打包$ipaName.ipa失败.”<br>exit 1<br>fi</p>
<p>path=$wwwIPADir/$projectName$(date +%Y%m%d%H%M%S).ipa<br>cp -f -p $appDir/$ipaName.ipa $path   #拷贝ipa文件<br>echo “复制$ipaName.ipa到${wwwIPADir}成功”<br>echo “<del>~</del><del>~</del><del>~</del><del>~~结束编译，处理成功</del><del>~</del><del>~</del><del>~</del>~~”</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/27/ios-e7-bc-96-e8-af-91-e8-bf-87-e7-a8-8b-e5-8e-9f-e7-90-86/">http://yoursite.com/2019/03/27/ios-e7-bc-96-e8-af-91-e8-bf-87-e7-a8-8b-e5-8e-9f-e7-90-86/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/27/e5-bf-83-e8-b7-b3-e4-bf-9d-e6-b4-bb/" class="pre"> 心跳保活		</a><a href="/2019/03/27/runtime2/" class="next"> Runtime(2)		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、iOS-编译"><span class="toc-text">二、iOS 编译</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、执行一次-XCode-build-的流程"><span class="toc-text">三、执行一次 XCode build 的流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、ipa-包的内容"><span class="toc-text">四、ipa 包的内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、二进制文件的内容"><span class="toc-text">五、二进制文件的内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、dSYM-文件"><span class="toc-text">六、dSYM 文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、应用场景"><span class="toc-text">七、应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八、附录"><span class="toc-text">八、附录</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>