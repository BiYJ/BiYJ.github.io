<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> Runtime(2)		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> Runtime(2)		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> Runtime(2)		</h1><div class="post-meta"><a href="/2019/03/27/runtime2/#comments" class="comment-count"></a><p><span class="date">Mar 27, 2019</span><span><a href="/categories/底层原理/" class="category">底层原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="https://www.cnblogs.com/ioshe/p/5489086.html" target="_blank" rel="noopener">iOS开发-Runtime 详解</a>、<a href="https://www.jianshu.com/p/26c41f48267d" target="_blank" rel="noopener">iOS RunTime 之数据结构</a>、<a href="https://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">iOS 模块分解—「Runtime面试、工作」</a>、<a href="http://www.opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Runtime 源码</a></p>
<h5 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h5><p>C++ 是基于静态类型，而 Objective-C 是基于动态运行时类型。用 C++ 编写的程序通过编译器直接把函数地址硬编码进入可执行文件；Objective-C 则不能，而是在程序运行的时，利用 Runtime 根据条件判断作出决定。函数标识与函数实现之间的关联可以动态修改。Runtime 是 Objective 不可缺少的重要一部分。</p>
<p>Runtime 又叫运行时，是一个用 C 和汇编编写的动态库，平时编写的 Objc 代码，底层都是基于它来实现的。它将 OC 和 C 紧密关联并提供动态特性，这个系统主要做两件事：</p>
<p>1、封装 C 语言的结构体和函数，让开发者在运行时创建、检查或者修改类、对象和方法等。</p>
<p>2、传递消息，找出方法的最终执行代码。</p>
<p>①、静态类型编程语言在编译期就确定了函数的地址，OC 的方法调用（消息发送）是运行时动态确定（代价是性能下降，objc_class 中的 objc_cache 就是用来补偿这种性能下降的）；<br>②、类层次体系查找（isa + objc_method_list）+ 消息转发（动态解析 => 备用接收者 => 签名+打包+完整转发）</p>
<blockquote>
<p>动态加载：<a href="https://link.jianshu.com/?t=https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSBundle_Class/index.html#//apple_ref/occ/cl/NSBundle" target="_blank" rel="noopener">NSBundle</a>类提供了许多面向对象的便捷接口用于动态加载；比如 Retina 设备自动加载 @2x 的图片。</p>
</blockquote>
<p>[receiver message];<br>// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector)<br>[receiver message:(id)arg…];<br>// 底层运行时会被编译器转化为：objc_msgSend(receiver, selector, arg1, arg2, …)</p>
<p>也就是说，有很多类和成员变量在编译时是不知道的，而在运行时，编写的代码会转换成完整的确定的代码运行。因此，只有编译器是不够的，我们还需要一个运行时系统（Runtime system）来处理编译后的代码。</p>
<h5 id="二、作用"><a href="#二、作用" class="headerlink" title="二、作用"></a>二、作用</h5><p>Objc 与 Runtime 相关：</p>
<p>①、通过 Objective-C 源代码<br>②、通过 Foundation 框架的 NSObject 类定义的方法<br>③、通过对 Runtime 库函数的直接调用</p>
<p>1、Objective-C 源代码</p>
<p>多数情况开发者只需要编写 Objc 代码即可，Runtime 系统自动在幕后搞定一切，就像简介中调用方法一样，编译器会将 Objc 代码转换成运行时代码，在运行时确定数据结构和函数。</p>
<p>2、通过 Foundation 框架的 NSObject 类定义的方法</p>
<p>Cocoa 程序中绝大部分类都是继承了 NSObject 的行为的子类。（NSProxy 是个抽象超类）</p>
<p>NSObject 类有时仅仅定义了完成某件事情的模板，并没有提供实现的代码。例如 -description 方法，该方法返回类内容的字符串表示，用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址。</p>
<p>一些 NSObject 的方法可以从 Runtime 系统中获取信息，允许对象进行自我检查。例如：</p>
<ul>
<li>-class 方法返回对象的类；</li>
<li>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中</li>
<li>-respondsToSelector: 检查对象能否响应指定的消息；</li>
<li>-conformsToProtocol: 检查对象是否实现了指定协议类的方法；</li>
<li>-methodForSelector: 返回指定方法实现的地址。</li>
</ul>
<p>3、通过对 Runtime 库函数的直接调用</p>
<p>Runtime 系统是具有公共接口的动态共享库。头文件存放于 /usr/include/objc 目录下，使用时 #import &lt;objc/Runtime.h&gt; 头文件即可。</p>
<p>许多函数可以让你使用纯 C 代码来实现 Objc 中同样的功能。除非是写一些 Objc 与其他语言的桥接或是底层的 debug 工作，否则一般不会用到这些 C 语言函数。</p>
<h5 id="三、术语及其数据结构"><a href="#三、术语及其数据结构" class="headerlink" title="三、术语及其数据结构"></a>三、术语及其数据结构</h5><p><strong>SEL</strong></p>
<p>它是 selector 在 Objc 中的表示（Swift 中是 Selector 类）。selector 是方法选择器，本质上是一个根据方法名 hash 化了的 key 值，为了加快查询方法实现的速度。它的数据结构是：</p>
<p>typedef struct objc_selector *SEL;  // An opaque type that represents a method selector.</p>
<p>可以看出它是个映射到方法的 C 字符串，你可以通过 Objc 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获取一个 SEL 类型的方法选择器。</p>
<blockquote>
<p>注意：不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。</p>
</blockquote>
<p><strong>id</strong></p>
<p>id 是一个参数类型，它是指向某个类的实例的指针。定义如下：</p>
<p>typedef struct objc_object *id;<br>struct objc_object { Class isa; };</p>
<p>objc_object 结构体包含一个 isa 指针，根据 isa 指针就可以找到对象所属的类。</p>
<blockquote>
<p>注意：isa 指针在代码运行时并不总指向实例对象所属的类型，所以不能用它来确定类型。可以用对象的 -class 方法和 Runtime 的 object_getClass() 方法。</p>
<p>Direct access to Objective-C’s isa is deprecated in favor of object_getClass()</p>
</blockquote>
<p><a href="http://lizhaoloveit.com/2014/05/11/KVO/" target="_blank" rel="noopener">KVO</a> 的实现机理就是将被观察对象的 isa 指针指向一个中间类而不是真实类型。</p>
<p><strong>Class</strong></p>
<p>typedef struct objc_class *Class;</p>
<p>Class 其实是指向 objc_class 结构体的指针。objc_class 的数据结构如下：</p>
<p>struct objc_class {<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !__OBJC2__<br>    /*  父类  <em>/<br>    Class _Nullable super_class                              OBJC2_UNAVAILABLE;<br>    /\</em>  类名  <em>/<br>    const char </em> _Nonnull name                               OBJC2_UNAVAILABLE; </p>
<pre><code>/\* 类的版本信息，默认为 0 */
long version                                             OBJC2_UNAVAILABLE;

/\* 类信息，供运行时期使用的一些位标识。

   如 CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;
     CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;
 */ 
long info                                                OBJC2_UNAVAILABLE;

/\* 实例变量大小（包括从父类继承下来的实例变量）*/
long instance\_size                                       OBJC2\_UNAVAILABLE;  

/\* 成员变量地址列表 */
struct objc\_ivar\_list * \_Nullable ivars                  OBJC2\_UNAVAILABLE; 

/\* 方法地址列表，与 info 的一些标志位有关。

   如 CLS\_CLASS (0x1L)，则存储实例方法；CLS\_META (0x2L)，则存储类方法;
 */
struct objc\_method\_list * \_Nullable * \_Nullable methodLists   OBJC2_UNAVAILABLE;

/\* 缓存最近使用的方法地址，用于提升效率 */
struct objc\_cache * \_Nonnull cache                       OBJC2_UNAVAILABLE; 

/\* 存储该类声明遵守的协议的列表 */
struct objc\_protocol\_list * \_Nullable protocols          OBJC2\_UNAVAILABLE;  
</code></pre><p>#endif</p>
<p>} OBJC2_UNAVAILABLE;</p>
<p>从 objc_class 可以看到：一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。</p>
<p>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：</p>
<p>// 成员变量列表<br>struct objc_ivar_list {<br>    int ivar_count                                           OBJC2_UNAVAILABLE;</p>
<p>#ifdef __LP64__<br>    int space                                                OBJC2_UNAVAILABLE;</p>
<p>#endif<br>    /* variable length structure */<br>    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;<br>}                                                            OBJC2_UNAVAILABLE;</p>
<p>// 方法列表<br>struct objc_method_list {<br>    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</p>
<pre><code>int method\_count                                         OBJC2\_UNAVAILABLE;
</code></pre><p>#ifdef __LP64__<br>    int space                                                OBJC2_UNAVAILABLE;</p>
<p>#endif<br>    /* variable length structure */<br>    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;<br>}</p>
<p>由此可见，我们可以动态修改 methodList 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因。<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解 Objective-C: Category</a>。</p>
<p>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p>
<p>值得注意的是，由 objc_object 和 objc_class 的代码可以看出，objc_class 中也有一个 isa 指针，这说明 objc_class 也是一个对象，分别称作类对象（class object）和实例对象（instance object）。</p>
<blockquote>
<p>实例对象 objc_object 的 isa 指针指向的类结构称为 class，也就是该对象所属的类，其中存放着普通成员变量与动态方法（” - “ 开头的方法）；</p>
<p>类对象 objc_class 的 isa 指针指向的类结构称为 meta class，其中存放着 static 类型的成员变量与 static 类型的方法（” + “ 开头的方法）。</p>
</blockquote>
<p>为了处理类和对象的关系，Runtime 库创建了 Meta Class (元类) ，类对象所属的类 Class 就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p>
<p>开发者所熟悉的类方法，就源自于 Meta Class。可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p>当调用 +alloc 的消息时，这个消息实际上被发送给了一个类对象（Class Object），这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类（Root Meta Class）的实例。所有元类的 isa 指针最终都指向根元类。</p>
<p>[NSObject.class alloc];    // [NSObject alloc]</p>
<p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-f45adc9fd1faea0b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Meta Class"></p>
<p>实线是 super_class 指针，虚线是 isa 指针。而根元类的父类是 NSObject，isa 指向了自己，NSObject 没有父类。</p>
<p>最后 objc_class 中还有一个 objc_cache 缓存，它的作用很重要，后面会提到。</p>
<p><strong>Method</strong></p>
<p>代表类中某个方法的类型。</p>
<p>typedef struct objc_method *Method;</p>
<p>struct objc_method {<br>    SEL _Nonnull method_name            OBJC2_UNAVAILABLE;   // 方法名<br>    char * _Nullable method_types       OBJC2_UNAVAILABLE;   // 方法类型<br>    IMP _Nonnull method_imp             OBJC2_UNAVAILABLE;   // 方法实现<br>}      </p>
<ul>
<li>method_name 类型为 SEL</li>
<li>method_types 是个 char 指针，存储方法的参数类型和返回值类型</li>
<li>method_imp 指向了方法的实现，本质是一个函数指针</li>
</ul>
<p><strong>Ivar</strong></p>
<p>表示成员变量的类型。</p>
<p>typedef struct objc_ivar *Ivar;</p>
<p>struct objc_ivar {<br>    char <em> _Nullable ivar_name                OBJC2_UNAVAILABLE;<br>    char </em> _Nullable ivar_type                OBJC2_UNAVAILABLE;<br>    int ivar_offset                           OBJC2_UNAVAILABLE;   // 基地址偏移字节</p>
<p>#ifdef __LP64__<br>    int space                                 OBJC2_UNAVAILABLE;  // 占用空间</p>
<p>#endif<br>}    </p>
<p><strong>IMP</strong></p>
<p>objc.h 中定义如下：</p>
<p>// 参数 1 : 如果是实例方法，则是 self 的内存地址；如果是类方法，则是指向元类的指针<br>typedef id (*IMP)(id, SEL, …);</p>
<p>它就是一个由编译器生成的函数指针，指向方法实现的首地址。当你发起一个 ObjC 消息之后，最终它会执行哪段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<p>如果得到了执行某个实例某个方法的入口，就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p>
<p>你会发现 IMP 指向的方法与 objc_msgSend() 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id 和 SEL 参数就能确定唯一的方法实现地址。一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p>
<p><strong>Cache</strong></p>
<p>runtime.h 中定义如下：</p>
<p>typedef struct objc_cache *Cache</p>
<p>struct objc_cache {<br>    /* 指定分配 cache buckets 的总数。在方法查找中，Runtime 使用这个字段确定数组的索引位置。<em>/<br>    unsigned int mask /</em> total = mask + 1 */                 OBJC2_UNAVAILABLE;</p>
<pre><code>/\* 实际占用cache buckets的总数 */
unsigned int occupied                                    OBJC2_UNAVAILABLE;

/\*  指定 Method 数据结构指针的数组。这个数组可能包含不超过 mask + 1 个元素。

   指针可能是 NULL，表示这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。这个数组可能会随着时间而增长
 */
Method \_Nullable buckets\[1\]                              OBJC2\_UNAVAILABLE;
</code></pre><p>};</p>
<p>Cache 优化方法调用的性能。每当实例对象接收到一个消息时，优先在 Cache 中查找，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<p><strong>Property</strong></p>
<p>typedef struct objc_property <em>Property;<br>typedef struct objc_property </em>objc_property_t;  // 这个更常用</p>
<p>可以通过 class_copyPropertyList() 和 protocol_copyPropertyList() 方法获取类和协议中的属性：</p>
<p>OBJC_EXPORT objc_property_t _Nonnull <em> _Nullable<br>class_copyPropertyList(Class _Nullable cls, unsigned int </em> _Nullable outCount)<br>    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</p>
<p>OBJC_EXPORT objc_property_t _Nonnull <em> _Nullable<br>protocol_copyPropertyList(Protocol </em> _Nonnull proto,<br>                          unsigned int * _Nullable outCount)<br>    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</p>
<blockquote>
<p>返回的是属性列表，列表中每个元素都是一个 objc_property_t 指针。</p>
</blockquote>
<p>property_getName() 用来查找属性的名称，返回 c 字符串。<br>property_getAttributes() 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。<br>class_getProperty() 和 protocol_getProperty() 通过给出属性名在类和协议中获得属性的引用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e2cb59d1344df2d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类对象结构图"></p>
<h5 id="四、消息"><a href="#四、消息" class="headerlink" title="四、消息"></a>四、消息</h5><p>体会官方文档中的 messages aren’t bound to method implementations until Runtime。消息直到运行时才会与方法实现进行绑定。</p>
<p>这里要清楚一点，objc_msgSend() 方法看起来好像返回了数据，其实 objc_msgSend() 从不返回数据，而是方法在运行时被调用实现后才会返回数据。下面详细叙述消息发送的步骤：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-2d3464848b8f4fc2?imageMogr2/auto-orient/strip" alt="消息发送"></p>
<p>①、首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain、release 这些函数；</p>
<p>②、检测这个 selector 的 target 是不是 nil。Objc 允许对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。</p>
<p>③、如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。</p>
<p>④、如果 cache 找不到就找类的方法列表中是否有对应的方法。</p>
<p>⑤、如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。</p>
<p>⑥、如果还找不到，就要开始进入动态方法解析了，后面会提到。</p>
<p>在消息的传递中，编译器会根据情况在 objc_msgSend()、objc_msgSend_stret()、objc_msgSendSuper()、objc_msgSendSuper_stret() 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数；如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数发送消息和接收返回值。</p>
<p>1、方法中的隐藏参数</p>
<blockquote>
<p>我们经常使用关键字 self，但是 self 是如何获取当前方法的对象呢？</p>
</blockquote>
<p>其实，这也是 Runtime 系统的作用，self 是在方法运行时被动态传入的。</p>
<p>当 objc_msgSend() 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<ul>
<li>self 当前方法的对象指针，接受消息的对象</li>
<li>_cmd 当前方法的 SEL 指针，方法选择器</li>
</ul>
<p>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们是在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中，self 更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>这时我们可能会想到另一个关键字 super，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体：</p>
<p>struct objc_super {<br>    /// Specifies an instance of a class.<br>    __unsafe_unretained _Nonnull id receiver;</p>
<pre><code>/// Specifies the particular superclass of the instance to message. 
</code></pre><p>#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__<br>    /* For compatibility with old objc-runtime.h header */<br>    __unsafe_unretained _Nonnull Class class;</p>
<p>#else<br>    __unsafe_unretained _Nonnull Class super_class;</p>
<p>#endif<br>    /* super_class is the first class to search */<br>};</p>
<p>这个结构体指明了消息应该被传递给特定的父类。</p>
<p>receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper() 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p>
<p>NSLog(@”%@”, NSStringFromClass([super class]));</p>
<p>2018-11-05 11:30:25.082134+0800 Demo[22838:128408] ViewController   // 当前类</p>
<p>2、获取方法地址</p>
<p>NSObject 中有 - methodForSelector: 实例方法，你可以用它来获取某个方法选择器对应的 IMP：</p>
<p>{<br>     CFTimeInterval ti = CFAbsoluteTimeGetCurrent();</p>
<pre><code>for (int i = 0; i &lt; 10000; i++) {
     \[self fail:YES\];
}
NSLog(@&quot;%f&quot;, CFAbsoluteTimeGetCurrent() - ti);
</code></pre><p>}</p>
<p>- (void)fail:(BOOL)value<br>{</p>
<p>}</p>
<p>2018-11-05 13:06:22.683838+0800 Demo[36187:211037] 4.104993</p>
<p>{<br>     void (*setter)(id, SEL, BOOL) = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(fail:)];</p>
<pre><code>CFTimeInterval ti = CFAbsoluteTimeGetCurrent();

for (int i = 0; i &lt; 10000; i++) {
     setter(self, @selector(fail:), YES);
}
NSLog(@&quot;%f&quot;, CFAbsoluteTimeGetCurrent() - ti);
</code></pre><p>}</p>
<p>2018-11-05 13:05:48.480498+0800 Demo[36095:209893] 3.751424</p>
<p>虽然是更高效的调用方法，但这种做法很少用，除非是需要持续大量重复调用某个方法的情况，才会选择使用，以免消息发送泛滥。</p>
<blockquote>
<p>注意：methodForSelector: 方法是由 Runtime 系统提供的，而不是 Objc 自身的特性</p>
</blockquote>
<h5 id="五、动态方法解析"><a href="#五、动态方法解析" class="headerlink" title="五、动态方法解析"></a>五、动态方法解析</h5><p>如果用关键字 @dynamic 在 .m 文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认生成该属性的 setter 和 getter 方法。</p>
<p>@dynamic propertyName;</p>
<p>这时，可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p>
<p>Runtime 系统会在 Cache 和类、父类的方法列表中找不到要执行的方法时，会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给开发者一次动态添加方法实现的机会。</p>
<p>void dynamicIMP(id self, SEL _cmd) {<br>    // implementation ….<br>}</p>
<p>@implementation MyClass</p>
<p>+ (BOOL)resolveInstanceMethod:(SEL)aSEL<br>{<br>     if (aSEL == @selector(resolveThisMethodDynamically)) {<br>          class_addMethod([self class], aSEL, (IMP) dynamicIMP, “v@:”);<br>          return YES;<br>     }<br>     return [super resolveInstanceMethod:aSEL];<br>}</p>
<p>@end</p>
<p>上面为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicIMP 方法中的代码。其中 “v@:” 表示返回值和参数，这个符号表示的含义见：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p>
<blockquote>
<p>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让 aSEL 被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。</p>
</blockquote>
<h5 id="六、消息转发"><a href="#六、消息转发" class="headerlink" title="六、消息转发"></a>六、消息转发</h5><p><img src="https://upload-images.jianshu.io/upload_images/5294842-3f7a92a32f8cc7d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="消息转发"></p>
<p>①、通过 resolveInstanceMethod: 方法决定是否动态添加方法。如果返回 YES 则通过 class_addMethod() 动态添加方法，消息得到处理，结束；如果返回 NO，则进入下一步；</p>
<p>②、进入 forwardingTargetForSelector: 方法，用于指定备选对象响应这个selector，不能指定为 self。如果返回某个对象则会调用对象的方法，结束。如果返回 nil，则进入下一步；</p>
<p>③、通过 methodSignatureForSelector: 方法签名，如果返回 nil，则消息无法处理。如果返回 methodSignature，则进入下一步；</p>
<p>④、调用 forwardInvocation: 方法，可以通过 anInvocation 对象做很多处理，比如修改实现方法、修改响应对象等，如果方法调用成功，则结束。如果失败，则进入 doesNotRecognizeSelector 方法，若我们没有实现这个方法，那么就会 crash。</p>
<p>1、重定向</p>
<p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p>
<p>- (id)forwardingTargetForSelector:(SEL)aSelector<br>{<br>     if(aSelector == @selector(xxx:)){<br>          return otherObj;<br>     }<br>     return [super forwardingTargetForSelector:aSelector];<br>}</p>
<p>如果此方法返回 nil 或者 self，则会计入消息转发机制（forwardInvocation:），否则将向返回的对象重新发送消息。</p>
<p>2、转发</p>
<p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p>
<p>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector<br>{<br>     return [otherObj methodSignatureForSelector:aSelector];<br>}</p>
<p>/**<br> *  @param  anInvocation  封装了原始的消息和消息的参数<br> */<br>- (void)forwardInvocation:(NSInvocation *)anInvocation<br>{<br>     // 判断 otherObj 对象是否实现了方法<br>     if ([otherObj respondsToSelector:[anInvocation selector]]) {<br>          [anInvocation invokeWithTarget:otherObj];<br>     }<br>     else {<br>          [super forwardInvocation:anInvocation];<br>     }<br>}</p>
<p>开发者可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p>
<blockquote>
<p>参数 anInvocation 是从哪来的？</p>
<p>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送 methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</p>
</blockquote>
<p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是 NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p>
<p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的 “吃掉” 某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p>
<blockquote>
<p>forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们想往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation: 将不可能被调用。</p>
</blockquote>
<p>3、转发和多继承</p>
<p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者 “继承” 过来一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-70cda98ab8c42661?imageMogr2/auto-orient/strip" alt="转发和多继承"></p>
<p>在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。这使得在不同继承体系下的两个类可以实现继承对方的方法，消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p>
<p>4、转发与继承</p>
<p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p>
<p>如果判断上图中的 Warrior 对象是否能响应 negotiate 消息：</p>
<p>if ( [aWarrior respondsToSelector:@selector(negotiate)] )<br>    …</p>
<p>尽管 Warrior 能转发消息给 Diplomat 类响应消息，但返回依然是 NO。</p>
<p>如果想要让外界以为 Warrior 继承到了 Diplomat 的 negotiate 方法，可以重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p>
<p>- (BOOL)respondsToSelector:(SEL)aSelector<br>{<br>     if ( [super respondsToSelector:aSelector] )<br>          return YES;<br>     else {<br>          /* Here, test whether the aSelector message can     <em><br>           \</em> be forwarded to another object and whether that  <em><br>           \</em> object can respond to it. Return YES if it can.  */<br>     }<br>     return NO;<br>}</p>
<p>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样需要。</p>
<p>如果一个对象想要转发它接受的任何远程消息，那得重新实现 - methodSignatureForSelector: 返回准确的方法描述 ，这个方法会最终响应被转发的消息，从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。</p>
<h5 id="七、健壮的实例变量-Non-Fragile-ivars"><a href="#七、健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="七、健壮的实例变量(Non Fragile ivars)"></a>七、健壮的实例变量(Non Fragile ivars)</h5><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。</p>
<p>当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-9b75736c89991ff2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>上图左边是 NSObject 类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了 NSObject 类，发布新版本的系统的话，那就悲剧了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0ddfa1eb170bae83.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量（Fragile ivars）环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下会发生什么呢？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a4a0f676708f0a30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="健壮的实例变量自动偏移"></p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p>
<p>需要注意的是在健壮的实例变量下，不要使用 sizeof(cls)，而是用 class_getInstanceSize(cls) 代替；也不要使用 offsetof(cls, ivar)，而要用 ivar_getOffset(class_getInstanceVariable(cls, “ivar”)) 来代替。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/27/runtime2/">http://yoursite.com/2019/03/27/runtime2/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/27/ios-e7-bc-96-e8-af-91-e8-bf-87-e7-a8-8b-e5-8e-9f-e7-90-86/" class="pre"> iOS 编译过程原理(1)		</a><a href="/2019/03/27/runtime1/" class="next"> Runtime(1)		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、简介"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、作用"><span class="toc-text">二、作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、术语及其数据结构"><span class="toc-text">三、术语及其数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、消息"><span class="toc-text">四、消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、动态方法解析"><span class="toc-text">五、动态方法解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、消息转发"><span class="toc-text">六、消息转发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、健壮的实例变量-Non-Fragile-ivars"><span class="toc-text">七、健壮的实例变量(Non Fragile ivars)</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>