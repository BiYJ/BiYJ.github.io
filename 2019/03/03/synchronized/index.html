<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> @synchronized		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> @synchronized		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> @synchronized		</h1><div class="post-meta"><a href="/2019/03/03/synchronized/#comments" class="comment-count"></a><p><span class="date">Mar 03, 2019</span><span><a href="/categories/多线程/" class="category">多线程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>
<h5 id="一、-synchronized"><a href="#一、-synchronized" class="headerlink" title="一、@synchronized"></a>一、@synchronized</h5><p>@synchronized 是一个 OC 层面的锁，主要是通过牺牲性能换来语法上的简洁与可读。它的性能是最差的。</p>
<p>@synchronized() 需要传入一个 OC 对象，实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组（可以理解为锁池），通过对对象去哈希值来得到对应的互斥锁。</p>
<p>@synchronized(object) {<br>    //do work<br>}</p>
<p>@synchronized(object) 指令使用的 object 为该锁的唯一标识，只有当标识相同时，才满足互斥。@synchronized 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized 块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。@synchronized 还有一个好处就是不用担心忘记解锁了。如果在 @sychronized(object){} 内部 object 被释放或被设为 nil，从测试的结果来看，的确没有问题，但如果 object 一开始就是 nil，则失去了锁的功能。不过虽然 nil 不行，但 @synchronized([NSNull null]) 是完全可以的。</p>
<h5 id="二、原理探究"><a href="#二、原理探究" class="headerlink" title="二、原理探究"></a>二、原理探究</h5><p>synchronized block 与 [_lock lock] 和 [_lock unlock] 效果相同。你可以把它当成是锁住 self，仿佛 self 就是个 NSLock。锁在 ‘{‘ 后面的任何代码运行之前被获取到，在 ‘}’ 后面的任何代码运行之前被释放掉。不用担心忘记调用 unlock。</p>
<p>@synchronized 的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW3" target="_blank" rel="noopener">文档</a>告诉我们 @synchronized block 在被保护的代码上暗中添加了一个异常处理。为的是同步某对象时如若抛出异常，锁会被释放掉。</p>
<p><a href="http://stackoverflow.com/questions/1215330/how-does-synchronized-lock-unlock-in-objective-c/6047218#6047218" target="_blank" rel="noopener">Stackoverflow 上的这篇帖子</a> 说 @synchronized block 会变成 objc_sync_enter 和 objc_sync_exit 的成对儿调用。我们不知道这些函数是干啥的，但基于这些事实我们可以认为编译器将这样的代码：</p>
<p>@synchronized(obj) {<br>    // do work<br>}</p>
<p>转化成：</p>
<p>@try {<br>     objc_sync_enter(obj);<br>     // do work<br>}<br>@finally {<br>     objc_sync_exit(obj);<br>}</p>
<p>objc_sync_enter 和 objc_sync_exit 是什么？它们是如何实现的？在 Xcode 中按住 Command 键单击它们，然后进到了 &lt;objc/objc-sync.h&gt;，里面有我们感兴趣的这两个函数：</p>
<p>/**<br> * Begin synchronizing on ‘obj’.<br> * Allocates recursive pthread_mutex associated with ‘obj’ if needed.<br> *<br> * @param obj The object to begin synchronizing on.<br> *<br> * @return OBJC_SYNC_SUCCESS once lock is acquired.<br> */<br>OBJC_EXPORT int<br>objc_sync_enter(id _Nonnull obj)<br>    OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0, 2.0);</p>
<p>/**<br> * End synchronizing on ‘obj’.<br> *<br> * @param obj The object to end synchronizing on.<br> *<br> * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR<br> */<br>OBJC_EXPORT int<br>objc_sync_exit(id _Nonnull obj)<br>    OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0, 2.0);</p>
<p>objc_sync_enter 的文档告诉我们一些新东西： @synchronized 结构在工作时为传入的对象分配了一个递归锁。分配工作何时发生，如何发生呢？它怎样处理 nil？幸运的是 Objective-C runtime 是开源的，所以我们马上阅读源码并找到答案！</p>
<p>注：递归锁在被同一线程重复获取时不会产生死锁。你可以在<a href="https://en.wikipedia.org/wiki/Reentrant_mutex#Example" target="_blank" rel="noopener">这</a>找到一个它工作原理的精巧案例。有个叫做 NSRecursiveLock 的现成的类也是这样的。</p>
<p>你可以在<a href="http://www.opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm" target="_blank" rel="noopener">这里</a>找到 objc-sync 的全部源码。先从文件顶部的数据结构开始看。在代码块的下方我将立刻做出解释，所以尝试理解代码时别花太长时间哦。</p>
<p>typedef struct SyncData {<br>    struct SyncData* nextData;<br>    id               object;<br>    int              threadCount;  // number of THREADS using this block<br>    recursive_mutex_t        mutex;<br>} SyncData;</p>
<p>typedef struct {<br>    SyncData *data;<br>    spinlock_t lock;</p>
<pre><code>char align\[64 - sizeof (spinlock_t) - sizeof (SyncData *)\];
</code></pre><p>} SyncList __attribute__((aligned(64)));</p>
<p>// Use multiple parallel lists to decrease contention among unrelated objects.</p>
<p>#define COUNT 16</p>
<p>#define HASH(obj) ((((uintptr_t)(obj)) &gt;&gt; 5) &amp; (COUNT - 1))</p>
<p>#define LOCK_FOR_OBJ(obj) sDataLists[HASH(obj)].lock</p>
<p>#define LIST_FOR_OBJ(obj) sDataLists[HASH(obj)].data<br>static SyncList sDataLists[COUNT];</p>
<p>一开始，有一个 struct SyncData 的定义。这个结构体包含一个 object（就是给 @synchronized 传入的那个对象）和一个有关联的 recursive_mutex_t，它就是那个跟 object 关联在一起的锁。每个 SyncData 也包含一个指向另一个 SyncData 对象的指针，叫做 nextData，所以你可以把每个 SyncData 结构体看做是链表中的一个元素。最后，每个 SyncData 包含一个 threadCount，这个 SyncData 对象中的锁会被一些线程使用或等待，threadCount 就是此时这些线程的数量。它很有用处，因为 SyncData 结构体会被缓存，threadCount == 0 就暗示了这个 SyncData 实例可以被复用。</p>
<p>下面是 struct SyncList 的定义。正如我在上面提过，你可以把 SyncData 当做是链表中的节点。每个 SyncList 结构体都有个指向 SyncData 节点链表头部的指针，也有一个用于防止多个线程对此列表做并发修改的锁。</p>
<p>上面代码块的最后一行是 sDataLists 的声明：一个 SyncList 结构体数组，大小为 16。通过定义的一个哈希算法将传入对象映射到数组上的一个下标。值得注意的是这个哈希算法设计的很巧妙，是将对象指针在内存的地址转化为无符号整型并右移五位，再跟 0xF 做按位与运算，这样结果不会超出数组大小。 LOCK_FOR_OBJ(obj) 和 LIST_FOR_OBJ(obj) 这俩宏就更好理解了，先是哈希出对象的数组下标，然后取出数组对应元素的 lock 或 data。一切都是这么顺理成章哈。</p>
<p>当你调用 objc_sync_enter(obj) 时，它用 obj 内存地址的哈希值查找合适的 SyncData，然后将其上锁。当你调用 objc_sync_exit(obj) 时，它查找合适的 SyncData 并将其解锁。</p>
<p>现在知道了 @synchronized 如何将一个锁和你正在同步的对象关联起来，接下来看看当一个对象在 @synchronized(){} 中被释放或设为 nil 时会发生什么。</p>
<p>如果看了源码，你会注意到 objc_sync_enter 里面没有 retain 和 release。所以它要么没有保持传递给它的对象，要么或是在 ARC 下被编译。我们可以用下面的代码来做个测试：</p>
<p>NSDate * test = [NSDate date];<br>NSLog(@”%@”, @([test retainCount]));</p>
<p>@synchronized (test) {<br>     NSLog(@”%@”, @([test retainCount]));<br>}</p>
<p>两次输出结果都是 1。那么 objc_sync_enter 貌似是没保持被传入的对象啊。这就有趣了。如果你正在同步的对象 A 被释放了，然后有可能在它的内存地址上生成了一个新的对象 B，有可能某个其他的线程试着去同步那个新的对象 B。在这种情况下，另一个线程将会阻塞，直到当前线程结束它的同步 block。这看起来并不是很糟。这听起来像是这种事情实现者早就知道并予以接受。没有遇到过任何好的替代方案。</p>
<p>假如对象在 “synchronized block” 中被设成 nil 呢？我们回顾下我们“拿衣服（naive）”的实现吧：</p>
<p>NSString * test = @”test”;</p>
<p>@try {<br>    // Allocates a lock for test and locks it<br>    objc_sync_enter(test);<br>    test = nil;<br>}<br>@finally {<br>    // Passed `nil`, so the lock allocated in `objc_sync_enter`<br>    // above is never unlocked or deallocated<br>    objc_sync_exit(test);<br>}</p>
<p>objc_sync_enter 被调用时传入的是 test 而 objc_sync_exit 被调用时传入的是 nil。而传入 nil 的时 objc_sync_exit 是个空操作，所以将不会有人释放锁。</p>
<p>如果 Objective-C 容易受这种情况的影响，我们知道么？下面的代码调用 @synchronized 并在 {} 中将一个指针设为 nil。然后在后台线程对指向同一个对象的指针调用 @synchronized。如果在 {} 中设置一个对象为 nil 会让锁死锁，那么在第二个 @synchronized 中的代码将永远不会执行。控制台中将不会打印任何东西出来。</p>
<p>NSNumber <em> number = @(1);<br>NSNumber </em> thisPtrWillGoToNil = number;</p>
<p>@synchronized (thisPtrWillGoToNil) {<br>    /**<br>     * Here we set the thing that we’re synchronizing on to `nil`. If<br>     * implemented naively, the object would be passed to `objc_sync_enter`<br>     * and `nil` would be passed to `objc_sync_exit`, causing a lock to<br>     * never be released.<br>     */<br>    thisPtrWillGoToNil = nil;<br>}</p>
<p>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^ {</p>
<pre><code>NSCAssert(!\[NSThread isMainThread\], @&quot;Must be run on background thread&quot;);
/\*\*
 \* If, as mentioned in the comment above, the synchronized lock is never
 \* released, then we expect to wait forever below as we try to acquire
 \* the lock associated with \`number\`.
 \*
 \* This doesn&apos;t happen, so we conclude that `@synchronized` must deal
 \* with this correctly.
 */
@synchronized (number) {
    NSLog(@&quot;This line does indeed get printed to stdout&quot;);
}
</code></pre><p>});</p>
<p>当执行上面的代码时，控制台打印了 “This line does indeed get printed to stdout”。所以 Objective-C 很好地处理了这种情形。编译器可能做了类似下面的事情来解决这事儿的。</p>
<p>NSString * test = @”test”;<br>id synchronizeTarget = (id)test;</p>
<p>@try {<br>     objc_sync_enter(synchronizeTarget);<br>     test = nil;<br>}<br>@finally {<br>     objc_sync_exit(synchronizeTarget);<br>}</p>
<p>用这种方式实现的话，传递给 objc_sync_enter 和 objc_sync_exit 总是相同的对象。他们在传入 nil 时都是空操作。这带来了个棘手的 debug 场景：如果向 @synchronized 传递 nil，那么你就不会得到任何锁而且你的代码将不会是线程安全的！如果你想知道为什么你正收到出乎意料的竞态（race），确保没有向 @synchronized 传入 nil。你可以在 objc_sync_nil 上设置一个符号断点来达到此目的。objc_sync_nil 是一个空方法，当 objc_sync_enter 函数被传入 nil 时会被调用，这让 debug 更容易些。</p>
<p>下面是 objc_sync_enter 的源码，主要逻辑很容易看懂，加深理解 objc_sync_nil：</p>
<p>// Begin synchronizing on ‘obj’.<br>// Allocates recursive mutex associated with ‘obj’ if needed.<br>// Returns OBJC_SYNC_SUCCESS once lock is acquired.<br>int objc_sync_enter(id obj)<br>{<br>    int result = OBJC_SYNC_SUCCESS;</p>
<pre><code>if (obj) {
    SyncData* data = id2data(obj, ACQUIRE);
    require\_action\_string(data != NULL, done, result = OBJC\_SYNC\_NOT_INITIALIZED, &quot;id2data failed&quot;);

    result = recursive\_mutex\_lock(&amp;data-&gt;mutex);
    require\_noerr\_string(result, done, &quot;mutex_lock failed&quot;);
} else {
    // @synchronized(nil) does nothing
    if (DebugNilSync) {
        \_objc\_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc\_sync\_nil to debug&quot;);
    }
    objc\_sync\_nil();
}
</code></pre><p>done:<br>    return result;<br>}</p>
<h5 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h5><ol>
<li>调用 sychronized 的每个对象，Objective-C runtime 都会为其分配一个递归锁并存储在哈希表中；</li>
<li>如果在 {} 中对象被释放或被设为 nil 看起来正常。不过这没在文档中说明，所以不要依赖这条；</li>
<li>注意不要向 @sychronized() 传入 nil，这将会从代码中移走线程安全。可以通过在 objc_sync_nil 上加断点来查看是否发生了这样的事情。</li>
</ol>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/03/synchronized/">http://yoursite.com/2019/03/03/synchronized/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/03/e8-87-aa-e6-97-8b-e9-94-81/" class="pre"> 自旋锁		</a><a href="/2019/03/03/nscondition/" class="next"> NSCondition		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、-synchronized"><span class="toc-text">一、@synchronized</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、原理探究"><span class="toc-text">二、原理探究</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、总结"><span class="toc-text">三、总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>