<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> iOS IM		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> iOS IM		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> iOS IM		</h1><div class="post-meta"><a href="/2019/03/26/iosim/#comments" class="comment-count"></a><p><span class="date">Mar 26, 2019</span><span><a href="/categories/网络编程/" class="category">网络编程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://www.jianshu.com/u/14431e509ae8" target="_blank" rel="noopener">涂耀辉</a>/<a href="https://www.jianshu.com/p/2dbb360886a8" target="_blank" rel="noopener">iOS即时通讯，从入门到“放弃”？</a>、github：<a href="https://link.jianshu.com?t=https://github.com/tuyaohui/IM_iOS" target="_blank" rel="noopener">iOS即时通讯，从入门到“放弃”？（demo）</a></p>
<p><strong>本文会用实例的方式，将 iOS 各种 IM 的方案都简单的实现一遍。并且提供一些选型、实现细节以及优化的建议。</strong></p>
<h5 id="一、实现-IM-的方式"><a href="#一、实现-IM-的方式" class="headerlink" title="一、实现 IM 的方式"></a>一、实现 IM 的方式</h5><p>1、使用第三方 IM 服务</p>
<p>对于短平快的公司，完全可以采用第三方 SDK 来实现。国内 IM 的第三方服务商有：云信、环信、融云、LeanCloud，当然还有其它的很多。</p>
<p>第三方服务商 IM 底层协议基本上都是 TCP。他们的 IM 方案很成熟，有了它们，我们甚至不需要自己去搭建 IM 后台，什么都不需要去考虑。</p>
<p>如果你足够懒，甚至连 UI 都不需要自己做，这些第三方有各自一套 IM 的 UI，拿来就可以直接用。</p>
<p>缺点：</p>
<p>①、定制化程度太高，很多东西我们不可控。</p>
<p>②、太贵。作为真正以社交为主打的 APP，仅此一点，就足以让我们望而却步。当然，如果 IM 对于 APP 只是一个辅助功能，那么用第三方服务也无可厚非。</p>
<p>2、自己实现</p>
<p>实现时也有很多选择：</p>
<p>①、首先面临的就是传输协议的选择，TCP 还是 UDP？</p>
<p>②、其次是需要去选择使用哪种聊天协议：</p>
<ul>
<li><ul>
<li>基于 Scoket 或者 WebScoket 或者其他的私有协议？</li>
<li>MQTT ？</li>
<li>还是广为人诟病的 XMPP?</li>
</ul>
</li>
</ul>
<p>③、是自己去基于 OS 底层 Socket 进行封装还是在第三方框架的基础上进行封装？</p>
<p>④、传输数据的格式，是用 Json、XML、还是谷歌推出的 ProtocolBuffer？</p>
<p>⑤、还有一些细节问题需要考虑，例如 TCP 的长连接如何保持、心跳机制、Qos 机制、重连机制等。当然，除此之外，我们还有一些安全问题需要考虑。</p>
<h5 id="二、传输协议的选择"><a href="#二、传输协议的选择" class="headerlink" title="二、传输协议的选择"></a>二、传输协议的选择</h5><p>接下来我们可能需要自己考虑去实现 IM，首先从传输层协议来说，我们有两种选择：TCP or UDP？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-2d6dc11cbf1ddabb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/994/format/webp" alt="6"></p>
<p>这个问题已经被讨论过无数次了，对深层次的细节感兴趣的朋友可以看看这篇文章：</p>
<ul>
<li><a href="https://link.jianshu.com?t=http://www.52im.net/thread-33-1-1.html" target="_blank" rel="noopener">移动端 IM/推送系统的协议选型：UDP 还是 TCP？</a></li>
</ul>
<p>结论：</p>
<p>对于小公司或者技术不那么成熟的公司，IM 一定要用 TCP 来实现，因为如果你要用 UDP 的话，需要做的事太多。</p>
<p>当然 QQ 就是用的 UDP 协议，当然不仅仅是 UDP，腾讯还用了自己的私有协议，来保证了传输的可靠性，杜绝了 UDP 下各种数据丢包、乱序等等一系列问题。</p>
<p>总之一句话，如果你觉得团队技术很成熟，那么你用 UDP 也行，否则还是用 TCP 为好。</p>
<h5 id="三、聊天协议"><a href="#三、聊天协议" class="headerlink" title="三、聊天协议"></a>三、聊天协议</h5><p>首先我们以实现方式来切入，基本上有以下四种实现方式：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-573332f0d9bfa79b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"></p>
<p>当然，以上四种方式我们都可以不使用第三方框架，直接基于 OS 底层 Scoket 去实现我们的自定义封装。下面会给出一个基于 Scoket 原生而不使用框架的例子，供大家参考一下。</p>
<p>首先需要搞清楚的是，其中 MQTT 和 XMPP 为聊天协议，它们是最上层的协议，而 WebScoket 是传输通讯协议，它是基于 Socket 封装的一个协议。而通常我们所说的腾讯 IM 的私有协议，就是基于 WebScoket 或者 Scoket 原生进行封装的一个聊天协议。</p>
<p>具体这 3 种聊天协议的对比优劣如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a871f1eef2dd18bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>所以说，iOS 要做一个真正的 IM 产品，一般都是基于 Scoket 或者 WebScoket 等，再之上加上一些私有协议来保证的。</p>
<h5 id="四、直接用-OS-底层-Socket-来实现一个简单的-IM"><a href="#四、直接用-OS-底层-Socket-来实现一个简单的-IM" class="headerlink" title="四、直接用 OS 底层 Socket 来实现一个简单的 IM"></a>四、直接用 OS 底层 Socket 来实现一个简单的 IM</h5><p>客户端的实现思路也是很简单，创建 Socket -&gt; 和服务器的 Socket 对接上 -> 开始传输数据。</p>
<ul>
<li>Socket 是什么呢，简单的来说，就是我们使用 TCP/IP 或者 UDP/IP 协议的一组编程接口。如下图所示：</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1194012-d35653654be833ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="5"></p>
<p>我们在应用层，使用 socket 轻易的实现了进程之间的通信（跨网络的）。想想，如果没有 socket，我们要直面 TCP/IP 协议，需要去写多少繁琐而又重复的代码。</p>
<p>如果有对 socket 概念仍然有所困惑的，可以看看这篇文章：<a href="https://link.jianshu.com?t=http://blog.csdn.net/yeyuangen/article/details/6799575" target="_blank" rel="noopener">从问题看本质，socket 到底是什么？</a>。</p>
<p>但是这篇文章关于并发连接数的认识是错误的，正确的认识可以看看这篇文章：<a href="https://link.jianshu.com?t=http://www.52im.net/thread-561-1-1.html" target="_blank" rel="noopener">单台服务器并发 TCP 连接数到底可以有多少</a></p>
<p>我们接着可以开始着手去实现 IM 了，首先我们不基于任何框架，直接去调用 OS 底层-基于 C 的 BSD Socket 去实现，它提供了这样一组接口：</p>
<p>/**<br> * socket 创建并初始化 socket，返回该 socket 的文件描述符，如果描述符为 -1 表示创建失败。<br> <em>/<br>int socket(int addressFamily, int type,int protocol)<br>/\</em>*<br> * 关闭 socket 连接<br> <em>/<br>int close(int socketFileDescriptor)<br>/\</em>*<br> * 将 socket 与特定主机地址与端口号绑定，成功绑定返回 0，失败返回 -1。<br> <em>/<br>int bind(int socketFileDescriptor,sockaddr </em>addressToBind,int addressStructLength)</p>
<p>/**<br> * 接受客户端连接请求并将客户端的网络地址信息保存到 clientAddress 中。<br> <em>/<br>int accept(int socketFileDescriptor,sockaddr </em>clientAddress, int clientAddressStructLength)<br>/**<br> * 客户端向特定网络地址的服务器发送连接请求，连接成功返回 0，失败返回 -1。<br> <em>/<br>int connect(int socketFileDescriptor,sockaddr </em>serverAddress, int serverAddressLength)</p>
<p>/**<br> * 使用 DNS 查找特定主机名字对应的 IP 地址。如果找不到对应的 IP 地址则返回 NULL。<br> <em>/<br>hostent</em> gethostbyname(char *hostname)</p>
<p>/**<br> * 通过 socket 发送数据，发送成功返回成功发送的字节数，否则返回 -1。<br> <em>/<br>int send(int socketFileDescriptor, char </em>buffer, int bufferLength, int flags)</p>
<p>/**<br> * 从 socket 中读取数据，读取成功返回成功读取的字节数，否则返回 -1。<br> <em>/<br>int receive(int socketFileDescriptor,char </em>buffer, int bufferLength, int flags)</p>
<p>/**<br> * 通过 UDP socket 发送数据到特定的网络地址，发送成功返回成功发送的字节数，否则返回 -1。<br> <em>/<br>int sendto(int socketFileDescriptor,char \</em>buffer, int bufferLength, int flags, sockaddr *destinationAddress, int destinationAddressLength)</p>
<p>/**<br> * 从 UDP socket 中读取数据，并保存发送者的网络地址信息，读取成功返回成功读取的字节数，否则返回 -1 。<br> <em>/<br>int recvfrom(int socketFileDescriptor,char \</em>buffer, int bufferLength, int flags, sockaddr *fromAddress, int *fromAddressLength)</p>
<p>可以对 socket 进行各种操作，首先我们来用它写个客户端。总结一下，简单的 IM 客户端需要做如下 4 件事：</p>
<ol>
<li><p>客户端调用 socket(…) 创建 socket；</p>
</li>
<li><p>客户端调用 connect(…) 向服务器发起连接请求以建立连接；</p>
</li>
<li><p>客户端与服务器建立连接之后，就可以通过 send(…)/receive(…) 向客户端发送或从客户端接收数据；</p>
</li>
<li><p>客户端调用 close 关闭 socket；</p>
</li>
</ol>
<p>根据上面 4 条大纲，我们封装了一个单例类来对 socket 相关方法进行调用：</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>@interface SocketManager : NSObject<br>+ (instancetype)sharedInstance;<br>- (void)connect;<br>- (void)disConnect;<br>- (void)sendMsg:(NSString *)msg;<br>@end</p>
<p>#import “SocketManager.h”</p>
<p>#import &lt;sys/types.h&gt;</p>
<p>#import &lt;sys/socket.h&gt;</p>
<p>#import &lt;netinet/in.h&gt;</p>
<p>#import &lt;arpa/inet.h&gt;</p>
<p>@interface SocketManager()<br>@property (nonatomic, assign) int clientScoket;<br>@end</p>
<p>@implementation SocketManager</p>
<p>/**<br> * @brief  单例<br> */<br>+ (instancetype)sharedInstance<br>{<br>    static dispatch_once_t onceToken;<br>    static SocketManager * instance = nil;<br>    dispatch_once(&amp;onceToken, ^{<br>        instance = [[self alloc] init];<br>        [instance initScoket];<br>        [instance pullMsg];<br>    });<br>    return instance;<br>}</p>
<p>/**<br> *  @brief  初始化 socket，并发起连接<br> */<br>- (void)initScoket<br>{<br>    // 每次连接前先断开连接<br>    if (_clientScoket != 0) {<br>        [self disConnect];<br>        _clientScoket = 0;<br>    }</p>
<pre><code>_clientScoket = CreateClinetSocket();

// 服务器 IP
const char * server_ip = &quot;127.0.0.1&quot;;
// 服务器端口
short server_port = 6969;

// 等于 0 说明连接失败
if (ConnectionToServer(\_clientScoket, server\_ip, server_port) == 0) {
    NSLog(&quot;Connect to server error&quot;);
    return;
}

// 连接成功
NSLog(&quot;Connect to server ok&quot;);
</code></pre><p>}</p>
<p>/**<br> * @brief  创建一个 socket，返回值为 Int。（注：scoket 其实就是 Int 类型）<br> */<br>static int CreateClinetSocket()<br>{<br>    int ClinetSocket = 0;</p>
<pre><code>/*
  参数 1 : IPv4(AF\_INET) 或 IPv6(AF\_INET6)。
  参数 2 : type 表示 socket 的类型，通常是流 stream(SOCK\_STREAM) 或数据报文 datagram(SOCK\_DGRAM)
  参数 3 : protocol 参数通常设置为 0，以便让系统自动为我们选择合适的协议。对于 stream socket 来说会是 TCP 协议(IPPROTO\_TCP)，而对于 datagram 来说会是 UDP 协议(IPPROTO\_UDP)。
 */
ClinetSocket = socket(AF\_INET, SOCK\_STREAM, 0);

return ClinetSocket;
</code></pre><p>}</p>
<p>/**<br> *  @breif  与服务器连接<br> <em>/<br>static int ConnectionToServer(int client_socket,const char </em> server_ip,unsigned short port)<br>{</p>
<pre><code>// 生成一个 sockaddr_in 类型结构体
struct sockaddr_in sAddr = {0};
sAddr.sin_len = sizeof(sAddr);
// 设置 IPv4
sAddr.sin\_family = AF\_INET;

/\* inet_aton 是一个改进的方法来将一个字符串IP地址转换为一个32位的网络序列IP地址

   如果这个函数成功，函数的返回值非零，如果输入地址不正确则会返回零。
 */
inet\_aton(server\_ip, &amp;sAddr.sin_addr);

// htons 是将整型变量从主机字节顺序转变成网络字节顺序，赋值端口号
sAddr.sin_port = htons(port);

/\* 用 scoket 和服务端地址，发起连接。
   客户端向特定网络地址的服务器发送连接请求，连接成功返回0，失败返回 -1。

   注意：该接口调用会阻塞当前线程，直到服务器返回。
 */
if (connect(client_socket, (struct sockaddr *)&amp;sAddr, sizeof(sAddr))==0) {
    return client_socket;
}
return 0;
</code></pre><p>}</p>
<p>#pragma mark - Thread<br>/**<br> * 开启新线程来接收消息<br> */<br>- (void)pullMsg<br>{<br>    [[[NSThread alloc] initWithTarget:self selector:@selector(recieveAction) object:nil] start];<br>}</p>
<p>#pragma mark - 对外逻辑</p>
<p>- (void)connect<br>{<br>    [self initScoket];<br>}<br>- (void)disConnect<br>{<br>    close(self.clientScoket);<br>}</p>
<p>- (void)sendMsg:(NSString <em>)msg<br>{<br>    const char </em>send_Message = [msg UTF8String];<br>    send(self.clientScoket, send_Message, strlen(send_Message) + 1, 0);<br>}</p>
<p>- (void)recieveAction<br>{<br>    while (1) {<br>        char recv_Message[1024] = {0};<br>        recv(self.clientScoket, recv_Message, sizeof(recv_Message), 0);<br>        NSLog(“%s”, recv_Message);<br>    }<br>}</p>
<p>如上所示：</p>
<ul>
<li><p>调用了 initScoket 方法，利用 CreateClinetSocket 方法创建了一个 scoket，就是调用了原生 socket 函数；</p>
</li>
<li><p>然后调用了 ConnectionToServer 函数与服务器连接，IP 地址为 127.0.0.1 也就是本机 localhost 和端口 6969 相连。在该函数中，我们绑定了一个 sockaddr_in 类型的结构体，该结构体内容如下：</p>
</li>
</ul>
<p>/*<br> * Socket address, internet style.<br> */<br>struct sockaddr_in {<br>    __uint8_t    sin_len;<br>    sa_family_t    sin_family;<br>    in_port_t    sin_port;<br>    struct    in_addr sin_addr;<br>    char        sin_zero[8];<br>};</p>
<p>里面包含了我们需要连接的服务端的 scoket 的一些基本参数，具体赋值细节可以见注释。</p>
<ul>
<li>连接成功之后，就可以调用 send函数和 recv函数进行消息收发了，在这里，新开辟了一个常驻线程，一个死循环里去不停的调用 recv 函数，这样服务端有消息发送过来，第一时间便能接收到。</li>
</ul>
<p>就这样客户端便简单的可以用了，接着我们来看看服务端的实现。</p>
<p>服务端需要做的工作简单的总结下：</p>
<ol>
<li><p>服务器调用 socket(…) 创建 socket；</p>
</li>
<li><p>服务器调用 listen(…) 设置缓冲区；</p>
</li>
<li><p>服务器通过 accept(…) 接受客户端请求建立连接；</p>
</li>
<li><p>服务器与客户端建立连接之后，就可以通过 send(…)/receive(…) 向客户端发送或从客户端接收数据；</p>
</li>
<li><p>服务器调用 close 关闭 socket；</p>
</li>
</ol>
<p>OS 底层的函数是支持我们去实现服务端的，但是我们一般不会用<code>iOS</code>去这么做（试问真正的应用场景，有谁用<code>iOS</code>做<code>scoket</code>服务器么…），如果还是想用这些函数去实现服务端，可以参考下这篇文章： <a href="https://link.jianshu.com?t=http://blog.csdn.net/kesalin/article/details/8798039" target="_blank" rel="noopener">深入浅出Cocoa-iOS网络编程之Socket</a>。</p>
<p>在这里我用 node.js 去搭了一个简单的 scoket 服务器。源码如下：</p>
<p>var net = require(‘net’);<br>var HOST = ‘127.0.0.1’;<br>var PORT = 6969;  </p>
<p>// 创建一个TCP服务器实例，调用listen函数开始监听指定端口<br>// 传入net.createServer()的回调函数将作为”connection“事件的处理函数<br>// 在每一个“connection”事件中，该回调函数接收到的socket对象是唯一的<br>net.createServer(function(sock) {  </p>
<pre><code>// 我们获得一个连接 \- 该连接自动关联一个socket对象  
console.log(&apos;CONNECTED: &apos; +  
    sock.remoteAddress + &apos;:&apos; + sock.remotePort);  
    sock.write(&apos;服务端发出：连接成功&apos;);  

// 为这个socket实例添加一个&quot;data&quot;事件处理函数  
sock.on(&apos;data&apos;, function(data) {  
    console.log(&apos;DATA &apos; + sock.remoteAddress + &apos;: &apos; + data);  
    // 回发该数据，客户端将收到来自服务端的数据  
    sock.write(&apos;You said &quot;&apos; + data + &apos;&quot;&apos;);  
});  
// 为这个socket实例添加一个&quot;close&quot;事件处理函数  
sock.on(&apos;close&apos;, function(data) {  
    console.log(&apos;CLOSED: &apos; +  
    sock.remoteAddress + &apos; &apos; + sock.remotePort);  
});  
</code></pre><p>}).listen(PORT, HOST);  </p>
<p>console.log(‘Server listening on ‘ + HOST +’:’+ PORT);  </p>
<p>可以使用 c/c++/java/oc 语言等去实现后台，这里是为了验证之前写的客户端 scoket 的效果。如果本机有 node 的解释器，那么直接在终端进入该源代码文件目录中输入：node fileName</p>
<p>~ $ node /Users/cykj/Desktop/IM_iOS-master/Server.js<br>Server listening on 127.0.0.1:6969</p>
<p>即可运行该脚本（fileName 为保存源代码的文件名）。</p>
<p>如果没有 node 解释器，Mac 系统在终端执行 brew install node 可以下载。</p>
<p>运行效果：</p>
<p>~ $ node /Users/cykj/Desktop/IM_iOS-master/Server.js<br>Server listening on 127.0.0.1:6969<br>CONNECTED: 127.0.0.1:61179<br>DATA 127.0.0.1: haha1<br>CONNECTED: 127.0.0.1:61183<br>CLOSED: 127.0.0.1 61179<br>DATA 127.0.0.1: haha2<br>CLOSED: 127.0.0.1 61183<br>CONNECTED: 127.0.0.1:61184<br>DATA 127.0.0.1: haha3</p>
<p>从上面可以看到，客户端每次点击连接时，关闭了之前的 socket，重新建立了一个连接，服务端一直在监听 6969 端口。</p>
<p>You said “haha1</p>
<p>Connect to server ok<br>服务端发出：连接成功<br>You said “haha2</p>
<p>Connect to server ok<br>服务端发出：连接成功<br>You said “haha3</p>
<p>客户端打印显示连接成功，而运行的服务器也打印了连接成功。接着我们发了一条消息，服务端成功的接收到了消息后，把该消息再发送回客户端，绕了一圈客户端又收到了这条消息。至此我们用 OS 底层 scoket 实现了简单的 IM。</p>
<p>目前的实现很简单，仅仅是实现了 Scoket 的连接，信息的发送与接收，除此之外什么都没有做，现实中，需要做的处理远不止于此，我们先接着往下看。接下来，我们就一起看看第三方框架是如何实现 IM 的。</p>
<h5 id="五、基于-Socket-原生的-CocoaAsyncSocket"><a href="#五、基于-Socket-原生的-CocoaAsyncSocket" class="headerlink" title="五、基于 Socket 原生的 CocoaAsyncSocket"></a>五、基于 Socket 原生的 CocoaAsyncSocket</h5><p>这个框架实现了 TCP 和 UDP 传输协议，分别对应 GCDAsyncSocket 和 GCDAsyncUdpSocket，重点讲 GCDAsyncSocket。</p>
<p>这里 Socket 服务器延续上一个例子，因为同样是基于原生 Scoket 的框架，所以之前的 Node.js 的服务端，该例仍然适用。这里只需要去封装客户端的实例。</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>@interface SocketManager : NSObject<br>+ (instancetype)sharedInstance;<br>- (BOOL)connect;<br>- (void)disConnect;<br>- (void)sendMsg:(NSString *)msg;<br>- (void)pullTheMsg;<br>@end</p>
<p>#import “SocketManager.h”</p>
<p>#import “GCDAsyncSocket.h” // for TCP</p>
<p>static NSString * Khost = @”127.0.0.1”;<br>static const uint16_t Kport = 6969;</p>
<p>@interface SocketManager() <gcdasyncsocketdelegate><br>{<br>    GCDAsyncSocket * gcdSocket;<br>}<br>@end</gcdasyncsocketdelegate></p>
<p>@implementation SocketManager<br>/**<br> * 单例<br> */<br>+ (instancetype)sharedInstance<br>{<br>    static dispatch_once_t onceToken;<br>    static SocketManager * instance = nil;<br>    dispatch_once(&amp;onceToken, ^{<br>        instance = [[self alloc]init];<br>        [instance initSocket];<br>    });<br>    return instance;<br>}</p>
<p>/**<br> * 初始化 socket<br> */<br>- (void)initSocket<br>{<br>    gcdSocket = [[GCDAsyncSocket alloc] initWithDelegate:self delegateQueue:dispatch_get_main_queue()];<br>}</p>
<p>#pragma mark - 对外接口</p>
<p>- (BOOL)connect<br>{<br>    return [gcdSocket connectToHost:Khost onPort:Kport error:nil];<br>}</p>
<p>- (void)disConnect<br>{<br>    [gcdSocket disconnect];<br>}</p>
<p>- (void)sendMsg:(NSString *)msg</p>
<p>{<br>    NSData * data = [msg dataUsingEncoding:NSUTF8StringEncoding];<br>    // 第二个参数，请求超时时间<br>    [gcdSocket writeData:data withTimeout:-1 tag:110];<br>}</p>
<p>/**<br> * 监听最新的消息<br> */<br>- (void)pullTheMsg<br>{<br>    // 监听读数据的代理  -1 永远监听，不超时，但是只收一次消息，所以每次接受到消息还得调用一次<br>    [gcdSocket readDataWithTimeout:-1 tag:110];</p>
<p>}</p>
<p>#pragma mark - GCDAsyncSocketDelegate<br>/**<br> * @brief 连接成功调用<br> */<br>- (void)socket:(GCDAsyncSocket <em>)sock didConnectToHost:(NSString </em>)host port:(uint16_t)port<br>{<br>    NSLog(@”连接成功, host:%@, port:%d”, host, port);</p>
<pre><code>\[self pullTheMsg\];

// 心跳写在这...
</code></pre><p>}</p>
<p>/**<br> * @brief 断开连接的时候调用<br> */<br>- (void)socketDidDisconnect:(GCDAsyncSocket <em>)sock withError:(nullable NSError </em>)err<br>{<br>    NSLog(@”断开连接, host:%@, port:%d”, sock.localHost, sock.localPort);</p>
<pre><code>//断线重连写在这...
</code></pre><p>}</p>
<p>/**<br> * @brief 写成功的回调<br> */<br>- (void)socket:(GCDAsyncSocket*)sock didWriteDataWithTag:(long)tag<br>{<br>//    NSLog(@”写的回调, tag:%ld”, tag);<br>}</p>
<p>/**<br> * @brief 收到消息的回调<br> */<br>- (void)socket:(GCDAsyncSocket <em>)sock didReadData:(NSData </em>)data withTag:(long)tag<br>{</p>
<pre><code>NSString * msg = \[\[NSString alloc\]initWithData:data encoding:NSUTF8StringEncoding\];
NSLog(@&quot;收到消息：%@&quot;, msg);

\[self pullTheMsg\];
</code></pre><p>}</p>
<p>/**<br> * @brief 分段去获取消息的回调<br> */<br>//- (void)socket:(GCDAsyncSocket *)sock didReadPartialDataOfLength:(NSUInteger)partialLength tag:(long)tag<br>//{<br>//<br>//    NSLog(@”读的回调,length:%ld,tag:%ld”,partialLength,tag);<br>//<br>//}</p>
<p>/**<br> * @brief 为上一次设置的读取数据代理续时 (如果设置超时为 -1，则永远不会调用到)<br> <em>/<br>//-(NSTimeInterval)socket:(GCDAsyncSocket </em>)sock shouldTimeoutReadWithTag:(long)tag elapsed:(NSTimeInterval)elapsed bytesDone:(NSUInteger)length<br>//{<br>//    NSLog(@”来延时，tag:%ld,elapsed:%f,length:%ld”,tag,elapsed,length);<br>//    return 10;<br>//}</p>
<p>@end</p>
<p>这个框架使用起来也十分简单，它基于 Scoket 进行了一层封装，提供了 OC 的接口给我们使用。至于使用方法，大家看看注释应该就能明白，这里唯一需要说的就是这个方法：</p>
<p>[gcdSocket readDataWithTimeout:-1 tag:110];</p>
<p>这个方法的作用就是去读取当前消息队列中的未读消息。记住，这里不调用这个方法，消息回调的代理是永远不会被触发的<strong>。</strong>而且必须是 tag 相同，如果 tag 不同，这个收到消息的代理也不会被触发。</p>
<p>每调用一次这个方法，只能触发一次读取消息的代理，如果我们调用的时候没有未读消息，它就会等在那，直到消息来了被触发。一旦被触发一次代理后，我们必须再次调用这个方法，否则，之后的消息到了仍旧无法触发我们读取消息的代理。就像我们在例子中使用的那样，在每次读取到消息之后我们都去调用：</p>
<p>/**<br> * 收到消息的回调<br> */<br>- (void)socket:(GCDAsyncSocket <em>)sock didReadData:(NSData </em>)data withTag:(long)tag<br>{<br>    NSString * msg = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</p>
<pre><code>NSLog(@&quot;收到消息：%@&quot;,msg);

\[self pullTheMsg\];
</code></pre><p>}<br>/**<br> * 监听最新的消息<br> */<br>- (void)pullTheMsg<br>{<br>    // 监听读数据的代理，只能监听 10 秒，10 秒过后调用代理方法  -1 永远监听，不超时，但是只收一次消息，所以每次接受到消息还得调用一次<br>    [gcdSocket readDataWithTimeout:-1 tag:110];<br>}</p>
<p>超时 timeout 如果设置 10 秒，那么就只能监听 10 秒，10 秒过后调用是否续时的代理方法：</p>
<p>-(NSTimeInterval)socket:(GCDAsyncSocket *)sock<br>shouldTimeoutReadWithTag:(long)tag elapsed:(NSTimeInterval)elapsed<br>              bytesDone:(NSUInteger)length;</p>
<p>如果我们选择不续时，那么 10 秒到了还没收到消息，那么 Scoket 会自动断开连接。看到这里有些小伙伴要吐槽了，怎么一个方法设计的这么麻烦，当然这里这么设计是有它的应用场景的，后面再来细讲。</p>
<p>至此我们也用 CocoaAsyncSocket 这个框架实现了一个简单的 IM。</p>
<h5 id="六、基于-webScoket-的-IM"><a href="#六、基于-webScoket-的-IM" class="headerlink" title="六、基于 webScoket 的 IM"></a>六、基于 webScoket 的 IM</h5><p>这个例子我们会把心跳、断线重连，以及 PingPong 机制进行简单的封装，所以我们先来谈谈这三个概念：</p>
<p>1、什么是心跳</p>
<p>简单的来说，心跳就是用来检测 TCP 连接的双方是否可用<strong>。</strong>那又会有人要问了，TCP 不是本身就自带一个 KeepAlive 机制吗？</p>
<p>这里需要说明的是 TCP 的 KeepAlive 机制只能保证连接的存在，但是并不能保证客户端以及服务端的可用性。比如会有以下一种情况：</p>
<p>某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态。</p>
<p>这个时候心跳机制就起到作用了：</p>
<ul>
<li><p>客户端发起心跳 Ping（一般都是客户端），假如设置在 10 秒后如果没有收到回调，那么说明服务器或者客户端某一方出现问题，这时候我们需要主动断开连接。</p>
</li>
<li><p>服务端也是一样，会维护一个 socket 的心跳间隔，当约定时间内，没有收到客户端发来的心跳，我们会知道该连接已经失效，然后主动断开连接。</p>
</li>
</ul>
<p>参考文章：<a href="https://link.jianshu.com?t=http://www.52im.net/thread-281-1-1.html" target="_blank" rel="noopener">为什么说基于TCP的移动端IM仍然需要心跳保活？</a></p>
<p>其实做过 IM 的小伙伴们都知道，我们真正需要心跳机制的原因其实主要是在于国内运营商 NAT 超时。</p>
<p>那么究竟什么是 NAT 超时呢？</p>
<p>原来这是因为 IPV4 引起的。我们上网很可能会处在一个 NAT 设备（无线路由器之类）之后。NAT 设备会在 IP 封包通过设备时修改源/目的 IP 地址。对于家用路由器来说，使用的是网络地址端口转换（NAPT），它不仅改 IP，还修改 TCP 和 UDP 协议的端口号，这样就能让内网中的设备共用同一个外网 IP。举个例子，NAPT 维护一个类似下表的 NAT 表：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-cefd86afd8b99939.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/622/format/webp" alt="9"></p>
<p>NAT 设备会根据 NAT 表对出去和进来的数据做修改, 比如将 192.168.0.3:8888 发出去的封包改成 120.132.92.21:9202，外部就认为它们是在和 120.132.92.21:9202 通信。同时 NAT 设备会将 120.132.92.21:9202 收到的封包的 IP 和端口改成192.168.0.3:8888，再发给内网的主机，这样内部和外部就能双向通信了。但如果其中 192.168.0.3:8888 == 120.132.92.21:9202 这一映射因为某些原因被 NAT 设备淘汰了, 那么外部设备就无法直接与 192.168.0.3:8888 通信了。</p>
<p>我们的设备经常是处在 NAT 设备的后面，比如在大学里的校园网，查一下自己分配到的 IP，其实是内网 IP，表明我们在 NAT 设备后面，如果我们在寝室再接个路由器，那么我们发出的数据包会多经过一次 NAT。</p>
<p>国内移动无线网络运营商在链路上一段时间内没有数据通讯后，会淘汰 NAT 表中的对应项，造成链路中断。</p>
<p>而国内的运营商一般 NAT 超时的时间为 5 分钟，所以通常我们心跳设置的时间间隔为 3-5 分钟。</p>
<p>2、接着我们来讲讲 PingPong 机制</p>
<p>很多小伙伴可能又会感觉到疑惑了，那么我们在这心跳间隔的 3-5 分钟如果连接假在线（例如在地铁电梯这种环境下）。那么我们岂不是无法保证消息的即时性么？这显然是我们无法接受的，所以业内的解决方案是采用双向的 PingPong 机制。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-6e51be4cf4ba7b11.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/372/format/webp" alt="10"></p>
<p>当服务端发出一个 Ping，客户端没有在约定的时间内返回响应的 ack，则认为客户端已经不在线，这时我们 Server 端会主动断开 Scoket 连接，并且改由 APNS 推送的方式发送消息。</p>
<p>同样的，当客户端去发送一个消息，因为我们迟迟无法收到服务端的响应 ack 包，则表明客户端或者服务端已不在线，我们也会显示消息发送失败，并且断开 Scoket 连接。</p>
<p>还记得我们之前 CocoaSyncSocket 的例子讲的获取消息超时就断开吗？其实它就是一个 PingPong 机制的客户端实现。我们每次可以在发送消息成功后，调用这个超时读取的方法，如果一段时间没收到服务器的响应，那么说明连接不可用，则断开 Scoket 连接。</p>
<p>3、最后就是重连机制</p>
<p>理论上，用户主动去断开的 Scoket 连接（例如退出账号、APP 退出到后台等），不需要重连。其他的连接断开，我们都需要进行断线重连。</p>
<p>一般解决方案是尝试重连几次，如果仍旧无法重连成功，那么不再进行重连。</p>
<p>接下来的 WebScoket 的例子，我会封装一个重连时间指数级增长的一个重连方式，可以作为一个参考。</p>
<p>看完上面三个概念之后，来讲一个 WebScoket 最具代表性的一个第三方框架 SocketRocket。</p>
<p>首先来看看它对外封装的一些方法：</p>
<p>@interface SRWebSocket : NSObject <nsstreamdelegate></nsstreamdelegate></p>
<p>@property (nonatomic, weak) id <srwebsocketdelegate> delegate;</srwebsocketdelegate></p>
<p>@property (nonatomic, readonly) SRReadyState readyState;<br>@property (nonatomic, readonly, retain) NSURL *url;</p>
<p>@property (nonatomic, readonly) CFHTTPMessageRef receivedHTTPHeaders;</p>
<p>// Optional array of cookies (NSHTTPCookie objects) to apply to the connections<br>@property (nonatomic, readwrite) NSArray * requestCookies;</p>
<p>// This returns the negotiated protocol.<br>// It will be nil until after the handshake completes.<br>@property (nonatomic, readonly, copy) NSString *protocol;</p>
<p>// Protocols should be an array of strings that turn into Sec-WebSocket-Protocol.<br>- (id)initWithURLRequest:(NSURLRequest <em>)request protocols:(NSArray </em>)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates;<br>- (id)initWithURLRequest:(NSURLRequest <em>)request protocols:(NSArray </em>)protocols;<br>- (id)initWithURLRequest:(NSURLRequest *)request;</p>
<p>// Some helper constructors.<br>- (id)initWithURL:(NSURL <em>)url protocols:(NSArray </em>)protocols allowsUntrustedSSLCertificates:(BOOL)allowsUntrustedSSLCertificates;<br>- (id)initWithURL:(NSURL <em>)url protocols:(NSArray </em>)protocols;<br>- (id)initWithURL:(NSURL *)url;</p>
<p>// Delegate queue will be dispatch_main_queue by default.<br>// You cannot set both OperationQueue and dispatch_queue.<br>- (void)setDelegateOperationQueue:(NSOperationQueue*) queue;<br>- (void)setDelegateDispatchQueue:(dispatch_queue_t) queue;</p>
<p>// By default, it will schedule itself on +[NSRunLoop SR_networkRunLoop] using defaultModes.<br>- (void)scheduleInRunLoop:(NSRunLoop <em>)aRunLoop forMode:(NSString </em>)mode;<br>- (void)unscheduleFromRunLoop:(NSRunLoop <em>)aRunLoop forMode:(NSString </em>)mode;</p>
<p>// SRWebSockets are intended for one-time-use only.  Open should be called once and only once.<br>- (void)open;</p>
<p>- (void)close;<br>- (void)closeWithCode:(NSInteger)code reason:(NSString *)reason;</p>
<p>// Send a UTF8 String or Data.<br>- (void)send:(id)data;</p>
<p>// Send Data (can be nil) in a ping message.<br>- (void)sendPing:(NSData *)data;</p>
<p>@end</p>
<p>#pragma mark - SRWebSocketDelegate</p>
<p>@protocol SRWebSocketDelegate <nsobject></nsobject></p>
<p>// message will either be an NSString if the server is using text<br>// or NSData if the server is using binary.<br>- (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message;</p>
<p>@optional</p>
<p>- (void)webSocketDidOpen:(SRWebSocket <em>)webSocket;<br>- (void)webSocket:(SRWebSocket </em>)webSocket didFailWithError:(NSError <em>)error;<br>- (void)webSocket:(SRWebSocket </em>)webSocket didCloseWithCode:(NSInteger)code reason:(NSString <em>)reason wasClean:(BOOL)wasClean;<br>- (void)webSocket:(SRWebSocket </em>)webSocket didReceivePong:(NSData *)pongPayload;</p>
<p>// Return YES to convert messages sent as Text to an NSString. Return NO to skip NSData -&gt; NSString conversion for Text messages. Defaults to YES.<br>- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket;</p>
<p>@end</p>
<p>方法也很简单，分为两个部分：</p>
<ul>
<li><p>一部分是 SRWebSocket 的初始化、连接、关闭连接、发送消息等方法。</p>
</li>
<li><p>另一部分是 SRWebSocketDelegate，其中包括一些回调：收到消息、连接失败、关闭连接、收到 pong 、是否需要把 data 消息转换成 string 的代理方法。</p>
</li>
</ul>
<p>接着我们还是举个例子来实现以下：</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>typedef enum : NSUInteger {<br>    disConnectByUser ,<br>    disConnectByServer,<br>} DisConnectType;</p>
<p>@interface SocketManager : NSObject<br>+ (instancetype)sharedInstance;<br>- (void)connect;<br>- (void)disConnect;<br>- (void)sendMsg:(NSString *)msg;<br>- (void)ping;<br>@end</p>
<p>#import “SocketManager.h”</p>
<p>#import “SocketRocket.h”</p>
<p>#define dispatch_main_async_safe(block)\<br>    if ([NSThread isMainThread]) {\<br>        block();\<br>    } else {\<br>        dispatch_async(dispatch_get_main_queue(), block);\<br>    }</p>
<p>static NSString * Khost = @”127.0.0.1”;<br>static const uint16_t Kport = 6969;</p>
<p>@interface SocketManager() <srwebsocketdelegate><br>{<br>    SRWebSocket <em>webSocket;<br>    NSTimer </em> heartBeat;<br>    NSTimeInterval reConnectTime;<br>}</srwebsocketdelegate></p>
<p>@end</p>
<p>@implementation TYHSocketManager</p>
<p>+ (instancetype)sharedInstance<br>{<br>    static dispatch_once_t onceToken;<br>    static SocketManager * instance = nil;<br>    dispatch_once(&amp;onceToken, ^{<br>        instance = [[self alloc]init];<br>        [instance initSocket];<br>    });<br>    return instance;<br>}</p>
<p>/**<br> * @brief 初始化连接<br> */<br>- (void)initSocket<br>{<br>    if (webSocket) {<br>        return;<br>    }</p>
<pre><code>// 注意：url 的格式
webSocket = \[\[SRWebSocket alloc\] initWithURL:\[NSURL URLWithString:\[NSString stringWithFormat:@&quot;ws://%@:%d&quot;, Khost, Kport\]\]\];

webSocket.delegate = self;

// 设置代理线程 queue
NSOperationQueue * queue = \[\[NSOperationQueue alloc\]init\];
queue.maxConcurrentOperationCount = 1;

\[webSocket setDelegateOperationQueue:queue\];

// 连接
\[webSocket open\];
</code></pre><p>}</p>
<p>/**<br> * @brief 初始化心跳<br> */<br>- (void)initHeartBeat<br>{<br>    dispatch_main_async_safe(^{</p>
<pre><code>    \[self destoryHeartBeat\];

    __weak typeof(self) weakSelf = self;
    // 心跳设置为 3 分钟，NAT 超时一般为 5 分钟
    heartBeat = \[NSTimer scheduledTimerWithTimeInterval:3\*60 repeats:YES block:^(NSTimer \* _Nonnull timer) {
        NSLog(@&quot;heart&quot;);

        // 和服务端约定好发送什么作为心跳标识，尽可能的减小心跳包的大小
        \[weakSelf sendMsg:@&quot;heart&quot;\];
    }\];
    \[\[NSRunLoop currentRunLoop\]addTimer:heartBeat forMode:NSRunLoopCommonModes\];
})   
</code></pre><p>}</p>
<p>/**<br> * @brief 取消心跳<br> */<br>- (void)destoryHeartBeat<br>{<br>    dispatch_main_async_safe(^{<br>        if (heartBeat) {<br>            [heartBeat invalidate];<br>            heartBeat = nil;<br>        }<br>    })<br>}</p>
<p>#pragma mark - 对外的一些接口<br>/**<br> * @brief  建立连接<br> */<br>- (void)connect<br>{<br>    [self initSocket];</p>
<pre><code>// 每次正常连接的时候清零重连时间
reConnectTime = 0;
</code></pre><p>}</p>
<p>/**<br> * @brief 断开连接<br> */<br>- (void)disConnect<br>{<br>    if (webSocket) {<br>        [webSocket close];<br>        webSocket = nil;<br>    }<br>}</p>
<p>/**<br> * @brief 发送消息<br> */<br>- (void)sendMsg:(NSString *)msg<br>{<br>    [webSocket send:msg];<br>}</p>
<p>/**<br> * @brief 重连机制<br> */<br>- (void)reConnect<br>{<br>    [self disConnect];</p>
<pre><code>// 超过一分钟就不再重连 所以只会重连 5 次，2^5 = 64
if (reConnectTime &gt; 64) {
    return;
}

dispatch\_after( dispatch\_time(DISPATCH\_TIME\_NOW, (int64\_t)(reConnectTime * NSEC\_PER_SEC)), 
                dispatch\_get\_main_queue(), ^{
    webSocket = nil;
    \[self initSocket\];
});


// 重连时间 2 的指数级增长
if (reConnectTime == 0) {
    reConnectTime = 2;
}
else {
    reConnectTime *= 2;
}
</code></pre><p>}</p>
<p>/**<br> * @brief pingPong<br> */<br>- (void)ping<br>{<br>    [webSocket sendPing:nil];<br>}</p>
<p>#pragma mark - SRWebSocketDelegate</p>
<p>- (void)webSocket:(SRWebSocket *)webSocket didReceiveMessage:(id)message<br>{<br>    NSLog(@”服务器返回收到消息:%@”, message);<br>}</p>
<p>- (void)webSocketDidOpen:(SRWebSocket *)webSocket<br>{<br>    NSLog(@”连接成功”);</p>
<pre><code>// 连接成功了开始发送心跳
\[self initHeartBeat\];
</code></pre><p>}</p>
<p>/**<br> * @brief open 失败的时候调用<br> */<br>- (void)webSocket:(SRWebSocket <em>)webSocket didFailWithError:(NSError </em>)error<br>{<br>    NSLog(@”连接失败…..\n%@”,error);</p>
<pre><code>// 失败了就去重连
\[self reConnect\];
</code></pre><p>}</p>
<p>/**<br> * @brief 网络连接中断被调用<br> */<br>- (void)webSocket:(SRWebSocket <em>)webSocket didCloseWithCode:(NSInteger)code reason:(NSString </em>)reason wasClean:(BOOL)wasClean<br>{<br>    NSLog(@”被关闭连接，code:%ld,reason:%@,wasClean:%d”,code,reason,wasClean);</p>
<pre><code>// 如果是被用户自己中断的那么直接断开连接，否则开始重连
if (code == disConnectByUser) {
    \[self disConnect\];
}
else{    
    \[self reConnect\];
}
// 断开连接时销毁心跳
\[self destoryHeartBeat\];
</code></pre><p>}</p>
<p>/**<br> * @brief sendPing 的时候，如果网络通的话，则会收到回调，但是必须保证 ScoketOpen，否则会 crash<br> */<br>- (void)webSocket:(SRWebSocket <em>)webSocket didReceivePong:(NSData </em>)pongPayload<br>{<br>    NSLog(@”收到 pong 回调”);<br>}</p>
<p>/**<br> * @brief 将收到的消息，是否需要把 data 转换为 NSString，每次收到消息都会被调用，默认 YES<br> */<br>//- (BOOL)webSocketShouldConvertTextFrameToString:(SRWebSocket *)webSocket<br>//{<br>//    NSLog(@”webSocketShouldConvertTextFrameToString”);<br>//<br>//    return NO;<br>//}</p>
<p>.m 文件有点长，可以参照 github 中的 demo 进行阅读，这回添加了一些细节的东西，包括一个简单的心跳、重连机制，还有 webScoket 封装好的一个 pingpong 机制。</p>
<p>代码非常简单，配合着注释读一读，应该很容易理解。</p>
<p>需要说一下的是这个心跳机制是一个定时的间隔，往往可能会有更复杂实现，比如我们正在发送消息的时候，可能就不需要心跳。当不在发送的时候再开启心跳之类的。微信有一种更高端的实现方式，有兴趣的小伙伴可以看看：<a href="https://link.jianshu.com?t=http://www.52im.net/thread-120-1-1.html" target="_blank" rel="noopener">微信的智能心跳实现方式</a></p>
<p>还有一点需要说的就是这个重连机制，demo 中采用的是 2 的指数级别增长，第一次立刻重连，第二次 2 秒，第三次 4 秒，第四次 8 秒…直到大于 64 秒就不再重连。而任意的一次成功的连接，都会重置这个重连时间。</p>
<p>最后一点需要说的是，这个框架给我们封装的 webscoket 在调用它的 sendPing 方法之前，一定要判断当前 scoket 是否连接，如果不是连接状态，程序则会 crash。</p>
<p>客户端的实现就大致如此，接着同样我们需要实现一个服务端，来看看实际通讯效果。</p>
<h5 id="七、webScoket-服务端实现"><a href="#七、webScoket-服务端实现" class="headerlink" title="七、webScoket 服务端实现"></a>七、webScoket 服务端实现</h5><p>在这里无法沿用之前的 node.js 例子了，因为这并不是一个原生的 scoket，服务端同样需要遵守 webScoket 协议，两者才能实现通信。</p>
<p>其实这里实现也很简单，采用 node.js 的 ws 模块，只需要用 npm 去安装 ws 即可。</p>
<p>什么是 npm 呢？</p>
<p>举个例子，npm 之于 Node.js 相当于 cocoaPods 之于 iOS，它就是一个拓展模块的一个管理工具。这篇文章：<a href="https://link.jianshu.com?t=http://www.runoob.com/nodejs/nodejs-npm.html" target="_blank" rel="noopener">npm 的使用</a></p>
<p>我们进入当前脚本目录，输入终端命令，即可安装 ws 模块：</p>
<p>$ npm install ws</p>
<p>如果懒得去看 npm，直接下载 github 中的 WSServer.js 文件运行即可。</p>
<p>该源文件代码如下：</p>
<p>var WebSocketServer = require(‘ws’).Server,</p>
<p>wss = new WebSocketServer({ port: 6969 });<br>wss.on(‘connection’, function (ws) {<br>    console.log(‘client connected’);</p>
<pre><code>ws.send(&apos;你是第&apos; + wss.clients.length + &apos;位&apos;);  
//收到消息回调
ws.on(&apos;message&apos;, function (message) {
    console.log(message);
    ws.send(&apos;收到:&apos;+message);  
});

 // 退出聊天  
ws.on(&apos;close&apos;, function(close) {  

    console.log(&apos;退出连接了&apos;);  
});  
</code></pre><p>});<br>console.log(‘开始监听6969端口’);</p>
<p>代码逻辑就是监听了本机 6969 端口，在客户端连接时打印 lient connected，并且向客户端发送：你是第几位。如果收到客户端消息后，打印消息，并且向客户端发送这条收到的消息。</p>
<h5 id="八、MQTT"><a href="#八、MQTT" class="headerlink" title="八、MQTT"></a>八、MQTT</h5><p>MQTT 是一个聊天协议，它比 webScoket 更上层，属于应用层。</p>
<p>它的基本模式是简单的发布订阅，也就是说当一条消息发出去的时候，谁订阅了谁就会收到。其实它并不适合 IM 的场景，例如用来实现有些简单 IM 场景，却需要很大量的、复杂的处理。</p>
<p>比较适合它的场景为订阅发布这种模式的，例如微信的实时共享位置、滴滴的地图上小车的移动、客户端推送等功能。</p>
<p>首先我们来看看基于 MQTT 协议的框架 MQTTKit。</p>
<p>这个框架是 c 来写的，把一些方法公开在 MQTTKit 类中，对外用 OC 来调用，我们来看看这个类：</p>
<p>@interface MQTTClient : NSObject {<br>    struct mosquitto *mosq;<br>}</p>
<p>@property (readwrite, copy) NSString <em>clientID;<br>@property (readwrite, copy) NSString </em>host;<br>@property (readwrite, assign) unsigned short port;<br>@property (readwrite, copy) NSString <em>username;<br>@property (readwrite, copy) NSString </em>password;<br>@property (readwrite, assign) unsigned short keepAlive;<br>@property (readwrite, assign) BOOL cleanSession;<br>@property (nonatomic, copy) MQTTMessageHandler messageHandler;</p>
<p>+ (void) initialize;<br>+ (NSString*) version;</p>
<p>- (MQTTClient<em>) initWithClientId: (NSString </em>)clientId;<br>- (void) setMessageRetry: (NSUInteger)seconds;</p>
<p>#pragma mark - Connection</p>
<p>- (void) connectWithCompletionHandler:(void (^)(MQTTConnectionReturnCode code))completionHandler;<br>- (void) connectToHost: (NSString<em>)host<br>     completionHandler:(void (^)(MQTTConnectionReturnCode code))completionHandler;<br>- (void) disconnectWithCompletionHandler:(void (^)(NSUInteger code))completionHandler;<br>- (void) reconnect;<br>- (void)setWillData:(NSData </em>)payload<br>            toTopic:(NSString <em>)willTopic<br>            withQos:(MQTTQualityOfService)willQos<br>             retain:(BOOL)retain;<br>- (void)setWill:(NSString </em>)payload<br>        toTopic:(NSString *)willTopic<br>        withQos:(MQTTQualityOfService)willQos<br>         retain:(BOOL)retain;<br>- (void)clearWill;</p>
<p>#pragma mark - Publish</p>
<p>- (void)publishData:(NSData <em>)payload<br>            toTopic:(NSString </em>)topic<br>            withQos:(MQTTQualityOfService)qos<br>             retain:(BOOL)retain<br>  completionHandler:(void (^)(int mid))completionHandler;<br>- (void)publishString:(NSString <em>)payload<br>              toTopic:(NSString </em>)topic<br>              withQos:(MQTTQualityOfService)qos<br>               retain:(BOOL)retain<br>    completionHandler:(void (^)(int mid))completionHandler;</p>
<p>#pragma mark - Subscribe</p>
<p>- (void)subscribe:(NSString <em>)topic<br>withCompletionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;<br>- (void)subscribe:(NSString </em>)topic<br>          withQos:(MQTTQualityOfService)qos<br>completionHandler:(MQTTSubscriptionCompletionHandler)completionHandler;<br>- (void)unsubscribe: (NSString *)topic<br>withCompletionHandler:(void (^)(void))completionHandler;</p>
<p>这个类一共分为 4 个部分：初始化、连接、发布、订阅，具体方法的作用可以先看看方法名理解下，接下来用这个框架封装一个实例。</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>@interface MQTTManager : NSObject</p>
<p>+ (instancetype)sharedInstance;</p>
<p>- (void)connect;<br>- (void)disConnect;</p>
<p>- (void)sendMsg:(NSString *)msg;</p>
<p>@end</p>
<p>#import “MQTTManager.h”</p>
<p>#import “MQTTKit.h”</p>
<p>static NSString <em> Khost = @”127.0.0.1”;<br>static const uint16_t Kport = 6969;<br>static NSString </em> KClientID = @”tuyaohui”;</p>
<p>@interface MQTTManager()<br>{<br>    MQTTClient * client;<br>}</p>
<p>@end</p>
<p>@implementation MQTTManager</p>
<p>+ (instancetype)sharedInstance<br>{<br>    static dispatch_once_t onceToken;<br>    static MQTTManager *instance = nil;<br>    dispatch_once(&amp;onceToken, ^{<br>        instance = [[self alloc]init];<br>    });<br>    return instance;<br>}</p>
<p>/**<br> * @brief 初始化连接<br> */<br>- (void)initSocket<br>{<br>    if (client) {<br>        [self disConnect];<br>    }</p>
<pre><code>client = \[\[MQTTClient alloc\] initWithClientId:KClientID\];
client.port = Kport;

\[client setMessageHandler:^(MQTTMessage *message) {
     // 收到消息的回调，前提是得先订阅

     NSString * msg = \[\[NSString alloc\] initWithData:message.payload encoding:NSUTF8StringEncoding\];

     NSLog(@&quot;收到服务端消息：%@&quot;,msg);
 }\];

\[client connectToHost:Khost completionHandler:^(MQTTConnectionReturnCode code) {

    switch (code) {
        case ConnectionAccepted:
            NSLog(@&quot;MQTT连接成功&quot;);
            // 订阅自己 ID 的消息，这样收到消息就能回调
            \[client subscribe:client.clientID withCompletionHandler:^(NSArray *grantedQos) {

                NSLog(@&quot;订阅 tuyaohui 成功&quot;);
            }\];

            break;

        case ConnectionRefusedBadUserNameOrPassword:

            NSLog(@&quot;错误的用户名密码&quot;);

        //....
        default:
            NSLog(@&quot;MQTT连接失败&quot;);

            break;
    }

}\];
</code></pre><p>}</p>
<p>#pragma mark - 对外的一些接口<br>/**<br> * @brief 建立连接<br> */<br>- (void)connect<br>{<br>    [self initSocket];<br>}</p>
<p>/**<br> * @brief 断开连接<br> */<br>- (void)disConnect<br>{<br>    if (client) {<br>        // 取消订阅<br>        [client unsubscribe:client.clientID withCompletionHandler:^{<br>            NSLog(@”取消订阅 tuyaohui 成功”);</p>
<pre><code>    }\];
    // 断开连接
    \[client disconnectWithCompletionHandler:^(NSUInteger code) {

        NSLog(@&quot;断开MQTT成功&quot;);
    }\];

    client = nil;
}
</code></pre><p>}</p>
<p>/**<br> * @brief 发送消息<br> */<br>- (void)sendMsg:(NSString *)msg<br>{<br>    // 发送一条消息，发送给自己订阅的主题<br>    [client publishString:msg toTopic:KClientID withQos:ExactlyOnce retain:YES completionHandler:^(int mid) {</p>
<pre><code>}\];
</code></pre><p>}<br>@end</p>
<p>实现代码很简单，需要说一下的是：</p>
<p>①、当我们连接成功了，需要去订阅自己 clientID 的消息，这样才能收到发给自己的消息。<br>②、这个框架为我们实现了一个 QOS 机制。</p>
<p>那什么是 QOS 呢？</p>
<p>QoS（Quality of Service <a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E8%B4%A8%E9%87%8F" target="_blank" rel="noopener">服务质量</a>）指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。</p>
<p>在这里，它提供了三个选项：</p>
<p>typedef enum MQTTQualityOfService : NSUInteger {<br>    AtMostOnce,   // 最多发送一次：如果消息没有发送过去，那么就直接丢失<br>    AtLeastOnce,  // 至少发送一次：保证消息一定发送过去，但是发几次不确定<br>    ExactlyOnce   // 精确只发送一次：它内部会有一个很复杂的发送机制，确保消息送到，而且只发送一次<br>} MQTTQualityOfService;</p>
<p>更详细的关于该机制可以看看这篇文章：<a href="https://link.jianshu.com?t=http://www.blogjava.net/yongboy/archive/2014/02/15/409893.html" target="_blank" rel="noopener">MQTT协议笔记之消息流QOS</a>。</p>
<p>同样的我们需要一个用 MQTT 协议实现的服务端，我们还是 node.js 来实现，这次我们还是需要用 npm 来新增一个模块 mosca。</p>
<p>服务端代码：</p>
<p>var mosca = require(‘mosca’);  </p>
<p>var MqttServer = new mosca.Server({<br>    port: 6969<br>});  </p>
<p>MqttServer.on(‘clientConnected’, function(client){<br>    console.log(‘收到客户端连接，连接ID：’, client.id);<br>});  </p>
<p>/**<br> * 监听MQTT主题消息<br> **/<br>MqttServer.on(‘published’, function(packet, client) {<br>    var topic = packet.topic;<br>    console.log(‘有消息来了’,’topic为：’+topic+’,message为：’+ packet.payload.toString());  </p>
<p>});  </p>
<p>MqttServer.on(‘ready’, function(){<br>    console.log(‘mqtt服务器开启，监听6969端口’);<br>});</p>
<p>服务端代码没几行，开启了一个服务，并且监听本机 6969 端口，同时监听了客户端连接、发布消息等状态。</p>
<p>至此，实现了一个简单的 MQTT 封装。</p>
<h5 id="九、XMPP：XMPPFramework-框架"><a href="#九、XMPP：XMPPFramework-框架" class="headerlink" title="九、XMPP：XMPPFramework 框架"></a>九、XMPP：XMPPFramework 框架</h5><p>个人感觉 XMPP 对于 IM 来说实在是不堪重用，仅仅只能作为一个玩具 demo，给大家练练手。</p>
<p>网上有太多 XMPP 的内容了，相当一部分用 openfire 来做服务端，这一套东西实在是太老了。如果仍然感兴趣的可以看这篇文章：<a href="http://www.cocoachina.com/ios/20141219/10703.html" target="_blank" rel="noopener">iOS 的 XMPPFramework 简介</a>。</p>
<h5 id="十、IM-传输格式"><a href="#十、IM-传输格式" class="headerlink" title="十、IM 传输格式"></a>十、IM 传输格式</h5><p>引用陈宜龙大神文章（<a href="https://www.jianshu.com/users/96a14318a4de/latest_articles" target="_blank" rel="noopener">iOS程序犭袁</a> ）中一段：使用 ProtocolBuffer 减少 Payload。</p>
<p>滴滴打车 40%；</p>
<p>携程之前分享过，说是采用新的 Protocol Buffer 数据格式 + Gzip压缩后的 Payload 大小降低了 15%-45%。数据序列化耗时下降了 80%-90%。</p>
<p>采用高效安全的私有协议，支持长连接的复用，稳定省电省流量。</p>
<p>【高效】</p>
<p>提高网络请求成功率，消息体越大，失败几率随之增加。</p>
<p>【省流量】</p>
<p>流量消耗极少，省流量。一条消息数据用 Protobuf 序列化后的大小是 JSON 的 1/10、XML 格式的 1/20、是二进制序列化的 1/10。同 XML 相比， Protobuf 性能优势明显。它以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。</p>
<p>【省电】</p>
<p>【高效心跳包】</p>
<p>同时心跳包协议对 IM 的电量和流量影响很大，对心跳包协议上进行了极简设计：仅 1 Byte。</p>
<p>【易于使用】</p>
<p>开发人员通过按照一定的语法定义结构化的消息格式，然后发送给命令行工具，工具将自动生成相关的类，可以支持java、c++、python、Objective-C 等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。语言支持：原生支持 c++、java、python、Objective-C 等多达 10 余种语言。 2015-08-27 Protocol Buffers v3.0.0-beta-1 中发布了 Objective-C(Alpha) 版本，2016-07-28 3.0 Protocol Buffers v3.0.0 正式版发布，正式支持 Objective-C。</p>
<p>【可靠】</p>
<p>微信和手机 QQ 这样的主流 IM 应用也早已在使用它（采用的是改造过的 Protobuf 协议）</p>
<p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">github</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-94dc79bb6c608924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11"></p>
<p>验证 Protobuf 的高性能：对数据分别操作 100、1000、10000 和 100000 次进行了测试。</p>
<p>纵坐标是完成时间，单位是毫秒。下图依次：1、反序列化    2、序列化    3、字节长度。<a href="http://www.cnblogs.com/beyondbit/p/4778264.html" target="_blank" rel="noopener">数据来源</a>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-68a519a95716a1e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-9671c7c62a2d9462.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="13"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-3768d8ba7cb21291.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/551/format/webp" alt="14"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702646-356bf2a501d04177.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/556/format/webp" alt="15"></p>
<p>数据来自：项目 <a href="https://link.jianshu.com?t=https://github.com/eishay/jvm-serializers/wiki" target="_blank" rel="noopener">thrift-protobuf-compare</a>，测试项为 Total Time，也就是 指一个对象操作的整个时间，包括创建对象，将对象序列化为内存中的字节序列，然后再反序列化的整个过程。从测试结果可以看到 Protobuf 的成绩很好。</p>
<p>缺点：</p>
<p>可能会造成 APP 的包体积增大，通过 Google 提供的脚本生成的 Model，会非常“庞大”，Model 多了，包体积也就会跟着变大。 Model 过多，可能导致 APP 打包后的体积骤增，但 IM 服务所使用的 Model 非常少，比如在 ChatKit-OC 中只用到了一个 Protobuf 的 Model:Message 对象，对包体积的影响微乎其微。</p>
<p>在使用过程中要合理地权衡包体积以及传输效率的问题，据说去哪儿网，就曾经为了减少包体积，减少了 Protobuf 的使用。</p>
<p>综上所述，我们选择传输格式的时候：ProtocolBuffer &gt; Json &gt; XML</p>
<p>如果大家对 ProtocolBuffer 用法感兴趣可以参考下这两篇文章：<a href="https://www.jianshu.com/p/8c6c009bc500" target="_blank" rel="noopener">ProtocolBuffer for Objective-C 运行环境配置及使用</a></p>
<p>、<a href="https://link.jianshu.com?t=http://www.qingpingshan.com/rjbc/ios/181571.html" target="_blank" rel="noopener">iOS之ProtocolBuffer搭建和示例demo  
</a></p>
<h5 id="十一、IM-的其它问题"><a href="#十一、IM-的其它问题" class="headerlink" title="十一、IM 的其它问题"></a>十一、IM 的其它问题</h5><p>1、IM 的可靠性</p>
<p>之前穿插在例子中提到过：心跳机制、PingPong 机制、断线重连机制、还有后面所说的 QOS 机制。这些被用来保证连接的可用，消息的即时与准确的送达等。</p>
<p>上述内容保证了 IM 服务时的可靠性，其实我们能做的还有很多：比如在大文件传输的时候使用分片上传、断点续传、秒传技术等来保证文件的传输。</p>
<p>2、安全性</p>
<p>通常还需要一些安全机制来保证 IM 通信安全。例如：<a href="https://link.jianshu.com?t=https://github.com/ChenYilong/iOSBlog/blob/master/Tips/%E5%9F%BA%E4%BA%8EWebsocket%E7%9A%84IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF/%E9%98%B2%20DNS%20%E6%B1%A1%E6%9F%93%E6%96%B9%E6%A1%88.md" target="_blank" rel="noopener">防止 DNS 污染</a>、帐号安全、第三方服务器鉴权、单点登录等。</p>
<p>3、一些其他的优化</p>
<p>类似微信，服务器不做聊天记录的存储，只在本机进行缓存，这样可以减少对服务端数据的请求，一方面减轻了服务器的压力，另一方面减少客户端流量的消耗。</p>
<p>进行 http 连接的时候尽量采用上层 API，类似 NSUrlSession。而网络框架尽量使用 AFNetWorking3。因为这些上层网络请求都用的是 HTTP/2 ，我们请求的时候可以复用这些连接。</p>
<p>更多优化相关内容可以参考参考这篇文章：<a href="https://www.jianshu.com/p/8cd908148f9e" target="_blank" rel="noopener">IM 即时通讯技术在多应用场景下的技术实现，以及性能调优</a></p>
<h5 id="十二、音视频通话"><a href="#十二、音视频通话" class="headerlink" title="十二、音视频通话"></a>十二、音视频通话</h5><p>IM 应用中的实时音视频技术，几乎是 IM 开发中的最后一道高墙。原因在于：实时音视频技术 = 音视频处理技术 + 网络传输技术的横向技术应用集合体，而公共互联网不是为了实时通信设计的。</p>
<p>实时音视频技术上的实现内容主要包括：音视频的采集、编码、网络传输、解码、播放等环节。这么多项并不是简单的技术应用，如果把握不当，将会在在实际开发过程中遇到一个又一个的坑。</p>
<p>相关系列的文章：<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-228-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（一）：视频编解码之理论概述</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-229-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（二）：视频编解码之数字视频介绍</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-232-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（三）：视频编解码之编码基础</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-235-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（四）：视频编解码之预测技术介绍</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-237-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（五）：认识主流视频编码技术H.264</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-241-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（六）：如何开始音频编解码技术的学习</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-242-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（七）：音频基础及编码原理入门</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-243-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（八）：常见的实时语音通讯编码标准</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-247-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（九）：实时语音通讯的回音及回音消除�概述</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-250-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十）：实时语音通讯的回音消除�技术详解</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-251-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十一）：实时语音通讯丢包补偿技术详解</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-253-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十二）：多人实时音视频聊天架构探讨</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-266-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十三）：实时视频编码H.264的特点与优势</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-267-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十四）：实时音视频数据传输协议介绍</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-269-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十五）：聊聊P2P与实时音视频的应用情况</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-270-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十六）：移动端实时音视频开发的几个建议</a>》<br>《<a href="https://link.jianshu.com?t=http://www.52im.net/thread-274-1-1.html" target="_blank" rel="noopener">即时通讯音视频开发（十七）：视频编码H.264、V8的前世今生</a>》</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2019/03/26/iosim/">http://yoursite.com/2019/03/26/iosim/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/03/26/tcp-e7-9a-84-e6-96-ad-e5-8c-85-e3-80-81-e7-b2-98-e5-8c-85/" class="pre"> TCP 的断包、粘包		</a><a href="/2019/03/25/php-e5-bc-80-e5-90-af-socket-e6-9c-8d-e5-8a-a1/" class="next"> php 开启 socket 服务		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、实现-IM-的方式"><span class="toc-text">一、实现 IM 的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、传输协议的选择"><span class="toc-text">二、传输协议的选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、聊天协议"><span class="toc-text">三、聊天协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、直接用-OS-底层-Socket-来实现一个简单的-IM"><span class="toc-text">四、直接用 OS 底层 Socket 来实现一个简单的 IM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、基于-Socket-原生的-CocoaAsyncSocket"><span class="toc-text">五、基于 Socket 原生的 CocoaAsyncSocket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、基于-webScoket-的-IM"><span class="toc-text">六、基于 webScoket 的 IM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、webScoket-服务端实现"><span class="toc-text">七、webScoket 服务端实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八、MQTT"><span class="toc-text">八、MQTT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#九、XMPP：XMPPFramework-框架"><span class="toc-text">九、XMPP：XMPPFramework 框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十、IM-传输格式"><span class="toc-text">十、IM 传输格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十一、IM-的其它问题"><span class="toc-text">十一、IM 的其它问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十二、音视频通话"><span class="toc-text">十二、音视频通话</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>