<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> Block 循环引用问题		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> Block 循环引用问题		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> Block 循环引用问题		</h1><div class="post-meta"><a href="/2018/02/26/block-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e9-97-ae-e9-a2-98/#comments" class="comment-count"></a><p><span class="date">Feb 26, 2018</span><span><a href="/categories/底层原理/" class="category">底层原理</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="http://blog.csdn.net/qq_30513483/article/details/52587551" target="_blank" rel="noopener">http://blog.csdn.net/qq_30513483/article/details/52587551</a></p>
<p><strong>前言</strong></p>
<p>实际使用 Block 的过程中，还是会遇到一些问题，比如 Retain Circle 的问题。</p>
<p><strong>目录</strong></p>
<p>1、Retain Circle 的由来</p>
<p>2、<strong>weak、</strong>strong 的实现原理</p>
<p>3、weakSelf、strongSelf 的用途</p>
<p>4、@weakify、@strongify 实现原理</p>
<p>一、RetainCircle的由来</p>
<p>当 A 对象里面强引用了 B 对象，B 对象又强引用了 A 对象，这样两者的 retainCount 值一直都无法为 0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/BlockObject.jpeg" alt></p>
<p>这是 2 个对象之间的，相应的，这种循环还能存在于 3、4 … n 个对象之间，只要相互形成环，就会导致 Retain Cicle 的问题。</p>
<p>当然也存在自身引用自身的。当一个对象内部的一个 obj，强引用的自身，也会导致循环引用的问题出现。常见的就是 block 里面引用的问题。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/BlockRelate.jpeg" alt></p>
<p>二、<strong>weak、</strong>strong 的实现原理</p>
<p>在 ARC 环境下，id 类型和对象类型、C 语言其他类型不同，类型前必须加上所有权的修饰符。</p>
<p>所有权修饰符总共有 4 种：</p>
<p>①、<strong>strong 修饰符<br>②、</strong>weak 修饰符<br>③、__unsafe_unretained 修饰符<br>④、__autoreleasing 修饰符</p>
<p>一般我们如果不写，默认的修饰符是 __strong。</p>
<p>要想弄清楚 <strong>strong、</strong>weak 的实现原理，我们就需要研究研究 clang(LLVM编译器)和 objc4 Objective-C runtime 库了。</p>
<p>关于 clang 有一份<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="noopener">关于ARC详细的文档</a>，有兴趣的可以仔细研究一下文档里面的说明和例子，很有帮助。</p>
<p>以下的讲解，也会来自于上述文档中的函数说明。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block1.jpg" alt></p>
<p>1、__strong 的实现原理</p>
<p>①、对象持有自己</p>
<p>首先我们先来看看生成的对象持有自己的情况，利用 alloc/new/copy/mutableCopy 生成对象。</p>
<p>当我们声明了一个 __strong 对象</p>
<p>{  id __strong obj = [[NSObject alloc] init];  }</p>
<p>LLVM 编译器会把上述代码转换成下面的样子</p>
<p>id __attribute__((objc_ownership(strong))) <strong>obj</strong> = ((NSObject <em>(</em>)(id, SEL))(void <em>)objc_msgSend)((id)((NSObject </em>(<em>)(id, SEL))(void </em>)objc_msgSend)((id)objc_getClass(“NSObject”), sel_registerName(“alloc”)), sel_registerName(“init”));</p>
<p>相应的会调用</p>
<p>id obj = objc_msgSend(NSObject, @selector(alloc));</p>
<p>objc_msgSend(obj,selector(init));</p>
<p>objc_release(obj);</p>
<p>上述这些方法都好理解。在 ARC 有效的时候就会自动插入 release 代码，在作用域结束的时候自动释放。</p>
<p>②、对象不持有自己</p>
<p>生成对象的时候不用 alloc/new/copy/mutableCopy 等方法。</p>
<p>{  id __strong obj = [NSMutableArray array];  }</p>
<p>LLVM 编译器会把上述代码转换成下面的样子</p>
<p>id __attribute__((objc_ownership(strong))) <strong>array</strong> = ((NSMutableArray <em>(</em>)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(“NSMutableArray”), sel_registerName(“array”));</p>
<p>查看 LLVM 文档，其实是下述的过程，相应的会调用</p>
<p>id obj = objc_msgSend(NSMutableArray, @selector(array));</p>
<p>objc_retainAutoreleasedReturnValue(obj);</p>
<p>objc_release(obj);</p>
<p>与之前对象会持有自己的情况不同，这里多了一个 objc_retainAutoreleasedReturnValue 函数。</p>
<p>这里有 3 个函数需要说明：</p>
<p>1、<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id69" target="_blank" rel="noopener">id objc_retainAutoreleaseReturnValue(id value);</a></p>
<p><em>Precondition:</em> value is null or a pointer to a valid object.</p>
<p>If value is null, this call has no effect. Otherwise, it performs a retain operation followed by the operation described in <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue" target="_blank" rel="noopener">objc_autoreleaseReturnValue</a>.</p>
<p>Equivalent to the following code:</p>
<p>id objc_retainAutoreleaseReturnValue(id value) {</p>
<p>return objc_autoreleaseReturnValue(objc_retain(value));</p>
<p>}</p>
<p>Always returns value</p>
<p>2、<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id70" target="_blank" rel="noopener">id objc_retainAutoreleasedReturnValue(id value);</a></p>
<p><em>Precondition:</em> value is null or a pointer to a valid object.</p>
<p>If value is null, this call has no effect. Otherwise, it attempts to accept a hand off of a retain count from a call to <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-autoreleasereturnvalue" target="_blank" rel="noopener">objc_autoreleaseReturnValue</a> on value in a recently-called function or something it calls. If that fails, it performs a retain operation exactly like <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retain" target="_blank" rel="noopener">objc_retain</a>.</p>
<p>Always returns value</p>
<p>3、<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id59" target="_blank" rel="noopener">id objc_autoreleaseReturnValue(id value);</a></p>
<p><em>Precondition:</em> value is null or a pointer to a valid object.</p>
<p>If value is null, this call has no effect. Otherwise, it makes a best effort to hand off ownership of a retain count on the object to a call to<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-retainautoreleasedreturnvalue" target="_blank" rel="noopener">objc_retainAutoreleasedReturnValue</a> for the same object in an enclosing call frame. If this is not possible, the object is autoreleased as above.</p>
<p>Always returns value</p>
<p>这 3 个函数其实都是在描述一件事情：it makes a best effort to hand off ownership of a retain count on the object to a call to objc_retainAutoreleasedReturnValue for the same object in an enclosing call frame。</p>
<p>这属于 LLVM 编译器的一个优化。objc_retainAutoreleasedReturnValue 函数是用于自己持有(retain)对象的函数，它持有的对象应为返回注册在 autoreleasepool 中对象的方法或者是函数的返回值。</p>
<p>在 ARC 中原本对象生成之后是要注册到 autoreleasepool 中，但是调用了objc_autoreleasedReturnValue 之后，紧接着调用了 objc_retainAutoreleasedReturnValue，objc_autoreleasedReturnValue 函数会去检查该函数方法或者函数调用方的执行命令列表，如果里面有objc_retainAutoreleasedReturnValue() 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 autoreleasepool 中，也可以返回拿到相应的对象。</p>
<p>2、__weak 的实现原理</p>
<p>声明一个 __weak 对象</p>
<p>{  id __weak obj = strongObj;  }   // 假设这里的 strongObj 是一个已经声明好了的对象。</p>
<p>LLVM 转换成对应的代码</p>
<p>id __attribute__((objc_ownership(none))) <strong>obj1</strong> = strongObj;</p>
<p>相应的会调用</p>
<p>id obj ;</p>
<p>objc_initWeak(&amp;obj,strongObj);</p>
<p>objc_destoryWeak(&amp;obj);</p>
<p>看看文档描述</p>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id62" target="_blank" rel="noopener">id objc_initWeak(id *object, id value);</a></p>
<p><em>Precondition:</em> object is a valid pointer which has not been registered as a <strong>weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is zero-initialized. Otherwise, object is registered as a </strong>weak object pointing to value</p>
<p>Equivalent to the following code:</p>
<p>id objc_initWeak(id _object, id value) { _</p>
<p>object = nil;</p>
<p>return objc_storeWeak(object, value);</p>
<p>}</p>
<p>Returns the value of object after the call.Does not need to be atomic with respect to calls to objc_storeWeak on object</p>
<p>objc_initWeak 的实现其实是这样的：</p>
<p>id objc_initWeak(id * object, id value) {</p>
<p>*object = nil;</p>
<p>return objc_storeWeak(object, value);</p>
<p>}</p>
<p>会把传入的 object 变成 0 或者 nil，然后执行 objc_storeWeak 函数。</p>
<p>那么 objc_destoryWeak 函数是干什么的呢？</p>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id61" target="_blank" rel="noopener">void objc_destroyWeak(id *object);</a></p>
<p><em>Precondition:</em> object is a valid pointer which either contains a null pointer or has been registered as a __weak object. object is unregistered as a weak object, if it ever was. The current value of object is left unspecified; otherwise, equivalent to the following code:</p>
<p>void objc_destroyWeak(id * object) {</p>
<p>objc_storeWeak(object, nil);</p>
<p>}</p>
<p>Does not need to be atomic with respect to calls to objc_storeWeak on object</p>
<p>objc_destoryWeak 函数的实现：</p>
<p>void objc_destroyWeak(id * object) {</p>
<p>objc_storeWeak(object, nil);</p>
<p>}</p>
<p>也是会去调用 objc_storeWeak 函数。objc_initWeak 和 objc_destroyWeak 函数都会去调用 objc_storeWeak 函数，唯一不同的是调用的入参不同，一个是 value，一个是 nil。</p>
<p>那么重点就都落在 objc_storeWeak 函数上了。</p>
<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#id73" target="_blank" rel="noopener">id objc_storeWeak(id *object, id value);</a></p>
<p><em>Precondition:</em> object is a valid pointer which either contains a null pointer or has been registered as a __weak object. value is null or a pointer to a valid object. If value is a null pointer or the object to which it points has begun deallocation, object is assigned null and unregistered as a __weak object. Otherwise, object is registered as a __weak object or has its registration updated to point to value</p>
<p>Returns the value of object after the call.</p>
<p>objc_storeWeak 函数的用途就很明显了。由于 weak 表也是用 Hash table 实现的，所以objc_storeWeak 函数就把第一个入参的变量地址注册到 weak 表中，然后根据第二个入参来决定是否移除。如果第二个参数为 0，那么就把 __weak 变量从 weak 表中删除记录，并从引用计数表中删除对应的键值记录。</p>
<p>所以如果 <strong>weak 引用的原对象如果被释放了，那么对应的 </strong>weak 对象就会被指为 nil。原来就是通过 objc_storeWeak 函数这些函数来实现的。</p>
<p>以上就是 ARC 中<strong>strong 和 </strong>weak 的简单的实现原理，更加详细的还请大家去看看这一章开头提到的那个 LLVM 文档，里面说明的很详细。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block2.png" alt></p>
<p>三、weakSelf、strongSelf 的用途</p>
<p>在提 weakSelf、strongSelf 之前，我们先引入一个 Retain Cicle 的例子。</p>
<p>假设自定义的一个 student 类</p>
<p>例子 1：</p>
<p><strong>Student.h 文件</strong></p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>typedef void(^ Study)();</p>
<p>@interface Student : NSObject</p>
<p>@property (nonatomic, copy) NSString * name;</p>
<p>@property (nonatomic, copy) Study study;</p>
<p>@end</p>
<p><strong>ViewController.m 文件</strong></p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc] init];</p>
<p>student.name = @”Hello World”;</p>
<p>student.study = ^{</p>
<p>NSLog(@”my name is = %@”, student.name);</p>
<p>};</p>
<p>}</p>
<p>到这里，大家应该看出来了，这里肯定出现了循环引用了。student 的 study 的 Block 里面强引用了 student 自身。根据<a href="http://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="noopener">上篇文章</a>的分析，可以知道，_NSConcreteMallocBlock 捕获了外部的对象，会在内部持有它。retainCount 值会加一。</p>
<p>我们用 Instruments 来观察一下。添加 Leak 观察器。</p>
<p>当程序运行起来之后，在 Leak Checks观察器里面应该可以看到红色的❌，点击它就会看到内存 leak了。有 2 个泄露的对象。Block 和 Student 相互循环引用了。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block3.jpeg" alt></p>
<p>打开 Cycles &amp; Roots 观察一下循环的环。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block4.jpg" alt></p>
<p>这里形成环的原因 block 里面持有 student 本身，student 本身又持有 block。</p>
<p>那再看一个例子 2：</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc] init];</p>
<p>student.name  = @”Hello World”;</p>
<p>student.study = ^(NSString * name){</p>
<p>NSLog(@”my name is = %@”,name);</p>
<p>};</p>
<p>student.study(student.name);</p>
<p>}</p>
<p>我把 block 新传入一个参数，传入的是 student.name。这个时候会引起循环引用么？</p>
<p>答案肯定是不会。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block5.jpeg" alt></p>
<p>如上图，并不会出现内存泄露。原因是因为，student 是作为形参传递进 block 的，block 并不会捕获形参到 block 内部进行持有。所以肯定不会造成循环引用。</p>
<p>再改一下。看例子 3：</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@property (nonatomic, copy) NSString * name;</p>
<p>@property (nonatomic, strong) Student * stu;</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc] init];</p>
<p>self.name = @”halfrost”;</p>
<p>self.stu  = student;</p>
<p>student.study = ^{</p>
<p>NSLog(@”my name is = %@”, self.name);</p>
<p>};</p>
<p>student.study();</p>
<p>}</p>
<p>这样会形成循环引用么？</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block6.jpg" alt></p>
<p>答案也是会的(ARC 环境)。</p>
<p>vc → student → block → vc 已经成环。这里即使是 self.name 也是循环引用了，因为 block 不可能说去单独的强持有某个实例的变量，这不符合内存管理规则(交叉管理了)，但是instruments 检测不出来。</p>
<p>(原文写着没有循环引用，我在 ARC 环境测试时，dealloc 不会被调用，说明还被引用这。可以自行验证)。</p>
<p>那遇到循环引用我们改如何处理呢？？类比平时我们经常写的 delegate，可以知道，只要有一边是__weak 就可以打破循环。</p>
<p>先说一种做法，利用 __block 解决循环的做法。例子 4：</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc] init];</p>
<p>__block Student * stu = student;</p>
<p>student.name = @”Hello World”;</p>
<p>student.study = ^{</p>
<p>NSLog(@”my name is = %@”, stu.name);</p>
<p>stu = nil;</p>
<p>};</p>
<p>}</p>
<p>这样写会循环么？看上去应该不会。但是实际上却是会的。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block7.jpg" alt></p>
<p>由于没有执行 study 这个 block，现在 student 持有该 block，block 持有 <strong>block 变量，</strong>block 变量又持有 student 对象。3 者形成了环，导致了循环引用了。</p>
<p>想打破环就需要破坏掉其中一个引用。__block 不持有 student 即可。</p>
<p>只需要执行一下 block 即可。例子 5：</p>
<p>student.study();</p>
<p>这样就不会循环引用了。</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/02/Block8.png" alt></p>
<p>使用 <strong>block 解决循环引用虽然可以控制对象持有时间，在 block 中还能动态的控制 </strong>block 变量的值，可以赋值 nil，也可以赋值其他的值，但是有一个唯一的缺点就是需要执行一次 block 才行。否则还是会造成循环引用。</p>
<p><strong>值得注意的是，在 ARC 下 __block**</strong>会导<strong>**致对象被 retain，有可能导致循环引用。而在 MRC 下，则不会 retain 这个对象，也不会导致循环引用。</strong></p>
<p>接下来可以正式开始讲讲 weakSelf 和 strongSelf 的用法了。</p>
<p>1、weakSelf</p>
<p>说道 weakSelf，需要先来区分几种写法。</p>
<p>①、__weak __typeof(self)weakSelf = self;   // 这是 AFN 里面的写法。。</p>
<p>②、#define WEAKSELF typeof(self) __weak weakSelf = self;</p>
<p>先区分 __typeof() 和 typeof()</p>
<p>AFNetWorking 的库里面的代码都很整洁，里面各方面的代码都可以当做代码范本来阅读。遇到不懂疑惑的，都要深究，肯定会有收获。这里就是一处，平时我们的写法是不带__的，AFN 里面用这种写法有什么特殊的用途么？</p>
<p>在 SOF 上能找到相关的<a href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c" target="_blank" rel="noopener">答案</a>：</p>
<p>__typeof__() and __typeof() are compiler-specific extensions to the C language, because standard C does not include such an operator. Standard C requires compilers to prefix language extensions with a double-underscore (which is also why you should never do so for your own functions, variables, etc.)<br>typeof() is exactly the same, but throws the underscores out the window with the understanding that every modern compiler supports it. (Actually, now that I think about it, Visual C++ might not. It does support decltype() though, which generally provides the same behaviour as typeof().)<br>All three mean the same thing, but none are standard C so a conforming compiler may choose to make any mean something different.</p>
<p>其实两者都是一样的东西，只不过是 C 里面不同的标准，兼容性不同罢了。更加详细的<a href="http://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html#Alternate-Keywords" target="_blank" rel="noopener">官方说明</a></p>
<p>那么抽象出来就是这 2 种写法。</p>
<p>#define WEAKSELF __weak typeof(self)weakSelf  = self;  </p>
<p>#define WEAKSELF typeof(self) __weak weakSelf = self;</p>
<p>这样子看就清楚了，两种写法就是完全一样的。</p>
<p>我们可以用 WEAKSELF 来解决循环引用的问题。例子 6：</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc]init];</p>
<p>student.name = @”Hello World”;</p>
<p>__weak typeof(student) weakSelf = student;</p>
<p>student.study = ^{</p>
<p>NSLog(@”my name is = %@”,weakSelf.name);</p>
<p>};</p>
<p>student.study();</p>
<p>}</p>
<p>这样就解决了循环引用的问题了。</p>
<p>解决循环应用的问题一定要分析清楚哪里出现了循环引用，只需要把其中一环加上 weakSelf 这类似的宏，就可以解决循环引用。如果分析不清楚，就只能无脑添加 weakSelf、strongSelf，这样的做法不可取。</p>
<p>在上面的例子 3 中，就完全不存在循环引用，要是无脑加 weakSelf、strongSelf 是不对的。在例子 6 中，也只需要加一个 weakSelf 就可以了，也不需要加 strongSelf。</p>
<p>曾经在 segmentfault 也看到过这样一个问题，问：<a href="https://segmentfault.com/q/1010000004343510" target="_blank" rel="noopener">为什么 iOS 的 Masonry 中的 self 不会循环引用?</a></p>
<p>UIButton * testButton = [[UIButton alloc] init];</p>
<p>[self.view addSubview:testButton];</p>
<p>testButton.backgroundColor = [UIColor redColor];</p>
<p>[testButton mas_makeConstraints:^(MASConstraintMaker * make) {</p>
<p>make.width.equalTo(@100);</p>
<p>make.height.equalTo(@100);</p>
<p>make.left.equalTo(self.view.mas_left);</p>
<p>make.top.equalTo(self.view.mas_top);</p>
<p>}];</p>
<p>[testButton bk_addEventHandler:^(id sender) {</p>
<p>[self dismissViewControllerAnimated:YES completion:nil];</p>
<p>} forControlEvents:UIControlEventTouchUpInside];</p>
<p>如果我用 blocksKit 的 bk_addEventHandler方法，其中使用 strong self，该 viewController 就无法 dealloc，我理解是因为 self → self.view → testButton → self。 但是如果只用 Mansonry 的 mas_makeConstraints方法，同样使用 strong self，该 viewController 却能正常 dealloc，请问为什么 Masonry 没有导致循环引用？</p>
<p>看到这里，读者应该就应该能回答这个问题了。</p>
<p>- (NSArray <em>)mas_makeConstraints:(void(^)(MASConstraintMaker </em>))block</p>
<p>{</p>
<p>self.translatesAutoresizingMaskIntoConstraints = NO;</p>
<p>MASConstraintMaker * maker = [[MASConstraintMaker alloc] initWithView:self];</p>
<p>block(maker);</p>
<p>return [maker install];</p>
<p>}</p>
<p>关于 Masonry ，它捕获了变量 self，然后对其执行了 setTranslatesAutoresizingMaskIntoConstraints:方法。但是，因为执行完毕后，block会被销毁，没有形成环。所以，没有引起循环依赖。</p>
<p>2、strongSelf</p>
<p>上面介绍完了 weakSelf，既然 weakSelf 能完美解决 Retain Circle 的问题了，那为何还需要strongSelf 呢？</p>
<p>还是先从 AFN 经典说起，以下是 AFN 其中的一段代码：</p>
<p>#pragma mark - NSOperation</p>
<p>- (void)setCompletionBlock:(void (^)(void))block</p>
<p>{</p>
<p>[self.lock lock];</p>
<p>if (!block) {</p>
<p>[super setCompletionBlock:nil];</p>
<p>}</p>
<p>else {</p>
<p>__weak __typeof(self)weakSelf = self;</p>
<p>[super setCompletionBlock:^ {</p>
<p>__strong __typeof(weakSelf)strongSelf = weakSelf;</p>
<p>#pragma clang diagnostic push</p>
<p>#pragma clang diagnostic ignored “-Wgnu”</p>
<p>dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</p>
<p>dispatch_queue_t queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</p>
<p>#pragma clang diagnostic pop</p>
<p>dispatch_group_async(group, queue, ^{</p>
<p>block();</p>
<p>});</p>
<p>dispatch_group_notify(group, url_request_operation_completion_queue(), ^{</p>
<p>[strongSelf setCompletionBlock:nil];</p>
<p>});</p>
<p>}];</p>
<p>}</p>
<p>[self.lock unlock];</p>
<p>}</p>
<p>如果 block 里面不加 __strong __typeof(weakSelf)strongSelf = weakSelf 会如何呢？</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc]init];</p>
<p>student.name = @”Hello World”;</p>
<p>__weak typeof(student) weakSelf = student;</p>
<p>student.study = ^{</p>
<p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{</p>
<p>NSLog(@”my name is = %@”,weakSelf.name); });</p>
<p>};</p>
<p>student.study();</p>
<p>}</p>
<p>输出：</p>
<p>my name is = (null)</p>
<p>为什么输出是这样的呢？</p>
<p>重点就在 dispatch_after 这个函数里面。在 study() 的 block 结束之后，student 被自动释放了。又由于 dispatch_after 里面捕获的 <strong>weak 的 student，根据第二章讲过的 </strong>weak的实现原理，在原对象释放之后 __weak 对象就会变成 null，防止野指针。所以就输出了 null了。</p>
<p>那么我们怎么才能在 weakSelf 之后，block里面还能继续使用 weakSelf 之后的对象呢？</p>
<p>究其根本原因就是 weakSelf 之后，无法控制什么时候会被释放，为了保证在 block 内不会被释放，需要添加 __strong。</p>
<p>在 block 里面使用的 __strong 修饰的 weakSelf 是为了在函数生命周期中防止 self 提前释放。strongSelf 是一个自动变量当 block 执行完毕就会释放自动变量 strongSelf 不会对 self 进行一直进行强引用。</p>
<p>#import “ViewController.h”</p>
<p>#import “Student.h”</p>
<p>@interface ViewController ()</p>
<p>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad</p>
<p>{</p>
<p>[super viewDidLoad];</p>
<p>Student * student = [[Student alloc] init];</p>
<p>student.name = @”Hello World”;</p>
<p>__weak typeof(student) weakSelf = student;</p>
<p>student.study = ^{</p>
<p>__strong typeof(student) strongSelf = weakSelf;</p>
<p>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{</p>
<p>NSLog(@”my name is = %@”,strongSelf.name);</p>
<p>});</p>
<p>};</p>
<p>student.study();</p>
<p>}</p>
<p>输出</p>
<p>my name is = Hello World</p>
<p>至此，我们就明白了 weakSelf、strongSelf 的用途了。</p>
<p>weakSelf 是为了 block 不持有 self，避免 Retain Circle 循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>
<p>strongSelf 的目的是因为一旦进入 block 执行，假设不允许 self 在这个执行过程中释放，就需要加入 strongSelf。block 执行完后这个 strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>
<p>关于 Retain Circle 最后总结一下，有 3 种方式可以解决循环引用。</p>
<p>结合《Effective Objective-C 2.0》(编写高质量 iOS 与 OS X 代码的 52 个有效方法)这本书的例子，来总结一下。</p>
<p><strong>EOCNetworkFetcher.h 文件</strong></p>
<p>typedef void (^ EOCNetworkFetcherCompletionHandler)(NSData * data);</p>
<p>@interface EOCNetworkFetcher : NSObject</p>
<p>@property (nonatomic, strong, readonly) NSURL * url;</p>
<p>- (id)initWithURL:(NSURL *)url;</p>
<p>- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</p>
<p>@end</p>
<p><strong>EOCNetworkFetcher.m 文件</strong></p>
<p>@interface EOCNetworkFetcher ()</p>
<p>@property (nonatomic, strong, readwrite) NSURL * url;</p>
<p>@property (nonatomic, copy) EOCNetworkFetcherCompletionHandler completionHandler;</p>
<p>@property (nonatomic, strong) NSData * downloadData;</p>
<p>@end</p>
<p>@implementation EOCNetworkFetcher</p>
<p>- (id)initWithURL:(NSURL *)url</p>
<p>{</p>
<p>if (self = [super init]) {</p>
<p>_url = url;</p>
<p>}</p>
<p>return self;</p>
<p>}</p>
<p>- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion</p>
<p>{</p>
<p>self.completionHandler = completion;   // 开始网络请求 dispatch_async(dispatch_get_global_queue(0, 0), ^{</p>
<p>_downloadData = [[NSData alloc] initWithContentsOfURL:_url]; dispatch_async(dispatch_get_main_queue(), ^{  // 网络请求完成</p>
<p>[self p_requestCompleted];</p>
<p>});</p>
<p>});</p>
<p>}</p>
<p>- (void)p_requestCompleted</p>
<p>{</p>
<p>if(_completionHandler) {</p>
<p>_completionHandler(_downloadData);</p>
<p>}</p>
<p>}</p>
<p>@end</p>
<p><strong>EOCClass.m 文件</strong></p>
<p>@implementation EOCClass</p>
<p>{</p>
<p>NSData * _fetchedData;</p>
<p>EOCNetworkFetcher * _networkFetcher;</p>
<p>}</p>
<p>- (void)downloadData</p>
<p>{</p>
<p>NSURL * url = [NSURL URLWithString:@”<a href="http://www.baidu.com&quot;\]" target="_blank" rel="noopener">http://www.baidu.com&quot;\]</a>;</p>
<p>_networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</p>
<p>[_networkFetcher startWithCompletionHandler:^(NSData * data) {</p>
<p>_fetchedData = data;</p>
<p>}];</p>
<p>}</p>
<p>@end</p>
<p>在这个例子中，存在 3 者之间形成环</p>
<p>①、completion handler 的 block 因为要设置 _fetchedData 实例变量的值，所以它必须捕获 self变量，也就是说 handler 块保留了 EOCClass 实例；</p>
<p>②、EOCClass 实例通过 strong 实例变量保留了 EOCNetworkFetcher，最后EOCNetworkFetcher 实例对象也会保留了 handler 的 block。</p>
<p>书上说的 3 种方法来打破循环。</p>
<p>方法一：手动释放 EOCNetworkFetcher 使用之后持有的 _networkFetcher，这样可以打破循环引用</p>
<p>- (void)downloadData</p>
<p>{</p>
<p>NSURL * url = [NSURL URLWithString:@”<a href="http://www.baidu.com&quot;\]" target="_blank" rel="noopener">http://www.baidu.com&quot;\]</a>;</p>
<p>_networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</p>
<p>[_networkFetcher startWithCompletionHandler:^(NSData * data) {</p>
<p>_fetchedData = data;</p>
<p>_networkFetcher = nil;   // 加上此行，打破循环引用</p>
<p>}];</p>
<p>}</p>
<p>方法二：直接释放 block。因为在使用完对象之后需要人为手动释放，如果忘记释放就会造成循环引用了。如果使用完 completion handler 之后直接释放 block 即可。打破循环引用</p>
<p>- (void)p_requestCompleted</p>
<p>{</p>
<p>if(_completionHandler) {</p>
<p>_completionHandler(_downloadData);</p>
<p>}</p>
<p>self.completionHandler = nil;  // 加上此行，打破循环引用</p>
<p>}</p>
<p>方法三：使用 weakSelf、strongSelf</p>
<p>- (void)downloadData</p>
<p>{</p>
<p>__weak __typeof(self) weakSelf = self;</p>
<p>NSURL * url = [NSURL URLWithString:@”<a href="http://www.baidu.com&quot;\]" target="_blank" rel="noopener">http://www.baidu.com&quot;\]</a>;</p>
<p>_networkFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</p>
<p>[_networkFetcher startWithCompletionHandler:^(NSData * data) {</p>
<p>__typeof(&amp;*weakSelf) strongSelf = weakSelf;</p>
<p>if (strongSelf) {</p>
<p>strongSelf.fetchedData = data;</p>
<p>}</p>
<p>}];</p>
<p>}</p>
<p><img src="http://www.dzliving.com/wp-content/uploads/2018/11/1194012-59b08429238b088d.png" alt></p>
<p>四、@weakify、@strongify 实现原理</p>
<p>上面讲完了 weakSelf、strongSelf 之后，接下来再讲讲 @weakify、@strongify，这两个关键字是 RAC 中避免 Block 循环引用而开发的 2 个宏，这 2 个宏的实现过程很牛，值得我们学习。</p>
<p>@weakify、@strongify 的作用和 weakSelf、strongSelf 对应的一样。这里我们具体看看大神是怎么实现这 2 个宏的。</p>
<p>直接从源码看起来。</p>
<p>#define weakify(…) \</p>
<p>rac_keywordify \</p>
<p>metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)</p>
<p>#define strongify(…) \</p>
<p>rac_keywordify \</p>
<p>_Pragma(“clang diagnostic push”) \</p>
<p>_Pragma(“clang diagnostic ignored \“-Wshadow\“”) \</p>
<p>metamacro_foreach(rac_strongify_,, __VA_ARGS__) \</p>
<p>_Pragma(“clang diagnostic pop”)</p>
<p>看到这种宏定义，咋一看什么都不知道。那就只能一层层的往下看。</p>
<p>1、weakify</p>
<p>先从 weakify(…) 开始。</p>
<p>#if DEBUG</p>
<p>#define rac_keywordify autoreleasepool {}</p>
<p>#else</p>
<p>#define rac_keywordify try {} @catch (…) {}</p>
<p>#endif</p>
<p>这里在 debug 模式下使用 @autoreleasepool 是为了维持编译器的分析能力，而使用 @try/@catch 是为了防止插入一些不必要的 autoreleasepool。rac_keywordify 实际上就是autoreleasepool {}的宏替换。因为有了 autoreleasepool {}的宏替换，所以 weakify 要加上 @，形成 @autoreleasepool {}。</p>
<p>#define metamacro_foreach_cxt(MACRO, SEP, CONTEXT, …) \</p>
<p>metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(__VA_ARGS__))(MACRO, SEP, CONTEXT, __VA_ARGS__)</p>
<p>__VA_ARGS__：总体来说就是将左边宏中 … 的内容原样抄写在右边 __VA_ARGS__ 所在的位置。它是一个可变参数的宏，是新的 C99 规范中新增的，目前似乎只有 gcc支持(VC 从 VC2005 开始支持)。</p>
<p>那么我们使用 @weakify(self) 传入进去。__VA_ARGS__ 相当于 self。此时我们可以把最新开始的 weakify 套下来。于是就变成了这样：</p>
<p>rac_weakify_,, __weak, __VA_ARGS__ 整体替换MACRO, SEP, CONTEXT, …</p>
<p>这里需要注意的是，源码中就是给的两个”,”逗号是连着的，所以我们也要等效替换参数，相当于 SEP 是空值。</p>
<p>替换完成之后就是下面这个样子：</p>
<p>autoreleasepool {} metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self))(rac_weakify_, , __weak, self)</p>
<p>现在我们需要弄懂的就是 metamacro_concat 和 metamacro_argcount 是干什么用的。</p>
<p>继续看看 metamacro_concat 的实现</p>
<p>#define metamacro_concat(A, B) \</p>
<p>metamacro_concat_(A, B) #define metamacro_concat_(A, B) A ## B</p>
<h2 id="是宏连接符。举个例子："><a href="#是宏连接符。举个例子：" class="headerlink" title="是宏连接符。举个例子："></a>是宏连接符。举个例子：</h2><p>假设宏定义为 #define XNAME(n) x##n，代码为：XNAME(4)，则在预编译时，宏发现XNAME(4) 与 XNAME(n) 匹配，则令 n 为 4，然后将右边的 n 的内容也变为 4，然后将整个XNAME(4) 替换为 x##n，亦即 x4，故最终结果为 XNAME(4) 变为 x4。所以 A##B 就是 AB。</p>
<p>metamacro_argcount 的实现</p>
<p>#define metamacro_argcount(…) \</p>
<p>metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) #define metamacro_at(N, …) \</p>
<p>metamacro_concat(metamacro_at, N)(__VA_ARGS__)</p>
<p>metamacro_concat 是上面讲过的连接符，那么 metamacro_at，N = metamacro_atN，由于 N = 20，于是 metamacro_atN = metamacro_at20。</p>
<p>#define metamacro_at0(…) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at1(_0, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at2(_0, _1, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at3(_0, _1, _2, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at4(_0, _1, _2, _3, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at5(_0, _1, _2, _3, _4, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at6(_0, _1, _2, _3, _4, _5, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at7(_0, _1, _2, _3, _4, _5, _6, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at8(_0, _1, _2, _3, _4, _5, _6, _7, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at9(_0, _1, _2, _3, _4, _5, _6, _7, _8, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at11(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at12(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at13(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at14(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at15(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at16(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at17(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at18(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at19(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, …) metamacro_head(__VA_ARGS__)</p>
<p>#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, …) metamacro_head(__VA_ARGS__)</p>
<p>metamacro_at20 的作用就是截取前 20 个参数，剩下的参数传入 metamacro_head。</p>
<p>#define metamacro_head(…) \</p>
<p>metamacro_head_(__VA_ARGS__, 0)</p>
<p>#define metamacro_head_(FIRST, …) FIRST</p>
<p>metamacro_head 的作用返回第一个参数。返回到上一级 metamacro_at20，如果我们从最源头的@weakify(self)，传递进来，那么 metamacro_at20(self, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)，截取前 20 个参数，最后一个留给metamacro_head_(1)，那么就应该返回 1。</p>
<p>metamacro_concat(metamacro_foreach_cxt, metamacro_argcount(self)) = metamacro_concat(metamacro_foreach_cxt, 1)</p>
<p>最终可以替换成 metamacro_foreach_cxt1。</p>
<p>在源码中继续搜寻。</p>
<p>// metamacro_foreach_cxt expansions</p>
<p>#define metamacro_foreach_cxt0(MACRO, SEP, CONTEXT)</p>
<p>#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)</p>
<p>#define metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \</p>
<p>metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) \</p>
<p>SEP \</p>
<p>MACRO(1, CONTEXT, _1)</p>
<p>#define metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \</p>
<p>metamacro_foreach_cxt2(MACRO, SEP, CONTEXT, _0, _1) \</p>
<p>SEP \</p>
<p>MACRO(2, CONTEXT, _2)</p>
<p>#define metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \</p>
<p>metamacro_foreach_cxt3(MACRO, SEP, CONTEXT, _0, _1, _2) \</p>
<p>SEP \</p>
<p>MACRO(3, CONTEXT, _3)</p>
<p>#define metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \</p>
<p>metamacro_foreach_cxt4(MACRO, SEP, CONTEXT, _0, _1, _2, _3) \</p>
<p>SEP \</p>
<p>MACRO(4, CONTEXT, _4)</p>
<p>#define metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \</p>
<p>metamacro_foreach_cxt5(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4) \</p>
<p>SEP \</p>
<p>MACRO(5, CONTEXT, _5)</p>
<p>#define metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \</p>
<p>metamacro_foreach_cxt6(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5) \</p>
<p>SEP \</p>
<p>MACRO(6, CONTEXT, _6)</p>
<p>#define metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \</p>
<p>metamacro_foreach_cxt7(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6) \</p>
<p>SEP \</p>
<p>MACRO(7, CONTEXT, _7)</p>
<p>#define metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \</p>
<p>metamacro_foreach_cxt8(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7) \</p>
<p>SEP \</p>
<p>MACRO(8, CONTEXT, _8)</p>
<p>#define metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \</p>
<p>metamacro_foreach_cxt9(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8) \</p>
<p>SEP \</p>
<p>MACRO(9, CONTEXT, _9)</p>
<p>#define metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \</p>
<p>metamacro_foreach_cxt10(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9) \</p>
<p>SEP \</p>
<p>MACRO(10, CONTEXT, _10)</p>
<p>#define metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \</p>
<p>metamacro_foreach_cxt11(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) \</p>
<p>SEP \</p>
<p>MACRO(11, CONTEXT, _11)</p>
<p>#define metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \</p>
<p>metamacro_foreach_cxt12(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11) \</p>
<p>SEP \</p>
<p>MACRO(12, CONTEXT, _12)</p>
<p>#define metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \</p>
<p>metamacro_foreach_cxt13(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12) \</p>
<p>SEP \</p>
<p>MACRO(13, CONTEXT, _13)</p>
<p>#define metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \</p>
<p>metamacro_foreach_cxt14(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13) \</p>
<p>SEP \</p>
<p>MACRO(14, CONTEXT, _14)</p>
<p>#define metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \</p>
<p>metamacro_foreach_cxt15(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14) \</p>
<p>SEP \</p>
<p>MACRO(15, CONTEXT, _15)</p>
<p>#define metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \</p>
<p>metamacro_foreach_cxt16(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15) \</p>
<p>SEP \</p>
<p>MACRO(16, CONTEXT, _16)</p>
<p>#define metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \</p>
<p>metamacro_foreach_cxt17(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16) \</p>
<p>SEP \</p>
<p>MACRO(17, CONTEXT, _17)</p>
<p>#define metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \</p>
<p>metamacro_foreach_cxt18(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17) \</p>
<p>SEP \</p>
<p>MACRO(18, CONTEXT, _18)</p>
<p>#define metamacro_foreach_cxt20(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19) \</p>
<p>metamacro_foreach_cxt19(MACRO, SEP, CONTEXT, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18) \</p>
<p>SEP \</p>
<p>MACRO(19, CONTEXT, _19)</p>
<p>metamacro_foreach_cxt 这个宏定义有点像递归，这里可以看到 N 最大就是 20，于是metamacro_foreach_cxt19 就是最大，metamacro_foreach_cxt19 会生成rac_weakify_(0,__weak,_18)，然后再把前 18 个数传入 metamacro_foreach_cxt18，并生成rac_weakify_(0,__weak,_17)，依次类推，一直递推到 metamacro_foreach_cxt0。</p>
<p>#define metamacro\_foreach\_cxt0(MACRO, SEP, CONTEXT)</p>
<p>metamacro_foreach_cxt0 就是终止条件，不做任何操作了。</p>
<p>于是最初的 @weakify 就被替换成</p>
<p>autoreleasepool {}</p>
<p>metamacro_foreach_cxt1(rac_weakify_, , __weak, self)</p>
<p>#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)</p>
<p>代入参数</p>
<p>autoreleasepool {} rac_weakify_（0,__weak,self）</p>
<p>最终需要解析的就是 rac_weakify_</p>
<p>#define rac_weakify_(INDEX, CONTEXT, VAR) \</p>
<p>CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);</p>
<p>把 (0,__weak,self) 的参数替换进来 (INDEX, CONTEXT, VAR)。</p>
<p>INDEX = 0， CONTEXT = __weak，VAR = self，</p>
<p>于是</p>
<p>CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);</p>
<p>等效替换为</p>
<p>__weak __typeof__(self) self_weak_ = self;</p>
<p>最终 @weakify(self) = __weak __typeof__(self) self_weak_ = self; 这里的 self_weak_ 就完全等价于我们之前写的 weakSelf。</p>
<p>2、strongify</p>
<p>再继续分析 strongify(…)</p>
<p>rac_keywordify 还是和 weakify 一样，是 autoreleasepool {}，只为了前面能加上 @</p>
<p>_Pragma(“clang diagnostic push”) \</p>
<p>_Pragma(“clang diagnostic ignored \“-Wshadow\“”) \</p>
<p>_Pragma(“clang diagnostic pop”)</p>
<p>strongify 比 weakify 多了这些 _Pragma 语句。</p>
<p>关键字 _Pragma 是 C99 里面引入的。_Pragma 比 #pragma(在设计上)更加合理，因而功能也有所增强。</p>
<p>上面的等效替换</p>
<p>#pragma clang diagnostic push</p>
<p>#pragma clang diagnostic ignored “-Wshadow”</p>
<p>#pragma clang diagnostic pop</p>
<p>这里的 clang 语句的作用：忽略当一个局部变量或类型声明遮盖另一个变量的警告。</p>
<p>最初的</p>
<p>#define strongify(…) \</p>
<p>rac_keywordify \</p>
<p>_Pragma(“clang diagnostic push”) \</p>
<p>_Pragma(“clang diagnostic ignored \“-Wshadow\“”) \</p>
<p>metamacro_foreach(rac_strongify_,, __VA_ARGS__) \</p>
<p>_Pragma(“clang diagnostic pop”)</p>
<p>strongify 里面需要弄清楚的就是 metamacro_foreach 和 rac_strongify_。</p>
<p>#define metamacro_foreach(MACRO, SEP, …) \</p>
<p>metamacro_foreach_cxt(metamacro_foreach_iter, SEP, MACRO, __VA_ARGS__)</p>
<p>#define rac_strongify_(INDEX, VAR) \</p>
<p>__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</p>
<p>我们先替换一次，SEP = 空 ， MACRO = rac_strongify_ ， __VA_ARGS__ ,  于是替换成这样。</p>
<p>metamacro_foreach_cxt(metamacro_foreach_iter,,rac_strongify_,self)</p>
<p>根据之前分析，metamacro_foreach_cxt 再次等效替换，metamacro_foreach_cxt##1(metamacro_foreach_iter,,rac_strongify_,self)</p>
<p>根据</p>
<p>#define metamacro_foreach_cxt1(MACRO, SEP, CONTEXT, _0) MACRO(0, CONTEXT, _0)</p>
<p>再次替换成 metamacro_foreach_iter(0, rac_strongify_, self)</p>
<p>继续看看 metamacro_foreach_iter 的实现</p>
<p>#define metamacro_foreach_iter(INDEX, MACRO, ARG) MACRO(INDEX, ARG)</p>
<p>最终替换成 rac_strongify_(0,self)</p>
<p>#define rac_strongify_(INDEX, VAR) \</p>
<p>__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</p>
<p>INDEX = 0, VAR = self, 于是 @strongify(self) 就等价于</p>
<p>__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</p>
<p>等价于</p>
<p>__strong __typeof__(self) self = self_weak_;</p>
<p>注意 @strongify(self) 只能使用在 block 中，如果用在 block 外面，会报错，因为这里会提示你Redefinition of ‘self’。</p>
<p><strong>实例</strong></p>
<p>#ifndef weakify</p>
<p>#if DEBUG   // 判断当前代码运行模式</p>
<p>#if __has_feature(objc_arc)  // 判断 ARC 环境</p>
<p>#define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object;     // ## 为连接符</p>
<p>#else</p>
<p>#define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object;</p>
<p>#endif      // 结束 if _has_feature()</p>
<p>#else</p>
<p>#if __has_feature(objc_arc)</p>
<p>#define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object;</p>
<p>#else</p>
<p>#define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object;</p>
<p>#endif      // 结束 if _has_feature()</p>
<p>#endif      // 结束 if DEBUG</p>
<p>#endif      // 结束 ifndef weakify</p>
<p>#ifndef strongify</p>
<p>#if DEBUG</p>
<p>#if __has_feature(objc_arc)</p>
<p>#define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object;</p>
<p>#else</p>
<p>#define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object;</p>
<p>#endif</p>
<p>#else</p>
<p>#if __has_feature(objc_arc)</p>
<p>#define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object;</p>
<p>#else</p>
<p>#define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object;、#endif</p>
<p>#endif</p>
<p>#endif</p>
<p><strong>总结一下</strong></p>
<p>@weakify(self) = @autoreleasepool{} __weak __typeof__ (self) self_weak_ = self;</p>
<p>@strongify(self) = @autoreleasepool{} __strong __typeof__(self) self = self_weak_;</p>
<p>经过分析以后，其实 @weakify(self) 和 @strongify(self) 就是比我们日常写的 weakSelf、strongSelf 多了一个 @autoreleasepool{} 而已，至于为何要用这些复杂的宏定义来做，目前我还没有理解。如果有大神指导其中的原因，还请多多指点。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2018/02/26/block-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e9-97-ae-e9-a2-98/">http://yoursite.com/2018/02/26/block-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e9-97-ae-e9-a2-98/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2018/02/27/e5-bb-ba-e7-ab-99/" class="pre"> 建站（粗略）		</a><a href="/2018/02/24/soa/" class="next"> SOA		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#是宏连接符。举个例子："><span class="toc-text">是宏连接符。举个例子：</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>