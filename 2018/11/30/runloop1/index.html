<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> RunLoop(1)		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> RunLoop(1)		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> RunLoop(1)		</h1><div class="post-meta"><a href="/2018/11/30/runloop1/#comments" class="comment-count"></a><p><span class="date">Nov 30, 2018</span><span><a href="/categories/多线程/" class="category">多线程</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>文章：<a href="http://www.cnblogs.com/kenshincui" target="_blank" rel="noopener">崔江涛（KenshinCui）</a>/<a href="https://www.cnblogs.com/kenshincui/p/6823841.html" target="_blank" rel="noopener">iOS刨根问底-深入理解RunLoop</a>、<a href="https://home.cnblogs.com/u/ioshe/" target="_blank" rel="noopener">一个低调的iOS开发</a>/<a href="https://www.cnblogs.com/ioshe/p/5489112.html" target="_blank" rel="noopener">Runloop 事件源</a>、<a href="https://www.jianshu.com/p/d260d18dd551" target="_blank" rel="noopener">iOS 多线程：『RunLoop』详尽总结</a></p>
<p>RunLoop 实际上是一个对象，这个对象循环处理程序运行过程中出现的各种事件（如触摸事件、UI 刷新事件、定时器事件、Selector 事件），从而保持程序的持续运行。</p>
<p>RunLoop 在没有事件处理的时候，会使线程进入睡眠模式，从而节省 CPU 资源，提高程序性能。</p>
<h5 id="一、CFRunloopRef"><a href="#一、CFRunloopRef" class="headerlink" title="一、CFRunloopRef"></a>一、CFRunloopRef</h5><p>CFRunloopRef 是纯 C 的函数，而 NSRunloop 仅仅是 CFRunloopRef 的 OC 封装，没有增加额外的功能，因此主要分析 CFRunloopRef。苹果已经开源了 <a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="noopener">CFRunloop 源代码</a>。</p>
<p>从代码可以看出 CFRunloopRef 其实是 __CFRunloop 这个结构体的指针。</p>
<p>struct __CFRunLoop {<br>    CFRuntimeBase _base;<br>    pthread_mutex_t <em>lock;          /<em> locked for accessing mode list </em>/<br>    \</em>_CFPort _wakeUpPort;           // used for CFRunLoopWakeUp<br>    Boolean _unused;<br>    volatile _per_run_data <em>_perRunData;       // reset for runs of the run loop<br>    pthread_t _pthread;<br>    uint32_t _winthread;<br>    CFMutableSetRef _commonModes;<br>    CFMutableSetRef _commonModeItems;<br>    CFRunLoopModeRef _currentMode;<br>    CFMutableSetRef _modes;<br>    struct _block_item </em>_blocks_head;<br>    struct _block_item *_blocks_tail;<br>    CFTypeRef _counterpart;<br>};</p>
<p>rl-&gt;_blocks_head<br>rl-&gt;_commonModes</p>
<p>从代码的执行顺序 CFRunLoopRun()/CFRunLoopRunInMode() -&gt; CFRunLoopRunSpecific() -&gt; <strong>CFRunloopRun() 可知 RunLoop 的核心方法是 </strong>CFRunloopRun()。</p>
<p>SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /<em> DOES CALLOUT </em>/</p>
<pre><code>if (currentMode-&gt;\_observerMask &amp; kCFRunLoopEntry ) \_\_CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
if (currentMode-&gt;\_observerMask &amp; kCFRunLoopExit ) \_\_CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);

return result;
</code></pre><p>}</p>
<p>/* 在默认模式下运行当前线程的 runloop。</p>
<p>   通过执行 CFRunLoopStop(_:)或者从 defaultMode 移除所有的 sources 和 timers,来停止 runloop 停止。</p>
<p>   runloop 能够递归运行，你可以通过这个方法在一个 runloop 调用里创建一个嵌套的 runloop 并且加入当前线程的调用栈。CFRunLoopStop() 仅当前 runloop 及其子 runloop 会停止，不影响父 runloop()<br> <em>/<br>void CFRunLoopRun(void) {   /</em> DOES CALLOUT */<br>    int32_t result;<br>    do {<br>        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);<br>        CHECK_FOR_FORK();<br>    } while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);<br>}</p>
<p>/**<br> * 判断其他 runloop 是否处于等待状态，如果用于判断当前 runloop，则永远返回 false<br> */<br>Bool CFRunLoopIsWaiting() {</p>
<p>}</p>
<p>/**<br> * 在指定的模式下运行当前线程的runloop, runloop能够被递归调用,你能够在当前线程的调用栈激活子runloop。你能在你可使用的模式激活任意runloop。<br> * @parma mode: 指定模式,可以是任意CFString类型的字符串(即:可以隐式创建一个模式)但是一个模式必须至少包括一个source或者timer才能运行。不必具体说明 runloop运行在commonModes中的哪个mode,runloop会在一个特定的模式运行。 只有当你注册一个observer时希望observer运行在不止一个模式的时候需要具体说明<br> *<br> * @parma seconds: 指定runloop运行时间. 如果为0,在runloop返回前会被执行一次;忽略returnAfterSourceHandled的值, 如果有多个sources或者timers已准备好立刻运行,仅有一个能被执行(除非sources中有source0)。<br> * @parma returnAfterSourceHandled: 判断运行了一个source之后runloop是否退出。如果为false,runloop继续执行事件直到第二次调遣结束<br> *<br> * @return runloop 退出的原因:<br>                  kCFRunLoopRunFinished:runloop 中已经没有sources和timers<br>                  kCFRunLoopRunStopped:runloop 通过 CFRunLoopStop(_:)方法停止<br>                  kCFRunLoopRunTimedOut:runloop 设置的时间已到<br>                  kCFRunLoopRunHandledSource: 当 returnAfterSourceHandled值为 ture 时,一个 source 被执行完<br><em>/<br>SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /</em> DOES CALLOUT */<br>    CHECK_FOR_FORK();<br>    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);<br>}</p>
<p>为了方便阅读不再直接贴源代码，放一段伪代码：</p>
<p>int32_t __CFRunLoopRun()<br>{<br>    // 通知即将进入 runloop<br>    __CFRunLoopDoObservers(KCFRunLoopEntry);</p>
<pre><code>do
{
    // 通知将要处理 timer 和 source
    __CFRunLoopDoObservers(kCFRunLoopBeforeTimers);
    __CFRunLoopDoObservers(kCFRunLoopBeforeSources);

    // 处理非延迟的主线程调用
    __CFRunLoopDoBlocks();
    // 处理 Source0 事件
    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(...);

    if (sourceHandledThisLoop) {
        __CFRunLoopDoBlocks();
     }
    /// 如果有 Source1 (基于 port) 处于 ready 状态，直接处理这个 Source1，然后跳转去处理消息。
    if (__Source0DidDispatchPortLastTime) {
        Boolean hasMsg = __CFRunLoopServiceMachPort();
        if (hasMsg) goto handle_msg;
    }

    /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
    if (!sourceHandledThisLoop) {
        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
    }

    // GCD dispatch main queue
    CheckIfExistMessagesInMainDispatchQueue();

    // 即将进入休眠
    __CFRunLoopDoObservers(kCFRunLoopBeforeWaiting);

    // 等待内核 mach_msg 事件
    mach\_port\_t wakeUpPort = SleepAndWaitForWakingUpPorts();

    // 等待 ...

    // 从等待中醒来
    __CFRunLoopDoObservers(kCFRunLoopAfterWaiting);

    // 处理因 timer 的唤醒
    if (wakeUpPort == timerPort)
        __CFRunLoopDoTimers();

    // 处理异步方法唤醒,如 dispatch_async
    else if (wakeUpPort == mainDispatchQueuePort)
        \_\_CFRUNLOOP\_IS\_SERVICING\_THE\_MAIN\_DISPATCH\_QUEUE\_\_()

    // 处理 Source1
    else
        __CFRunLoopDoSource1();

    // 再次确保是否有同步的方法需要调用
    __CFRunLoopDoBlocks();

} while (!stop &amp;&amp; !timeout);

// 通知即将退出runloop
__CFRunLoopDoObservers(CFRunLoopExit);
</code></pre><p>}</p>
<p>现在只要了解上面的伪代码知道核心的方法 __CFRunLoopRun() 内部其实是一个 do-while 循环，这也正是 Runloop 运行的本质。执行这个函数以后就一直处于 “等待-处理” 的循环之中，直到循环结束。只是不同于我们写的循环，它在休眠时几乎不会占用系统资源，当然这是由于系统内核负责实现的，也是 Runloop 精华所在。</p>
<blockquote>
<p>随着 Swift 的开源，苹果也维护着一个 Swift 版本的跨平台 <a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="noopener">CoreFoundation</a>，除了 Mac 平台，它还适配了 Linux 和 Windows 平台。</p>
</blockquote>
<p>下图描述了 Runloop 运行流程（基本描述了上面 Runloop 的核心流程，当然可以查看官方 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">The Run Loop Sequence of Events</a> 描述）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-91e7ffed86201be0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop"></p>
<p>需要注意的是黄色区域的消息处理中并不包含 source0，因为它在循环开始之初就被处理了，之后的循环中不再处理。</p>
<p>整个流程其实就是一种 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a> 的实现，其他平台均有类似的实现，只是名称不同。</p>
<p>既然 RunLoop 是一个消息循环，谁来管理和运行 Runloop ？那么它接收什么类型的消息？休眠过程是怎么样的 ？如何保证休眠时不占用系统资源 ？如何处理这些消息以及何时退出循环？还有一系列问题需要解开。</p>
<blockquote>
<p>注意：尽管 CFRunLoopPerformBlock() 在上图中作为唤醒机制（手动）有所体现，但事实上执行 CFRunLoopPerformBlock() 只是入队，下次 RunLoop 运行才会执行，而如果需要立即执行则必须调用 CFRunLoopWakeUp()。</p>
</blockquote>
<p>当一个 runloop 正在等一个 source 准备或者 timer 执行 fire 的时候，runloop 处于休眠状态。如果没有 source 或者 timer 准备好，runloop 会保持休眠直到超时或者被唤醒。当 runloop 被修改，例如添加了一个 source，你需要唤醒 runloop 将其加入队列。</p>
<h5 id="二、Runloop-Mode"><a href="#二、Runloop-Mode" class="headerlink" title="二、Runloop Mode"></a>二、Runloop Mode</h5><p>从源码很容易看出，每次运行 __CFRunLoopRun() 函数时必须指定 Mode，Runloop 总是运行在某种特定的 CFRunLoopModeRef 下。</p>
<p>而通过 CFRunloopRef 对应的结构体 __CFRunLoop 的定义可以很容易知道每种 Runloop 都可以包含若干个 Mode，每个 Mode 又包含 Source/Timer/Observer。</p>
<p>struct __CFRunLoop {<br>    …<br>    CFMutableSetRef _commonModes;<br>    CFMutableSetRef _commonModeItems;<br>    CFRunLoopModeRef _currentMode;<br>    CFMutableSetRef _modes;<br>    …<br>};</p>
<p>struct __CFRunLoopMode {<br>     …<br>     CFMutableSetRef _sources0;<br>     CFMutableSetRef _sources1;<br>     CFMutableArrayRef _observers;<br>     CFMutableArrayRef _timers;<br>     …<br>};</p>
<p>每次调用 __CFRunLoopRun() 时指定的 Mode 是 _currentMode，当切换 Mode 时必须退出当前 Mode，然后重新进入 Runloop 以保证不同 Mode 的 Source/Timer/Observer 互不影响。</p>
<p>系统提供的 Mode 有</p>
<blockquote>
<ul>
<li>kCFRunLoopCommonModes (NSRunLoopCommonModes)</li>
<li>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</li>
<li>UITrackingRunLoopMode</li>
</ul>
</blockquote>
<p>进入 iOS 程序默认不做任何操作就处于 NSDefaultRunLoopMode 中，此时滑动视图，主线程就切换 Runloop 到 UITrackingRunLoopMode，不再接受其他事件操作，除非你将其他 Source/Timer 设置到 UITrackingRunLoopMode 下。</p>
<p>NSRunLoopCommonModes 并不是某种具体的 Mode，而是一种模式组合，在 iOS 系统中默认包含了 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。</p>
<blockquote>
<p>注意：并不是 Runloop 会运行在 kCFRunLoopCommonModes 这种模式下，而是相当于分别注册了 NSDefaultRunLoopMode 和 UITrackingRunLoopMode。</p>
<p>当然你也可以通过调用 CFRunLoopAddCommonMode() 方法将自定义 Mode 放到 kCFRunLoopCommonModes 组合中）。</p>
</blockquote>
<blockquote>
<ul>
<li>系统框架自定义 Mode，例如 Foundation 中 NSConnectionReplyMode</li>
<li>系统私有 Mode，例如：GSEventReceiveRunLoopMode 接受系统事件，UIInitializationRunLoopMode App 启动过程中初始化 Mode。</li>
</ul>
<p>更多系统或框架 Mode 查看<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">这里</a></p>
</blockquote>
<p>CFRunLoopRef 和 CFRunloopMode、CFRunLoopSourceRef/CFRunloopTimerRef/CFRunLoopObserverRef 关系如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-16335ba4a146f5a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>CFRunLoopRef：代表 RunLoop 的对象</li>
<li>CFRunLoopModeRef：代表 RunLoop 的运行模式</li>
<li>CFRunLoopSourceRef：就是 RunLoop 模型图中提到的输入源/事件源</li>
<li>CFRunLoopTimerRef：就是 RunLoop 模型图中提到的定时源</li>
<li>CFRunLoopObserverRef：观察者，能够监听 RunLoop 的状态改变</li>
</ul>
<p>那么 CFRunLoopSourceRef、CFRunLoopTimerRef 和 CFRunLoopObserverRef 究竟是什么？它们在 Runloop 运行流程中起到什么作用呢？</p>
<h5 id="三、Source"><a href="#三、Source" class="headerlink" title="三、Source"></a>三、Source</h5><p>Run Loop 处理两大类事件源：Timer Source 和 Input Source（包括 performSelector** 方法簇、Port 或者自定义 Input Source），每个事件源都会绑定在 Run Loop 的某个特定模式 mode 上，而且只有 RunLoop 在这个模式运行的时候才会触发该 Timer 和 Input Source。</p>
<p>首先看一下官方 Runloop 结构图（注意下图右侧的 Input Source Port 和前面流程图中的 Source0 并不对应，而是对应 Source1。当然 Source0 也是 Input Source 中的一类，Input Source 还包括 Custom Input Source，由其他线程手动发出。Source1 和 Timer 都属于端口事件源，不同的是所有的 Timer 都共用一个端口 “Mode Timer Port”，而每个 Source1 都有不同的对应端口）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-bffb4a8d6ebef494.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoopSource"></p>
<p>结合前面 RunLoop 核心运行流程可以看出 Source0（负责 App 内部事件，由 App 负责管理触发，例如 UITouch 事件）和 Timer（又叫 Timer Source，基于时间的触发器，上层对应 NSTimer）是两个不同的 Runloop 事件源，RunLoop 被这些事件唤醒之后就会处理并调用事件处理方法（CFRunLoopTimerRef 和 CFRunLoopSourceRef  均包含对应的回调指针）。</p>
<p>但是对于 CFRunLoopSourceRef 除了 Source0 之外还有另一个版本就是 Source1，Source1 除了包含回调指针外包含一个 mach port，和 Source0 需要手动触发不同，Source1 可以监听系统端口和其他线程相互发送消息，它能够主动唤醒 RunLoop（由操作系统内核进行管理，例如 CFMessagePort 消息）。</p>
<p>官方也指出可以自定义 Source，因此对于 CFRunLoopSourceRef 来说它更像一种协议，框架已经默认定义了两种实现，如果有必要开发人员也可以自定义，<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h5 id="四、Observer"><a href="#四、Observer" class="headerlink" title="四、Observer"></a>四、Observer</h5><p>struct __CFRunLoopObserver {<br>     CFRuntimeBase _base;<br>     pthread_mutex_t _lock;<br>     CFRunLoopRef _runLoop;<br>     CFIndex _rlCount;<br>     CFOptionFlags _activities;      /<em> immutable </em>/<br>     CFIndex _order;         /<em> immutable </em>/<br>     CFRunLoopObserverCallBack _callout; /<em> immutable </em>/<br>     CFRunLoopObserverContext _context;  /<em> immutable, except invalidation </em>/<br>};</p>
<p>相对来说 CFRunloopObserverRef 理解起来并不复杂，它相当于消息循环中的一个监听器，随时通知外部当前 RunLoop 的运行状态（它包含一个函数指针 _callout 将当前状态及时告诉观察者）。具体的 Observer 状态如下：</p>
<p>/* Run Loop Observer Activities */<br>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {<br>     kCFRunLoopEntry = (1UL &lt;&lt; 0),          // 进入 RunLoop<br>     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),   // 即将开始 Timer 处理<br>     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),  // 即将开始 Source 处理<br>     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),  // 即将进入休眠<br>     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),   // 从休眠状态唤醒<br>     kCFRunLoopExit = (1UL &lt;&lt; 7),           // 退出 RunLoop<br>     kCFRunLoopAllActivities = 0x0FFFFFFFU<br>};</p>
<p>通过代码监听 runloop 的状态变化。</p>
<p>- (void)viewDidLoad<br>{<br>    [super viewDidLoad];</p>
<pre><code>// 创建观察者
CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault,
                                                                   kCFRunLoopAllActivities,
                                                                   YES,
                                                                   0,
                                          ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
    NSLog(@&quot;监听到 RunLoop 状态发生变化----%zd&quot;, activity);
});

// 添加观察者到当前 runloop 中
CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
</code></pre><p>}</p>
<p>2019-03-28 14:00:56.349332+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-2<br>…<br>2019-03-28 14:01:00.002807+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-32<br>2019-03-28 14:02:00.002030+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-64<br>2019-03-28 14:02:00.003182+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-2<br>2019-03-28 14:02:00.003376+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-4<br>2019-03-28 14:02:00.003634+0800 Demo[27078:5797867] 监听到 RunLoop 状态发生变化—-32</p>
<h5 id="五、Call-out"><a href="#五、Call-out" class="headerlink" title="五、Call out"></a>五、Call out</h5><p>开发过程中，无论是 Observer 的状态通知还是 Timer、Source 的处理，几乎所有的操作都是通过 Call out 进行回调的，而系统在回调时通常使用如下几个函数进行回调，换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听 Observer 也会先调用下面的函数然后间接通知你，所以在调用堆栈中经常看到这些函数：</p>
<p>static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();<br>static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();<br>static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();<br>static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();<br>static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();<br>static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</p>
<p>例如在控制器的 touchBegin 中打入断点查看堆栈（由于 UIEvent 是 Source0，所以可以看到一个 Source0 的 Call out 函数****CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION****调用）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ea90c1d5dee027cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_Source0_UITouch"></p>
<h5 id="六、RunLoop-休眠"><a href="#六、RunLoop-休眠" class="headerlink" title="六、RunLoop 休眠"></a>六、RunLoop 休眠</h5><p>对于 Event Loop 而言，RunLoop 最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。</p>
<p>RunLoop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 <a href="https://opensource.apple.com/" target="_blank" rel="noopener">Darwin</a> 中的 Mach 来完成的。可以从下图最底层 Kernel 中找到 Mach：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-0acd97fbc744bd21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="osx_architecture-kernels_drivers"></p>
<p>Mach 是 Darwin 的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。</p>
<p>在 Mach 中，进程、线程间的通信是以消息的方式来完成的，消息在两个 Port 之间进行传递（这也正是 Source1 之所以称之为 Port-based Source 的原因，因为它就是依靠系统发送消息到指定的 Port 来触发的）。消息的发送和接收使用 &lt;mach/message.h&gt; 中的 mach_msg() 函数：</p>
<p>/**<br> *  Routine:    mach_msg<br> *  Purpose:<br> *      Send and/or receive a message.  If the message operation<br> *      is interrupted, and the user did not request an indication<br> *      of that fact, then restart the appropriate parts of the<br> *      operation silently (trap version does not restart).<br> <em>/<br>__WATCHOS_PROHIBITED __TVOS_PROHIBITED<br>extern mach_msg_return_t    mach_msg(<br>              mach_msg_header_t </em>msg,<br>              mach_msg_option_t option,<br>              mach_msg_size_t send_size,<br>              mach_msg_size_t rcv_size,<br>              mach_port_name_t rcv_name,<br>              mach_msg_timeout_t timeout,<br>              mach_port_name_t notify);</p>
<p>而 mach_msg() 的本质是一个调用 mach_msg_trap()，这相当于一个系统调用，会触发内核状态切换。当程序静止时，RunLoop 停留在 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy)，而这个函数内部就是调用了 mach_msg() 让程序处于休眠状态。</p>
<h5 id="七、Runloop-与线程的关系"><a href="#七、Runloop-与线程的关系" class="headerlink" title="七、Runloop 与线程的关系"></a>七、Runloop 与线程的关系</h5><p>Runloop 是基于 pthread 进行管理的，pthread 是基于 c 的跨平台多线程操作底层 API。它是 mach thread 的上层封装（可以参见 <a href="https://developer.apple.com/library/content/documentation/Darwin/Conceptual/KernelProgramming/Mach/Mach.html" target="_blank" rel="noopener">Kernel Programming Guide</a>），和 NSThread 一一对应。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e9ddb74fb86de028.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>苹果没有开放直接创建 Runloop 的接口，如果需要，通常调用 CFRunLoopGetMain() 和 CFRunLoopGetCurrent() 两个方法来获取。</p>
<p>通过代码不难发现，只有当我们使用线程的方法主动 get 时才会在第一次创建该线程的 Runloop，同时将它保存在全局的字典中（线程和 Runloop 一一对应），默认情况下线程并不会创建 Runloop（主线程的 Runloop 比较特殊，任何线程创建之前都会保证主线程的已经存在），同时在线程结束的时也会销毁对应的 Runloop。</p>
<p>CFRunLoopRef CFRunLoopGetMain(void) {<br>    CHECK_FOR_FORK();<br>    static CFRunLoopRef <strong>main = NULL; // no retain needed<br>    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); // no CAS needed<br>    return </strong>main;<br>}</p>
<p>CFRunLoopRef CFRunLoopGetCurrent(void) {<br>    CHECK_FOR_FORK();<br>    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);<br>    if (rl) return rl;<br>    return _CFRunLoopGet0(pthread_self());<br>}</p>
<p>NSRunloop 默认提供了三个常用的 run 方法：</p>
<p>/**<br> * 对应上面 CFRunloopRef 中的 CFRunLoopRun() ，并且不会退出，除非调用 CFRunLoopStop()。通常如果想要永远不会退出 runloop 才会使用此方法，否则可以使用 runUntilData。<br> */<br>- (void)run; </p>
<p>/**<br> * 对应 CFRunLoopRunInMode(mode, limiteData, true) 方法，只执行一次，执行完就退出。通常用于手动控制 runloop。<br> */<br>- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;</p>
<p>/**<br> * 其实是 CFRunLoopRunInMode(kCFRunLoopDefaultMode, limiteDate, false)，执行完并不会退出，继续下一次 RunLoop 直到 timeout。<br> */<br>-  (void)runUntilDate:(NSDate *)limitDate;</p>
<ol>
<li><p>一条线程对应一个 RunLoop 对象，每条线程都有唯一一个与之对应的 RunLoop 对象。</p>
</li>
<li><p>RunLoop 并不保证线程安全。只能在当前线程内部操作当前线程的 RunLoop 对象，而不能去操作其他线程的 RunLoop 对象方法。</p>
</li>
<li><p>RunLoop 对象在第一次获取 RunLoop 时创建，销毁则是在线程结束的时候。</p>
</li>
<li><p>主线程的 RunLoop 对象系统自动帮助我们创建好了，而子线程的 RunLoop 对象需要我们主动创建和维护。</p>
</li>
</ol>
<p>我们在启动一个 iOS 程序的时候，系统会调用创建项目时自动生成的 main.m 的文件。main.m 文件如下所示：</p>
<p>int main(int argc, char * argv[]) {<br>    @autoreleasepool {<br>         return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));<br>    }<br>}</p>
<p>其中 UIApplicationMain 函数内部帮我们开启了主线程的 RunLoop，UIApplicationMain 内部拥有一个无限循环的代码，只要程序不退出/崩溃，它就一直循环。上边的代码中主线程开启 RunLoop 的过程可以简单的理解为如下代码：</p>
<p>int main(int argc, char * argv[]) {</p>
<pre><code>BOOL running = YES;    

do {        
    // 执行各种任务，处理各种事件        
    // ......
} while (running);  // 判断是否需要退出 


return 0;
</code></pre><p>}</p>
<h5 id="八、RunLoop-应用"><a href="#八、RunLoop-应用" class="headerlink" title="八、RunLoop 应用"></a>八、RunLoop 应用</h5><p>1、NSTimer</p>
<p>前面提到的 Timer Source 作为事件源，事实上它的上层对应就是 NSTimer（其实就是 CFRunloopTimerRef，底层基于使用 mk_timer 实现），甚至很多开发者接触 RunLoop 还是从 NSTimer 开始的。</p>
<p>其实 NSTimer 定时器的触发正是基于 RunLoop 运行的，所以使用 NSTimer 之前必须注册到 RunLoop。但是 RunLoop 为了节省资源并不会在非常准确的时间点调用定时器，如果一个任务执行时间较长，那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer 提供了一个 tolerance 属性用于设置宽容度，如果确实想要 NSTimer 尽可能的准确，可以设置此属性）。</p>
<p>NSTimer 的创建通常有两种方式，尽管都是类方法，一种是 timerWithXXX:，另一种 scheduedTimerWithXXX:。</p>
<p>+ (NSTimer <em>)timerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation </em>)invocation repeats:(BOOL)yesOrNo;<br>+ (NSTimer <em>)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;<br>+ (NSTimer </em>)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer <em>timer))block;<br>+ (NSTimer </em>)scheduledTimerWithTimeInterval:(NSTimeInterval)ti invocation:(NSInvocation <em>)invocation repeats:(BOOL)yesOrNo;<br>+ (NSTimer </em>)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer <em>timer))block;<br>+ (NSTimer </em>)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;</p>
<p>schedued 方式不仅创建一个定时器，而且会自动以 NSDefaultRunLoopMode 添加到当前线程 RunLoop 中，不添加到 RunLoop 中的 NSTimer 是无法正常工作的。</p>
<p>同时注意，如果触发滚动事件，NSDefaultRunLoopMode 下 NSTimer 是无法正常工作的，但将 NSDefaultRunLoopMode 改为 NSRunLoopCommonModes 则可以正常工作，这也解释了前面介绍的 Mode 内容。</p>
<p>@interface MyViewController ()<br>@property (nonatomic, weak) NSTimer <em> timer1;<br>@property (nonatomic, weak) NSTimer </em> timer2;<br>@end    </p>
<p>- (void)viewDidLoad<br>{<br>     [super viewDidLoad];</p>
<pre><code>self.timer1 = \[NSTimer scheduledTimerWithTimeInterval:...\];

NSTimer * tempTimer = \[NSTimer timerWithTimeInterval:...\];
// 如果不把 tempTimer 添加到 RunLoop 中是无法正常工作的
\[\[NSRunLoop currentRunLoop\] addTimer:tempTimer forMode:NSDefaultRunLoopMode\];
self.timer2 = tempTimer;
</code></pre><p>}</p>
<p>注意上面的 timer1 和 timer2 并没有强引用，对于其他的对象而言，执行完 viewDidLoad 方法后的的一个 RunLoop 运行结束，二者应该会被释放，但事实上二者并没有被释放。</p>
<blockquote>
<p>为了确保定时器正常运转，当加入到 RunLoop 以后系统会对 NSTimer 执行一次 retain 操作。</p>
</blockquote>
<p>特别注意：tempTimer 创建时并没直接赋值给 timer2，原因是 timer2 是 weak 属性，timerWithXXX: 方法创建的 NSTimer 默认并没有加入 RunLoop，如果直接赋值给 timer2 会被立即释放，只有加入 RunLoop 以后才可以将引用指向 timer2。</p>
<p>但是即使使用了弱引用，MyViewController 对象也无法正常释放</p>
<blockquote>
<p>创建 NSTimer 时指定了 target:self，导致 NSTimer 对象对 self 有一个强引用。</p>
</blockquote>
<p>解决这个问题的方法通常有两种：</p>
<p>①、将 target 分离出来独立成一个对象，在对象内创建 NSTimer 并将对象本身作为 NSTimer 的 target，Controller 通过这个对象间接使用 NSTimer；</p>
<p>②、增加 NSTimer 分类，让 NSTimer 自身作为 target，同时可以将操作 selector 封装到 block 中。后者相对优雅，也是目前使用较多的方案，例如：<a href="https://github.com/mBrissman/NSTimer-Block" target="_blank" rel="noopener">NSTimer+Block</a>。</p>
<p>显然苹果也认识到了这个问题，如果你确保工程只支持 iOS10 运行就可以使用 iOS10 新增的系统级 block 方案。</p>
<p>NSTimer <em> timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer </em> _Nonnull timer) {</p>
<p>}];</p>
<p>使用上面第 ② 种方法可以解决控制器无法释放的问题，但是会发现即使控制器被释放了两个定时器仍然正常运行，要解决这个问题就需要调用 NSTimer 的 invalidate 方法（注意：一次性的定时器执行完操作后会自动调用 invalidate 方法）。</p>
<p>- (void)dealloc<br>{<br>     [self.timer1 invalidate];<br>     [self.timer2 invalidate];<br>}</p>
<p>其实和定时器相关的另一个问题大家也经常碰到，那就是 NSTimer 不是一种实时机制。<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Timers/Articles/timerConcepts.html" target="_blank" rel="noopener">官方文档</a>明确说明：</p>
<blockquote>
<p>在一个循环中，如果 RunLoop 没有被识别（这个时间大概在 50-100ms），或者说 currentRunLoop 在执行一个长的 call out（例如执行某个循环操作）则 NSTimer 可能就会存在误差，RunLoop 在下一次循环中继续检查并根据情况确定是否执行。</p>
</blockquote>
<p>NSTimer 的执行时间总是固定在一定的时间间隔，例如 1:00:00、1:00:01、1:00:02、1:00:05 则跳过了第 4、5 次运行循环。</p>
<p>要演示这个问题请看下面的例子（注意：有些示例中可能会让一个线程中启动一个定时器，再在主线程启动一个耗时任务来演示这个问，如果实际测试可能效果不会太明显，因为现在的 iPhone 都是多核运算的，这样一来这个问题会变得相对复杂，因此下面的例子选择在同一个 RunLoop 中即加入定时器和执行耗时任务）</p>
<p>#import “MyViewController.h”<br>@interface MyViewController ()<br>@property (nonatomic, weak) NSTimer <em> timer;<br>@property (nonatomic, strong) NSThread </em> thread;<br>@end<br>@implementation MyViewController</p>
<p>- (void)dealloc<br>{<br>     [self.timer invalidate];   // 取消定时器<br>}</p>
<p>- (void)viewDidLoad<br>{<br>    [super viewDidLoad];</p>
<pre><code>self.thread = \[\[NSThread alloc\] initWithTarget:self
                                      selector:@selector(performTask)
                                        object:nil\];
\[self.thread start\];
</code></pre><p>}</p>
<p>- (void)performTask<br>{<br>     // 使用下面的方式创建定时器虽然会自动加入到当前线程的 RunLoop 中，但是除了主线程外其他线程的 RunLoop 默认是不会运行的，必须手动调用<br>     __weak typeof(self) weakSelf = self;</p>
<pre><code>self.timer = \[NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {

     if (\[NSThread currentThread\].isCancelled) {
          //\[NSObject cancelPreviousPerformRequestsWithTarget:weakSelf selector:@selector(longTimeTask) object:nil\];
          //\[NSThread exit\];
          \[weakSelf.timer invalidate\];
     }
     NSLog(@&quot;111111111&quot;);
}\];

NSLog(@&quot;runloop before performSelector:%@&quot;,\[NSRunLoop currentRunLoop\]);

// 区分直接调用和「performSelector:withObject:afterDelay:」区别,下面的直接调用无论是否运行RunLoop一样可以执行，但是后者则不行。
//\[self longTimeTask\];
\[self performSelector:@selector(longTimeTask) withObject:nil afterDelay:2.0\];

// 取消当前 RunLoop 中注册的 @selector（注意：只是当前 RunLoop，所以也只能在当前 RunLoop 中取消）
// \[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(longTimeTask) object:nil\];
NSLog(@&quot;runloop after performSelector:%@&quot;,\[NSRunLoop currentRunLoop\]);

// 非主线程RunLoop必须手动调用
\[\[NSRunLoop currentRunLoop\] run\];

NSLog(@&quot;注意：如果RunLoop 还在运行中，这里的代码并不会执行，RunLoop 本身就是一个循环.&quot;);
</code></pre><p>}</p>
<p>// 长时间任务：打印 9999 次<br>- (void)longTimeTask<br>{<br>     for (int i = 0;i &lt; 9999;++i) {<br>          NSLog(@”%i, %@”, i, [NSThread currentThread]);</p>
<pre><code>     if (\[NSThread currentThread\].isCancelled) {
          return;
     }
}
</code></pre><p>}</p>
<p>// 取消线程<br>- (void)touchesBegan:(NSSet<uitouch *> <em>)touches withEvent:(UIEvent </em>)event<br>{<br>     [self.thread cancel];<br>}</uitouch></p>
<p>@end</p>
<p>如果运行并且不退出上面的程序会发现，前两秒 NSTimer 可以正常执行，但是两秒后由于同一个 RunLoop 中 longTimeTask 循环操作的执行造成定时器跳过了中间执行的机会一直到 longTimeTask 循环完毕，这也正说明了 NSTimer 不是实时系统机制的原因。</p>
<p>以上程序还有几点需要说明一下：</p>
<p>①、NSTimer 会对 target 进行强引用直到任务结束或 exit 之后才会释放。如果上面的程序没有进行线程 cancel 而终止任务，则即使关闭控制器也无法正确释放。</p>
<p>②、非主线程的 RunLoop 并不会自动运行。同时注意，默认情况下非主线程的 RunLoop 直到第一次使用之前并不会自动创建，RunLoop 运行必须要在加入 NSTimer 或 Source0、Sourc1、Observer 输入后运行否则会直接退出。例如上面代码如果 run 放到 NSTimer 创建之前，则既不会执行定时任务也不会执行循环运算。</p>
<p>③、performSelector:withObject:afterDelay: 执行的本质还是通过创建一个 NSTimer 然后加入到当前线程 RunLoop（通过前后两次打印 RunLoop 信息可以看到此方法执行之后 RunLoop 的 timer 会增加 1 个。类似的还有performSelector:onThread:withObject:afterDelay:，只是它会在另一个线程的 RunLoop 中创建一个 Timer），所以此方法事实上在任务执行完之前会对触发对象形成引用，任务执行完进行释放（例如上面会对 MyViewController 形成引用，注意：performSelector:withObject: 等方法则等同于直接调用，原理与此不同）。</p>
<p>④、同时上面的代码也充分说明了 RunLoop 是一个循环事实，run 方法之后的代码不会立即执行，直到 RunLoop 退出。</p>
<p>⑤、上面程序的运行过程中如果突然 dismiss/pop，则程序的实际执行过程要分为两种情况考虑：如果循环任务 longTimeTask 还没有开始则会停止 timer 运行（停止了线程中第一个任务），然后等待 longTimeTask 执行并 break（停止线程中第二个任务）后线程任务执行结束释放对控制器的引用；如果循环任务 longTimeTask 执行过程中 dismiss/pop 则 longTimeTask 任务执行结束，等待 timer 下个周期运行（因为当前线程的 RunLoop 并没有退出，timer 引用计数器并不为 0）时检测到线程取消状态则执行 invalidate 方法（第二个任务也结束了），此时线程释放对于控制器的引用。</p>
<blockquote>
<p>CADisplayLink 默认时是一个执行频率 fps 和屏幕刷新相同的定时器，它也需要加入到 RunLoop 才能执行。</p>
<p>CADisplayLink 同样是基于 CFRunloopTimerRef 实现，底层使用 mk_timer。它比 NSTimer 精度更高（尽管 NSTimer 可以修改精度）。不过遇到大任务它和 NStimer 一样存在丢帧现象。</p>
<p>通常情况下 CADisaplayLink 用于构建帧动画，看起来相对更加流畅，而 NSTimer 则有更广泛的用处。</p>
</blockquote>
<p>2、AutoreleasePool</p>
<p>AutoreleasePool 是另一个与 RunLoop 相关讨论较多的话题。其实从 RunLoop 源代码分析，AutoreleasePool 与 RunLoop 并没有直接的关系，之所以将两个话题放到一起讨论最主要的原因是因为在 iOS 应用启动后会注册两个 Observer 管理和维护 AutoreleasePool。不妨在应用程序刚刚启动时打印 currentRunLoop 可以看到系统默认注册了很多个 Observer，其中有两个 Observer 的 callout 都是 ** _ wrapRunLoopWithAutoreleasePoolHandler**，这两个是和自动释放池相关的两个监听。</p>
<p><cfrunloopobserver 0x6080001246a0 \[0x101f81df0\]>{valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = <cfarray 0x60800004cae0 \[0x101f81df0\]>{type = mutable-small, count = 0, values = ()}}</cfarray></cfrunloopobserver></p>
<p><cfrunloopobserver 0x608000124420 \[0x101f81df0\]>{valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x1020e07ce), context = <cfarray 0x60800004cae0 \[0x101f81df0\]>{type = mutable-small, count = 0, values = ()}}</cfarray></cfrunloopobserver></p>
<p>第一个 Observer 会监听 RunLoop 的进入，它会回调 objc_autoreleasePoolPush() 向当前的 AutoreleasePoolPage 增加一个哨兵对象标志创建自动释放池。这个 Observer 的 order 是 -2147483647 优先级最高，确保发生在所有回调操作之前。</p>
<p>第二个 Observer 会监听 RunLoop 的进入休眠和即将退出 RunLoop 两种状态，在即将进入休眠时会调用**objc_autoreleasePoolPop()** 和 **objc_autoreleasePoolPush() 根据情况从最新加入的对象一直往前清理直到遇到哨兵对象。而在即将退出 RunLoop 时会调用 objc_autoreleasePoolPop() 释放自动自动释放池内对象。这个 Observer 的 order 是 2147483647，优先级最低，确保发生在所有回调操作之后。</p>
<p>主线程的其他操作通常均在这个 AutoreleasePool 之内（main 函数中），以尽可能减少内存维护操作。当然你如果需要显式释放（例如循环）时可以自己创建 AutoreleasePool 否则一般不需要自己创建。</p>
<p>其实在应用程序启动后系统还注册了其他 Observer（例如即将进入休眠时执行注册回调 _UIGestureRecognizerUpdateObserver 用于手势处理、回调为 _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv 的 Observer 用于界面实时绘制更新）和多个 Source1（例如 context 为 CFMachPort 的 Source1 用于接收硬件事件响应进而分发到应用程序一直到 UIEvent），这里不再一一详述。</p>
<p>3、UI 更新</p>
<p>如果打印 App 启动之后的主线程 RunLoop 可以发现另外一个 callout 为_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv 的 Observer，这个监听专门负责 UI 变化后的更新，比如修改了 frame、调整了 UI 层级（UIView/CALayer）或者手动设置了 setNeedsDisplay/setNeedsLayout 之后就会将这些操作提交到全局容器。而这个 Observer 监听了主线程 RunLoop 的即将进入休眠和退出状态，一旦进入这两种状态则会遍历所有的 UI 更新并提交进行实际绘制更新。</p>
<p>通常情况下这种方式是完美的，因为除了系统的更新，还可以利用 setNeedsDisplay 等方法手动触发下一次 RunLoop 运行的更新。但是如果当前正在执行大量的逻辑运算可能 UI 的更新就会比较卡，因此 facebook 推出了<a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a>来解决这个问题。</p>
<p>AsyncDisplayKit 其实是将 UI 排版和绘制运算尽可能放到后台，将 UI 的最终更新操作放到主线程（这一步也必须在主线程完成），同时提供一套类 UIView 或 CALayer 的相关属性，尽可能保证开发者的开发习惯。这个过程中 AsyncDisplayKit 在主线程 RunLoop 中增加了一个 Observer 监听即将进入休眠和退出 RunLoop 两种状态，收到回调时遍历队列中的待处理任务一一执行。</p>
<p>4、NSURLConnection</p>
<p>在前面的<a href="http://www.cnblogs.com/kenshincui/p/4042190.html#requestAndResponse" target="_blank" rel="noopener">网络开发</a>的文章中已经介绍过 NSURLConnection 的使用，一旦启动 NSURLConnection 以后就会不断调用 delegate 方法接收数据，这样一个连续的的动作正是基于 RunLoop 来运行。</p>
<p>一旦 NSURLConnection 设置了 delegate 会立即创建一个线程 com.apple.NSURLConnectionLoader，同时内部启动RunLoop 并在 NSDefaultMode 模式下添加 4 个 Source0。其中 CFHTTPCookieStorage 用于处理 cookie；CFMultiplexerSource 负责各种 delegate 回调并在回调中唤醒 delegate 内部的 RunLoop（通常是主线程）来执行实际操作。</p>
<p>早期版本的 AFNetworking 库也是基于 NSURLConnection 实现，为了能够在后台接收 delegate 回调 AFNetworking 内部创建了一个空的线程并启动了 RunLoop，当需要使用这个后台线程执行任务时 AFNetworking 通过 performSelector: onThread: 将这个任务放到后台线程的 RunLoop 中。</p>
<h5 id="九、GCD-和-RunLoop的关系"><a href="#九、GCD-和-RunLoop的关系" class="headerlink" title="九、GCD 和 RunLoop的关系"></a>九、GCD 和 RunLoop的关系</h5><p>在 RunLoop 的源代码中可以看到用到了 GCD 的相关内容，但是 RunLoop 本身和 GCD 并没有直接的关系。当调用了dispatch_async(dispatch_get_main_queue(), ^(void)block) 时 libDispatch 会向主线程 RunLoop 发送消息唤醒 RunLoop，RunLoop 从消息中获取 block，并且在 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE 回调里执行这个 block。不过这个操作仅限于主线程，其他线程 dispatch 操作是全部由 libDispatch 驱动的。</p>
<h5 id="十、更多-RunLoop-使用"><a href="#十、更多-RunLoop-使用" class="headerlink" title="十、更多 RunLoop 使用"></a>十、更多 RunLoop 使用</h5><p>前面看了很多 RunLoop 的系统应用和一些知名第三方库使用，那么除了这些究竟在实际开发过程中我们自己能不能适当的使用RunLoop 帮我们做一些事情呢？</p>
<p>思考这个问题其实只要看 RunLoopRef 的包含关系就知道了，RunLoop 包含多个 Mode，而它的 Mode 又是可以自定义的，这么推断下来其实无论是 Source1、Timer 还是 Observer 开发者都可以利用，但是通常情况下不会自定义 Timer，更不会自定义一个完整的 Mode，利用更多的其实是 Observer 和 Mode 的切换。</p>
<p>例如很多人都熟悉的使用 perfromSelector 在默认模式下设置图片，防止 UITableView 滚动卡顿。</p>
<p>[[[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)] performSelector:@selector(setImage:)<br>                                                                     withObject:myImage<br>                                                                     afterDelay:0.0<br>                                                                        inModes:@NSDefaultRunLoopMode];</p>
<p>我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），最好能让这条线程常驻内存。</p>
<p>做法：添加一条用于常驻内存的强引用的子线程，在该线程的 RunLoop 下添加一个 Sources，开启 RunLoop。</p>
<p>具体实现过程如下：</p>
<ol>
<li>在项目的 ViewController.m 中添加一条强引用的 thread 线程属性</li>
</ol>
<p>#import “ViewController.h”</p>
<p>@interface ViewController ()<br>@property (nonatomic, strong) NSThread * thread;<br>@end</p>
<ol start="2">
<li>在 viewDidLoad 中创建线程 self.thread，使线程启动并执行 addToRunLoop 方法。</li>
</ol>
<p>- (void)viewDidLoad<br>{<br>    [super viewDidLoad];</p>
<pre><code>// 创建线程
self.thread = \[\[NSThread alloc\] initWithTarget:self selector:@selector(addToRunLoop) object:nil\];
// 开启线程
\[self.thread start\];    
</code></pre><p>}</p>
<p>- (void)addToRunLoop<br>{<br>    NSLog(@”–addToRunLoop–”);</p>
<pre><code>// 添加下边两句代码，就可以开启 RunLoop，之后 self.thread 就变成了常驻线程，可随时添加任务，并交于 RunLoop 处理
\[\[NSRunLoop currentRunLoop\] addPort:\[NSPort port\] forMode:NSDefaultRunLoopMode\];
\[\[NSRunLoop currentRunLoop\] run\];

// 测试是否开启了 RunLoop，如果开启 RunLoop，则来不了这里，因为 RunLoop 开启了循环。
NSLog(@&quot;--after addToRunLoop--&quot;);
</code></pre><p>}</p>
<ol start="3">
<li>运行之后发现打印了—-addToRunLoop—–，而 –after addToRunLoop– 未打印。</li>
</ol>
<p>- (void)touchesBegan:(NSSet<uitouch *> <em>)touches withEvent:(UIEvent </em>)event<br>{<br>    [self performSelector:@selector(run2) onThread:self.thread withObject:nil waitUntilDone:NO];<br>}</uitouch></p>
<p>- (void)run2<br>{<br>    NSLog(@”run2”);  /// 可以打印。如果 thread 没有永驻 runloop，会打印 –after addToRunLoop–，不会打印 run2<br>}</p>
<p>还有 sunnyxx 的 <a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView+FDTemplateLayoutCell</a> 利用 Observer 在界面空闲状态下计算出 UITableViewCell 的高度并进行缓存。</p>
<p>再有老谭的 <a href="http://storage.tanhao.me/2015/11/PerformanceMonitor.zip" target="_blank" rel="noopener">PerformanceMonitor</a> 关于 iOS 实时卡顿监控，同样是利用 Observer 对 RunLoop 进行监视。</p>
<p>关于如何自定义一个 Custom Input Source<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3" target="_blank" rel="noopener">官网</a>给出了详细的流程。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2018/11/30/runloop1/">http://yoursite.com/2018/11/30/runloop1/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2018/11/30/runloop2/" class="pre"> RunLoop(2)		</a><a href="/2018/11/29/e6-84-9f-e7-9f-a5-e5-93-88-e5-b8-8c-e7-ae-97-e6-b3-95/" class="next"> 感知哈希算法		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、CFRunloopRef"><span class="toc-text">一、CFRunloopRef</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、Runloop-Mode"><span class="toc-text">二、Runloop Mode</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、Source"><span class="toc-text">三、Source</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、Observer"><span class="toc-text">四、Observer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、Call-out"><span class="toc-text">五、Call out</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、RunLoop-休眠"><span class="toc-text">六、RunLoop 休眠</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、Runloop-与线程的关系"><span class="toc-text">七、Runloop 与线程的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八、RunLoop-应用"><span class="toc-text">八、RunLoop 应用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#九、GCD-和-RunLoop的关系"><span class="toc-text">九、GCD 和 RunLoop的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十、更多-RunLoop-使用"><span class="toc-text">十、更多 RunLoop 使用</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>