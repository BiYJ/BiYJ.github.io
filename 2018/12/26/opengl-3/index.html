<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> OpenGL - 3 绘制三角形		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> OpenGL - 3 绘制三角形		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> OpenGL - 3 绘制三角形		</h1><div class="post-meta"><a href="/2018/12/26/opengl-3/#comments" class="comment-count"></a><p><span class="date">Dec 26, 2018</span><span><a href="/categories/OPENGL/" class="category">OPENGL</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文：<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/</a></p>
<p>在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 <strong>3D 坐标转变为适应屏幕的 2D 像素</strong>。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的图形渲染管线管理的。</p>
<p>Graphics Pipeline大多译为管线，实际上指的是<strong>一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程</strong>。</p>
<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的 3D 坐标转换为 2D 坐标；第二部分是把 2D 坐标转变为实际的有颜色的像素。这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。</p>
<p>2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。</p>
<p>图形渲染管线接受一组 3D 坐标，然后把它们转变为屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易<strong>并行执行</strong>。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在 GPU 上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在 GPU 上，所以它们可以给我们节约宝贵的 CPU 时间。OpenGL 着色器是用 OpenGL 着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中再花更多时间研究它。</p>
<p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意<strong>蓝色部分代表的是开发者可以注入自定义的着色器的部分</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e569dd2cb66116d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>如图所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。我们会概括性地解释一下渲染管线的每个部分，让你对图形渲染管线的工作方式有个大概了解。</p>
<p>首先，以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据Vertex Data；顶点数据是一系列顶点的集合。一个顶点是一个 3D 坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，还是假定每个顶点只由一个 3D 位置和一些颜色值组成的吧。</p>
<blockquote>
<p>当我们谈论一个”位置”的时候，它代表在一个”空间”中所处地点的这个特殊属性；同时”空间”代表着任何一种坐标系，比如 x、y、z 三维坐标系，x、y 二维坐标系，或者一条直线上的 x 和 y 的线性关系，只不过二维坐标系是一个扁扁的平面空间，而一条直线是一个很瘦的长长的空间。</p>
</blockquote>
<p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给 OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p>
<p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。<strong>顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理</strong>。</p>
<p>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并 <strong>把所有的点装配成指定图元的形状</strong>。本节例子是一个三角形。</p>
<p>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。<strong>几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状</strong>。例子中，它生成了另一个三角形。</p>
<p>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会<strong>把图元映射为最终屏幕上相应的像素，生成供片段着色器（Fragment Shader）使用的片段（Fragment）</strong>。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<p>OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。</p>
</blockquote>
<p><strong>片段着色器的主要目的是计算一个像素的最终颜色</strong>，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等），这些数据可以被用来计算最终像素的颜色。</p>
<p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 Alpha 测试和混合(Blending)阶段。这个阶段<strong>检测片段的对应的深度（和模板 Stencil）值，用它们来判断这个像素是在其它物体的前面还是后面，决定是否应该丢弃</strong>。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行<strong>混合</strong>(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，开发者只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p>
<p>在现代 OpenGL 中，我们必须定义至少一个顶点着色器和一个片段着色器（因为 GPU 中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代 OpenGL 的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。</p>
<h4 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h4><p>开始绘制图形之前，我们必须先给 OpenGL 输入一些顶点数据。OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 <strong>3D 坐标</strong>（x、y 和 z）。OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素；OpenGL 仅当 3D 坐标在 3 个轴（x、y 和 z）上都为 [-1.0, 1.0] 的范围内时才处理它。所有的在标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上。</p>
<p>由于我们希望渲染一个三角形，那么一共要指定三个顶点，每个顶点都有一个 3D 位置。我们会将它们以标准化设备坐标的形式定义为一个 float 数组。</p>
<p>float vertices[] = {<br>    -0.5f, -0.5f, 0.0f,<br>     0.5f, -0.5f, 0.0f,<br>     0.0f,  0.5f, 0.0f<br>};</p>
<p>由于 OpenGL 是在 3D 空间中工作的，而我们渲染的是一个 2D 三角形，将它顶点的 z 坐标设置为 0.0。这样三角形每一点的<strong>深度</strong>(Depth)都是一样的，从而使它看上去像是 2D 的。</p>
<blockquote>
<p>通常深度可以理解为 z 坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p>
<p><strong>标准化设备坐标(Normalized Device Coordinates, NDC)</strong></p>
</blockquote>
<blockquote>
<p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个 x、y 和 z 值在 [-1.0, 1.0] 的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略 z 轴)：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a817fa3dec194560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>与通常的屏幕坐标不同，y 轴正方向为向上，(0, 0) 坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p>
<p>你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过 glViewport 函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p>
</blockquote>
<p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在 GPU 上创建内存用于储存我们的顶点数据，还要配置 OpenGL 如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
<p>我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在 GPU 内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以<strong>一次性的发送一大批数据到显卡</strong>上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>
<p>顶点缓冲对象是在<a href="https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/" target="_blank" rel="noopener">OpenGL</a>教程中第一个出现的 OpenGL 对象。就像 OpenGL 中的其它对象一样，这个缓冲有一个独一无二的 ID，所以我们可以使用 glGenBuffers 函数和一个缓冲 ID 生成一个 VBO 对象：</p>
<p>unsigned int VBO;<br>glGenBuffers(1, &amp;VBO);</p>
<p>OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 glBindBuffer 函数把新创建的缓冲绑定到 GL_ARRAY_BUFFER目标上：</p>
<p>glBindBuffer(GL_ARRAY_BUFFER, VBO);</p>
<p>从这一刻起，我们使用的任何（在 GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用 glBufferData 函数，它会把之前定义的顶点数据复制到缓冲的内存中：</p>
<p>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</p>
<p>glBufferData 是一个专门用来<strong>把用户定义的数据复制到当前绑定缓冲的函数</strong>。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到 _GL_ARRAY_BUFFER_目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的 sizeof 计算出顶点数据大小就行。第三个参数是希望发送的实际数据。</p>
<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ： 数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ： 数据每次绘制时都会改变。</li>
</ul>
<p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是 GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是 GL_DYNAMIC_DRAW或 GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p>
<p>现在我们已经把顶点数据储存在显卡的内存中，用 VBO这个顶点缓冲对象管理。下面我们会创建一个顶点和片段着色器来真正处理这些数据。现在我们开始着手创建它们吧。</p>
<h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代 OpenGL 需要我们<strong>至少设置一个顶点和一个片段着色器</strong>。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形。下一节中我们会更详细的讨论着色器。</p>
<p>我们需要做的第一件事是用着色器语言 GLSL(OpenGL Shading Language) 编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的 GLSL 顶点着色器的源代码：</p>
<p>#version 330 core<br>layout (location = 0) in vec3 aPos;</p>
<p>void main()<br>{<br>    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);<br>}</p>
<p>可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和OpenGL 的版本是匹配的（比如说 GLSL 420 版本对应于 OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</p>
<p>下一步，使用 <strong>in</strong> 关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 float 分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个 3D 坐标，我们就创建一个 vec3 输入变量 aPos。我们同样也通过 layout (location = 0) 设定了输入变量的位置值(Location)，后面会看到为什么我们会需要这个位置值。</p>
<blockquote>
<p><strong>向量(Vector)</strong></p>
<p>在图形编程中经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 vec.x、vec.y、vec.z 和 vec.w 来获取。注意 vec.w分量不是用作表达空间中的位置的（我们处理的是 3D 不是 4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。</p>
</blockquote>
<p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 gl_Position 变量，它在幕后是 vec4 类型的。在 main 函数的最后，我们将 gl_Position 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为 4 分量的。我们可以把 vec3 的数据作为 vec4 构造器的参数，同时把 w 分量设置为 1.0f（我们会在后面解释为什么）来完成这一任务。</p>
<p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内。</p>
<h4 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h4><p>我们已经写了一个顶点着色器源码（储存在一个 C 的字符串中），但是为了能够让 OpenGL 使用它，我们必须在运行时动态编译它的源码。</p>
<p>我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的。所以我们储存这个顶点着色器为 unsigned int，然后用glCreateShader 创建这个着色器：</p>
<p>unsigned int vertexShader;<br>vertexShader = glCreateShader(GL_VERTEX_SHADER);</p>
<p>我们把需要创建的着色器类型以参数形式提供给 glCreateShader。由于创建的是一个顶点着色器，所以传递的参数是GL_VERTEX_SHADER。</p>
<p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p>
<p>glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);<br>glCompileShader(vertexShader);</p>
<p>glShaderSource 函数第一个参数是要编译的着色器对象；第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为 NULL。</p>
<p>你可能会希望检测在调用 glCompileShader 后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</p>
<p>int  success;<br>char infoLog[512];<br>glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</p>
<p>首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用 glGetShaderiv 检查是否编译成功。如果编译失败，我们会用 glGetShaderInfoLog 获取错误消息，然后打印它。</p>
<p>if(!success)<br>{<br>    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);<br>    std::cout &lt;&lt; “ERROR::SHADER::VERTEX::COMPILATION_FAILED\n” &lt;&lt; infoLog &lt;&lt; std::endl;<br>}</p>
<p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p>
<h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。</p>
<p>在计算机图形中颜色被表示为有 4 个元素的数组：红色、绿色、蓝色和 alpha(透明度)分量，通常缩写为 RGBA。当在 OpenGL 或 GLSL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过 1600 万种不同的颜色！</p>
<p>#version 330 core<br>out vec4 FragColor;</p>
<p>void main()<br>{<br>    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);<br>}</p>
<p>片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用 <strong>out</strong> 关键字声明输出变量，这里我们命名为 FragColor。下面，我们将一个 alpha 值为 1.0(1.0 代表完全不透明)的橘黄色的 vec4 赋值给颜色输出。</p>
<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用 GL_FRAGMENT_SHADER常量作为着色器类型：</p>
<p>unsigned int fragmentShader;<br>fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);<br>glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);<br>glCompileShader(fragmentShader);</p>
<p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p>
<h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p>
<p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p>
<p>创建一个程序对象很简单：</p>
<p>unsigned int shaderProgram;<br>shaderProgram = glCreateProgram();</p>
<p>glCreateProgram 函数创建一个程序，并返回新创建程序对象的 ID 引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用 glLinkProgram 链接它们：</p>
<p>glAttachShader(shaderProgram, vertexShader);<br>glAttachShader(shaderProgram, fragmentShader);<br>glLinkProgram(shaderProgram);</p>
<p>代码应该很清楚，我们把着色器附加到了程序上，然后用 glLinkProgram 链接。</p>
<p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，这里调用：</p>
<p>glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);<br>if(!success) {<br>    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);<br>    …<br>}</p>
<p>得到的结果就是一个程序对象，我们可以调用 glUseProgram 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p>
<p>glUseProgram(shaderProgram);</p>
<p>在 glUseProgram 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器）了。</p>
<p>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：</p>
<p>glDeleteShader(vertexShader);<br>glDeleteShader(fragmentShader);</p>
<p>现在，我们已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉 OpenGL怎么做。</p>
<h2 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h2><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定 OpenGL 该如何解释顶点数据。</p>
<p>我们的顶点缓冲数据会被解析为下面这样子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-56b2c59880d673fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>位置数据被储存为 32 位（4 字节）浮点值。</li>
<li>每个位置包含 3 个这样的值。</li>
<li>在这 3 个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li>
<li>数据中第一个值在缓冲开始的位置。</li>
</ul>
<p>有了这些信息我们就可以使用 glVertexAttribPointer 函数告诉 OpenGL 该如何解析顶点数据（应用到逐个顶点属性上）了：</p>
<p>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);</p>
<p>glVertexAttribPointer 函数的参数非常多，所以逐一介绍它们：</p>
<ul>
<li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用 layout(location = 0) 定义了 position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为 0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。</li>
<li>第二个参数指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。</li>
<li>第三个参数指定数据的类型，这里是 GL_FLOAT(GLSL中 vec* 都是由浮点数值组成的)。</li>
<li>第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为 GL_TRUE，所有数据都会被映射到 0（对于有符号型 signed 数据是 -1）到 1 之间。我们把它设置为 GL_FALSE。</li>
<li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float之后，我们把步长设置为 3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为 0 来让 OpenGL 决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注：这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组 0 位置之间有多少字节）。</li>
<li>最后一个参数的类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是 0。我们会在后面详细解释这个参数。</li>
</ul>
<p>每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用glVetexAttribPointer 时绑定到 GL_ARRAY_BUFFER的 VBO 决定的。由于在调用 glVetexAttribPointer 之前绑定的是先前定义的 VBO对象，顶点属性 0 现在会链接到它的顶点数据。</p>
<p>现在我们已经定义了 OpenGL 该如何解释顶点数据，我们现在应该使用 glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。在 OpenGL 中绘制一个物体，代码会像是这样：</p>
<p>// 0. 复制顶点数组到缓冲中供OpenGL使用<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);<br>// 1. 设置顶点属性指针<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);<br>// 2. 当我们渲染一个物体时要使用着色器程序<br>glUseProgram(shaderProgram);<br>// 3. 绘制物体<br>someOpenGLFunctionThatDrawsOurTriangle();</p>
<p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p>
<h4 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h4><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个 VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在VAO 中</p>
<p>OpenGL 的核心模式<strong>要求</strong>我们使用 VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定 VAO 失败，OpenGL 会拒绝绘制任何东西。</p>
<p>一个顶点数组对象会储存以下这些内容：</p>
<ul>
<li>glEnableVertexAttribArray 和 glDisableVertexAttribArray 的调用。</li>
<li>通过 glVertexAttribPointer 设置的顶点属性配置。</li>
<li>通过 glVertexAttribPointer 调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a4315d14298d0b7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>创建一个 VAO 和创建一个 VBO 很类似：</p>
<p>unsigned int VAO;<br>glGenVertexArrays(1, &amp;VAO);</p>
<p>要想使用 VAO，要做的只是使用 glBindVertexArray 绑定 VAO。从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</p>
<p>// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..<br>// 1. 绑定VAO<br>glBindVertexArray(VAO);<br>// 2. 把顶点数组复制到缓冲中供OpenGL使用<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);<br>// 3. 设置顶点属性指针<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);</p>
<p>[…]</p>
<p>// ..:: 绘制代码（渲染循环中） :: ..<br>// 4. 绘制物体<br>glUseProgram(shaderProgram);<br>glBindVertexArray(VAO);<br>someOpenGLFunctionThatDrawsOurTriangle();</p>
<p>就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO。</p>
<h4 id="我们一直期待的三角形"><a href="#我们一直期待的三角形" class="headerlink" title="我们一直期待的三角形"></a>我们一直期待的三角形</h4><p>要想绘制我们想要的物体，OpenGL 给我们提供了 glDrawArrays 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元。</p>
<p>glUseProgram(shaderProgram);<br>glBindVertexArray(VAO);<br>glDrawArrays(GL_TRIANGLES, 0, 3);</p>
<p>glDrawArrays 函数第一个参数是我们打算绘制的 OpenGL 图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填 0。最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有 3 个顶点长）。</p>
<p>现在尝试编译代码，如果弹出了任何错误，回头检查你的代码。如果你编译通过了，你应该看到下面的结果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-a41e2530a747de6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>完整的程序源码可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp" target="_blank" rel="noopener">这里</a>找到。</p>
<p>如果你的输出和这个看起来不一样，你可能做错了什么。去查看一下源码，检查你是否遗漏了什么东西，或者你也可以在评论区提问。</p>
<h4 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h4><p>在渲染顶点中，还有最后一个需要讨论的–索引缓冲对象(Element Buffer Object, EBO，也叫 Index Buffer Object, IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL 主要处理三角形）。这会生成下面的顶点的集合：</p>
<p>float vertices[] = {<br>    // 第一个三角形<br>    0.5f, 0.5f, 0.0f,   // 右上角<br>    0.5f, -0.5f, 0.0f,  // 右下角<br>    -0.5f, 0.5f, 0.0f,  // 左上角<br>    // 第二个三角形<br>    0.5f, -0.5f, 0.0f,  // 右下角<br>    -0.5f, -0.5f, 0.0f, // 左下角<br>    -0.5f, 0.5f, 0.0f   // 左上角<br>};</p>
<p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有 4 个而不是 6 个顶点，这样就产生 50% 的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果 OpenGL 提供这个功能就好了，对吧？</p>
<p>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO 也是一个缓冲，它专门储存索引，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p>
<p>float vertices[] = {<br>    0.5f, 0.5f, 0.0f,   // 右上角<br>    0.5f, -0.5f, 0.0f,  // 右下角<br>    -0.5f, -0.5f, 0.0f, // 左下角<br>    -0.5f, 0.5f, 0.0f   // 左上角<br>};</p>
<p>unsigned int indices[] = { // 注意索引从0开始!<br>    0, 1, 3, // 第一个三角形<br>    1, 2, 3  // 第二个三角形<br>};</p>
<p>你可以看到，当时用索引的时候，我们只定义了 4 个顶点，而不是 6 个。下一步我们需要创建索引缓冲对象：</p>
<p>unsigned int EBO;<br>glGenBuffers(1, &amp;EBO);</p>
<p>与 VBO 类似，我们先绑定 EBO 然后用 glBufferData 把索引复制到缓冲里。同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p>
<p>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</p>
<p>要注意的是，我们传递了 GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用 glDrawElements 来替换glDrawArrays 函数，来指明我们从索引缓冲渲染。使用 glDrawElements 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p>
<p>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</p>
<p>第一个参数指定了我们绘制的模式，这个和 glDrawArrays 的一样。第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。第三个参数是索引的类型，这里是 GL_UNSIGNED_INT。最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0。</p>
<p>glDrawElements 函数从当前绑定到 GL_ELEMENT_ARRAY_BUFFER目标的 EBO 中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象。绑定 VAO 的同时也会自动绑定 EBO。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-e111d4c80543efca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>当目标是 GL_ELEMENT_ARRAY_BUFFER的时候，VAO 会储存 glBindBuffer 的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑 VAO 之前解绑索引数组缓冲，否则它就没有这个 EBO 配置了。</p>
<p>最后的初始化和绘制代码现在看起来像这样：</p>
<p>// ..:: 初始化代码 :: ..<br>// 1. 绑定顶点数组对象<br>glBindVertexArray(VAO);<br>// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用<br>glBindBuffer(GL_ARRAY_BUFFER, VBO);<br>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);<br>// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用<br>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);<br>// 4. 设定顶点属性指针<br>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);<br>glEnableVertexAttribArray(0);</p>
<p>[…]</p>
<p>// ..:: 绘制代码（渲染循环中） :: ..<br>glUseProgram(shaderProgram);<br>glBindVertexArray(VAO);<br>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)<br>glBindVertexArray(0);</p>
<p>运行程序会获得下面这样的图片的结果。左侧图片看应该起来很熟悉，而右侧的则是使用线框模式(Wireframe Mode)绘制的。线框矩形可以显示出矩形的确是由两个三角形组成的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-3c843b4785f3149f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><strong>线框模式(Wireframe Mode)</strong></p>
<p>要想用线框模式绘制你的三角形，你可以通过 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置 OpenGL 如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用 glPolygonMode(GL_FRONT_AND_BACK, GL_FILL) 将其设置回默认模式。</p>
<p>如果你遇到任何错误，回头检查代码，看看是否遗漏了什么。同时，可以在<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp" target="_blank" rel="noopener">这里</a>找到全部源码。</p>
<p>如果你像我这样成功绘制出了这个三角形或矩形，那么恭喜你，你成功地通过了现代 OpenGL 最难部分之一：绘制你自己的第一个三角形。这部分很难，因为在可以绘制第一个三角形之前你需要了解很多知识。幸运的是我们现在已经越过了这个障碍，接下来的教程会比较容易理解一些。</p>
<h4 id="OC-示例"><a href="#OC-示例" class="headerlink" title="OC 示例"></a>OC 示例</h4><p><img src="https://upload-images.jianshu.io/upload_images/5294842-8d9a7848b6bfbf91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenGLæµç¨"></p>
<p>#import &lt;GLKit/GLKit.h&gt;</p>
<p>@interface ViewController : GLKViewController<br>@end</p>
<p>@interface ViewController ()<br>@property (nonatomic, strong) EAGLContext * context;<br>@property (nonatomic, assign) GLint mCount;<br>@end</p>
<p>@implementation ViewController</p>
<p>- (void)viewDidLoad<br>{<br>    [super viewDidLoad];</p>
<pre><code>// 设置上下文
self.context = \[\[EAGLContext alloc\] initWithAPI:kEAGLRenderingAPIOpenGLES3\];
\[EAGLContext setCurrentContext:self.context\];

GLKView * glkView = (GLKView *)self.view;
glkView.context = self.context;
glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;
glkView.enableSetNeedsDisplay = NO;

float vertexs\[\] = {
    -0.5, -0.5, 0.0, // 左下
    -0.5, 0.5, 0.0,  // 左上
    0.5, -0.5, 0.0,  // 右下
    0.5, 0.5, 0.0    // 右上
};

GLuint indecs\[\] = {
    0, 1, 2,
    1, 2, 3
};

self.mCount = sizeof(indecs) / sizeof(GLuint);

GLuint VBO;
glGenBuffers(1, &amp;VBO);
glBindBuffer(GL\_ARRAY\_BUFFER, VBO);
// 之前定义的顶点数据复制到缓冲的内存中
glBufferData(GL\_ARRAY\_BUFFER, sizeof(vertexs), vertexs, GL\_STATIC\_DRAW);

GLuint VEO;
glGenBuffers(1, &amp;VEO);
glBindBuffer(GL\_ELEMENT\_ARRAY_BUFFER, VEO);
glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, sizeof(indecs), indecs, GL\_STATIC_DRAW);

// 顶点着色器
GLuint vertexShader;
vertexShader = glCreateShader(GL\_VERTEX\_SHADER);

NSString * shaderFile = \[\[NSBundle mainBundle\] pathForResource:@&quot;shader&quot; ofType:@&quot;vsh&quot;\];
const GLchar * shaderString;
NSString * string = \[NSString stringWithContentsOfFile:shaderFile encoding:NSUTF8StringEncoding error:nil\];
shaderString = (GLchar *)\[string UTF8String\];

glShaderSource(vertexShader, 1, &amp;shaderString, NULL);
glCompileShader(vertexShader);  // 编译

GLint success;
glGetShaderiv(vertexShader, GL\_COMPILE\_STATUS, &amp;success);
if (success != GL_TRUE) {

    GLint logLength;
    glGetShaderiv(vertexShader, GL\_INFO\_LOG_LENGTH, &amp;logLength);

    if (logLength &gt; 0) {
        GLchar * log = (GLchar *)malloc(logLength);
        glGetShaderInfoLog(vertexShader, logLength, &amp;logLength, log);

        NSLog(@&quot;顶点着色器编译错误信息：%s&quot;, log);
        free(log);
    }
}

// 片段着色器
GLuint fragmentShader;
fragmentShader = glCreateShader(GL\_FRAGMENT\_SHADER);

NSString * fragFile = \[\[NSBundle mainBundle\] pathForResource:@&quot;Frag&quot; ofType:@&quot;fsh&quot;\];
const GLchar * fragString;
fragString = (GLchar *)\[\[NSString stringWithContentsOfFile:fragFile encoding:NSUTF8StringEncoding error:nil\] UTF8String\];

glShaderSource(fragmentShader, 1, &amp;fragString, NULL);
glCompileShader(fragmentShader);

glGetShaderiv(fragmentShader, GL\_COMPILE\_STATUS, &amp;success);
if (success != GL_TRUE) {

    GLint logLength;
    glGetShaderiv(fragmentShader, GL\_INFO\_LOG_LENGTH, &amp;logLength);

    if (logLength &gt; 0) {
        GLchar * log = (GLchar *)malloc(logLength);
        glGetShaderInfoLog(vertexShader, logLength, &amp;logLength, log);

        NSLog(@&quot;片段着色器编译错误信息：%s&quot;, log);
        free(log);
    }
}

// 着色器程序
GLuint program;
program = glCreateProgram();
// 附加
glAttachShader(program, vertexShader);
glAttachShader(program, fragmentShader);
glLinkProgram(program);

glGetProgramiv(program, GL\_LINK\_STATUS, &amp;success);
if (success != GL_TRUE) {

    GLint logLength;
    glGetProgramiv(program, GL\_INFO\_LOG_LENGTH, &amp;logLength);
    GLchar * log;

    if (logLength &gt; 0) {
        log = (GLchar *)malloc(logLength);
        glGetProgramInfoLog(program, logLength, &amp;logLength, log);

        NSLog(@&quot;链接着色器程序错误信息：%s&quot;, log);
        free(log);
    }
}

glUseProgram(program);

// 删除着色器
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);

glEnableVertexAttribArray(GLKVertexAttribPosition);
/\*   解析顶点数据

            1、指定要配置的顶点属性。此处与 layout (location = 0) 对应
            2、指定顶点属性的大小。顶点属性是一个 vec3，它由 3个值组成，所以大小是3
            3、
        */
glVertexAttribPointer(GLKVertexAttribPosition, 3, GL\_FLOAT, GL\_FALSE, 3 * sizeof(float), (void *)0);

\[glkView display\];
</code></pre><p>}</p>
<p>- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect<br>{<br>    glClearColor(0, 1.0, 0, 1.0);<br>    glClear(GL_COLOR_BUFFER_BIT);</p>
<p>//    glDrawArrays(GL_TRIANGLES, 0, 3);<br>    glDrawElements(GL_TRIANGLES, self.mCount, GL_UNSIGNED_INT, 0);<br>}</p>
<h4 id="附加资源"><a href="#附加资源" class="headerlink" title="附加资源"></a>附加资源</h4><ul>
<li><a href="http://antongerdelan.net/opengl/hellotriangle.html" target="_blank" rel="noopener">antongerdelan.net/hellotriangle</a>：Anton Gerdelan的渲染第一个三角形教程。</li>
<li><a href="https://open.gl/drawing" target="_blank" rel="noopener">open.gl/drawing</a>：Alexander Overvoorde的渲染第一个三角形教程。</li>
<li><a href="http://antongerdelan.net/opengl/vertexbuffers.html" target="_blank" rel="noopener">antongerdelan.net/vertexbuffers</a>：顶点缓冲对象的一些深入探讨。</li>
<li><a href="https://learnopengl.com/#!In-Practice/Debugging" target="_blank" rel="noopener">调试</a>：这个教程中涉及到了很多步骤，如果你在哪卡住了，阅读一点调试的教程是非常值得的（只需要阅读到调试输出部分）。</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>建议在继续下一节的学习之前先做完这些练习，确保你对这些知识有比较好的理解。</p>
<ol>
<li>添加更多顶点到数据中，使用 glDrawArrays，尝试绘制两个彼此相连的三角形：<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp" target="_blank" rel="noopener">参考解答</a></li>
<li>创建相同的两个三角形，但对它们的数据使用不同的 VAO 和 VBO：<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.4.hello_triangle_exercise2/hello_triangle_exercise2.cpp" target="_blank" rel="noopener">参考解答</a></li>
<li>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色：<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.5.hello_triangle_exercise3/hello_triangle_exercise3.cpp" target="_blank" rel="noopener">参考解答</a></li>
</ol>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2018/12/26/opengl-3/">http://yoursite.com/2018/12/26/opengl-3/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/01/01/opengl-4-e7-9d-80-e8-89-b2-e5-99-a8/" class="pre"> OpenGL - 4 着色器		</a><a href="/2018/12/25/opengl-2/" class="next"> OpenGL 2		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点输入"><span class="toc-text">顶点输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点着色器"><span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译着色器"><span class="toc-text">编译着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#片段着色器"><span class="toc-text">片段着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#着色器程序"><span class="toc-text">着色器程序</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#链接顶点属性"><span class="toc-text">链接顶点属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点数组对象"><span class="toc-text">顶点数组对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#我们一直期待的三角形"><span class="toc-text">我们一直期待的三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引缓冲对象"><span class="toc-text">索引缓冲对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OC-示例"><span class="toc-text">OC 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#附加资源"><span class="toc-text">附加资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#练习"><span class="toc-text">练习</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 内存管理：MRC、ARC/">iOS 内存管理：从 MRC 到 ARC 实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>