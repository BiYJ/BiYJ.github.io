<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> 组件化讨论之二		 | D</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> 组件化讨论之二		</h1><a id="logo" href="/.">D</a><p class="description">While there is life there is hope</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title"> 组件化讨论之二		</h1><div class="post-meta"><a href="/2018/04/08/e7-bb-84-e4-bb-b6-e5-8c-96-e8-ae-a8-e8-ae-ba-e5-a7-8b-e6-9c-ab-e4-b9-8b-e4-ba-8c/#comments" class="comment-count"></a><p><span class="date">Apr 08, 2018</span><span><a href="/categories/架构设计/" class="category">架构设计</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>原文地址：<a href="https://casatwy.com/iOS-Modulization.html" title="Permalink to iOS应用架构谈 组件化方案" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a>、<a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">demo</a></p>
<p>这个 Demo 对业务敏感的边界情况处理比较简单，这需要根据不同 App 的特性和不同产品的需求才能做，所以只是为了说明组件化架构用的。如果要应用在实际场景中的话，可以根据代码里给出的注释稍加修改。</p>
<h5 id="一、蘑菇街组件化方案的问题"><a href="#一、蘑菇街组件化方案的问题" class="headerlink" title="一、蘑菇街组件化方案的问题"></a>一、蘑菇街组件化方案的问题</h5><p>蘑菇街的组件化是怎么做的：</p>
<ol>
<li><p>App 启动时实例化各组件模块，然后这些组件向 ModuleManager 注册 Url。有时不需要实例化，使用 class 注册。</p>
</li>
<li><p>当组件 A 需要调用组件 B 时，向 ModuleManager 传递 URL，参数跟随 URL 以 GET 方式传递，类似 openURL。然后由ModuleManager 负责调度组件 B，最后完成任务。</p>
</li>
</ol>
<p>这里的两步中，每一步都存在问题。</p>
<p>1、第一步的问题</p>
<p>在组件化的过程中，注册 URL 并不是充分必要条件，组件是不需要向组件管理器注册 Url 的。而且注册了 Url 之后，会造成不必要的内存常驻，如果只是注册 Class，内存常驻量就小一点，如果是注册实例，内存常驻量就大了。至于蘑菇街注册的是 Class 还是实例，Limboy 分享时没有说，文章里我也没看出来，也有可能是我看漏了。不过这还并不能算是致命错误，只能算是小缺陷。</p>
<p>真正的致命错误在第二步。</p>
<p>2、第二部的问题</p>
<p>在 iOS 领域里，一定是组件化的中间件为 openUrl 提供服务，而不是 openUrl 方式为组件化提供服务。</p>
<p>什么意思呢？</p>
<p>也就是说，一个 App 的组件化方案一定不是建立在 URL 上的，openURL 的跨 App 调用是可以建立在组件化方案上的。当然，如果 App 还没有组件化，openURL 方式也是可以建立的，就是丑陋一点而已。</p>
<p>为什么这么说？</p>
<p>因为组件化方案的实施过程中，需要处理的问题的复杂度，以及拆解、调度业务的过程的复杂度比较大，单纯以 openURL 的方式是无法胜任让一个 App 去实施组件化架构的。如果在给 App 实施组件化方案的过程中是基于 openURL 的方案的话，有一个致命缺陷：非常规对象无法参与本地组件间调度。关于非常规对象我会在详细讲解组件化方案时有一个辨析。</p>
<p>实际 App 场景下，如果本地组件间采用 GET 方式的 URL 调用，就会产生两个问题：</p>
<ul>
<li>根本无法表达非常规对象</li>
</ul>
<p>比如你要调用一个图片编辑模块，不能传递 UIImage 到对应的模块上去的话，这是一个很悲催的事情。 当然，这可以通过给方法新开一个参数，然后传递过去来解决。比如原来是：</p>
<p>[a openUrl:”<a href="http://casa.com/detail?id=123&amp;type=0&quot;\]" target="_blank" rel="noopener">http://casa.com/detail?id=123&amp;type=0&quot;\]</a>;</p>
<p>同时就也要提供这样的方法：</p>
<p>[a openUrl:”<a href="http://casa.com/detail&quot;" target="_blank" rel="noopener">http://casa.com/detail&quot;</a> params:@{ @”id” : “123”,<br>                                              @”type” : “0”,<br>                                              @”image” : [UIImage imageNamed:@”test”] }];</p>
<p>如果不像上面这么做，复杂参数和非常规参数就无法传递。如果这么做了，那么事实上这就是拆分远程调用和本地调用的入口了，这就变成了我文章中提倡的做法，也是蘑菇街方案没有做到的地方。</p>
<p>另外，在本地调用中使用 URL 的方式其实是不必要的，如果业务工程师在本地间调度时需要给出 URL，那么就不可避免要提供 params，在调用时要提供哪些 params 是业务工程师很容易懵逼的地方。。。在文章下半部分给出的 demo 代码样例已经说明了业务工程师在本地间调用时，是不需要知道 URL 的，而且 demo 代码样例也阐释了如何解决业务工程师遇到传 params容易懵逼的问题。</p>
<ul>
<li>URL 注册对于实施组件化方案是完全不必要的，且通过 URL 注册的方式形成的组件化方案，拓展性和可维护性都会被打折</li>
</ul>
<p>注册 URL 的目的其实是一个服务发现的过程，在 iOS 领域中，服务发现的方式是不需要通过主动注册的，使用 runtime 就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime 由于不存在注册过程，那也就不会产生维护的操作，维护成本就降低了。</p>
<p>由于通过 runtime 做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。</p>
<h5 id="二、小总结"><a href="#二、小总结" class="headerlink" title="二、小总结"></a>二、小总结</h5><p>蘑菇街采用了 openURL 的方式来进行 App 的组件化是一个错误的做法，使用注册的方式发现服务是一个不必要的做法。而且这方案还有其它问题，随着下文对组件化方案介绍的展开，相信各位自然心里有数。</p>
<h5 id="三、正确的组件化方案"><a href="#三、正确的组件化方案" class="headerlink" title="三、正确的组件化方案"></a>三、正确的组件化方案</h5><p>先来看一下方案的架构图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-cab5dd96a2de7eb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7"></p>
<p>这幅图是组件化方案的一个简化版架构描述，主要是基于 Mediator 模式和 Target-Action 模式，中间采用了 runtime来完成调用。这套组件化方案将远程应用调用和本地应用调用做了拆分，而且是由本地应用调用为远程应用调用提供服务，与蘑菇街方案正好相反。</p>
<h5 id="四、调用方式"><a href="#四、调用方式" class="headerlink" title="四、调用方式"></a>四、调用方式</h5><p>先说本地应用调用，本地组件 A 在某处调用 [[CTMediator sharedInstance] performTarget:targetName action:actionName params:@{…}] 向 CTMediator 发起跨组件调用，CTMediator 根据获得的 target 和 action 信息，通过 objective-C 的 runtime 转化生成 target 实例以及对应的 action 选择器，然后最终调用到目标业务提供的逻辑，完成需求。</p>
<p>在远程应用调用中，远程应用通过 openURL 的方式，由 iOS 系统根据 info.plist 里的 scheme 配置找到可以响应 URL 的应用，应用通过 AppDelegate 接收到 URL 之后，调用 CTMediator 的 openUrl: 方法将接收到的 URL 信息传入。当然，CTMediator 也可以用 openUrl:options: 的方式顺便把随之而来的 option 也接收，这取决于你本地业务执行逻辑时的充要条件是否包含 option 数据。传入 URL 之后，CTMediator 通过解析 URL，将请求路由到对应的 target 和 action，随后的过程就变成了上面说过的本地应用调用的过程了，最终完成响应。</p>
<p>针对请求的路由操作很少会采用本地文件记录路由表的方式，服务端经常处理这种业务，在服务端领域基本上都是通过正则表达式来做路由解析。App 中做路由解析可以做得简单点，制定 URL 规范就也能完成，最简单的方式就是 scheme://target/action 这种，简单做个字符串处理就能把 target 和 action 信息从 URL 中提取出来了。</p>
<h5 id="五、组件仅通过-Action-暴露可调用接口"><a href="#五、组件仅通过-Action-暴露可调用接口" class="headerlink" title="五、组件仅通过 Action 暴露可调用接口"></a>五、组件仅通过 Action 暴露可调用接口</h5><p>所有组件都通过组件自带的 Target-Action 来响应，也就是说，模块与模块之间的接口被固化在了 Target-Action 这一层，避免了实施组件化的改造过程中，对 Business 的侵入，同时也提高了组件化接口的可维护性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5294842-ebe8e96c85cb70e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8"></p>
<p>可以看到，虚线圈起来的地方就是用于跨组件调用的 target 和 action，这种方式避免了由 BusinessA 直接提供组件间调用会增加的复杂度，而且任何组件如果想要对外提供调用服务，直接挂上 target 和 action 就可以了，业务本身在大多数场景下去进行组件化改造时，是基本不用动的。</p>
<h5 id="六、复杂参数和非常规参数，以及组件化相关设计思路"><a href="#六、复杂参数和非常规参数，以及组件化相关设计思路" class="headerlink" title="六、复杂参数和非常规参数，以及组件化相关设计思路"></a>六、复杂参数和非常规参数，以及组件化相关设计思路</h5><p>统一术语的理解：</p>
<p>复杂参数是指由普通类型的数据组成的多层级参数。在本文中，我们定义只要是能够被 json 解析的类型就都是普通类型，包括 NSNumber、NSString、NSArray、NSDictionary，以及相关衍生类型，比如来自系统的 NSMutableArray 或者你自己定义的都算。</p>
<p>总结：在本文讨论的场景中，复杂参数的定义是由普通类型组成的具有复杂结构的参数。普通类型的定义就是指能够被 json 解析的类型。</p>
<p>非常规参数是指由普通类型以外的类型组成的参数，例如 UIImage 等这些不能够被 json 解析的类型。然后这些类型组成的参数在文中就被定义为非常规参数。</p>
<p>总结：非常规参数是包含非常规类型的参数。非常规类型的定义就是不能被 json 解析的类型都叫非常规类型。</p>
<p>边界情况：</p>
<p>①、假设多层级参数中有存在任何一个内容是非常规参数，本文中这种参数就也被认为是非常规参数。</p>
<p>②、如果某个类型当前不能够被 json 解析，但通过某种转化方式能够转化成 json，那么这种类型在场景上下文中，我们也称为普通类型。举个例子就是通过 json 描述的自定义 view。如果这个 view 能够通过某个组件被转化成 json，那么即使这个 view 本身并不是普通类型，在具有转化器的上下文场景中，我们依旧认为它是普通类型。</p>
<p>③、如果上下文场景中没有转化器，这个 view 就是非常规类型了。</p>
<p>④、假设转化出的 json 不能够被还原成 view，比如组件 A 有转化器，组件 B 中没有转化器，因此在组件间调用过程中 json 在组件 B 里不能被还原成 view。在这种调用方向中，只要调用者能将非常规类型转化成 json 的，我们就依然认为这个 view 是普通类型。如果调用者是组件 A，转化器在组件 B 中，A 传递 view 参数时是没办法转化成 json 的，那么这个 view 就被认为是非常规类型，哪怕它在组件 B 中能够被转化成 json。</p>
<h5 id="七、为什么应该由本地组件间调用来支持远程应用调用？"><a href="#七、为什么应该由本地组件间调用来支持远程应用调用？" class="headerlink" title="七、为什么应该由本地组件间调用来支持远程应用调用？"></a>七、为什么应该由本地组件间调用来支持远程应用调用？</h5><p>远程 App 是不可能通过 URL 来提供非常规参数的，最多只能以 json string 的方式经过 URLEncode 之后再通过 GET来提供复杂参数，然后再在本地组件中解析 json，最终完成调用。在组件间调用时，通过 performTarget:action:params:是能够提供非常规参数的，于是我们可以知道，远程 App 调用时的上下文环境以及功能是本地组件间调用时上下文环境以及功能的子集。</p>
<p>因此这个逻辑注定了必须由本地组件间调用来为远程 App 调用来提供服务，只有符合这个逻辑的设计思路才是正确的组件化方案的设计思路，其他跟这个不一致的思路一定就是错的。因为逻辑上子集为父集提供服务说不通，所以强行这么做的话，用一个成语来总结就叫做倒行逆施。</p>
<p>另外，远程 App 调用和本地组件间调用必须要拆分开，远程 App 调用只能走 CTMediator 提供的专用远程的方法，本地组件间调用只能走 CTMediator 提供的专用本地的方法，两者不能通过同一个接口来调用。这里有两个原因：</p>
<p>①、远程 App 调用处理入参的过程比本地多了一个 URL 解析的过程，这是远程 App 调用特有的过程。</p>
<p>②、架构师没有充要条件可以认为远程 App 调用对于无响应请求的处理方式和本地组件间调用无响应请求的处理方式在未来产品的演进过程中是一致的。</p>
<p>在远程 App 调用中，用户通过 url 进入 app，当 app 无法为这个 url 提供服务时，常见的办法是展示一个的 404 界面，告诉用户“当前没有相对应的内容，不过你可以在 app 里别的地方再逛逛”。这个场景多见于用户使用的 App 版本不一致。比如有一个 URL 只有 v1.1 版本的 app 能完整响应，v1.0 版本的 app 虽然能被唤起，但是无法完成整个响应过程，那么 v1.0 的 app 就要展示一个 404 页面了。</p>
<p>在组件间调用中，如果遇到了无法响应的请求，就要分两种场景考虑了。</p>
<p><strong>场景 1</strong></p>
<p>如果这种无法响应的请求发生场景是在开发过程中，比如两个组件同时在开发，组件 A 调用组件 B 时，组件 B 还处于旧版本没有发布新版本，因此响应不了，那么这时候的处理方式可以相对随意，只要能体现 B 模块是旧版本就行了，最后在RC 阶段统测时是一定能够发现的，只要 App 没发版，怎么处理都来得及。</p>
<p><strong>场景 2</strong></p>
<p>如果这种无法响应的请求发生场景是在已发布的 App 中，有可能展示个 404 就结束了，那这就跟远程 App 调用时的 404 处理场景一样。但也有可能需要为此做一些额外的事情，有可能因为做了额外的事情，就不展示 404 了，展示别的页面了，这一切取决于产品经理。</p>
<p>那么这种场景是如何发生的呢？</p>
<p>举一个例子：当用户在 v1.0 版本时收藏了一个东西，然后用户升级 App 到 v1.1 版本。v1.0 版本的收藏项目在本地持久层存入的数据有可能是会跟 v1.1 版本收藏时存入的数据是不一致的。此时用户在 v1.1 版本的 app 中对 v1.0 版本收藏的东西做了一些操作，触发了本地组件间调用，这个本地间调用又与收藏项目本身的数据相关，那么这时这个调用就是有可能变成无响应调用，此时的处理方式就不见得跟以前一样展示个 404 页面就结束了，因为用户已经看到了收藏了的东西，结果你还告诉他找不到，用户立刻懵逼。。。这时候的处理方式就会用很多种，至于产品经理会选择哪种，你作为架构师是没有办法预测的。如果产品经理提的需求落实到架构上，对调用入口产生要求然而你的架构又没有拆分调用入口，对于你的选择就只有两个：要么打回产品需求，要么加个班去拆分调用入口。</p>
<p>当然，架构师可以选择打回产品经理的需求，最终挑选一个自己的架构能够承载的需求。但是，如果这种是因为你早期设计架构时挖的坑而打回的产品需求，你不觉得丢脸么？</p>
<p>鉴于远程 app 调用和本地组件间调用下的无响应请求处理方式不同，以及未来不可知的产品演进，拆分远程 app 调用入口和本地组件间调用入口是功在当代利在千秋的事情。</p>
<h5 id="八、组件化方案中的去-model-设计"><a href="#八、组件化方案中的去-model-设计" class="headerlink" title="八、组件化方案中的去 model 设计"></a>八、组件化方案中的去 model 设计</h5><p>组件间调用时，是需要针对参数做去 model 化的。如果组件间调用不对参数做去 model 化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。</p>
<p>假设模块 A 和模块 B 之间采用 model 化的方案去调用，那么调用方法时传递的参数就会是一个对象。</p>
<p>如果对象不是一个面向接口的通用对象，那么 mediator 的参数处理就会非常复杂，因为要区分不同的对象类型。如果mediator 不处理参数，直接将对象以范型的方式转交给模块 B，那么模块 B 必然要包含对象类型的声明。假设对象声明放在模块 A，那么 B 和 A 之间的组件化只是个形式主义。如果对象类型声明放在 mediator，那么对于 B 而言，就不得不依赖mediator。但是，大家可以从上面的架构图中看到，对于响应请求的模块而言，依赖 mediator 并不是必要条件，因此这种依赖是完全不需要的，这种依赖的存在对于架构整体而言，是一种污染。</p>
<p>如果参数是一个面向接口的对象，那么 mediator 对于这种参数的处理其实就没必要了，更多的是直接转给响应方的模块。而且接口的定义就不可能放在发起方的模块中了，只能放在 mediator 中。响应方如果要完成响应，就也必须要依赖mediator，然而前面我已经说过，响应方对于 mediator 的依赖是不必要的，因此参数其实也并不适合以面向接口的对象的方式去传递。</p>
<p>因此，使用对象化的参数无论是否面向接口，带来的结果就是业务模块形式上是被组件化了，但实质上依然没有被独立。</p>
<p>在这种跨模块场景中，参数最好还是以去 model 化的方式去传递，在 iOS 的开发中，就是以字典的方式去传递。这样就能够做到只有调用方依赖 mediator，而响应方不需要依赖 mediator。然而在去 model 化的实践中，由于这种方式自由度太大，我们至少需要保证调用方生成的参数能够被响应方理解，然而在组件化场景中，限制去 model 化方案的自由度的手段，相比于网络层和持久层更加容易得多。</p>
<p>因为组件化天然具备了限制手段：参数不对就无法调用！无法调用时直接 debug 就能很快找到原因。所以接下来要解决的去model 化方案的另一个问题就是：如何提高开发效率。</p>
<p>在去 model 的组件化方案中，影响效率的点有两个：调用方如何知道接收方需要哪些 key 的参数？调用方如何知道有哪些target 可以被调用？其实后面的那个问题不管是不是去 model 的方案，都会遇到。为什么放在一起说，因为我接下来要说的解决方案可以把这两个问题一起解决。</p>
<h5 id="九、使用-category"><a href="#九、使用-category" class="headerlink" title="九、使用 category"></a>九、使用 category</h5><p>mediator 这个 repo 维护了若干个针对 mediator 的 category，每一个对应一个 target，每个 category 里的方法对应了这个 target 下所有可能的调用场景，这样调用者在包含 mediator 的时候，自动获得了所有可用的 target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是 category 而不是其他：</p>
<p>①、category 本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用 category 封装是很合理的。</p>
<p>②、在 category 的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category 就提供了补救的入口。</p>
<p>③、category 可以很轻松地做请求转发，如果不采用 category，请求转发逻辑就非常难做了。</p>
<p>④、category 统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。</p>
<p>⑤、由于 category 统一了所有的调用入口，使得在跨模块调用时，对于 param 的 hardcode 在整个 App 中的作用域仅存在于 category 中，在这种场景下的 hardcode 就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。</p>
<p>本文对应的 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="noopener">Demo</a> 展示了如何使用 category 来实现去 model 的组件调用。上面的代码片段也是摘自这个 demo。</p>
<h5 id="十、基于其他考虑还要再做的一些额外措施"><a href="#十、基于其他考虑还要再做的一些额外措施" class="headerlink" title="十、基于其他考虑还要再做的一些额外措施"></a>十、基于其他考虑还要再做的一些额外措施</h5><p>1、基于安全考虑</p>
<p>我们需要防止黑客通过 URL 的方式调用本属于 native 的组件，比如支付宝的个人财产页面。如果在调用层级上没有区分好，没有做好安全措施，黑客就有通过 safari 查看任何人的个人财产的可能。</p>
<p>安全措施其实有很多，大部分取决于 App 本身以及产品的要求。在架构层面要做的最基础的一点就是区分调用是来自于远程 App 还是本地组件，我在 demo 中的安全措施是采用给 action 添加 native 前缀去做的，凡是带有 native 前缀的就都只允许本地组件调用，如果在 url 阶段发现调用了前缀为 native 的方法，那就可以采取停止响应的措施了。这也是将远程 app 调用入口和本地组件调用入口区分开来的重要原因之一。</p>
<p>当然，为了确保安全的做法有很多，但只要拆出远程调用和本地调用，各种做法就都有施展的空间了。</p>
<p>2、基于动态调度考虑</p>
<p>动态调度的意思就是，今天可能这个跳转是要展示 A 页面，但是明天可能同样的跳转就要去展示 B 页面了。这个跳转有可能是来自于本地组件间跳转也有可能是来自于远程 app。</p>
<p>做这个事情的切点在本文架构中，有很多个：</p>
<p>①、以 url parse 为切点</p>
<p>②、以实例化 target 时为切点</p>
<p>③、以 category 调度方法为切点</p>
<p>④、以 target 下的 action 为切点</p>
<p>如果以 url parse 为切点的话，那么这个动态调度就只能够对远程 App 跳转产生影响，失去了动态调度本地跳转的能力，因此是不适合的。</p>
<p>如果以实例化 target 时为切点的话，就需要在代码中针对所有 target 都做一次审查，看是否要被调度，这是没必要的。假设 10 个调用请求中，只有 1 个要被动态调度，那么就必须要审查 10 次，只有那 1 次审查通过了，才走动态调度，这是一种相对比较粗暴的方法。</p>
<p>如果以 category 调度方法为切点的话，那动态调度就只能影响到本地件组件的跳转，因为 category 是只有本地才用的，所以也不适合。</p>
<p>以 target 下的 action 为切点是最适合的，因为动态调度在一般场景下都是有范围的，大多数是活动页需要动态调度，今天这个活动明天那个活动，或者今天活动正在进行明天活动就结束了，所以产生动态调度的需求。我们在可能产生动态调度的 action 中审查当前 action 是否需要被动态调度，在常规调度中就没必要审查了，例如个人主页的跳转，商品详情的跳转等，这样效率就能比较高。</p>
<p>大家会发现，如果要做类似这种效率更高的动态调度，target-action 层被抽象出来就是必不可少的，然而蘑菇街并没有抽象出 target-action 层，这也是其中的一个问题。</p>
<p>当然，如果你的产品要求所有页面都是存在动态调度需求的，那就还是以实例化 target 时为切点去调度了，这样能做到审查每一次调度请求，从而实现动态调度。</p>
<p>说完了调度切点，接下来要说的就是如何完成审查流程。完整的审查流程有几种，我每个都列举一下：</p>
<p>①、App 启动时下载调度列表，或者定期下载调度列表。然后审查时检查当前 target 是否存在要被动态调度跳转的 action，如果存在，则跳转到另一个 action</p>
<p>②、每一次到达新的 action 时，以 action 为参数调用 API 获知是否需要被跳转，如果需要被跳转，则 API 告知要跳转的 action，然后再跳转到 API 指定的 action</p>
<p>这两种做法其实都可以，如果产品对即时性的要求比较高，那么采用第二种方案，如果产品对即时性要求不那么高，第一种方案就可以了。由于本文的方案是没有 URL 注册列表的，因此服务器只要给出原始 target-action 和对应跳转的 target-action 就可以了，整个流程不是只有注册 URL 列表才能达成的，而且这种方案比注册 URL 列表要更易于维护一些。</p>
<p>另外，说采用 url rewrite 的手段来进行动态调度，也不是不可以。但是这里我需要辨析的是，URL 的必要性仅仅体现在远程 App 调度中，是没必要蔓延到本地组件间调用的。这样，当我们做远程 App 的 URL 路由时（目前的 demo 没有提供 URL 路由功能，但是提供了 URL 路由操作的接入点，可以根据业务需求插入这个功能），要关心的事情就能少很多，可以比较干净。在这种场景下，单纯以 URL rewrite 的方式其实就与上文提到的以 url parse 为切点没有区别了。</p>
<h5 id="十一、蘑菇街的组件化方案的缺陷"><a href="#十一、蘑菇街的组件化方案的缺陷" class="headerlink" title="十一、蘑菇街的组件化方案的缺陷"></a>十一、蘑菇街的组件化方案的缺陷</h5><ul>
<li>蘑菇街没有拆分远程调用和本地间调用</li>
</ul>
<p>不拆分远程调用和本地间调用，就使得后续很多手段难以实施，这个我在前文中都已经有论述了。另外再补充一下，这里的拆分不是针对来源做拆分。比如通过 URL 来区分是远程 App 调用还是本地调用，这只是区分了调用者的来源。</p>
<p>这里说的区分是指：远程调用走远程调用路径，也就是 openUrl -&gt; urlParse -&gt; perform -&gt; target-action。本地组件间调用就走本地组件间调用路径：perform -&gt; target-action。这两个是一定要作区分的，蘑菇街方案并没有对此做好区分。</p>
<ul>
<li>蘑菇街以远程调用的方式为本地间调用提供服务</li>
</ul>
<p>这是本末倒置的做法，倒行逆施导致的是未来架构难以为业务发展提供支撑。因为前面已经论述过，在 iOS 场景下，远程调用的实现是本地调用实现的子集，只有大的为小提供服务，也就是本地调用为远程调用提供服务，如果反过来就是倒行逆施了。</p>
<ul>
<li>蘑菇街的本地间调用无法传递非常规参数，复杂参数的传递方式非常丑陋</li>
</ul>
<p>注意这里复杂参数和非常规参数的辨析。</p>
<p>由于采用远程调用的方式执行本地调用，在前面已经论述过两者功能集的关系，因此这种做法无法满足传递非常规参数的需求。而且如果基于这种方式不变的话，复杂参数的传递也只能依靠经过 urlencode 的 json string 进行，这种方式非常丑陋，而且也不便于调试。</p>
<ul>
<li>蘑菇街必须要在 app 启动时注册 URL 响应者</li>
</ul>
<p>这个条件在组件化方案中是不必要条件，demo 也已经证实了这一点。这个不必要的操作会导致不必要的维护成本，如果单纯从只要完成业务就好的角度出发，这倒不是什么大问题。这就看架构师对自己是不是要求严格了。</p>
<ul>
<li>新增组件化的调用路径时，蘑菇街的操作相对复杂</li>
</ul>
<p>在本文给出的组件化方案中，响应者唯一要做的事情就是提供 Target 和 Action，并不需要再做其它的事情。蘑菇街除此之外还要再做很多额外不必要措施，才能保证调用成功。</p>
<ul>
<li>蘑菇街没有针对 target 层做封装</li>
</ul>
<p>这种做法使得所有的跨组件调用请求直接 hit 到业务模块，业务模块必然因此变得臃肿难以维护，属于侵入式架构。应该将原本属于调用相应的部分拿出来放在 target-action 中，才能尽可能保证不将无关代码侵入到原有业务组件中，才能保证业务组件未来的迁移和修改不受组件调用的影响，以及降低为项目的组件化实施而带来的时间成本。</p>
<h5 id="十二、总结"><a href="#十二、总结" class="headerlink" title="十二、总结"></a>十二、总结</h5><p>本文提供的组件化方案是采用 Mediator 模式和苹果体系下的 Target-Action 模式设计的。</p>
<p>然而这款方案有一个很小的缺陷在于对 param 的 key 的 hardcode，这是为了达到最大限度的解耦和灵活度而做的权衡。在我的网络层架构和持久层架构中，都没有 hardcode 的场景，这也从另一个侧面说明了组件化架构的特殊性。</p>
<p>权衡时，考虑到这部分 hardcode 的影响域仅仅存在于 mediator 的 category 中。在这种情况下，hardcode 对于调用者的调用是完全透明的。对于响应者而言，处理方式等价于对 API 返回的参数的处理方式，且响应者的处理方式也被限制在了Action 中。</p>
<p>因此这部分的 hardcode 的存在虽然确实有点不干净，但是相比于这些不干净而带来的其他好处而言，在权衡时是可以接受的，如果不采用 hardcode，那势必就会导致请求响应方也需要依赖 mediator，然而这在逻辑上是不必要的。另外，在我的各个项目的实际使用过程中，这部分 hardcode 是没有影响的。</p>
<p>另外要谈的是，之所以会在组件化方案中出现 harcode，而网络层和持久层的去 model 化都没有发生 hardcode 情况，是因为组件化调用的所有接受者和调用者都在同一片上下文里。网络层有一方在服务端，持久层有一方在数据库。再加上设计时针对 hardcode 部分的改进手段其实已经超出了语言本身的限制。也就是说，harcode 受限于语言本身。objective-C 也好，swift 也好，它们的接口设计哲学是存在缺陷的。如果我们假设在 golang 的背景下，是完全可以用 golang 的接口体系去做一个最优美的架构方案出来的。不过这已经不属于本文的讨论范围了，有兴趣的同学可以去了解一下相关知识。架构设计有时就是这么无奈。</p>
<p>组件化方案在 App 业务稳定，且规模（业务规模和开发团队规模）增长初期去实施非常重要，它有助于将复杂 App 分而治之，也有助于多人大型团队的协同开发。但组件化方案不适合在业务不稳定的情况下过早实施，至少要等产品已经经过 MVP 阶段时才适合实施组件化。因为业务不稳定意味着链路不稳定，在不稳定的链路上实施组件化会导致将来主业务产生变化时，全局性模块调度和重构会变得相对复杂。</p>
<p>当决定要实施组件化方案时，对于组件化方案的架构设计优劣直接影响到架构体系能否长远地支持未来业务的发展，对 App 的组件化不只是仅仅的拆代码和跨业务调页面，还要考虑复杂和非常规业务参数参与的调度，非页面的跨组件功能调度，组件调度安全保障，组件间解耦，新旧业务的调用接口修改等问题。</p>
<p>蘑菇街的组件化方案只实现了跨业务页面调用的需求，本质上只实现了我在 view 层架构的文章中跨业务页面调用的内容，这还没有到成为组件化方案的程度，且蘑菇街的组件化方案距离真正的 App 组件化的要求还是差了一段距离的，且存在设计逻辑缺陷，希望蘑菇街能够加紧重构，打造真正的组件化方案。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: BiYJ</p><p>原文链接: <a href="http://yoursite.com/2018/04/08/e7-bb-84-e4-bb-b6-e5-8c-96-e8-ae-a8-e8-ae-ba-e5-a7-8b-e6-9c-ab-e4-b9-8b-e4-ba-8c/">http://yoursite.com/2018/04/08/e7-bb-84-e4-bb-b6-e5-8c-96-e8-ae-a8-e8-ae-ba-e5-a7-8b-e6-9c-ab-e4-b9-8b-e4-ba-8c/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2018/04/09/modularization3/" class="pre"> 组件化讨论之三		</a><a href="/2018/04/08/modularization1/" class="next"> 组件化讨论之一		</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、蘑菇街组件化方案的问题"><span class="toc-text">一、蘑菇街组件化方案的问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、小总结"><span class="toc-text">二、小总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三、正确的组件化方案"><span class="toc-text">三、正确的组件化方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四、调用方式"><span class="toc-text">四、调用方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五、组件仅通过-Action-暴露可调用接口"><span class="toc-text">五、组件仅通过 Action 暴露可调用接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六、复杂参数和非常规参数，以及组件化相关设计思路"><span class="toc-text">六、复杂参数和非常规参数，以及组件化相关设计思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七、为什么应该由本地组件间调用来支持远程应用调用？"><span class="toc-text">七、为什么应该由本地组件间调用来支持远程应用调用？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八、组件化方案中的去-model-设计"><span class="toc-text">八、组件化方案中的去 model 设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#九、使用-category"><span class="toc-text">九、使用 category</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十、基于其他考虑还要再做的一些额外措施"><span class="toc-text">十、基于其他考虑还要再做的一些额外措施</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十一、蘑菇街的组件化方案的缺陷"><span class="toc-text">十一、蘑菇街的组件化方案的缺陷</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#十二、总结"><span class="toc-text">十二、总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/WKWebView/">WKWebView</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/iOS 编译过程原理(2)/">iOS 编译过程原理(2)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/BFPRT算法/">BFPRT 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/全排列/">全排列</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/01-背包/">0-1 背包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/直接插入排序/">直接插入排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/armv7、armv7s、arm64/">armv7、armv7s、arm64</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/Archives配置/">Archives 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/App-Thinning/">App Thinning</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/AFNetworking/">AFNetworking</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AFNetworking/">AFNetworking</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GLSL/">GLSL</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Games/">Games</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Leetcode/">Leetcode</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MJRefresh/">MJRefresh</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OC/">OC</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OPENGL/">OPENGL</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveCocoa/">ReactiveCocoa</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SDWebImage/">SDWebImage</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpriteKit/">SpriteKit</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Xcode/">Xcode</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存管理/">内存管理</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/减治法/">减治法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分治法/">分治法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动态规划/">动态规划</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/变治法/">变治法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/图像视频/">图像视频</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程/">多线程</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习笔记/">学习笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工程发布/">工程发布</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/底层原理/">底层原理</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/排序算法/">排序算法</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/效率-工具/">效率 | 工具</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据存储/">数据存储</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构设计/">架构设计</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法相关/">算法相关</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络编程/">网络编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/视图-amp-动画/">视图 &amp; 动画</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计策略/">设计策略</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读源码/">阅读源码</a><span class="category-list-count">8</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/排序算法/" style="font-size: 15px;">排序算法</a> <a href="/tags/动态规划/" style="font-size: 15px;">动态规划</a> <a href="/tags/分治法/" style="font-size: 15px;">分治法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a><ul></ul><a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a><ul></ul><a href="https://www.cnblogs.com/machao/" title="马在路上" target="_blank">马在路上</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">BiYJ.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>