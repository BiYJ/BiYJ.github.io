---
title: 排序算法
categories: algorithm
---

## 一、冒泡排序

#### 1.1 简介

冒泡排序是<font color=#cc0000>蛮力法</font>在排序问题上的一个典型的应用场景。

> 对于一个给定长度为 n 的无序数组，由初始位置开始，比较数组相邻两个元素。如果是逆序排列的，就交换它们的位置，重复多次之后，最大数就“<font color=#cc0000>沉</font>”到了数组最后的位置。第二次再从初始位置开始，将第二大的元素沉到倒数第二个位置。这样一直做 n-1 次，整个数组就是有序的了。

![](https://upload-images.jianshu.io/upload_images/5294842-b62f26f8b7dc357b.gif?imageMogr2/auto-orient/strip)

对于一个长度为 n 的数组，整个算法消耗的时间为：(n-1) + (n-2) + ... + 1 = n(n-1)/2，那么它的时间复杂度为 <font color=#cc0000>O(n<sup>2</sup>)</font>。同时，显而易见，整个算法只消耗一份数组的空间，所以空间复杂度为 <font color=#cc0000>O(1)</font>。

另外，普及一下排序算法另一个重要的特性：**<font color=#cc0000>稳定性</font>**。

> 所谓的稳定性，通俗地讲就是能保证两个相等的数在排序前后的顺序相同。
> 
> 假定原数组有两个相同的元素 Ω，在数组的 a[i] 和 a[j] 位置。排序前 a[i] 在 a[j] 的前面，在排序之后，a[i] 仍然在 a[j] 的前面，那么就说这种排序方法具有稳定性。

<font color=#cc0000>冒泡排序是一种稳定排序</font>。

蛮力法的应用有一个显著的特点，就是在经过适当的努力之后，可以对算法进行一定的改良，从而提高它的性能，但并不会减弱算法本身的时间复杂度。冒泡排序作为蛮力法的典型应用，自然也有这种特性。

#### 1.2 改进

> 设定交换发生的标识位

对于待排序的数组，可以设定一个标志位，检查一次比较之后，是否有数据进行了交换，若是没有，那么整个数组就已经有序了，可以直接退出。极端情况下，如刚才提到的，对有序数组进行排序，只需要执行 n-1 次操作，就可以完成排序。

> 记录最后一次发生交换的位置

初始排序时，数组是在 [0, n] 区间遍历，那么下一轮的遍历是在 [0, n-1] 区间。

现在记录数组本轮遍历的最后一次交换发生在 lastSwapPos 位置，那么下一轮的遍历实际上是在 [0, lastSwapPos] 区间。

#### 1.3 代码

```c
#define ARRAY_LENGTH  10
void bubbleSort(int arr[])
{
    int lastSwapPos = ARRAY_LENGTH - 1;
    int lastSwapPosTemp = ARRAY_LENGTH - 1;
    int temp  = 0;
    
    // ①
    for (int i = 0; i < ARRAY_LENGTH - 1; i++) {
        for (int j = 0; j < ARRAY_LENGTH - i - 1; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    
    // ②
    for (int i = 0; i < ARRAY_LENGTH - 1; i++) {
        
        lastSwapPos = lastSwapPosTemp;
        
        for (int j = 0; j < lastSwapPos; j++) {
            if (arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                lastSwapPosTemp = j;
            }            
        }
        
        // 一次都未交换的情况
        if (lastSwapPos == lastSwapPosTemp) {
            break;
        }
    }
    
    for (int i = 0; i < ARRAY_LENGTH; i++) {
        printf("%d  ", arr[i]);
    }
}
```

#### 1.4 总结

优点：

*   空间复杂度 T = O(1)
*   稳定排序
*   在排序过程中，整个数组趋向稳定
*   对于已经有序的数组，排序效率高

缺点：

*   效率低
*   交换次数多，交换效率低（每次交换只减少一组逆序对）
*   不能并发执行

## 二、选择排序

#### 2.1 简介

选择排序是<font color=#cc0000>蛮力法</font>的一种实际应用。

> 首先扫描整个数组，<font color=#cc0000>找到最小的元素</font>，然后和第一个元素进行交换，如此一来就等同于将最小的元素放到它在有序表中最终的位置上。然后从第二个元素开始扫描整个表，找到剩余 n-1 个元素中最小的元素，与第二个元素交换位置。以此类推，在执行 n-1 遍之后，这个数组就自然有序了。（当然每次找最大的元素，与最后一个元素交换也是可行的）

![SelectSortGif.gif](https://upload-images.jianshu.io/upload_images/5294842-95d0e230361f79d5.gif?imageMogr2/auto-orient/strip)

选择排序有一个最明显的优于冒泡排序的：<font color=#cc0000>数据交换的次数</font>。在完全逆序的情况下，冒泡排序需要最多的 n*(n-1)/2 次交换，而选择排序最多产生 n-1 次交换。

选择排序的时间复杂度是 <font color=#cc0000>O(n^2)</font>，空间复杂度是 <font color=#cc0000>O(1)</font>。

选择排序有一个很重要的特性——<font color=#cc0000>它是一种不稳定排序</font>。假定一个数组：[5, 5, 6, 1, 8]，可以很清晰的发现，在选择排序结束之后，两个 5 并不能保持原来的顺序，第一个 5 在第四的位置，第二个 5 还在第二的位置。

#### 2.2 改进

每一次外循环的遍历，可以同时找到最小值（minIndex）和最大值（maxIndex），分别和头、尾两个元素进行交换。这样一来外循环只要执行原来一半的循环次数就可以了。

但是需要注意一点：每次循环要进行 2 次交换，第一次最小值交换结束之后，在进行最大值交换的时候要先判断最大值是不是在第一个位置，在第一次最小值交换的时候已经换到了后面。

如 [5, 4, 3, 2, 1] 第一次最小值交换后变成了 [1, 4, 3, 2, 5]，初始记录的 maxIndex = 0 就指向了 1，而不是 5。

#### 2.3 代码

```c
#define ARRAY_LENGTH  10
void selectSort(int arr[])
{
    // 数组内容合法性判断
    
    int minIndex;
    int maxIndex;
    
    // 方式 ①
    for (int i = 0; i < ARRAY_LENGTH - 1; i++) {
        minIndex = i;
        for (int j = i; j < ARRAY_LENGTH; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 判断第一个是不是最小值，是的话可以不用交换
        if (i != minIndex) {
            swap(i, minIndex, arr);
        }
    }
    
    // 方式 ②
    for (int i = 0; i < ARRAY_LENGTH / 2; i++) {
        
        minIndex = i;
        maxIndex = i;
        
        for (int j = i; j < ARRAY_LENGTH - i; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
            
            if (arr[j] > arr[maxIndex]) {
                maxIndex = j;
            }
        }
        
        // 判断第一个是不是最小值，是的话可以不用交换
        if (i != minIndex) {
            swap(i, minIndex, arr);
        }
        if (ARRAY_LENGTH - 1 - i != maxIndex) {
            // 防止最大数在第一个，优先和最小数进行交换
            swap(ARRAY_LENGTH - 1 - i, (i == maxIndex) ? minIndex : maxIndex, arr);
        }
    }
    
    for (int i = 0; i < ARRAY_LENGTH; i++) {
        printf("%d  ", arr[i]);
    }
}
void swap(int idx1, int idx2, int arr[]) {
    int temp  = arr[idx1];
    arr[idx1] = array[idx2];
    arr[idx2] = temp;
}
```

## 三、直接插入排序

#### 3.1 减治法（增量法）

> *    减治法：对于一个全局的大问题，将其与一个更小规模的问题建立递推关系。
> *    增量法：基于一个小规模问题的解，和一个更大规模的问题建立递推关系。

减治法和增量法，从本质上来讲，都是基于一种建立递推关系的思想来减小或扩大问题规模的方法。

很显然，无论是减治法还是增量法，其核心是如何建立一个大规模问题和一个小规模问题的递推关系。根据应用的场景不同，主要有以下 3 种变化形式：

*    减去一个常量。（直接插入排序）
*    减去一个常量因子。（二分查找法）
*    减去的规模可变。（辗转相除法）

#### 3.2 直接插入排序

直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：

> 对于数组 a[0, n] 的排序问题，假定数组在 a[0, n - 1] 排序的问题已经解决了。
> 
> 考虑 a[n] 的值 x，从右向左扫描有序数组 a[0, n - 1]，直到第一个小于等于 x 的元素，将 x 插在这个元素的后面。

![InsertSort.gif](https://upload-images.jianshu.io/upload_images/5294842-efaf86b318ef2893.gif?imageMogr2/auto-orient/strip)

很显然，基于增量法的思想在解决这个问题上拥有更高的效率。

直接插入排序对于完全逆序的数组，需要比较和移位的次数为 n(n-1)/2；对于已经有序的数组，只需要比较的次数是 n-1，需要移位的次数是 0。

当然，对于最好和最坏的情况的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）

直接插入排序的时间复杂度是 <font color=#cc0000>O(n<sup>2</sup>)</font>，空间复杂度是 <font color=#cc0000>O(1)</font>，同时也是<font color=#cc0000>稳定排序</font>。

#### 3.3 优化

> 设置哨兵位

仔细分析直接插入排序的代码，会发现虽然每次都需要将数组向后移位，但是在此之前的判断却是可以优化的。

不难发现，每次都是从有序数组的最后一位开始，向前扫描的，这意味着，如果当前值比有序数组的第一位还要小，那就必须比较有序数组的长度 n 次。这个比较次数，在不影响算法稳定性的情况下，是可以简化的：<font color=#cc0000>记录上一次插入的值和位置，与当前插入值比较</font>。若当前值小于上个值，将上个值插入的位置之后的数，全部向后移位，从上个值插入的位置作为比较的起点；反之，仍然从有序数组的最后一位开始比较。

> 二分查找法

优化直接插入排序的核心在于：<font color=#cc0000>快速定位当前数字待插入的位置</font>。

在一个有序数组中查找一个给定的值，最快的方法无疑是二分查找法，对于当前数不在有序数组中的情况，java 官方的 JDK 源码 Arrays.binarySearch() 方法也给出了定位的方式。当然此方法的入参，需要将有序数组传递进去，这需要不断地组装数组，既消耗空间，也不现实，但是可以借鉴这方法，自己实现类似的功能。

这种定位方式有一个致命的缺点就是虽然能找到位置，但最终形成的数组会**打破排序算法的稳定性**，导致即使效率高出普通的直接插入排序法很多，但却不被使用。既然一定会打破稳定性，那么为什么不使用更优秀的希尔排序呢？

#### 3.4 简单的性能比较

![多种优化方式性能比较](https://upload-images.jianshu.io/upload_images/5294842-53aa065d1538f636.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

结论：

*    **在某些特定场景下**，由于入参的条件不同，自定义的方式实现执行效率可能高于源码。
    
*    对于小规模的数组，优化的结果和预想相反，效率比不上最初的方法。原因在于本身只是对于判断的优化，而不是执行次数的优化。在每次循环中，加上更多的计算去优化这个判断，在小数组上对于整个排序的效率，反而是一种伤害。
    
*    大规模数组，二分查找优化效率明显。
    

#### 3.5 代码

```c
#define ARRAY_LENGTH  10
void insertSort(int list[])
{
    // 第1个数肯定是有序的，从第2个数开始遍历，依次插入有序序列
    for (int i = 1; i < ARRAY_LENGTH; i++) {
        int j = 0;
        int temp = list[i]; // 取出第i个数，和前i-1个数比较后，插入合适位置
        
        // 因为前i-1个数都是从小到大的有序序列，所以只要当前比较的数(list[j])比temp大，就把这个数后移一位
        for (j = i - 1; j > -1 && temp < list[j]; j--) {
            list[j + 1] = list[j];
        }
        list[j + 1] = temp;
    }
    
    for (int i = 0; i < ARRAY_LENGTH; i++) {
        printf("%d  ", list[i]);
    }
}
// 根据上一次的位置，简化下一次定位
static void optimized_1(int array[]) {
    // 记录上一个插入值的位置和数值
    int checkValue = array[0];
    int checkIndex = 0;
    
    // 循环插入
    for (int i = 1; i < ARRAY_LENGTH; i++) {
        
        int cur = array[i];
        int start = i - 1;
        int j = 0;
       
        // 根据上一个值，定位开始遍历的位置
        if (cur < checkValue) {
            start = checkIndex;
            for (int j = i - 1; j > start - 1; j--) {
                array[j + 1] = array[j];
            }
        }
        
        // 剩余情况是：checkIndex 位置的数字，和其下一个坐标位置是相同的
        // 循环判断 + 插入
        for (j = start; j > -1; j--) {
            
            if (cur < array[j]) {
                array[j + 1] = array[j];
            }
            else {
                break;
            }
        }
        array[j + 1] = cur;
        checkValue = cur;
        checkIndex = j + 1;
    }
    
    for (int i = 0; i < ARRAY_LENGTH; i++) {
        printf("%d  ", array[i]);
    }
}
```
  

## 四、学习文章

[Gerrard_Feng](https://home.cnblogs.com/u/jing-an-feng-shao/) & [排序算法(一) 冒泡排序](https://www.cnblogs.com/jing-an-feng-shao/p/5951431.html)

[Gerrard_Feng](https://home.cnblogs.com/u/jing-an-feng-shao/) & [排序算法(二) 选择排序](https://www.cnblogs.com/jing-an-feng-shao/p/5956672.html)

[常见排序算法导读(3)[简单选择排序]](https://www.cnblogs.com/idorax/p/6537412.html)

[Gerrard_Feng](https://home.cnblogs.com/u/jing-an-feng-shao/) & [排序算法(三) 直接插入排序](https://www.cnblogs.com/jing-an-feng-shao/p/6165094.html)