---
title: " SDWebImage\t\t"
url: 778.html
id: 778
comments: false
categories:
  - 阅读源码
date: 2018-03-19 11:46:27
tags:
---

##### 一、SDWebImageCompat

原文：[https://www.cnblogs.com/machao/p/6137517.html](https://www.cnblogs.com/machao/p/6137517.html)

该配置文件主要是兼容 Apple 的其他设备。也许真实的开发平台只有一个，但还是需要考虑各个平台的兼容性，这对于框架有着很重要的意义。这些用法能够在项目开发中提高效率。

#ifdef \_\_OBJC\_GC__

#error SDWebImage does not support Objective-C Garbage Collection

#endif

\_\_OBJC\_GC__表示宏内引用的文件确保只被使用 Objective-C 语言的文件所引用，保证引用关系的清晰。

SDWebImage 不支持垃圾回收机制，垃圾回收(Gargage-collection)是 Objective-C 提供的一种自动内存回收机制。当启动这个功能后，所有的 retain、autorelease、release 和 dealloc 方法都将被系统忽略。

#if !TARGET\_OS\_IPHONE && !TARGET\_OS\_IOS && !TARGET\_OS\_TV && !TARGET\_OS\_WATCH

#define SD_MAC 1

#else

#define SD_MAC 0

#endif

Apple's defines from TargetConditionals.h are a bit weird. Seems like TARGET\_OS\_MAC is always defined (on all platforms). To determine if we are running on OSX, we can only rely on TARGET\_OS\_IPHONE=0 and all the other platforms.

用于判断当前平台是不是 MAC。因为 TARGET\_OS\_MAC 在 TargetConditionals.h 文件中总是被定义，所以单纯使用 TARGET\_OS\_MAC 是不靠谱的，那么可以根据举反的方式来判断。当然这样判断的缺点是：当 Apple 出现新的平台时，判断条件要修改。

#if TARGET\_OS\_IOS || TARGET\_OS\_TV

#define SD_UIKIT 1   

#else

#define SD_UIKIT 0

#endif

iOS and tvOS are very similar, UIKit exists on both platforms. Note: watchOS also has UIKit, but it's very limited.

用于判断当前平台是不是 iOS 和 tvOS。iOS 和 tvOS 平台非常相似，这两个平台中都存在 UIKit，watchOS 也有 UIKit，但是使用是受限的。

#if TARGET\_OS\_IOS

#define SD_IOS 1

#else

#define SD_IOS 0

#endif

#if TARGET\_OS\_TV

#define SD_TV 1

#else

#define SD_TV 0

#endif

#if TARGET\_OS\_WATCH

#define SD_WATCH 1

#else

#define SD_WATCH 0

#endif

用于判断当前平台是不是 iOS/tvOS/watchOS 平台。

#if SD_MAC

#import <AppKit/AppKit.h>

#ifndef UIImage

#define UIImage NSImage      // mac 平台下UIImage -> NSImage

#endif

#ifndef UIImageView

#define UIImageView NSImageView  // mac 平台下UIImageView -> NSImageView

#endif

#ifndef UIView

#define UIView NSView   // mac 平台下UIView -> NSView

#endif

#else

#if \_\_IPHONE\_OS\_VERSION\_MIN\_REQUIRED !=20000 && \_\_IPHONE\_OS\_VERSION\_MIN\_REQUIRED < \_\_IPHONE\_5_0       // SDWebImage 不支持5.0 以下的iOS 版本

#error SDWebImage doesn't support Deployment Target version < 5.0

#endif

#if SD_UIKIT

#import <UIKit/UIKit.h>

#endif

#if SD_WATCH

#import <WatchKit/WatchKit.h>

#endif

#endif

#ifndef NS_ENUM

#define NS\_ENUM(\_type, \_name) enum \_name : \_type \_name; enum \_name : \_type

#endif

#ifndef NS_OPTIONS

#define NS\_OPTIONS(\_type, \_name) enum \_name : \_type \_name; enum \_name : \_type

#endif

实际上是将 enum 定义和typedef 合二为一，并且采用不同的宏来从代码角度来区分。NS_OPTIONS 一般用来定义位移相关操作的枚举值。

这两个宏的定义在 Foundation.framework 的NSObjCRuntime.h 中：

#if (\_\_cplusplus && \_\_cplusplus >= 201103L && (\_\_has\_extension(cxx\_strong\_enums) || \_\_has\_feature(objc\_fixed\_enum))) || (!\_\_cplusplus && \_\_has\_feature(objc\_fixed_enum))

#define NS\_ENUM(\_type, \_name) enum \_name : \_type \_name; enum \_name : \_type

#if (__cplusplus)

#define NS\_OPTIONS(\_type, \_name) \_type \_name; enum : \_type

#else

#define NS\_OPTIONS(\_type, \_name) enum \_name : \_type \_name; enum \_name : \_type

#endif

#else

#define NS\_ENUM(\_type, \_name) \_type _name; enum

#define NS\_OPTIONS(\_type, \_name) \_type _name; enum

#endif

将 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {   展开得到： 

1.   typedef enum UIViewAnimationTransition : NSInteger UIViewAnimationTransition;  
2.   enum UIViewAnimationTransition : NSInteger {

从枚举定义来看，NS_ENUM 和 NS_OPTIONS 本质是一样的，仅仅从字面上来区分其用途。NS_ENUM 是通用情况，NS_OPTIONS 一般用来定义具有位移操作或特点的情况(bitmask)。

#ifndef dispatch\_queue\_async_safe

#define dispatch\_queue\_async_safe(queue, block)\

if ( strcmp(dispatch\_queue\_get\_label(DISPATCH\_CURRENT\_QUEUE\_LABEL), dispatch\_queue\_get_label(queue)) == 0) {\

block();\

}\

else {\

dispatch_async(queue, block);\

}

#endif

#ifndef dispatch\_main\_async_safe

#define dispatch\_main\_async_safe(block) dispatch\_queue\_async\_safe(dispatch\_get\_main\_queue(), block)

#endif

按理说使用 dispatch\_main\_async 就可以了，为什么要加入 safe 呢？

*    可以像这样在定义宏的时候使用换行，但需要添加 \ 操作符
*    如果当前线程已经是主线程了，那么在调用 dispatch\_async(dispatch\_get\_main\_queue(), block) 有可能会出现 crash
*    如果当前线程是主线程，直接调用；如果不是则调用 dispatch\_async(dispatch\_get\_main\_queue(), block)

#if !\_\_has\_feature(objc_arc)

#error SDWebImage is ARC only. Either turn on ARC for the project or use -fobjc-arc flag

#endif

用于判断当前是 MRC 环境。SDWebImage 只能在 ARC 环境中使用。

#if !OS\_OBJECT\_USE_OBJC

#error SDWebImage need ARC for dispatch object

#endif

首先看下 OS\_OBJECT\_USE_OBJC 宏定义常见用处：

#if OS\_OBJECT\_USE_OBJC

@property (strong, nonatomic) dispatch\_queue\_t barrierQueue;  
#else  
@property (assign, nonatomic) dispatch\_queue\_t barrierQueue;  
#endif

这段代码表示 GCD 中的对象在 6.0 之前是[不参与ARC](http://stackoverflow.com/questions/12730202/do-you-need-to-release-gcd-queues-under-arc-in-ios-6-0)的，6.0 之后在 ARC 模式下使用 GCD 也不用关心释放问题。

6.0 版本之前，在 dealloc 方法中应该加上：

#if !OS\_OBJECT\_USE_OBJC   // 在 sdk6.0 之前OS\_OBJECT\_USE_OBJC 为0  
    dispatch\_release(\_barrierQueue);  
#endif

当然了，也可以使用：

#if \_\_IPHONE\_OS\_VERSION\_MIN_REQUIRED < 60000   // sdk6.0 之前

dispatch\_release(\_barrierQueue);

#endif

这里的宏 \_\_IPHONE\_OS\_VERSION\_MIN_REQUIRED 就是工程的设置项里设置的最低部署 sdk 版本。

在 sdk < 6.0 的时候,即使我们开启了 ARC，这个宏 OS\_OBJECT\_USE_OBJC 也是没有的，也就是说这个时候，GCD 对象还必须得自己管理。

inline UIImage * SDScaledImageForKey(NSString * \_Nullable key, UIImage * \_Nullable image) {

...

#if SD_MAC

...

#elif SD\_UIKIT || SD\_WATCH

if ((image.images).count > 0) {

...

// 循环递归添加图片

for (UIImage * tempImage in image.images) {

\[scaledImages addObject:SDScaledImageForKey(key, tempImage)\];

}

// animatedImage 方法将多张图片创建成UIImage

UIImage * animatedImage = \[UIImage animatedImageWithImages:scaledImages

 duration:image.duration\];

...

return animatedImage;

}

else {

#if SD_WATCH

...

#elif SD_UIKIT

if (\[\[UIScreen mainScreen\] respondsToSelector:@selector(scale)\]) {

#endif

CGFloat scale = 1;

if (key.length >= 8) {

NSRange range = \[key rangeOfString:@"@2x."\];

if (range.location != NSNotFound) {

scale = 2.0;

}

range = \[key rangeOfString:@"@3x."\];

if (range.location != NSNotFound) {

scale = 3.0;

}

}

UIImage * scaledImage = \[\[UIImage alloc\] initWithCGImage:image.CGImage

  scale:scale

orientation:image.imageOrientation\]; 

image = scaledImage;

}

return image;

}

#endif

}

根据 key 来修改图片的尺寸。scale = 2 即为缩小一倍。