---
title: 深拷贝和浅拷贝
categories: iOS
---

深拷贝和浅拷贝的<font color=#cc0000>本质区别是地址是否相同</font>。

*   浅拷贝并没有进行真正的复制，而是复制的对象和原对象都指向同一个地址；
*   深拷贝是真正的复制了一份，复制的对象指向了新的地址。

## 一、非容器类对象

对象的 copy 是浅拷贝，mutableCopy 是深拷贝。

1、不可变

```
NSString * s1 = @"AAA";
NSString * s2 = [s1 copy];
NSString * s3 = [s1 mutableCopy];
    
NSLog(@"%p   %@", s1, s1.class);
NSLog(@"%p   %@", s2, s2.class);
NSLog(@"%p   %@", s3, s3.class);
0x1083a40e8   __NSCFConstantString
0x1083a40e8   __NSCFConstantString
0x60400044f840   __NSCFString
```

结论：

①、非容器不可变对象执行 copy 为浅拷贝，mutableCopy 为深拷贝；

②、浅拷贝返回不可变对象，深拷贝返回可变对象。

2、可变

```
NSMutableString * ms1 = [NSMutableString stringWithString:@"1"];
NSMutableString * ms2 = [ms1 copy];
NSString * ms3 = [ms1 mutableCopy];
    
NSLog(@"%p   %@", ms1, ms1.class);
NSLog(@"%p   %@", ms2, ms2.class);
NSLog(@"%p   %@", ms3, ms3.class);
0x6040004500b0   __NSCFString
0xa000000000000311   NSTaggedPointerString
0x60400044fc60   __NSCFString
```

结论：

①、对于非容器可变对象的 copy、mutableCopy 都是深拷贝；

②、copy 和 mutableCopy 返回对象都为可变对象。

## 二、容器对象

1、不可变

```
NSMutableString * ms = [NSMutableString stringWithString:@"1"];
NSArray * arr1 = [NSArray arrayWithObjects:ms, @"2", nil];
NSArray * arr2 = [arr1 copy];
NSArray * arr3 = [arr1 mutableCopy];
    
NSLog(@"%p  %@  %p  %@  %p  %@", arr1, arr1.class, arr1[0], [arr1[0] class], arr1[1], [arr1[1] class]);
NSLog(@"%p  %@  %p  %@  %p  %@", arr2, arr2.class, arr2[0], [arr2[0] class], arr2[1], [arr2[1] class]);
NSLog(@"%p  %@  %p  %@  %p  %@", arr3, arr3.class, arr3[0], [arr3[0] class], arr3[1], [arr3[1] class]);
    
0x600000037620  __NSArrayI  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
0x600000037620  __NSArrayI  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
0x60000025a940  __NSArrayM  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
```

结论：

①、外层容器和非容器类对象的表现一致：copy 为浅拷贝，mutableCopy 为深拷贝；

②、浅拷贝返回不可变对象，深拷贝返回可变对象。

③、容器内的元素始终都是浅拷贝。

2、可变

```
NSMutableString * ms = [NSMutableString stringWithString:@"1"];
NSMutableArray * mArr1 = [NSMutableArray arrayWithObjects:ms, @"2", nil];
NSMutableArray * mArr2 = [mArr1 copy];
NSMutableArray * mArr3 = [mArr1 mutableCopy];
    
NSLog(@"%p  %@  %p  %@  %p  %@", mArr1, mArr1.class, mArr1[0], [mArr1[0] class], mArr1[1], [mArr1[1] class]);
NSLog(@"%p  %@  %p  %@  %p  %@", mArr2, mArr2.class, mArr2[0], [mArr2[0] class], mArr2[1], [mArr2[1] class]);
NSLog(@"%p  %@  %p  %@  %p  %@", mArr3, mArr3.class, mArr3[0], [mArr3[0] class], mArr3[1], [mArr3[1] class]);
0x60000025aeb0  __NSArrayM  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
0x600000037640  __NSArrayI  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
0x60000025ae80  __NSArrayM  0x60000025ab80  __NSCFString  0x1032b2148  __NSCFConstantString
```

结论：

①、外层容器和非容器类可变对象的表现一致：copy、mutableCopy 都是深拷贝；
②、copy 返回不可变对象，mutableCopy 返回可变对象；
③、容器内的元素始终是浅拷贝。

## 三、自定义类对象的深浅拷贝

自定义的类需要遵循 <NSCopying> 才支持 copy，遵循 <NSMutableCopying> 支持 mutableCopy。

```
@interface Person : NSObject <NSCopying, NSMutableCopying>
@end
@implementation Person
- (instancetype)copyWithZone:(NSZone *)zone
{
    return  [Person allocWithZone:zone];   // return self;
}
- (instancetype)mutableCopyWithZone:(NSZone *)zone
{    
    return  [Person allocWithZone:zone];
}
@end
Person * p1 = [[Person alloc] init];
Person * p2 = [p1 copy];
Person * p3 = [p1 mutableCopy];
    
NSLog(@"%p   %@", p1, p1.class);
NSLog(@"%p   %@", p2, p2.class);
NSLog(@"%p   %@", p3, p3.class);
0x600000011e30   Person
0x600000011f70   Person
0x600000011f90   Person
```

## 四、实现容器对象的完全拷贝

```
NSMutableString * ms = [NSMutableString stringWithFormat:@"1"];
NSArray * arr = [NSArray arrayWithObjects:ms, @"2", nil];
NSLog(@"%p  %p", arr[0], arr[1]);
NSMutableArray * mArr = [[NSMutableArray alloc] initWithArray:arr copyItems:YES];
NSLog(@"%p  %p", mArr[0], mArr[1]);
NSData * data = [NSKeyedArchiver archivedDataWithRootObject:mArr];
NSMutableArray * newMutableArr = [NSKeyedUnarchiver unarchiveObjectWithData:data];
NSLog(@"%p  %p", newMutableArr[0], newMutableArr[1]);
0x6040004434b0  0x109c93100
0xa000000000000311  0x109c93100
0xa000000000000311  0xa000000000000321
```

由上可以看到：copyItem 对元素内容执行了 copy 操作；归档解档时对于 NSMutableString 没有进行深拷贝。

> 自定义类对象需要遵循 <NSCoding> 才能归档解档，否则在使用 NSKeyedArchiver 的时候会 Crash。

```
- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self.xxx = [aDecoder decodeObjectForKey:@"key"];
    return self;
}
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.xxx forKey:@"key"];
}
```

## 五、总结

只有对不可变对象进行 copy 操作是指针复制（浅拷贝），其他情况都是内容复制（深拷贝）。

## 六、学习文章

[深刻理解iOS中的“深拷贝”和“浅拷贝”](https://www.jianshu.com/p/33f175d97b86)
