---
title: 【GLSL】七、逐像素的光照
categories: OpenGL
---

原文：http://www.cnblogs.com/mazhenyu/p/5580965.html 

**一、逐像素的方向光（Directional Light per Pixel）**这一节将把前面的 shader 代码改为逐像素计算的方向光。我们需要将工作按照两个 shader 拆分，以确定哪些是需要逐像素操作的。 首先看看每个顶点接收到的信息：•     法线  
•     半向量  
•     光源方向 我们需要将法线变换到视点空间然后归一化。我们还需要将半向量和光源方向也归一化，不过它们已经位于视点空间中了。这些归一化之后的向量会进行插值，然后送入片断 shader，所以需要声明易变变量保存这些向量。 我们也可以在顶点 shader 中完成一些与光和材质相关的计算，这样可以帮助平衡顶点 shader 和片断 shader 的负载。 

顶点 shader 代码可以写成如下形式：

1.   varying vec4 diffuse, ambient;  
2.   varying vec3 normal, lightDir, halfVector;

4.   void main()
5.   {  
6.       /* first transform the normal into eye space and normalize the result */  
7.       normal = normalize(gl\_NormalMatrix * gl\_Normal);  
8.       /* now normalize the light's direction. Note that according to the OpenGL 
9.          specification, the light is stored in eye space. Also since we're talking
10.          about a directional light, the position field is actually direction */
11.       lightDir = normalize(vec3(gl_LightSource\[0\].position));  
12.       /* Normalize the halfVector to pass it to the fragment shader */  
13.       halfVector = normalize(gl_LightSource\[0\].halfVector.xyz);  
14.       /* Compute the diffuse, ambient and globalAmbient terms */
15.       diffuse = gl\_FrontMaterial.diffuse * gl\_LightSource\[0\].diffuse;  
16.       ambient = gl\_FrontMaterial.ambient * gl\_LightSource\[0\].ambient;  
17.       ambient += gl\_FrontMaterial.ambient * gl\_LightModel.ambient;  

19.       gl_Position = ftransform();  
20.   }  

 

接下来在片断 shader 中，首先要声明同样的易变变量。此外还要再次对法线进行归一化，光线向量不需要进行归一化了，因为方向光对所有顶点都是一致的，插值得到的结果自然也不会变。之后就是计算插值过的法线向量与光线向量的点积。

1.   varying vec4 diffuse,ambient;  
2.   varying vec3 normal,lightDir,halfVector;  

4.   void main()  
5.   {  
6.       vec3 n,halfV;  
7.       float NdotL,NdotHV;  
8.       /* The ambient term will always be present */  
9.       vec4 color = ambient;  
10.       /* a fragment shader can't write a varying variable, hence we need a new 
11.          variable to store the normalized interpolated normal */  
12.       n = normalize(normal);  
13.       /* compute the dot product between normal and ldir */  
14.       NdotL = max(dot(n,lightDir),0.0);  
15.       ...  
16.   }

 

如果点积结果 NdotL 大于 0，我们就必须计算散射光，也就是用顶点 shader 传过来的散射项乘以这个点积。我们还需要计算镜面反射光，计算时首先对接收到的半向量归一化，然后计算半向量和法线之间的点积。

1.   ...  
2.   if (NdotL > 0.0)  
3.   {  
4.       color += diffuse * NdotL;  
5.       halfV = normalize(halfVector);  
6.       NdotHV = max(dot(n, halfV), 0.0);  
7.       color += gl\_FrontMaterial.specular * gl\_LightSource\[0\].specular *  
8.              pow(NdotHV, gl_FrontMaterial.shininess);  
9.   }  

11.   gl_FragColor = color;  

下图显示了逐像素光照和逐顶点光照效果的区别：![](http://hi.csdn.net/attachment/201108/5/0_1312515143xIk5.gif)本节内容的工程下载地址：[http://www.lighthouse3d.com/wp-content/uploads/2011/03/dirpixsd.zip](http://www.lighthouse3d.com/wp-content/uploads/2011/03/dirpixsd.zip) **二、逐像素的点光（Point Light Per Pixel）**本节基于前面有关方向光的内容，大部分代码都相同。本节内容主要涉及方向光和点光的不同之处。方向光一般假设光源在无限远的地方，所以到达物体时是平行光。相反，点光源有一个空间中的位置，并向四面八方辐射光线。此外，点光的强度会随到达顶点的距离而衰弱。 对于 OpenGL 程序来说，这两种光的区别主要有：•      光源的 position 域的 w 分量：对方向光来说它是 0，表面这个 position 实际是一个方向(direction)；对点光来说，这个分量是 1。  
•      点光源的衰减由三个系数决定：一个常数项，一个线性项和一个二次项。 对方向光来说，光线的方向对所有顶点相同，但是对点光来说，方向是从顶点指向光源位置的向量。因此对我们来说需要修改的就是在顶点 shader 中加入计算光线方向的内容。 在 OpenGL 中衰减是按照如下公式计算的：![](http://hi.csdn.net/attachment/201108/5/0_1312515158f7FZ.gif) 式中 k0 是常数衰减系数，k1 是线性衰减系数，k2 是二次衰减系数，d 是光源位置到顶点的距离。 注意衰减与距离是非线性关系，所以我们不能逐顶点计算衰减再在片断 shader 中使用插值结果，不过我们可以在顶点 shader 中计算距离，然后在片断 shader 中使用距离的插值计算衰减。 使用点光计算颜色值的公式为：![](http://hi.csdn.net/attachment/201108/5/0_1312515172d7xr.gif) 

在上面公式中，环境光部分必须分解为两项：使用光照模型的全局环境光设置和光源中的环境光设置。顶点 shader 也必须分别计算这两个环境光成分。新的顶点 shader 如下：

1.   varying vec4 diffuse, ambientGlobal, ambient;  
2.   varying vec3 normal, lightDir, halfVector;  
3.   varying float dist;  

5.   void main()  
6.   {  
7.       vec4 ecPos;  
8.       vec3 aux;  
9.       normal = normalize(gl\_NormalMatrix * gl\_Normal);  

11.       /* these are the new lines of code to compute the light's direction */  
12.       ecPos = gl\_ModelViewMatrix * gl\_Vertex;  
13.       aux = vec3(gl_LightSource\[0\].position - ecPos);  
14.       lightDir = normalize(aux);  
15.       dist = length(aux);  
16.       halfVector = normalize(gl_LightSource\[0\].halfVector.xyz);  

18.       /* Compute the diffuse, ambient and globalAmbient terms */  
19.       diffuse = gl\_FrontMaterial.diffuse * gl\_LightSource\[0\].diffuse;  
20.       /* The ambient terms have been separated since one of them */  
21.       /* suffers attenuation */  
22.       ambient = gl\_FrontMaterial.ambient * gl\_LightSource\[0\].ambient;  
23.       ambientGlobal = gl\_FrontMaterial.ambient * gl\_LightModel.ambient;  
24.       gl_Position = ftransform();  
25.   }  

在片断 shader 中需要计算衰减，还需要将插值得到的光线方向向量归一化，因为一般来说照到每个顶点的光线方向都不同。

1.   varying vec4 diffuse, ambientGlobal, ambient;  
2.   varying vec3 normal, lightDir, halfVector;  
3.   varying float dist;  

5.   void main()  
6.   {  
7.       vec3 n, halfV, viewV, ldir;  
8.       float NdotL, NdotHV;  
9.       vec4 color = ambientGlobal;  
10.       float att;  
11.       /* a fragment shader can't write a varying variable, hence we need a new
12.       variable to store the normalized interpolated normal */  
13.       n = normalize(normal);  
14.       /* compute the dot product between normal and normalized lightdir */  
15.       NdotL = max(dot(n,normalize(lightDir)), 0.0);  

17.       if (NdotL > 0.0) {

19.           att = 1.0 / (gl_LightSource\[0\].constantAttenuation +  
20.                  gl_LightSource\[0\].linearAttenuation * dist +  
21.                  gl_LightSource\[0\].quadraticAttenuation * dist * dist);  
22.           color += att * (diffuse * NdotL + ambient);  
23.           halfV = normalize(halfVector);  
24.           NdotHV = max(dot(n, halfV), 0.0);  
25.           color += att * gl\_FrontMaterial.specular * gl\_LightSource\[0\].specular *  
26.                           pow(NdotHV,gl_FrontMaterial.shininess);  
27.       }  
28.       gl_FragColor = color;  
29.   }  

下图显示了固定功能的逐顶点与本节中逐像素计算得到的点光效果：![](http://hi.csdn.net/attachment/201108/5/0_131251522718NV.gif)

本节内容的工程下载地址：[http://www.lighthouse3d.com/wp-content/uploads/2011/03/pointlightsd.zip](http://www.lighthouse3d.com/wp-content/uploads/2011/03/pointlightsd.zip)

**三、逐像素的聚光（Spot Light Per Pixel）**本节内容与上一节基本一致，唯一不同的就是聚光不同于点光，其发出的光线被限制在一个圆锥体中。  
对于 OpenGL 程序来说，这两种光的区别主要有：•      聚光包含一个方向向量 spotDirection，表示圆锥体的轴。  
•      圆锥体包含一个角度，在 GLSL 中可以使用应用程序设置的角度值以及对应的余弦值spotCosCutoff。  
•      最后还有一个衰减速率 spotExponent，它表示从圆锥的中心轴向外表面变化时光强度的衰减。 聚光的顶点 shader 与点光完全相同，我们只需要对片断 shader 进行一些修改。只有当当前片断位于聚光的光锥内时，才需要对散射光、镜面反射光和环境光成分进行着色。所以我们首先要检查这个条件。 

光源与某点连线向量以及聚光方向向量(spotDirection)之间夹角的余弦值必须大于 spotCosCutoff，否则此点位于聚光之外，只能接收到全局环境光。

1.   ...  

3.   n = normalize(normal);  

5.   /* compute the dot product between normal and ldir */  
6.   NdotL = max(dot(n, normalize(lightDir)), 0.0);  

8.   if (NdotL > 0.0) {

10.       spotEffect = dot(normalize(gl_LightSource\[0\].spotDirection),   
11.              normalize(-lightDir));  
12.       if (spotEffect > gl_LightSource\[0\].spotCosCutoff) {  
13.           /* compute the illumination in here */  
14.       }  
15.   }  

17.   gl_FragColor = ...  

下面的光照计算与点光非常相似，唯一区别是衰减必须乘以聚光效果(spotlight effect)，这个值按如下公式计算： 

![](http://hi.csdn.net/attachment/201108/5/0_13125152549HSC.gif)

上式中 spotDirection 来自 OpenGL 中设置的状态，lightDir 是光源到某点的向量，spotExp 是聚光衰减率，这个值也是在 OpenGL 程序中设置的，它用来控制从聚光光锥中心到边缘的衰减。spotExp 越大衰减越快，如果为 0 表示在光锥内光强是常数。

1.   spotEffect = pow(spotEffect, gl_LightSource\[0\].spotExponent);  
2.   att = spotEffect / (gl_LightSource\[0\].constantAttenuation +  
3.           gl_LightSource\[0\].linearAttenuation * dist +  
4.           gl_LightSource\[0\].quadraticAttenuation * dist * dist);  

6.   color += att * (diffuse * NdotL + ambient);  

8.   halfV = normalize(halfVector);  
9.   NdotHV = max(dot(n, halfV), 0.0);  
10.   color += att * gl\_FrontMaterial.specular * gl\_LightSource\[0\].specular *
11.              pow(NdotHV, gl_FrontMaterial.shininess);  

 下图分别显示了使用固定功能流水线的逐顶点光照计算，以及使用本节 shader 的逐像素光照计算得到的聚光效果。![](http://hi.csdn.net/attachment/201108/5/0_1312515294z6I2.gif)本节内容的工程下载地址：[http://www.lighthouse3d.com/wp-content/uploads/2011/03/spotlightsd.zip](http://www.lighthouse3d.com/wp-content/uploads/2011/03/spotlightsd.zip)