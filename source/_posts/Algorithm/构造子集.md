---
title: 构造子集
categories: algorithm
---

## 1、问题描述

构造出 0~n-1 的所有子集。

## 2、算法分析

一次选出一个元素放入集合。

## 3、代码实现

```c
#define ARRAY_LENGTH  10

{ 
    int A[ARRAY_LENGTH];
    print_subset(ARRAY_LENGTH, A, 0);
}


void print_subset(int n, int* A, int cur)
{
    // cur:当前位置
    printf("cur = %d      ", cur);

    // 确定当前元素的最小可能值
    int s = cur ? A[cur-1] + 1 : 0;  
    
    printf("s = %d     ", s); 

    // 打印当前子集元素。
    for(int i = 0; i < cur; i++) {  
        printf("%d ", A[i]);
    }
       
    // 每次选出一个元素当子集的首元素,
    for(int i = s; i < n; i++) {
        A[cur] = i;

        // 打印加入元素后的数组
        printf("       after：");
        for(int j = 0; j <= cur; j++) {
            printf("%d ", A[j]);
        }
        printf("\n");

        print_subset(n, A, cur + 1); // 递归构造子集
    }
}

cur = 0      s = 0                  after：0 
cur = 1      s = 1     0            after：0 1 
cur = 2      s = 2     0 1          after：0 1 2 
cur = 3      s = 3     0 1 2        after：0 1 2 3 
cur = 4      s = 4     0 1 2 3      after：0 1 3 
cur = 3      s = 4     0 1 3        after：0 2 
cur = 2      s = 3     0 2          after：0 2 3 
cur = 3      s = 4     0 2 3        after：0 3 
cur = 2      s = 4     0 3          after：1 
cur = 1      s = 2     1            after：1 2 
cur = 2      s = 3     1 2          after：1 2 3 
cur = 3      s = 4     1 2 3        after：1 3 
cur = 2      s = 4     1 3          after：2 
cur = 1      s = 3     2            after：2 3 
cur = 2      s = 4     2 3          after：3 
cur = 1      s = 4     3 
```

<center>
![](https://upload-images.jianshu.io/upload_images/5294842-8e32679a27ba0063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</center>